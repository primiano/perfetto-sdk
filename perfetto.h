// Copyright (C) 2019 The Android Open Source Project
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// This file is automatically generated by gen_amalgamated. Do not edit.

// gen_amalgamated begin header: include/perfetto/tracing.h
// gen_amalgamated begin header: /Users/primiano/code/perfetto/tools/../include/perfetto/tracing/buffer_exhausted_policy.h
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_TRACING_BUFFER_EXHAUSTED_POLICY_H_
#define INCLUDE_PERFETTO_TRACING_BUFFER_EXHAUSTED_POLICY_H_

namespace perfetto {

// Determines how SharedMemoryArbiterImpl::GetNewChunk() behaves when no free
// chunks are available.
enum class BufferExhaustedPolicy {
  // SharedMemoryArbiterImpl::GetNewChunk() will stall if no free SMB chunk is
  // available and wait for the tracing service to free one. Note that this
  // requires that messages the arbiter sends to the tracing service (from any
  // TraceWriter thread) will be received by it, even if all TraceWriter threads
  // are stalled.
  kStall,

  // SharedMemoryArbiterImpl::GetNewChunk() will return an invalid chunk if no
  // free SMB chunk is available. In this case, the TraceWriter will fall back
  // to a garbage chunk and drop written data until acquiring a future chunk
  // succeeds again.
  kDrop,

  // TODO(eseckler): Switch to kDrop by default and change the Android code to
  // explicitly request kStall instead.
  kDefault = kStall
};

}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_TRACING_BUFFER_EXHAUSTED_POLICY_H_
// gen_amalgamated begin header: /Users/primiano/code/perfetto/tools/../include/perfetto/tracing/core/data_source_config.h
// gen_amalgamated begin header: /Users/primiano/code/perfetto/tools/../include/perfetto/tracing/core/forward_decls.h
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_TRACING_CORE_FORWARD_DECLS_H_
#define INCLUDE_PERFETTO_TRACING_CORE_FORWARD_DECLS_H_

// Forward declares classes that are generated at build-time from protos.
// First of all, why are we forward declaring at all?
//  1. Chromium diverges from the Google style guide on this, because forward
//     declarations typically make build times faster, and that's a desirable
//     property for a large and complex codebase.
//  2. Adding #include to build-time-generated headers from headers typically
//     creates subtle build errors that are hard to spot in GN. This is because
//     once a standard header (say foo.h) has an #include "protos/foo.gen.h",
//     the build target that depends on foo.h needs to depend on the genrule
//     that generates foo.gen.h. This is achievable using public_deps in GN but
//     is not testable / enforceable, hence too easy to get wrong.

// Historically the classes below used to be generated from the corresponding
// .proto(s) at CL *check-in* time (!= build time) in the ::perfetto namespace.
// Nowadays we have code everywhere that assume the right class is
// ::perfetto::TraceConfig or the like. Back then other headers could just
// forward declared ::perfetto::TraceConfig. These days, the real class is
// ::perfetto::protos::gen::TraceConfig and core/trace_config.h aliases that as
// using ::perfetto::TraceConfig = ::perfetto::protos::gen::TraceConfig.
// In C++ one cannot forward declare a type alias (but only the aliased type).
// Hence this header, which should be used every time one wants to forward
// declare classes like TraceConfig.

// The overall plan is that, when one of the classes below is needed:
// The .h file includes this file.
// The .cc file includes perfetto/tracing/core/trace_config.h (or equiv). That
// header will pull the full declaration from trace_config.gen.h and will also
// setup the alias in the ::perfetto namespace.

namespace perfetto {
namespace protos {
namespace gen {

class ChromeConfig;
class CommitDataRequest;
class DataSourceConfig;
class DataSourceDescriptor;
class ObservableEvents;
class TraceConfig;
class TraceStats;
class TracingServiceState;

}  // namespace gen
}  // namespace protos

using ChromeConfig = ::perfetto::protos::gen::ChromeConfig;
using CommitDataRequest = ::perfetto::protos::gen::CommitDataRequest;
using DataSourceConfig = ::perfetto::protos::gen::DataSourceConfig;
using DataSourceDescriptor = ::perfetto::protos::gen::DataSourceDescriptor;
using ObservableEvents = ::perfetto::protos::gen::ObservableEvents;
using TraceConfig = ::perfetto::protos::gen::TraceConfig;
using TraceStats = ::perfetto::protos::gen::TraceStats;
using TracingServiceState = ::perfetto::protos::gen::TracingServiceState;

}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_TRACING_CORE_FORWARD_DECLS_H_
// gen_amalgamated begin header: /Users/primiano/code/perfetto/tools/../out/tmp.gen_amalgamated.16011/gen/protos/perfetto/config/data_source_config.gen.h
// gen_amalgamated begin header: /Users/primiano/code/perfetto/tools/../include/perfetto/protozero/cpp_message_obj.h
// gen_amalgamated begin header: /Users/primiano/code/perfetto/tools/../include/perfetto/base/export.h
// gen_amalgamated begin header: /Users/primiano/code/perfetto/tools/../include/perfetto/base/build_config.h
// gen_amalgamated begin header: /Users/primiano/code/perfetto/tools/../out/tmp.gen_amalgamated.16011/gen/build_config/perfetto_build_flags.h
// Generated by ../../gn/write_buildflag_header.py

// fix_include_guards: off
#ifndef GEN_BUILD_CONFIG_PERFETTO_BUILD_FLAGS_H_
#define GEN_BUILD_CONFIG_PERFETTO_BUILD_FLAGS_H_

// clang-format off
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_ANDROID_BUILD() (0)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_CHROMIUM_BUILD() (0)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_STANDALONE_BUILD() (0)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_START_DAEMONS() (1)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_IPC() (1)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_WATCHDOG() (0)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_COMPONENT_BUILD() (0)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_FORCE_DLOG_ON() (0)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_FORCE_DLOG_OFF() (0)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_VERSION_GEN() (0)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_TP_SQLITE() (1)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_TP_PERCENTILE() (0)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_TP_LINENOISE() (0)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_TP_METRICS() (1)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_TP_FTRACE() (1)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_TP_HTTPD() (0)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_TP_SYSTEM_PROBES() (1)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_TP_ANDROID_PROBES() (1)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_TP_HEAP_GRAPHS() (1)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_TP_GRAPHICS() (1)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_TP_JSON() (1)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_TP_JSON_IMPORT() (1)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_TP_FUCHSIA() (1)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_TP_SYSCALLS() (1)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_LOCAL_SYMBOLIZER() (0)

// clang-format on
#endif  // GEN_BUILD_CONFIG_PERFETTO_BUILD_FLAGS_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_BASE_BUILD_CONFIG_H_
#define INCLUDE_PERFETTO_BASE_BUILD_CONFIG_H_

// Allows to define build flags that give a compiler error if the header that
// defined the flag is not included, instead of silently ignoring the #if block.
#define PERFETTO_BUILDFLAG_CAT_INDIRECT(a, b) a##b
#define PERFETTO_BUILDFLAG_CAT(a, b) PERFETTO_BUILDFLAG_CAT_INDIRECT(a, b)
#define PERFETTO_BUILDFLAG(flag) \
  (PERFETTO_BUILDFLAG_CAT(PERFETTO_BUILDFLAG_DEFINE_, flag)())

#if defined(__ANDROID__)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_ANDROID() 1
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_MACOSX() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_LINUX() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WIN() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WASM() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_FUCHSIA() 0
#elif defined(__APPLE__)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_ANDROID() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_MACOSX() 1
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_LINUX() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WIN() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WASM() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_FUCHSIA() 0
#elif defined(__linux__)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_ANDROID() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_MACOSX() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_LINUX() 1
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WIN() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WASM() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_FUCHSIA() 0
#elif defined(_WIN32)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_ANDROID() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_MACOSX() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_LINUX() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WIN() 1
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WASM() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_FUCHSIA() 0
#elif defined(__EMSCRIPTEN__)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_ANDROID() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_MACOSX() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_LINUX() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WIN() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WASM() 1
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_FUCHSIA() 0
#elif defined(__Fuchsia__)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_ANDROID() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_MACOSX() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_LINUX() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WIN() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WASM() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_FUCHSIA() 1
#else
#error OS not supported (see build_config.h)
#endif

#if defined(__clang__)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_COMPILER_CLANG() 1
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_COMPILER_GCC() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_COMPILER_MSVC() 0
#elif defined(__GNUC__) // Careful: Clang also defines this!
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_COMPILER_CLANG() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_COMPILER_GCC() 1
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_COMPILER_MSVC() 0
#elif defined(_MSC_VER)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_COMPILER_CLANG() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_COMPILER_GCC() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_COMPILER_MSVC() 1
#else
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_COMPILER_CLANG() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_COMPILER_GCC() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_COMPILER_MSVC() 0
#endif

#if defined(PERFETTO_BUILD_WITH_ANDROID_USERDEBUG)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_ANDROID_USERDEBUG_BUILD() 1
#else
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_ANDROID_USERDEBUG_BUILD() 0
#endif

// perfetto_build_flags.h contains the tweakable build flags defined via GN.
// - In GN builds (e.g., standalone, chromium, v8) this file is generated at
//   build time via the gen_rule //gn/gen_buildflags.
// - In Android in-tree builds, this file is generated by tools/gen_android_bp
//   and checked in into include/perfetto/base/build_configs/android_tree/. The
//   default cflags add this path to the default include path.
// - Similarly, in bazel builds, this file is generated by tools/gen_bazel and
//   checked in into include/perfetto/base/build_configs/bazel/.
// - In amaglamated builds, this file is generated by tools/gen_amalgamated and
//   added to the amalgamated headers.
// gen_amalgamated expanded: #include "perfetto_build_flags.h"  // no-include-violation-check

#endif  // INCLUDE_PERFETTO_BASE_BUILD_CONFIG_H_
/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_BASE_EXPORT_H_
#define INCLUDE_PERFETTO_BASE_EXPORT_H_

// gen_amalgamated expanded: #include "perfetto/base/build_config.h"

#if PERFETTO_BUILDFLAG(PERFETTO_COMPONENT_BUILD)

#if PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)

#if defined(PERFETTO_IMPLEMENTATION)
#define PERFETTO_EXPORT __declspec(dllexport)
#else
#define PERFETTO_EXPORT __declspec(dllimport)
#endif

#else  // PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)

#if defined(PERFETTO_IMPLEMENTATION)
#define PERFETTO_EXPORT __attribute__((visibility("default")))
#else
#define PERFETTO_EXPORT
#endif

#endif  // PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)

#else  // !PERFETTO_BUILDFLAG(PERFETTO_COMPONENT_BUILD)

#define PERFETTO_EXPORT

#endif  // PERFETTO_BUILDFLAG(PERFETTO_COMPONENT_BUILD)

#endif  // INCLUDE_PERFETTO_BASE_EXPORT_H_
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_PROTOZERO_CPP_MESSAGE_OBJ_H_
#define INCLUDE_PERFETTO_PROTOZERO_CPP_MESSAGE_OBJ_H_

#include <stdint.h>

#include <string>
#include <vector>

// gen_amalgamated expanded: #include "perfetto/base/export.h"

namespace protozero {

// Base class for generated .gen.h classes, which are full C++ objects that
// support both ser and deserialization (but are not zero-copy).
// This is only used by the "cpp" targets not the "pbzero" ones.
class PERFETTO_EXPORT CppMessageObj {
 public:
  virtual ~CppMessageObj();
  virtual std::string SerializeAsString() const = 0;
  virtual std::vector<uint8_t> SerializeAsArray() const = 0;
  virtual bool ParseFromArray(const void*, size_t) = 0;

  bool ParseFromString(const std::string& str) {
    return ParseFromArray(str.data(), str.size());
  }
};

}  // namespace protozero

#endif  // INCLUDE_PERFETTO_PROTOZERO_CPP_MESSAGE_OBJ_H_
// gen_amalgamated begin header: /Users/primiano/code/perfetto/tools/../include/perfetto/protozero/copyable_ptr.h
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_PROTOZERO_COPYABLE_PTR_H_
#define INCLUDE_PERFETTO_PROTOZERO_COPYABLE_PTR_H_

#include <memory>

namespace protozero {

// This class is essentially a std::vector<T> of fixed size = 1.
// It's a pointer wrapper with deep copying and deep equality comparison.
// At all effects this wrapper behaves like the underlying T, with the exception
// of the heap indirection.
// Conversely to a std::unique_ptr, the pointer will be always valid, never
// null. The problem it solves is the following: when generating C++ classes
// from proto files, we want to keep each header hermetic (i.e. not #include
// headers of dependent types). As such we can't directly instantiate T
// field members but we can instead rely on pointers, so only the .cc file needs
// to see the actual definition of T. If the generated classes were move-only we
// could just use a unique_ptr there. But they aren't, hence this wrapper.
// Converesely to unique_ptr, this wrapper:
// - Default constructs the T instance in its constructor.
// - Implements deep comparison in operator== instead of pointer comparison.
template <typename T>
class CopyablePtr {
 public:
  CopyablePtr() : ptr_(new T()) {}
  ~CopyablePtr() = default;

  // Copy operators.
  CopyablePtr(const CopyablePtr& other) : ptr_(new T(*other.ptr_)) {}
  CopyablePtr& operator=(const CopyablePtr& other) {
    *ptr_ = *other.ptr_;
    return *this;
  }

  // Move operators.
  CopyablePtr(CopyablePtr&& other) noexcept : ptr_(std::move(other.ptr_)) {
    other.ptr_.reset(new T());
  }

  CopyablePtr& operator=(CopyablePtr&& other) {
    ptr_ = std::move(other.ptr_);
    other.ptr_.reset(new T());
    return *this;
  }

  T* get() { return ptr_.get(); }
  const T* get() const { return ptr_.get(); }

  T* operator->() { return ptr_.get(); }
  const T* operator->() const { return ptr_.get(); }

  T& operator*() { return *ptr_; }
  const T& operator*() const { return *ptr_; }

  friend bool operator==(const CopyablePtr& lhs, const CopyablePtr& rhs) {
    return *lhs == *rhs;
  }

  friend bool operator!=(const CopyablePtr& lhs, const CopyablePtr& rhs) {
    // In theory the underlying type might have a special operator!=
    // implementation which is not just !(x == y). Respect that.
    return *lhs != *rhs;
  }

 private:
  std::unique_ptr<T> ptr_;
};

}  // namespace protozero

#endif  // INCLUDE_PERFETTO_PROTOZERO_COPYABLE_PTR_H_
// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_DATA_SOURCE_CONFIG_PROTO_CPP_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_DATA_SOURCE_CONFIG_PROTO_CPP_H_

#include <stdint.h>
#include <bitset>
#include <vector>
#include <string>
#include <type_traits>

// gen_amalgamated expanded: #include "perfetto/protozero/cpp_message_obj.h"
// gen_amalgamated expanded: #include "perfetto/protozero/copyable_ptr.h"
// gen_amalgamated expanded: #include "perfetto/base/export.h"

namespace perfetto {
namespace protos {
namespace gen {
class DataSourceConfig;
class TestConfig;
class TestConfig_DummyFields;
class ChromeConfig;
}  // namespace perfetto
}  // namespace protos
}  // namespace gen

namespace protozero {
class Message;
}  // namespace protozero

namespace perfetto {
namespace protos {
namespace gen {

class PERFETTO_EXPORT DataSourceConfig : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kNameFieldNumber = 1,
    kTargetBufferFieldNumber = 2,
    kTraceDurationMsFieldNumber = 3,
    kStopTimeoutMsFieldNumber = 7,
    kEnableExtraGuardrailsFieldNumber = 6,
    kTracingSessionIdFieldNumber = 4,
    kFtraceConfigFieldNumber = 100,
    kInodeFileConfigFieldNumber = 102,
    kProcessStatsConfigFieldNumber = 103,
    kSysStatsConfigFieldNumber = 104,
    kHeapprofdConfigFieldNumber = 105,
    kJavaHprofConfigFieldNumber = 110,
    kAndroidPowerConfigFieldNumber = 106,
    kAndroidLogConfigFieldNumber = 107,
    kGpuCounterConfigFieldNumber = 108,
    kPackagesListConfigFieldNumber = 109,
    kPerfEventConfigFieldNumber = 111,
    kChromeConfigFieldNumber = 101,
    kLegacyConfigFieldNumber = 1000,
    kForTestingFieldNumber = 1001,
  };

  DataSourceConfig();
  ~DataSourceConfig() override;
  DataSourceConfig(DataSourceConfig&&) noexcept;
  DataSourceConfig& operator=(DataSourceConfig&&);
  DataSourceConfig(const DataSourceConfig&);
  DataSourceConfig& operator=(const DataSourceConfig&);
  bool operator==(const DataSourceConfig&) const;
  bool operator!=(const DataSourceConfig& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;
  // (DEPRECATED) Conversion methods from/to libprotobuf types.
  // These two will go away soon, see go/perfetto-libprotobuf.
  template <typename T /*perfetto::protos::gen::DataSourceConfig*/> void FromProto(const T& pb_obj) { ParseFromString(pb_obj.SerializeAsString()); }
  template <typename T /*perfetto::protos::gen::DataSourceConfig*/> void ToProto(T* pb_obj) const { pb_obj->Clear(); pb_obj->ParseFromString(SerializeAsString()); }

  bool has_name() const { return _has_field_[1]; }
  const std::string& name() const { return name_; }
  void set_name(const std::string& value) { name_ = value; _has_field_.set(1); }

  bool has_target_buffer() const { return _has_field_[2]; }
  uint32_t target_buffer() const { return target_buffer_; }
  void set_target_buffer(uint32_t value) { target_buffer_ = value; _has_field_.set(2); }

  bool has_trace_duration_ms() const { return _has_field_[3]; }
  uint32_t trace_duration_ms() const { return trace_duration_ms_; }
  void set_trace_duration_ms(uint32_t value) { trace_duration_ms_ = value; _has_field_.set(3); }

  bool has_stop_timeout_ms() const { return _has_field_[7]; }
  uint32_t stop_timeout_ms() const { return stop_timeout_ms_; }
  void set_stop_timeout_ms(uint32_t value) { stop_timeout_ms_ = value; _has_field_.set(7); }

  bool has_enable_extra_guardrails() const { return _has_field_[6]; }
  bool enable_extra_guardrails() const { return enable_extra_guardrails_; }
  void set_enable_extra_guardrails(bool value) { enable_extra_guardrails_ = value; _has_field_.set(6); }

  bool has_tracing_session_id() const { return _has_field_[4]; }
  uint64_t tracing_session_id() const { return tracing_session_id_; }
  void set_tracing_session_id(uint64_t value) { tracing_session_id_ = value; _has_field_.set(4); }

  const std::string& ftrace_config_raw() const { return ftrace_config_; }
  void set_ftrace_config_raw(const std::string& raw) { ftrace_config_ = raw; _has_field_.set(100); }

  const std::string& inode_file_config_raw() const { return inode_file_config_; }
  void set_inode_file_config_raw(const std::string& raw) { inode_file_config_ = raw; _has_field_.set(102); }

  const std::string& process_stats_config_raw() const { return process_stats_config_; }
  void set_process_stats_config_raw(const std::string& raw) { process_stats_config_ = raw; _has_field_.set(103); }

  const std::string& sys_stats_config_raw() const { return sys_stats_config_; }
  void set_sys_stats_config_raw(const std::string& raw) { sys_stats_config_ = raw; _has_field_.set(104); }

  const std::string& heapprofd_config_raw() const { return heapprofd_config_; }
  void set_heapprofd_config_raw(const std::string& raw) { heapprofd_config_ = raw; _has_field_.set(105); }

  const std::string& java_hprof_config_raw() const { return java_hprof_config_; }
  void set_java_hprof_config_raw(const std::string& raw) { java_hprof_config_ = raw; _has_field_.set(110); }

  const std::string& android_power_config_raw() const { return android_power_config_; }
  void set_android_power_config_raw(const std::string& raw) { android_power_config_ = raw; _has_field_.set(106); }

  const std::string& android_log_config_raw() const { return android_log_config_; }
  void set_android_log_config_raw(const std::string& raw) { android_log_config_ = raw; _has_field_.set(107); }

  const std::string& gpu_counter_config_raw() const { return gpu_counter_config_; }
  void set_gpu_counter_config_raw(const std::string& raw) { gpu_counter_config_ = raw; _has_field_.set(108); }

  const std::string& packages_list_config_raw() const { return packages_list_config_; }
  void set_packages_list_config_raw(const std::string& raw) { packages_list_config_ = raw; _has_field_.set(109); }

  const std::string& perf_event_config_raw() const { return perf_event_config_; }
  void set_perf_event_config_raw(const std::string& raw) { perf_event_config_ = raw; _has_field_.set(111); }

  bool has_chrome_config() const { return _has_field_[101]; }
  const ChromeConfig& chrome_config() const { return *chrome_config_; }
  ChromeConfig* mutable_chrome_config() { _has_field_.set(101); return chrome_config_.get(); }

  bool has_legacy_config() const { return _has_field_[1000]; }
  const std::string& legacy_config() const { return legacy_config_; }
  void set_legacy_config(const std::string& value) { legacy_config_ = value; _has_field_.set(1000); }

  bool has_for_testing() const { return _has_field_[1001]; }
  const TestConfig& for_testing() const { return *for_testing_; }
  TestConfig* mutable_for_testing() { _has_field_.set(1001); return for_testing_.get(); }

 private:
  std::string name_{};
  uint32_t target_buffer_{};
  uint32_t trace_duration_ms_{};
  uint32_t stop_timeout_ms_{};
  bool enable_extra_guardrails_{};
  uint64_t tracing_session_id_{};
  std::string ftrace_config_;  // [lazy=true]
  std::string inode_file_config_;  // [lazy=true]
  std::string process_stats_config_;  // [lazy=true]
  std::string sys_stats_config_;  // [lazy=true]
  std::string heapprofd_config_;  // [lazy=true]
  std::string java_hprof_config_;  // [lazy=true]
  std::string android_power_config_;  // [lazy=true]
  std::string android_log_config_;  // [lazy=true]
  std::string gpu_counter_config_;  // [lazy=true]
  std::string packages_list_config_;  // [lazy=true]
  std::string perf_event_config_;  // [lazy=true]
  ::protozero::CopyablePtr<ChromeConfig> chrome_config_;
  std::string legacy_config_{};
  ::protozero::CopyablePtr<TestConfig> for_testing_;

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<1002> _has_field_{};
};

}  // namespace perfetto
}  // namespace protos
}  // namespace gen

#endif  // PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_DATA_SOURCE_CONFIG_PROTO_CPP_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_TRACING_CORE_DATA_SOURCE_CONFIG_H_
#define INCLUDE_PERFETTO_TRACING_CORE_DATA_SOURCE_CONFIG_H_

// Creates the aliases in the ::perfetto namespace, doing things like:
// using ::perfetto::Foo = ::perfetto::protos::gen::Foo.
// See comments in forward_decls.h for the historical reasons of this
// indirection layer.
// gen_amalgamated expanded: #include "perfetto/tracing/core/forward_decls.h"

// gen_amalgamated expanded: #include "protos/perfetto/config/data_source_config.gen.h"

#endif  // INCLUDE_PERFETTO_TRACING_CORE_DATA_SOURCE_CONFIG_H_
// gen_amalgamated begin header: /Users/primiano/code/perfetto/tools/../include/perfetto/tracing/core/data_source_descriptor.h
// gen_amalgamated begin header: /Users/primiano/code/perfetto/tools/../out/tmp.gen_amalgamated.16011/gen/protos/perfetto/common/data_source_descriptor.gen.h
// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_COMMON_DATA_SOURCE_DESCRIPTOR_PROTO_CPP_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_COMMON_DATA_SOURCE_DESCRIPTOR_PROTO_CPP_H_

#include <stdint.h>
#include <bitset>
#include <vector>
#include <string>
#include <type_traits>

// gen_amalgamated expanded: #include "perfetto/protozero/cpp_message_obj.h"
// gen_amalgamated expanded: #include "perfetto/protozero/copyable_ptr.h"
// gen_amalgamated expanded: #include "perfetto/base/export.h"

namespace perfetto {
namespace protos {
namespace gen {
class DataSourceDescriptor;
}  // namespace perfetto
}  // namespace protos
}  // namespace gen

namespace protozero {
class Message;
}  // namespace protozero

namespace perfetto {
namespace protos {
namespace gen {

class PERFETTO_EXPORT DataSourceDescriptor : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kNameFieldNumber = 1,
    kWillNotifyOnStopFieldNumber = 2,
    kWillNotifyOnStartFieldNumber = 3,
    kHandlesIncrementalStateClearFieldNumber = 4,
    kGpuCounterDescriptorFieldNumber = 5,
    kTrackEventDescriptorFieldNumber = 6,
  };

  DataSourceDescriptor();
  ~DataSourceDescriptor() override;
  DataSourceDescriptor(DataSourceDescriptor&&) noexcept;
  DataSourceDescriptor& operator=(DataSourceDescriptor&&);
  DataSourceDescriptor(const DataSourceDescriptor&);
  DataSourceDescriptor& operator=(const DataSourceDescriptor&);
  bool operator==(const DataSourceDescriptor&) const;
  bool operator!=(const DataSourceDescriptor& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;
  // (DEPRECATED) Conversion methods from/to libprotobuf types.
  // These two will go away soon, see go/perfetto-libprotobuf.
  template <typename T /*perfetto::protos::gen::DataSourceDescriptor*/> void FromProto(const T& pb_obj) { ParseFromString(pb_obj.SerializeAsString()); }
  template <typename T /*perfetto::protos::gen::DataSourceDescriptor*/> void ToProto(T* pb_obj) const { pb_obj->Clear(); pb_obj->ParseFromString(SerializeAsString()); }

  bool has_name() const { return _has_field_[1]; }
  const std::string& name() const { return name_; }
  void set_name(const std::string& value) { name_ = value; _has_field_.set(1); }

  bool has_will_notify_on_stop() const { return _has_field_[2]; }
  bool will_notify_on_stop() const { return will_notify_on_stop_; }
  void set_will_notify_on_stop(bool value) { will_notify_on_stop_ = value; _has_field_.set(2); }

  bool has_will_notify_on_start() const { return _has_field_[3]; }
  bool will_notify_on_start() const { return will_notify_on_start_; }
  void set_will_notify_on_start(bool value) { will_notify_on_start_ = value; _has_field_.set(3); }

  bool has_handles_incremental_state_clear() const { return _has_field_[4]; }
  bool handles_incremental_state_clear() const { return handles_incremental_state_clear_; }
  void set_handles_incremental_state_clear(bool value) { handles_incremental_state_clear_ = value; _has_field_.set(4); }

  const std::string& gpu_counter_descriptor_raw() const { return gpu_counter_descriptor_; }
  void set_gpu_counter_descriptor_raw(const std::string& raw) { gpu_counter_descriptor_ = raw; _has_field_.set(5); }

  const std::string& track_event_descriptor_raw() const { return track_event_descriptor_; }
  void set_track_event_descriptor_raw(const std::string& raw) { track_event_descriptor_ = raw; _has_field_.set(6); }

 private:
  std::string name_{};
  bool will_notify_on_stop_{};
  bool will_notify_on_start_{};
  bool handles_incremental_state_clear_{};
  std::string gpu_counter_descriptor_;  // [lazy=true]
  std::string track_event_descriptor_;  // [lazy=true]

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<7> _has_field_{};
};

}  // namespace perfetto
}  // namespace protos
}  // namespace gen

#endif  // PERFETTO_PROTOS_PROTOS_PERFETTO_COMMON_DATA_SOURCE_DESCRIPTOR_PROTO_CPP_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_TRACING_CORE_DATA_SOURCE_DESCRIPTOR_H_
#define INCLUDE_PERFETTO_TRACING_CORE_DATA_SOURCE_DESCRIPTOR_H_

// Creates the aliases in the ::perfetto namespace, doing things like:
// using ::perfetto::Foo = ::perfetto::protos::gen::Foo.
// See comments in forward_decls.h for the historical reasons of this
// indirection layer.
// gen_amalgamated expanded: #include "perfetto/tracing/core/forward_decls.h"

// gen_amalgamated expanded: #include "protos/perfetto/common/data_source_descriptor.gen.h"

#endif  // INCLUDE_PERFETTO_TRACING_CORE_DATA_SOURCE_DESCRIPTOR_H_
// gen_amalgamated begin header: /Users/primiano/code/perfetto/tools/../include/perfetto/tracing/core/trace_config.h
// gen_amalgamated begin header: /Users/primiano/code/perfetto/tools/../out/tmp.gen_amalgamated.16011/gen/protos/perfetto/config/trace_config.gen.h
// DO NOT EDIT. Autogenerated by Perfetto cppgen_plugin
#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_TRACE_CONFIG_PROTO_CPP_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_TRACE_CONFIG_PROTO_CPP_H_

#include <stdint.h>
#include <bitset>
#include <vector>
#include <string>
#include <type_traits>

// gen_amalgamated expanded: #include "perfetto/protozero/cpp_message_obj.h"
// gen_amalgamated expanded: #include "perfetto/protozero/copyable_ptr.h"
// gen_amalgamated expanded: #include "perfetto/base/export.h"

namespace perfetto {
namespace protos {
namespace gen {
class TraceConfig;
class TraceConfig_IncidentReportConfig;
class TraceConfig_IncrementalStateConfig;
class TraceConfig_TriggerConfig;
class TraceConfig_TriggerConfig_Trigger;
class TraceConfig_GuardrailOverrides;
class TraceConfig_StatsdMetadata;
class TraceConfig_ProducerConfig;
class TraceConfig_BuiltinDataSource;
class TraceConfig_DataSource;
class DataSourceConfig;
class TestConfig;
class TestConfig_DummyFields;
class ChromeConfig;
class TraceConfig_BufferConfig;
enum TraceConfig_LockdownModeOperation : int;
enum TraceConfig_CompressionType : int;
enum TraceConfig_TriggerConfig_TriggerMode : int;
enum TraceConfig_BufferConfig_FillPolicy : int;
}  // namespace perfetto
}  // namespace protos
}  // namespace gen

namespace protozero {
class Message;
}  // namespace protozero

namespace perfetto {
namespace protos {
namespace gen {
enum TraceConfig_LockdownModeOperation : int {
  TraceConfig_LockdownModeOperation_LOCKDOWN_UNCHANGED = 0,
  TraceConfig_LockdownModeOperation_LOCKDOWN_CLEAR = 1,
  TraceConfig_LockdownModeOperation_LOCKDOWN_SET = 2,
};
enum TraceConfig_CompressionType : int {
  TraceConfig_CompressionType_COMPRESSION_TYPE_UNSPECIFIED = 0,
  TraceConfig_CompressionType_COMPRESSION_TYPE_DEFLATE = 1,
};
enum TraceConfig_TriggerConfig_TriggerMode : int {
  TraceConfig_TriggerConfig_TriggerMode_UNSPECIFIED = 0,
  TraceConfig_TriggerConfig_TriggerMode_START_TRACING = 1,
  TraceConfig_TriggerConfig_TriggerMode_STOP_TRACING = 2,
};
enum TraceConfig_BufferConfig_FillPolicy : int {
  TraceConfig_BufferConfig_FillPolicy_UNSPECIFIED = 0,
  TraceConfig_BufferConfig_FillPolicy_RING_BUFFER = 1,
  TraceConfig_BufferConfig_FillPolicy_DISCARD = 2,
};

class PERFETTO_EXPORT TraceConfig : public ::protozero::CppMessageObj {
 public:
  using BufferConfig = TraceConfig_BufferConfig;
  using DataSource = TraceConfig_DataSource;
  using BuiltinDataSource = TraceConfig_BuiltinDataSource;
  using ProducerConfig = TraceConfig_ProducerConfig;
  using StatsdMetadata = TraceConfig_StatsdMetadata;
  using GuardrailOverrides = TraceConfig_GuardrailOverrides;
  using TriggerConfig = TraceConfig_TriggerConfig;
  using IncrementalStateConfig = TraceConfig_IncrementalStateConfig;
  using IncidentReportConfig = TraceConfig_IncidentReportConfig;
  using LockdownModeOperation = TraceConfig_LockdownModeOperation;
  static constexpr auto LOCKDOWN_UNCHANGED = TraceConfig_LockdownModeOperation_LOCKDOWN_UNCHANGED;
  static constexpr auto LOCKDOWN_CLEAR = TraceConfig_LockdownModeOperation_LOCKDOWN_CLEAR;
  static constexpr auto LOCKDOWN_SET = TraceConfig_LockdownModeOperation_LOCKDOWN_SET;
  using CompressionType = TraceConfig_CompressionType;
  static constexpr auto COMPRESSION_TYPE_UNSPECIFIED = TraceConfig_CompressionType_COMPRESSION_TYPE_UNSPECIFIED;
  static constexpr auto COMPRESSION_TYPE_DEFLATE = TraceConfig_CompressionType_COMPRESSION_TYPE_DEFLATE;
  enum FieldNumbers {
    kBuffersFieldNumber = 1,
    kDataSourcesFieldNumber = 2,
    kBuiltinDataSourcesFieldNumber = 20,
    kDurationMsFieldNumber = 3,
    kEnableExtraGuardrailsFieldNumber = 4,
    kLockdownModeFieldNumber = 5,
    kProducersFieldNumber = 6,
    kStatsdMetadataFieldNumber = 7,
    kWriteIntoFileFieldNumber = 8,
    kFileWritePeriodMsFieldNumber = 9,
    kMaxFileSizeBytesFieldNumber = 10,
    kGuardrailOverridesFieldNumber = 11,
    kDeferredStartFieldNumber = 12,
    kFlushPeriodMsFieldNumber = 13,
    kFlushTimeoutMsFieldNumber = 14,
    kDataSourceStopTimeoutMsFieldNumber = 23,
    kNotifyTraceurFieldNumber = 16,
    kTriggerConfigFieldNumber = 17,
    kActivateTriggersFieldNumber = 18,
    kIncrementalStateConfigFieldNumber = 21,
    kAllowUserBuildTracingFieldNumber = 19,
    kUniqueSessionNameFieldNumber = 22,
    kCompressionTypeFieldNumber = 24,
    kIncidentReportConfigFieldNumber = 25,
    kTraceUuidMsbFieldNumber = 27,
    kTraceUuidLsbFieldNumber = 28,
  };

  TraceConfig();
  ~TraceConfig() override;
  TraceConfig(TraceConfig&&) noexcept;
  TraceConfig& operator=(TraceConfig&&);
  TraceConfig(const TraceConfig&);
  TraceConfig& operator=(const TraceConfig&);
  bool operator==(const TraceConfig&) const;
  bool operator!=(const TraceConfig& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;
  // (DEPRECATED) Conversion methods from/to libprotobuf types.
  // These two will go away soon, see go/perfetto-libprotobuf.
  template <typename T /*perfetto::protos::gen::TraceConfig*/> void FromProto(const T& pb_obj) { ParseFromString(pb_obj.SerializeAsString()); }
  template <typename T /*perfetto::protos::gen::TraceConfig*/> void ToProto(T* pb_obj) const { pb_obj->Clear(); pb_obj->ParseFromString(SerializeAsString()); }

  int buffers_size() const { return static_cast<int>(buffers_.size()); }
  const std::vector<TraceConfig_BufferConfig>& buffers() const { return buffers_; }
  std::vector<TraceConfig_BufferConfig>* mutable_buffers() { return &buffers_; }
  void clear_buffers() { buffers_.clear(); }
  TraceConfig_BufferConfig* add_buffers() { buffers_.emplace_back(); return &buffers_.back(); }

  int data_sources_size() const { return static_cast<int>(data_sources_.size()); }
  const std::vector<TraceConfig_DataSource>& data_sources() const { return data_sources_; }
  std::vector<TraceConfig_DataSource>* mutable_data_sources() { return &data_sources_; }
  void clear_data_sources() { data_sources_.clear(); }
  TraceConfig_DataSource* add_data_sources() { data_sources_.emplace_back(); return &data_sources_.back(); }

  bool has_builtin_data_sources() const { return _has_field_[20]; }
  const TraceConfig_BuiltinDataSource& builtin_data_sources() const { return *builtin_data_sources_; }
  TraceConfig_BuiltinDataSource* mutable_builtin_data_sources() { _has_field_.set(20); return builtin_data_sources_.get(); }

  bool has_duration_ms() const { return _has_field_[3]; }
  uint32_t duration_ms() const { return duration_ms_; }
  void set_duration_ms(uint32_t value) { duration_ms_ = value; _has_field_.set(3); }

  bool has_enable_extra_guardrails() const { return _has_field_[4]; }
  bool enable_extra_guardrails() const { return enable_extra_guardrails_; }
  void set_enable_extra_guardrails(bool value) { enable_extra_guardrails_ = value; _has_field_.set(4); }

  bool has_lockdown_mode() const { return _has_field_[5]; }
  TraceConfig_LockdownModeOperation lockdown_mode() const { return lockdown_mode_; }
  void set_lockdown_mode(TraceConfig_LockdownModeOperation value) { lockdown_mode_ = value; _has_field_.set(5); }

  int producers_size() const { return static_cast<int>(producers_.size()); }
  const std::vector<TraceConfig_ProducerConfig>& producers() const { return producers_; }
  std::vector<TraceConfig_ProducerConfig>* mutable_producers() { return &producers_; }
  void clear_producers() { producers_.clear(); }
  TraceConfig_ProducerConfig* add_producers() { producers_.emplace_back(); return &producers_.back(); }

  bool has_statsd_metadata() const { return _has_field_[7]; }
  const TraceConfig_StatsdMetadata& statsd_metadata() const { return *statsd_metadata_; }
  TraceConfig_StatsdMetadata* mutable_statsd_metadata() { _has_field_.set(7); return statsd_metadata_.get(); }

  bool has_write_into_file() const { return _has_field_[8]; }
  bool write_into_file() const { return write_into_file_; }
  void set_write_into_file(bool value) { write_into_file_ = value; _has_field_.set(8); }

  bool has_file_write_period_ms() const { return _has_field_[9]; }
  uint32_t file_write_period_ms() const { return file_write_period_ms_; }
  void set_file_write_period_ms(uint32_t value) { file_write_period_ms_ = value; _has_field_.set(9); }

  bool has_max_file_size_bytes() const { return _has_field_[10]; }
  uint64_t max_file_size_bytes() const { return max_file_size_bytes_; }
  void set_max_file_size_bytes(uint64_t value) { max_file_size_bytes_ = value; _has_field_.set(10); }

  bool has_guardrail_overrides() const { return _has_field_[11]; }
  const TraceConfig_GuardrailOverrides& guardrail_overrides() const { return *guardrail_overrides_; }
  TraceConfig_GuardrailOverrides* mutable_guardrail_overrides() { _has_field_.set(11); return guardrail_overrides_.get(); }

  bool has_deferred_start() const { return _has_field_[12]; }
  bool deferred_start() const { return deferred_start_; }
  void set_deferred_start(bool value) { deferred_start_ = value; _has_field_.set(12); }

  bool has_flush_period_ms() const { return _has_field_[13]; }
  uint32_t flush_period_ms() const { return flush_period_ms_; }
  void set_flush_period_ms(uint32_t value) { flush_period_ms_ = value; _has_field_.set(13); }

  bool has_flush_timeout_ms() const { return _has_field_[14]; }
  uint32_t flush_timeout_ms() const { return flush_timeout_ms_; }
  void set_flush_timeout_ms(uint32_t value) { flush_timeout_ms_ = value; _has_field_.set(14); }

  bool has_data_source_stop_timeout_ms() const { return _has_field_[23]; }
  uint32_t data_source_stop_timeout_ms() const { return data_source_stop_timeout_ms_; }
  void set_data_source_stop_timeout_ms(uint32_t value) { data_source_stop_timeout_ms_ = value; _has_field_.set(23); }

  bool has_notify_traceur() const { return _has_field_[16]; }
  bool notify_traceur() const { return notify_traceur_; }
  void set_notify_traceur(bool value) { notify_traceur_ = value; _has_field_.set(16); }

  bool has_trigger_config() const { return _has_field_[17]; }
  const TraceConfig_TriggerConfig& trigger_config() const { return *trigger_config_; }
  TraceConfig_TriggerConfig* mutable_trigger_config() { _has_field_.set(17); return trigger_config_.get(); }

  int activate_triggers_size() const { return static_cast<int>(activate_triggers_.size()); }
  const std::vector<std::string>& activate_triggers() const { return activate_triggers_; }
  std::vector<std::string>* mutable_activate_triggers() { return &activate_triggers_; }
  void clear_activate_triggers() { activate_triggers_.clear(); }
  void add_activate_triggers(std::string value) { activate_triggers_.emplace_back(value); }
  std::string* add_activate_triggers() { activate_triggers_.emplace_back(); return &activate_triggers_.back(); }

  bool has_incremental_state_config() const { return _has_field_[21]; }
  const TraceConfig_IncrementalStateConfig& incremental_state_config() const { return *incremental_state_config_; }
  TraceConfig_IncrementalStateConfig* mutable_incremental_state_config() { _has_field_.set(21); return incremental_state_config_.get(); }

  bool has_allow_user_build_tracing() const { return _has_field_[19]; }
  bool allow_user_build_tracing() const { return allow_user_build_tracing_; }
  void set_allow_user_build_tracing(bool value) { allow_user_build_tracing_ = value; _has_field_.set(19); }

  bool has_unique_session_name() const { return _has_field_[22]; }
  const std::string& unique_session_name() const { return unique_session_name_; }
  void set_unique_session_name(const std::string& value) { unique_session_name_ = value; _has_field_.set(22); }

  bool has_compression_type() const { return _has_field_[24]; }
  TraceConfig_CompressionType compression_type() const { return compression_type_; }
  void set_compression_type(TraceConfig_CompressionType value) { compression_type_ = value; _has_field_.set(24); }

  bool has_incident_report_config() const { return _has_field_[25]; }
  const TraceConfig_IncidentReportConfig& incident_report_config() const { return *incident_report_config_; }
  TraceConfig_IncidentReportConfig* mutable_incident_report_config() { _has_field_.set(25); return incident_report_config_.get(); }

  bool has_trace_uuid_msb() const { return _has_field_[27]; }
  int64_t trace_uuid_msb() const { return trace_uuid_msb_; }
  void set_trace_uuid_msb(int64_t value) { trace_uuid_msb_ = value; _has_field_.set(27); }

  bool has_trace_uuid_lsb() const { return _has_field_[28]; }
  int64_t trace_uuid_lsb() const { return trace_uuid_lsb_; }
  void set_trace_uuid_lsb(int64_t value) { trace_uuid_lsb_ = value; _has_field_.set(28); }

 private:
  std::vector<TraceConfig_BufferConfig> buffers_;
  std::vector<TraceConfig_DataSource> data_sources_;
  ::protozero::CopyablePtr<TraceConfig_BuiltinDataSource> builtin_data_sources_;
  uint32_t duration_ms_{};
  bool enable_extra_guardrails_{};
  TraceConfig_LockdownModeOperation lockdown_mode_{};
  std::vector<TraceConfig_ProducerConfig> producers_;
  ::protozero::CopyablePtr<TraceConfig_StatsdMetadata> statsd_metadata_;
  bool write_into_file_{};
  uint32_t file_write_period_ms_{};
  uint64_t max_file_size_bytes_{};
  ::protozero::CopyablePtr<TraceConfig_GuardrailOverrides> guardrail_overrides_;
  bool deferred_start_{};
  uint32_t flush_period_ms_{};
  uint32_t flush_timeout_ms_{};
  uint32_t data_source_stop_timeout_ms_{};
  bool notify_traceur_{};
  ::protozero::CopyablePtr<TraceConfig_TriggerConfig> trigger_config_;
  std::vector<std::string> activate_triggers_;
  ::protozero::CopyablePtr<TraceConfig_IncrementalStateConfig> incremental_state_config_;
  bool allow_user_build_tracing_{};
  std::string unique_session_name_{};
  TraceConfig_CompressionType compression_type_{};
  ::protozero::CopyablePtr<TraceConfig_IncidentReportConfig> incident_report_config_;
  int64_t trace_uuid_msb_{};
  int64_t trace_uuid_lsb_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<29> _has_field_{};
};


class PERFETTO_EXPORT TraceConfig_IncidentReportConfig : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDestinationPackageFieldNumber = 1,
    kDestinationClassFieldNumber = 2,
    kPrivacyLevelFieldNumber = 3,
    kSkipDropboxFieldNumber = 4,
  };

  TraceConfig_IncidentReportConfig();
  ~TraceConfig_IncidentReportConfig() override;
  TraceConfig_IncidentReportConfig(TraceConfig_IncidentReportConfig&&) noexcept;
  TraceConfig_IncidentReportConfig& operator=(TraceConfig_IncidentReportConfig&&);
  TraceConfig_IncidentReportConfig(const TraceConfig_IncidentReportConfig&);
  TraceConfig_IncidentReportConfig& operator=(const TraceConfig_IncidentReportConfig&);
  bool operator==(const TraceConfig_IncidentReportConfig&) const;
  bool operator!=(const TraceConfig_IncidentReportConfig& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;
  // (DEPRECATED) Conversion methods from/to libprotobuf types.
  // These two will go away soon, see go/perfetto-libprotobuf.
  template <typename T /*perfetto::protos::gen::TraceConfig_IncidentReportConfig*/> void FromProto(const T& pb_obj) { ParseFromString(pb_obj.SerializeAsString()); }
  template <typename T /*perfetto::protos::gen::TraceConfig_IncidentReportConfig*/> void ToProto(T* pb_obj) const { pb_obj->Clear(); pb_obj->ParseFromString(SerializeAsString()); }

  bool has_destination_package() const { return _has_field_[1]; }
  const std::string& destination_package() const { return destination_package_; }
  void set_destination_package(const std::string& value) { destination_package_ = value; _has_field_.set(1); }

  bool has_destination_class() const { return _has_field_[2]; }
  const std::string& destination_class() const { return destination_class_; }
  void set_destination_class(const std::string& value) { destination_class_ = value; _has_field_.set(2); }

  bool has_privacy_level() const { return _has_field_[3]; }
  int32_t privacy_level() const { return privacy_level_; }
  void set_privacy_level(int32_t value) { privacy_level_ = value; _has_field_.set(3); }

  bool has_skip_dropbox() const { return _has_field_[4]; }
  bool skip_dropbox() const { return skip_dropbox_; }
  void set_skip_dropbox(bool value) { skip_dropbox_ = value; _has_field_.set(4); }

 private:
  std::string destination_package_{};
  std::string destination_class_{};
  int32_t privacy_level_{};
  bool skip_dropbox_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT TraceConfig_IncrementalStateConfig : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kClearPeriodMsFieldNumber = 1,
  };

  TraceConfig_IncrementalStateConfig();
  ~TraceConfig_IncrementalStateConfig() override;
  TraceConfig_IncrementalStateConfig(TraceConfig_IncrementalStateConfig&&) noexcept;
  TraceConfig_IncrementalStateConfig& operator=(TraceConfig_IncrementalStateConfig&&);
  TraceConfig_IncrementalStateConfig(const TraceConfig_IncrementalStateConfig&);
  TraceConfig_IncrementalStateConfig& operator=(const TraceConfig_IncrementalStateConfig&);
  bool operator==(const TraceConfig_IncrementalStateConfig&) const;
  bool operator!=(const TraceConfig_IncrementalStateConfig& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;
  // (DEPRECATED) Conversion methods from/to libprotobuf types.
  // These two will go away soon, see go/perfetto-libprotobuf.
  template <typename T /*perfetto::protos::gen::TraceConfig_IncrementalStateConfig*/> void FromProto(const T& pb_obj) { ParseFromString(pb_obj.SerializeAsString()); }
  template <typename T /*perfetto::protos::gen::TraceConfig_IncrementalStateConfig*/> void ToProto(T* pb_obj) const { pb_obj->Clear(); pb_obj->ParseFromString(SerializeAsString()); }

  bool has_clear_period_ms() const { return _has_field_[1]; }
  uint32_t clear_period_ms() const { return clear_period_ms_; }
  void set_clear_period_ms(uint32_t value) { clear_period_ms_ = value; _has_field_.set(1); }

 private:
  uint32_t clear_period_ms_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<2> _has_field_{};
};


class PERFETTO_EXPORT TraceConfig_TriggerConfig : public ::protozero::CppMessageObj {
 public:
  using Trigger = TraceConfig_TriggerConfig_Trigger;
  using TriggerMode = TraceConfig_TriggerConfig_TriggerMode;
  static constexpr auto UNSPECIFIED = TraceConfig_TriggerConfig_TriggerMode_UNSPECIFIED;
  static constexpr auto START_TRACING = TraceConfig_TriggerConfig_TriggerMode_START_TRACING;
  static constexpr auto STOP_TRACING = TraceConfig_TriggerConfig_TriggerMode_STOP_TRACING;
  enum FieldNumbers {
    kTriggerModeFieldNumber = 1,
    kTriggersFieldNumber = 2,
    kTriggerTimeoutMsFieldNumber = 3,
  };

  TraceConfig_TriggerConfig();
  ~TraceConfig_TriggerConfig() override;
  TraceConfig_TriggerConfig(TraceConfig_TriggerConfig&&) noexcept;
  TraceConfig_TriggerConfig& operator=(TraceConfig_TriggerConfig&&);
  TraceConfig_TriggerConfig(const TraceConfig_TriggerConfig&);
  TraceConfig_TriggerConfig& operator=(const TraceConfig_TriggerConfig&);
  bool operator==(const TraceConfig_TriggerConfig&) const;
  bool operator!=(const TraceConfig_TriggerConfig& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;
  // (DEPRECATED) Conversion methods from/to libprotobuf types.
  // These two will go away soon, see go/perfetto-libprotobuf.
  template <typename T /*perfetto::protos::gen::TraceConfig_TriggerConfig*/> void FromProto(const T& pb_obj) { ParseFromString(pb_obj.SerializeAsString()); }
  template <typename T /*perfetto::protos::gen::TraceConfig_TriggerConfig*/> void ToProto(T* pb_obj) const { pb_obj->Clear(); pb_obj->ParseFromString(SerializeAsString()); }

  bool has_trigger_mode() const { return _has_field_[1]; }
  TraceConfig_TriggerConfig_TriggerMode trigger_mode() const { return trigger_mode_; }
  void set_trigger_mode(TraceConfig_TriggerConfig_TriggerMode value) { trigger_mode_ = value; _has_field_.set(1); }

  int triggers_size() const { return static_cast<int>(triggers_.size()); }
  const std::vector<TraceConfig_TriggerConfig_Trigger>& triggers() const { return triggers_; }
  std::vector<TraceConfig_TriggerConfig_Trigger>* mutable_triggers() { return &triggers_; }
  void clear_triggers() { triggers_.clear(); }
  TraceConfig_TriggerConfig_Trigger* add_triggers() { triggers_.emplace_back(); return &triggers_.back(); }

  bool has_trigger_timeout_ms() const { return _has_field_[3]; }
  uint32_t trigger_timeout_ms() const { return trigger_timeout_ms_; }
  void set_trigger_timeout_ms(uint32_t value) { trigger_timeout_ms_ = value; _has_field_.set(3); }

 private:
  TraceConfig_TriggerConfig_TriggerMode trigger_mode_{};
  std::vector<TraceConfig_TriggerConfig_Trigger> triggers_;
  uint32_t trigger_timeout_ms_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT TraceConfig_TriggerConfig_Trigger : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kNameFieldNumber = 1,
    kProducerNameRegexFieldNumber = 2,
    kStopDelayMsFieldNumber = 3,
  };

  TraceConfig_TriggerConfig_Trigger();
  ~TraceConfig_TriggerConfig_Trigger() override;
  TraceConfig_TriggerConfig_Trigger(TraceConfig_TriggerConfig_Trigger&&) noexcept;
  TraceConfig_TriggerConfig_Trigger& operator=(TraceConfig_TriggerConfig_Trigger&&);
  TraceConfig_TriggerConfig_Trigger(const TraceConfig_TriggerConfig_Trigger&);
  TraceConfig_TriggerConfig_Trigger& operator=(const TraceConfig_TriggerConfig_Trigger&);
  bool operator==(const TraceConfig_TriggerConfig_Trigger&) const;
  bool operator!=(const TraceConfig_TriggerConfig_Trigger& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;
  // (DEPRECATED) Conversion methods from/to libprotobuf types.
  // These two will go away soon, see go/perfetto-libprotobuf.
  template <typename T /*perfetto::protos::gen::TraceConfig_TriggerConfig_Trigger*/> void FromProto(const T& pb_obj) { ParseFromString(pb_obj.SerializeAsString()); }
  template <typename T /*perfetto::protos::gen::TraceConfig_TriggerConfig_Trigger*/> void ToProto(T* pb_obj) const { pb_obj->Clear(); pb_obj->ParseFromString(SerializeAsString()); }

  bool has_name() const { return _has_field_[1]; }
  const std::string& name() const { return name_; }
  void set_name(const std::string& value) { name_ = value; _has_field_.set(1); }

  bool has_producer_name_regex() const { return _has_field_[2]; }
  const std::string& producer_name_regex() const { return producer_name_regex_; }
  void set_producer_name_regex(const std::string& value) { producer_name_regex_ = value; _has_field_.set(2); }

  bool has_stop_delay_ms() const { return _has_field_[3]; }
  uint32_t stop_delay_ms() const { return stop_delay_ms_; }
  void set_stop_delay_ms(uint32_t value) { stop_delay_ms_ = value; _has_field_.set(3); }

 private:
  std::string name_{};
  std::string producer_name_regex_{};
  uint32_t stop_delay_ms_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT TraceConfig_GuardrailOverrides : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kMaxUploadPerDayBytesFieldNumber = 1,
  };

  TraceConfig_GuardrailOverrides();
  ~TraceConfig_GuardrailOverrides() override;
  TraceConfig_GuardrailOverrides(TraceConfig_GuardrailOverrides&&) noexcept;
  TraceConfig_GuardrailOverrides& operator=(TraceConfig_GuardrailOverrides&&);
  TraceConfig_GuardrailOverrides(const TraceConfig_GuardrailOverrides&);
  TraceConfig_GuardrailOverrides& operator=(const TraceConfig_GuardrailOverrides&);
  bool operator==(const TraceConfig_GuardrailOverrides&) const;
  bool operator!=(const TraceConfig_GuardrailOverrides& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;
  // (DEPRECATED) Conversion methods from/to libprotobuf types.
  // These two will go away soon, see go/perfetto-libprotobuf.
  template <typename T /*perfetto::protos::gen::TraceConfig_GuardrailOverrides*/> void FromProto(const T& pb_obj) { ParseFromString(pb_obj.SerializeAsString()); }
  template <typename T /*perfetto::protos::gen::TraceConfig_GuardrailOverrides*/> void ToProto(T* pb_obj) const { pb_obj->Clear(); pb_obj->ParseFromString(SerializeAsString()); }

  bool has_max_upload_per_day_bytes() const { return _has_field_[1]; }
  uint64_t max_upload_per_day_bytes() const { return max_upload_per_day_bytes_; }
  void set_max_upload_per_day_bytes(uint64_t value) { max_upload_per_day_bytes_ = value; _has_field_.set(1); }

 private:
  uint64_t max_upload_per_day_bytes_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<2> _has_field_{};
};


class PERFETTO_EXPORT TraceConfig_StatsdMetadata : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kTriggeringAlertIdFieldNumber = 1,
    kTriggeringConfigUidFieldNumber = 2,
    kTriggeringConfigIdFieldNumber = 3,
    kTriggeringSubscriptionIdFieldNumber = 4,
  };

  TraceConfig_StatsdMetadata();
  ~TraceConfig_StatsdMetadata() override;
  TraceConfig_StatsdMetadata(TraceConfig_StatsdMetadata&&) noexcept;
  TraceConfig_StatsdMetadata& operator=(TraceConfig_StatsdMetadata&&);
  TraceConfig_StatsdMetadata(const TraceConfig_StatsdMetadata&);
  TraceConfig_StatsdMetadata& operator=(const TraceConfig_StatsdMetadata&);
  bool operator==(const TraceConfig_StatsdMetadata&) const;
  bool operator!=(const TraceConfig_StatsdMetadata& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;
  // (DEPRECATED) Conversion methods from/to libprotobuf types.
  // These two will go away soon, see go/perfetto-libprotobuf.
  template <typename T /*perfetto::protos::gen::TraceConfig_StatsdMetadata*/> void FromProto(const T& pb_obj) { ParseFromString(pb_obj.SerializeAsString()); }
  template <typename T /*perfetto::protos::gen::TraceConfig_StatsdMetadata*/> void ToProto(T* pb_obj) const { pb_obj->Clear(); pb_obj->ParseFromString(SerializeAsString()); }

  bool has_triggering_alert_id() const { return _has_field_[1]; }
  int64_t triggering_alert_id() const { return triggering_alert_id_; }
  void set_triggering_alert_id(int64_t value) { triggering_alert_id_ = value; _has_field_.set(1); }

  bool has_triggering_config_uid() const { return _has_field_[2]; }
  int32_t triggering_config_uid() const { return triggering_config_uid_; }
  void set_triggering_config_uid(int32_t value) { triggering_config_uid_ = value; _has_field_.set(2); }

  bool has_triggering_config_id() const { return _has_field_[3]; }
  int64_t triggering_config_id() const { return triggering_config_id_; }
  void set_triggering_config_id(int64_t value) { triggering_config_id_ = value; _has_field_.set(3); }

  bool has_triggering_subscription_id() const { return _has_field_[4]; }
  int64_t triggering_subscription_id() const { return triggering_subscription_id_; }
  void set_triggering_subscription_id(int64_t value) { triggering_subscription_id_ = value; _has_field_.set(4); }

 private:
  int64_t triggering_alert_id_{};
  int32_t triggering_config_uid_{};
  int64_t triggering_config_id_{};
  int64_t triggering_subscription_id_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};


class PERFETTO_EXPORT TraceConfig_ProducerConfig : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kProducerNameFieldNumber = 1,
    kShmSizeKbFieldNumber = 2,
    kPageSizeKbFieldNumber = 3,
  };

  TraceConfig_ProducerConfig();
  ~TraceConfig_ProducerConfig() override;
  TraceConfig_ProducerConfig(TraceConfig_ProducerConfig&&) noexcept;
  TraceConfig_ProducerConfig& operator=(TraceConfig_ProducerConfig&&);
  TraceConfig_ProducerConfig(const TraceConfig_ProducerConfig&);
  TraceConfig_ProducerConfig& operator=(const TraceConfig_ProducerConfig&);
  bool operator==(const TraceConfig_ProducerConfig&) const;
  bool operator!=(const TraceConfig_ProducerConfig& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;
  // (DEPRECATED) Conversion methods from/to libprotobuf types.
  // These two will go away soon, see go/perfetto-libprotobuf.
  template <typename T /*perfetto::protos::gen::TraceConfig_ProducerConfig*/> void FromProto(const T& pb_obj) { ParseFromString(pb_obj.SerializeAsString()); }
  template <typename T /*perfetto::protos::gen::TraceConfig_ProducerConfig*/> void ToProto(T* pb_obj) const { pb_obj->Clear(); pb_obj->ParseFromString(SerializeAsString()); }

  bool has_producer_name() const { return _has_field_[1]; }
  const std::string& producer_name() const { return producer_name_; }
  void set_producer_name(const std::string& value) { producer_name_ = value; _has_field_.set(1); }

  bool has_shm_size_kb() const { return _has_field_[2]; }
  uint32_t shm_size_kb() const { return shm_size_kb_; }
  void set_shm_size_kb(uint32_t value) { shm_size_kb_ = value; _has_field_.set(2); }

  bool has_page_size_kb() const { return _has_field_[3]; }
  uint32_t page_size_kb() const { return page_size_kb_; }
  void set_page_size_kb(uint32_t value) { page_size_kb_ = value; _has_field_.set(3); }

 private:
  std::string producer_name_{};
  uint32_t shm_size_kb_{};
  uint32_t page_size_kb_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT TraceConfig_BuiltinDataSource : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kDisableClockSnapshottingFieldNumber = 1,
    kDisableTraceConfigFieldNumber = 2,
    kDisableSystemInfoFieldNumber = 3,
  };

  TraceConfig_BuiltinDataSource();
  ~TraceConfig_BuiltinDataSource() override;
  TraceConfig_BuiltinDataSource(TraceConfig_BuiltinDataSource&&) noexcept;
  TraceConfig_BuiltinDataSource& operator=(TraceConfig_BuiltinDataSource&&);
  TraceConfig_BuiltinDataSource(const TraceConfig_BuiltinDataSource&);
  TraceConfig_BuiltinDataSource& operator=(const TraceConfig_BuiltinDataSource&);
  bool operator==(const TraceConfig_BuiltinDataSource&) const;
  bool operator!=(const TraceConfig_BuiltinDataSource& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;
  // (DEPRECATED) Conversion methods from/to libprotobuf types.
  // These two will go away soon, see go/perfetto-libprotobuf.
  template <typename T /*perfetto::protos::gen::TraceConfig_BuiltinDataSource*/> void FromProto(const T& pb_obj) { ParseFromString(pb_obj.SerializeAsString()); }
  template <typename T /*perfetto::protos::gen::TraceConfig_BuiltinDataSource*/> void ToProto(T* pb_obj) const { pb_obj->Clear(); pb_obj->ParseFromString(SerializeAsString()); }

  bool has_disable_clock_snapshotting() const { return _has_field_[1]; }
  bool disable_clock_snapshotting() const { return disable_clock_snapshotting_; }
  void set_disable_clock_snapshotting(bool value) { disable_clock_snapshotting_ = value; _has_field_.set(1); }

  bool has_disable_trace_config() const { return _has_field_[2]; }
  bool disable_trace_config() const { return disable_trace_config_; }
  void set_disable_trace_config(bool value) { disable_trace_config_ = value; _has_field_.set(2); }

  bool has_disable_system_info() const { return _has_field_[3]; }
  bool disable_system_info() const { return disable_system_info_; }
  void set_disable_system_info(bool value) { disable_system_info_ = value; _has_field_.set(3); }

 private:
  bool disable_clock_snapshotting_{};
  bool disable_trace_config_{};
  bool disable_system_info_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<4> _has_field_{};
};


class PERFETTO_EXPORT TraceConfig_DataSource : public ::protozero::CppMessageObj {
 public:
  enum FieldNumbers {
    kConfigFieldNumber = 1,
    kProducerNameFilterFieldNumber = 2,
  };

  TraceConfig_DataSource();
  ~TraceConfig_DataSource() override;
  TraceConfig_DataSource(TraceConfig_DataSource&&) noexcept;
  TraceConfig_DataSource& operator=(TraceConfig_DataSource&&);
  TraceConfig_DataSource(const TraceConfig_DataSource&);
  TraceConfig_DataSource& operator=(const TraceConfig_DataSource&);
  bool operator==(const TraceConfig_DataSource&) const;
  bool operator!=(const TraceConfig_DataSource& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;
  // (DEPRECATED) Conversion methods from/to libprotobuf types.
  // These two will go away soon, see go/perfetto-libprotobuf.
  template <typename T /*perfetto::protos::gen::TraceConfig_DataSource*/> void FromProto(const T& pb_obj) { ParseFromString(pb_obj.SerializeAsString()); }
  template <typename T /*perfetto::protos::gen::TraceConfig_DataSource*/> void ToProto(T* pb_obj) const { pb_obj->Clear(); pb_obj->ParseFromString(SerializeAsString()); }

  bool has_config() const { return _has_field_[1]; }
  const DataSourceConfig& config() const { return *config_; }
  DataSourceConfig* mutable_config() { _has_field_.set(1); return config_.get(); }

  int producer_name_filter_size() const { return static_cast<int>(producer_name_filter_.size()); }
  const std::vector<std::string>& producer_name_filter() const { return producer_name_filter_; }
  std::vector<std::string>* mutable_producer_name_filter() { return &producer_name_filter_; }
  void clear_producer_name_filter() { producer_name_filter_.clear(); }
  void add_producer_name_filter(std::string value) { producer_name_filter_.emplace_back(value); }
  std::string* add_producer_name_filter() { producer_name_filter_.emplace_back(); return &producer_name_filter_.back(); }

 private:
  ::protozero::CopyablePtr<DataSourceConfig> config_;
  std::vector<std::string> producer_name_filter_;

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<3> _has_field_{};
};


class PERFETTO_EXPORT TraceConfig_BufferConfig : public ::protozero::CppMessageObj {
 public:
  using FillPolicy = TraceConfig_BufferConfig_FillPolicy;
  static constexpr auto UNSPECIFIED = TraceConfig_BufferConfig_FillPolicy_UNSPECIFIED;
  static constexpr auto RING_BUFFER = TraceConfig_BufferConfig_FillPolicy_RING_BUFFER;
  static constexpr auto DISCARD = TraceConfig_BufferConfig_FillPolicy_DISCARD;
  enum FieldNumbers {
    kSizeKbFieldNumber = 1,
    kFillPolicyFieldNumber = 4,
  };

  TraceConfig_BufferConfig();
  ~TraceConfig_BufferConfig() override;
  TraceConfig_BufferConfig(TraceConfig_BufferConfig&&) noexcept;
  TraceConfig_BufferConfig& operator=(TraceConfig_BufferConfig&&);
  TraceConfig_BufferConfig(const TraceConfig_BufferConfig&);
  TraceConfig_BufferConfig& operator=(const TraceConfig_BufferConfig&);
  bool operator==(const TraceConfig_BufferConfig&) const;
  bool operator!=(const TraceConfig_BufferConfig& other) const { return !(*this == other); }

  bool ParseFromArray(const void*, size_t) override;
  std::string SerializeAsString() const override;
  std::vector<uint8_t> SerializeAsArray() const override;
  void Serialize(::protozero::Message*) const;
  // (DEPRECATED) Conversion methods from/to libprotobuf types.
  // These two will go away soon, see go/perfetto-libprotobuf.
  template <typename T /*perfetto::protos::gen::TraceConfig_BufferConfig*/> void FromProto(const T& pb_obj) { ParseFromString(pb_obj.SerializeAsString()); }
  template <typename T /*perfetto::protos::gen::TraceConfig_BufferConfig*/> void ToProto(T* pb_obj) const { pb_obj->Clear(); pb_obj->ParseFromString(SerializeAsString()); }

  bool has_size_kb() const { return _has_field_[1]; }
  uint32_t size_kb() const { return size_kb_; }
  void set_size_kb(uint32_t value) { size_kb_ = value; _has_field_.set(1); }

  bool has_fill_policy() const { return _has_field_[4]; }
  TraceConfig_BufferConfig_FillPolicy fill_policy() const { return fill_policy_; }
  void set_fill_policy(TraceConfig_BufferConfig_FillPolicy value) { fill_policy_ = value; _has_field_.set(4); }

 private:
  uint32_t size_kb_{};
  TraceConfig_BufferConfig_FillPolicy fill_policy_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;

  std::bitset<5> _has_field_{};
};

}  // namespace perfetto
}  // namespace protos
}  // namespace gen

#endif  // PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_TRACE_CONFIG_PROTO_CPP_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_TRACING_CORE_TRACE_CONFIG_H_
#define INCLUDE_PERFETTO_TRACING_CORE_TRACE_CONFIG_H_

// Creates the aliases in the ::perfetto namespace, doing things like:
// using ::perfetto::Foo = ::perfetto::protos::gen::Foo.
// See comments in forward_decls.h for the historical reasons of this
// indirection layer.
// gen_amalgamated expanded: #include "perfetto/tracing/core/forward_decls.h"

// gen_amalgamated expanded: #include "protos/perfetto/config/trace_config.gen.h"

#endif  // INCLUDE_PERFETTO_TRACING_CORE_TRACE_CONFIG_H_
// gen_amalgamated begin header: /Users/primiano/code/perfetto/tools/../include/perfetto/tracing/data_source.h
// gen_amalgamated begin header: /Users/primiano/code/perfetto/tools/../include/perfetto/base/compiler.h
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_BASE_COMPILER_H_
#define INCLUDE_PERFETTO_BASE_COMPILER_H_

#include <type_traits>

#define PERFETTO_LIKELY(_x) __builtin_expect(!!(_x), 1)
#define PERFETTO_UNLIKELY(_x) __builtin_expect(!!(_x), 0)

#if defined(__GNUC__) || defined(__clang__)
#define PERFETTO_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
#define PERFETTO_WARN_UNUSED_RESULT
#endif

#if defined(__clang__)
#define PERFETTO_ALWAYS_INLINE __attribute__((__always_inline__))
#define PERFETTO_NO_INLINE __attribute__((__noinline__))
#else
// GCC is too pedantic and often fails with the error:
// "always_inline function might not be inlinable"
#define PERFETTO_ALWAYS_INLINE
#define PERFETTO_NO_INLINE
#endif

#if defined(__GNUC__) || defined(__clang__)
#define PERFETTO_DEBUG_FUNCTION_IDENTIFIER() __PRETTY_FUNCTION__
#elif defined(_MSC_VER)
#define PERFETTO_DEBUG_FUNCTION_IDENTIFIER() __FUNCSIG__
#else
#define PERFETTO_DEBUG_FUNCTION_IDENTIFIER() \
  static_assert(false, "Not implemented for this compiler")
#endif

namespace perfetto {
namespace base {

template <typename... T>
inline void ignore_result(const T&...) {}

}  // namespace base
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_BASE_COMPILER_H_
// gen_amalgamated begin header: /Users/primiano/code/perfetto/tools/../include/perfetto/protozero/message.h
// gen_amalgamated begin header: /Users/primiano/code/perfetto/tools/../include/perfetto/base/logging.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_BASE_LOGGING_H_
#define INCLUDE_PERFETTO_BASE_LOGGING_H_

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>  // For strerror.

// gen_amalgamated expanded: #include "perfetto/base/build_config.h"
// gen_amalgamated expanded: #include "perfetto/base/compiler.h"

// TODO(primiano): movee this to base/build_config.h, turn into
// PERFETTO_BUILDFLAG(DCHECK_IS_ON) and update call sites to use that instead.
#if defined(NDEBUG) && !defined(DCHECK_ALWAYS_ON)
#define PERFETTO_DCHECK_IS_ON() 0
#else
#define PERFETTO_DCHECK_IS_ON() 1
#endif

#if PERFETTO_BUILDFLAG(PERFETTO_FORCE_DLOG_ON)
#define PERFETTO_DLOG_IS_ON() 1
#elif PERFETTO_BUILDFLAG(PERFETTO_FORCE_DLOG_OFF)
#define PERFETTO_DLOG_IS_ON() 0
#else
#define PERFETTO_DLOG_IS_ON() PERFETTO_DCHECK_IS_ON()
#endif

#if defined(PERFETTO_ANDROID_ASYNC_SAFE_LOG)
#if !PERFETTO_BUILDFLAG(PERFETTO_OS_ANDROID) || \
    !PERFETTO_BUILDFLAG(PERFETTO_ANDROID_BUILD)
#error "Async-safe logging is limited to Android tree builds"
#endif
// For binaries which need a very lightweight logging implementation.
// Note that this header is incompatible with android/log.h.
#include <async_safe/log.h>
#elif PERFETTO_BUILDFLAG(PERFETTO_OS_ANDROID)
// Normal android logging.
#include <android/log.h>
#endif

#if !PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)
#include <unistd.h>
#endif

namespace perfetto {
namespace base {

// Constexpr functions to extract basename(__FILE__), e.g.: ../foo/f.c -> f.c .
constexpr const char* StrEnd(const char* s) {
  return *s ? StrEnd(s + 1) : s;
}

constexpr const char* BasenameRecursive(const char* s,
                                        const char* begin,
                                        const char* end) {
  return (*s == '/' && s < end)
             ? (s + 1)
             : ((s > begin) ? BasenameRecursive(s - 1, begin, end) : s);
}

constexpr const char* Basename(const char* str) {
  return BasenameRecursive(StrEnd(str), str, StrEnd(str));
}

#define PERFETTO_LOG_LINE__(x) #x
#define PERFETTO_LOG_LINE_(x) PERFETTO_LOG_LINE__(x)
#define PERFETTO_LOG_LINE PERFETTO_LOG_LINE_(__LINE__)

enum LogLev { kLogDebug = 0, kLogInfo, kLogImportant, kLogError };
#if PERFETTO_BUILDFLAG(PERFETTO_OS_WIN) || PERFETTO_BUILDFLAG(PERFETTO_OS_WASM)
// The escape sequences don't work in a Windows command prompt.
#define PERFETTO_XLOG_STDERR(level, fmt, ...)                              \
  fprintf(stderr, "%-24.24s " fmt "\n",                                    \
          ::perfetto::base::Basename(__FILE__ "(" PERFETTO_LOG_LINE "):"), \
          ##__VA_ARGS__)
#else
constexpr const char* kLogFmt[] = {"\x1b[2m", "\x1b[39m", "\x1b[32m\x1b[1m",
                                   "\x1b[31m"};

#define PERFETTO_XLOG_STDERR(level, fmt, ...)                         \
  fprintf(stderr, "\x1b[90m%-24.24s\x1b[0m %s" fmt "\x1b[0m\n",       \
          ::perfetto::base::Basename(__FILE__ ":" PERFETTO_LOG_LINE), \
          ::perfetto::base::kLogFmt[::perfetto::base::LogLev::level], \
          ##__VA_ARGS__)
#endif

#if PERFETTO_BUILDFLAG(PERFETTO_OS_ANDROID) && \
    defined(PERFETTO_ANDROID_ASYNC_SAFE_LOG)
#define PERFETTO_XLOG(level, fmt, ...)                                         \
  do {                                                                         \
    async_safe_format_log(                                                     \
        (ANDROID_LOG_DEBUG + ::perfetto::base::LogLev::level), "perfetto",     \
        "%s " fmt, ::perfetto::base::Basename(__FILE__ ":" PERFETTO_LOG_LINE), \
        ##__VA_ARGS__);                                                        \
  } while (0)
#elif PERFETTO_BUILDFLAG(PERFETTO_OS_ANDROID)
// Standard logging marco on Android - log to both stderr and logcat. When part
// of the Android tree, stderr points to /dev/null so logcat is the only way to
// get some logging.
#define PERFETTO_XLOG(level, fmt, ...)                                         \
  do {                                                                         \
    __android_log_print(                                                       \
        (ANDROID_LOG_DEBUG + ::perfetto::base::LogLev::level), "perfetto",     \
        "%s " fmt, ::perfetto::base::Basename(__FILE__ ":" PERFETTO_LOG_LINE), \
        ##__VA_ARGS__);                                                        \
    PERFETTO_XLOG_STDERR(level, fmt, ##__VA_ARGS__);                           \
  } while (0)
#else
#define PERFETTO_XLOG PERFETTO_XLOG_STDERR
#endif

#define PERFETTO_IMMEDIATE_CRASH() \
  do {                             \
    __builtin_trap();              \
    __builtin_unreachable();       \
  } while (0)

#define PERFETTO_LOG(fmt, ...) PERFETTO_XLOG(kLogInfo, fmt, ##__VA_ARGS__)
#define PERFETTO_ILOG(fmt, ...) PERFETTO_XLOG(kLogImportant, fmt, ##__VA_ARGS__)
#define PERFETTO_ELOG(fmt, ...) PERFETTO_XLOG(kLogError, fmt, ##__VA_ARGS__)
#define PERFETTO_FATAL(fmt, ...)       \
  do {                                 \
    PERFETTO_PLOG(fmt, ##__VA_ARGS__); \
    PERFETTO_IMMEDIATE_CRASH();        \
  } while (0)

#define PERFETTO_PLOG(x, ...) \
  PERFETTO_ELOG(x " (errno: %d, %s)", ##__VA_ARGS__, errno, strerror(errno))

#if PERFETTO_DLOG_IS_ON()

#define PERFETTO_DLOG(fmt, ...) PERFETTO_XLOG(kLogDebug, fmt, ##__VA_ARGS__)

#define PERFETTO_DPLOG(x, ...) \
  PERFETTO_DLOG(x " (errno: %d, %s)", ##__VA_ARGS__, errno, strerror(errno))

#else

#define PERFETTO_DLOG(...) ::perfetto::base::ignore_result(__VA_ARGS__)
#define PERFETTO_DPLOG(...) ::perfetto::base::ignore_result(__VA_ARGS__)

#endif  // PERFETTO_DLOG_IS_ON()

#if PERFETTO_DCHECK_IS_ON()

#define PERFETTO_DCHECK(x)                           \
  do {                                               \
    if (PERFETTO_UNLIKELY(!(x))) {                   \
      PERFETTO_PLOG("%s", "PERFETTO_CHECK(" #x ")"); \
      PERFETTO_IMMEDIATE_CRASH();                    \
    }                                                \
  } while (0)

#define PERFETTO_DFATAL(fmt, ...)      \
  do {                                 \
    PERFETTO_PLOG(fmt, ##__VA_ARGS__); \
    PERFETTO_IMMEDIATE_CRASH();        \
  } while (0)

#define PERFETTO_DFATAL_OR_ELOG(...) PERFETTO_DFATAL(__VA_ARGS__)

#else

#define PERFETTO_DCHECK(x) \
  do {                     \
  } while (false && (x))

#define PERFETTO_DFATAL(...) ::perfetto::base::ignore_result(__VA_ARGS__)
#define PERFETTO_DFATAL_OR_ELOG(...) PERFETTO_ELOG(__VA_ARGS__)

#endif  // PERFETTO_DCHECK_IS_ON()

#if PERFETTO_DCHECK_IS_ON()
#define PERFETTO_CHECK(x) PERFETTO_DCHECK(x)
#else
#define PERFETTO_CHECK(x)                            \
  do {                                               \
    if (PERFETTO_UNLIKELY(!(x))) {                   \
      PERFETTO_PLOG("%s", "PERFETTO_CHECK(" #x ")"); \
      PERFETTO_IMMEDIATE_CRASH();                    \
    }                                                \
  } while (0)

#endif  // PERFETTO_DCHECK_IS_ON()

}  // namespace base
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_BASE_LOGGING_H_
// gen_amalgamated begin header: /Users/primiano/code/perfetto/tools/../include/perfetto/protozero/contiguous_memory_range.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_PROTOZERO_CONTIGUOUS_MEMORY_RANGE_H_
#define INCLUDE_PERFETTO_PROTOZERO_CONTIGUOUS_MEMORY_RANGE_H_

#include <assert.h>
#include <stddef.h>
#include <stdint.h>

namespace protozero {

// Keep this struct trivially constructible (no ctors, no default initializers).
struct ContiguousMemoryRange {
  uint8_t* begin;
  uint8_t* end;  // STL style: one byte past the end of the buffer.

  inline bool is_valid() const { return begin != nullptr; }
  inline void reset() { begin = nullptr; }
  inline size_t size() { return static_cast<size_t>(end - begin); }
};

}  // namespace protozero

#endif  // INCLUDE_PERFETTO_PROTOZERO_CONTIGUOUS_MEMORY_RANGE_H_
// gen_amalgamated begin header: /Users/primiano/code/perfetto/tools/../include/perfetto/protozero/proto_utils.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_PROTOZERO_PROTO_UTILS_H_
#define INCLUDE_PERFETTO_PROTOZERO_PROTO_UTILS_H_

#include <inttypes.h>
#include <stddef.h>

#include <type_traits>

// gen_amalgamated expanded: #include "perfetto/base/logging.h"

namespace protozero {
namespace proto_utils {

// See https://developers.google.com/protocol-buffers/docs/encoding wire types.
// This is a type encoded into the proto that provides just enough info to
// find the length of the following value.
enum class ProtoWireType : uint32_t {
  kVarInt = 0,
  kFixed64 = 1,
  kLengthDelimited = 2,
  kFixed32 = 5,
};

// This is the type defined in the proto for each field. This information
// is used to decide the translation strategy when writing the trace.
enum class ProtoSchemaType {
  kUnknown = 0,
  kDouble,
  kFloat,
  kInt64,
  kUint64,
  kInt32,
  kFixed64,
  kFixed32,
  kBool,
  kString,
  kGroup,  // Deprecated (proto2 only)
  kMessage,
  kBytes,
  kUint32,
  kEnum,
  kSfixed32,
  kSfixed64,
  kSint32,
  kSint64,
};

inline const char* ProtoSchemaToString(ProtoSchemaType v) {
  switch (v) {
    case ProtoSchemaType::kUnknown:
      return "unknown";
    case ProtoSchemaType::kDouble:
      return "double";
    case ProtoSchemaType::kFloat:
      return "float";
    case ProtoSchemaType::kInt64:
      return "int64";
    case ProtoSchemaType::kUint64:
      return "uint64";
    case ProtoSchemaType::kInt32:
      return "int32";
    case ProtoSchemaType::kFixed64:
      return "fixed64";
    case ProtoSchemaType::kFixed32:
      return "fixed32";
    case ProtoSchemaType::kBool:
      return "bool";
    case ProtoSchemaType::kString:
      return "string";
    case ProtoSchemaType::kGroup:
      return "group";
    case ProtoSchemaType::kMessage:
      return "message";
    case ProtoSchemaType::kBytes:
      return "bytes";
    case ProtoSchemaType::kUint32:
      return "uint32";
    case ProtoSchemaType::kEnum:
      return "enum";
    case ProtoSchemaType::kSfixed32:
      return "sfixed32";
    case ProtoSchemaType::kSfixed64:
      return "sfixed64";
    case ProtoSchemaType::kSint32:
      return "sint32";
    case ProtoSchemaType::kSint64:
      return "sint64";
  }
  // For gcc:
  PERFETTO_DCHECK(false);
  return "";
}

// Maximum message size supported: 256 MiB (4 x 7-bit due to varint encoding).
constexpr size_t kMessageLengthFieldSize = 4;
constexpr size_t kMaxMessageLength = (1u << (kMessageLengthFieldSize * 7)) - 1;

// Field tag is encoded as 32-bit varint (5 bytes at most).
// Largest value of simple (not length-delimited) field is 64-bit varint
// (10 bytes at most). 15 bytes buffer is enough to store a simple field.
constexpr size_t kMaxTagEncodedSize = 5;
constexpr size_t kMaxSimpleFieldEncodedSize = kMaxTagEncodedSize + 10;

// Proto types: (int|uint|sint)(32|64), bool, enum.
constexpr uint32_t MakeTagVarInt(uint32_t field_id) {
  return (field_id << 3) | static_cast<uint32_t>(ProtoWireType::kVarInt);
}

// Proto types: fixed64, sfixed64, fixed32, sfixed32, double, float.
template <typename T>
constexpr uint32_t MakeTagFixed(uint32_t field_id) {
  static_assert(sizeof(T) == 8 || sizeof(T) == 4, "Value must be 4 or 8 bytes");
  return (field_id << 3) |
         static_cast<uint32_t>((sizeof(T) == 8 ? ProtoWireType::kFixed64
                                               : ProtoWireType::kFixed32));
}

// Proto types: string, bytes, embedded messages.
constexpr uint32_t MakeTagLengthDelimited(uint32_t field_id) {
  return (field_id << 3) |
         static_cast<uint32_t>(ProtoWireType::kLengthDelimited);
}

// Proto types: sint64, sint32.
template <typename T>
inline typename std::make_unsigned<T>::type ZigZagEncode(T value) {
  using UnsignedType = typename std::make_unsigned<T>::type;

  // Right-shift of negative values is implementation specific.
  // Assert the implementation does what we expect, which is that shifting any
  // positive value by sizeof(T) * 8 - 1 gives an all 0 bitmap, and a negative
  // value gives and all 1 bitmap.
  constexpr uint64_t kUnsignedZero = 0u;
  constexpr int64_t kNegativeOne = -1;
  constexpr int64_t kPositiveOne = 1;
  static_assert(static_cast<uint64_t>(kNegativeOne >> 63) == ~kUnsignedZero,
                "implementation does not support assumed rightshift");
  static_assert(static_cast<uint64_t>(kPositiveOne >> 63) == kUnsignedZero,
                "implementation does not support assumed rightshift");

  return (static_cast<UnsignedType>(value) << 1) ^
         static_cast<UnsignedType>(value >> (sizeof(T) * 8 - 1));
}

// Proto types: sint64, sint32.
template <typename T>
inline typename std::make_signed<T>::type ZigZagDecode(T value) {
  using UnsignedType = typename std::make_unsigned<T>::type;
  auto u_value = static_cast<UnsignedType>(value);
  return static_cast<typename std::make_signed<T>::type>(
      ((u_value >> 1) ^ -(u_value & 1)));
}

template <typename T>
inline uint8_t* WriteVarInt(T value, uint8_t* target) {
  // If value is <= 0 we must first sign extend to int64_t (see [1]).
  // Finally we always cast to an unsigned value to to avoid arithmetic
  // (sign expanding) shifts in the while loop.
  // [1]: "If you use int32 or int64 as the type for a negative number, the
  // resulting varint is always ten bytes long".
  // - developers.google.com/protocol-buffers/docs/encoding
  // So for each input type we do the following casts:
  // uintX_t -> uintX_t -> uintX_t
  // int8_t  -> int64_t -> uint64_t
  // int16_t -> int64_t -> uint64_t
  // int32_t -> int64_t -> uint64_t
  // int64_t -> int64_t -> uint64_t
  using MaybeExtendedType =
      typename std::conditional<std::is_unsigned<T>::value, T, int64_t>::type;
  using UnsignedType = typename std::make_unsigned<MaybeExtendedType>::type;

  MaybeExtendedType extended_value = static_cast<MaybeExtendedType>(value);
  UnsignedType unsigned_value = static_cast<UnsignedType>(extended_value);

  while (unsigned_value >= 0x80) {
    *target++ = static_cast<uint8_t>(unsigned_value) | 0x80;
    unsigned_value >>= 7;
  }
  *target = static_cast<uint8_t>(unsigned_value);
  return target + 1;
}

// Writes a fixed-size redundant encoding of the given |value|. This is
// used to backfill fixed-size reservations for the length field using a
// non-canonical varint encoding (e.g. \x81\x80\x80\x00 instead of \x01).
// See https://github.com/google/protobuf/issues/1530.
// In particular, this is used for nested messages. The size of a nested message
// is not known until all its field have been written. |kMessageLengthFieldSize|
// bytes are reserved to encode the size field and backfilled at the end.
inline void WriteRedundantVarInt(uint32_t value, uint8_t* buf) {
  for (size_t i = 0; i < kMessageLengthFieldSize; ++i) {
    const uint8_t msb = (i < kMessageLengthFieldSize - 1) ? 0x80 : 0;
    buf[i] = static_cast<uint8_t>(value) | msb;
    value >>= 7;
  }
}

template <uint32_t field_id>
void StaticAssertSingleBytePreamble() {
  static_assert(field_id < 16,
                "Proto field id too big to fit in a single byte preamble");
}

// Parses a VarInt from the encoded buffer [start, end). |end| is STL-style and
// points one byte past the end of buffer.
// The parsed int value is stored in the output arg |value|. Returns a pointer
// to the next unconsumed byte (so start < retval <= end) or |start| if the
// VarInt could not be fully parsed because there was not enough space in the
// buffer.
inline const uint8_t* ParseVarInt(const uint8_t* start,
                                  const uint8_t* end,
                                  uint64_t* out_value) {
  const uint8_t* pos = start;
  uint64_t value = 0;
  for (uint32_t shift = 0; pos < end && shift < 64u; shift += 7) {
    // Cache *pos into |cur_byte| to prevent that the compiler dereferences the
    // pointer twice (here and in the if() below) due to char* aliasing rules.
    uint8_t cur_byte = *pos++;
    value |= static_cast<uint64_t>(cur_byte & 0x7f) << shift;
    if ((cur_byte & 0x80) == 0) {
      // In valid cases we get here.
      *out_value = value;
      return pos;
    }
  }
  *out_value = 0;
  return start;
}

}  // namespace proto_utils
}  // namespace protozero

#endif  // INCLUDE_PERFETTO_PROTOZERO_PROTO_UTILS_H_
// gen_amalgamated begin header: /Users/primiano/code/perfetto/tools/../include/perfetto/protozero/scattered_stream_writer.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_PROTOZERO_SCATTERED_STREAM_WRITER_H_
#define INCLUDE_PERFETTO_PROTOZERO_SCATTERED_STREAM_WRITER_H_

#include <assert.h>
#include <stddef.h>
#include <stdint.h>
#include <string.h>

// gen_amalgamated expanded: #include "perfetto/base/compiler.h"
// gen_amalgamated expanded: #include "perfetto/base/export.h"
// gen_amalgamated expanded: #include "perfetto/protozero/contiguous_memory_range.h"

namespace protozero {

// This class deals with the following problem: append-only proto messages want
// to write a stream of bytes, without caring about the implementation of the
// underlying buffer (which concretely will be either the trace ring buffer
// or a heap-allocated buffer). The main deal is: proto messages don't know in
// advance what their size will be.
// Due to the tracing buffer being split into fixed-size chunks, on some
// occasions, these writes need to be spread over two (or more) non-contiguous
// chunks of memory. Similarly, when the buffer is backed by the heap, we want
// to avoid realloc() calls, as they might cause a full copy of the contents
// of the buffer.
// The purpose of this class is to abstract away the non-contiguous write logic.
// This class knows how to deal with writes as long as they fall in the same
// ContiguousMemoryRange and defers the chunk-chaining logic to the Delegate.
class PERFETTO_EXPORT ScatteredStreamWriter {
 public:
  class PERFETTO_EXPORT Delegate {
   public:
    virtual ~Delegate();
    virtual ContiguousMemoryRange GetNewBuffer() = 0;
  };

  explicit ScatteredStreamWriter(Delegate* delegate);
  ~ScatteredStreamWriter();

  inline void WriteByte(uint8_t value) {
    if (write_ptr_ >= cur_range_.end)
      Extend();
    *write_ptr_++ = value;
  }

  // Assumes that the caller checked that there is enough headroom.
  // TODO(primiano): perf optimization, this is a tracing hot path. The
  // compiler can make strong optimization on memcpy if the size arg is a
  // constexpr. Make a templated variant of this for fixed-size writes.
  // TODO(primiano): restrict / noalias might also help.
  inline void WriteBytesUnsafe(const uint8_t* src, size_t size) {
    uint8_t* const end = write_ptr_ + size;
    assert(end <= cur_range_.end);
    memcpy(write_ptr_, src, size);
    write_ptr_ = end;
  }

  inline void WriteBytes(const uint8_t* src, size_t size) {
    uint8_t* const end = write_ptr_ + size;
    if (PERFETTO_LIKELY(end <= cur_range_.end))
      return WriteBytesUnsafe(src, size);
    WriteBytesSlowPath(src, size);
  }

  void WriteBytesSlowPath(const uint8_t* src, size_t size);

  // Reserves a fixed amount of bytes to be backfilled later. The reserved range
  // is guaranteed to be contiguous and not span across chunks. |size| has to be
  // <= than the size of a new buffer returned by the Delegate::GetNewBuffer().
  uint8_t* ReserveBytes(size_t size);

  // Fast (but unsafe) version of the above. The caller must have previously
  // checked that there are at least |size| contiguous bytes available.
  // Returns only the start pointer of the reservation.
  uint8_t* ReserveBytesUnsafe(size_t size) {
    uint8_t* begin = write_ptr_;
    write_ptr_ += size;
    assert(write_ptr_ <= cur_range_.end);
    return begin;
  }

  // Resets the buffer boundaries and the write pointer to the given |range|.
  // Subsequent WriteByte(s) will write into |range|.
  void Reset(ContiguousMemoryRange range);

  // Number of contiguous free bytes in |cur_range_| that can be written without
  // requesting a new buffer.
  size_t bytes_available() const {
    return static_cast<size_t>(cur_range_.end - write_ptr_);
  }

  uint8_t* write_ptr() const { return write_ptr_; }

  uint64_t written() const {
    return written_previously_ +
           static_cast<uint64_t>(write_ptr_ - cur_range_.begin);
  }

 private:
  ScatteredStreamWriter(const ScatteredStreamWriter&) = delete;
  ScatteredStreamWriter& operator=(const ScatteredStreamWriter&) = delete;

  void Extend();

  Delegate* const delegate_;
  ContiguousMemoryRange cur_range_;
  uint8_t* write_ptr_;
  uint64_t written_previously_ = 0;
};

}  // namespace protozero

#endif  // INCLUDE_PERFETTO_PROTOZERO_SCATTERED_STREAM_WRITER_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_PROTOZERO_MESSAGE_H_
#define INCLUDE_PERFETTO_PROTOZERO_MESSAGE_H_

#include <assert.h>
#include <stdint.h>
#include <string.h>

#include <string>
#include <type_traits>

// gen_amalgamated expanded: #include "perfetto/base/export.h"
// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/protozero/contiguous_memory_range.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"
// gen_amalgamated expanded: #include "perfetto/protozero/scattered_stream_writer.h"

namespace perfetto {
namespace shm_fuzz {
class FakeProducer;
}  // namespace shm_fuzz
}  // namespace perfetto

namespace protozero {

class MessageHandleBase;

// Base class extended by the proto C++ stubs generated by the ProtoZero
// compiler. This class provides the minimal runtime required to support
// append-only operations and is designed for performance. None of the methods
// require any dynamic memory allocation.
class PERFETTO_EXPORT Message {
 public:
  friend class MessageHandleBase;

  // Adjust the |nested_messages_arena_| size when changing this, or the
  // static_assert in the .cc file will bark.
  static constexpr uint32_t kMaxNestingDepth = 10;

  // Ctor and Dtor of Message are never called, with the exeception
  // of root (non-nested) messages. Nested messages are allocated via placement
  // new in the |nested_messages_arena_| and implictly destroyed when the arena
  // of the root message goes away. This is fine as long as all the fields are
  // PODs, which is checked by the static_assert in the ctor (see the Reset()
  // method in the .cc file).
  Message() = default;

  // Clears up the state, allowing the message to be reused as a fresh one.
  void Reset(ScatteredStreamWriter*);

  // Commits all the changes to the buffer (backfills the size field of this and
  // all nested messages) and seals the message. Returns the size of the message
  // (and all nested sub-messages), without taking into account any chunking.
  // Finalize is idempotent and can be called several times w/o side effects.
  uint32_t Finalize();

  // Optional. If is_valid() == true, the corresponding memory region (its
  // length == proto_utils::kMessageLengthFieldSize) is backfilled with the size
  // of this message (minus |size_already_written| below). This is the mechanism
  // used by messages to backfill their corresponding size field in the parent
  // message.
  uint8_t* size_field() const { return size_field_; }
  void set_size_field(uint8_t* size_field) { size_field_ = size_field; }

  // This is to deal with case of backfilling the size of a root (non-nested)
  // message which is split into multiple chunks. Upon finalization only the
  // partial size that lies in the last chunk has to be backfilled.
  void inc_size_already_written(uint32_t sz) { size_already_written_ += sz; }

  Message* nested_message() { return nested_message_; }

  bool is_finalized() const { return finalized_; }

#if PERFETTO_DCHECK_IS_ON()
  void set_handle(MessageHandleBase* handle) { handle_ = handle; }
#endif

  // Proto types: uint64, uint32, int64, int32, bool, enum.
  template <typename T>
  void AppendVarInt(uint32_t field_id, T value) {
    if (nested_message_)
      EndNestedMessage();

    uint8_t buffer[proto_utils::kMaxSimpleFieldEncodedSize];
    uint8_t* pos = buffer;

    pos = proto_utils::WriteVarInt(proto_utils::MakeTagVarInt(field_id), pos);
    // WriteVarInt encodes signed values in two's complement form.
    pos = proto_utils::WriteVarInt(value, pos);
    WriteToStream(buffer, pos);
  }

  // Proto types: sint64, sint32.
  template <typename T>
  void AppendSignedVarInt(uint32_t field_id, T value) {
    AppendVarInt(field_id, proto_utils::ZigZagEncode(value));
  }

  // Proto types: bool, enum (small).
  // Faster version of AppendVarInt for tiny numbers.
  void AppendTinyVarInt(uint32_t field_id, int32_t value) {
    PERFETTO_DCHECK(0 <= value && value < 0x80);
    if (nested_message_)
      EndNestedMessage();

    uint8_t buffer[proto_utils::kMaxSimpleFieldEncodedSize];
    uint8_t* pos = buffer;
    // MakeTagVarInt gets super optimized here for constexpr.
    pos = proto_utils::WriteVarInt(proto_utils::MakeTagVarInt(field_id), pos);
    *pos++ = static_cast<uint8_t>(value);
    WriteToStream(buffer, pos);
  }

  // Proto types: fixed64, sfixed64, fixed32, sfixed32, double, float.
  template <typename T>
  void AppendFixed(uint32_t field_id, T value) {
    if (nested_message_)
      EndNestedMessage();

    uint8_t buffer[proto_utils::kMaxSimpleFieldEncodedSize];
    uint8_t* pos = buffer;

    pos = proto_utils::WriteVarInt(proto_utils::MakeTagFixed<T>(field_id), pos);
    memcpy(pos, &value, sizeof(T));
    pos += sizeof(T);
    // TODO: Optimize memcpy performance, see http://crbug.com/624311 .
    WriteToStream(buffer, pos);
  }

  void AppendString(uint32_t field_id, const char* str);

  void AppendString(uint32_t field_id, const std::string& str) {
    AppendBytes(field_id, str.data(), str.size());
  }

  void AppendBytes(uint32_t field_id, const void* value, size_t size);

  // Append raw bytes for a field, using the supplied |ranges| to
  // copy from |num_ranges| individual buffers.
  size_t AppendScatteredBytes(uint32_t field_id,
                              ContiguousMemoryRange* ranges,
                              size_t num_ranges);

  // Begins a nested message, using the static storage provided by the parent
  // class (see comment in |nested_messages_arena_|). The nested message ends
  // either when Finalize() is called or when any other Append* method is called
  // in the parent class.
  // The template argument T is supposed to be a stub class auto generated from
  // a .proto, hence a subclass of Message.
  template <class T>
  T* BeginNestedMessage(uint32_t field_id) {
    // This is to prevent subclasses (which should be autogenerated, though), to
    // introduce extra state fields (which wouldn't be initialized by Reset()).
    static_assert(std::is_base_of<Message, T>::value,
                  "T must be a subclass of Message");
    static_assert(sizeof(T) == sizeof(Message),
                  "Message subclasses cannot introduce extra state.");
    T* message = reinterpret_cast<T*>(nested_messages_arena_);
    BeginNestedMessageInternal(field_id, message);
    return message;
  }

  ScatteredStreamWriter* stream_writer_for_testing() { return stream_writer_; }

  // Appends some raw bytes to the message. The use-case for this is preserving
  // unknown fields in the decode -> re-encode path of xxx.gen.cc classes
  // generated by the cppgen_plugin.cc.
  // The caller needs to guarantee that the appended data is properly
  // proto-encoded and each field has a proto preamble.
  void AppendRawProtoBytes(const void* data, size_t size) {
    const uint8_t* src = reinterpret_cast<const uint8_t*>(data);
    WriteToStream(src, src + size);
  }

 private:
  Message(const Message&) = delete;
  Message& operator=(const Message&) = delete;

  void BeginNestedMessageInternal(uint32_t field_id, Message*);

  // Called by Finalize and Append* methods.
  void EndNestedMessage();

  void WriteToStream(const uint8_t* src_begin, const uint8_t* src_end) {
    PERFETTO_DCHECK(!finalized_);
    PERFETTO_DCHECK(src_begin <= src_end);
    const uint32_t size = static_cast<uint32_t>(src_end - src_begin);
    stream_writer_->WriteBytes(src_begin, size);
    size_ += size;
  }

  // Only POD fields are allowed. This class's dtor is never called.
  // See the comment on the static_assert in the corresponding .cc file.

  // The stream writer interface used for the serialization.
  ScatteredStreamWriter* stream_writer_;

  uint8_t* size_field_;

  // Keeps track of the size of the current message.
  uint32_t size_;

  // See comment for inc_size_already_written().
  uint32_t size_already_written_;

  // When true, no more changes to the message are allowed. This is to DCHECK
  // attempts of writing to a message which has been Finalize()-d.
  bool finalized_;

  // Used to detect attemps to create messages with a nesting level >
  // kMaxNestingDepth. |nesting_depth_| == 0 for root (non-nested) messages.
  uint8_t nesting_depth_;

#if PERFETTO_DCHECK_IS_ON()
  // Current generation of message. Incremented on Reset.
  // Used to detect stale handles.
  uint32_t generation_;

  MessageHandleBase* handle_;
#endif

  // Pointer to the last child message created through BeginNestedMessage(), if
  // any, nullptr otherwise. There is no need to keep track of more than one
  // message per nesting level as the proto-zero API contract mandates that
  // nested fields can be filled only in a stacked fashion. In other words,
  // nested messages are finalized and sealed when any other field is set in the
  // parent message (or the parent message itself is finalized) and cannot be
  // accessed anymore afterwards.
  // TODO(primiano): optimization: I think that nested_message_, when non-null.
  // will always be @ (this) + offsetof(nested_messages_arena_).
  Message* nested_message_;

  // The root message owns the storage for all its nested messages, up to a max
  // of kMaxNestingDepth levels (see the .cc file). Note that the boundaries of
  // the arena are meaningful only for the root message.
  // Unfortunately we cannot put the sizeof() math here because we cannot sizeof
  // the current class in a header. However the .cc file has a static_assert
  // that guarantees that (see the Reset() method in the .cc file).
  alignas(sizeof(void*)) uint8_t nested_messages_arena_[512];

  // DO NOT add any fields below |nested_messages_arena_|. The memory layout of
  // nested messages would overflow the storage allocated by the root message.
};

}  // namespace protozero

#endif  // INCLUDE_PERFETTO_PROTOZERO_MESSAGE_H_
// gen_amalgamated begin header: /Users/primiano/code/perfetto/tools/../include/perfetto/protozero/message_handle.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_PROTOZERO_MESSAGE_HANDLE_H_
#define INCLUDE_PERFETTO_PROTOZERO_MESSAGE_HANDLE_H_

#include <functional>

// gen_amalgamated expanded: #include "perfetto/base/export.h"
// gen_amalgamated expanded: #include "perfetto/protozero/message.h"

namespace protozero {

class Message;

// MessageHandle allows to decouple the lifetime of a proto message
// from the underlying storage. It gives the following guarantees:
// - The underlying message is finalized (if still alive) if the handle goes
//   out of scope.
// - In Debug / DCHECK_ALWAYS_ON builds, the handle becomes null once the
//   message is finalized. This is to enforce the append-only API. For instance
//   when adding two repeated messages, the addition of the 2nd one forces
//   the finalization of the first.
// Think about this as a WeakPtr<Message> which calls
// Message::Finalize() when going out of scope.

class PERFETTO_EXPORT MessageHandleBase {
 public:
  class FinalizationListener {
   public:
    virtual ~FinalizationListener();
    virtual void OnMessageFinalized(Message* message) = 0;
  };

  ~MessageHandleBase();

  // Move-only type.
  MessageHandleBase(MessageHandleBase&&) noexcept;
  MessageHandleBase& operator=(MessageHandleBase&&);
  explicit operator bool() const {
#if PERFETTO_DCHECK_IS_ON()
    PERFETTO_DCHECK(!message_ || generation_ == message_->generation_);
#endif
    return !!message_;
  }

  void set_finalization_listener(FinalizationListener* listener) {
    listener_ = listener;
  }

 protected:
  explicit MessageHandleBase(Message* = nullptr);
  Message* operator->() const {
#if PERFETTO_DCHECK_IS_ON()
    PERFETTO_DCHECK(!message_ || generation_ == message_->generation_);
#endif
    return message_;
  }
  Message& operator*() const { return *(operator->()); }

 private:
  friend class Message;
  MessageHandleBase(const MessageHandleBase&) = delete;
  MessageHandleBase& operator=(const MessageHandleBase&) = delete;

  void reset_message() {
    // This is called by Message::Finalize().
    PERFETTO_DCHECK(message_->is_finalized());
    message_ = nullptr;
    listener_ = nullptr;
  }

  void Move(MessageHandleBase&&);

  void FinalizeMessage() {
    // |message_| and |listener_| may be cleared by reset_message() during
    // Message::Finalize().
    auto* listener = listener_;
    auto* message = message_;
    message->Finalize();
    if (listener)
      listener->OnMessageFinalized(message);
  }

  Message* message_;
  FinalizationListener* listener_ = nullptr;
#if PERFETTO_DCHECK_IS_ON()
  uint32_t generation_;
#endif
};

template <typename T>
class MessageHandle : public MessageHandleBase {
 public:
  MessageHandle() : MessageHandle(nullptr) {}
  explicit MessageHandle(T* message) : MessageHandleBase(message) {}

  T& operator*() const {
    return static_cast<T&>(MessageHandleBase::operator*());
  }

  T* operator->() const {
    return static_cast<T*>(MessageHandleBase::operator->());
  }
};

}  // namespace protozero

#endif  // INCLUDE_PERFETTO_PROTOZERO_MESSAGE_HANDLE_H_
// gen_amalgamated begin header: /Users/primiano/code/perfetto/tools/../include/perfetto/tracing/internal/basic_types.h
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_TRACING_INTERNAL_BASIC_TYPES_H_
#define INCLUDE_PERFETTO_TRACING_INTERNAL_BASIC_TYPES_H_

#include <stddef.h>
#include <stdint.h>

namespace perfetto {
namespace internal {

// A static_assert in tracing_muxer_impl.cc guarantees that this stays in sync
// with the definition in tracing/core/basic_types.h
using BufferId = uint16_t;

// This is a direct index in the TracingMuxer::backends_ vector.
// Backends are only added and never removed.
using TracingBackendId = size_t;

// Max numbers of data sources that can be registered in a process.
constexpr size_t kMaxDataSources = 32;

// Max instances for each data source type. This typically matches the
// "max number of concurrent tracing sessions". However remember that a data
// source can be instantiated more than once within one tracing session by
// creating two entries for it in the trace config.
constexpr size_t kMaxDataSourceInstances = 8;

}  // namespace internal
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_TRACING_INTERNAL_BASIC_TYPES_H_
// gen_amalgamated begin header: /Users/primiano/code/perfetto/tools/../include/perfetto/tracing/internal/data_source_internal.h
// gen_amalgamated begin header: /Users/primiano/code/perfetto/tools/../include/perfetto/tracing/trace_writer_base.h
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_TRACING_TRACE_WRITER_BASE_H_
#define INCLUDE_PERFETTO_TRACING_TRACE_WRITER_BASE_H_

// gen_amalgamated expanded: #include "perfetto/protozero/message_handle.h"

namespace perfetto {

namespace protos {
namespace pbzero {
class TracePacket;
}  // namespace pbzero
}  // namespace protos

// The bare-minimum subset of the TraceWriter interface that is exposed as a
// fully public API.
// See comments in /include/perfetto/ext/tracing/core/trace_writer.h.
class TraceWriterBase {
 public:
  virtual ~TraceWriterBase();

  virtual protozero::MessageHandle<protos::pbzero::TracePacket>
  NewTracePacket() = 0;

  virtual void Flush(std::function<void()> callback = {}) = 0;
};

}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_TRACING_TRACE_WRITER_BASE_H_
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_TRACING_INTERNAL_DATA_SOURCE_INTERNAL_H_
#define INCLUDE_PERFETTO_TRACING_INTERNAL_DATA_SOURCE_INTERNAL_H_

#include <stddef.h>
#include <stdint.h>

#include <array>
#include <atomic>
#include <functional>
#include <memory>
#include <mutex>

// No perfetto headers (other than tracing/api and protozero) should be here.
// gen_amalgamated expanded: #include "perfetto/tracing/buffer_exhausted_policy.h"
// gen_amalgamated expanded: #include "perfetto/tracing/internal/basic_types.h"
// gen_amalgamated expanded: #include "perfetto/tracing/trace_writer_base.h"

namespace perfetto {

class DataSourceBase;
class TraceWriterBase;

namespace internal {

class TracingTLS;

// This maintains the internal state of a data source instance that is used only
// to implement the tracing mechanics and is not exposed to the API client.
// There is one of these object per DataSource instance (up to
// kMaxDataSourceInstances).
struct DataSourceState {
  // This boolean flag determines whether the DataSource::Trace() method should
  // do something or be a no-op. This flag doesn't give the full guarantee
  // that tracing data will be visible in the trace, it just makes it so that
  // the client attemps writing trace data and interacting with the service.
  // For instance, when a tracing session ends the service will reject data
  // commits that arrive too late even if the producer hasn't received the stop
  // IPC message.
  // This flag is set right before calling OnStart() and cleared right before
  // calling OnStop(), unless using HandleStopAsynchronously() (see comments
  // in data_source.h).
  // Keep this flag as the first field. This allows the compiler to directly
  // dereference the DataSourceState* pointer in the trace fast-path without
  // doing extra pointr arithmetic.
  bool trace_lambda_enabled = false;

  // The central buffer id that all TraceWriter(s) created by this data source
  // must target.
  BufferId buffer_id = 0;

  // The index within TracingMuxerImpl.backends_. Practically it allows to
  // lookup the Producer object, and hence the IPC channel, for this data
  // source.
  TracingBackendId backend_id = 0;

  // The instance id as assigned by the tracing service. Note that because a
  // process can be connected to >1 services, this ID is not globally unique but
  // is only unique within the scope of its backend.
  // Only the tuple (backend_id, data_source_instance_id) is globally unique.
  uint64_t data_source_instance_id = 0;

  // A hash of the trace config used by this instance. This is used to
  // de-duplicate instances for data sources with identical names (e.g., track
  // event).
  uint64_t config_hash = 0;

  // This lock is not held to implement Trace() and it's used only if the trace
  // code wants to access its own data source state.
  // This is to prevent that accessing the data source on an arbitrary embedder
  // thread races with the internal IPC thread destroying the data source
  // because of a end-of-tracing notification from the service.
  std::recursive_mutex lock;
  std::unique_ptr<DataSourceBase> data_source;
};

// This is to allow lazy-initialization and avoid static initializers and
// at-exit destructors. All the entries are initialized via placement-new when
// DataSource::Register() is called, see TracingMuxerImpl::RegisterDataSource().
struct DataSourceStateStorage {
  alignas(DataSourceState) char storage[sizeof(DataSourceState)]{};
};

// Per-DataSource-type global state.
struct DataSourceStaticState {
  // Unique index of the data source, assigned at registration time.
  uint32_t index = kMaxDataSources;

  // A bitmap that tells about the validity of each |instances| entry. When the
  // i-th bit of the bitmap it's set, instances[i] is valid.
  std::atomic<uint32_t> valid_instances{};
  std::array<DataSourceStateStorage, kMaxDataSourceInstances> instances{};

  // Can be used with a cached |valid_instances| bitmap.
  DataSourceState* TryGetCached(uint32_t cached_bitmap, size_t n) {
    return cached_bitmap & (1 << n)
               ? reinterpret_cast<DataSourceState*>(&instances[n])
               : nullptr;
  }

  DataSourceState* TryGet(size_t n) {
    return TryGetCached(valid_instances.load(std::memory_order_acquire), n);
  }

  void CompilerAsserts() {
    static_assert(sizeof(valid_instances.load()) * 8 >= kMaxDataSourceInstances,
                  "kMaxDataSourceInstances too high");
  }
};

// Per-DataSource-instance thread-local state.
struct DataSourceInstanceThreadLocalState {
  using IncrementalStatePointer = std::unique_ptr<void, void (*)(void*)>;

  void Reset() {
    trace_writer.reset();
    incremental_state.reset();
    backend_id = 0;
    buffer_id = 0;
  }

  std::unique_ptr<TraceWriterBase> trace_writer;
  IncrementalStatePointer incremental_state = {nullptr, [](void*) {}};
  TracingBackendId backend_id;
  BufferId buffer_id;
};

// Per-DataSource-type thread-local state.
struct DataSourceThreadLocalState {
  DataSourceStaticState* static_state = nullptr;

  // Pointer to the parent tls object that holds us. Used to retrieve the
  // generation, which is per-global-TLS and not per data-source.
  TracingTLS* root_tls = nullptr;

  // One entry per each data source instance.
  std::array<DataSourceInstanceThreadLocalState, kMaxDataSourceInstances>
      per_instance{};
};

}  // namespace internal
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_TRACING_INTERNAL_DATA_SOURCE_INTERNAL_H_
// gen_amalgamated begin header: /Users/primiano/code/perfetto/tools/../include/perfetto/tracing/internal/tracing_muxer.h
// gen_amalgamated begin header: /Users/primiano/code/perfetto/tools/../include/perfetto/tracing/internal/tracing_tls.h
// gen_amalgamated begin header: /Users/primiano/code/perfetto/tools/../include/perfetto/tracing/platform.h
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_TRACING_PLATFORM_H_
#define INCLUDE_PERFETTO_TRACING_PLATFORM_H_

#include <stddef.h>
#include <stdint.h>

#include <functional>
#include <memory>

// gen_amalgamated expanded: #include "perfetto/base/export.h"

namespace perfetto {

namespace base {
class TaskRunner;
}  // namespace base

// This abstract class is used to abstract dependencies on platform-specific
// primitives that cannot be implemented by the perfetto codebase and must be
// provided or overridden by the embedder.
// This is, for instance, for cases where we want to use some particular
// base:: class in Chrome and provide instead POSIX fallbacks for other
// embedders.

// Base class for thread-local objects. This is to get a basic object vtable and
// delegate destruction to the embedder. See Platform::CreateThreadLocalObject.
class PlatformThreadLocalObject {
 public:
  // Implemented by perfetto internal code. The embedder must call this when
  // implementing GetOrCreateThreadLocalObject() to create an instance for the
  // first time on each thread.
  static std::unique_ptr<PlatformThreadLocalObject> CreateInstance();
  virtual ~PlatformThreadLocalObject();
};

class PERFETTO_EXPORT Platform {
 public:
  // Embedders can use this unless they have custom needs (e.g. Chrome wanting
  // to use its own base class for TLS).
  static Platform* GetDefaultPlatform();

  virtual ~Platform();

  // Creates a thread-local object. The embedder must:
  // - Create an instance per-thread calling ThreadLocalObject::CreateInstance.
  // - Own the lifetime of the returned object as long as the thread is alive.
  // - Destroy it when the thread exits.
  // Perfetto requires only one thread-local object overall (obviously, one
  // instance per-thread) from the embedder.
  using ThreadLocalObject = ::perfetto::PlatformThreadLocalObject;
  virtual ThreadLocalObject* GetOrCreateThreadLocalObject() = 0;

  // Creates a sequenced task runner. The easiest implementation is to create
  // a new thread (e.g. use base::ThreadTaskRunner) but this can also be
  // implemented in some more clever way (e.g. using chromiums's scheduler).
  struct CreateTaskRunnerArgs {};
  virtual std::unique_ptr<base::TaskRunner> CreateTaskRunner(
      const CreateTaskRunnerArgs&) = 0;

  // Used to derive the producer name. Mostly relevant when using the
  // kSystemBackend mode. It can be an arbitrary string when using the
  // in-process mode.
  virtual std::string GetCurrentProcessName() = 0;
};

}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_TRACING_PLATFORM_H_
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_TRACING_INTERNAL_TRACING_TLS_H_
#define INCLUDE_PERFETTO_TRACING_INTERNAL_TRACING_TLS_H_

#include <array>
#include <memory>

// gen_amalgamated expanded: #include "perfetto/tracing/internal/basic_types.h"
// gen_amalgamated expanded: #include "perfetto/tracing/internal/data_source_internal.h"
// gen_amalgamated expanded: #include "perfetto/tracing/platform.h"

namespace perfetto {

class TraceWriterBase;

namespace internal {

// Organization of the thread-local storage
// ----------------------------------------
// First of all, remember the cardinality of the problem: at any point in time
// there are M data sources registered (i.e. number of subclasses of DataSource)
// and up to N concurrent instances for each data source, so up to M * N total
// data source instances around.
// Each data source instance can be accessed by T threads (no upper bound).
// We can safely put hard limits both to M and N (i.e. say that we support at
// most 32 data source types per process and up to 8 concurrent instances).
//
// We want to make it so from the Platform viewpoint, we use only one global
// TLS object, so T instances in total, one per thread, regardless of M and N.
// This allows to deal with at-thread-exit destruction only in one place, rather
// than N, M or M * N.
//
// Visually:
//                     [    Thread 1   ] [    Thread 2   ] [    Thread T   ]
//                     +---------------+ +---------------+ +---------------+
// Data source Foo     |               | |               | |               |
//  Instance 1         |     TLS       | |     TLS       | |     TLS       |
//  Instance 2         |    Object     | |    Object     | |    Object     |
//  Instance 3         |               | |               | |               |
//                     |               | |               | |               |
// Data source Bar     |               | |               | |               |
//  Instance 1         |               | |               | |               |
//  Instance 2         |               | |               | |               |
//                     +---------------+ +---------------+ +---------------+
//
// Each TLS Object is organized as an array of M DataSourceThreadLocalState.
// Each DSTLS itself is an array of up to N per-instance objects.
// The only per-instance object for now is the TraceWriter.
// So for each data source, for each instance, for each thread we keep one
// TraceWriter.
// The lookup is O(1): Given the TLS object, the TraceWriter is just tls[M][N].
class TracingTLS : public Platform::ThreadLocalObject {
 public:
  ~TracingTLS() override;

  // This is checked against TraceMuxerImpl's global generation counter to
  // handle destruction of TraceWriter(s) that belong to data sources that
  // have been stopped. When the two numbers diverge, a scan of all the
  // thread-local TraceWriter(s) is issued.
  uint32_t generation = 0;

  // By default all data source instances have independent thread-local state
  // (see above).
  std::array<DataSourceThreadLocalState, kMaxDataSources> data_sources_tls{};

  // Track event data sources, however, share the same thread-local state in
  // order to be able to share trace writers and interning state across all
  // track event categories.
  DataSourceThreadLocalState track_event_tls{};
};

}  // namespace internal
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_TRACING_INTERNAL_TRACING_TLS_H_
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_TRACING_INTERNAL_TRACING_MUXER_H_
#define INCLUDE_PERFETTO_TRACING_INTERNAL_TRACING_MUXER_H_

#include <atomic>
#include <memory>

// gen_amalgamated expanded: #include "perfetto/base/export.h"
// gen_amalgamated expanded: #include "perfetto/tracing/core/forward_decls.h"
// gen_amalgamated expanded: #include "perfetto/tracing/internal/basic_types.h"
// gen_amalgamated expanded: #include "perfetto/tracing/internal/tracing_tls.h"
// gen_amalgamated expanded: #include "perfetto/tracing/platform.h"
namespace perfetto {

class DataSourceBase;
class TraceWriterBase;
struct TracingInitArgs;
class TracingSession;

namespace internal {

struct DataSourceStaticState;

// This class acts as a bridge between the public API methods and the
// TracingBackend(s). It exposes a simplified view of the world to the API
// methods, so that they don't have to care about the multiplicity of backends.
// It handles all the bookkeeping to map data source instances and trace writers
// to the various backends.
// See tracing_muxer_impl.h for the full picture. This class contains only the
// fewer fields and methods that need to be exposed to public/ headers. Fields
// and methods that are required to implement them should go into
// src/tracing/internal/tracing_muxer_impl.h instead: that one can pull in
// perfetto headers outside of public, this one cannot.
class PERFETTO_EXPORT TracingMuxer {
 public:
  static TracingMuxer* Get() { return instance_; }

  virtual ~TracingMuxer();

  TracingTLS* GetOrCreateTracingTLS() {
    return static_cast<TracingTLS*>(platform_->GetOrCreateThreadLocalObject());
  }

  // This method can fail and return false if trying to register more than
  // kMaxDataSources types.
  using DataSourceFactory = std::function<std::unique_ptr<DataSourceBase>()>;
  virtual bool RegisterDataSource(const DataSourceDescriptor&,
                                  DataSourceFactory,
                                  DataSourceStaticState*) = 0;

  // It identifies the right backend and forwards the call to it.
  // The returned TraceWriter must be used within the same sequence (for most
  // projects this means "same thread"). Alternatively the client needs to take
  // care of using synchronization primitives to prevent concurrent accesses.
  virtual std::unique_ptr<TraceWriterBase> CreateTraceWriter(
      DataSourceState*,
      BufferExhaustedPolicy buffer_exhausted_policy) = 0;

  virtual void DestroyStoppedTraceWritersForCurrentThread() = 0;

  uint32_t generation(std::memory_order ord) { return generation_.load(ord); }

 protected:
  explicit TracingMuxer(Platform* platform) : platform_(platform) {}

  static TracingMuxer* instance_;
  Platform* const platform_ = nullptr;

  // Incremented every time a data source is destroyed. See tracing_tls.h.
  std::atomic<uint32_t> generation_{};
};

}  // namespace internal
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_TRACING_INTERNAL_TRACING_MUXER_H_
// gen_amalgamated begin header: /Users/primiano/code/perfetto/tools/../include/perfetto/tracing/locked_handle.h
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_TRACING_LOCKED_HANDLE_H_
#define INCLUDE_PERFETTO_TRACING_LOCKED_HANDLE_H_

#include <mutex>

namespace perfetto {

// This is used for GetDataSourceLocked(), in the (rare) case where the
// tracing code wants to access the state of its data source from the Trace()
// method.
template <typename T>
class LockedHandle {
 public:
  LockedHandle(std::recursive_mutex* mtx, T* obj) : lock_(*mtx), obj_(obj) {}
  LockedHandle() = default;  // For the invalid case.
  LockedHandle(LockedHandle&&) = default;
  LockedHandle& operator=(LockedHandle&&) = default;

  bool valid() const { return obj_; }
  explicit operator bool() const { return valid(); }

  T* operator->() {
    assert(valid());
    return obj_;
  }

  T& operator*() { return *(this->operator->()); }

 private:
  std::unique_lock<std::recursive_mutex> lock_;
  T* obj_ = nullptr;
};

}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_TRACING_LOCKED_HANDLE_H_
// gen_amalgamated begin header: /Users/primiano/code/perfetto/tools/../out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/trace_packet.pbzero.h
// gen_amalgamated begin header: /Users/primiano/code/perfetto/tools/../include/perfetto/protozero/packed_repeated_fields.h
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_PROTOZERO_PACKED_REPEATED_FIELDS_H_
#define INCLUDE_PERFETTO_PROTOZERO_PACKED_REPEATED_FIELDS_H_

#include <stdint.h>

#include <array>
#include <memory>
#include <type_traits>

// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace protozero {

// This file contains classes used when encoding packed repeated fields.
// To encode such a field, the caller is first expected to accumulate all of the
// values in one of the following types (depending on the wire type of the
// individual elements), defined below:
// * protozero::PackedVarInt
// * protozero::PackedFixedSizeInt</*element_type=*/ uint32_t>
// Then that buffer is passed to the protozero-generated setters as an argument.
// After calling the setter, the buffer can be destroyed.
//
// An example of encoding a packed field:
//   protozero::HeapBuffered<protozero::Message> msg;
//   protozero::PackedVarInt buf;
//   buf.Append(42);
//   buf.Append(-1);
//   msg->set_fieldname(buf);
//   msg.SerializeAsString();

class PackedBufferBase {
 public:
  PackedBufferBase() { Reset(); }

  // Copy or move is disabled due to pointers to stack addresses.
  PackedBufferBase(const PackedBufferBase&) = delete;
  PackedBufferBase(PackedBufferBase&&) = delete;
  PackedBufferBase& operator=(const PackedBufferBase&) = delete;
  PackedBufferBase& operator=(PackedBufferBase&&) = delete;

  void Reset();

  const uint8_t* data() const { return storage_begin_; }

  size_t size() const {
    return static_cast<size_t>(write_ptr_ - storage_begin_);
  }

 protected:
  void GrowIfNeeded() {
    PERFETTO_DCHECK(write_ptr_ >= storage_begin_ && write_ptr_ <= storage_end_);
    if (PERFETTO_UNLIKELY(write_ptr_ + kMaxElementSize > storage_end_)) {
      GrowSlowpath();
    }
  }

  void GrowSlowpath();

  // max(uint64_t varint encoding, biggest fixed type (uint64)).
  static constexpr size_t kMaxElementSize = 10;

  // So sizeof(this) == 8k.
  static constexpr size_t kOnStackStorageSize = 8192 - 32;

  uint8_t* storage_begin_;
  uint8_t* storage_end_;
  uint8_t* write_ptr_;
  std::unique_ptr<uint8_t[]> heap_buf_;
  alignas(uint64_t) uint8_t stack_buf_[kOnStackStorageSize];
};

class PackedVarInt : public PackedBufferBase {
 public:
  template <typename T>
  void Append(T value) {
    GrowIfNeeded();
    write_ptr_ = proto_utils::WriteVarInt(value, write_ptr_);
  }
};

template <typename T /* e.g. uint32_t for Fixed32 */>
class PackedFixedSizeInt : public PackedBufferBase {
 public:
  void Append(T value) {
    static_assert(sizeof(T) == 4 || sizeof(T) == 8,
                  "PackedFixedSizeInt should be used only with 32/64-bit ints");
    static_assert(sizeof(T) <= kMaxElementSize,
                  "kMaxElementSize needs to be updated");
    GrowIfNeeded();
    PERFETTO_DCHECK(reinterpret_cast<size_t>(write_ptr_) % alignof(T) == 0);
    memcpy(reinterpret_cast<T*>(write_ptr_), &value, sizeof(T));
    write_ptr_ += sizeof(T);
  }
};

}  // namespace protozero

#endif  // INCLUDE_PERFETTO_PROTOZERO_PACKED_REPEATED_FIELDS_H_
// gen_amalgamated begin header: /Users/primiano/code/perfetto/tools/../include/perfetto/protozero/proto_decoder.h
// gen_amalgamated begin header: /Users/primiano/code/perfetto/tools/../include/perfetto/protozero/field.h
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_PROTOZERO_FIELD_H_
#define INCLUDE_PERFETTO_PROTOZERO_FIELD_H_

#include <stdint.h>

#include <string>

// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/protozero/contiguous_memory_range.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace protozero {

struct ConstBytes {
  std::string ToStdString() const {
    return std::string(reinterpret_cast<const char*>(data), size);
  }

  const uint8_t* data;
  size_t size;
};

struct ConstChars {
  // Allow implicit conversion to perfetto's base::StringView without depending
  // on perfetto/base or viceversa.
  static constexpr bool kConvertibleToStringView = true;
  std::string ToStdString() const { return std::string(data, size); }

  const char* data;
  size_t size;
};

// A protobuf field decoded by the protozero proto decoders. It exposes
// convenience accessors with minimal debug checks.
// This class is used both by the iterator-based ProtoDecoder and by the
// one-shot TypedProtoDecoder.
// If the field is not valid the accessors consistently return zero-integers or
// null strings.
class Field {
 public:
  bool valid() const { return id_ != 0; }
  uint16_t id() const { return id_; }
  explicit operator bool() const { return valid(); }

  proto_utils::ProtoWireType type() const {
    auto res = static_cast<proto_utils::ProtoWireType>(type_);
    PERFETTO_DCHECK(res == proto_utils::ProtoWireType::kVarInt ||
                    res == proto_utils::ProtoWireType::kLengthDelimited ||
                    res == proto_utils::ProtoWireType::kFixed32 ||
                    res == proto_utils::ProtoWireType::kFixed64);
    return res;
  }

  bool as_bool() const {
    PERFETTO_DCHECK(!valid() || type() == proto_utils::ProtoWireType::kVarInt);
    return static_cast<bool>(int_value_);
  }

  uint32_t as_uint32() const {
    PERFETTO_DCHECK(!valid() || type() == proto_utils::ProtoWireType::kVarInt ||
                    type() == proto_utils::ProtoWireType::kFixed32);
    return static_cast<uint32_t>(int_value_);
  }

  int32_t as_int32() const {
    PERFETTO_DCHECK(!valid() || type() == proto_utils::ProtoWireType::kVarInt ||
                    type() == proto_utils::ProtoWireType::kFixed32);
    return static_cast<int32_t>(int_value_);
  }

  int32_t as_sint32() const {
    PERFETTO_DCHECK(!valid() || type() == proto_utils::ProtoWireType::kVarInt);
    return proto_utils::ZigZagDecode(static_cast<uint32_t>(int_value_));
  }

  uint64_t as_uint64() const {
    PERFETTO_DCHECK(!valid() || type() == proto_utils::ProtoWireType::kVarInt ||
                    type() == proto_utils::ProtoWireType::kFixed32 ||
                    type() == proto_utils::ProtoWireType::kFixed64);
    return int_value_;
  }

  int64_t as_int64() const {
    PERFETTO_DCHECK(!valid() || type() == proto_utils::ProtoWireType::kVarInt ||
                    type() == proto_utils::ProtoWireType::kFixed32 ||
                    type() == proto_utils::ProtoWireType::kFixed64);
    return static_cast<int64_t>(int_value_);
  }

  int64_t as_sint64() const {
    PERFETTO_DCHECK(!valid() || type() == proto_utils::ProtoWireType::kVarInt);
    return proto_utils::ZigZagDecode(static_cast<uint64_t>(int_value_));
  }

  float as_float() const {
    PERFETTO_DCHECK(!valid() || type() == proto_utils::ProtoWireType::kFixed32);
    float res;
    uint32_t value32 = static_cast<uint32_t>(int_value_);
    memcpy(&res, &value32, sizeof(res));
    return res;
  }

  double as_double() const {
    PERFETTO_DCHECK(!valid() || type() == proto_utils::ProtoWireType::kFixed64);
    double res;
    memcpy(&res, &int_value_, sizeof(res));
    return res;
  }

  ConstChars as_string() const {
    PERFETTO_DCHECK(!valid() ||
                    type() == proto_utils::ProtoWireType::kLengthDelimited);
    return ConstChars{reinterpret_cast<const char*>(data()), size_};
  }

  std::string as_std_string() const { return as_string().ToStdString(); }

  ConstBytes as_bytes() const {
    PERFETTO_DCHECK(!valid() ||
                    type() == proto_utils::ProtoWireType::kLengthDelimited);
    return ConstBytes{data(), size_};
  }

  const uint8_t* data() const {
    PERFETTO_DCHECK(!valid() ||
                    type() == proto_utils::ProtoWireType::kLengthDelimited);
    return reinterpret_cast<const uint8_t*>(int_value_);
  }

  size_t size() const {
    PERFETTO_DCHECK(!valid() ||
                    type() == proto_utils::ProtoWireType::kLengthDelimited);
    return size_;
  }

  uint64_t raw_int_value() const { return int_value_; }

  void initialize(uint16_t id,
                  uint8_t type,
                  uint64_t int_value,
                  uint32_t size) {
    id_ = id;
    type_ = type;
    int_value_ = int_value;
    size_ = size;
  }

  // For use with templates. This is used by RepeatedFieldIterator::operator*().
  void get(bool* val) const { *val = as_bool(); }
  void get(uint32_t* val) const { *val = as_uint32(); }
  void get(int32_t* val) const { *val = as_int32(); }
  void get(uint64_t* val) const { *val = as_uint64(); }
  void get(int64_t* val) const { *val = as_int64(); }
  void get(float* val) const { *val = as_float(); }
  void get(double* val) const { *val = as_double(); }
  void get(std::string* val) const { *val = as_std_string(); }
  void get(ConstChars* val) const { *val = as_string(); }
  void get(ConstBytes* val) const { *val = as_bytes(); }
  void get_signed(int32_t* val) const { *val = as_sint32(); }
  void get_signed(int64_t* val) const { *val = as_sint64(); }

  // For enum types.
  template <typename T,
            typename = typename std::enable_if<std::is_enum<T>::value, T>::type>
  void get(T* val) const {
    *val = static_cast<T>(as_int32());
  }

  // Serializes the field back into a proto-encoded byte stream and appends it
  // to |dst|. |dst| is resized accordingly.
  void SerializeAndAppendTo(std::string* dst);

 private:
  // Fields are deliberately not initialized to keep the class trivially
  // constructible. It makes a large perf difference for ProtoDecoder.

  uint64_t int_value_;  // In kLengthDelimited this contains the data() addr.
  uint32_t size_;       // Only valid when when type == kLengthDelimited.
  uint16_t id_;         // Proto field ordinal.
  uint8_t type_;        // proto_utils::ProtoWireType.
};

// The Field struct is used in a lot of perf-sensitive contexts.
static_assert(sizeof(Field) == 16, "Field struct too big");

}  // namespace protozero

#endif  // INCLUDE_PERFETTO_PROTOZERO_FIELD_H_
/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_PROTOZERO_PROTO_DECODER_H_
#define INCLUDE_PERFETTO_PROTOZERO_PROTO_DECODER_H_

#include <stdint.h>
#include <array>
#include <memory>
#include <vector>

// gen_amalgamated expanded: #include "perfetto/base/compiler.h"
// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/protozero/field.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace protozero {

// A generic protobuf decoder. Doesn't require any knowledge about the proto
// schema. It tokenizes fields, retrieves their ID and type and exposes
// accessors to retrieve its values.
// It does NOT recurse in nested submessages, instead it just computes their
// boundaries, recursion is left to the caller.
// This class is designed to be used in perf-sensitive contexts. It does not
// allocate and does not perform any proto semantic checks (e.g. repeated /
// required / optional). It's supposedly safe wrt out-of-bounds memory accesses
// (see proto_decoder_fuzzer.cc).
// This class serves also as a building block for TypedProtoDecoder, used when
// the schema is known at compile time.
class ProtoDecoder {
 public:
  // Creates a ProtoDecoder using the given |buffer| with size |length| bytes.
  ProtoDecoder(const void* buffer, size_t length)
      : begin_(reinterpret_cast<const uint8_t*>(buffer)),
        end_(begin_ + length),
        read_ptr_(begin_) {}
  ProtoDecoder(const std::string& str) : ProtoDecoder(str.data(), str.size()) {}
  ProtoDecoder(const ConstBytes& cb) : ProtoDecoder(cb.data, cb.size) {}

  // Reads the next field from the buffer and advances the read cursor. If a
  // full field cannot be read, the returned Field will be invalid (i.e.
  // field.valid() == false).
  Field ReadField();

  // Finds the first field with the given id. Doesn't affect the read cursor.
  Field FindField(uint32_t field_id);

  // Resets the read cursor to the start of the buffer.
  void Reset() { read_ptr_ = begin_; }

  // Resets the read cursor to the given position (must be within the buffer).
  void Reset(const uint8_t* pos) {
    PERFETTO_DCHECK(pos >= begin_ && pos < end_);
    read_ptr_ = pos;
  }

  // Returns the position of read cursor, relative to the start of the buffer.
  size_t read_offset() const { return static_cast<size_t>(read_ptr_ - begin_); }

  size_t bytes_left() const {
    PERFETTO_DCHECK(read_ptr_ <= end_);
    return static_cast<size_t>(end_ - read_ptr_);
  }

  const uint8_t* begin() const { return begin_; }
  const uint8_t* end() const { return end_; }

 protected:
  const uint8_t* const begin_;
  const uint8_t* const end_;
  const uint8_t* read_ptr_ = nullptr;
};

// An iterator-like class used to iterate through repeated fields. Used by
// TypedProtoDecoder. The iteration sequence is a bit counter-intuitive due to
// the fact that fields_[field_id] holds the *last* value of the field, not the
// first, but the remaining storage holds repeated fields in FIFO order.
// Assume that we push the 10,11,12 into a repeated field with ID=1.
//
// Decoder memory layout:  [  fields storage  ] [ repeated fields storage ]
// 1st iteration:           10
// 2nd iteration:           11                   10
// 3rd iteration:           12                   10 11
//
// We start the iteration @ fields_[num_fields], which is the start of the
// repeated fields storage, proceed until the end and lastly jump @ fields_[id].
template <typename T>
class RepeatedFieldIterator {
 public:
  RepeatedFieldIterator(uint32_t field_id,
                        const Field* begin,
                        const Field* end,
                        const Field* last)
      : field_id_(field_id), iter_(begin), end_(end), last_(last) {
    FindNextMatchingId();
  }

  explicit operator bool() const { return iter_ != end_; }
  const Field& field() const { return *iter_; }

  T operator*() const {
    T val{};
    iter_->get(&val);
    return val;
  }
  const Field* operator->() const { return iter_; }

  RepeatedFieldIterator& operator++() {
    PERFETTO_DCHECK(iter_ != end_);
    if (iter_ == last_) {
      iter_ = end_;
      return *this;
    }
    ++iter_;
    FindNextMatchingId();
    return *this;
  }

  RepeatedFieldIterator operator++(int) {
    PERFETTO_DCHECK(iter_ != end_);
    RepeatedFieldIterator it(*this);
    ++(*this);
    return it;
  }

 private:
  void FindNextMatchingId() {
    PERFETTO_DCHECK(iter_ != last_);
    for (; iter_ != end_; ++iter_) {
      if (iter_->id() == field_id_)
        return;
    }
    iter_ = last_->valid() ? last_ : end_;
  }

  uint32_t field_id_;

  // Initially points to the beginning of the repeated field storage, then is
  // incremented as we call operator++().
  const Field* iter_;

  // Always points to fields_[size_], i.e. past the end of the storage.
  const Field* end_;

  // Always points to fields_[field_id].
  const Field* last_;
};

// As RepeatedFieldIterator, but allows iterating over a packed repeated field
// (which will be initially stored as a single length-delimited field).
// See |GetPackedRepeatedField| for details.
//
// Assumes little endianness, and that the input buffers are well formed -
// containing an exact multiple of encoded elements.
template <proto_utils::ProtoWireType wire_type, typename CppType>
class PackedRepeatedFieldIterator {
 public:
  PackedRepeatedFieldIterator(const uint8_t* data_begin,
                              size_t size,
                              bool* parse_error_ptr)
      : data_end_(data_begin ? data_begin + size : nullptr),
        read_ptr_(data_begin),
        parse_error_(parse_error_ptr) {
    using proto_utils::ProtoWireType;
    static_assert(wire_type == ProtoWireType::kVarInt ||
                      wire_type == ProtoWireType::kFixed32 ||
                      wire_type == ProtoWireType::kFixed64,
                  "invalid type");

    PERFETTO_DCHECK(parse_error_ptr);

    // Either the field is unset (and there are no data pointer), or the field
    // is set with a zero length payload. Mark the iterator as invalid in both
    // cases.
    if (size == 0) {
      curr_value_valid_ = false;
      return;
    }

    if ((wire_type == ProtoWireType::kFixed32 && (size % 4) != 0) ||
        (wire_type == ProtoWireType::kFixed64 && (size % 8) != 0)) {
      *parse_error_ = true;
      curr_value_valid_ = false;
      return;
    }

    ++(*this);
  }

  const CppType operator*() const { return curr_value_; }
  explicit operator bool() const { return curr_value_valid_; }

  PackedRepeatedFieldIterator& operator++() {
    using proto_utils::ProtoWireType;

    if (PERFETTO_UNLIKELY(!curr_value_valid_))
      return *this;

    if (PERFETTO_UNLIKELY(read_ptr_ == data_end_)) {
      curr_value_valid_ = false;
      return *this;
    }

    if (wire_type == ProtoWireType::kVarInt) {
      uint64_t new_value = 0;
      const uint8_t* new_pos =
          proto_utils::ParseVarInt(read_ptr_, data_end_, &new_value);

      if (PERFETTO_UNLIKELY(new_pos == read_ptr_)) {
        // Failed to decode the varint (probably incomplete buffer).
        *parse_error_ = true;
        curr_value_valid_ = false;
      } else {
        read_ptr_ = new_pos;
        curr_value_ = static_cast<CppType>(new_value);
      }
    } else {  // kFixed32 or kFixed64
      constexpr size_t kStep = wire_type == ProtoWireType::kFixed32 ? 4 : 8;

      // NB: the raw buffer is not guaranteed to be aligned, so neither are
      // these copies.
      memcpy(&curr_value_, read_ptr_, sizeof(CppType));
      read_ptr_ += kStep;
    }

    return *this;
  }

  PackedRepeatedFieldIterator operator++(int) {
    PackedRepeatedFieldIterator it(*this);
    ++(*this);
    return it;
  }

 private:
  // Might be null if the backing proto field isn't set.
  const uint8_t* const data_end_;

  // The iterator looks ahead by an element, so |curr_value| holds the value
  // to be returned when the caller dereferences the iterator, and |read_ptr_|
  // points at the start of the next element to be decoded.
  // |read_ptr_| might be null if the backing proto field isn't set.
  const uint8_t* read_ptr_;
  CppType curr_value_ = 0;

  // Set to false once we've exhausted the iterator, or encountered an error.
  bool curr_value_valid_ = true;

  // Where to set parsing errors, supplied by the caller.
  bool* const parse_error_;
};

// This decoder loads all fields upfront, without recursing in nested messages.
// It is used as a base class for typed decoders generated by the pbzero plugin.
// The split between TypedProtoDecoderBase and TypedProtoDecoder<> is to have
// unique definition of functions like ParseAllFields() and ExpandHeapStorage().
// The storage (either on-stack or on-heap) for this class is organized as
// follows:
// |-------------------------- fields_ ----------------------|
// [ field 0 (invalid) ] [ fields 1 .. N ] [ repeated fields ]
//                                        ^                  ^
//                                        num_fields_        size_
class TypedProtoDecoderBase : public ProtoDecoder {
 public:
  // If the field |id| is known at compile time, prefer the templated
  // specialization at<kFieldNumber>().
  const Field& Get(uint32_t id) const {
    return PERFETTO_LIKELY(id < num_fields_) ? fields_[id] : fields_[0];
  }

  // Returns an object that allows to iterate over all instances of a repeated
  // field given its id. Example usage:
  //   for (auto it = decoder.GetRepeated<int32_t>(N); it; ++it) { ... }
  template <typename T>
  RepeatedFieldIterator<T> GetRepeated(uint32_t field_id) const {
    return RepeatedFieldIterator<T>(field_id, &fields_[num_fields_],
                                    &fields_[size_], &fields_[field_id]);
  }

  // Returns an objects that allows to iterate over all entries of a packed
  // repeated field given its id and type. The |wire_type| is necessary for
  // decoding the packed field, the |cpp_type| is for convenience & stronger
  // typing.
  //
  // The caller must also supply a pointer to a bool that is set to true if the
  // packed buffer is found to be malformed while iterating (so you need to
  // exhaust the iterator if you want to check the full extent of the buffer).
  //
  // Note that unlike standard protobuf parsers, protozero does not allow
  // treating of packed repeated fields as non-packed and vice-versa (therefore
  // not making the packed option forwards and backwards compatible). So
  // the caller needs to use the right accessor for correct results.
  template <proto_utils::ProtoWireType wire_type, typename cpp_type>
  PackedRepeatedFieldIterator<wire_type, cpp_type> GetPackedRepeated(
      uint32_t field_id,
      bool* parse_error_location) const {
    const Field& field = Get(field_id);
    if (field.valid()) {
      return PackedRepeatedFieldIterator<wire_type, cpp_type>(
          field.data(), field.size(), parse_error_location);
    } else {
      return PackedRepeatedFieldIterator<wire_type, cpp_type>(
          nullptr, 0, parse_error_location);
    }
  }

 protected:
  TypedProtoDecoderBase(Field* storage,
                        uint32_t num_fields,
                        uint32_t capacity,
                        const uint8_t* buffer,
                        size_t length)
      : ProtoDecoder(buffer, length),
        fields_(storage),
        num_fields_(num_fields),
        size_(num_fields),
        capacity_(capacity) {
    // The reason why Field needs to be trivially de/constructible is to avoid
    // implicit initializers on all the ~1000 entries. We need it to initialize
    // only on the first |max_field_id| fields, the remaining capacity doesn't
    // require initialization.
    static_assert(std::is_trivially_constructible<Field>::value &&
                      std::is_trivially_destructible<Field>::value &&
                      std::is_trivial<Field>::value,
                  "Field must be a trivial aggregate type");
    memset(fields_, 0, sizeof(Field) * num_fields_);
  }

  void ParseAllFields();

  // Called when the default on-stack storage is exhausted and new repeated
  // fields need to be pushed.
  void ExpandHeapStorage();

  // Used only in presence of a large number of repeated fields, when the
  // default on-stack storage is exhausted.
  std::unique_ptr<Field[]> heap_storage_;

  // Points to the storage, either on-stack (default, provided by the template
  // specialization) or |heap_storage_| after ExpandHeapStorage() is called, in
  // case of a large number of repeated fields.
  Field* fields_;

  // Number of fields without accounting repeated storage. This is equal to
  // MAX_FIELD_ID + 1 (to account for the invalid 0th field).
  // This value is always <= size_ (and hence <= capacity);
  uint32_t num_fields_;

  // Number of active |fields_| entries. This is initially equal to the highest
  // number of fields for the message (num_fields_ == MAX_FIELD_ID + 1) and can
  // grow up to |capacity_| in the case of repeated fields.
  uint32_t size_;

  // Initially equal to kFieldsCapacity of the TypedProtoDecoder
  // specialization. Can grow when falling back on heap-based storage, in which
  // case it represents the size (#fields with each entry of a repeated field
  // counted individually) of the |heap_storage_| array.
  uint32_t capacity_;
};

// Template class instantiated by the auto-generated decoder classes declared in
// xxx.pbzero.h files.
template <int MAX_FIELD_ID, bool HAS_NONPACKED_REPEATED_FIELDS>
class TypedProtoDecoder : public TypedProtoDecoderBase {
 public:
  TypedProtoDecoder(const uint8_t* buffer, size_t length)
      : TypedProtoDecoderBase(on_stack_storage_,
                              /*num_fields=*/MAX_FIELD_ID + 1,
                              kCapacity,
                              buffer,
                              length) {
    static_assert(MAX_FIELD_ID <= kMaxDecoderFieldId, "Field ordinal too high");
    TypedProtoDecoderBase::ParseAllFields();
  }

  template <uint32_t FIELD_ID>
  const Field& at() const {
    static_assert(FIELD_ID <= MAX_FIELD_ID, "FIELD_ID > MAX_FIELD_ID");
    return fields_[FIELD_ID];
  }

  TypedProtoDecoder(TypedProtoDecoder&& other) noexcept
      : TypedProtoDecoderBase(std::move(other)) {
    // If the moved-from decoder was using on-stack storage, we need to update
    // our pointer to point to this decoder's on-stack storage.
    if (fields_ == other.on_stack_storage_) {
      fields_ = on_stack_storage_;
      memcpy(on_stack_storage_, other.on_stack_storage_,
             sizeof(on_stack_storage_));
    }
  }

 private:
  // In the case of non-repeated fields, this constant defines the highest field
  // id we are able to decode. This is to limit the on-stack storage.
  // In the case of repeated fields, this constant defines the max number of
  // repeated fields that we'll be able to store before falling back on the
  // heap. Keep this value in sync with the one in protozero_generator.cc.
  static constexpr size_t kMaxDecoderFieldId = 999;

  // If we the message has no repeated fields we need at most N Field entries
  // in the on-stack storage, where N is the highest field id.
  // Otherwise we need some room to store repeated fields.
  static constexpr size_t kCapacity =
      1 + (HAS_NONPACKED_REPEATED_FIELDS ? kMaxDecoderFieldId : MAX_FIELD_ID);

  Field on_stack_storage_[kCapacity];
};

}  // namespace protozero

#endif  // INCLUDE_PERFETTO_PROTOZERO_PROTO_DECODER_H_
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACE_PACKET_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACE_PACKET_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class AndroidLogPacket;
class BatteryCounters;
class ChromeBenchmarkMetadata;
class ChromeEventBundle;
class ChromeMetadataPacket;
class ClockSnapshot;
class DeobfuscationMapping;
class FtraceEventBundle;
class FtraceStats;
class GpuCounterEvent;
class GpuLog;
class GpuRenderStageEvent;
class GraphicsFrameEvent;
class HeapGraph;
class InodeFileMap;
class InternedData;
class ModuleSymbols;
class PackagesList;
class PerfettoMetatrace;
class PowerRails;
class ProcessDescriptor;
class ProcessStats;
class ProcessTree;
class ProfilePacket;
class ProfiledFrameSymbols;
class StreamingProfilePacket;
class SysStats;
class SystemInfo;
class TestEvent;
class ThreadDescriptor;
class TraceConfig;
class TracePacketDefaults;
class TraceStats;
class TrackDescriptor;
class TrackEvent;
class Trigger;
class VulkanMemoryEvent;

enum TracePacket_SequenceFlags : int32_t {
  TracePacket_SequenceFlags_SEQ_UNSPECIFIED = 0,
  TracePacket_SequenceFlags_SEQ_INCREMENTAL_STATE_CLEARED = 1,
  TracePacket_SequenceFlags_SEQ_NEEDS_INCREMENTAL_STATE = 2,
};

const TracePacket_SequenceFlags TracePacket_SequenceFlags_MIN = TracePacket_SequenceFlags_SEQ_UNSPECIFIED;
const TracePacket_SequenceFlags TracePacket_SequenceFlags_MAX = TracePacket_SequenceFlags_SEQ_NEEDS_INCREMENTAL_STATE;

class TracePacket_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/900, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TracePacket_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TracePacket_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TracePacket_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_timestamp() const { return at<8>().valid(); }
  uint64_t timestamp() const { return at<8>().as_uint64(); }
  bool has_timestamp_clock_id() const { return at<58>().valid(); }
  uint32_t timestamp_clock_id() const { return at<58>().as_uint32(); }
  bool has_ftrace_events() const { return at<1>().valid(); }
  ::protozero::ConstBytes ftrace_events() const { return at<1>().as_bytes(); }
  bool has_process_tree() const { return at<2>().valid(); }
  ::protozero::ConstBytes process_tree() const { return at<2>().as_bytes(); }
  bool has_process_stats() const { return at<9>().valid(); }
  ::protozero::ConstBytes process_stats() const { return at<9>().as_bytes(); }
  bool has_inode_file_map() const { return at<4>().valid(); }
  ::protozero::ConstBytes inode_file_map() const { return at<4>().as_bytes(); }
  bool has_chrome_events() const { return at<5>().valid(); }
  ::protozero::ConstBytes chrome_events() const { return at<5>().as_bytes(); }
  bool has_clock_snapshot() const { return at<6>().valid(); }
  ::protozero::ConstBytes clock_snapshot() const { return at<6>().as_bytes(); }
  bool has_sys_stats() const { return at<7>().valid(); }
  ::protozero::ConstBytes sys_stats() const { return at<7>().as_bytes(); }
  bool has_track_event() const { return at<11>().valid(); }
  ::protozero::ConstBytes track_event() const { return at<11>().as_bytes(); }
  bool has_trace_config() const { return at<33>().valid(); }
  ::protozero::ConstBytes trace_config() const { return at<33>().as_bytes(); }
  bool has_ftrace_stats() const { return at<34>().valid(); }
  ::protozero::ConstBytes ftrace_stats() const { return at<34>().as_bytes(); }
  bool has_trace_stats() const { return at<35>().valid(); }
  ::protozero::ConstBytes trace_stats() const { return at<35>().as_bytes(); }
  bool has_profile_packet() const { return at<37>().valid(); }
  ::protozero::ConstBytes profile_packet() const { return at<37>().as_bytes(); }
  bool has_battery() const { return at<38>().valid(); }
  ::protozero::ConstBytes battery() const { return at<38>().as_bytes(); }
  bool has_power_rails() const { return at<40>().valid(); }
  ::protozero::ConstBytes power_rails() const { return at<40>().as_bytes(); }
  bool has_android_log() const { return at<39>().valid(); }
  ::protozero::ConstBytes android_log() const { return at<39>().as_bytes(); }
  bool has_system_info() const { return at<45>().valid(); }
  ::protozero::ConstBytes system_info() const { return at<45>().as_bytes(); }
  bool has_trigger() const { return at<46>().valid(); }
  ::protozero::ConstBytes trigger() const { return at<46>().as_bytes(); }
  bool has_packages_list() const { return at<47>().valid(); }
  ::protozero::ConstBytes packages_list() const { return at<47>().as_bytes(); }
  bool has_chrome_benchmark_metadata() const { return at<48>().valid(); }
  ::protozero::ConstBytes chrome_benchmark_metadata() const { return at<48>().as_bytes(); }
  bool has_perfetto_metatrace() const { return at<49>().valid(); }
  ::protozero::ConstBytes perfetto_metatrace() const { return at<49>().as_bytes(); }
  bool has_chrome_metadata() const { return at<51>().valid(); }
  ::protozero::ConstBytes chrome_metadata() const { return at<51>().as_bytes(); }
  bool has_gpu_counter_event() const { return at<52>().valid(); }
  ::protozero::ConstBytes gpu_counter_event() const { return at<52>().as_bytes(); }
  bool has_gpu_render_stage_event() const { return at<53>().valid(); }
  ::protozero::ConstBytes gpu_render_stage_event() const { return at<53>().as_bytes(); }
  bool has_streaming_profile_packet() const { return at<54>().valid(); }
  ::protozero::ConstBytes streaming_profile_packet() const { return at<54>().as_bytes(); }
  bool has_heap_graph() const { return at<56>().valid(); }
  ::protozero::ConstBytes heap_graph() const { return at<56>().as_bytes(); }
  bool has_graphics_frame_event() const { return at<57>().valid(); }
  ::protozero::ConstBytes graphics_frame_event() const { return at<57>().as_bytes(); }
  bool has_vulkan_memory_event() const { return at<62>().valid(); }
  ::protozero::ConstBytes vulkan_memory_event() const { return at<62>().as_bytes(); }
  bool has_gpu_log() const { return at<63>().valid(); }
  ::protozero::ConstBytes gpu_log() const { return at<63>().as_bytes(); }
  bool has_profiled_frame_symbols() const { return at<55>().valid(); }
  ::protozero::ConstBytes profiled_frame_symbols() const { return at<55>().as_bytes(); }
  bool has_module_symbols() const { return at<61>().valid(); }
  ::protozero::ConstBytes module_symbols() const { return at<61>().as_bytes(); }
  bool has_deobfuscation_mapping() const { return at<64>().valid(); }
  ::protozero::ConstBytes deobfuscation_mapping() const { return at<64>().as_bytes(); }
  bool has_track_descriptor() const { return at<60>().valid(); }
  ::protozero::ConstBytes track_descriptor() const { return at<60>().as_bytes(); }
  bool has_process_descriptor() const { return at<43>().valid(); }
  ::protozero::ConstBytes process_descriptor() const { return at<43>().as_bytes(); }
  bool has_thread_descriptor() const { return at<44>().valid(); }
  ::protozero::ConstBytes thread_descriptor() const { return at<44>().as_bytes(); }
  bool has_synchronization_marker() const { return at<36>().valid(); }
  ::protozero::ConstBytes synchronization_marker() const { return at<36>().as_bytes(); }
  bool has_compressed_packets() const { return at<50>().valid(); }
  ::protozero::ConstBytes compressed_packets() const { return at<50>().as_bytes(); }
  bool has_for_testing() const { return at<900>().valid(); }
  ::protozero::ConstBytes for_testing() const { return at<900>().as_bytes(); }
  bool has_trusted_uid() const { return at<3>().valid(); }
  int32_t trusted_uid() const { return at<3>().as_int32(); }
  bool has_trusted_packet_sequence_id() const { return at<10>().valid(); }
  uint32_t trusted_packet_sequence_id() const { return at<10>().as_uint32(); }
  bool has_interned_data() const { return at<12>().valid(); }
  ::protozero::ConstBytes interned_data() const { return at<12>().as_bytes(); }
  bool has_sequence_flags() const { return at<13>().valid(); }
  uint32_t sequence_flags() const { return at<13>().as_uint32(); }
  bool has_incremental_state_cleared() const { return at<41>().valid(); }
  bool incremental_state_cleared() const { return at<41>().as_bool(); }
  bool has_trace_packet_defaults() const { return at<59>().valid(); }
  ::protozero::ConstBytes trace_packet_defaults() const { return at<59>().as_bytes(); }
  bool has_previous_packet_dropped() const { return at<42>().valid(); }
  bool previous_packet_dropped() const { return at<42>().as_bool(); }
};

class TracePacket : public ::protozero::Message {
 public:
  using Decoder = TracePacket_Decoder;
  enum : int32_t {
    kTimestampFieldNumber = 8,
    kTimestampClockIdFieldNumber = 58,
    kFtraceEventsFieldNumber = 1,
    kProcessTreeFieldNumber = 2,
    kProcessStatsFieldNumber = 9,
    kInodeFileMapFieldNumber = 4,
    kChromeEventsFieldNumber = 5,
    kClockSnapshotFieldNumber = 6,
    kSysStatsFieldNumber = 7,
    kTrackEventFieldNumber = 11,
    kTraceConfigFieldNumber = 33,
    kFtraceStatsFieldNumber = 34,
    kTraceStatsFieldNumber = 35,
    kProfilePacketFieldNumber = 37,
    kBatteryFieldNumber = 38,
    kPowerRailsFieldNumber = 40,
    kAndroidLogFieldNumber = 39,
    kSystemInfoFieldNumber = 45,
    kTriggerFieldNumber = 46,
    kPackagesListFieldNumber = 47,
    kChromeBenchmarkMetadataFieldNumber = 48,
    kPerfettoMetatraceFieldNumber = 49,
    kChromeMetadataFieldNumber = 51,
    kGpuCounterEventFieldNumber = 52,
    kGpuRenderStageEventFieldNumber = 53,
    kStreamingProfilePacketFieldNumber = 54,
    kHeapGraphFieldNumber = 56,
    kGraphicsFrameEventFieldNumber = 57,
    kVulkanMemoryEventFieldNumber = 62,
    kGpuLogFieldNumber = 63,
    kProfiledFrameSymbolsFieldNumber = 55,
    kModuleSymbolsFieldNumber = 61,
    kDeobfuscationMappingFieldNumber = 64,
    kTrackDescriptorFieldNumber = 60,
    kProcessDescriptorFieldNumber = 43,
    kThreadDescriptorFieldNumber = 44,
    kSynchronizationMarkerFieldNumber = 36,
    kCompressedPacketsFieldNumber = 50,
    kForTestingFieldNumber = 900,
    kTrustedUidFieldNumber = 3,
    kTrustedPacketSequenceIdFieldNumber = 10,
    kInternedDataFieldNumber = 12,
    kSequenceFlagsFieldNumber = 13,
    kIncrementalStateClearedFieldNumber = 41,
    kTracePacketDefaultsFieldNumber = 59,
    kPreviousPacketDroppedFieldNumber = 42,
  };
  using SequenceFlags = ::perfetto::protos::pbzero::TracePacket_SequenceFlags;
  static const SequenceFlags SEQ_UNSPECIFIED = TracePacket_SequenceFlags_SEQ_UNSPECIFIED;
  static const SequenceFlags SEQ_INCREMENTAL_STATE_CLEARED = TracePacket_SequenceFlags_SEQ_INCREMENTAL_STATE_CLEARED;
  static const SequenceFlags SEQ_NEEDS_INCREMENTAL_STATE = TracePacket_SequenceFlags_SEQ_NEEDS_INCREMENTAL_STATE;
  void set_timestamp(uint64_t value) {
    AppendVarInt(8, value);
  }
  void set_timestamp_clock_id(uint32_t value) {
    AppendVarInt(58, value);
  }
  template <typename T = FtraceEventBundle> T* set_ftrace_events() {
    return BeginNestedMessage<T>(1);
  }

  template <typename T = ProcessTree> T* set_process_tree() {
    return BeginNestedMessage<T>(2);
  }

  template <typename T = ProcessStats> T* set_process_stats() {
    return BeginNestedMessage<T>(9);
  }

  template <typename T = InodeFileMap> T* set_inode_file_map() {
    return BeginNestedMessage<T>(4);
  }

  template <typename T = ChromeEventBundle> T* set_chrome_events() {
    return BeginNestedMessage<T>(5);
  }

  template <typename T = ClockSnapshot> T* set_clock_snapshot() {
    return BeginNestedMessage<T>(6);
  }

  template <typename T = SysStats> T* set_sys_stats() {
    return BeginNestedMessage<T>(7);
  }

  template <typename T = TrackEvent> T* set_track_event() {
    return BeginNestedMessage<T>(11);
  }

  template <typename T = TraceConfig> T* set_trace_config() {
    return BeginNestedMessage<T>(33);
  }

  template <typename T = FtraceStats> T* set_ftrace_stats() {
    return BeginNestedMessage<T>(34);
  }

  template <typename T = TraceStats> T* set_trace_stats() {
    return BeginNestedMessage<T>(35);
  }

  template <typename T = ProfilePacket> T* set_profile_packet() {
    return BeginNestedMessage<T>(37);
  }

  template <typename T = BatteryCounters> T* set_battery() {
    return BeginNestedMessage<T>(38);
  }

  template <typename T = PowerRails> T* set_power_rails() {
    return BeginNestedMessage<T>(40);
  }

  template <typename T = AndroidLogPacket> T* set_android_log() {
    return BeginNestedMessage<T>(39);
  }

  template <typename T = SystemInfo> T* set_system_info() {
    return BeginNestedMessage<T>(45);
  }

  template <typename T = Trigger> T* set_trigger() {
    return BeginNestedMessage<T>(46);
  }

  template <typename T = PackagesList> T* set_packages_list() {
    return BeginNestedMessage<T>(47);
  }

  template <typename T = ChromeBenchmarkMetadata> T* set_chrome_benchmark_metadata() {
    return BeginNestedMessage<T>(48);
  }

  template <typename T = PerfettoMetatrace> T* set_perfetto_metatrace() {
    return BeginNestedMessage<T>(49);
  }

  template <typename T = ChromeMetadataPacket> T* set_chrome_metadata() {
    return BeginNestedMessage<T>(51);
  }

  template <typename T = GpuCounterEvent> T* set_gpu_counter_event() {
    return BeginNestedMessage<T>(52);
  }

  template <typename T = GpuRenderStageEvent> T* set_gpu_render_stage_event() {
    return BeginNestedMessage<T>(53);
  }

  template <typename T = StreamingProfilePacket> T* set_streaming_profile_packet() {
    return BeginNestedMessage<T>(54);
  }

  template <typename T = HeapGraph> T* set_heap_graph() {
    return BeginNestedMessage<T>(56);
  }

  template <typename T = GraphicsFrameEvent> T* set_graphics_frame_event() {
    return BeginNestedMessage<T>(57);
  }

  template <typename T = VulkanMemoryEvent> T* set_vulkan_memory_event() {
    return BeginNestedMessage<T>(62);
  }

  template <typename T = GpuLog> T* set_gpu_log() {
    return BeginNestedMessage<T>(63);
  }

  template <typename T = ProfiledFrameSymbols> T* set_profiled_frame_symbols() {
    return BeginNestedMessage<T>(55);
  }

  template <typename T = ModuleSymbols> T* set_module_symbols() {
    return BeginNestedMessage<T>(61);
  }

  template <typename T = DeobfuscationMapping> T* set_deobfuscation_mapping() {
    return BeginNestedMessage<T>(64);
  }

  template <typename T = TrackDescriptor> T* set_track_descriptor() {
    return BeginNestedMessage<T>(60);
  }

  template <typename T = ProcessDescriptor> T* set_process_descriptor() {
    return BeginNestedMessage<T>(43);
  }

  template <typename T = ThreadDescriptor> T* set_thread_descriptor() {
    return BeginNestedMessage<T>(44);
  }

  void set_synchronization_marker(const std::string& value) {
    AppendBytes(36, value.data(), value.size());
  }
  void set_synchronization_marker(const uint8_t* data, size_t size) {
    AppendBytes(36, data, size);
  }
  void set_compressed_packets(const std::string& value) {
    AppendBytes(50, value.data(), value.size());
  }
  void set_compressed_packets(const uint8_t* data, size_t size) {
    AppendBytes(50, data, size);
  }
  template <typename T = TestEvent> T* set_for_testing() {
    return BeginNestedMessage<T>(900);
  }

  void set_trusted_uid(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_trusted_packet_sequence_id(uint32_t value) {
    AppendVarInt(10, value);
  }
  template <typename T = InternedData> T* set_interned_data() {
    return BeginNestedMessage<T>(12);
  }

  void set_sequence_flags(uint32_t value) {
    AppendVarInt(13, value);
  }
  void set_incremental_state_cleared(bool value) {
    AppendTinyVarInt(41, value);
  }
  template <typename T = TracePacketDefaults> T* set_trace_packet_defaults() {
    return BeginNestedMessage<T>(59);
  }

  void set_previous_packet_dropped(bool value) {
    AppendTinyVarInt(42, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_TRACING_DATA_SOURCE_H_
#define INCLUDE_PERFETTO_TRACING_DATA_SOURCE_H_

// This header contains the key class (DataSource) that a producer app should
// override in order to create a custom data source that gets tracing Start/Stop
// notifications and emits tracing data.

#include <assert.h>
#include <stddef.h>
#include <stdint.h>

#include <array>
#include <atomic>
#include <functional>
#include <memory>
#include <mutex>

// gen_amalgamated expanded: #include "perfetto/base/compiler.h"
// gen_amalgamated expanded: #include "perfetto/base/export.h"
// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/message_handle.h"
// gen_amalgamated expanded: #include "perfetto/tracing/buffer_exhausted_policy.h"
// gen_amalgamated expanded: #include "perfetto/tracing/core/forward_decls.h"
// gen_amalgamated expanded: #include "perfetto/tracing/internal/basic_types.h"
// gen_amalgamated expanded: #include "perfetto/tracing/internal/data_source_internal.h"
// gen_amalgamated expanded: #include "perfetto/tracing/internal/tracing_muxer.h"
// gen_amalgamated expanded: #include "perfetto/tracing/locked_handle.h"
// gen_amalgamated expanded: #include "perfetto/tracing/trace_writer_base.h"

// gen_amalgamated expanded: #include "protos/perfetto/trace/trace_packet.pbzero.h"

namespace perfetto {
namespace internal {
class TracingMuxerImpl;
class TrackEventCategoryRegistry;
template <typename, const internal::TrackEventCategoryRegistry*>
class TrackEventDataSource;
}  // namespace internal

// Base class with the virtual methods to get start/stop notifications.
// Embedders are supposed to derive the templated version below, not this one.
class PERFETTO_EXPORT DataSourceBase {
 public:
  virtual ~DataSourceBase();

  // TODO(primiano): change the const& args below to be pointers instead. It
  // makes it more awkward to handle output arguments and require mutable(s).
  // This requires synchronizing a breaking API change for existing embedders.

  // OnSetup() is invoked when tracing is configured. In most cases this happens
  // just before starting the trace. In the case of deferred start (see
  // deferred_start in trace_config.proto) start might happen later.
  class SetupArgs {
   public:
    // This is valid only within the scope of the OnSetup() call and must not
    // be retained.
    const DataSourceConfig* config = nullptr;

    // The index of this data source instance (0..kMaxDataSourceInstances - 1).
    uint32_t internal_instance_index = 0;
  };
  virtual void OnSetup(const SetupArgs&);

  class StartArgs {
   public:
    // The index of this data source instance (0..kMaxDataSourceInstances - 1).
    uint32_t internal_instance_index = 0;
  };
  virtual void OnStart(const StartArgs&);

  class StopArgs {
   public:
    virtual ~StopArgs();

    // HandleAsynchronously() can optionally be called to defer the tracing
    // session stop and write tracing data just before stopping.
    // This function returns a closure that must be invoked after the last
    // trace events have been emitted. The returned closure can be called from
    // any thread. The caller also needs to explicitly call TraceContext.Flush()
    // from the last Trace() lambda invocation because no other implicit flushes
    // will happen after the stop signal.
    // When this function is called, the tracing service will defer the stop of
    // the tracing session until the returned closure is invoked.
    // However, the caller cannot hang onto this closure for too long. The
    // tracing service will forcefully stop the tracing session without waiting
    // for pending producers after TraceConfig.data_source_stop_timeout_ms
    // (default: 5s, can be overridden by Consumers when starting a trace).
    // If the closure is called after this timeout an error will be logged and
    // the trace data emitted will not be present in the trace. No other
    // functional side effects (e.g. crashes or corruptions) will happen. In
    // other words, it is fine to accidentally hold onto this closure for too
    // long but, if that happens, some tracing data will be lost.
    virtual std::function<void()> HandleStopAsynchronously() const = 0;

    // The index of this data source instance (0..kMaxDataSourceInstances - 1).
    uint32_t internal_instance_index = 0;
  };
  virtual void OnStop(const StopArgs&);
};

struct DefaultDataSourceTraits {
  // |IncrementalStateType| can optionally be used store custom per-sequence
  // incremental data (e.g., interning tables). It should have a Clear() method
  // for when incremental state needs to be cleared. See
  // TraceContext::GetIncrementalState().
  using IncrementalStateType = void;

  // Allows overriding what type of thread-local state configuration the data
  // source uses. By default every data source gets independent thread-local
  // state, which means every instance uses separate trace writers and
  // incremental state even on the same thread. Some data sources (most notably
  // the track event data source) want to share trace writers and incremental
  // state on the same thread.
  static internal::DataSourceThreadLocalState* GetDataSourceTLS(
      internal::DataSourceStaticState* static_state,
      internal::TracingTLS* root_tls) {
    auto* ds_tls = &root_tls->data_sources_tls[static_state->index];
    // The per-type TLS is either zero-initialized or must have been initialized
    // for this specific data source type.
    assert(!ds_tls->static_state ||
           ds_tls->static_state->index == static_state->index);
    return ds_tls;
  }
};

// Templated base class meant to be derived by embedders to create a custom data
// source. DataSourceType must be the type of the derived class itself, e.g.:
// class MyDataSource : public DataSourceBase<MyDataSource> {...}.
//
// |DataSourceTraits| allows customizing the behavior of the data source. See
// |DefaultDataSourceTraits|.
template <typename DataSourceType,
          typename DataSourceTraits = DefaultDataSourceTraits>
class DataSource : public DataSourceBase {
  struct DefaultTracePointTraits;

 public:
  // The BufferExhaustedPolicy to use for TraceWriters of this DataSource.
  // Override this in your DataSource class to change the default, which is to
  // drop data on shared memory overruns.
  constexpr static BufferExhaustedPolicy kBufferExhaustedPolicy =
      BufferExhaustedPolicy::kDrop;

  // Argument passed to the lambda function passed to Trace() (below).
  class TraceContext {
   public:
    using TracePacketHandle =
        ::protozero::MessageHandle<::perfetto::protos::pbzero::TracePacket>;

    TraceContext(TraceContext&&) noexcept = default;
    ~TraceContext() = default;

    TracePacketHandle NewTracePacket() {
      return tls_inst_->trace_writer->NewTracePacket();
    }

    // Forces a commit of the thread-local tracing data written so far to the
    // service. This is almost never required (tracing data is periodically
    // committed as trace pages are filled up) and has a non-negligible
    // performance hit (requires an IPC + refresh of the current thread-local
    // chunk). The only case when this should be used is when handling OnStop()
    // asynchronously, to ensure sure that the data is committed before the
    // Stop timeout expires.
    // The TracePacketHandle obtained by the last NewTracePacket() call must be
    // finalized before calling Flush() (either implicitly by going out of scope
    // or by explicitly calling Finalize()).
    // |cb| is an optional callback. When non-null it will request the
    // service to ACK the flush and will be invoked on an internal thread after
    // the service has  acknowledged it. The callback might be NEVER INVOKED if
    // the service crashes or the IPC connection is dropped.
    void Flush(std::function<void()> cb = {}) {
      tls_inst_->trace_writer->Flush(cb);
    }

    // Returns a RAII handle to access the data source instance, guaranteeing
    // that it won't be deleted on another thread (because of trace stopping)
    // while accessing it from within the Trace() lambda.
    // The returned handle can be invalid (nullptr) if tracing is stopped
    // immediately before calling this. The caller is supposed to check for its
    // validity before using it. After checking, the handle is guaranteed to
    // remain valid until the handle goes out of scope.
    LockedHandle<DataSourceType> GetDataSourceLocked() {
      auto* internal_state = static_state_.TryGet(instance_index_);
      if (!internal_state)
        return LockedHandle<DataSourceType>();
      return LockedHandle<DataSourceType>(
          &internal_state->lock,
          static_cast<DataSourceType*>(internal_state->data_source.get()));
    }

    typename DataSourceTraits::IncrementalStateType* GetIncrementalState() {
      return reinterpret_cast<typename DataSourceTraits::IncrementalStateType*>(
          tls_inst_->incremental_state.get());
    }

   private:
    friend class DataSource;
    template <typename, const internal::TrackEventCategoryRegistry*>
    friend class internal::TrackEventDataSource;
    TraceContext(internal::DataSourceInstanceThreadLocalState* tls_inst,
                 uint32_t instance_index)
        : tls_inst_(tls_inst), instance_index_(instance_index) {}
    TraceContext(const TraceContext&) = delete;
    TraceContext& operator=(const TraceContext&) = delete;

    internal::DataSourceInstanceThreadLocalState* const tls_inst_;
    uint32_t const instance_index_;
  };

  // The main tracing method. Tracing code should call this passing a lambda as
  // argument, with the following signature: void(TraceContext).
  // The lambda will be called synchronously (i.e., always before Trace()
  // returns) only if tracing is enabled and the data source has been enabled in
  // the tracing config.
  // The lambda can be called more than once per Trace() call, in the case of
  // concurrent tracing sessions (or even if the data source is instantiated
  // twice within the same trace config).
  template <typename Lambda>
  static void Trace(Lambda tracing_fn) {
    CallIfEnabled<DefaultTracePointTraits>([&tracing_fn](uint32_t instances) {
      TraceWithInstances<DefaultTracePointTraits>(instances,
                                                  std::move(tracing_fn));
    });
  }

  // An efficient trace point guard for checking if this data source is active.
  // |callback| is a function which will only be called if there are active
  // instances. It is given an instance state parameter, which should be passed
  // to TraceWithInstances() to actually record trace data.
  template <typename Traits = DefaultTracePointTraits, typename Callback>
  static void CallIfEnabled(Callback callback) PERFETTO_ALWAYS_INLINE {
    // |instances| is a per-class bitmap that tells:
    // 1. If the data source is enabled at all.
    // 2. The index of the slot within |static_state_| that holds the instance
    //    state. In turn this allows to map the data source to the tracing
    //    session and buffers.
    // memory_order_relaxed is okay because:
    // - |instances| is re-read with an acquire barrier below if this succeeds.
    // - The code between this point and the acquire-load is based on static
    //    storage which has indefinite lifetime.
    uint32_t instances =
        Traits::GetActiveInstances()->load(std::memory_order_relaxed);

    // This is the tracing fast-path. Bail out immediately if tracing is not
    // enabled (or tracing is enabled but not for this data source).
    if (PERFETTO_LIKELY(!instances))
      return;
    callback(instances);
  }

  // The "lower half" of a trace point which actually performs tracing after
  // this data source has been determined to be active.
  // |instances| must be the instance state value retrieved through
  // CallIfEnabled().
  // |tracing_fn| will be called to record trace data as in Trace().
  //
  // TODO(primiano): all the stuff below should be outlined from the trace
  // point. Or at least we should have some compile-time traits like
  // kOptimizeBinarySize / kOptimizeTracingLatency.
  template <typename Traits = DefaultTracePointTraits, typename Lambda>
  static void TraceWithInstances(uint32_t instances, Lambda tracing_fn) {
    PERFETTO_DCHECK(instances);
    constexpr auto kMaxDataSourceInstances = internal::kMaxDataSourceInstances;

    // See tracing_muxer.h for the structure of the TLS.
    auto* tracing_impl = internal::TracingMuxer::Get();
    if (PERFETTO_UNLIKELY(!tls_state_))
      tls_state_ = GetOrCreateDataSourceTLS(&static_state_);

    // TracingTLS::generation is a global monotonic counter that is incremented
    // every time a tracing session is stopped. We use that as a signal to force
    // a slow-path garbage collection of all the trace writers for the current
    // thread and to destroy the ones that belong to tracing sessions that have
    // ended. This is to avoid having too many TraceWriter instances alive, each
    // holding onto one chunk of the shared memory buffer.
    // Rationale why memory_order_relaxed should be fine:
    // - The TraceWriter object that we use is always constructed and destructed
    //   on the current thread. There is no risk of accessing a half-initialized
    //   TraceWriter (which would be really bad).
    // - In the worst case, in the case of a race on the generation check, we
    //   might end up using a TraceWriter for the same data source that belongs
    //   to a stopped session. This is not really wrong, as we don't give any
    //   guarantee on the global atomicity of the stop. In the worst case the
    //   service will reject the data commit if this arrives too late.

    if (PERFETTO_UNLIKELY(
            tls_state_->root_tls->generation !=
            tracing_impl->generation(std::memory_order_relaxed))) {
      // Will update root_tls->generation.
      tracing_impl->DestroyStoppedTraceWritersForCurrentThread();
    }

    for (uint32_t i = 0; i < kMaxDataSourceInstances; i++) {
      internal::DataSourceState* instance_state =
          static_state_.TryGetCached(instances, i);
      if (!instance_state)
        continue;

      // Even if we passed the check above, the DataSourceInstance might be
      // still destroyed concurrently while this code runs. The code below is
      // designed to deal with such race, as follows:
      // - We don't access the user-defined data source instance state. The only
      //   bits of state we use are |backend_id| and |buffer_id|.
      // - Beyond those two integers, we access only the TraceWriter here. The
      //   TraceWriter is always safe because it lives on the TLS.
      // - |instance_state| is backed by static storage, so the pointer is
      //   always valid, even after the data source instance is destroyed.
      // - In the case of a race-on-destruction, we'll still see the latest
      //   backend_id and buffer_id and in the worst case keep trying writing
      //   into the tracing shared memory buffer after stopped. But this isn't
      //   really any worse than the case of the stop IPC being delayed by the
      //   kernel scheduler. The tracing service is robust against data commit
      //   attemps made after tracing is stopped.
      // There is a theoretical race that would case the wrong behavior w.r.t
      // writing data in the wrong buffer, but it's so rare that we ignore it:
      // if the data source is stopped and started kMaxDataSourceInstances
      // times (so that the same id is recycled) while we are in this function,
      // we might end up reusing the old data source's backend_id and buffer_id
      // for the new one, because we don't see the generation change past this
      // point. But stopping and starting tracing (even once) takes so much
      // handshaking to make this extremely unrealistic.

      auto& tls_inst = tls_state_->per_instance[i];
      if (PERFETTO_UNLIKELY(!tls_inst.trace_writer)) {
        // Here we need an acquire barrier, which matches the release-store made
        // by TracingMuxerImpl::SetupDataSource(), to ensure that the backend_id
        // and buffer_id are consistent.
        instances =
            Traits::GetActiveInstances()->load(std::memory_order_acquire);
        instance_state = static_state_.TryGetCached(instances, i);
        if (!instance_state || !instance_state->trace_lambda_enabled)
          return;
        tls_inst.backend_id = instance_state->backend_id;
        tls_inst.buffer_id = instance_state->buffer_id;
        tls_inst.trace_writer = tracing_impl->CreateTraceWriter(
            instance_state, DataSourceType::kBufferExhaustedPolicy);
        CreateIncrementalState(
            &tls_inst,
            static_cast<typename DataSourceTraits::IncrementalStateType*>(
                nullptr));

        // Even in the case of out-of-IDs, SharedMemoryArbiterImpl returns a
        // NullTraceWriter. The returned pointer should never be null.
        assert(tls_inst.trace_writer);
      }

      tracing_fn(TraceContext(&tls_inst, i));
    }
  }

  // Registers the data source on all tracing backends, including ones that
  // connect after the registration. Doing so enables the data source to receive
  // Setup/Start/Stop notifications and makes the Trace() method work when
  // tracing is enabled and the data source is selected.
  // This must be called after Tracing::Initialize().
  // The caller must also use the DEFINE_DATA_SOURCE_STATIC_MEMBERS() macro
  // documented below.
  // Can return false to signal failure if attemping to register more than
  // kMaxDataSources (32) data sources types.
  static bool Register(const DataSourceDescriptor& descriptor) {
    // Silences -Wunused-variable warning in case the trace method is not used
    // by the translation unit that declares the data source.
    (void)static_state_;
    (void)tls_state_;

    auto factory = [] {
      return std::unique_ptr<DataSourceBase>(new DataSourceType());
    };
    auto* tracing_impl = internal::TracingMuxer::Get();
    return tracing_impl->RegisterDataSource(descriptor, factory,
                                            &static_state_);
  }

 private:
  // Traits for customizing the behavior of a specific trace point.
  struct DefaultTracePointTraits {
    // By default, every call to DataSource::Trace() will record trace events
    // for every active instance of that data source. A single trace point can,
    // however, use a custom set of enable flags for more fine grained control
    // of when that trace point is active.
    //
    // DANGER: when doing this, the data source must use the appropriate memory
    // fences when changing the state of the bitmap.
    static constexpr std::atomic<uint32_t>* GetActiveInstances() {
      return &static_state_.valid_instances;
    }
  };

  // Create the user provided incremental state in the given thread-local
  // storage. Note: The second parameter here is used to specialize the case
  // where there is no incremental state type.
  template <typename T>
  static void CreateIncrementalState(
      internal::DataSourceInstanceThreadLocalState* tls_inst,
      const T*) {
    PERFETTO_DCHECK(!tls_inst->incremental_state);
    tls_inst->incremental_state =
        internal::DataSourceInstanceThreadLocalState::IncrementalStatePointer(
            reinterpret_cast<void*>(new T()),
            [](void* p) { delete reinterpret_cast<T*>(p); });
  }
  static void CreateIncrementalState(
      internal::DataSourceInstanceThreadLocalState*,
      const void*) {}

  // Note that the returned object is one per-thread per-data-source-type, NOT
  // per data-source *instance*.
  static internal::DataSourceThreadLocalState* GetOrCreateDataSourceTLS(
      internal::DataSourceStaticState* static_state) {
    auto* tracing_impl = internal::TracingMuxer::Get();
    internal::TracingTLS* root_tls = tracing_impl->GetOrCreateTracingTLS();
    internal::DataSourceThreadLocalState* ds_tls =
        DataSourceTraits::GetDataSourceTLS(static_state, root_tls);
    // We keep re-initializing as the initialization is idempotent and not worth
    // the code for extra checks.
    ds_tls->static_state = static_state;
    assert(!ds_tls->root_tls || ds_tls->root_tls == root_tls);
    ds_tls->root_tls = root_tls;
    return ds_tls;
  }

  // Static state. Accessed by the static Trace() method fastpaths.
  static internal::DataSourceStaticState static_state_;

  // This TLS object is a cached raw pointer and has deliberately no destructor.
  // The Platform implementation is supposed to create and manage the lifetime
  // of the Platform::ThreadLocalObject and take care of destroying it.
  // This is because non-POD thread_local variables have subtleties (global
  // destructors) that we need to defer to the embedder. In chromium's platform
  // implementation, for instance, the tls slot is implemented using
  // chromium's base::ThreadLocalStorage.
  static thread_local internal::DataSourceThreadLocalState* tls_state_;
};

template <typename T, typename D>
internal::DataSourceStaticState DataSource<T, D>::static_state_;
template <typename T, typename D>
thread_local internal::DataSourceThreadLocalState* DataSource<T, D>::tls_state_;

}  // namespace perfetto

// Not needed -- only here for backwards compatibility.
// TODO(skyostil): Remove this macro.
#define PERFETTO_DECLARE_DATA_SOURCE_STATIC_MEMBERS(...)

// The API client must use this in a translation unit. This is because it needs
// to instantiate the static storage for the datasource to allow the fastpath
// enabled check.
#define PERFETTO_DEFINE_DATA_SOURCE_STATIC_MEMBERS(...)        \
  template <>                                                  \
  perfetto::internal::DataSourceStaticState                    \
      perfetto::DataSource<__VA_ARGS__>::static_state_{};      \
  template <>                                                  \
  thread_local perfetto::internal::DataSourceThreadLocalState* \
      perfetto::DataSource<__VA_ARGS__>::tls_state_ = nullptr

#endif  // INCLUDE_PERFETTO_TRACING_DATA_SOURCE_H_
// gen_amalgamated begin header: /Users/primiano/code/perfetto/tools/../include/perfetto/tracing/tracing.h
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_TRACING_TRACING_H_
#define INCLUDE_PERFETTO_TRACING_TRACING_H_

#include <stddef.h>
#include <stdint.h>

#include <functional>
#include <memory>
#include <string>
#include <vector>

// gen_amalgamated expanded: #include "perfetto/base/export.h"
// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/tracing/core/forward_decls.h"
namespace perfetto {

class TracingBackend;
class Platform;
class TracingSession;  // Declared below.

enum BackendType : uint32_t {
  kUnspecifiedBackend = 0,

  // Connects to a previously-initialized perfetto tracing backend for
  // in-process. If the in-process backend has not been previously initialized
  // it will do so and create the tracing service on a dedicated thread.
  kInProcessBackend = 1 << 0,

  // Connects to the system tracing service (e.g. on Linux/Android/Mac uses a
  // named UNIX socket).
  kSystemBackend = 1 << 1,

  // Used to provide a custom IPC transport to connect to the service.
  // TracingInitArgs::custom_backend must be non-null and point to an
  // indefinitely lived instance.
  kCustomBackend = 1 << 2,
};

struct TracingInitArgs {
  uint32_t backends = 0;                     // One or more BackendFlags.
  TracingBackend* custom_backend = nullptr;  // [Optional].

  // [Optional] Platform implementation. It allows the embedder to take control
  // of platform-specific bits like thread creation and TLS slot handling. If
  // not set it will use Platform::GetDefaultPlatform().
  Platform* platform = nullptr;

  // [Optional] Tune the size of the shared memory buffer between the current
  // process and the service backend(s). This is a trade-off between memory
  // footprint and the ability to sustain bursts of trace writes (see comments
  // in shared_memory_abi.h).
  // If set, the value must be a multiple of 4KB. The value can be ignored if
  // larger than kMaxShmSize (32MB) or not a multiple of 4KB.
  uint32_t shmem_size_hint_kb = 0;

  // [Optional] Specifies the preferred size of each page in the shmem buffer.
  // This is a trade-off between IPC overhead and fragmentation/efficiency of
  // the shmem buffer in presence of multiple writer threads.
  // Must be one of [4, 8, 16, 32].
  uint32_t shmem_page_size_hint_kb = 0;

 protected:
  friend class Tracing;
  bool dcheck_is_on_ = PERFETTO_DCHECK_IS_ON();
};

// The entry-point for using perfetto.
class PERFETTO_EXPORT Tracing {
 public:
  // Initializes Perfetto with the given backends in the calling process and/or
  // with a user-provided backend. Can only be called once.
  static void Initialize(const TracingInitArgs&);

  // Start a new tracing session using the given tracing backend. Use
  // |kUnspecifiedBackend| to select an available backend automatically.
  // For the moment this can be used only when initializing tracing in
  // kInProcess mode. For the system mode use the 'bin/perfetto' cmdline client.
  static std::unique_ptr<TracingSession> NewTrace(
      BackendType = kUnspecifiedBackend);

 private:
  Tracing() = delete;
};

class PERFETTO_EXPORT TracingSession {
 public:
  virtual ~TracingSession();

  // Configure the session passing the trace config.
  // If a writable file handle is given through |fd|, the trace will
  // automatically written to that file. Otherwise you should call ReadTrace()
  // to retrieve the trace data. This call does not take ownership of |fd|.
  // TODO(primiano): add an error callback.
  virtual void Setup(const TraceConfig&, int fd = -1) = 0;

  // Enable tracing asynchronously.
  virtual void Start() = 0;

  // Enable tracing and block until tracing has started. Note that if data
  // sources are registered after this call was initiated, the call may return
  // before the additional data sources have started. Also, if other producers
  // (e.g., with system-wide tracing) have registered data sources without start
  // notification support, this call may return before those data sources have
  // started.
  virtual void StartBlocking() = 0;

  // Disable tracing asynchronously.
  // Use SetOnStopCallback() to get a notification when the tracing session is
  // fully stopped and all data sources have acked.
  virtual void Stop() = 0;

  // Disable tracing and block until tracing has stopped.
  virtual void StopBlocking() = 0;

  // This callback will be invoked when tracing is disabled.
  // This can happen either when explicitly calling TracingSession.Stop() or
  // when the trace reaches its |duration_ms| time limit.
  // This callback will be invoked on an internal perfetto thread.
  virtual void SetOnStopCallback(std::function<void()>) = 0;

  // Struct passed as argument to the callback passed to ReadTrace().
  // [data, size] is guaranteed to contain 1 or more full trace packets, which
  // can be decoded using trace.proto. No partial or truncated packets are
  // exposed. If the trace is empty this returns a zero-sized nullptr with
  // |has_more| == true to signal EOF.
  // This callback will be invoked on an internal perfetto thread.
  struct ReadTraceCallbackArgs {
    const char* data = nullptr;
    size_t size = 0;

    // When false, this will be the last invocation of the callback for this
    // read cycle.
    bool has_more = false;
  };

  // Reads back the trace data (raw protobuf-encoded bytes) asynchronously.
  // Can be called at any point during the trace, typically but not necessarily,
  // after stopping. Reading the trace data is a destructive operation w.r.t.
  // contents of the trace buffer and is not idempotent.
  // A single ReadTrace() call can yield >1 callback invocations, until
  // |has_more| is true.
  using ReadTraceCallback = std::function<void(ReadTraceCallbackArgs)>;
  virtual void ReadTrace(ReadTraceCallback) = 0;

  // Synchronous version of ReadTrace(). It blocks the calling thread until all
  // the trace contents are read. This is slow and inefficient (involves more
  // copies) and is mainly intended for testing.
  std::vector<char> ReadTraceBlocking();
};

}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_TRACING_TRACING_H_
// gen_amalgamated begin header: /Users/primiano/code/perfetto/tools/../include/perfetto/tracing/tracing_backend.h
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_TRACING_TRACING_BACKEND_H_
#define INCLUDE_PERFETTO_TRACING_TRACING_BACKEND_H_

#include <memory>
#include <string>

// The embedder can (but doesn't have to) extend the TracingBackend class and
// pass as an argument to Tracing::Initialize(kCustomBackend) to override the
// way to reach the service. This is for peculiar cases where the embedder has
// a multi-process architecture and wants to override the IPC transport. The
// real use-case for this at the time of writing is chromium (+ Mojo IPC).
// Extending this class requires depending on the full set of perfetto headers
// (not just /public/). Contact the team before doing so as the non-public
// headers are not guaranteed to be API stable.

namespace perfetto {

namespace base {
class TaskRunner;
}

// These classes are declared in headers outside of /public/.
class Consumer;
class ConsumerEndpoint;
class Producer;
class ProducerEndpoint;

class TracingBackend {
 public:
  virtual ~TracingBackend();

  // Connects a Producer instance and obtains a ProducerEndpoint, which is
  // essentially a 1:1 channel between one Producer and the Service.
  // To disconnect just destroy the returned endpoint object. It is safe to
  // destroy the Producer once Producer::OnDisconnect() has been invoked.
  struct ConnectProducerArgs {
    std::string producer_name;

    // The Producer object that will receive calls like Start/StopDataSource().
    // The caller has to guarantee that this object is valid as long as the
    // returned ProducerEndpoint is alive.
    Producer* producer = nullptr;

    // The task runner where the Producer methods will be called onto.
    // The caller has to guarantee that the passed TaskRunner is valid as long
    // as the returned ProducerEndpoint is alive.
    ::perfetto::base::TaskRunner* task_runner = nullptr;

    // These get propagated from TracingInitArgs and are optionally provided by
    // the client when calling Tracing::Initialize().
    uint32_t shmem_size_hint_bytes = 0;
    uint32_t shmem_page_size_hint_bytes = 0;
  };

  virtual std::unique_ptr<ProducerEndpoint> ConnectProducer(
      const ConnectProducerArgs&) = 0;

  // As above, for the Consumer-side.
  struct ConnectConsumerArgs {
    // The Consumer object that will receive calls like OnTracingDisabled(),
    // OnTraceData().
    Consumer* consumer{};

    // The task runner where the Consumer methods will be called onto.
    ::perfetto::base::TaskRunner* task_runner{};
  };
  virtual std::unique_ptr<ConsumerEndpoint> ConnectConsumer(
      const ConnectConsumerArgs&) = 0;
};

}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_TRACING_TRACING_BACKEND_H_
// gen_amalgamated begin header: /Users/primiano/code/perfetto/tools/../include/perfetto/tracing/track_event.h
// gen_amalgamated begin header: /Users/primiano/code/perfetto/tools/../include/perfetto/base/time.h
/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_BASE_TIME_H_
#define INCLUDE_PERFETTO_BASE_TIME_H_

#include <time.h>

#include <chrono>

// gen_amalgamated expanded: #include "perfetto/base/build_config.h"
// gen_amalgamated expanded: #include "perfetto/base/logging.h"

#if PERFETTO_BUILDFLAG(PERFETTO_OS_MACOSX)
#include <mach/mach_init.h>
#include <mach/mach_port.h>
#include <mach/mach_time.h>
#include <mach/thread_act.h>
#endif

#if PERFETTO_BUILDFLAG(PERFETTO_OS_WASM)
#include <emscripten/emscripten.h>
#endif

namespace perfetto {
namespace base {

using TimeSeconds = std::chrono::seconds;
using TimeMillis = std::chrono::milliseconds;
using TimeNanos = std::chrono::nanoseconds;

inline TimeNanos FromPosixTimespec(const struct timespec& ts) {
  return TimeNanos(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

void SleepMicroseconds(unsigned interval_us);

#if PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)

TimeNanos GetWallTimeNs();
TimeNanos GetThreadCPUTimeNs();

// TODO: Clock that counts time during suspend is not implemented on Windows.
inline TimeNanos GetBootTimeNs() {
  return GetWallTimeNs();
}

#elif PERFETTO_BUILDFLAG(PERFETTO_OS_MACOSX)

inline TimeNanos GetWallTimeNs() {
  auto init_time_factor = []() -> uint64_t {
    mach_timebase_info_data_t timebase_info;
    mach_timebase_info(&timebase_info);
    return timebase_info.numer / timebase_info.denom;
  };

  static uint64_t monotonic_timebase_factor = init_time_factor();
  return TimeNanos(mach_absolute_time() * monotonic_timebase_factor);
}

// TODO: Clock that counts time during suspend is not implemented on Mac.
inline TimeNanos GetBootTimeNs() {
  return GetWallTimeNs();
}

inline TimeNanos GetThreadCPUTimeNs() {
  mach_port_t this_thread = mach_thread_self();
  mach_msg_type_number_t count = THREAD_BASIC_INFO_COUNT;
  thread_basic_info_data_t info{};
  kern_return_t kr =
      thread_info(this_thread, THREAD_BASIC_INFO,
                  reinterpret_cast<thread_info_t>(&info), &count);
  mach_port_deallocate(mach_task_self(), this_thread);

  if (kr != KERN_SUCCESS) {
    PERFETTO_DFATAL("Failed to get CPU time.");
    return TimeNanos(0);
  }
  return TimeNanos(info.user_time.seconds * 1000000000LL +
                   info.user_time.microseconds * 1000LL +
                   info.system_time.seconds * 1000000000LL +
                   info.system_time.microseconds * 1000LL);
}

#elif PERFETTO_BUILDFLAG(PERFETTO_OS_WASM)

inline TimeNanos GetWallTimeNs() {
  return TimeNanos(static_cast<uint64_t>(emscripten_get_now()) * 1000000);
}

inline TimeNanos GetThreadCPUTimeNs() {
  return TimeNanos(0);
}

// TODO: Clock that counts time during suspend is not implemented on WASM.
inline TimeNanos GetBootTimeNs() {
  return GetWallTimeNs();
}

#else

constexpr clockid_t kWallTimeClockSource = CLOCK_MONOTONIC;

inline TimeNanos GetTimeInternalNs(clockid_t clk_id) {
  struct timespec ts = {};
  PERFETTO_CHECK(clock_gettime(clk_id, &ts) == 0);
  return FromPosixTimespec(ts);
}

// Return ns from boot. Conversely to GetWallTimeNs, this clock counts also time
// during suspend (when supported).
inline TimeNanos GetBootTimeNs() {
  // Determine if CLOCK_BOOTTIME is available on the first call.
  static const clockid_t kBootTimeClockSource = [] {
    struct timespec ts = {};
    int res = clock_gettime(CLOCK_BOOTTIME, &ts);
    return res == 0 ? CLOCK_BOOTTIME : kWallTimeClockSource;
  }();
  return GetTimeInternalNs(kBootTimeClockSource);
}

inline TimeNanos GetWallTimeNs() {
  return GetTimeInternalNs(kWallTimeClockSource);
}

inline TimeNanos GetThreadCPUTimeNs() {
  return GetTimeInternalNs(CLOCK_THREAD_CPUTIME_ID);
}

#endif

inline TimeMillis GetWallTimeMs() {
  return std::chrono::duration_cast<TimeMillis>(GetWallTimeNs());
}

inline TimeSeconds GetWallTimeS() {
  return std::chrono::duration_cast<TimeSeconds>(GetWallTimeNs());
}

inline struct timespec ToPosixTimespec(TimeMillis time) {
  struct timespec ts {};
  const long time_s = static_cast<long>(time.count() / 1000);
  ts.tv_sec = time_s;
  ts.tv_nsec = (static_cast<long>(time.count()) - time_s * 1000L) * 1000000L;
  return ts;
}

}  // namespace base
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_BASE_TIME_H_
// gen_amalgamated begin header: /Users/primiano/code/perfetto/tools/../include/perfetto/tracing/internal/track_event_data_source.h
// gen_amalgamated begin header: /Users/primiano/code/perfetto/tools/../include/perfetto/tracing/event_context.h
// gen_amalgamated begin header: /Users/primiano/code/perfetto/tools/../include/perfetto/tracing/internal/track_event_internal.h
// gen_amalgamated begin header: /Users/primiano/code/perfetto/tools/../include/perfetto/protozero/scattered_heap_buffer.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_PROTOZERO_SCATTERED_HEAP_BUFFER_H_
#define INCLUDE_PERFETTO_PROTOZERO_SCATTERED_HEAP_BUFFER_H_

#include <memory>
#include <string>
#include <vector>

// gen_amalgamated expanded: #include "perfetto/base/export.h"
// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/protozero/scattered_stream_writer.h"

namespace protozero {

class Message;

class PERFETTO_EXPORT ScatteredHeapBuffer
    : public protozero::ScatteredStreamWriter::Delegate {
 public:
  class PERFETTO_EXPORT Slice {
   public:
    Slice();
    explicit Slice(size_t size);
    Slice(Slice&& slice) noexcept;
    ~Slice();
    Slice& operator=(Slice&&);

    inline protozero::ContiguousMemoryRange GetTotalRange() const {
      return {buffer_.get(), buffer_.get() + size_};
    }

    inline protozero::ContiguousMemoryRange GetUsedRange() const {
      return {buffer_.get(), buffer_.get() + size_ - unused_bytes_};
    }

    uint8_t* start() const { return buffer_.get(); }
    size_t size() const { return size_; }
    size_t unused_bytes() const { return unused_bytes_; }
    void set_unused_bytes(size_t unused_bytes) {
      PERFETTO_DCHECK(unused_bytes_ <= size_);
      unused_bytes_ = unused_bytes;
    }

    void Clear();

   private:
    std::unique_ptr<uint8_t[]> buffer_;
    size_t size_;
    size_t unused_bytes_;
  };

  ScatteredHeapBuffer(size_t initial_slice_size_bytes = 128,
                      size_t maximum_slice_size_bytes = 128 * 1024);
  ~ScatteredHeapBuffer() override;

  // protozero::ScatteredStreamWriter::Delegate implementation.
  protozero::ContiguousMemoryRange GetNewBuffer() override;

  // Stitch all the slices into a single contiguous buffer.
  std::vector<uint8_t> StitchSlices();

  // Note that the returned ranges point back to this buffer and thus cannot
  // outlive it.
  std::vector<protozero::ContiguousMemoryRange> GetRanges();

  const std::vector<Slice>& slices() const { return slices_; }

  void set_writer(protozero::ScatteredStreamWriter* writer) {
    writer_ = writer;
  }

  // Update unused_bytes() of the current |Slice| based on the writer's state.
  void AdjustUsedSizeOfCurrentSlice();

  // Returns the total size the slices occupy in heap memory (including unused).
  size_t GetTotalSize();

  // Reset the contents of this buffer but retain one slice allocation (if it
  // exists) to be reused for future writes.
  void Reset();

 private:
  size_t next_slice_size_;
  const size_t maximum_slice_size_;
  protozero::ScatteredStreamWriter* writer_ = nullptr;
  std::vector<Slice> slices_;

  // Used to keep an allocated slice around after this buffer is reset.
  Slice cached_slice_;
};

// Helper function to create heap-based protozero messages in one line.
// Useful when manually serializing a protozero message (primarily in
// tests/utilities). So instead of the following:
//   protozero::MyMessage msg;
//   protozero::ScatteredHeapBuffer shb;
//   protozero::ScatteredStreamWriter writer(&shb);
//   shb.set_writer(&writer);
//   msg.Reset(&writer);
//   ...
// You can write:
//   protozero::HeapBuffered<protozero::MyMessage> msg;
//   msg->set_stuff(...);
//   msg.SerializeAsString();
template <typename T = ::protozero::Message>
class HeapBuffered {
 public:
  HeapBuffered() : HeapBuffered(4096, 4096) {}
  HeapBuffered(size_t initial_slice_size_bytes, size_t maximum_slice_size_bytes)
      : shb_(initial_slice_size_bytes, maximum_slice_size_bytes),
        writer_(&shb_) {
    shb_.set_writer(&writer_);
    msg_.Reset(&writer_);
  }

  // This can't be neither copied nor moved because Message hands out pointers
  // to itself when creating submessages.
  HeapBuffered(const HeapBuffered&) = delete;
  HeapBuffered& operator=(const HeapBuffered&) = delete;
  HeapBuffered(HeapBuffered&&) = delete;
  HeapBuffered& operator=(HeapBuffered&&) = delete;

  T* get() { return &msg_; }
  T* operator->() { return &msg_; }

  bool empty() const { return shb_.slices().empty(); }

  std::vector<uint8_t> SerializeAsArray() {
    msg_.Finalize();
    return shb_.StitchSlices();
  }

  std::string SerializeAsString() {
    auto vec = SerializeAsArray();
    return std::string(reinterpret_cast<const char*>(vec.data()), vec.size());
  }

  std::vector<protozero::ContiguousMemoryRange> GetRanges() {
    msg_.Finalize();
    return shb_.GetRanges();
  }

  void Reset() {
    shb_.Reset();
    writer_.Reset(protozero::ContiguousMemoryRange{});
    msg_.Reset(&writer_);
    PERFETTO_DCHECK(empty());
  }

 private:
  ScatteredHeapBuffer shb_;
  ScatteredStreamWriter writer_;
  T msg_;
};

}  // namespace protozero

#endif  // INCLUDE_PERFETTO_PROTOZERO_SCATTERED_HEAP_BUFFER_H_
// gen_amalgamated begin header: /Users/primiano/code/perfetto/tools/../out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/interned_data/interned_data.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_INTERNED_DATA_INTERNED_DATA_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_INTERNED_DATA_INTERNED_DATA_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class Callstack;
class DebugAnnotationName;
class EventCategory;
class EventName;
class Frame;
class InternedString;
class LogMessageBody;
class Mapping;
class ProfiledFrameSymbols;
class SourceLocation;

class InternedData_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/22, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  InternedData_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit InternedData_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit InternedData_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_event_categories() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> event_categories() const { return GetRepeated<::protozero::ConstBytes>(1); }
  bool has_event_names() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> event_names() const { return GetRepeated<::protozero::ConstBytes>(2); }
  bool has_debug_annotation_names() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> debug_annotation_names() const { return GetRepeated<::protozero::ConstBytes>(3); }
  bool has_source_locations() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> source_locations() const { return GetRepeated<::protozero::ConstBytes>(4); }
  bool has_log_message_body() const { return at<20>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> log_message_body() const { return GetRepeated<::protozero::ConstBytes>(20); }
  bool has_build_ids() const { return at<16>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> build_ids() const { return GetRepeated<::protozero::ConstBytes>(16); }
  bool has_mapping_paths() const { return at<17>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> mapping_paths() const { return GetRepeated<::protozero::ConstBytes>(17); }
  bool has_source_paths() const { return at<18>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> source_paths() const { return GetRepeated<::protozero::ConstBytes>(18); }
  bool has_function_names() const { return at<5>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> function_names() const { return GetRepeated<::protozero::ConstBytes>(5); }
  bool has_profiled_frame_symbols() const { return at<21>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> profiled_frame_symbols() const { return GetRepeated<::protozero::ConstBytes>(21); }
  bool has_mappings() const { return at<19>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> mappings() const { return GetRepeated<::protozero::ConstBytes>(19); }
  bool has_frames() const { return at<6>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> frames() const { return GetRepeated<::protozero::ConstBytes>(6); }
  bool has_callstacks() const { return at<7>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> callstacks() const { return GetRepeated<::protozero::ConstBytes>(7); }
  bool has_vulkan_memory_keys() const { return at<22>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> vulkan_memory_keys() const { return GetRepeated<::protozero::ConstBytes>(22); }
};

class InternedData : public ::protozero::Message {
 public:
  using Decoder = InternedData_Decoder;
  enum : int32_t {
    kEventCategoriesFieldNumber = 1,
    kEventNamesFieldNumber = 2,
    kDebugAnnotationNamesFieldNumber = 3,
    kSourceLocationsFieldNumber = 4,
    kLogMessageBodyFieldNumber = 20,
    kBuildIdsFieldNumber = 16,
    kMappingPathsFieldNumber = 17,
    kSourcePathsFieldNumber = 18,
    kFunctionNamesFieldNumber = 5,
    kProfiledFrameSymbolsFieldNumber = 21,
    kMappingsFieldNumber = 19,
    kFramesFieldNumber = 6,
    kCallstacksFieldNumber = 7,
    kVulkanMemoryKeysFieldNumber = 22,
  };
  template <typename T = EventCategory> T* add_event_categories() {
    return BeginNestedMessage<T>(1);
  }

  template <typename T = EventName> T* add_event_names() {
    return BeginNestedMessage<T>(2);
  }

  template <typename T = DebugAnnotationName> T* add_debug_annotation_names() {
    return BeginNestedMessage<T>(3);
  }

  template <typename T = SourceLocation> T* add_source_locations() {
    return BeginNestedMessage<T>(4);
  }

  template <typename T = LogMessageBody> T* add_log_message_body() {
    return BeginNestedMessage<T>(20);
  }

  template <typename T = InternedString> T* add_build_ids() {
    return BeginNestedMessage<T>(16);
  }

  template <typename T = InternedString> T* add_mapping_paths() {
    return BeginNestedMessage<T>(17);
  }

  template <typename T = InternedString> T* add_source_paths() {
    return BeginNestedMessage<T>(18);
  }

  template <typename T = InternedString> T* add_function_names() {
    return BeginNestedMessage<T>(5);
  }

  template <typename T = ProfiledFrameSymbols> T* add_profiled_frame_symbols() {
    return BeginNestedMessage<T>(21);
  }

  template <typename T = Mapping> T* add_mappings() {
    return BeginNestedMessage<T>(19);
  }

  template <typename T = Frame> T* add_frames() {
    return BeginNestedMessage<T>(6);
  }

  template <typename T = Callstack> T* add_callstacks() {
    return BeginNestedMessage<T>(7);
  }

  template <typename T = InternedString> T* add_vulkan_memory_keys() {
    return BeginNestedMessage<T>(22);
  }

};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: /Users/primiano/code/perfetto/tools/../out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/track_event/track_event.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACK_EVENT_TRACK_EVENT_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACK_EVENT_TRACK_EVENT_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class DebugAnnotation;
class LogMessage;
class TaskExecution;
class TrackEvent_LegacyEvent;
enum TrackEvent_LegacyEvent_FlowDirection : int32_t;
enum TrackEvent_LegacyEvent_InstantEventScope : int32_t;
enum TrackEvent_Type : int32_t;

enum TrackEvent_Type : int32_t {
  TrackEvent_Type_TYPE_UNSPECIFIED = 0,
  TrackEvent_Type_TYPE_SLICE_BEGIN = 1,
  TrackEvent_Type_TYPE_SLICE_END = 2,
  TrackEvent_Type_TYPE_INSTANT = 3,
};

const TrackEvent_Type TrackEvent_Type_MIN = TrackEvent_Type_TYPE_UNSPECIFIED;
const TrackEvent_Type TrackEvent_Type_MAX = TrackEvent_Type_TYPE_INSTANT;

enum TrackEvent_LegacyEvent_FlowDirection : int32_t {
  TrackEvent_LegacyEvent_FlowDirection_FLOW_UNSPECIFIED = 0,
  TrackEvent_LegacyEvent_FlowDirection_FLOW_IN = 1,
  TrackEvent_LegacyEvent_FlowDirection_FLOW_OUT = 2,
  TrackEvent_LegacyEvent_FlowDirection_FLOW_INOUT = 3,
};

const TrackEvent_LegacyEvent_FlowDirection TrackEvent_LegacyEvent_FlowDirection_MIN = TrackEvent_LegacyEvent_FlowDirection_FLOW_UNSPECIFIED;
const TrackEvent_LegacyEvent_FlowDirection TrackEvent_LegacyEvent_FlowDirection_MAX = TrackEvent_LegacyEvent_FlowDirection_FLOW_INOUT;

enum TrackEvent_LegacyEvent_InstantEventScope : int32_t {
  TrackEvent_LegacyEvent_InstantEventScope_SCOPE_UNSPECIFIED = 0,
  TrackEvent_LegacyEvent_InstantEventScope_SCOPE_GLOBAL = 1,
  TrackEvent_LegacyEvent_InstantEventScope_SCOPE_PROCESS = 2,
  TrackEvent_LegacyEvent_InstantEventScope_SCOPE_THREAD = 3,
};

const TrackEvent_LegacyEvent_InstantEventScope TrackEvent_LegacyEvent_InstantEventScope_MIN = TrackEvent_LegacyEvent_InstantEventScope_SCOPE_UNSPECIFIED;
const TrackEvent_LegacyEvent_InstantEventScope TrackEvent_LegacyEvent_InstantEventScope_MAX = TrackEvent_LegacyEvent_InstantEventScope_SCOPE_THREAD;

class EventName_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  EventName_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit EventName_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit EventName_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_iid() const { return at<1>().valid(); }
  uint64_t iid() const { return at<1>().as_uint64(); }
  bool has_name() const { return at<2>().valid(); }
  ::protozero::ConstChars name() const { return at<2>().as_string(); }
};

class EventName : public ::protozero::Message {
 public:
  using Decoder = EventName_Decoder;
  enum : int32_t {
    kIidFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  void set_iid(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_name(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void set_name(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
};

class EventCategory_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  EventCategory_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit EventCategory_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit EventCategory_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_iid() const { return at<1>().valid(); }
  uint64_t iid() const { return at<1>().as_uint64(); }
  bool has_name() const { return at<2>().valid(); }
  ::protozero::ConstChars name() const { return at<2>().as_string(); }
};

class EventCategory : public ::protozero::Message {
 public:
  using Decoder = EventCategory_Decoder;
  enum : int32_t {
    kIidFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  void set_iid(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_name(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void set_name(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
};

class TrackEventDefaults_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/10, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TrackEventDefaults_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TrackEventDefaults_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TrackEventDefaults_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_track_uuid() const { return at<10>().valid(); }
  uint64_t track_uuid() const { return at<10>().as_uint64(); }
};

class TrackEventDefaults : public ::protozero::Message {
 public:
  using Decoder = TrackEventDefaults_Decoder;
  enum : int32_t {
    kTrackUuidFieldNumber = 10,
  };
  void set_track_uuid(uint64_t value) {
    AppendVarInt(10, value);
  }
};

class TrackEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/23, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  TrackEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TrackEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TrackEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_category_iids() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator<uint64_t> category_iids() const { return GetRepeated<uint64_t>(3); }
  bool has_categories() const { return at<22>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstChars> categories() const { return GetRepeated<::protozero::ConstChars>(22); }
  bool has_name_iid() const { return at<10>().valid(); }
  uint64_t name_iid() const { return at<10>().as_uint64(); }
  bool has_name() const { return at<23>().valid(); }
  ::protozero::ConstChars name() const { return at<23>().as_string(); }
  bool has_type() const { return at<9>().valid(); }
  int32_t type() const { return at<9>().as_int32(); }
  bool has_track_uuid() const { return at<11>().valid(); }
  uint64_t track_uuid() const { return at<11>().as_uint64(); }
  bool has_thread_time_delta_us() const { return at<2>().valid(); }
  int64_t thread_time_delta_us() const { return at<2>().as_int64(); }
  bool has_thread_time_absolute_us() const { return at<17>().valid(); }
  int64_t thread_time_absolute_us() const { return at<17>().as_int64(); }
  bool has_thread_instruction_count_delta() const { return at<8>().valid(); }
  int64_t thread_instruction_count_delta() const { return at<8>().as_int64(); }
  bool has_thread_instruction_count_absolute() const { return at<20>().valid(); }
  int64_t thread_instruction_count_absolute() const { return at<20>().as_int64(); }
  bool has_debug_annotations() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> debug_annotations() const { return GetRepeated<::protozero::ConstBytes>(4); }
  bool has_task_execution() const { return at<5>().valid(); }
  ::protozero::ConstBytes task_execution() const { return at<5>().as_bytes(); }
  bool has_log_message() const { return at<21>().valid(); }
  ::protozero::ConstBytes log_message() const { return at<21>().as_bytes(); }
  bool has_timestamp_delta_us() const { return at<1>().valid(); }
  int64_t timestamp_delta_us() const { return at<1>().as_int64(); }
  bool has_timestamp_absolute_us() const { return at<16>().valid(); }
  int64_t timestamp_absolute_us() const { return at<16>().as_int64(); }
  bool has_legacy_event() const { return at<6>().valid(); }
  ::protozero::ConstBytes legacy_event() const { return at<6>().as_bytes(); }
};

class TrackEvent : public ::protozero::Message {
 public:
  using Decoder = TrackEvent_Decoder;
  enum : int32_t {
    kCategoryIidsFieldNumber = 3,
    kCategoriesFieldNumber = 22,
    kNameIidFieldNumber = 10,
    kNameFieldNumber = 23,
    kTypeFieldNumber = 9,
    kTrackUuidFieldNumber = 11,
    kThreadTimeDeltaUsFieldNumber = 2,
    kThreadTimeAbsoluteUsFieldNumber = 17,
    kThreadInstructionCountDeltaFieldNumber = 8,
    kThreadInstructionCountAbsoluteFieldNumber = 20,
    kDebugAnnotationsFieldNumber = 4,
    kTaskExecutionFieldNumber = 5,
    kLogMessageFieldNumber = 21,
    kTimestampDeltaUsFieldNumber = 1,
    kTimestampAbsoluteUsFieldNumber = 16,
    kLegacyEventFieldNumber = 6,
  };
  using LegacyEvent = ::perfetto::protos::pbzero::TrackEvent_LegacyEvent;
  using Type = ::perfetto::protos::pbzero::TrackEvent_Type;
  static const Type TYPE_UNSPECIFIED = TrackEvent_Type_TYPE_UNSPECIFIED;
  static const Type TYPE_SLICE_BEGIN = TrackEvent_Type_TYPE_SLICE_BEGIN;
  static const Type TYPE_SLICE_END = TrackEvent_Type_TYPE_SLICE_END;
  static const Type TYPE_INSTANT = TrackEvent_Type_TYPE_INSTANT;
  void add_category_iids(uint64_t value) {
    AppendVarInt(3, value);
  }
  void add_categories(const std::string& value) {
    AppendBytes(22, value.data(), value.size());
  }
  void add_categories(const char* data, size_t size) {
    AppendBytes(22, data, size);
  }
  void set_name_iid(uint64_t value) {
    AppendVarInt(10, value);
  }
  void set_name(const std::string& value) {
    AppendBytes(23, value.data(), value.size());
  }
  void set_name(const char* data, size_t size) {
    AppendBytes(23, data, size);
  }
  void set_type(::perfetto::protos::pbzero::TrackEvent_Type value) {
    AppendTinyVarInt(9, value);
  }
  void set_track_uuid(uint64_t value) {
    AppendVarInt(11, value);
  }
  void set_thread_time_delta_us(int64_t value) {
    AppendVarInt(2, value);
  }
  void set_thread_time_absolute_us(int64_t value) {
    AppendVarInt(17, value);
  }
  void set_thread_instruction_count_delta(int64_t value) {
    AppendVarInt(8, value);
  }
  void set_thread_instruction_count_absolute(int64_t value) {
    AppendVarInt(20, value);
  }
  template <typename T = DebugAnnotation> T* add_debug_annotations() {
    return BeginNestedMessage<T>(4);
  }

  template <typename T = TaskExecution> T* set_task_execution() {
    return BeginNestedMessage<T>(5);
  }

  template <typename T = LogMessage> T* set_log_message() {
    return BeginNestedMessage<T>(21);
  }

  void set_timestamp_delta_us(int64_t value) {
    AppendVarInt(1, value);
  }
  void set_timestamp_absolute_us(int64_t value) {
    AppendVarInt(16, value);
  }
  template <typename T = TrackEvent_LegacyEvent> T* set_legacy_event() {
    return BeginNestedMessage<T>(6);
  }

};

class TrackEvent_LegacyEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/19, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TrackEvent_LegacyEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TrackEvent_LegacyEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TrackEvent_LegacyEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name_iid() const { return at<1>().valid(); }
  uint64_t name_iid() const { return at<1>().as_uint64(); }
  bool has_phase() const { return at<2>().valid(); }
  int32_t phase() const { return at<2>().as_int32(); }
  bool has_duration_us() const { return at<3>().valid(); }
  int64_t duration_us() const { return at<3>().as_int64(); }
  bool has_thread_duration_us() const { return at<4>().valid(); }
  int64_t thread_duration_us() const { return at<4>().as_int64(); }
  bool has_thread_instruction_delta() const { return at<15>().valid(); }
  int64_t thread_instruction_delta() const { return at<15>().as_int64(); }
  bool has_unscoped_id() const { return at<6>().valid(); }
  uint64_t unscoped_id() const { return at<6>().as_uint64(); }
  bool has_local_id() const { return at<10>().valid(); }
  uint64_t local_id() const { return at<10>().as_uint64(); }
  bool has_global_id() const { return at<11>().valid(); }
  uint64_t global_id() const { return at<11>().as_uint64(); }
  bool has_id_scope() const { return at<7>().valid(); }
  ::protozero::ConstChars id_scope() const { return at<7>().as_string(); }
  bool has_use_async_tts() const { return at<9>().valid(); }
  bool use_async_tts() const { return at<9>().as_bool(); }
  bool has_bind_id() const { return at<8>().valid(); }
  uint64_t bind_id() const { return at<8>().as_uint64(); }
  bool has_bind_to_enclosing() const { return at<12>().valid(); }
  bool bind_to_enclosing() const { return at<12>().as_bool(); }
  bool has_flow_direction() const { return at<13>().valid(); }
  int32_t flow_direction() const { return at<13>().as_int32(); }
  bool has_instant_event_scope() const { return at<14>().valid(); }
  int32_t instant_event_scope() const { return at<14>().as_int32(); }
  bool has_pid_override() const { return at<18>().valid(); }
  int32_t pid_override() const { return at<18>().as_int32(); }
  bool has_tid_override() const { return at<19>().valid(); }
  int32_t tid_override() const { return at<19>().as_int32(); }
};

class TrackEvent_LegacyEvent : public ::protozero::Message {
 public:
  using Decoder = TrackEvent_LegacyEvent_Decoder;
  enum : int32_t {
    kNameIidFieldNumber = 1,
    kPhaseFieldNumber = 2,
    kDurationUsFieldNumber = 3,
    kThreadDurationUsFieldNumber = 4,
    kThreadInstructionDeltaFieldNumber = 15,
    kUnscopedIdFieldNumber = 6,
    kLocalIdFieldNumber = 10,
    kGlobalIdFieldNumber = 11,
    kIdScopeFieldNumber = 7,
    kUseAsyncTtsFieldNumber = 9,
    kBindIdFieldNumber = 8,
    kBindToEnclosingFieldNumber = 12,
    kFlowDirectionFieldNumber = 13,
    kInstantEventScopeFieldNumber = 14,
    kPidOverrideFieldNumber = 18,
    kTidOverrideFieldNumber = 19,
  };
  using FlowDirection = ::perfetto::protos::pbzero::TrackEvent_LegacyEvent_FlowDirection;
  using InstantEventScope = ::perfetto::protos::pbzero::TrackEvent_LegacyEvent_InstantEventScope;
  static const FlowDirection FLOW_UNSPECIFIED = TrackEvent_LegacyEvent_FlowDirection_FLOW_UNSPECIFIED;
  static const FlowDirection FLOW_IN = TrackEvent_LegacyEvent_FlowDirection_FLOW_IN;
  static const FlowDirection FLOW_OUT = TrackEvent_LegacyEvent_FlowDirection_FLOW_OUT;
  static const FlowDirection FLOW_INOUT = TrackEvent_LegacyEvent_FlowDirection_FLOW_INOUT;
  static const InstantEventScope SCOPE_UNSPECIFIED = TrackEvent_LegacyEvent_InstantEventScope_SCOPE_UNSPECIFIED;
  static const InstantEventScope SCOPE_GLOBAL = TrackEvent_LegacyEvent_InstantEventScope_SCOPE_GLOBAL;
  static const InstantEventScope SCOPE_PROCESS = TrackEvent_LegacyEvent_InstantEventScope_SCOPE_PROCESS;
  static const InstantEventScope SCOPE_THREAD = TrackEvent_LegacyEvent_InstantEventScope_SCOPE_THREAD;
  void set_name_iid(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_phase(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_duration_us(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_thread_duration_us(int64_t value) {
    AppendVarInt(4, value);
  }
  void set_thread_instruction_delta(int64_t value) {
    AppendVarInt(15, value);
  }
  void set_unscoped_id(uint64_t value) {
    AppendVarInt(6, value);
  }
  void set_local_id(uint64_t value) {
    AppendVarInt(10, value);
  }
  void set_global_id(uint64_t value) {
    AppendVarInt(11, value);
  }
  void set_id_scope(const std::string& value) {
    AppendBytes(7, value.data(), value.size());
  }
  void set_id_scope(const char* data, size_t size) {
    AppendBytes(7, data, size);
  }
  void set_use_async_tts(bool value) {
    AppendTinyVarInt(9, value);
  }
  void set_bind_id(uint64_t value) {
    AppendVarInt(8, value);
  }
  void set_bind_to_enclosing(bool value) {
    AppendTinyVarInt(12, value);
  }
  void set_flow_direction(::perfetto::protos::pbzero::TrackEvent_LegacyEvent_FlowDirection value) {
    AppendTinyVarInt(13, value);
  }
  void set_instant_event_scope(::perfetto::protos::pbzero::TrackEvent_LegacyEvent_InstantEventScope value) {
    AppendTinyVarInt(14, value);
  }
  void set_pid_override(int32_t value) {
    AppendVarInt(18, value);
  }
  void set_tid_override(int32_t value) {
    AppendVarInt(19, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_TRACING_INTERNAL_TRACK_EVENT_INTERNAL_H_
#define INCLUDE_PERFETTO_TRACING_INTERNAL_TRACK_EVENT_INTERNAL_H_

#include <unordered_map>

// gen_amalgamated expanded: #include "perfetto/protozero/scattered_heap_buffer.h"
// gen_amalgamated expanded: #include "perfetto/tracing/core/forward_decls.h"
// gen_amalgamated expanded: #include "perfetto/tracing/trace_writer_base.h"
// gen_amalgamated expanded: #include "protos/perfetto/trace/interned_data/interned_data.pbzero.h"
// gen_amalgamated expanded: #include "protos/perfetto/trace/track_event/track_event.pbzero.h"

namespace perfetto {
class EventContext;

namespace internal {
class TrackEventCategoryRegistry;

class BaseTrackEventInternedDataIndex {
 public:
  virtual ~BaseTrackEventInternedDataIndex();

#if PERFETTO_DCHECK_IS_ON()
  const char* type_id_ = nullptr;
#endif  // PERFETTO_DCHECK_IS_ON()
};

struct TrackEventIncrementalState {
  static constexpr size_t kMaxInternedDataFields = 32;

  bool was_cleared = true;

  // A heap-allocated message for storing newly seen interned data while we are
  // in the middle of writing a track event. When a track event wants to write
  // new interned data into the trace, it is first serialized into this message
  // and then flushed to the real trace in EventContext when the packet ends.
  // The message is cached here as a part of incremental state so that we can
  // reuse the underlying buffer allocation for subsequently written interned
  // data.
  protozero::HeapBuffered<protos::pbzero::InternedData>
      serialized_interned_data;

  // In-memory indices for looking up interned data ids.
  // For each intern-able field (up to a max of 32) we keep a dictionary of
  // field-value -> interning-key. Depending on the type we either keep the full
  // value or a hash of it (See track_event_interned_data_index.h)
  using InternedDataIndex =
      std::pair</* interned_data.proto field number */ size_t,
                std::unique_ptr<BaseTrackEventInternedDataIndex>>;
  std::array<InternedDataIndex, kMaxInternedDataFields> interned_data_indices =
      {};
};

// The backend portion of the track event trace point implemention. Outlined to
// a separate .cc file so it can be shared by different track event category
// namespaces.
class TrackEventInternal {
 public:
  static bool Initialize(
      bool (*register_data_source)(const DataSourceDescriptor&));

  static void EnableTracing(const TrackEventCategoryRegistry& registry,
                            const DataSourceConfig& config,
                            uint32_t instance_index);
  static void DisableTracing(const TrackEventCategoryRegistry& registry,
                             uint32_t instance_index);

  static perfetto::EventContext WriteEvent(
      TraceWriterBase*,
      TrackEventIncrementalState*,
      const char* category,
      const char* name,
      perfetto::protos::pbzero::TrackEvent::Type);
};

}  // namespace internal
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_TRACING_INTERNAL_TRACK_EVENT_INTERNAL_H_
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_TRACING_EVENT_CONTEXT_H_
#define INCLUDE_PERFETTO_TRACING_EVENT_CONTEXT_H_

// gen_amalgamated expanded: #include "perfetto/protozero/message_handle.h"
// gen_amalgamated expanded: #include "perfetto/tracing/internal/track_event_internal.h"
// gen_amalgamated expanded: #include "protos/perfetto/trace/trace_packet.pbzero.h"

namespace perfetto {
namespace internal {
class TrackEventInternal;
}

// Allows adding custom arguments into track events. Example:
//
//   TRACE_EVENT_BEGIN("category", "Title",
//                     [](perfetto::EventContext ctx) {
//                       auto* dbg = ctx.event()->add_debug_annotations();
//                       dbg->set_name("name");
//                       dbg->set_int_value(1234);
//                     });
//
class EventContext {
 public:
  EventContext(EventContext&&) = default;
  ~EventContext();

  protos::pbzero::TrackEvent* event() const { return event_; }

 private:
  template <typename, size_t, typename, typename>
  friend class TrackEventInternedDataIndex;
  friend class internal::TrackEventInternal;

  using TracePacketHandle =
      ::protozero::MessageHandle<protos::pbzero::TracePacket>;

  EventContext(TracePacketHandle, internal::TrackEventIncrementalState*);
  EventContext(const EventContext&) = delete;

  TracePacketHandle trace_packet_;
  protos::pbzero::TrackEvent* event_;
  internal::TrackEventIncrementalState* incremental_state_;
};

}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_TRACING_EVENT_CONTEXT_H_
// gen_amalgamated begin header: /Users/primiano/code/perfetto/tools/../include/perfetto/tracing/track_event_category_registry.h
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_TRACING_TRACK_EVENT_CATEGORY_REGISTRY_H_
#define INCLUDE_PERFETTO_TRACING_TRACK_EVENT_CATEGORY_REGISTRY_H_

// gen_amalgamated expanded: #include "perfetto/tracing/data_source.h"

#include <atomic>

namespace perfetto {
namespace internal {

// A compile-time representation of a track event category. See
// PERFETTO_DEFINE_CATEGORIES for registering your own categories.
struct TrackEventCategory {
  const char* const name;
};

// Holds all the registered categories for one category namespace. See
// PERFETTO_DEFINE_CATEGORIES for building the registry.
class TrackEventCategoryRegistry {
 public:
  constexpr TrackEventCategoryRegistry(size_t category_count,
                                       const TrackEventCategory* categories,
                                       std::atomic<uint8_t>* state_storage)
      : categories_(categories),
        category_count_(category_count),
        state_storage_(state_storage) {
    static_assert(
        sizeof(state_storage[0].load()) * 8 >= kMaxDataSourceInstances,
        "The category state must have enough bits for all possible data source "
        "instances");
  }

  size_t category_count() const { return category_count_; }

  // Returns a category based on its index.
  const TrackEventCategory* GetCategory(size_t index) const;

  // Turn tracing on or off for the given category in a track event data source
  // instance.
  void EnableCategoryForInstance(size_t category_index,
                                 uint32_t instance_index) const;
  void DisableCategoryForInstance(size_t category_index,
                                  uint32_t instance_index) const;

  constexpr std::atomic<uint8_t>* GetCategoryState(
      size_t category_index) const {
    return &state_storage_[category_index];
  }

  // --------------------------------------------------------------------------
  // Trace point support
  // --------------------------------------------------------------------------
  //
  // (The following methods are used by the track event trace point
  // implementation and typically don't need to be called by other code.)

  // At compile time, turn a category name into an index into the registry.
  // Returns kInvalidCategoryIndex if the category was not found.
  static constexpr size_t kInvalidCategoryIndex = static_cast<size_t>(-1);
  constexpr size_t Find(const char* name, size_t index = 0) const {
    return (index == category_count_) ? kInvalidCategoryIndex
                                      : StringEq(categories_[index].name, name)
                                            ? index
                                            : Find(name, index + 1);
  }

  // A helper for validating that a category was registered at compile time.
  template <size_t CategoryIndex>
  static constexpr size_t Validate() {
    static_assert(CategoryIndex != kInvalidCategoryIndex,
                  "A track event used an unknown category. Please add it to "
                  "PERFETTO_DEFINE_CATEGORIES().");
    return CategoryIndex;
  }

  constexpr bool ValidateCategories(size_t index = 0) const {
    return (index == category_count_)
               ? true
               : IsValidCategoryName(categories_[index].name)
                     ? ValidateCategories(index + 1)
                     : false;
  }

 private:
  // TODO(skyostil): Make the compile-time routines nicer with C++14.
  static constexpr bool IsValidCategoryName(const char* name) {
    return (*name == '\"' || *name == '*')
               ? false
               : *name ? IsValidCategoryName(name + 1) : true;
  }

  static constexpr bool StringEq(const char* a, const char* b) {
    return *a != *b ? false
                    : (!*a || !*b) ? (*a == *b) : StringEq(a + 1, b + 1);
  }

  const TrackEventCategory* const categories_;
  const size_t category_count_;
  std::atomic<uint8_t>* const state_storage_;
};

}  // namespace internal
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_TRACING_TRACK_EVENT_CATEGORY_REGISTRY_H_
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_TRACING_INTERNAL_TRACK_EVENT_DATA_SOURCE_H_
#define INCLUDE_PERFETTO_TRACING_INTERNAL_TRACK_EVENT_DATA_SOURCE_H_

// gen_amalgamated expanded: #include "perfetto/base/compiler.h"
// gen_amalgamated expanded: #include "perfetto/protozero/message_handle.h"
// gen_amalgamated expanded: #include "perfetto/tracing/data_source.h"
// gen_amalgamated expanded: #include "perfetto/tracing/event_context.h"
// gen_amalgamated expanded: #include "perfetto/tracing/internal/track_event_internal.h"
// gen_amalgamated expanded: #include "perfetto/tracing/track_event_category_registry.h"
// gen_amalgamated expanded: #include "protos/perfetto/trace/track_event/track_event.pbzero.h"

#include <unordered_map>

namespace perfetto {
namespace internal {

struct TrackEventDataSourceTraits : public perfetto::DefaultDataSourceTraits {
  using IncrementalStateType = TrackEventIncrementalState;

  // Use a one shared TLS slot so that all track event data sources write into
  // the same sequence and share interning dictionaries.
  static DataSourceThreadLocalState* GetDataSourceTLS(DataSourceStaticState*,
                                                      TracingTLS* root_tls) {
    return &root_tls->track_event_tls;
  }
};

// A generic track event data source which is instantiated once per track event
// category namespace.
template <typename DataSourceType, const TrackEventCategoryRegistry* Registry>
class TrackEventDataSource
    : public DataSource<DataSourceType, TrackEventDataSourceTraits> {
  using Base = DataSource<DataSourceType, TrackEventDataSourceTraits>;

 public:
  // DataSource implementation.
  void OnSetup(const DataSourceBase::SetupArgs& args) override {
    TrackEventInternal::EnableTracing(*Registry, *args.config,
                                      args.internal_instance_index);
  }

  void OnStart(const DataSourceBase::StartArgs&) override {}

  void OnStop(const DataSourceBase::StopArgs& args) override {
    TrackEventInternal::DisableTracing(*Registry, args.internal_instance_index);
  }

  static void Flush() {
    Base::template Trace([](typename Base::TraceContext ctx) { ctx.Flush(); });
  }

  // This is the inlined entrypoint for all track event trace points. It tries
  // to be as lightweight as possible in terms of instructions and aims to
  // compile down to an unlikely conditional jump to the actual trace writing
  // function.
  template <size_t CategoryIndex, typename Callback>
  static void CallIfCategoryEnabled(Callback callback) PERFETTO_ALWAYS_INLINE {
    Base::template CallIfEnabled<CategoryTracePointTraits<CategoryIndex>>(
        [&callback](uint32_t instances) { callback(instances); });
  }

  // Once we've determined tracing to be enabled for this category, actually
  // write a trace event. Outlined to avoid bloating code at the actual trace
  // point.
  // TODO(skyostil): Investigate whether this should be fully outlined to reduce
  // binary size.
  template <size_t CategoryIndex,
            typename ArgumentFunction = void (*)(EventContext)>
  static void TraceForCategory(
      uint32_t instances,
      const char* event_name,
      perfetto::protos::pbzero::TrackEvent::Type type,
      ArgumentFunction arg_function = [](EventContext) {}) PERFETTO_NO_INLINE {
    Base::template TraceWithInstances<CategoryTracePointTraits<CategoryIndex>>(
        instances, [&](typename Base::TraceContext ctx) {
          // TODO(skyostil): Intern categories at compile time.
          arg_function(TrackEventInternal::WriteEvent(
              ctx.tls_inst_->trace_writer.get(), ctx.GetIncrementalState(),
              Registry->GetCategory(CategoryIndex)->name, event_name, type));
        });
  }

  static bool Register() {
    // Registration is performed out-of-line so users don't need to depend on
    // DataSourceDescriptor C++ bindings.
    return TrackEventInternal::Initialize(
        [](const DataSourceDescriptor& dsd) { return Base::Register(dsd); });
  }

 private:
  // Each category has its own enabled/disabled state, stored in the category
  // registry.
  template <size_t CategoryIndex>
  struct CategoryTracePointTraits {
    static constexpr std::atomic<uint8_t>* GetActiveInstances() {
      return Registry->GetCategoryState(CategoryIndex);
    }
  };
};

}  // namespace internal
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_TRACING_INTERNAL_TRACK_EVENT_DATA_SOURCE_H_
// gen_amalgamated begin header: /Users/primiano/code/perfetto/tools/../include/perfetto/tracing/internal/track_event_macros.h
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_TRACING_INTERNAL_TRACK_EVENT_MACROS_H_
#define INCLUDE_PERFETTO_TRACING_INTERNAL_TRACK_EVENT_MACROS_H_

// This file contains underlying macros for the trace point track event
// implementation. Perfetto API users typically don't need to use anything here
// directly.

// gen_amalgamated expanded: #include "perfetto/base/compiler.h"
// gen_amalgamated expanded: #include "perfetto/tracing/internal/track_event_data_source.h"
// gen_amalgamated expanded: #include "perfetto/tracing/track_event_category_registry.h"

// Defines data structures for backing a category registry.
//
// Each category has one enabled/disabled bit per possible data source instance.
// The bits are packed, i.e., each byte holds the state for instances. To
// improve cache locality, the bits for each instance are stored separately from
// the names of the categories:
//
//   byte 0                      byte 1
//   (inst0, inst1, ..., inst7), (inst0, inst1, ..., inst7)
//
#define PERFETTO_INTERNAL_DECLARE_CATEGORIES(...)                             \
  namespace internal {                                                        \
  constexpr ::perfetto::internal::TrackEventCategory kCategories[] = {        \
      __VA_ARGS__};                                                           \
  constexpr size_t kCategoryCount =                                           \
      sizeof(kCategories) / sizeof(kCategories[0]);                           \
  /* The per-instance enable/disable state per category */                    \
  extern std::atomic<uint8_t> g_category_state_storage[kCategoryCount];       \
  /* The category registry which mediates access to the above structures. */  \
  /* The registry is used for two purposes: */                                \
  /**/                                                                        \
  /*    1) For looking up categories at build (constexpr) time. */            \
  /*    2) For declaring the per-namespace TrackEvent data source. */         \
  /**/                                                                        \
  /* Because usage #1 requires a constexpr type and usage #2 requires an */   \
  /* extern type (to avoid declaring a type based on a translation-unit */    \
  /* variable), we need two separate copies of the registry with different */ \
  /* storage specifiers. */                                                   \
  /**/                                                                        \
  /* TODO(skyostil): Unify these using a C++17 inline constexpr variable. */  \
  constexpr ::perfetto::internal::TrackEventCategoryRegistry                  \
      kConstExprCategoryRegistry(kCategoryCount,                              \
                                 &kCategories[0],                             \
                                 &g_category_state_storage[0]);               \
  extern const ::perfetto::internal::TrackEventCategoryRegistry               \
      kCategoryRegistry;                                                      \
  static_assert(kConstExprCategoryRegistry.ValidateCategories(),              \
                "Invalid category names found");                              \
  }  // namespace internal

// In a .cc file, declares storage for each category's runtime state.
#define PERFETTO_INTERNAL_CATEGORY_STORAGE()                     \
  namespace internal {                                           \
  std::atomic<uint8_t> g_category_state_storage[kCategoryCount]; \
  constexpr ::perfetto::internal::TrackEventCategoryRegistry     \
      kCategoryRegistry(kCategoryCount,                          \
                        &kCategories[0],                         \
                        &g_category_state_storage[0]);           \
  }  // namespace internal

// Defines the TrackEvent data source for the current track event namespace.
#define PERFETTO_INTERNAL_DECLARE_TRACK_EVENT_DATA_SOURCE()              \
  struct TrackEvent : public ::perfetto::internal::TrackEventDataSource< \
                          TrackEvent, &internal::kCategoryRegistry> {}

// At compile time, turns a category name represented by a static string into an
// index into the current category registry. A build error will be generated if
// the category hasn't been registered. See PERFETTO_DEFINE_CATEGORIES.
#define PERFETTO_GET_CATEGORY_INDEX(category)                                \
  ::perfetto::internal::TrackEventCategoryRegistry::Validate<                \
      ::PERFETTO_TRACK_EVENT_NAMESPACE::internal::kConstExprCategoryRegistry \
          .Find(category)>()

// Efficiently determines whether tracing is enabled for the given category, and
// if so, emits one trace event with the given arguments.
#define PERFETTO_INTERNAL_TRACK_EVENT(category, ...)                      \
  ::PERFETTO_TRACK_EVENT_NAMESPACE::TrackEvent::CallIfCategoryEnabled<    \
      PERFETTO_GET_CATEGORY_INDEX(category)>([&](uint32_t instances) {    \
    ::PERFETTO_TRACK_EVENT_NAMESPACE::TrackEvent::TraceForCategory<       \
        PERFETTO_GET_CATEGORY_INDEX(category)>(instances, ##__VA_ARGS__); \
  })

// Generate a unique variable name with a given prefix.
#define PERFETTO_INTERNAL_CONCAT2(a, b) a##b
#define PERFETTO_INTERNAL_CONCAT(a, b) PERFETTO_INTERNAL_CONCAT2(a, b)
#define PERFETTO_INTERNAL_UID(prefix) PERFETTO_INTERNAL_CONCAT(prefix, __LINE__)

#endif  // INCLUDE_PERFETTO_TRACING_INTERNAL_TRACK_EVENT_MACROS_H_
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_TRACING_TRACK_EVENT_H_
#define INCLUDE_PERFETTO_TRACING_TRACK_EVENT_H_

// gen_amalgamated expanded: #include "perfetto/base/time.h"
// gen_amalgamated expanded: #include "perfetto/tracing/internal/track_event_data_source.h"
// gen_amalgamated expanded: #include "perfetto/tracing/internal/track_event_internal.h"
// gen_amalgamated expanded: #include "perfetto/tracing/internal/track_event_macros.h"
// gen_amalgamated expanded: #include "perfetto/tracing/track_event_category_registry.h"
// gen_amalgamated expanded: #include "protos/perfetto/trace/track_event/track_event.pbzero.h"

// This file contains a set of macros designed for instrumenting applications
// with track event trace points. While the underlying TrackEvent API can also
// be used directly, doing so efficiently requires some care (e.g., to avoid
// evaluating arguments while tracing is disabled). These types of optimizations
// are abstracted away by the macros below.
//
// ================
// Quickstart guide
// ================
//
//   To add track events to your application, first define your categories in,
//   e.g., my_tracing.h:
//
//       PERFETTO_DEFINE_CATEGORIES(
//           PERFETTO_CATEGORY(base),
//           PERFETTO_CATEGORY(v8),
//           PERFETTO_CATEGORY(cc));
//
//   Then in a single .cc file, e.g., my_tracing.cc:
//
//       #include "my_tracing.h"
//       PERFETTO_TRACK_EVENT_STATIC_STORAGE();
//
//   Finally, register track events at startup, after which you can record
//   events with the TRACE_EVENT macros:
//
//       #include "my_tracing.h"
//
//       int main() {
//         perfetto::TrackEvent::Register();
//         TRACK_EVENT("category", "MyEvent");
//         ...
//       }
//
// ====================
// Implementation notes
// ====================
//
// The track event library consists of the following layers and components. The
// classes the internal namespace shouldn't be considered part of the public
// API.
//                    .--------------------------------.
//               .----|  TRACE_EVENT                   |----.
//      write   |     |   - App instrumentation point  |     |  write
//      event   |     '--------------------------------'     |  arguments
//              V                                            V
//  .----------------------------------.    .-----------------------------.
//  | TrackEvent                       |    | EventContext                |
//  |  - Registry of event categories  |    |  - One track event instance |
//  '----------------------------------'    '-----------------------------'
//              |                                            |
//              |                                            | look up
//              | is                                         | interning ids
//              V                                            V
//  .----------------------------------.    .-----------------------------.
//  | internal::TrackEventDataSource   |    | TrackEventInternedDataIndex |
//  | - Perfetto data source           |    | - Corresponds to a field in |
//  | - Has TrackEventIncrementalState |    |   in interned_data.proto    |
//  '----------------------------------'    '-----------------------------'
//              |                  |                         ^
//              |                  |       owns (1:many)     |
//              | write event      '-------------------------'
//              V
//  .----------------------------------.
//  | internal::TrackEventInternal     |
//  | - Outlined code to serialize     |
//  |   one track event                |
//  '----------------------------------'
//

// Each compilation unit can be in exactly one track event namespace,
// allowing the overall program to use multiple track event data sources and
// category lists if necessary. Use this macro to select the namespace for the
// current compilation unit.
//
// If the program uses multiple track event namespaces, category & track event
// registration (see quickstart above) needs to happen for both namespaces
// separately.
#ifndef PERFETTO_TRACK_EVENT_NAMESPACE
#define PERFETTO_TRACK_EVENT_NAMESPACE perfetto
#endif

// A name for a single category. Wrapped in a macro in case we need to introduce
// more fields in the future.
#define PERFETTO_CATEGORY(name) \
  { #name }

// Register the set of available categories by passing a list of categories to
// this macro: PERFETTO_CATEGORY(cat1), PERFETTO_CATEGORY(cat2), ...
#define PERFETTO_DEFINE_CATEGORIES(...)                        \
  namespace PERFETTO_TRACK_EVENT_NAMESPACE {                   \
  /* The list of category names */                             \
  PERFETTO_INTERNAL_DECLARE_CATEGORIES(__VA_ARGS__);           \
  /* The track event data source for this set of categories */ \
  PERFETTO_INTERNAL_DECLARE_TRACK_EVENT_DATA_SOURCE();         \
  }  // namespace PERFETTO_TRACK_EVENT_NAMESPACE

// Allocate storage for each category by using this macro once per track event
// namespace.
#define PERFETTO_TRACK_EVENT_STATIC_STORAGE() \
  namespace PERFETTO_TRACK_EVENT_NAMESPACE {  \
  PERFETTO_INTERNAL_CATEGORY_STORAGE();       \
  }  // namespace PERFETTO_TRACK_EVENT_NAMESPACE

// Begin a thread-scoped slice under |category| with the title |name|. Both
// strings must be static constants. The track event is only recorded if
// |category| is enabled for a tracing session.
#define TRACE_EVENT_BEGIN(category, name, ...) \
  PERFETTO_INTERNAL_TRACK_EVENT(               \
      category, name,                          \
      ::perfetto::protos::pbzero::TrackEvent::TYPE_SLICE_BEGIN, ##__VA_ARGS__)

// End a thread-scoped slice under |category|.
#define TRACE_EVENT_END(category, ...) \
  PERFETTO_INTERNAL_TRACK_EVENT(       \
      category, nullptr,               \
      ::perfetto::protos::pbzero::TrackEvent::TYPE_SLICE_END, ##__VA_ARGS__)

// Begin a thread-scoped slice which gets automatically closed when going out of
// scope.
#define TRACE_EVENT(category, name, ...)               \
  TRACE_EVENT_BEGIN(category, name, ##__VA_ARGS__);    \
  struct {                                             \
    struct EventFinalizer {                            \
      ~EventFinalizer() { TRACE_EVENT_END(category); } \
    } finalizer;                                       \
  } PERFETTO_INTERNAL_UID(scoped_event)

// Emit a thread-scoped slice which has zero duration.
// TODO(skyostil): Add support for process-wide and global instant events.
#define TRACE_EVENT_INSTANT(category, name, ...)                            \
  PERFETTO_INTERNAL_TRACK_EVENT(                                            \
      category, name, ::perfetto::protos::pbzero::TrackEvent::TYPE_INSTANT, \
      ##__VA_ARGS__)

// TODO(skyostil): Add arguments.
// TODO(skyostil): Add async events.
// TODO(skyostil): Add flow events.
// TODO(skyostil): Add counters.

#endif  // INCLUDE_PERFETTO_TRACING_TRACK_EVENT_H_
// gen_amalgamated begin header: /Users/primiano/code/perfetto/tools/../include/perfetto/tracing/track_event_interned_data_index.h
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_TRACING_TRACK_EVENT_INTERNED_DATA_INDEX_H_
#define INCLUDE_PERFETTO_TRACING_TRACK_EVENT_INTERNED_DATA_INDEX_H_

// gen_amalgamated expanded: #include "perfetto/tracing/internal/track_event_internal.h"

// gen_amalgamated expanded: #include "perfetto/base/compiler.h"

#include <map>
#include <type_traits>
#include <unordered_map>

// This file has templates for defining your own interned data types to be used
// with track event. Interned data can be useful for avoiding repeating the same
// constant data (e.g., strings) throughout the trace.
//
// =============
// Example usage
// =============
//
// First define an interning index for your type. It should map to a specific
// field of interned_data.proto and define how the interned data is written into
// that message.
//
//   struct MyInternedData
//       : public perfetto::TrackEventInternedDataIndex<
//           MyInternedData,
//           perfetto::protos::pbzero::InternedData::kMyInternedDataFieldNumber,
//           const char*> {
//     static void Add(perfetto::protos::pbzero::InternedData* interned_data,
//                      size_t iid,
//                      const char* value) {
//       auto my_data = interned_data->add_my_interned_data();
//       my_data->set_iid(iid);
//       my_data->set_value(value);
//     }
//   };
//
// Next, use your interned data in a trace point as shown below. The interned
// string will only be emitted the first time the trace point is hit.
//
//   TRACE_EVENT_BEGIN(
//      "category", "Event", [&](perfetto::EventContext ctx) {
//        auto my_message = ctx.event()->set_my_message();
//        size_t iid = MyInternedData::Get(&ctx, "Some data");
//        my_message->set_iid(iid);
//      });
//

namespace perfetto {

// By default, the interning index stores a full copy of the interned data. This
// ensures the same data is always mapped to the same interning id, and there is
// no danger of collisions. This comes at the cost of memory usage, however, so
// consider using HashedInternedDataTraits if that may be an issue.
//
// This type of index also performs hashing on the stored data for lookups; for
// types where this isn't necessary (e.g., raw const char*), use
// SmallInternedDataTraits.
struct BigInternedDataTraits {
  template <typename ValueType>
  class Index {
   public:
    bool LookUpOrInsert(size_t* iid, const ValueType& value) {
      size_t next_id = data_.size() + 1;
      auto it_and_inserted = data_.insert(std::make_pair(value, next_id));
      if (!it_and_inserted.second) {
        *iid = it_and_inserted.first->second;
        return true;
      }
      *iid = next_id;
      return false;
    }

   private:
    std::unordered_map<ValueType, size_t> data_;
  };
};

// This type of interning index keeps full copies of interned data without
// hashing the values. This is a good fit for small types that can be directly
// used as index keys.
struct SmallInternedDataTraits {
  template <typename ValueType>
  class Index {
   public:
    bool LookUpOrInsert(size_t* iid, const ValueType& value) {
      size_t next_id = data_.size() + 1;
      auto it_and_inserted = data_.insert(std::make_pair(value, next_id));
      if (!it_and_inserted.second) {
        *iid = it_and_inserted.first->second;
        return true;
      }
      *iid = next_id;
      return false;
    }

   private:
    std::map<ValueType, size_t> data_;
  };
};

// This type of interning index only stores the hash of the interned values
// instead of the values themselves. This is more efficient in terms of memory
// usage, but assumes that there are no hash collisions. If a hash collision
// occurs, two or more values will be mapped to the same interning id.
//
// Note that the given type must have a specialization for std::hash.
struct HashedInternedDataTraits {
  template <typename ValueType>
  class Index {
   public:
    bool LookUpOrInsert(size_t* iid, const ValueType& value) {
      auto key = std::hash<ValueType>()(value);
      size_t next_id = data_.size() + 1;
      auto it_and_inserted = data_.insert(std::make_pair(key, next_id));
      if (!it_and_inserted.second) {
        *iid = it_and_inserted.first->second;
        return true;
      }
      *iid = next_id;
      return false;
    }

   private:
    std::map<size_t, size_t> data_;
  };
};

// A templated base class for an interned data type which corresponds to a field
// in interned_data.proto.
//
// |InternedDataType| must be the type of the subclass.
// |FieldNumber| is the corresponding protobuf field in InternedData.
// |ValueType| is the type which is stored in the index. It must be copyable.
// |Traits| can be used to customize the storage and lookup mechanism.
//
// The subclass should define a static method with the following signature for
// committing interned data together with the interning id |iid| into the trace:
//
//   static void Add(perfetto::protos::pbzero::InternedData*,
//                   size_t iid,
//                   const ValueType& value);
//
template <typename InternedDataType,
          size_t FieldNumber,
          typename ValueType,
          // Avoid unnecessary hashing for pointers by default.
          typename Traits =
              typename std::conditional<(std::is_pointer<ValueType>::value),
                                        SmallInternedDataTraits,
                                        BigInternedDataTraits>::type>
class TrackEventInternedDataIndex
    : public internal::BaseTrackEventInternedDataIndex {
 public:
  // Return an interning id for |value|. The returned id can be immediately
  // written to the trace.
  static size_t Get(EventContext* ctx, const ValueType& value) {
    // First check if the value exists in the dictionary.
    auto index_for_field = GetOrCreateIndexForField(ctx->incremental_state_);
    size_t iid;
    if (PERFETTO_LIKELY(index_for_field->index_.LookUpOrInsert(&iid, value))) {
      PERFETTO_DCHECK(iid);
      return iid;
    }

    // If not, we need to serialize the definition of the interned value into
    // the heap buffered message (which is committed to the trace when the
    // packet ends).
    PERFETTO_DCHECK(iid);
    InternedDataType::Add(
        ctx->incremental_state_->serialized_interned_data.get(), iid,
        std::move(value));
    return iid;
  }

 private:
  static InternedDataType* GetOrCreateIndexForField(
      internal::TrackEventIncrementalState* incremental_state) {
    // Fast path: look for matching field number.
    for (const auto& entry : incremental_state->interned_data_indices) {
      if (entry.first == FieldNumber) {
#if PERFETTO_DCHECK_IS_ON()
        if (strcmp(PERFETTO_DEBUG_FUNCTION_IDENTIFIER(),
                   entry.second->type_id_)) {
          PERFETTO_FATAL(
              "Interned data accessed under different types! Previous type: "
              "%s. New type: %s.",
              entry.second->type_id_, PERFETTO_DEBUG_FUNCTION_IDENTIFIER());
        }
#endif  // PERFETTO_DCHECK_IS_ON()
        return reinterpret_cast<InternedDataType*>(entry.second.get());
      }
    }
    // No match -- add a new entry for this field.
    for (auto& entry : incremental_state->interned_data_indices) {
      if (!entry.first) {
        entry.first = FieldNumber;
        entry.second.reset(new InternedDataType());
#if PERFETTO_DCHECK_IS_ON()
        entry.second->type_id_ = PERFETTO_DEBUG_FUNCTION_IDENTIFIER();
#endif  // PERFETTO_DCHECK_IS_ON()
        return reinterpret_cast<InternedDataType*>(entry.second.get());
      }
    }
    // Out of space in the interned data index table.
    PERFETTO_CHECK(false);
  }

  // The actual interning dictionary for this type of interned data. The actual
  // container type is defined by |Traits|, hence the extra layer of template
  // indirection here.
  typename Traits::template Index<ValueType> index_;
};

}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_TRACING_TRACK_EVENT_INTERNED_DATA_INDEX_H_
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_TRACING_H_
#define INCLUDE_PERFETTO_TRACING_H_

// This headers wraps all the headers necessary to use the public Perfetto
// Tracing API. Embedders should preferably use this one header to avoid having
// to figure out the various set of header required for each class.
// The only exception to this should be large projects where build time is a
// concern (e.g. chromium), which migh prefer sticking to strict IWYU.

// gen_amalgamated expanded: #include "perfetto/tracing/buffer_exhausted_policy.h"
// gen_amalgamated expanded: #include "perfetto/tracing/core/data_source_config.h"
// gen_amalgamated expanded: #include "perfetto/tracing/core/data_source_descriptor.h"
// gen_amalgamated expanded: #include "perfetto/tracing/core/trace_config.h"
// gen_amalgamated expanded: #include "perfetto/tracing/data_source.h"
// gen_amalgamated expanded: #include "perfetto/tracing/platform.h"
// gen_amalgamated expanded: #include "perfetto/tracing/tracing.h"
// gen_amalgamated expanded: #include "perfetto/tracing/tracing_backend.h"
// gen_amalgamated expanded: #include "perfetto/tracing/track_event.h"
// gen_amalgamated expanded: #include "perfetto/tracing/track_event_interned_data_index.h"

#endif  // INCLUDE_PERFETTO_TRACING_H_
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/common/android_log_constants.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_COMMON_ANDROID_LOG_CONSTANTS_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_COMMON_ANDROID_LOG_CONSTANTS_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


enum AndroidLogId : int32_t {
  LID_DEFAULT = 0,
  LID_RADIO = 1,
  LID_EVENTS = 2,
  LID_SYSTEM = 3,
  LID_CRASH = 4,
  LID_STATS = 5,
  LID_SECURITY = 6,
  LID_KERNEL = 7,
};

const AndroidLogId AndroidLogId_MIN = LID_DEFAULT;
const AndroidLogId AndroidLogId_MAX = LID_KERNEL;

enum AndroidLogPriority : int32_t {
  PRIO_UNSPECIFIED = 0,
  PRIO_UNUSED = 1,
  PRIO_VERBOSE = 2,
  PRIO_DEBUG = 3,
  PRIO_INFO = 4,
  PRIO_WARN = 5,
  PRIO_ERROR = 6,
  PRIO_FATAL = 7,
};

const AndroidLogPriority AndroidLogPriority_MIN = PRIO_UNSPECIFIED;
const AndroidLogPriority AndroidLogPriority_MAX = PRIO_FATAL;

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/common/commit_data_request.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_COMMON_COMMIT_DATA_REQUEST_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_COMMON_COMMIT_DATA_REQUEST_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class CommitDataRequest_ChunkToPatch;
class CommitDataRequest_ChunkToPatch_Patch;
class CommitDataRequest_ChunksToMove;

class CommitDataRequest_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  CommitDataRequest_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit CommitDataRequest_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit CommitDataRequest_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_chunks_to_move() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> chunks_to_move() const { return GetRepeated<::protozero::ConstBytes>(1); }
  bool has_chunks_to_patch() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> chunks_to_patch() const { return GetRepeated<::protozero::ConstBytes>(2); }
  bool has_flush_request_id() const { return at<3>().valid(); }
  uint64_t flush_request_id() const { return at<3>().as_uint64(); }
};

class CommitDataRequest : public ::protozero::Message {
 public:
  using Decoder = CommitDataRequest_Decoder;
  enum : int32_t {
    kChunksToMoveFieldNumber = 1,
    kChunksToPatchFieldNumber = 2,
    kFlushRequestIdFieldNumber = 3,
  };
  using ChunksToMove = ::perfetto::protos::pbzero::CommitDataRequest_ChunksToMove;
  using ChunkToPatch = ::perfetto::protos::pbzero::CommitDataRequest_ChunkToPatch;
  template <typename T = CommitDataRequest_ChunksToMove> T* add_chunks_to_move() {
    return BeginNestedMessage<T>(1);
  }

  template <typename T = CommitDataRequest_ChunkToPatch> T* add_chunks_to_patch() {
    return BeginNestedMessage<T>(2);
  }

  void set_flush_request_id(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class CommitDataRequest_ChunkToPatch_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  CommitDataRequest_ChunkToPatch_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit CommitDataRequest_ChunkToPatch_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit CommitDataRequest_ChunkToPatch_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_target_buffer() const { return at<1>().valid(); }
  uint32_t target_buffer() const { return at<1>().as_uint32(); }
  bool has_writer_id() const { return at<2>().valid(); }
  uint32_t writer_id() const { return at<2>().as_uint32(); }
  bool has_chunk_id() const { return at<3>().valid(); }
  uint32_t chunk_id() const { return at<3>().as_uint32(); }
  bool has_patches() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> patches() const { return GetRepeated<::protozero::ConstBytes>(4); }
  bool has_has_more_patches() const { return at<5>().valid(); }
  bool has_more_patches() const { return at<5>().as_bool(); }
};

class CommitDataRequest_ChunkToPatch : public ::protozero::Message {
 public:
  using Decoder = CommitDataRequest_ChunkToPatch_Decoder;
  enum : int32_t {
    kTargetBufferFieldNumber = 1,
    kWriterIdFieldNumber = 2,
    kChunkIdFieldNumber = 3,
    kPatchesFieldNumber = 4,
    kHasMorePatchesFieldNumber = 5,
  };
  using Patch = ::perfetto::protos::pbzero::CommitDataRequest_ChunkToPatch_Patch;
  void set_target_buffer(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_writer_id(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_chunk_id(uint32_t value) {
    AppendVarInt(3, value);
  }
  template <typename T = CommitDataRequest_ChunkToPatch_Patch> T* add_patches() {
    return BeginNestedMessage<T>(4);
  }

  void set_has_more_patches(bool value) {
    AppendTinyVarInt(5, value);
  }
};

class CommitDataRequest_ChunkToPatch_Patch_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  CommitDataRequest_ChunkToPatch_Patch_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit CommitDataRequest_ChunkToPatch_Patch_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit CommitDataRequest_ChunkToPatch_Patch_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_offset() const { return at<1>().valid(); }
  uint32_t offset() const { return at<1>().as_uint32(); }
  bool has_data() const { return at<2>().valid(); }
  ::protozero::ConstBytes data() const { return at<2>().as_bytes(); }
};

class CommitDataRequest_ChunkToPatch_Patch : public ::protozero::Message {
 public:
  using Decoder = CommitDataRequest_ChunkToPatch_Patch_Decoder;
  enum : int32_t {
    kOffsetFieldNumber = 1,
    kDataFieldNumber = 2,
  };
  void set_offset(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_data(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void set_data(const uint8_t* data, size_t size) {
    AppendBytes(2, data, size);
  }
};

class CommitDataRequest_ChunksToMove_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  CommitDataRequest_ChunksToMove_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit CommitDataRequest_ChunksToMove_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit CommitDataRequest_ChunksToMove_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_page() const { return at<1>().valid(); }
  uint32_t page() const { return at<1>().as_uint32(); }
  bool has_chunk() const { return at<2>().valid(); }
  uint32_t chunk() const { return at<2>().as_uint32(); }
  bool has_target_buffer() const { return at<3>().valid(); }
  uint32_t target_buffer() const { return at<3>().as_uint32(); }
};

class CommitDataRequest_ChunksToMove : public ::protozero::Message {
 public:
  using Decoder = CommitDataRequest_ChunksToMove_Decoder;
  enum : int32_t {
    kPageFieldNumber = 1,
    kChunkFieldNumber = 2,
    kTargetBufferFieldNumber = 3,
  };
  void set_page(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_chunk(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_target_buffer(uint32_t value) {
    AppendVarInt(3, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/common/data_source_descriptor.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_COMMON_DATA_SOURCE_DESCRIPTOR_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_COMMON_DATA_SOURCE_DESCRIPTOR_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class GpuCounterDescriptor;
class TrackEventDescriptor;

class DataSourceDescriptor_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  DataSourceDescriptor_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit DataSourceDescriptor_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit DataSourceDescriptor_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_will_notify_on_stop() const { return at<2>().valid(); }
  bool will_notify_on_stop() const { return at<2>().as_bool(); }
  bool has_will_notify_on_start() const { return at<3>().valid(); }
  bool will_notify_on_start() const { return at<3>().as_bool(); }
  bool has_handles_incremental_state_clear() const { return at<4>().valid(); }
  bool handles_incremental_state_clear() const { return at<4>().as_bool(); }
  bool has_gpu_counter_descriptor() const { return at<5>().valid(); }
  ::protozero::ConstBytes gpu_counter_descriptor() const { return at<5>().as_bytes(); }
  bool has_track_event_descriptor() const { return at<6>().valid(); }
  ::protozero::ConstBytes track_event_descriptor() const { return at<6>().as_bytes(); }
};

class DataSourceDescriptor : public ::protozero::Message {
 public:
  using Decoder = DataSourceDescriptor_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kWillNotifyOnStopFieldNumber = 2,
    kWillNotifyOnStartFieldNumber = 3,
    kHandlesIncrementalStateClearFieldNumber = 4,
    kGpuCounterDescriptorFieldNumber = 5,
    kTrackEventDescriptorFieldNumber = 6,
  };
  void set_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_will_notify_on_stop(bool value) {
    AppendTinyVarInt(2, value);
  }
  void set_will_notify_on_start(bool value) {
    AppendTinyVarInt(3, value);
  }
  void set_handles_incremental_state_clear(bool value) {
    AppendTinyVarInt(4, value);
  }
  template <typename T = GpuCounterDescriptor> T* set_gpu_counter_descriptor() {
    return BeginNestedMessage<T>(5);
  }

  void set_gpu_counter_descriptor_raw(const std::string& raw) {
    return AppendBytes(5, raw.data(), raw.size());
  }

  template <typename T = TrackEventDescriptor> T* set_track_event_descriptor() {
    return BeginNestedMessage<T>(6);
  }

  void set_track_event_descriptor_raw(const std::string& raw) {
    return AppendBytes(6, raw.data(), raw.size());
  }

};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/common/descriptor.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_COMMON_DESCRIPTOR_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_COMMON_DESCRIPTOR_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class DescriptorProto;
class DescriptorProto_ReservedRange;
class EnumDescriptorProto;
class EnumValueDescriptorProto;
class FieldDescriptorProto;
class FileDescriptorProto;
class OneofDescriptorProto;
class OneofOptions;
enum FieldDescriptorProto_Label : int32_t;
enum FieldDescriptorProto_Type : int32_t;

enum FieldDescriptorProto_Type : int32_t {
  FieldDescriptorProto_Type_TYPE_DOUBLE = 1,
  FieldDescriptorProto_Type_TYPE_FLOAT = 2,
  FieldDescriptorProto_Type_TYPE_INT64 = 3,
  FieldDescriptorProto_Type_TYPE_UINT64 = 4,
  FieldDescriptorProto_Type_TYPE_INT32 = 5,
  FieldDescriptorProto_Type_TYPE_FIXED64 = 6,
  FieldDescriptorProto_Type_TYPE_FIXED32 = 7,
  FieldDescriptorProto_Type_TYPE_BOOL = 8,
  FieldDescriptorProto_Type_TYPE_STRING = 9,
  FieldDescriptorProto_Type_TYPE_GROUP = 10,
  FieldDescriptorProto_Type_TYPE_MESSAGE = 11,
  FieldDescriptorProto_Type_TYPE_BYTES = 12,
  FieldDescriptorProto_Type_TYPE_UINT32 = 13,
  FieldDescriptorProto_Type_TYPE_ENUM = 14,
  FieldDescriptorProto_Type_TYPE_SFIXED32 = 15,
  FieldDescriptorProto_Type_TYPE_SFIXED64 = 16,
  FieldDescriptorProto_Type_TYPE_SINT32 = 17,
  FieldDescriptorProto_Type_TYPE_SINT64 = 18,
};

const FieldDescriptorProto_Type FieldDescriptorProto_Type_MIN = FieldDescriptorProto_Type_TYPE_DOUBLE;
const FieldDescriptorProto_Type FieldDescriptorProto_Type_MAX = FieldDescriptorProto_Type_TYPE_SINT64;

enum FieldDescriptorProto_Label : int32_t {
  FieldDescriptorProto_Label_LABEL_OPTIONAL = 1,
  FieldDescriptorProto_Label_LABEL_REQUIRED = 2,
  FieldDescriptorProto_Label_LABEL_REPEATED = 3,
};

const FieldDescriptorProto_Label FieldDescriptorProto_Label_MIN = FieldDescriptorProto_Label_LABEL_OPTIONAL;
const FieldDescriptorProto_Label FieldDescriptorProto_Label_MAX = FieldDescriptorProto_Label_LABEL_REPEATED;

class OneofOptions_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/0, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  OneofOptions_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit OneofOptions_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit OneofOptions_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
};

class OneofOptions : public ::protozero::Message {
 public:
  using Decoder = OneofOptions_Decoder;
};

class EnumValueDescriptorProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  EnumValueDescriptorProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit EnumValueDescriptorProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit EnumValueDescriptorProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_number() const { return at<2>().valid(); }
  int32_t number() const { return at<2>().as_int32(); }
};

class EnumValueDescriptorProto : public ::protozero::Message {
 public:
  using Decoder = EnumValueDescriptorProto_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kNumberFieldNumber = 2,
  };
  void set_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_number(int32_t value) {
    AppendVarInt(2, value);
  }
};

class EnumDescriptorProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  EnumDescriptorProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit EnumDescriptorProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit EnumDescriptorProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_value() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> value() const { return GetRepeated<::protozero::ConstBytes>(2); }
  bool has_reserved_name() const { return at<5>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstChars> reserved_name() const { return GetRepeated<::protozero::ConstChars>(5); }
};

class EnumDescriptorProto : public ::protozero::Message {
 public:
  using Decoder = EnumDescriptorProto_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
    kReservedNameFieldNumber = 5,
  };
  void set_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  template <typename T = EnumValueDescriptorProto> T* add_value() {
    return BeginNestedMessage<T>(2);
  }

  void add_reserved_name(const std::string& value) {
    AppendBytes(5, value.data(), value.size());
  }
  void add_reserved_name(const char* data, size_t size) {
    AppendBytes(5, data, size);
  }
};

class OneofDescriptorProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  OneofDescriptorProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit OneofDescriptorProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit OneofDescriptorProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_options() const { return at<2>().valid(); }
  ::protozero::ConstBytes options() const { return at<2>().as_bytes(); }
};

class OneofDescriptorProto : public ::protozero::Message {
 public:
  using Decoder = OneofDescriptorProto_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kOptionsFieldNumber = 2,
  };
  void set_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  template <typename T = OneofOptions> T* set_options() {
    return BeginNestedMessage<T>(2);
  }

};

class FieldDescriptorProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/9, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  FieldDescriptorProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit FieldDescriptorProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit FieldDescriptorProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_number() const { return at<3>().valid(); }
  int32_t number() const { return at<3>().as_int32(); }
  bool has_label() const { return at<4>().valid(); }
  int32_t label() const { return at<4>().as_int32(); }
  bool has_type() const { return at<5>().valid(); }
  int32_t type() const { return at<5>().as_int32(); }
  bool has_type_name() const { return at<6>().valid(); }
  ::protozero::ConstChars type_name() const { return at<6>().as_string(); }
  bool has_extendee() const { return at<2>().valid(); }
  ::protozero::ConstChars extendee() const { return at<2>().as_string(); }
  bool has_default_value() const { return at<7>().valid(); }
  ::protozero::ConstChars default_value() const { return at<7>().as_string(); }
  bool has_oneof_index() const { return at<9>().valid(); }
  int32_t oneof_index() const { return at<9>().as_int32(); }
};

class FieldDescriptorProto : public ::protozero::Message {
 public:
  using Decoder = FieldDescriptorProto_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kNumberFieldNumber = 3,
    kLabelFieldNumber = 4,
    kTypeFieldNumber = 5,
    kTypeNameFieldNumber = 6,
    kExtendeeFieldNumber = 2,
    kDefaultValueFieldNumber = 7,
    kOneofIndexFieldNumber = 9,
  };
  using Type = ::perfetto::protos::pbzero::FieldDescriptorProto_Type;
  using Label = ::perfetto::protos::pbzero::FieldDescriptorProto_Label;
  static const Type TYPE_DOUBLE = FieldDescriptorProto_Type_TYPE_DOUBLE;
  static const Type TYPE_FLOAT = FieldDescriptorProto_Type_TYPE_FLOAT;
  static const Type TYPE_INT64 = FieldDescriptorProto_Type_TYPE_INT64;
  static const Type TYPE_UINT64 = FieldDescriptorProto_Type_TYPE_UINT64;
  static const Type TYPE_INT32 = FieldDescriptorProto_Type_TYPE_INT32;
  static const Type TYPE_FIXED64 = FieldDescriptorProto_Type_TYPE_FIXED64;
  static const Type TYPE_FIXED32 = FieldDescriptorProto_Type_TYPE_FIXED32;
  static const Type TYPE_BOOL = FieldDescriptorProto_Type_TYPE_BOOL;
  static const Type TYPE_STRING = FieldDescriptorProto_Type_TYPE_STRING;
  static const Type TYPE_GROUP = FieldDescriptorProto_Type_TYPE_GROUP;
  static const Type TYPE_MESSAGE = FieldDescriptorProto_Type_TYPE_MESSAGE;
  static const Type TYPE_BYTES = FieldDescriptorProto_Type_TYPE_BYTES;
  static const Type TYPE_UINT32 = FieldDescriptorProto_Type_TYPE_UINT32;
  static const Type TYPE_ENUM = FieldDescriptorProto_Type_TYPE_ENUM;
  static const Type TYPE_SFIXED32 = FieldDescriptorProto_Type_TYPE_SFIXED32;
  static const Type TYPE_SFIXED64 = FieldDescriptorProto_Type_TYPE_SFIXED64;
  static const Type TYPE_SINT32 = FieldDescriptorProto_Type_TYPE_SINT32;
  static const Type TYPE_SINT64 = FieldDescriptorProto_Type_TYPE_SINT64;
  static const Label LABEL_OPTIONAL = FieldDescriptorProto_Label_LABEL_OPTIONAL;
  static const Label LABEL_REQUIRED = FieldDescriptorProto_Label_LABEL_REQUIRED;
  static const Label LABEL_REPEATED = FieldDescriptorProto_Label_LABEL_REPEATED;
  void set_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_number(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_label(::perfetto::protos::pbzero::FieldDescriptorProto_Label value) {
    AppendTinyVarInt(4, value);
  }
  void set_type(::perfetto::protos::pbzero::FieldDescriptorProto_Type value) {
    AppendTinyVarInt(5, value);
  }
  void set_type_name(const std::string& value) {
    AppendBytes(6, value.data(), value.size());
  }
  void set_type_name(const char* data, size_t size) {
    AppendBytes(6, data, size);
  }
  void set_extendee(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void set_extendee(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
  void set_default_value(const std::string& value) {
    AppendBytes(7, value.data(), value.size());
  }
  void set_default_value(const char* data, size_t size) {
    AppendBytes(7, data, size);
  }
  void set_oneof_index(int32_t value) {
    AppendVarInt(9, value);
  }
};

class DescriptorProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/10, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  DescriptorProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit DescriptorProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit DescriptorProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_field() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> field() const { return GetRepeated<::protozero::ConstBytes>(2); }
  bool has_extension() const { return at<6>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> extension() const { return GetRepeated<::protozero::ConstBytes>(6); }
  bool has_nested_type() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> nested_type() const { return GetRepeated<::protozero::ConstBytes>(3); }
  bool has_enum_type() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> enum_type() const { return GetRepeated<::protozero::ConstBytes>(4); }
  bool has_oneof_decl() const { return at<8>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> oneof_decl() const { return GetRepeated<::protozero::ConstBytes>(8); }
  bool has_reserved_range() const { return at<9>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> reserved_range() const { return GetRepeated<::protozero::ConstBytes>(9); }
  bool has_reserved_name() const { return at<10>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstChars> reserved_name() const { return GetRepeated<::protozero::ConstChars>(10); }
};

class DescriptorProto : public ::protozero::Message {
 public:
  using Decoder = DescriptorProto_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kFieldFieldNumber = 2,
    kExtensionFieldNumber = 6,
    kNestedTypeFieldNumber = 3,
    kEnumTypeFieldNumber = 4,
    kOneofDeclFieldNumber = 8,
    kReservedRangeFieldNumber = 9,
    kReservedNameFieldNumber = 10,
  };
  using ReservedRange = ::perfetto::protos::pbzero::DescriptorProto_ReservedRange;
  void set_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  template <typename T = FieldDescriptorProto> T* add_field() {
    return BeginNestedMessage<T>(2);
  }

  template <typename T = FieldDescriptorProto> T* add_extension() {
    return BeginNestedMessage<T>(6);
  }

  template <typename T = DescriptorProto> T* add_nested_type() {
    return BeginNestedMessage<T>(3);
  }

  template <typename T = EnumDescriptorProto> T* add_enum_type() {
    return BeginNestedMessage<T>(4);
  }

  template <typename T = OneofDescriptorProto> T* add_oneof_decl() {
    return BeginNestedMessage<T>(8);
  }

  template <typename T = DescriptorProto_ReservedRange> T* add_reserved_range() {
    return BeginNestedMessage<T>(9);
  }

  void add_reserved_name(const std::string& value) {
    AppendBytes(10, value.data(), value.size());
  }
  void add_reserved_name(const char* data, size_t size) {
    AppendBytes(10, data, size);
  }
};

class DescriptorProto_ReservedRange_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  DescriptorProto_ReservedRange_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit DescriptorProto_ReservedRange_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit DescriptorProto_ReservedRange_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_start() const { return at<1>().valid(); }
  int32_t start() const { return at<1>().as_int32(); }
  bool has_end() const { return at<2>().valid(); }
  int32_t end() const { return at<2>().as_int32(); }
};

class DescriptorProto_ReservedRange : public ::protozero::Message {
 public:
  using Decoder = DescriptorProto_ReservedRange_Decoder;
  enum : int32_t {
    kStartFieldNumber = 1,
    kEndFieldNumber = 2,
  };
  void set_start(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_end(int32_t value) {
    AppendVarInt(2, value);
  }
};

class FileDescriptorProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/11, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  FileDescriptorProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit FileDescriptorProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit FileDescriptorProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_package() const { return at<2>().valid(); }
  ::protozero::ConstChars package() const { return at<2>().as_string(); }
  bool has_dependency() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstChars> dependency() const { return GetRepeated<::protozero::ConstChars>(3); }
  bool has_public_dependency() const { return at<10>().valid(); }
  ::protozero::RepeatedFieldIterator<int32_t> public_dependency() const { return GetRepeated<int32_t>(10); }
  bool has_weak_dependency() const { return at<11>().valid(); }
  ::protozero::RepeatedFieldIterator<int32_t> weak_dependency() const { return GetRepeated<int32_t>(11); }
  bool has_message_type() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> message_type() const { return GetRepeated<::protozero::ConstBytes>(4); }
  bool has_enum_type() const { return at<5>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> enum_type() const { return GetRepeated<::protozero::ConstBytes>(5); }
  bool has_extension() const { return at<7>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> extension() const { return GetRepeated<::protozero::ConstBytes>(7); }
};

class FileDescriptorProto : public ::protozero::Message {
 public:
  using Decoder = FileDescriptorProto_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kPackageFieldNumber = 2,
    kDependencyFieldNumber = 3,
    kPublicDependencyFieldNumber = 10,
    kWeakDependencyFieldNumber = 11,
    kMessageTypeFieldNumber = 4,
    kEnumTypeFieldNumber = 5,
    kExtensionFieldNumber = 7,
  };
  void set_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_package(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void set_package(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
  void add_dependency(const std::string& value) {
    AppendBytes(3, value.data(), value.size());
  }
  void add_dependency(const char* data, size_t size) {
    AppendBytes(3, data, size);
  }
  void add_public_dependency(int32_t value) {
    AppendVarInt(10, value);
  }
  void add_weak_dependency(int32_t value) {
    AppendVarInt(11, value);
  }
  template <typename T = DescriptorProto> T* add_message_type() {
    return BeginNestedMessage<T>(4);
  }

  template <typename T = EnumDescriptorProto> T* add_enum_type() {
    return BeginNestedMessage<T>(5);
  }

  template <typename T = FieldDescriptorProto> T* add_extension() {
    return BeginNestedMessage<T>(7);
  }

};

class FileDescriptorSet_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  FileDescriptorSet_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit FileDescriptorSet_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit FileDescriptorSet_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_file() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> file() const { return GetRepeated<::protozero::ConstBytes>(1); }
};

class FileDescriptorSet : public ::protozero::Message {
 public:
  using Decoder = FileDescriptorSet_Decoder;
  enum : int32_t {
    kFileFieldNumber = 1,
  };
  template <typename T = FileDescriptorProto> T* add_file() {
    return BeginNestedMessage<T>(1);
  }

};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/common/gpu_counter_descriptor.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_COMMON_GPU_COUNTER_DESCRIPTOR_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_COMMON_GPU_COUNTER_DESCRIPTOR_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class GpuCounterDescriptor_GpuCounterBlock;
class GpuCounterDescriptor_GpuCounterSpec;
enum GpuCounterDescriptor_MeasureUnit : int32_t;

enum GpuCounterDescriptor_MeasureUnit : int32_t {
  GpuCounterDescriptor_MeasureUnit_NONE = 0,
  GpuCounterDescriptor_MeasureUnit_BIT = 1,
  GpuCounterDescriptor_MeasureUnit_KILOBIT = 2,
  GpuCounterDescriptor_MeasureUnit_MEGABIT = 3,
  GpuCounterDescriptor_MeasureUnit_GIGABIT = 4,
  GpuCounterDescriptor_MeasureUnit_TERABIT = 5,
  GpuCounterDescriptor_MeasureUnit_PETABIT = 6,
  GpuCounterDescriptor_MeasureUnit_BYTE = 7,
  GpuCounterDescriptor_MeasureUnit_KILOBYTE = 8,
  GpuCounterDescriptor_MeasureUnit_MEGABYTE = 9,
  GpuCounterDescriptor_MeasureUnit_GIGABYTE = 10,
  GpuCounterDescriptor_MeasureUnit_TERABYTE = 11,
  GpuCounterDescriptor_MeasureUnit_PETABYTE = 12,
  GpuCounterDescriptor_MeasureUnit_HERTZ = 13,
  GpuCounterDescriptor_MeasureUnit_KILOHERTZ = 14,
  GpuCounterDescriptor_MeasureUnit_MEGAHERTZ = 15,
  GpuCounterDescriptor_MeasureUnit_GIGAHERTZ = 16,
  GpuCounterDescriptor_MeasureUnit_TERAHERTZ = 17,
  GpuCounterDescriptor_MeasureUnit_PETAHERTZ = 18,
  GpuCounterDescriptor_MeasureUnit_NANOSECOND = 19,
  GpuCounterDescriptor_MeasureUnit_MICROSECOND = 20,
  GpuCounterDescriptor_MeasureUnit_MILLISECOND = 21,
  GpuCounterDescriptor_MeasureUnit_SECOND = 22,
  GpuCounterDescriptor_MeasureUnit_MINUTE = 23,
  GpuCounterDescriptor_MeasureUnit_HOUR = 24,
  GpuCounterDescriptor_MeasureUnit_VERTEX = 25,
  GpuCounterDescriptor_MeasureUnit_PIXEL = 26,
  GpuCounterDescriptor_MeasureUnit_TRIANGLE = 27,
  GpuCounterDescriptor_MeasureUnit_PRIMITIVE = 38,
  GpuCounterDescriptor_MeasureUnit_FRAGMENT = 39,
  GpuCounterDescriptor_MeasureUnit_MILLIWATT = 28,
  GpuCounterDescriptor_MeasureUnit_WATT = 29,
  GpuCounterDescriptor_MeasureUnit_KILOWATT = 30,
  GpuCounterDescriptor_MeasureUnit_JOULE = 31,
  GpuCounterDescriptor_MeasureUnit_VOLT = 32,
  GpuCounterDescriptor_MeasureUnit_AMPERE = 33,
  GpuCounterDescriptor_MeasureUnit_CELSIUS = 34,
  GpuCounterDescriptor_MeasureUnit_FAHRENHEIT = 35,
  GpuCounterDescriptor_MeasureUnit_KELVIN = 36,
  GpuCounterDescriptor_MeasureUnit_PERCENT = 37,
  GpuCounterDescriptor_MeasureUnit_INSTRUCTION = 40,
};

const GpuCounterDescriptor_MeasureUnit GpuCounterDescriptor_MeasureUnit_MIN = GpuCounterDescriptor_MeasureUnit_NONE;
const GpuCounterDescriptor_MeasureUnit GpuCounterDescriptor_MeasureUnit_MAX = GpuCounterDescriptor_MeasureUnit_INSTRUCTION;

class GpuCounterDescriptor_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  GpuCounterDescriptor_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit GpuCounterDescriptor_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit GpuCounterDescriptor_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_specs() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> specs() const { return GetRepeated<::protozero::ConstBytes>(1); }
  bool has_blocks() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> blocks() const { return GetRepeated<::protozero::ConstBytes>(2); }
  bool has_min_sampling_period_ns() const { return at<3>().valid(); }
  uint64_t min_sampling_period_ns() const { return at<3>().as_uint64(); }
  bool has_max_sampling_period_ns() const { return at<4>().valid(); }
  uint64_t max_sampling_period_ns() const { return at<4>().as_uint64(); }
  bool has_supports_instrumented_sampling() const { return at<5>().valid(); }
  bool supports_instrumented_sampling() const { return at<5>().as_bool(); }
};

class GpuCounterDescriptor : public ::protozero::Message {
 public:
  using Decoder = GpuCounterDescriptor_Decoder;
  enum : int32_t {
    kSpecsFieldNumber = 1,
    kBlocksFieldNumber = 2,
    kMinSamplingPeriodNsFieldNumber = 3,
    kMaxSamplingPeriodNsFieldNumber = 4,
    kSupportsInstrumentedSamplingFieldNumber = 5,
  };
  using GpuCounterSpec = ::perfetto::protos::pbzero::GpuCounterDescriptor_GpuCounterSpec;
  using GpuCounterBlock = ::perfetto::protos::pbzero::GpuCounterDescriptor_GpuCounterBlock;
  using MeasureUnit = ::perfetto::protos::pbzero::GpuCounterDescriptor_MeasureUnit;
  static const MeasureUnit NONE = GpuCounterDescriptor_MeasureUnit_NONE;
  static const MeasureUnit BIT = GpuCounterDescriptor_MeasureUnit_BIT;
  static const MeasureUnit KILOBIT = GpuCounterDescriptor_MeasureUnit_KILOBIT;
  static const MeasureUnit MEGABIT = GpuCounterDescriptor_MeasureUnit_MEGABIT;
  static const MeasureUnit GIGABIT = GpuCounterDescriptor_MeasureUnit_GIGABIT;
  static const MeasureUnit TERABIT = GpuCounterDescriptor_MeasureUnit_TERABIT;
  static const MeasureUnit PETABIT = GpuCounterDescriptor_MeasureUnit_PETABIT;
  static const MeasureUnit BYTE = GpuCounterDescriptor_MeasureUnit_BYTE;
  static const MeasureUnit KILOBYTE = GpuCounterDescriptor_MeasureUnit_KILOBYTE;
  static const MeasureUnit MEGABYTE = GpuCounterDescriptor_MeasureUnit_MEGABYTE;
  static const MeasureUnit GIGABYTE = GpuCounterDescriptor_MeasureUnit_GIGABYTE;
  static const MeasureUnit TERABYTE = GpuCounterDescriptor_MeasureUnit_TERABYTE;
  static const MeasureUnit PETABYTE = GpuCounterDescriptor_MeasureUnit_PETABYTE;
  static const MeasureUnit HERTZ = GpuCounterDescriptor_MeasureUnit_HERTZ;
  static const MeasureUnit KILOHERTZ = GpuCounterDescriptor_MeasureUnit_KILOHERTZ;
  static const MeasureUnit MEGAHERTZ = GpuCounterDescriptor_MeasureUnit_MEGAHERTZ;
  static const MeasureUnit GIGAHERTZ = GpuCounterDescriptor_MeasureUnit_GIGAHERTZ;
  static const MeasureUnit TERAHERTZ = GpuCounterDescriptor_MeasureUnit_TERAHERTZ;
  static const MeasureUnit PETAHERTZ = GpuCounterDescriptor_MeasureUnit_PETAHERTZ;
  static const MeasureUnit NANOSECOND = GpuCounterDescriptor_MeasureUnit_NANOSECOND;
  static const MeasureUnit MICROSECOND = GpuCounterDescriptor_MeasureUnit_MICROSECOND;
  static const MeasureUnit MILLISECOND = GpuCounterDescriptor_MeasureUnit_MILLISECOND;
  static const MeasureUnit SECOND = GpuCounterDescriptor_MeasureUnit_SECOND;
  static const MeasureUnit MINUTE = GpuCounterDescriptor_MeasureUnit_MINUTE;
  static const MeasureUnit HOUR = GpuCounterDescriptor_MeasureUnit_HOUR;
  static const MeasureUnit VERTEX = GpuCounterDescriptor_MeasureUnit_VERTEX;
  static const MeasureUnit PIXEL = GpuCounterDescriptor_MeasureUnit_PIXEL;
  static const MeasureUnit TRIANGLE = GpuCounterDescriptor_MeasureUnit_TRIANGLE;
  static const MeasureUnit PRIMITIVE = GpuCounterDescriptor_MeasureUnit_PRIMITIVE;
  static const MeasureUnit FRAGMENT = GpuCounterDescriptor_MeasureUnit_FRAGMENT;
  static const MeasureUnit MILLIWATT = GpuCounterDescriptor_MeasureUnit_MILLIWATT;
  static const MeasureUnit WATT = GpuCounterDescriptor_MeasureUnit_WATT;
  static const MeasureUnit KILOWATT = GpuCounterDescriptor_MeasureUnit_KILOWATT;
  static const MeasureUnit JOULE = GpuCounterDescriptor_MeasureUnit_JOULE;
  static const MeasureUnit VOLT = GpuCounterDescriptor_MeasureUnit_VOLT;
  static const MeasureUnit AMPERE = GpuCounterDescriptor_MeasureUnit_AMPERE;
  static const MeasureUnit CELSIUS = GpuCounterDescriptor_MeasureUnit_CELSIUS;
  static const MeasureUnit FAHRENHEIT = GpuCounterDescriptor_MeasureUnit_FAHRENHEIT;
  static const MeasureUnit KELVIN = GpuCounterDescriptor_MeasureUnit_KELVIN;
  static const MeasureUnit PERCENT = GpuCounterDescriptor_MeasureUnit_PERCENT;
  static const MeasureUnit INSTRUCTION = GpuCounterDescriptor_MeasureUnit_INSTRUCTION;
  template <typename T = GpuCounterDescriptor_GpuCounterSpec> T* add_specs() {
    return BeginNestedMessage<T>(1);
  }

  template <typename T = GpuCounterDescriptor_GpuCounterBlock> T* add_blocks() {
    return BeginNestedMessage<T>(2);
  }

  void set_min_sampling_period_ns(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_max_sampling_period_ns(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_supports_instrumented_sampling(bool value) {
    AppendTinyVarInt(5, value);
  }
};

class GpuCounterDescriptor_GpuCounterBlock_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  GpuCounterDescriptor_GpuCounterBlock_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit GpuCounterDescriptor_GpuCounterBlock_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit GpuCounterDescriptor_GpuCounterBlock_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_block_id() const { return at<1>().valid(); }
  uint32_t block_id() const { return at<1>().as_uint32(); }
  bool has_block_capacity() const { return at<2>().valid(); }
  uint32_t block_capacity() const { return at<2>().as_uint32(); }
  bool has_name() const { return at<3>().valid(); }
  ::protozero::ConstChars name() const { return at<3>().as_string(); }
  bool has_description() const { return at<4>().valid(); }
  ::protozero::ConstChars description() const { return at<4>().as_string(); }
  bool has_counter_ids() const { return at<5>().valid(); }
  ::protozero::RepeatedFieldIterator<uint32_t> counter_ids() const { return GetRepeated<uint32_t>(5); }
};

class GpuCounterDescriptor_GpuCounterBlock : public ::protozero::Message {
 public:
  using Decoder = GpuCounterDescriptor_GpuCounterBlock_Decoder;
  enum : int32_t {
    kBlockIdFieldNumber = 1,
    kBlockCapacityFieldNumber = 2,
    kNameFieldNumber = 3,
    kDescriptionFieldNumber = 4,
    kCounterIdsFieldNumber = 5,
  };
  void set_block_id(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_block_capacity(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_name(const std::string& value) {
    AppendBytes(3, value.data(), value.size());
  }
  void set_name(const char* data, size_t size) {
    AppendBytes(3, data, size);
  }
  void set_description(const std::string& value) {
    AppendBytes(4, value.data(), value.size());
  }
  void set_description(const char* data, size_t size) {
    AppendBytes(4, data, size);
  }
  void add_counter_ids(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class GpuCounterDescriptor_GpuCounterSpec_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/9, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  GpuCounterDescriptor_GpuCounterSpec_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit GpuCounterDescriptor_GpuCounterSpec_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit GpuCounterDescriptor_GpuCounterSpec_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_counter_id() const { return at<1>().valid(); }
  uint32_t counter_id() const { return at<1>().as_uint32(); }
  bool has_name() const { return at<2>().valid(); }
  ::protozero::ConstChars name() const { return at<2>().as_string(); }
  bool has_description() const { return at<3>().valid(); }
  ::protozero::ConstChars description() const { return at<3>().as_string(); }
  bool has_int_peak_value() const { return at<5>().valid(); }
  int64_t int_peak_value() const { return at<5>().as_int64(); }
  bool has_double_peak_value() const { return at<6>().valid(); }
  double double_peak_value() const { return at<6>().as_double(); }
  bool has_numerator_units() const { return at<7>().valid(); }
  ::protozero::RepeatedFieldIterator<int32_t> numerator_units() const { return GetRepeated<int32_t>(7); }
  bool has_denominator_units() const { return at<8>().valid(); }
  ::protozero::RepeatedFieldIterator<int32_t> denominator_units() const { return GetRepeated<int32_t>(8); }
  bool has_select_by_default() const { return at<9>().valid(); }
  bool select_by_default() const { return at<9>().as_bool(); }
};

class GpuCounterDescriptor_GpuCounterSpec : public ::protozero::Message {
 public:
  using Decoder = GpuCounterDescriptor_GpuCounterSpec_Decoder;
  enum : int32_t {
    kCounterIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kIntPeakValueFieldNumber = 5,
    kDoublePeakValueFieldNumber = 6,
    kNumeratorUnitsFieldNumber = 7,
    kDenominatorUnitsFieldNumber = 8,
    kSelectByDefaultFieldNumber = 9,
  };
  void set_counter_id(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_name(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void set_name(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
  void set_description(const std::string& value) {
    AppendBytes(3, value.data(), value.size());
  }
  void set_description(const char* data, size_t size) {
    AppendBytes(3, data, size);
  }
  void set_int_peak_value(int64_t value) {
    AppendVarInt(5, value);
  }
  void set_double_peak_value(double value) {
    AppendFixed(6, value);
  }
  void add_numerator_units(::perfetto::protos::pbzero::GpuCounterDescriptor_MeasureUnit value) {
    AppendTinyVarInt(7, value);
  }
  void add_denominator_units(::perfetto::protos::pbzero::GpuCounterDescriptor_MeasureUnit value) {
    AppendTinyVarInt(8, value);
  }
  void set_select_by_default(bool value) {
    AppendTinyVarInt(9, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/common/observable_events.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_COMMON_OBSERVABLE_EVENTS_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_COMMON_OBSERVABLE_EVENTS_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class ObservableEvents_DataSourceInstanceStateChange;
enum ObservableEvents_DataSourceInstanceState : int32_t;

enum ObservableEvents_Type : int32_t {
  ObservableEvents_Type_TYPE_UNSPECIFIED = 0,
  ObservableEvents_Type_TYPE_DATA_SOURCES_INSTANCES = 1,
};

const ObservableEvents_Type ObservableEvents_Type_MIN = ObservableEvents_Type_TYPE_UNSPECIFIED;
const ObservableEvents_Type ObservableEvents_Type_MAX = ObservableEvents_Type_TYPE_DATA_SOURCES_INSTANCES;

enum ObservableEvents_DataSourceInstanceState : int32_t {
  ObservableEvents_DataSourceInstanceState_DATA_SOURCE_INSTANCE_STATE_STOPPED = 1,
  ObservableEvents_DataSourceInstanceState_DATA_SOURCE_INSTANCE_STATE_STARTED = 2,
};

const ObservableEvents_DataSourceInstanceState ObservableEvents_DataSourceInstanceState_MIN = ObservableEvents_DataSourceInstanceState_DATA_SOURCE_INSTANCE_STATE_STOPPED;
const ObservableEvents_DataSourceInstanceState ObservableEvents_DataSourceInstanceState_MAX = ObservableEvents_DataSourceInstanceState_DATA_SOURCE_INSTANCE_STATE_STARTED;

class ObservableEvents_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  ObservableEvents_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ObservableEvents_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ObservableEvents_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_instance_state_changes() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> instance_state_changes() const { return GetRepeated<::protozero::ConstBytes>(1); }
};

class ObservableEvents : public ::protozero::Message {
 public:
  using Decoder = ObservableEvents_Decoder;
  enum : int32_t {
    kInstanceStateChangesFieldNumber = 1,
  };
  using DataSourceInstanceStateChange = ::perfetto::protos::pbzero::ObservableEvents_DataSourceInstanceStateChange;
  using Type = ::perfetto::protos::pbzero::ObservableEvents_Type;
  using DataSourceInstanceState = ::perfetto::protos::pbzero::ObservableEvents_DataSourceInstanceState;
  static const Type TYPE_UNSPECIFIED = ObservableEvents_Type_TYPE_UNSPECIFIED;
  static const Type TYPE_DATA_SOURCES_INSTANCES = ObservableEvents_Type_TYPE_DATA_SOURCES_INSTANCES;
  static const DataSourceInstanceState DATA_SOURCE_INSTANCE_STATE_STOPPED = ObservableEvents_DataSourceInstanceState_DATA_SOURCE_INSTANCE_STATE_STOPPED;
  static const DataSourceInstanceState DATA_SOURCE_INSTANCE_STATE_STARTED = ObservableEvents_DataSourceInstanceState_DATA_SOURCE_INSTANCE_STATE_STARTED;
  template <typename T = ObservableEvents_DataSourceInstanceStateChange> T* add_instance_state_changes() {
    return BeginNestedMessage<T>(1);
  }

};

class ObservableEvents_DataSourceInstanceStateChange_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ObservableEvents_DataSourceInstanceStateChange_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ObservableEvents_DataSourceInstanceStateChange_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ObservableEvents_DataSourceInstanceStateChange_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_producer_name() const { return at<1>().valid(); }
  ::protozero::ConstChars producer_name() const { return at<1>().as_string(); }
  bool has_data_source_name() const { return at<2>().valid(); }
  ::protozero::ConstChars data_source_name() const { return at<2>().as_string(); }
  bool has_state() const { return at<3>().valid(); }
  int32_t state() const { return at<3>().as_int32(); }
};

class ObservableEvents_DataSourceInstanceStateChange : public ::protozero::Message {
 public:
  using Decoder = ObservableEvents_DataSourceInstanceStateChange_Decoder;
  enum : int32_t {
    kProducerNameFieldNumber = 1,
    kDataSourceNameFieldNumber = 2,
    kStateFieldNumber = 3,
  };
  void set_producer_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_producer_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_data_source_name(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void set_data_source_name(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
  void set_state(::perfetto::protos::pbzero::ObservableEvents_DataSourceInstanceState value) {
    AppendTinyVarInt(3, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/common/sys_stats_counters.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_COMMON_SYS_STATS_COUNTERS_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_COMMON_SYS_STATS_COUNTERS_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


enum MeminfoCounters : int32_t {
  MEMINFO_UNSPECIFIED = 0,
  MEMINFO_MEM_TOTAL = 1,
  MEMINFO_MEM_FREE = 2,
  MEMINFO_MEM_AVAILABLE = 3,
  MEMINFO_BUFFERS = 4,
  MEMINFO_CACHED = 5,
  MEMINFO_SWAP_CACHED = 6,
  MEMINFO_ACTIVE = 7,
  MEMINFO_INACTIVE = 8,
  MEMINFO_ACTIVE_ANON = 9,
  MEMINFO_INACTIVE_ANON = 10,
  MEMINFO_ACTIVE_FILE = 11,
  MEMINFO_INACTIVE_FILE = 12,
  MEMINFO_UNEVICTABLE = 13,
  MEMINFO_MLOCKED = 14,
  MEMINFO_SWAP_TOTAL = 15,
  MEMINFO_SWAP_FREE = 16,
  MEMINFO_DIRTY = 17,
  MEMINFO_WRITEBACK = 18,
  MEMINFO_ANON_PAGES = 19,
  MEMINFO_MAPPED = 20,
  MEMINFO_SHMEM = 21,
  MEMINFO_SLAB = 22,
  MEMINFO_SLAB_RECLAIMABLE = 23,
  MEMINFO_SLAB_UNRECLAIMABLE = 24,
  MEMINFO_KERNEL_STACK = 25,
  MEMINFO_PAGE_TABLES = 26,
  MEMINFO_COMMIT_LIMIT = 27,
  MEMINFO_COMMITED_AS = 28,
  MEMINFO_VMALLOC_TOTAL = 29,
  MEMINFO_VMALLOC_USED = 30,
  MEMINFO_VMALLOC_CHUNK = 31,
  MEMINFO_CMA_TOTAL = 32,
  MEMINFO_CMA_FREE = 33,
};

const MeminfoCounters MeminfoCounters_MIN = MEMINFO_UNSPECIFIED;
const MeminfoCounters MeminfoCounters_MAX = MEMINFO_CMA_FREE;

enum VmstatCounters : int32_t {
  VMSTAT_UNSPECIFIED = 0,
  VMSTAT_NR_FREE_PAGES = 1,
  VMSTAT_NR_ALLOC_BATCH = 2,
  VMSTAT_NR_INACTIVE_ANON = 3,
  VMSTAT_NR_ACTIVE_ANON = 4,
  VMSTAT_NR_INACTIVE_FILE = 5,
  VMSTAT_NR_ACTIVE_FILE = 6,
  VMSTAT_NR_UNEVICTABLE = 7,
  VMSTAT_NR_MLOCK = 8,
  VMSTAT_NR_ANON_PAGES = 9,
  VMSTAT_NR_MAPPED = 10,
  VMSTAT_NR_FILE_PAGES = 11,
  VMSTAT_NR_DIRTY = 12,
  VMSTAT_NR_WRITEBACK = 13,
  VMSTAT_NR_SLAB_RECLAIMABLE = 14,
  VMSTAT_NR_SLAB_UNRECLAIMABLE = 15,
  VMSTAT_NR_PAGE_TABLE_PAGES = 16,
  VMSTAT_NR_KERNEL_STACK = 17,
  VMSTAT_NR_OVERHEAD = 18,
  VMSTAT_NR_UNSTABLE = 19,
  VMSTAT_NR_BOUNCE = 20,
  VMSTAT_NR_VMSCAN_WRITE = 21,
  VMSTAT_NR_VMSCAN_IMMEDIATE_RECLAIM = 22,
  VMSTAT_NR_WRITEBACK_TEMP = 23,
  VMSTAT_NR_ISOLATED_ANON = 24,
  VMSTAT_NR_ISOLATED_FILE = 25,
  VMSTAT_NR_SHMEM = 26,
  VMSTAT_NR_DIRTIED = 27,
  VMSTAT_NR_WRITTEN = 28,
  VMSTAT_NR_PAGES_SCANNED = 29,
  VMSTAT_WORKINGSET_REFAULT = 30,
  VMSTAT_WORKINGSET_ACTIVATE = 31,
  VMSTAT_WORKINGSET_NODERECLAIM = 32,
  VMSTAT_NR_ANON_TRANSPARENT_HUGEPAGES = 33,
  VMSTAT_NR_FREE_CMA = 34,
  VMSTAT_NR_SWAPCACHE = 35,
  VMSTAT_NR_DIRTY_THRESHOLD = 36,
  VMSTAT_NR_DIRTY_BACKGROUND_THRESHOLD = 37,
  VMSTAT_PGPGIN = 38,
  VMSTAT_PGPGOUT = 39,
  VMSTAT_PGPGOUTCLEAN = 40,
  VMSTAT_PSWPIN = 41,
  VMSTAT_PSWPOUT = 42,
  VMSTAT_PGALLOC_DMA = 43,
  VMSTAT_PGALLOC_NORMAL = 44,
  VMSTAT_PGALLOC_MOVABLE = 45,
  VMSTAT_PGFREE = 46,
  VMSTAT_PGACTIVATE = 47,
  VMSTAT_PGDEACTIVATE = 48,
  VMSTAT_PGFAULT = 49,
  VMSTAT_PGMAJFAULT = 50,
  VMSTAT_PGREFILL_DMA = 51,
  VMSTAT_PGREFILL_NORMAL = 52,
  VMSTAT_PGREFILL_MOVABLE = 53,
  VMSTAT_PGSTEAL_KSWAPD_DMA = 54,
  VMSTAT_PGSTEAL_KSWAPD_NORMAL = 55,
  VMSTAT_PGSTEAL_KSWAPD_MOVABLE = 56,
  VMSTAT_PGSTEAL_DIRECT_DMA = 57,
  VMSTAT_PGSTEAL_DIRECT_NORMAL = 58,
  VMSTAT_PGSTEAL_DIRECT_MOVABLE = 59,
  VMSTAT_PGSCAN_KSWAPD_DMA = 60,
  VMSTAT_PGSCAN_KSWAPD_NORMAL = 61,
  VMSTAT_PGSCAN_KSWAPD_MOVABLE = 62,
  VMSTAT_PGSCAN_DIRECT_DMA = 63,
  VMSTAT_PGSCAN_DIRECT_NORMAL = 64,
  VMSTAT_PGSCAN_DIRECT_MOVABLE = 65,
  VMSTAT_PGSCAN_DIRECT_THROTTLE = 66,
  VMSTAT_PGINODESTEAL = 67,
  VMSTAT_SLABS_SCANNED = 68,
  VMSTAT_KSWAPD_INODESTEAL = 69,
  VMSTAT_KSWAPD_LOW_WMARK_HIT_QUICKLY = 70,
  VMSTAT_KSWAPD_HIGH_WMARK_HIT_QUICKLY = 71,
  VMSTAT_PAGEOUTRUN = 72,
  VMSTAT_ALLOCSTALL = 73,
  VMSTAT_PGROTATED = 74,
  VMSTAT_DROP_PAGECACHE = 75,
  VMSTAT_DROP_SLAB = 76,
  VMSTAT_PGMIGRATE_SUCCESS = 77,
  VMSTAT_PGMIGRATE_FAIL = 78,
  VMSTAT_COMPACT_MIGRATE_SCANNED = 79,
  VMSTAT_COMPACT_FREE_SCANNED = 80,
  VMSTAT_COMPACT_ISOLATED = 81,
  VMSTAT_COMPACT_STALL = 82,
  VMSTAT_COMPACT_FAIL = 83,
  VMSTAT_COMPACT_SUCCESS = 84,
  VMSTAT_COMPACT_DAEMON_WAKE = 85,
  VMSTAT_UNEVICTABLE_PGS_CULLED = 86,
  VMSTAT_UNEVICTABLE_PGS_SCANNED = 87,
  VMSTAT_UNEVICTABLE_PGS_RESCUED = 88,
  VMSTAT_UNEVICTABLE_PGS_MLOCKED = 89,
  VMSTAT_UNEVICTABLE_PGS_MUNLOCKED = 90,
  VMSTAT_UNEVICTABLE_PGS_CLEARED = 91,
  VMSTAT_UNEVICTABLE_PGS_STRANDED = 92,
  VMSTAT_NR_ZSPAGES = 93,
  VMSTAT_NR_ION_HEAP = 94,
  VMSTAT_NR_GPU_HEAP = 95,
};

const VmstatCounters VmstatCounters_MIN = VMSTAT_UNSPECIFIED;
const VmstatCounters VmstatCounters_MAX = VMSTAT_NR_GPU_HEAP;

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/common/trace_stats.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_COMMON_TRACE_STATS_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_COMMON_TRACE_STATS_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class TraceStats_BufferStats;

class TraceStats_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/10, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  TraceStats_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TraceStats_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TraceStats_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_buffer_stats() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> buffer_stats() const { return GetRepeated<::protozero::ConstBytes>(1); }
  bool has_producers_connected() const { return at<2>().valid(); }
  uint32_t producers_connected() const { return at<2>().as_uint32(); }
  bool has_producers_seen() const { return at<3>().valid(); }
  uint64_t producers_seen() const { return at<3>().as_uint64(); }
  bool has_data_sources_registered() const { return at<4>().valid(); }
  uint32_t data_sources_registered() const { return at<4>().as_uint32(); }
  bool has_data_sources_seen() const { return at<5>().valid(); }
  uint64_t data_sources_seen() const { return at<5>().as_uint64(); }
  bool has_tracing_sessions() const { return at<6>().valid(); }
  uint32_t tracing_sessions() const { return at<6>().as_uint32(); }
  bool has_total_buffers() const { return at<7>().valid(); }
  uint32_t total_buffers() const { return at<7>().as_uint32(); }
  bool has_chunks_discarded() const { return at<8>().valid(); }
  uint64_t chunks_discarded() const { return at<8>().as_uint64(); }
  bool has_patches_discarded() const { return at<9>().valid(); }
  uint64_t patches_discarded() const { return at<9>().as_uint64(); }
  bool has_invalid_packets() const { return at<10>().valid(); }
  uint64_t invalid_packets() const { return at<10>().as_uint64(); }
};

class TraceStats : public ::protozero::Message {
 public:
  using Decoder = TraceStats_Decoder;
  enum : int32_t {
    kBufferStatsFieldNumber = 1,
    kProducersConnectedFieldNumber = 2,
    kProducersSeenFieldNumber = 3,
    kDataSourcesRegisteredFieldNumber = 4,
    kDataSourcesSeenFieldNumber = 5,
    kTracingSessionsFieldNumber = 6,
    kTotalBuffersFieldNumber = 7,
    kChunksDiscardedFieldNumber = 8,
    kPatchesDiscardedFieldNumber = 9,
    kInvalidPacketsFieldNumber = 10,
  };
  using BufferStats = ::perfetto::protos::pbzero::TraceStats_BufferStats;
  template <typename T = TraceStats_BufferStats> T* add_buffer_stats() {
    return BeginNestedMessage<T>(1);
  }

  void set_producers_connected(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_producers_seen(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_data_sources_registered(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_data_sources_seen(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_tracing_sessions(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_total_buffers(uint32_t value) {
    AppendVarInt(7, value);
  }
  void set_chunks_discarded(uint64_t value) {
    AppendVarInt(8, value);
  }
  void set_patches_discarded(uint64_t value) {
    AppendVarInt(9, value);
  }
  void set_invalid_packets(uint64_t value) {
    AppendVarInt(10, value);
  }
};

class TraceStats_BufferStats_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/19, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TraceStats_BufferStats_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TraceStats_BufferStats_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TraceStats_BufferStats_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_buffer_size() const { return at<12>().valid(); }
  uint64_t buffer_size() const { return at<12>().as_uint64(); }
  bool has_bytes_written() const { return at<1>().valid(); }
  uint64_t bytes_written() const { return at<1>().as_uint64(); }
  bool has_bytes_overwritten() const { return at<13>().valid(); }
  uint64_t bytes_overwritten() const { return at<13>().as_uint64(); }
  bool has_bytes_read() const { return at<14>().valid(); }
  uint64_t bytes_read() const { return at<14>().as_uint64(); }
  bool has_padding_bytes_written() const { return at<15>().valid(); }
  uint64_t padding_bytes_written() const { return at<15>().as_uint64(); }
  bool has_padding_bytes_cleared() const { return at<16>().valid(); }
  uint64_t padding_bytes_cleared() const { return at<16>().as_uint64(); }
  bool has_chunks_written() const { return at<2>().valid(); }
  uint64_t chunks_written() const { return at<2>().as_uint64(); }
  bool has_chunks_rewritten() const { return at<10>().valid(); }
  uint64_t chunks_rewritten() const { return at<10>().as_uint64(); }
  bool has_chunks_overwritten() const { return at<3>().valid(); }
  uint64_t chunks_overwritten() const { return at<3>().as_uint64(); }
  bool has_chunks_discarded() const { return at<18>().valid(); }
  uint64_t chunks_discarded() const { return at<18>().as_uint64(); }
  bool has_chunks_read() const { return at<17>().valid(); }
  uint64_t chunks_read() const { return at<17>().as_uint64(); }
  bool has_chunks_committed_out_of_order() const { return at<11>().valid(); }
  uint64_t chunks_committed_out_of_order() const { return at<11>().as_uint64(); }
  bool has_write_wrap_count() const { return at<4>().valid(); }
  uint64_t write_wrap_count() const { return at<4>().as_uint64(); }
  bool has_patches_succeeded() const { return at<5>().valid(); }
  uint64_t patches_succeeded() const { return at<5>().as_uint64(); }
  bool has_patches_failed() const { return at<6>().valid(); }
  uint64_t patches_failed() const { return at<6>().as_uint64(); }
  bool has_readaheads_succeeded() const { return at<7>().valid(); }
  uint64_t readaheads_succeeded() const { return at<7>().as_uint64(); }
  bool has_readaheads_failed() const { return at<8>().valid(); }
  uint64_t readaheads_failed() const { return at<8>().as_uint64(); }
  bool has_abi_violations() const { return at<9>().valid(); }
  uint64_t abi_violations() const { return at<9>().as_uint64(); }
  bool has_trace_writer_packet_loss() const { return at<19>().valid(); }
  uint64_t trace_writer_packet_loss() const { return at<19>().as_uint64(); }
};

class TraceStats_BufferStats : public ::protozero::Message {
 public:
  using Decoder = TraceStats_BufferStats_Decoder;
  enum : int32_t {
    kBufferSizeFieldNumber = 12,
    kBytesWrittenFieldNumber = 1,
    kBytesOverwrittenFieldNumber = 13,
    kBytesReadFieldNumber = 14,
    kPaddingBytesWrittenFieldNumber = 15,
    kPaddingBytesClearedFieldNumber = 16,
    kChunksWrittenFieldNumber = 2,
    kChunksRewrittenFieldNumber = 10,
    kChunksOverwrittenFieldNumber = 3,
    kChunksDiscardedFieldNumber = 18,
    kChunksReadFieldNumber = 17,
    kChunksCommittedOutOfOrderFieldNumber = 11,
    kWriteWrapCountFieldNumber = 4,
    kPatchesSucceededFieldNumber = 5,
    kPatchesFailedFieldNumber = 6,
    kReadaheadsSucceededFieldNumber = 7,
    kReadaheadsFailedFieldNumber = 8,
    kAbiViolationsFieldNumber = 9,
    kTraceWriterPacketLossFieldNumber = 19,
  };
  void set_buffer_size(uint64_t value) {
    AppendVarInt(12, value);
  }
  void set_bytes_written(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_bytes_overwritten(uint64_t value) {
    AppendVarInt(13, value);
  }
  void set_bytes_read(uint64_t value) {
    AppendVarInt(14, value);
  }
  void set_padding_bytes_written(uint64_t value) {
    AppendVarInt(15, value);
  }
  void set_padding_bytes_cleared(uint64_t value) {
    AppendVarInt(16, value);
  }
  void set_chunks_written(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_chunks_rewritten(uint64_t value) {
    AppendVarInt(10, value);
  }
  void set_chunks_overwritten(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_chunks_discarded(uint64_t value) {
    AppendVarInt(18, value);
  }
  void set_chunks_read(uint64_t value) {
    AppendVarInt(17, value);
  }
  void set_chunks_committed_out_of_order(uint64_t value) {
    AppendVarInt(11, value);
  }
  void set_write_wrap_count(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_patches_succeeded(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_patches_failed(uint64_t value) {
    AppendVarInt(6, value);
  }
  void set_readaheads_succeeded(uint64_t value) {
    AppendVarInt(7, value);
  }
  void set_readaheads_failed(uint64_t value) {
    AppendVarInt(8, value);
  }
  void set_abi_violations(uint64_t value) {
    AppendVarInt(9, value);
  }
  void set_trace_writer_packet_loss(uint64_t value) {
    AppendVarInt(19, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/common/tracing_service_state.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_COMMON_TRACING_SERVICE_STATE_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_COMMON_TRACING_SERVICE_STATE_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class DataSourceDescriptor;
class TracingServiceState_DataSource;
class TracingServiceState_Producer;

class TracingServiceState_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  TracingServiceState_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TracingServiceState_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TracingServiceState_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_producers() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> producers() const { return GetRepeated<::protozero::ConstBytes>(1); }
  bool has_data_sources() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> data_sources() const { return GetRepeated<::protozero::ConstBytes>(2); }
  bool has_num_sessions() const { return at<3>().valid(); }
  int32_t num_sessions() const { return at<3>().as_int32(); }
  bool has_num_sessions_started() const { return at<4>().valid(); }
  int32_t num_sessions_started() const { return at<4>().as_int32(); }
};

class TracingServiceState : public ::protozero::Message {
 public:
  using Decoder = TracingServiceState_Decoder;
  enum : int32_t {
    kProducersFieldNumber = 1,
    kDataSourcesFieldNumber = 2,
    kNumSessionsFieldNumber = 3,
    kNumSessionsStartedFieldNumber = 4,
  };
  using Producer = ::perfetto::protos::pbzero::TracingServiceState_Producer;
  using DataSource = ::perfetto::protos::pbzero::TracingServiceState_DataSource;
  template <typename T = TracingServiceState_Producer> T* add_producers() {
    return BeginNestedMessage<T>(1);
  }

  template <typename T = TracingServiceState_DataSource> T* add_data_sources() {
    return BeginNestedMessage<T>(2);
  }

  void set_num_sessions(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_num_sessions_started(int32_t value) {
    AppendVarInt(4, value);
  }
};

class TracingServiceState_DataSource_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TracingServiceState_DataSource_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TracingServiceState_DataSource_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TracingServiceState_DataSource_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_ds_descriptor() const { return at<1>().valid(); }
  ::protozero::ConstBytes ds_descriptor() const { return at<1>().as_bytes(); }
  bool has_producer_id() const { return at<2>().valid(); }
  int32_t producer_id() const { return at<2>().as_int32(); }
};

class TracingServiceState_DataSource : public ::protozero::Message {
 public:
  using Decoder = TracingServiceState_DataSource_Decoder;
  enum : int32_t {
    kDsDescriptorFieldNumber = 1,
    kProducerIdFieldNumber = 2,
  };
  template <typename T = DataSourceDescriptor> T* set_ds_descriptor() {
    return BeginNestedMessage<T>(1);
  }

  void set_producer_id(int32_t value) {
    AppendVarInt(2, value);
  }
};

class TracingServiceState_Producer_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TracingServiceState_Producer_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TracingServiceState_Producer_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TracingServiceState_Producer_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_id() const { return at<1>().valid(); }
  int32_t id() const { return at<1>().as_int32(); }
  bool has_name() const { return at<2>().valid(); }
  ::protozero::ConstChars name() const { return at<2>().as_string(); }
  bool has_uid() const { return at<3>().valid(); }
  int32_t uid() const { return at<3>().as_int32(); }
};

class TracingServiceState_Producer : public ::protozero::Message {
 public:
  using Decoder = TracingServiceState_Producer_Decoder;
  enum : int32_t {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kUidFieldNumber = 3,
  };
  void set_id(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_name(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void set_name(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
  void set_uid(int32_t value) {
    AppendVarInt(3, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/common/track_event_descriptor.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_COMMON_TRACK_EVENT_DESCRIPTOR_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_COMMON_TRACK_EVENT_DESCRIPTOR_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class TrackEventDescriptor_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  TrackEventDescriptor_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TrackEventDescriptor_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TrackEventDescriptor_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_available_categories() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstChars> available_categories() const { return GetRepeated<::protozero::ConstChars>(1); }
};

class TrackEventDescriptor : public ::protozero::Message {
 public:
  using Decoder = TrackEventDescriptor_Decoder;
  enum : int32_t {
    kAvailableCategoriesFieldNumber = 1,
  };
  void add_available_categories(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void add_available_categories(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/config/android/android_log_config.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_ANDROID_ANDROID_LOG_CONFIG_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_ANDROID_ANDROID_LOG_CONFIG_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

enum AndroidLogId : int32_t;
enum AndroidLogPriority : int32_t;

class AndroidLogConfig_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  AndroidLogConfig_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit AndroidLogConfig_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit AndroidLogConfig_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_log_ids() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<int32_t> log_ids() const { return GetRepeated<int32_t>(1); }
  bool has_min_prio() const { return at<3>().valid(); }
  int32_t min_prio() const { return at<3>().as_int32(); }
  bool has_filter_tags() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstChars> filter_tags() const { return GetRepeated<::protozero::ConstChars>(4); }
};

class AndroidLogConfig : public ::protozero::Message {
 public:
  using Decoder = AndroidLogConfig_Decoder;
  enum : int32_t {
    kLogIdsFieldNumber = 1,
    kMinPrioFieldNumber = 3,
    kFilterTagsFieldNumber = 4,
  };
  void add_log_ids(::perfetto::protos::pbzero::AndroidLogId value) {
    AppendTinyVarInt(1, value);
  }
  void set_min_prio(::perfetto::protos::pbzero::AndroidLogPriority value) {
    AppendTinyVarInt(3, value);
  }
  void add_filter_tags(const std::string& value) {
    AppendBytes(4, value.data(), value.size());
  }
  void add_filter_tags(const char* data, size_t size) {
    AppendBytes(4, data, size);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/config/android/packages_list_config.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_ANDROID_PACKAGES_LIST_CONFIG_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_ANDROID_PACKAGES_LIST_CONFIG_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class PackagesListConfig_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  PackagesListConfig_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit PackagesListConfig_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit PackagesListConfig_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_package_name_filter() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstChars> package_name_filter() const { return GetRepeated<::protozero::ConstChars>(1); }
};

class PackagesListConfig : public ::protozero::Message {
 public:
  using Decoder = PackagesListConfig_Decoder;
  enum : int32_t {
    kPackageNameFilterFieldNumber = 1,
  };
  void add_package_name_filter(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void add_package_name_filter(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/config/ftrace/ftrace_config.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_FTRACE_FTRACE_CONFIG_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_FTRACE_FTRACE_CONFIG_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class FtraceConfig_CompactSchedConfig;

class FtraceConfig_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/12, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  FtraceConfig_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit FtraceConfig_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit FtraceConfig_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_ftrace_events() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstChars> ftrace_events() const { return GetRepeated<::protozero::ConstChars>(1); }
  bool has_atrace_categories() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstChars> atrace_categories() const { return GetRepeated<::protozero::ConstChars>(2); }
  bool has_atrace_apps() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstChars> atrace_apps() const { return GetRepeated<::protozero::ConstChars>(3); }
  bool has_buffer_size_kb() const { return at<10>().valid(); }
  uint32_t buffer_size_kb() const { return at<10>().as_uint32(); }
  bool has_drain_period_ms() const { return at<11>().valid(); }
  uint32_t drain_period_ms() const { return at<11>().as_uint32(); }
  bool has_compact_sched() const { return at<12>().valid(); }
  ::protozero::ConstBytes compact_sched() const { return at<12>().as_bytes(); }
};

class FtraceConfig : public ::protozero::Message {
 public:
  using Decoder = FtraceConfig_Decoder;
  enum : int32_t {
    kFtraceEventsFieldNumber = 1,
    kAtraceCategoriesFieldNumber = 2,
    kAtraceAppsFieldNumber = 3,
    kBufferSizeKbFieldNumber = 10,
    kDrainPeriodMsFieldNumber = 11,
    kCompactSchedFieldNumber = 12,
  };
  using CompactSchedConfig = ::perfetto::protos::pbzero::FtraceConfig_CompactSchedConfig;
  void add_ftrace_events(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void add_ftrace_events(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void add_atrace_categories(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void add_atrace_categories(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
  void add_atrace_apps(const std::string& value) {
    AppendBytes(3, value.data(), value.size());
  }
  void add_atrace_apps(const char* data, size_t size) {
    AppendBytes(3, data, size);
  }
  void set_buffer_size_kb(uint32_t value) {
    AppendVarInt(10, value);
  }
  void set_drain_period_ms(uint32_t value) {
    AppendVarInt(11, value);
  }
  template <typename T = FtraceConfig_CompactSchedConfig> T* set_compact_sched() {
    return BeginNestedMessage<T>(12);
  }

};

class FtraceConfig_CompactSchedConfig_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  FtraceConfig_CompactSchedConfig_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit FtraceConfig_CompactSchedConfig_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit FtraceConfig_CompactSchedConfig_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_enabled() const { return at<1>().valid(); }
  bool enabled() const { return at<1>().as_bool(); }
};

class FtraceConfig_CompactSchedConfig : public ::protozero::Message {
 public:
  using Decoder = FtraceConfig_CompactSchedConfig_Decoder;
  enum : int32_t {
    kEnabledFieldNumber = 1,
  };
  void set_enabled(bool value) {
    AppendTinyVarInt(1, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/config/gpu/gpu_counter_config.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_GPU_GPU_COUNTER_CONFIG_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_GPU_GPU_COUNTER_CONFIG_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class GpuCounterConfig_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  GpuCounterConfig_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit GpuCounterConfig_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit GpuCounterConfig_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_counter_period_ns() const { return at<1>().valid(); }
  uint64_t counter_period_ns() const { return at<1>().as_uint64(); }
  bool has_counter_ids() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<uint32_t> counter_ids() const { return GetRepeated<uint32_t>(2); }
  bool has_instrumented_sampling() const { return at<3>().valid(); }
  bool instrumented_sampling() const { return at<3>().as_bool(); }
  bool has_fix_gpu_clock() const { return at<4>().valid(); }
  bool fix_gpu_clock() const { return at<4>().as_bool(); }
};

class GpuCounterConfig : public ::protozero::Message {
 public:
  using Decoder = GpuCounterConfig_Decoder;
  enum : int32_t {
    kCounterPeriodNsFieldNumber = 1,
    kCounterIdsFieldNumber = 2,
    kInstrumentedSamplingFieldNumber = 3,
    kFixGpuClockFieldNumber = 4,
  };
  void set_counter_period_ns(uint64_t value) {
    AppendVarInt(1, value);
  }
  void add_counter_ids(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_instrumented_sampling(bool value) {
    AppendTinyVarInt(3, value);
  }
  void set_fix_gpu_clock(bool value) {
    AppendTinyVarInt(4, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/config/inode_file/inode_file_config.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_INODE_FILE_INODE_FILE_CONFIG_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_INODE_FILE_INODE_FILE_CONFIG_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class InodeFileConfig_MountPointMappingEntry;

class InodeFileConfig_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  InodeFileConfig_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit InodeFileConfig_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit InodeFileConfig_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_scan_interval_ms() const { return at<1>().valid(); }
  uint32_t scan_interval_ms() const { return at<1>().as_uint32(); }
  bool has_scan_delay_ms() const { return at<2>().valid(); }
  uint32_t scan_delay_ms() const { return at<2>().as_uint32(); }
  bool has_scan_batch_size() const { return at<3>().valid(); }
  uint32_t scan_batch_size() const { return at<3>().as_uint32(); }
  bool has_do_not_scan() const { return at<4>().valid(); }
  bool do_not_scan() const { return at<4>().as_bool(); }
  bool has_scan_mount_points() const { return at<5>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstChars> scan_mount_points() const { return GetRepeated<::protozero::ConstChars>(5); }
  bool has_mount_point_mapping() const { return at<6>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> mount_point_mapping() const { return GetRepeated<::protozero::ConstBytes>(6); }
};

class InodeFileConfig : public ::protozero::Message {
 public:
  using Decoder = InodeFileConfig_Decoder;
  enum : int32_t {
    kScanIntervalMsFieldNumber = 1,
    kScanDelayMsFieldNumber = 2,
    kScanBatchSizeFieldNumber = 3,
    kDoNotScanFieldNumber = 4,
    kScanMountPointsFieldNumber = 5,
    kMountPointMappingFieldNumber = 6,
  };
  using MountPointMappingEntry = ::perfetto::protos::pbzero::InodeFileConfig_MountPointMappingEntry;
  void set_scan_interval_ms(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_scan_delay_ms(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_scan_batch_size(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_do_not_scan(bool value) {
    AppendTinyVarInt(4, value);
  }
  void add_scan_mount_points(const std::string& value) {
    AppendBytes(5, value.data(), value.size());
  }
  void add_scan_mount_points(const char* data, size_t size) {
    AppendBytes(5, data, size);
  }
  template <typename T = InodeFileConfig_MountPointMappingEntry> T* add_mount_point_mapping() {
    return BeginNestedMessage<T>(6);
  }

};

class InodeFileConfig_MountPointMappingEntry_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  InodeFileConfig_MountPointMappingEntry_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit InodeFileConfig_MountPointMappingEntry_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit InodeFileConfig_MountPointMappingEntry_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_mountpoint() const { return at<1>().valid(); }
  ::protozero::ConstChars mountpoint() const { return at<1>().as_string(); }
  bool has_scan_roots() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstChars> scan_roots() const { return GetRepeated<::protozero::ConstChars>(2); }
};

class InodeFileConfig_MountPointMappingEntry : public ::protozero::Message {
 public:
  using Decoder = InodeFileConfig_MountPointMappingEntry_Decoder;
  enum : int32_t {
    kMountpointFieldNumber = 1,
    kScanRootsFieldNumber = 2,
  };
  void set_mountpoint(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_mountpoint(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void add_scan_roots(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void add_scan_roots(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/config/power/android_power_config.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_POWER_ANDROID_POWER_CONFIG_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_POWER_ANDROID_POWER_CONFIG_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

enum AndroidPowerConfig_BatteryCounters : int32_t;

enum AndroidPowerConfig_BatteryCounters : int32_t {
  AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_UNSPECIFIED = 0,
  AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_CHARGE = 1,
  AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_CAPACITY_PERCENT = 2,
  AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_CURRENT = 3,
  AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_CURRENT_AVG = 4,
};

const AndroidPowerConfig_BatteryCounters AndroidPowerConfig_BatteryCounters_MIN = AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_UNSPECIFIED;
const AndroidPowerConfig_BatteryCounters AndroidPowerConfig_BatteryCounters_MAX = AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_CURRENT_AVG;

class AndroidPowerConfig_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  AndroidPowerConfig_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit AndroidPowerConfig_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit AndroidPowerConfig_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_battery_poll_ms() const { return at<1>().valid(); }
  uint32_t battery_poll_ms() const { return at<1>().as_uint32(); }
  bool has_battery_counters() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<int32_t> battery_counters() const { return GetRepeated<int32_t>(2); }
  bool has_collect_power_rails() const { return at<3>().valid(); }
  bool collect_power_rails() const { return at<3>().as_bool(); }
};

class AndroidPowerConfig : public ::protozero::Message {
 public:
  using Decoder = AndroidPowerConfig_Decoder;
  enum : int32_t {
    kBatteryPollMsFieldNumber = 1,
    kBatteryCountersFieldNumber = 2,
    kCollectPowerRailsFieldNumber = 3,
  };
  using BatteryCounters = ::perfetto::protos::pbzero::AndroidPowerConfig_BatteryCounters;
  static const BatteryCounters BATTERY_COUNTER_UNSPECIFIED = AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_UNSPECIFIED;
  static const BatteryCounters BATTERY_COUNTER_CHARGE = AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_CHARGE;
  static const BatteryCounters BATTERY_COUNTER_CAPACITY_PERCENT = AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_CAPACITY_PERCENT;
  static const BatteryCounters BATTERY_COUNTER_CURRENT = AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_CURRENT;
  static const BatteryCounters BATTERY_COUNTER_CURRENT_AVG = AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_CURRENT_AVG;
  void set_battery_poll_ms(uint32_t value) {
    AppendVarInt(1, value);
  }
  void add_battery_counters(::perfetto::protos::pbzero::AndroidPowerConfig_BatteryCounters value) {
    AppendTinyVarInt(2, value);
  }
  void set_collect_power_rails(bool value) {
    AppendTinyVarInt(3, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/config/process_stats/process_stats_config.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_PROCESS_STATS_PROCESS_STATS_CONFIG_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_PROCESS_STATS_PROCESS_STATS_CONFIG_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

enum ProcessStatsConfig_Quirks : int32_t;

enum ProcessStatsConfig_Quirks : int32_t {
  ProcessStatsConfig_Quirks_QUIRKS_UNSPECIFIED = 0,
  ProcessStatsConfig_Quirks_DISABLE_INITIAL_DUMP = 1,
  ProcessStatsConfig_Quirks_DISABLE_ON_DEMAND = 2,
};

const ProcessStatsConfig_Quirks ProcessStatsConfig_Quirks_MIN = ProcessStatsConfig_Quirks_QUIRKS_UNSPECIFIED;
const ProcessStatsConfig_Quirks ProcessStatsConfig_Quirks_MAX = ProcessStatsConfig_Quirks_DISABLE_ON_DEMAND;

class ProcessStatsConfig_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  ProcessStatsConfig_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ProcessStatsConfig_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ProcessStatsConfig_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_quirks() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<int32_t> quirks() const { return GetRepeated<int32_t>(1); }
  bool has_scan_all_processes_on_start() const { return at<2>().valid(); }
  bool scan_all_processes_on_start() const { return at<2>().as_bool(); }
  bool has_record_thread_names() const { return at<3>().valid(); }
  bool record_thread_names() const { return at<3>().as_bool(); }
  bool has_proc_stats_poll_ms() const { return at<4>().valid(); }
  uint32_t proc_stats_poll_ms() const { return at<4>().as_uint32(); }
  bool has_proc_stats_cache_ttl_ms() const { return at<6>().valid(); }
  uint32_t proc_stats_cache_ttl_ms() const { return at<6>().as_uint32(); }
};

class ProcessStatsConfig : public ::protozero::Message {
 public:
  using Decoder = ProcessStatsConfig_Decoder;
  enum : int32_t {
    kQuirksFieldNumber = 1,
    kScanAllProcessesOnStartFieldNumber = 2,
    kRecordThreadNamesFieldNumber = 3,
    kProcStatsPollMsFieldNumber = 4,
    kProcStatsCacheTtlMsFieldNumber = 6,
  };
  using Quirks = ::perfetto::protos::pbzero::ProcessStatsConfig_Quirks;
  static const Quirks QUIRKS_UNSPECIFIED = ProcessStatsConfig_Quirks_QUIRKS_UNSPECIFIED;
  static const Quirks DISABLE_INITIAL_DUMP = ProcessStatsConfig_Quirks_DISABLE_INITIAL_DUMP;
  static const Quirks DISABLE_ON_DEMAND = ProcessStatsConfig_Quirks_DISABLE_ON_DEMAND;
  void add_quirks(::perfetto::protos::pbzero::ProcessStatsConfig_Quirks value) {
    AppendTinyVarInt(1, value);
  }
  void set_scan_all_processes_on_start(bool value) {
    AppendTinyVarInt(2, value);
  }
  void set_record_thread_names(bool value) {
    AppendTinyVarInt(3, value);
  }
  void set_proc_stats_poll_ms(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_proc_stats_cache_ttl_ms(uint32_t value) {
    AppendVarInt(6, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/config/profiling/heapprofd_config.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_PROFILING_HEAPPROFD_CONFIG_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_PROFILING_HEAPPROFD_CONFIG_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class HeapprofdConfig_ContinuousDumpConfig;

class HeapprofdConfig_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/14, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  HeapprofdConfig_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit HeapprofdConfig_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit HeapprofdConfig_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_sampling_interval_bytes() const { return at<1>().valid(); }
  uint64_t sampling_interval_bytes() const { return at<1>().as_uint64(); }
  bool has_process_cmdline() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstChars> process_cmdline() const { return GetRepeated<::protozero::ConstChars>(2); }
  bool has_pid() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator<uint64_t> pid() const { return GetRepeated<uint64_t>(4); }
  bool has_all() const { return at<5>().valid(); }
  bool all() const { return at<5>().as_bool(); }
  bool has_skip_symbol_prefix() const { return at<7>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstChars> skip_symbol_prefix() const { return GetRepeated<::protozero::ConstChars>(7); }
  bool has_continuous_dump_config() const { return at<6>().valid(); }
  ::protozero::ConstBytes continuous_dump_config() const { return at<6>().as_bytes(); }
  bool has_shmem_size_bytes() const { return at<8>().valid(); }
  uint64_t shmem_size_bytes() const { return at<8>().as_uint64(); }
  bool has_block_client() const { return at<9>().valid(); }
  bool block_client() const { return at<9>().as_bool(); }
  bool has_block_client_timeout_us() const { return at<14>().valid(); }
  uint32_t block_client_timeout_us() const { return at<14>().as_uint32(); }
  bool has_no_startup() const { return at<10>().valid(); }
  bool no_startup() const { return at<10>().as_bool(); }
  bool has_no_running() const { return at<11>().valid(); }
  bool no_running() const { return at<11>().as_bool(); }
  bool has_idle_allocations() const { return at<12>().valid(); }
  bool idle_allocations() const { return at<12>().as_bool(); }
  bool has_dump_at_max() const { return at<13>().valid(); }
  bool dump_at_max() const { return at<13>().as_bool(); }
};

class HeapprofdConfig : public ::protozero::Message {
 public:
  using Decoder = HeapprofdConfig_Decoder;
  enum : int32_t {
    kSamplingIntervalBytesFieldNumber = 1,
    kProcessCmdlineFieldNumber = 2,
    kPidFieldNumber = 4,
    kAllFieldNumber = 5,
    kSkipSymbolPrefixFieldNumber = 7,
    kContinuousDumpConfigFieldNumber = 6,
    kShmemSizeBytesFieldNumber = 8,
    kBlockClientFieldNumber = 9,
    kBlockClientTimeoutUsFieldNumber = 14,
    kNoStartupFieldNumber = 10,
    kNoRunningFieldNumber = 11,
    kIdleAllocationsFieldNumber = 12,
    kDumpAtMaxFieldNumber = 13,
  };
  using ContinuousDumpConfig = ::perfetto::protos::pbzero::HeapprofdConfig_ContinuousDumpConfig;
  void set_sampling_interval_bytes(uint64_t value) {
    AppendVarInt(1, value);
  }
  void add_process_cmdline(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void add_process_cmdline(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
  void add_pid(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_all(bool value) {
    AppendTinyVarInt(5, value);
  }
  void add_skip_symbol_prefix(const std::string& value) {
    AppendBytes(7, value.data(), value.size());
  }
  void add_skip_symbol_prefix(const char* data, size_t size) {
    AppendBytes(7, data, size);
  }
  template <typename T = HeapprofdConfig_ContinuousDumpConfig> T* set_continuous_dump_config() {
    return BeginNestedMessage<T>(6);
  }

  void set_shmem_size_bytes(uint64_t value) {
    AppendVarInt(8, value);
  }
  void set_block_client(bool value) {
    AppendTinyVarInt(9, value);
  }
  void set_block_client_timeout_us(uint32_t value) {
    AppendVarInt(14, value);
  }
  void set_no_startup(bool value) {
    AppendTinyVarInt(10, value);
  }
  void set_no_running(bool value) {
    AppendTinyVarInt(11, value);
  }
  void set_idle_allocations(bool value) {
    AppendTinyVarInt(12, value);
  }
  void set_dump_at_max(bool value) {
    AppendTinyVarInt(13, value);
  }
};

class HeapprofdConfig_ContinuousDumpConfig_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  HeapprofdConfig_ContinuousDumpConfig_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit HeapprofdConfig_ContinuousDumpConfig_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit HeapprofdConfig_ContinuousDumpConfig_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dump_phase_ms() const { return at<5>().valid(); }
  uint32_t dump_phase_ms() const { return at<5>().as_uint32(); }
  bool has_dump_interval_ms() const { return at<6>().valid(); }
  uint32_t dump_interval_ms() const { return at<6>().as_uint32(); }
};

class HeapprofdConfig_ContinuousDumpConfig : public ::protozero::Message {
 public:
  using Decoder = HeapprofdConfig_ContinuousDumpConfig_Decoder;
  enum : int32_t {
    kDumpPhaseMsFieldNumber = 5,
    kDumpIntervalMsFieldNumber = 6,
  };
  void set_dump_phase_ms(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_dump_interval_ms(uint32_t value) {
    AppendVarInt(6, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/config/profiling/java_hprof_config.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_PROFILING_JAVA_HPROF_CONFIG_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_PROFILING_JAVA_HPROF_CONFIG_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class JavaHprofConfig_ContinuousDumpConfig;

class JavaHprofConfig_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  JavaHprofConfig_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit JavaHprofConfig_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit JavaHprofConfig_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_process_cmdline() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstChars> process_cmdline() const { return GetRepeated<::protozero::ConstChars>(1); }
  bool has_pid() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<uint64_t> pid() const { return GetRepeated<uint64_t>(2); }
  bool has_continuous_dump_config() const { return at<3>().valid(); }
  ::protozero::ConstBytes continuous_dump_config() const { return at<3>().as_bytes(); }
};

class JavaHprofConfig : public ::protozero::Message {
 public:
  using Decoder = JavaHprofConfig_Decoder;
  enum : int32_t {
    kProcessCmdlineFieldNumber = 1,
    kPidFieldNumber = 2,
    kContinuousDumpConfigFieldNumber = 3,
  };
  using ContinuousDumpConfig = ::perfetto::protos::pbzero::JavaHprofConfig_ContinuousDumpConfig;
  void add_process_cmdline(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void add_process_cmdline(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void add_pid(uint64_t value) {
    AppendVarInt(2, value);
  }
  template <typename T = JavaHprofConfig_ContinuousDumpConfig> T* set_continuous_dump_config() {
    return BeginNestedMessage<T>(3);
  }

};

class JavaHprofConfig_ContinuousDumpConfig_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  JavaHprofConfig_ContinuousDumpConfig_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit JavaHprofConfig_ContinuousDumpConfig_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit JavaHprofConfig_ContinuousDumpConfig_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dump_phase_ms() const { return at<1>().valid(); }
  uint32_t dump_phase_ms() const { return at<1>().as_uint32(); }
  bool has_dump_interval_ms() const { return at<2>().valid(); }
  uint32_t dump_interval_ms() const { return at<2>().as_uint32(); }
};

class JavaHprofConfig_ContinuousDumpConfig : public ::protozero::Message {
 public:
  using Decoder = JavaHprofConfig_ContinuousDumpConfig_Decoder;
  enum : int32_t {
    kDumpPhaseMsFieldNumber = 1,
    kDumpIntervalMsFieldNumber = 2,
  };
  void set_dump_phase_ms(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_dump_interval_ms(uint32_t value) {
    AppendVarInt(2, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/config/profiling/perf_event_config.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_PROFILING_PERF_EVENT_CONFIG_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_PROFILING_PERF_EVENT_CONFIG_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class PerfEventConfig_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  PerfEventConfig_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit PerfEventConfig_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit PerfEventConfig_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_tid() const { return at<1>().valid(); }
  int32_t tid() const { return at<1>().as_int32(); }
};

class PerfEventConfig : public ::protozero::Message {
 public:
  using Decoder = PerfEventConfig_Decoder;
  enum : int32_t {
    kTidFieldNumber = 1,
  };
  void set_tid(int32_t value) {
    AppendVarInt(1, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/config/sys_stats/sys_stats_config.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_SYS_STATS_SYS_STATS_CONFIG_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_SYS_STATS_SYS_STATS_CONFIG_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

enum MeminfoCounters : int32_t;
enum SysStatsConfig_StatCounters : int32_t;
enum VmstatCounters : int32_t;

enum SysStatsConfig_StatCounters : int32_t {
  SysStatsConfig_StatCounters_STAT_UNSPECIFIED = 0,
  SysStatsConfig_StatCounters_STAT_CPU_TIMES = 1,
  SysStatsConfig_StatCounters_STAT_IRQ_COUNTS = 2,
  SysStatsConfig_StatCounters_STAT_SOFTIRQ_COUNTS = 3,
  SysStatsConfig_StatCounters_STAT_FORK_COUNT = 4,
};

const SysStatsConfig_StatCounters SysStatsConfig_StatCounters_MIN = SysStatsConfig_StatCounters_STAT_UNSPECIFIED;
const SysStatsConfig_StatCounters SysStatsConfig_StatCounters_MAX = SysStatsConfig_StatCounters_STAT_FORK_COUNT;

class SysStatsConfig_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  SysStatsConfig_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SysStatsConfig_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SysStatsConfig_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_meminfo_period_ms() const { return at<1>().valid(); }
  uint32_t meminfo_period_ms() const { return at<1>().as_uint32(); }
  bool has_meminfo_counters() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<int32_t> meminfo_counters() const { return GetRepeated<int32_t>(2); }
  bool has_vmstat_period_ms() const { return at<3>().valid(); }
  uint32_t vmstat_period_ms() const { return at<3>().as_uint32(); }
  bool has_vmstat_counters() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator<int32_t> vmstat_counters() const { return GetRepeated<int32_t>(4); }
  bool has_stat_period_ms() const { return at<5>().valid(); }
  uint32_t stat_period_ms() const { return at<5>().as_uint32(); }
  bool has_stat_counters() const { return at<6>().valid(); }
  ::protozero::RepeatedFieldIterator<int32_t> stat_counters() const { return GetRepeated<int32_t>(6); }
};

class SysStatsConfig : public ::protozero::Message {
 public:
  using Decoder = SysStatsConfig_Decoder;
  enum : int32_t {
    kMeminfoPeriodMsFieldNumber = 1,
    kMeminfoCountersFieldNumber = 2,
    kVmstatPeriodMsFieldNumber = 3,
    kVmstatCountersFieldNumber = 4,
    kStatPeriodMsFieldNumber = 5,
    kStatCountersFieldNumber = 6,
  };
  using StatCounters = ::perfetto::protos::pbzero::SysStatsConfig_StatCounters;
  static const StatCounters STAT_UNSPECIFIED = SysStatsConfig_StatCounters_STAT_UNSPECIFIED;
  static const StatCounters STAT_CPU_TIMES = SysStatsConfig_StatCounters_STAT_CPU_TIMES;
  static const StatCounters STAT_IRQ_COUNTS = SysStatsConfig_StatCounters_STAT_IRQ_COUNTS;
  static const StatCounters STAT_SOFTIRQ_COUNTS = SysStatsConfig_StatCounters_STAT_SOFTIRQ_COUNTS;
  static const StatCounters STAT_FORK_COUNT = SysStatsConfig_StatCounters_STAT_FORK_COUNT;
  void set_meminfo_period_ms(uint32_t value) {
    AppendVarInt(1, value);
  }
  void add_meminfo_counters(::perfetto::protos::pbzero::MeminfoCounters value) {
    AppendTinyVarInt(2, value);
  }
  void set_vmstat_period_ms(uint32_t value) {
    AppendVarInt(3, value);
  }
  void add_vmstat_counters(::perfetto::protos::pbzero::VmstatCounters value) {
    AppendTinyVarInt(4, value);
  }
  void set_stat_period_ms(uint32_t value) {
    AppendVarInt(5, value);
  }
  void add_stat_counters(::perfetto::protos::pbzero::SysStatsConfig_StatCounters value) {
    AppendTinyVarInt(6, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/config/chrome/chrome_config.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_CHROME_CHROME_CONFIG_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_CHROME_CHROME_CONFIG_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class ChromeConfig_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ChromeConfig_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ChromeConfig_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ChromeConfig_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_trace_config() const { return at<1>().valid(); }
  ::protozero::ConstChars trace_config() const { return at<1>().as_string(); }
  bool has_privacy_filtering_enabled() const { return at<2>().valid(); }
  bool privacy_filtering_enabled() const { return at<2>().as_bool(); }
};

class ChromeConfig : public ::protozero::Message {
 public:
  using Decoder = ChromeConfig_Decoder;
  enum : int32_t {
    kTraceConfigFieldNumber = 1,
    kPrivacyFilteringEnabledFieldNumber = 2,
  };
  void set_trace_config(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_trace_config(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_privacy_filtering_enabled(bool value) {
    AppendTinyVarInt(2, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/config/data_source_config.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_DATA_SOURCE_CONFIG_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_DATA_SOURCE_CONFIG_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class AndroidLogConfig;
class AndroidPowerConfig;
class ChromeConfig;
class FtraceConfig;
class GpuCounterConfig;
class HeapprofdConfig;
class InodeFileConfig;
class JavaHprofConfig;
class PackagesListConfig;
class PerfEventConfig;
class ProcessStatsConfig;
class SysStatsConfig;
class TestConfig;

class DataSourceConfig_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/111, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  DataSourceConfig_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit DataSourceConfig_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit DataSourceConfig_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_target_buffer() const { return at<2>().valid(); }
  uint32_t target_buffer() const { return at<2>().as_uint32(); }
  bool has_trace_duration_ms() const { return at<3>().valid(); }
  uint32_t trace_duration_ms() const { return at<3>().as_uint32(); }
  bool has_stop_timeout_ms() const { return at<7>().valid(); }
  uint32_t stop_timeout_ms() const { return at<7>().as_uint32(); }
  bool has_enable_extra_guardrails() const { return at<6>().valid(); }
  bool enable_extra_guardrails() const { return at<6>().as_bool(); }
  bool has_tracing_session_id() const { return at<4>().valid(); }
  uint64_t tracing_session_id() const { return at<4>().as_uint64(); }
  bool has_ftrace_config() const { return at<100>().valid(); }
  ::protozero::ConstBytes ftrace_config() const { return at<100>().as_bytes(); }
  bool has_inode_file_config() const { return at<102>().valid(); }
  ::protozero::ConstBytes inode_file_config() const { return at<102>().as_bytes(); }
  bool has_process_stats_config() const { return at<103>().valid(); }
  ::protozero::ConstBytes process_stats_config() const { return at<103>().as_bytes(); }
  bool has_sys_stats_config() const { return at<104>().valid(); }
  ::protozero::ConstBytes sys_stats_config() const { return at<104>().as_bytes(); }
  bool has_heapprofd_config() const { return at<105>().valid(); }
  ::protozero::ConstBytes heapprofd_config() const { return at<105>().as_bytes(); }
  bool has_java_hprof_config() const { return at<110>().valid(); }
  ::protozero::ConstBytes java_hprof_config() const { return at<110>().as_bytes(); }
  bool has_android_power_config() const { return at<106>().valid(); }
  ::protozero::ConstBytes android_power_config() const { return at<106>().as_bytes(); }
  bool has_android_log_config() const { return at<107>().valid(); }
  ::protozero::ConstBytes android_log_config() const { return at<107>().as_bytes(); }
  bool has_gpu_counter_config() const { return at<108>().valid(); }
  ::protozero::ConstBytes gpu_counter_config() const { return at<108>().as_bytes(); }
  bool has_packages_list_config() const { return at<109>().valid(); }
  ::protozero::ConstBytes packages_list_config() const { return at<109>().as_bytes(); }
  bool has_perf_event_config() const { return at<111>().valid(); }
  ::protozero::ConstBytes perf_event_config() const { return at<111>().as_bytes(); }
  bool has_chrome_config() const { return at<101>().valid(); }
  ::protozero::ConstBytes chrome_config() const { return at<101>().as_bytes(); }
  // field legacy_config omitted because its id is too high
  // field for_testing omitted because its id is too high
};

class DataSourceConfig : public ::protozero::Message {
 public:
  using Decoder = DataSourceConfig_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kTargetBufferFieldNumber = 2,
    kTraceDurationMsFieldNumber = 3,
    kStopTimeoutMsFieldNumber = 7,
    kEnableExtraGuardrailsFieldNumber = 6,
    kTracingSessionIdFieldNumber = 4,
    kFtraceConfigFieldNumber = 100,
    kInodeFileConfigFieldNumber = 102,
    kProcessStatsConfigFieldNumber = 103,
    kSysStatsConfigFieldNumber = 104,
    kHeapprofdConfigFieldNumber = 105,
    kJavaHprofConfigFieldNumber = 110,
    kAndroidPowerConfigFieldNumber = 106,
    kAndroidLogConfigFieldNumber = 107,
    kGpuCounterConfigFieldNumber = 108,
    kPackagesListConfigFieldNumber = 109,
    kPerfEventConfigFieldNumber = 111,
    kChromeConfigFieldNumber = 101,
    kLegacyConfigFieldNumber = 1000,
    kForTestingFieldNumber = 1001,
  };
  void set_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_target_buffer(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_trace_duration_ms(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_stop_timeout_ms(uint32_t value) {
    AppendVarInt(7, value);
  }
  void set_enable_extra_guardrails(bool value) {
    AppendTinyVarInt(6, value);
  }
  void set_tracing_session_id(uint64_t value) {
    AppendVarInt(4, value);
  }
  template <typename T = FtraceConfig> T* set_ftrace_config() {
    return BeginNestedMessage<T>(100);
  }

  void set_ftrace_config_raw(const std::string& raw) {
    return AppendBytes(100, raw.data(), raw.size());
  }

  template <typename T = InodeFileConfig> T* set_inode_file_config() {
    return BeginNestedMessage<T>(102);
  }

  void set_inode_file_config_raw(const std::string& raw) {
    return AppendBytes(102, raw.data(), raw.size());
  }

  template <typename T = ProcessStatsConfig> T* set_process_stats_config() {
    return BeginNestedMessage<T>(103);
  }

  void set_process_stats_config_raw(const std::string& raw) {
    return AppendBytes(103, raw.data(), raw.size());
  }

  template <typename T = SysStatsConfig> T* set_sys_stats_config() {
    return BeginNestedMessage<T>(104);
  }

  void set_sys_stats_config_raw(const std::string& raw) {
    return AppendBytes(104, raw.data(), raw.size());
  }

  template <typename T = HeapprofdConfig> T* set_heapprofd_config() {
    return BeginNestedMessage<T>(105);
  }

  void set_heapprofd_config_raw(const std::string& raw) {
    return AppendBytes(105, raw.data(), raw.size());
  }

  template <typename T = JavaHprofConfig> T* set_java_hprof_config() {
    return BeginNestedMessage<T>(110);
  }

  void set_java_hprof_config_raw(const std::string& raw) {
    return AppendBytes(110, raw.data(), raw.size());
  }

  template <typename T = AndroidPowerConfig> T* set_android_power_config() {
    return BeginNestedMessage<T>(106);
  }

  void set_android_power_config_raw(const std::string& raw) {
    return AppendBytes(106, raw.data(), raw.size());
  }

  template <typename T = AndroidLogConfig> T* set_android_log_config() {
    return BeginNestedMessage<T>(107);
  }

  void set_android_log_config_raw(const std::string& raw) {
    return AppendBytes(107, raw.data(), raw.size());
  }

  template <typename T = GpuCounterConfig> T* set_gpu_counter_config() {
    return BeginNestedMessage<T>(108);
  }

  void set_gpu_counter_config_raw(const std::string& raw) {
    return AppendBytes(108, raw.data(), raw.size());
  }

  template <typename T = PackagesListConfig> T* set_packages_list_config() {
    return BeginNestedMessage<T>(109);
  }

  void set_packages_list_config_raw(const std::string& raw) {
    return AppendBytes(109, raw.data(), raw.size());
  }

  template <typename T = PerfEventConfig> T* set_perf_event_config() {
    return BeginNestedMessage<T>(111);
  }

  void set_perf_event_config_raw(const std::string& raw) {
    return AppendBytes(111, raw.data(), raw.size());
  }

  template <typename T = ChromeConfig> T* set_chrome_config() {
    return BeginNestedMessage<T>(101);
  }

  void set_legacy_config(const std::string& value) {
    AppendBytes(1000, value.data(), value.size());
  }
  void set_legacy_config(const char* data, size_t size) {
    AppendBytes(1000, data, size);
  }
  template <typename T = TestConfig> T* set_for_testing() {
    return BeginNestedMessage<T>(1001);
  }

};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/config/test_config.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_TEST_CONFIG_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_TEST_CONFIG_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class TestConfig_DummyFields;

class TestConfig_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TestConfig_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TestConfig_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TestConfig_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_message_count() const { return at<1>().valid(); }
  uint32_t message_count() const { return at<1>().as_uint32(); }
  bool has_max_messages_per_second() const { return at<2>().valid(); }
  uint32_t max_messages_per_second() const { return at<2>().as_uint32(); }
  bool has_seed() const { return at<3>().valid(); }
  uint32_t seed() const { return at<3>().as_uint32(); }
  bool has_message_size() const { return at<4>().valid(); }
  uint32_t message_size() const { return at<4>().as_uint32(); }
  bool has_send_batch_on_register() const { return at<5>().valid(); }
  bool send_batch_on_register() const { return at<5>().as_bool(); }
  bool has_dummy_fields() const { return at<6>().valid(); }
  ::protozero::ConstBytes dummy_fields() const { return at<6>().as_bytes(); }
};

class TestConfig : public ::protozero::Message {
 public:
  using Decoder = TestConfig_Decoder;
  enum : int32_t {
    kMessageCountFieldNumber = 1,
    kMaxMessagesPerSecondFieldNumber = 2,
    kSeedFieldNumber = 3,
    kMessageSizeFieldNumber = 4,
    kSendBatchOnRegisterFieldNumber = 5,
    kDummyFieldsFieldNumber = 6,
  };
  using DummyFields = ::perfetto::protos::pbzero::TestConfig_DummyFields;
  void set_message_count(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_max_messages_per_second(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_seed(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_message_size(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_send_batch_on_register(bool value) {
    AppendTinyVarInt(5, value);
  }
  template <typename T = TestConfig_DummyFields> T* set_dummy_fields() {
    return BeginNestedMessage<T>(6);
  }

};

class TestConfig_DummyFields_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/14, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TestConfig_DummyFields_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TestConfig_DummyFields_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TestConfig_DummyFields_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_field_uint32() const { return at<1>().valid(); }
  uint32_t field_uint32() const { return at<1>().as_uint32(); }
  bool has_field_int32() const { return at<2>().valid(); }
  int32_t field_int32() const { return at<2>().as_int32(); }
  bool has_field_uint64() const { return at<3>().valid(); }
  uint64_t field_uint64() const { return at<3>().as_uint64(); }
  bool has_field_int64() const { return at<4>().valid(); }
  int64_t field_int64() const { return at<4>().as_int64(); }
  bool has_field_fixed64() const { return at<5>().valid(); }
  uint64_t field_fixed64() const { return at<5>().as_uint64(); }
  bool has_field_sfixed64() const { return at<6>().valid(); }
  int64_t field_sfixed64() const { return at<6>().as_int64(); }
  bool has_field_fixed32() const { return at<7>().valid(); }
  uint32_t field_fixed32() const { return at<7>().as_uint32(); }
  bool has_field_sfixed32() const { return at<8>().valid(); }
  int32_t field_sfixed32() const { return at<8>().as_int32(); }
  bool has_field_double() const { return at<9>().valid(); }
  double field_double() const { return at<9>().as_double(); }
  bool has_field_float() const { return at<10>().valid(); }
  float field_float() const { return at<10>().as_float(); }
  bool has_field_sint64() const { return at<11>().valid(); }
  int64_t field_sint64() const { return at<11>().as_int64(); }
  bool has_field_sint32() const { return at<12>().valid(); }
  int32_t field_sint32() const { return at<12>().as_int32(); }
  bool has_field_string() const { return at<13>().valid(); }
  ::protozero::ConstChars field_string() const { return at<13>().as_string(); }
  bool has_field_bytes() const { return at<14>().valid(); }
  ::protozero::ConstBytes field_bytes() const { return at<14>().as_bytes(); }
};

class TestConfig_DummyFields : public ::protozero::Message {
 public:
  using Decoder = TestConfig_DummyFields_Decoder;
  enum : int32_t {
    kFieldUint32FieldNumber = 1,
    kFieldInt32FieldNumber = 2,
    kFieldUint64FieldNumber = 3,
    kFieldInt64FieldNumber = 4,
    kFieldFixed64FieldNumber = 5,
    kFieldSfixed64FieldNumber = 6,
    kFieldFixed32FieldNumber = 7,
    kFieldSfixed32FieldNumber = 8,
    kFieldDoubleFieldNumber = 9,
    kFieldFloatFieldNumber = 10,
    kFieldSint64FieldNumber = 11,
    kFieldSint32FieldNumber = 12,
    kFieldStringFieldNumber = 13,
    kFieldBytesFieldNumber = 14,
  };
  void set_field_uint32(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_field_int32(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_field_uint64(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_field_int64(int64_t value) {
    AppendVarInt(4, value);
  }
  void set_field_fixed64(uint64_t value) {
    AppendFixed(5, value);
  }
  void set_field_sfixed64(int64_t value) {
    AppendFixed(6, value);
  }
  void set_field_fixed32(uint32_t value) {
    AppendFixed(7, value);
  }
  void set_field_sfixed32(int32_t value) {
    AppendFixed(8, value);
  }
  void set_field_double(double value) {
    AppendFixed(9, value);
  }
  void set_field_float(float value) {
    AppendFixed(10, value);
  }
  void set_field_sint64(int64_t value) {
    AppendSignedVarInt(11, value);
  }
  void set_field_sint32(int32_t value) {
    AppendSignedVarInt(12, value);
  }
  void set_field_string(const std::string& value) {
    AppendBytes(13, value.data(), value.size());
  }
  void set_field_string(const char* data, size_t size) {
    AppendBytes(13, data, size);
  }
  void set_field_bytes(const std::string& value) {
    AppendBytes(14, value.data(), value.size());
  }
  void set_field_bytes(const uint8_t* data, size_t size) {
    AppendBytes(14, data, size);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/config/trace_config.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_TRACE_CONFIG_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_TRACE_CONFIG_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class DataSourceConfig;
class TraceConfig_BufferConfig;
class TraceConfig_BuiltinDataSource;
class TraceConfig_DataSource;
class TraceConfig_GuardrailOverrides;
class TraceConfig_IncidentReportConfig;
class TraceConfig_IncrementalStateConfig;
class TraceConfig_ProducerConfig;
class TraceConfig_StatsdMetadata;
class TraceConfig_TriggerConfig;
class TraceConfig_TriggerConfig_Trigger;
enum TraceConfig_BufferConfig_FillPolicy : int32_t;
enum TraceConfig_CompressionType : int32_t;
enum TraceConfig_LockdownModeOperation : int32_t;
enum TraceConfig_TriggerConfig_TriggerMode : int32_t;

enum TraceConfig_LockdownModeOperation : int32_t {
  TraceConfig_LockdownModeOperation_LOCKDOWN_UNCHANGED = 0,
  TraceConfig_LockdownModeOperation_LOCKDOWN_CLEAR = 1,
  TraceConfig_LockdownModeOperation_LOCKDOWN_SET = 2,
};

const TraceConfig_LockdownModeOperation TraceConfig_LockdownModeOperation_MIN = TraceConfig_LockdownModeOperation_LOCKDOWN_UNCHANGED;
const TraceConfig_LockdownModeOperation TraceConfig_LockdownModeOperation_MAX = TraceConfig_LockdownModeOperation_LOCKDOWN_SET;

enum TraceConfig_CompressionType : int32_t {
  TraceConfig_CompressionType_COMPRESSION_TYPE_UNSPECIFIED = 0,
  TraceConfig_CompressionType_COMPRESSION_TYPE_DEFLATE = 1,
};

const TraceConfig_CompressionType TraceConfig_CompressionType_MIN = TraceConfig_CompressionType_COMPRESSION_TYPE_UNSPECIFIED;
const TraceConfig_CompressionType TraceConfig_CompressionType_MAX = TraceConfig_CompressionType_COMPRESSION_TYPE_DEFLATE;

enum TraceConfig_TriggerConfig_TriggerMode : int32_t {
  TraceConfig_TriggerConfig_TriggerMode_UNSPECIFIED = 0,
  TraceConfig_TriggerConfig_TriggerMode_START_TRACING = 1,
  TraceConfig_TriggerConfig_TriggerMode_STOP_TRACING = 2,
};

const TraceConfig_TriggerConfig_TriggerMode TraceConfig_TriggerConfig_TriggerMode_MIN = TraceConfig_TriggerConfig_TriggerMode_UNSPECIFIED;
const TraceConfig_TriggerConfig_TriggerMode TraceConfig_TriggerConfig_TriggerMode_MAX = TraceConfig_TriggerConfig_TriggerMode_STOP_TRACING;

enum TraceConfig_BufferConfig_FillPolicy : int32_t {
  TraceConfig_BufferConfig_FillPolicy_UNSPECIFIED = 0,
  TraceConfig_BufferConfig_FillPolicy_RING_BUFFER = 1,
  TraceConfig_BufferConfig_FillPolicy_DISCARD = 2,
};

const TraceConfig_BufferConfig_FillPolicy TraceConfig_BufferConfig_FillPolicy_MIN = TraceConfig_BufferConfig_FillPolicy_UNSPECIFIED;
const TraceConfig_BufferConfig_FillPolicy TraceConfig_BufferConfig_FillPolicy_MAX = TraceConfig_BufferConfig_FillPolicy_DISCARD;

class TraceConfig_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/28, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  TraceConfig_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TraceConfig_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TraceConfig_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_buffers() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> buffers() const { return GetRepeated<::protozero::ConstBytes>(1); }
  bool has_data_sources() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> data_sources() const { return GetRepeated<::protozero::ConstBytes>(2); }
  bool has_builtin_data_sources() const { return at<20>().valid(); }
  ::protozero::ConstBytes builtin_data_sources() const { return at<20>().as_bytes(); }
  bool has_duration_ms() const { return at<3>().valid(); }
  uint32_t duration_ms() const { return at<3>().as_uint32(); }
  bool has_enable_extra_guardrails() const { return at<4>().valid(); }
  bool enable_extra_guardrails() const { return at<4>().as_bool(); }
  bool has_lockdown_mode() const { return at<5>().valid(); }
  int32_t lockdown_mode() const { return at<5>().as_int32(); }
  bool has_producers() const { return at<6>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> producers() const { return GetRepeated<::protozero::ConstBytes>(6); }
  bool has_statsd_metadata() const { return at<7>().valid(); }
  ::protozero::ConstBytes statsd_metadata() const { return at<7>().as_bytes(); }
  bool has_write_into_file() const { return at<8>().valid(); }
  bool write_into_file() const { return at<8>().as_bool(); }
  bool has_file_write_period_ms() const { return at<9>().valid(); }
  uint32_t file_write_period_ms() const { return at<9>().as_uint32(); }
  bool has_max_file_size_bytes() const { return at<10>().valid(); }
  uint64_t max_file_size_bytes() const { return at<10>().as_uint64(); }
  bool has_guardrail_overrides() const { return at<11>().valid(); }
  ::protozero::ConstBytes guardrail_overrides() const { return at<11>().as_bytes(); }
  bool has_deferred_start() const { return at<12>().valid(); }
  bool deferred_start() const { return at<12>().as_bool(); }
  bool has_flush_period_ms() const { return at<13>().valid(); }
  uint32_t flush_period_ms() const { return at<13>().as_uint32(); }
  bool has_flush_timeout_ms() const { return at<14>().valid(); }
  uint32_t flush_timeout_ms() const { return at<14>().as_uint32(); }
  bool has_data_source_stop_timeout_ms() const { return at<23>().valid(); }
  uint32_t data_source_stop_timeout_ms() const { return at<23>().as_uint32(); }
  bool has_notify_traceur() const { return at<16>().valid(); }
  bool notify_traceur() const { return at<16>().as_bool(); }
  bool has_trigger_config() const { return at<17>().valid(); }
  ::protozero::ConstBytes trigger_config() const { return at<17>().as_bytes(); }
  bool has_activate_triggers() const { return at<18>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstChars> activate_triggers() const { return GetRepeated<::protozero::ConstChars>(18); }
  bool has_incremental_state_config() const { return at<21>().valid(); }
  ::protozero::ConstBytes incremental_state_config() const { return at<21>().as_bytes(); }
  bool has_allow_user_build_tracing() const { return at<19>().valid(); }
  bool allow_user_build_tracing() const { return at<19>().as_bool(); }
  bool has_unique_session_name() const { return at<22>().valid(); }
  ::protozero::ConstChars unique_session_name() const { return at<22>().as_string(); }
  bool has_compression_type() const { return at<24>().valid(); }
  int32_t compression_type() const { return at<24>().as_int32(); }
  bool has_incident_report_config() const { return at<25>().valid(); }
  ::protozero::ConstBytes incident_report_config() const { return at<25>().as_bytes(); }
  bool has_trace_uuid_msb() const { return at<27>().valid(); }
  int64_t trace_uuid_msb() const { return at<27>().as_int64(); }
  bool has_trace_uuid_lsb() const { return at<28>().valid(); }
  int64_t trace_uuid_lsb() const { return at<28>().as_int64(); }
};

class TraceConfig : public ::protozero::Message {
 public:
  using Decoder = TraceConfig_Decoder;
  enum : int32_t {
    kBuffersFieldNumber = 1,
    kDataSourcesFieldNumber = 2,
    kBuiltinDataSourcesFieldNumber = 20,
    kDurationMsFieldNumber = 3,
    kEnableExtraGuardrailsFieldNumber = 4,
    kLockdownModeFieldNumber = 5,
    kProducersFieldNumber = 6,
    kStatsdMetadataFieldNumber = 7,
    kWriteIntoFileFieldNumber = 8,
    kFileWritePeriodMsFieldNumber = 9,
    kMaxFileSizeBytesFieldNumber = 10,
    kGuardrailOverridesFieldNumber = 11,
    kDeferredStartFieldNumber = 12,
    kFlushPeriodMsFieldNumber = 13,
    kFlushTimeoutMsFieldNumber = 14,
    kDataSourceStopTimeoutMsFieldNumber = 23,
    kNotifyTraceurFieldNumber = 16,
    kTriggerConfigFieldNumber = 17,
    kActivateTriggersFieldNumber = 18,
    kIncrementalStateConfigFieldNumber = 21,
    kAllowUserBuildTracingFieldNumber = 19,
    kUniqueSessionNameFieldNumber = 22,
    kCompressionTypeFieldNumber = 24,
    kIncidentReportConfigFieldNumber = 25,
    kTraceUuidMsbFieldNumber = 27,
    kTraceUuidLsbFieldNumber = 28,
  };
  using BufferConfig = ::perfetto::protos::pbzero::TraceConfig_BufferConfig;
  using DataSource = ::perfetto::protos::pbzero::TraceConfig_DataSource;
  using BuiltinDataSource = ::perfetto::protos::pbzero::TraceConfig_BuiltinDataSource;
  using ProducerConfig = ::perfetto::protos::pbzero::TraceConfig_ProducerConfig;
  using StatsdMetadata = ::perfetto::protos::pbzero::TraceConfig_StatsdMetadata;
  using GuardrailOverrides = ::perfetto::protos::pbzero::TraceConfig_GuardrailOverrides;
  using TriggerConfig = ::perfetto::protos::pbzero::TraceConfig_TriggerConfig;
  using IncrementalStateConfig = ::perfetto::protos::pbzero::TraceConfig_IncrementalStateConfig;
  using IncidentReportConfig = ::perfetto::protos::pbzero::TraceConfig_IncidentReportConfig;
  using LockdownModeOperation = ::perfetto::protos::pbzero::TraceConfig_LockdownModeOperation;
  using CompressionType = ::perfetto::protos::pbzero::TraceConfig_CompressionType;
  static const LockdownModeOperation LOCKDOWN_UNCHANGED = TraceConfig_LockdownModeOperation_LOCKDOWN_UNCHANGED;
  static const LockdownModeOperation LOCKDOWN_CLEAR = TraceConfig_LockdownModeOperation_LOCKDOWN_CLEAR;
  static const LockdownModeOperation LOCKDOWN_SET = TraceConfig_LockdownModeOperation_LOCKDOWN_SET;
  static const CompressionType COMPRESSION_TYPE_UNSPECIFIED = TraceConfig_CompressionType_COMPRESSION_TYPE_UNSPECIFIED;
  static const CompressionType COMPRESSION_TYPE_DEFLATE = TraceConfig_CompressionType_COMPRESSION_TYPE_DEFLATE;
  template <typename T = TraceConfig_BufferConfig> T* add_buffers() {
    return BeginNestedMessage<T>(1);
  }

  template <typename T = TraceConfig_DataSource> T* add_data_sources() {
    return BeginNestedMessage<T>(2);
  }

  template <typename T = TraceConfig_BuiltinDataSource> T* set_builtin_data_sources() {
    return BeginNestedMessage<T>(20);
  }

  void set_duration_ms(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_enable_extra_guardrails(bool value) {
    AppendTinyVarInt(4, value);
  }
  void set_lockdown_mode(::perfetto::protos::pbzero::TraceConfig_LockdownModeOperation value) {
    AppendTinyVarInt(5, value);
  }
  template <typename T = TraceConfig_ProducerConfig> T* add_producers() {
    return BeginNestedMessage<T>(6);
  }

  template <typename T = TraceConfig_StatsdMetadata> T* set_statsd_metadata() {
    return BeginNestedMessage<T>(7);
  }

  void set_write_into_file(bool value) {
    AppendTinyVarInt(8, value);
  }
  void set_file_write_period_ms(uint32_t value) {
    AppendVarInt(9, value);
  }
  void set_max_file_size_bytes(uint64_t value) {
    AppendVarInt(10, value);
  }
  template <typename T = TraceConfig_GuardrailOverrides> T* set_guardrail_overrides() {
    return BeginNestedMessage<T>(11);
  }

  void set_deferred_start(bool value) {
    AppendTinyVarInt(12, value);
  }
  void set_flush_period_ms(uint32_t value) {
    AppendVarInt(13, value);
  }
  void set_flush_timeout_ms(uint32_t value) {
    AppendVarInt(14, value);
  }
  void set_data_source_stop_timeout_ms(uint32_t value) {
    AppendVarInt(23, value);
  }
  void set_notify_traceur(bool value) {
    AppendTinyVarInt(16, value);
  }
  template <typename T = TraceConfig_TriggerConfig> T* set_trigger_config() {
    return BeginNestedMessage<T>(17);
  }

  void add_activate_triggers(const std::string& value) {
    AppendBytes(18, value.data(), value.size());
  }
  void add_activate_triggers(const char* data, size_t size) {
    AppendBytes(18, data, size);
  }
  template <typename T = TraceConfig_IncrementalStateConfig> T* set_incremental_state_config() {
    return BeginNestedMessage<T>(21);
  }

  void set_allow_user_build_tracing(bool value) {
    AppendTinyVarInt(19, value);
  }
  void set_unique_session_name(const std::string& value) {
    AppendBytes(22, value.data(), value.size());
  }
  void set_unique_session_name(const char* data, size_t size) {
    AppendBytes(22, data, size);
  }
  void set_compression_type(::perfetto::protos::pbzero::TraceConfig_CompressionType value) {
    AppendTinyVarInt(24, value);
  }
  template <typename T = TraceConfig_IncidentReportConfig> T* set_incident_report_config() {
    return BeginNestedMessage<T>(25);
  }

  void set_trace_uuid_msb(int64_t value) {
    AppendVarInt(27, value);
  }
  void set_trace_uuid_lsb(int64_t value) {
    AppendVarInt(28, value);
  }
};

class TraceConfig_IncidentReportConfig_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TraceConfig_IncidentReportConfig_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TraceConfig_IncidentReportConfig_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TraceConfig_IncidentReportConfig_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_destination_package() const { return at<1>().valid(); }
  ::protozero::ConstChars destination_package() const { return at<1>().as_string(); }
  bool has_destination_class() const { return at<2>().valid(); }
  ::protozero::ConstChars destination_class() const { return at<2>().as_string(); }
  bool has_privacy_level() const { return at<3>().valid(); }
  int32_t privacy_level() const { return at<3>().as_int32(); }
  bool has_skip_dropbox() const { return at<4>().valid(); }
  bool skip_dropbox() const { return at<4>().as_bool(); }
};

class TraceConfig_IncidentReportConfig : public ::protozero::Message {
 public:
  using Decoder = TraceConfig_IncidentReportConfig_Decoder;
  enum : int32_t {
    kDestinationPackageFieldNumber = 1,
    kDestinationClassFieldNumber = 2,
    kPrivacyLevelFieldNumber = 3,
    kSkipDropboxFieldNumber = 4,
  };
  void set_destination_package(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_destination_package(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_destination_class(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void set_destination_class(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
  void set_privacy_level(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_skip_dropbox(bool value) {
    AppendTinyVarInt(4, value);
  }
};

class TraceConfig_IncrementalStateConfig_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TraceConfig_IncrementalStateConfig_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TraceConfig_IncrementalStateConfig_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TraceConfig_IncrementalStateConfig_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_clear_period_ms() const { return at<1>().valid(); }
  uint32_t clear_period_ms() const { return at<1>().as_uint32(); }
};

class TraceConfig_IncrementalStateConfig : public ::protozero::Message {
 public:
  using Decoder = TraceConfig_IncrementalStateConfig_Decoder;
  enum : int32_t {
    kClearPeriodMsFieldNumber = 1,
  };
  void set_clear_period_ms(uint32_t value) {
    AppendVarInt(1, value);
  }
};

class TraceConfig_TriggerConfig_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  TraceConfig_TriggerConfig_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TraceConfig_TriggerConfig_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TraceConfig_TriggerConfig_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_trigger_mode() const { return at<1>().valid(); }
  int32_t trigger_mode() const { return at<1>().as_int32(); }
  bool has_triggers() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> triggers() const { return GetRepeated<::protozero::ConstBytes>(2); }
  bool has_trigger_timeout_ms() const { return at<3>().valid(); }
  uint32_t trigger_timeout_ms() const { return at<3>().as_uint32(); }
};

class TraceConfig_TriggerConfig : public ::protozero::Message {
 public:
  using Decoder = TraceConfig_TriggerConfig_Decoder;
  enum : int32_t {
    kTriggerModeFieldNumber = 1,
    kTriggersFieldNumber = 2,
    kTriggerTimeoutMsFieldNumber = 3,
  };
  using Trigger = ::perfetto::protos::pbzero::TraceConfig_TriggerConfig_Trigger;
  using TriggerMode = ::perfetto::protos::pbzero::TraceConfig_TriggerConfig_TriggerMode;
  static const TriggerMode UNSPECIFIED = TraceConfig_TriggerConfig_TriggerMode_UNSPECIFIED;
  static const TriggerMode START_TRACING = TraceConfig_TriggerConfig_TriggerMode_START_TRACING;
  static const TriggerMode STOP_TRACING = TraceConfig_TriggerConfig_TriggerMode_STOP_TRACING;
  void set_trigger_mode(::perfetto::protos::pbzero::TraceConfig_TriggerConfig_TriggerMode value) {
    AppendTinyVarInt(1, value);
  }
  template <typename T = TraceConfig_TriggerConfig_Trigger> T* add_triggers() {
    return BeginNestedMessage<T>(2);
  }

  void set_trigger_timeout_ms(uint32_t value) {
    AppendVarInt(3, value);
  }
};

class TraceConfig_TriggerConfig_Trigger_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TraceConfig_TriggerConfig_Trigger_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TraceConfig_TriggerConfig_Trigger_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TraceConfig_TriggerConfig_Trigger_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_producer_name_regex() const { return at<2>().valid(); }
  ::protozero::ConstChars producer_name_regex() const { return at<2>().as_string(); }
  bool has_stop_delay_ms() const { return at<3>().valid(); }
  uint32_t stop_delay_ms() const { return at<3>().as_uint32(); }
};

class TraceConfig_TriggerConfig_Trigger : public ::protozero::Message {
 public:
  using Decoder = TraceConfig_TriggerConfig_Trigger_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kProducerNameRegexFieldNumber = 2,
    kStopDelayMsFieldNumber = 3,
  };
  void set_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_producer_name_regex(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void set_producer_name_regex(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
  void set_stop_delay_ms(uint32_t value) {
    AppendVarInt(3, value);
  }
};

class TraceConfig_GuardrailOverrides_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TraceConfig_GuardrailOverrides_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TraceConfig_GuardrailOverrides_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TraceConfig_GuardrailOverrides_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_max_upload_per_day_bytes() const { return at<1>().valid(); }
  uint64_t max_upload_per_day_bytes() const { return at<1>().as_uint64(); }
};

class TraceConfig_GuardrailOverrides : public ::protozero::Message {
 public:
  using Decoder = TraceConfig_GuardrailOverrides_Decoder;
  enum : int32_t {
    kMaxUploadPerDayBytesFieldNumber = 1,
  };
  void set_max_upload_per_day_bytes(uint64_t value) {
    AppendVarInt(1, value);
  }
};

class TraceConfig_StatsdMetadata_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TraceConfig_StatsdMetadata_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TraceConfig_StatsdMetadata_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TraceConfig_StatsdMetadata_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_triggering_alert_id() const { return at<1>().valid(); }
  int64_t triggering_alert_id() const { return at<1>().as_int64(); }
  bool has_triggering_config_uid() const { return at<2>().valid(); }
  int32_t triggering_config_uid() const { return at<2>().as_int32(); }
  bool has_triggering_config_id() const { return at<3>().valid(); }
  int64_t triggering_config_id() const { return at<3>().as_int64(); }
  bool has_triggering_subscription_id() const { return at<4>().valid(); }
  int64_t triggering_subscription_id() const { return at<4>().as_int64(); }
};

class TraceConfig_StatsdMetadata : public ::protozero::Message {
 public:
  using Decoder = TraceConfig_StatsdMetadata_Decoder;
  enum : int32_t {
    kTriggeringAlertIdFieldNumber = 1,
    kTriggeringConfigUidFieldNumber = 2,
    kTriggeringConfigIdFieldNumber = 3,
    kTriggeringSubscriptionIdFieldNumber = 4,
  };
  void set_triggering_alert_id(int64_t value) {
    AppendVarInt(1, value);
  }
  void set_triggering_config_uid(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_triggering_config_id(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_triggering_subscription_id(int64_t value) {
    AppendVarInt(4, value);
  }
};

class TraceConfig_ProducerConfig_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TraceConfig_ProducerConfig_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TraceConfig_ProducerConfig_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TraceConfig_ProducerConfig_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_producer_name() const { return at<1>().valid(); }
  ::protozero::ConstChars producer_name() const { return at<1>().as_string(); }
  bool has_shm_size_kb() const { return at<2>().valid(); }
  uint32_t shm_size_kb() const { return at<2>().as_uint32(); }
  bool has_page_size_kb() const { return at<3>().valid(); }
  uint32_t page_size_kb() const { return at<3>().as_uint32(); }
};

class TraceConfig_ProducerConfig : public ::protozero::Message {
 public:
  using Decoder = TraceConfig_ProducerConfig_Decoder;
  enum : int32_t {
    kProducerNameFieldNumber = 1,
    kShmSizeKbFieldNumber = 2,
    kPageSizeKbFieldNumber = 3,
  };
  void set_producer_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_producer_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_shm_size_kb(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_page_size_kb(uint32_t value) {
    AppendVarInt(3, value);
  }
};

class TraceConfig_BuiltinDataSource_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TraceConfig_BuiltinDataSource_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TraceConfig_BuiltinDataSource_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TraceConfig_BuiltinDataSource_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_disable_clock_snapshotting() const { return at<1>().valid(); }
  bool disable_clock_snapshotting() const { return at<1>().as_bool(); }
  bool has_disable_trace_config() const { return at<2>().valid(); }
  bool disable_trace_config() const { return at<2>().as_bool(); }
  bool has_disable_system_info() const { return at<3>().valid(); }
  bool disable_system_info() const { return at<3>().as_bool(); }
};

class TraceConfig_BuiltinDataSource : public ::protozero::Message {
 public:
  using Decoder = TraceConfig_BuiltinDataSource_Decoder;
  enum : int32_t {
    kDisableClockSnapshottingFieldNumber = 1,
    kDisableTraceConfigFieldNumber = 2,
    kDisableSystemInfoFieldNumber = 3,
  };
  void set_disable_clock_snapshotting(bool value) {
    AppendTinyVarInt(1, value);
  }
  void set_disable_trace_config(bool value) {
    AppendTinyVarInt(2, value);
  }
  void set_disable_system_info(bool value) {
    AppendTinyVarInt(3, value);
  }
};

class TraceConfig_DataSource_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  TraceConfig_DataSource_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TraceConfig_DataSource_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TraceConfig_DataSource_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_config() const { return at<1>().valid(); }
  ::protozero::ConstBytes config() const { return at<1>().as_bytes(); }
  bool has_producer_name_filter() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstChars> producer_name_filter() const { return GetRepeated<::protozero::ConstChars>(2); }
};

class TraceConfig_DataSource : public ::protozero::Message {
 public:
  using Decoder = TraceConfig_DataSource_Decoder;
  enum : int32_t {
    kConfigFieldNumber = 1,
    kProducerNameFilterFieldNumber = 2,
  };
  template <typename T = DataSourceConfig> T* set_config() {
    return BeginNestedMessage<T>(1);
  }

  void add_producer_name_filter(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void add_producer_name_filter(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
};

class TraceConfig_BufferConfig_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TraceConfig_BufferConfig_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TraceConfig_BufferConfig_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TraceConfig_BufferConfig_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_size_kb() const { return at<1>().valid(); }
  uint32_t size_kb() const { return at<1>().as_uint32(); }
  bool has_fill_policy() const { return at<4>().valid(); }
  int32_t fill_policy() const { return at<4>().as_int32(); }
};

class TraceConfig_BufferConfig : public ::protozero::Message {
 public:
  using Decoder = TraceConfig_BufferConfig_Decoder;
  enum : int32_t {
    kSizeKbFieldNumber = 1,
    kFillPolicyFieldNumber = 4,
  };
  using FillPolicy = ::perfetto::protos::pbzero::TraceConfig_BufferConfig_FillPolicy;
  static const FillPolicy UNSPECIFIED = TraceConfig_BufferConfig_FillPolicy_UNSPECIFIED;
  static const FillPolicy RING_BUFFER = TraceConfig_BufferConfig_FillPolicy_RING_BUFFER;
  static const FillPolicy DISCARD = TraceConfig_BufferConfig_FillPolicy_DISCARD;
  void set_size_kb(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_fill_policy(::perfetto::protos::pbzero::TraceConfig_BufferConfig_FillPolicy value) {
    AppendTinyVarInt(4, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/clock_snapshot.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_CLOCK_SNAPSHOT_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_CLOCK_SNAPSHOT_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class ClockSnapshot_Clock;

enum ClockSnapshot_Clock_BuiltinClocks : int32_t {
  ClockSnapshot_Clock_BuiltinClocks_UNKNOWN = 0,
  ClockSnapshot_Clock_BuiltinClocks_REALTIME = 1,
  ClockSnapshot_Clock_BuiltinClocks_REALTIME_COARSE = 2,
  ClockSnapshot_Clock_BuiltinClocks_MONOTONIC = 3,
  ClockSnapshot_Clock_BuiltinClocks_MONOTONIC_COARSE = 4,
  ClockSnapshot_Clock_BuiltinClocks_MONOTONIC_RAW = 5,
  ClockSnapshot_Clock_BuiltinClocks_BOOTTIME = 6,
  ClockSnapshot_Clock_BuiltinClocks_PROCESS_CPUTIME = 7,
  ClockSnapshot_Clock_BuiltinClocks_THREAD_CPUTIME = 8,
  ClockSnapshot_Clock_BuiltinClocks_BUILTIN_CLOCK_MAX_ID = 63,
};

const ClockSnapshot_Clock_BuiltinClocks ClockSnapshot_Clock_BuiltinClocks_MIN = ClockSnapshot_Clock_BuiltinClocks_UNKNOWN;
const ClockSnapshot_Clock_BuiltinClocks ClockSnapshot_Clock_BuiltinClocks_MAX = ClockSnapshot_Clock_BuiltinClocks_BUILTIN_CLOCK_MAX_ID;

class ClockSnapshot_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  ClockSnapshot_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ClockSnapshot_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ClockSnapshot_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_clocks() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> clocks() const { return GetRepeated<::protozero::ConstBytes>(1); }
};

class ClockSnapshot : public ::protozero::Message {
 public:
  using Decoder = ClockSnapshot_Decoder;
  enum : int32_t {
    kClocksFieldNumber = 1,
  };
  using Clock = ::perfetto::protos::pbzero::ClockSnapshot_Clock;
  template <typename T = ClockSnapshot_Clock> T* add_clocks() {
    return BeginNestedMessage<T>(1);
  }

};

class ClockSnapshot_Clock_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ClockSnapshot_Clock_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ClockSnapshot_Clock_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ClockSnapshot_Clock_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_clock_id() const { return at<1>().valid(); }
  uint32_t clock_id() const { return at<1>().as_uint32(); }
  bool has_timestamp() const { return at<2>().valid(); }
  uint64_t timestamp() const { return at<2>().as_uint64(); }
  bool has_is_incremental() const { return at<3>().valid(); }
  bool is_incremental() const { return at<3>().as_bool(); }
  bool has_unit_multiplier_ns() const { return at<4>().valid(); }
  uint64_t unit_multiplier_ns() const { return at<4>().as_uint64(); }
};

class ClockSnapshot_Clock : public ::protozero::Message {
 public:
  using Decoder = ClockSnapshot_Clock_Decoder;
  enum : int32_t {
    kClockIdFieldNumber = 1,
    kTimestampFieldNumber = 2,
    kIsIncrementalFieldNumber = 3,
    kUnitMultiplierNsFieldNumber = 4,
  };
  using BuiltinClocks = ::perfetto::protos::pbzero::ClockSnapshot_Clock_BuiltinClocks;
  static const BuiltinClocks UNKNOWN = ClockSnapshot_Clock_BuiltinClocks_UNKNOWN;
  static const BuiltinClocks REALTIME = ClockSnapshot_Clock_BuiltinClocks_REALTIME;
  static const BuiltinClocks REALTIME_COARSE = ClockSnapshot_Clock_BuiltinClocks_REALTIME_COARSE;
  static const BuiltinClocks MONOTONIC = ClockSnapshot_Clock_BuiltinClocks_MONOTONIC;
  static const BuiltinClocks MONOTONIC_COARSE = ClockSnapshot_Clock_BuiltinClocks_MONOTONIC_COARSE;
  static const BuiltinClocks MONOTONIC_RAW = ClockSnapshot_Clock_BuiltinClocks_MONOTONIC_RAW;
  static const BuiltinClocks BOOTTIME = ClockSnapshot_Clock_BuiltinClocks_BOOTTIME;
  static const BuiltinClocks PROCESS_CPUTIME = ClockSnapshot_Clock_BuiltinClocks_PROCESS_CPUTIME;
  static const BuiltinClocks THREAD_CPUTIME = ClockSnapshot_Clock_BuiltinClocks_THREAD_CPUTIME;
  static const BuiltinClocks BUILTIN_CLOCK_MAX_ID = ClockSnapshot_Clock_BuiltinClocks_BUILTIN_CLOCK_MAX_ID;
  void set_clock_id(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_timestamp(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_is_incremental(bool value) {
    AppendTinyVarInt(3, value);
  }
  void set_unit_multiplier_ns(uint64_t value) {
    AppendVarInt(4, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/trigger.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRIGGER_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRIGGER_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class Trigger_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Trigger_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Trigger_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Trigger_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_trigger_name() const { return at<1>().valid(); }
  ::protozero::ConstChars trigger_name() const { return at<1>().as_string(); }
  bool has_producer_name() const { return at<2>().valid(); }
  ::protozero::ConstChars producer_name() const { return at<2>().as_string(); }
  bool has_trusted_producer_uid() const { return at<3>().valid(); }
  int32_t trusted_producer_uid() const { return at<3>().as_int32(); }
};

class Trigger : public ::protozero::Message {
 public:
  using Decoder = Trigger_Decoder;
  enum : int32_t {
    kTriggerNameFieldNumber = 1,
    kProducerNameFieldNumber = 2,
    kTrustedProducerUidFieldNumber = 3,
  };
  void set_trigger_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_trigger_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_producer_name(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void set_producer_name(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
  void set_trusted_producer_uid(int32_t value) {
    AppendVarInt(3, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/system_info.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_SYSTEM_INFO_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_SYSTEM_INFO_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class Utsname;

class SystemInfo_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SystemInfo_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SystemInfo_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SystemInfo_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_utsname() const { return at<1>().valid(); }
  ::protozero::ConstBytes utsname() const { return at<1>().as_bytes(); }
  bool has_android_build_fingerprint() const { return at<2>().valid(); }
  ::protozero::ConstChars android_build_fingerprint() const { return at<2>().as_string(); }
};

class SystemInfo : public ::protozero::Message {
 public:
  using Decoder = SystemInfo_Decoder;
  enum : int32_t {
    kUtsnameFieldNumber = 1,
    kAndroidBuildFingerprintFieldNumber = 2,
  };
  template <typename T = Utsname> T* set_utsname() {
    return BeginNestedMessage<T>(1);
  }

  void set_android_build_fingerprint(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void set_android_build_fingerprint(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
};

class Utsname_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Utsname_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Utsname_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Utsname_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_sysname() const { return at<1>().valid(); }
  ::protozero::ConstChars sysname() const { return at<1>().as_string(); }
  bool has_version() const { return at<2>().valid(); }
  ::protozero::ConstChars version() const { return at<2>().as_string(); }
  bool has_release() const { return at<3>().valid(); }
  ::protozero::ConstChars release() const { return at<3>().as_string(); }
  bool has_machine() const { return at<4>().valid(); }
  ::protozero::ConstChars machine() const { return at<4>().as_string(); }
};

class Utsname : public ::protozero::Message {
 public:
  using Decoder = Utsname_Decoder;
  enum : int32_t {
    kSysnameFieldNumber = 1,
    kVersionFieldNumber = 2,
    kReleaseFieldNumber = 3,
    kMachineFieldNumber = 4,
  };
  void set_sysname(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_sysname(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_version(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void set_version(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
  void set_release(const std::string& value) {
    AppendBytes(3, value.data(), value.size());
  }
  void set_release(const char* data, size_t size) {
    AppendBytes(3, data, size);
  }
  void set_machine(const std::string& value) {
    AppendBytes(4, value.data(), value.size());
  }
  void set_machine(const char* data, size_t size) {
    AppendBytes(4, data, size);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/android/android_log.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_ANDROID_ANDROID_LOG_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_ANDROID_ANDROID_LOG_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class AndroidLogPacket_LogEvent;
class AndroidLogPacket_LogEvent_Arg;
class AndroidLogPacket_Stats;
enum AndroidLogId : int32_t;
enum AndroidLogPriority : int32_t;

class AndroidLogPacket_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  AndroidLogPacket_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit AndroidLogPacket_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit AndroidLogPacket_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_events() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> events() const { return GetRepeated<::protozero::ConstBytes>(1); }
  bool has_stats() const { return at<2>().valid(); }
  ::protozero::ConstBytes stats() const { return at<2>().as_bytes(); }
};

class AndroidLogPacket : public ::protozero::Message {
 public:
  using Decoder = AndroidLogPacket_Decoder;
  enum : int32_t {
    kEventsFieldNumber = 1,
    kStatsFieldNumber = 2,
  };
  using LogEvent = ::perfetto::protos::pbzero::AndroidLogPacket_LogEvent;
  using Stats = ::perfetto::protos::pbzero::AndroidLogPacket_Stats;
  template <typename T = AndroidLogPacket_LogEvent> T* add_events() {
    return BeginNestedMessage<T>(1);
  }

  template <typename T = AndroidLogPacket_Stats> T* set_stats() {
    return BeginNestedMessage<T>(2);
  }

};

class AndroidLogPacket_Stats_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  AndroidLogPacket_Stats_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit AndroidLogPacket_Stats_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit AndroidLogPacket_Stats_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_num_total() const { return at<1>().valid(); }
  uint64_t num_total() const { return at<1>().as_uint64(); }
  bool has_num_failed() const { return at<2>().valid(); }
  uint64_t num_failed() const { return at<2>().as_uint64(); }
  bool has_num_skipped() const { return at<3>().valid(); }
  uint64_t num_skipped() const { return at<3>().as_uint64(); }
};

class AndroidLogPacket_Stats : public ::protozero::Message {
 public:
  using Decoder = AndroidLogPacket_Stats_Decoder;
  enum : int32_t {
    kNumTotalFieldNumber = 1,
    kNumFailedFieldNumber = 2,
    kNumSkippedFieldNumber = 3,
  };
  void set_num_total(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_num_failed(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_num_skipped(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class AndroidLogPacket_LogEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/9, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  AndroidLogPacket_LogEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit AndroidLogPacket_LogEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit AndroidLogPacket_LogEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_log_id() const { return at<1>().valid(); }
  int32_t log_id() const { return at<1>().as_int32(); }
  bool has_pid() const { return at<2>().valid(); }
  int32_t pid() const { return at<2>().as_int32(); }
  bool has_tid() const { return at<3>().valid(); }
  int32_t tid() const { return at<3>().as_int32(); }
  bool has_uid() const { return at<4>().valid(); }
  int32_t uid() const { return at<4>().as_int32(); }
  bool has_timestamp() const { return at<5>().valid(); }
  uint64_t timestamp() const { return at<5>().as_uint64(); }
  bool has_tag() const { return at<6>().valid(); }
  ::protozero::ConstChars tag() const { return at<6>().as_string(); }
  bool has_prio() const { return at<7>().valid(); }
  int32_t prio() const { return at<7>().as_int32(); }
  bool has_message() const { return at<8>().valid(); }
  ::protozero::ConstChars message() const { return at<8>().as_string(); }
  bool has_args() const { return at<9>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> args() const { return GetRepeated<::protozero::ConstBytes>(9); }
};

class AndroidLogPacket_LogEvent : public ::protozero::Message {
 public:
  using Decoder = AndroidLogPacket_LogEvent_Decoder;
  enum : int32_t {
    kLogIdFieldNumber = 1,
    kPidFieldNumber = 2,
    kTidFieldNumber = 3,
    kUidFieldNumber = 4,
    kTimestampFieldNumber = 5,
    kTagFieldNumber = 6,
    kPrioFieldNumber = 7,
    kMessageFieldNumber = 8,
    kArgsFieldNumber = 9,
  };
  using Arg = ::perfetto::protos::pbzero::AndroidLogPacket_LogEvent_Arg;
  void set_log_id(::perfetto::protos::pbzero::AndroidLogId value) {
    AppendTinyVarInt(1, value);
  }
  void set_pid(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_tid(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_uid(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_timestamp(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_tag(const std::string& value) {
    AppendBytes(6, value.data(), value.size());
  }
  void set_tag(const char* data, size_t size) {
    AppendBytes(6, data, size);
  }
  void set_prio(::perfetto::protos::pbzero::AndroidLogPriority value) {
    AppendTinyVarInt(7, value);
  }
  void set_message(const std::string& value) {
    AppendBytes(8, value.data(), value.size());
  }
  void set_message(const char* data, size_t size) {
    AppendBytes(8, data, size);
  }
  template <typename T = AndroidLogPacket_LogEvent_Arg> T* add_args() {
    return BeginNestedMessage<T>(9);
  }

};

class AndroidLogPacket_LogEvent_Arg_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  AndroidLogPacket_LogEvent_Arg_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit AndroidLogPacket_LogEvent_Arg_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit AndroidLogPacket_LogEvent_Arg_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_int_value() const { return at<2>().valid(); }
  int64_t int_value() const { return at<2>().as_int64(); }
  bool has_float_value() const { return at<3>().valid(); }
  float float_value() const { return at<3>().as_float(); }
  bool has_string_value() const { return at<4>().valid(); }
  ::protozero::ConstChars string_value() const { return at<4>().as_string(); }
};

class AndroidLogPacket_LogEvent_Arg : public ::protozero::Message {
 public:
  using Decoder = AndroidLogPacket_LogEvent_Arg_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kIntValueFieldNumber = 2,
    kFloatValueFieldNumber = 3,
    kStringValueFieldNumber = 4,
  };
  void set_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_int_value(int64_t value) {
    AppendVarInt(2, value);
  }
  void set_float_value(float value) {
    AppendFixed(3, value);
  }
  void set_string_value(const std::string& value) {
    AppendBytes(4, value.data(), value.size());
  }
  void set_string_value(const char* data, size_t size) {
    AppendBytes(4, data, size);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/android/graphics_frame_event.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_ANDROID_GRAPHICS_FRAME_EVENT_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_ANDROID_GRAPHICS_FRAME_EVENT_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class GraphicsFrameEvent_BufferEvent;
enum GraphicsFrameEvent_BufferEventType : int32_t;

enum GraphicsFrameEvent_BufferEventType : int32_t {
  GraphicsFrameEvent_BufferEventType_UNSPECIFIED = 0,
  GraphicsFrameEvent_BufferEventType_DEQUEUE = 1,
  GraphicsFrameEvent_BufferEventType_QUEUE = 2,
  GraphicsFrameEvent_BufferEventType_POST = 3,
  GraphicsFrameEvent_BufferEventType_ACQUIRE_FENCE = 4,
  GraphicsFrameEvent_BufferEventType_LATCH = 5,
  GraphicsFrameEvent_BufferEventType_HWC_COMPOSITION_QUEUED = 6,
  GraphicsFrameEvent_BufferEventType_FALLBACK_COMPOSITION = 7,
  GraphicsFrameEvent_BufferEventType_PRESENT_FENCE = 8,
  GraphicsFrameEvent_BufferEventType_RELEASE_FENCE = 9,
  GraphicsFrameEvent_BufferEventType_MODIFY = 10,
  GraphicsFrameEvent_BufferEventType_DETACH = 11,
  GraphicsFrameEvent_BufferEventType_ATTACH = 12,
  GraphicsFrameEvent_BufferEventType_CANCEL = 13,
};

const GraphicsFrameEvent_BufferEventType GraphicsFrameEvent_BufferEventType_MIN = GraphicsFrameEvent_BufferEventType_UNSPECIFIED;
const GraphicsFrameEvent_BufferEventType GraphicsFrameEvent_BufferEventType_MAX = GraphicsFrameEvent_BufferEventType_CANCEL;

class GraphicsFrameEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  GraphicsFrameEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit GraphicsFrameEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit GraphicsFrameEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_buffer_event() const { return at<1>().valid(); }
  ::protozero::ConstBytes buffer_event() const { return at<1>().as_bytes(); }
};

class GraphicsFrameEvent : public ::protozero::Message {
 public:
  using Decoder = GraphicsFrameEvent_Decoder;
  enum : int32_t {
    kBufferEventFieldNumber = 1,
  };
  using BufferEvent = ::perfetto::protos::pbzero::GraphicsFrameEvent_BufferEvent;
  using BufferEventType = ::perfetto::protos::pbzero::GraphicsFrameEvent_BufferEventType;
  static const BufferEventType UNSPECIFIED = GraphicsFrameEvent_BufferEventType_UNSPECIFIED;
  static const BufferEventType DEQUEUE = GraphicsFrameEvent_BufferEventType_DEQUEUE;
  static const BufferEventType QUEUE = GraphicsFrameEvent_BufferEventType_QUEUE;
  static const BufferEventType POST = GraphicsFrameEvent_BufferEventType_POST;
  static const BufferEventType ACQUIRE_FENCE = GraphicsFrameEvent_BufferEventType_ACQUIRE_FENCE;
  static const BufferEventType LATCH = GraphicsFrameEvent_BufferEventType_LATCH;
  static const BufferEventType HWC_COMPOSITION_QUEUED = GraphicsFrameEvent_BufferEventType_HWC_COMPOSITION_QUEUED;
  static const BufferEventType FALLBACK_COMPOSITION = GraphicsFrameEvent_BufferEventType_FALLBACK_COMPOSITION;
  static const BufferEventType PRESENT_FENCE = GraphicsFrameEvent_BufferEventType_PRESENT_FENCE;
  static const BufferEventType RELEASE_FENCE = GraphicsFrameEvent_BufferEventType_RELEASE_FENCE;
  static const BufferEventType MODIFY = GraphicsFrameEvent_BufferEventType_MODIFY;
  static const BufferEventType DETACH = GraphicsFrameEvent_BufferEventType_DETACH;
  static const BufferEventType ATTACH = GraphicsFrameEvent_BufferEventType_ATTACH;
  static const BufferEventType CANCEL = GraphicsFrameEvent_BufferEventType_CANCEL;
  template <typename T = GraphicsFrameEvent_BufferEvent> T* set_buffer_event() {
    return BeginNestedMessage<T>(1);
  }

};

class GraphicsFrameEvent_BufferEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  GraphicsFrameEvent_BufferEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit GraphicsFrameEvent_BufferEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit GraphicsFrameEvent_BufferEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_frame_number() const { return at<1>().valid(); }
  uint32_t frame_number() const { return at<1>().as_uint32(); }
  bool has_type() const { return at<2>().valid(); }
  int32_t type() const { return at<2>().as_int32(); }
  bool has_layer_name() const { return at<3>().valid(); }
  ::protozero::ConstChars layer_name() const { return at<3>().as_string(); }
  bool has_duration_ns() const { return at<4>().valid(); }
  uint64_t duration_ns() const { return at<4>().as_uint64(); }
  bool has_buffer_id() const { return at<5>().valid(); }
  uint32_t buffer_id() const { return at<5>().as_uint32(); }
};

class GraphicsFrameEvent_BufferEvent : public ::protozero::Message {
 public:
  using Decoder = GraphicsFrameEvent_BufferEvent_Decoder;
  enum : int32_t {
    kFrameNumberFieldNumber = 1,
    kTypeFieldNumber = 2,
    kLayerNameFieldNumber = 3,
    kDurationNsFieldNumber = 4,
    kBufferIdFieldNumber = 5,
  };
  void set_frame_number(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_type(::perfetto::protos::pbzero::GraphicsFrameEvent_BufferEventType value) {
    AppendTinyVarInt(2, value);
  }
  void set_layer_name(const std::string& value) {
    AppendBytes(3, value.data(), value.size());
  }
  void set_layer_name(const char* data, size_t size) {
    AppendBytes(3, data, size);
  }
  void set_duration_ns(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_buffer_id(uint32_t value) {
    AppendVarInt(5, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/android/packages_list.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_ANDROID_PACKAGES_LIST_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_ANDROID_PACKAGES_LIST_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class PackagesList_PackageInfo;

class PackagesList_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  PackagesList_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit PackagesList_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit PackagesList_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_packages() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> packages() const { return GetRepeated<::protozero::ConstBytes>(1); }
  bool has_parse_error() const { return at<2>().valid(); }
  bool parse_error() const { return at<2>().as_bool(); }
  bool has_read_error() const { return at<3>().valid(); }
  bool read_error() const { return at<3>().as_bool(); }
};

class PackagesList : public ::protozero::Message {
 public:
  using Decoder = PackagesList_Decoder;
  enum : int32_t {
    kPackagesFieldNumber = 1,
    kParseErrorFieldNumber = 2,
    kReadErrorFieldNumber = 3,
  };
  using PackageInfo = ::perfetto::protos::pbzero::PackagesList_PackageInfo;
  template <typename T = PackagesList_PackageInfo> T* add_packages() {
    return BeginNestedMessage<T>(1);
  }

  void set_parse_error(bool value) {
    AppendTinyVarInt(2, value);
  }
  void set_read_error(bool value) {
    AppendTinyVarInt(3, value);
  }
};

class PackagesList_PackageInfo_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  PackagesList_PackageInfo_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit PackagesList_PackageInfo_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit PackagesList_PackageInfo_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_uid() const { return at<2>().valid(); }
  uint64_t uid() const { return at<2>().as_uint64(); }
  bool has_debuggable() const { return at<3>().valid(); }
  bool debuggable() const { return at<3>().as_bool(); }
  bool has_profileable_from_shell() const { return at<4>().valid(); }
  bool profileable_from_shell() const { return at<4>().as_bool(); }
  bool has_version_code() const { return at<5>().valid(); }
  int64_t version_code() const { return at<5>().as_int64(); }
};

class PackagesList_PackageInfo : public ::protozero::Message {
 public:
  using Decoder = PackagesList_PackageInfo_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kUidFieldNumber = 2,
    kDebuggableFieldNumber = 3,
    kProfileableFromShellFieldNumber = 4,
    kVersionCodeFieldNumber = 5,
  };
  void set_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_uid(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_debuggable(bool value) {
    AppendTinyVarInt(3, value);
  }
  void set_profileable_from_shell(bool value) {
    AppendTinyVarInt(4, value);
  }
  void set_version_code(int64_t value) {
    AppendVarInt(5, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/chrome/chrome_benchmark_metadata.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_CHROME_CHROME_BENCHMARK_METADATA_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_CHROME_CHROME_BENCHMARK_METADATA_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class ChromeBenchmarkMetadata_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/9, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  ChromeBenchmarkMetadata_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ChromeBenchmarkMetadata_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ChromeBenchmarkMetadata_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_benchmark_start_time_us() const { return at<1>().valid(); }
  int64_t benchmark_start_time_us() const { return at<1>().as_int64(); }
  bool has_story_run_time_us() const { return at<2>().valid(); }
  int64_t story_run_time_us() const { return at<2>().as_int64(); }
  bool has_benchmark_name() const { return at<3>().valid(); }
  ::protozero::ConstChars benchmark_name() const { return at<3>().as_string(); }
  bool has_benchmark_description() const { return at<4>().valid(); }
  ::protozero::ConstChars benchmark_description() const { return at<4>().as_string(); }
  bool has_label() const { return at<5>().valid(); }
  ::protozero::ConstChars label() const { return at<5>().as_string(); }
  bool has_story_name() const { return at<6>().valid(); }
  ::protozero::ConstChars story_name() const { return at<6>().as_string(); }
  bool has_story_tags() const { return at<7>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstChars> story_tags() const { return GetRepeated<::protozero::ConstChars>(7); }
  bool has_story_run_index() const { return at<8>().valid(); }
  int32_t story_run_index() const { return at<8>().as_int32(); }
  bool has_had_failures() const { return at<9>().valid(); }
  bool had_failures() const { return at<9>().as_bool(); }
};

class ChromeBenchmarkMetadata : public ::protozero::Message {
 public:
  using Decoder = ChromeBenchmarkMetadata_Decoder;
  enum : int32_t {
    kBenchmarkStartTimeUsFieldNumber = 1,
    kStoryRunTimeUsFieldNumber = 2,
    kBenchmarkNameFieldNumber = 3,
    kBenchmarkDescriptionFieldNumber = 4,
    kLabelFieldNumber = 5,
    kStoryNameFieldNumber = 6,
    kStoryTagsFieldNumber = 7,
    kStoryRunIndexFieldNumber = 8,
    kHadFailuresFieldNumber = 9,
  };
  void set_benchmark_start_time_us(int64_t value) {
    AppendVarInt(1, value);
  }
  void set_story_run_time_us(int64_t value) {
    AppendVarInt(2, value);
  }
  void set_benchmark_name(const std::string& value) {
    AppendBytes(3, value.data(), value.size());
  }
  void set_benchmark_name(const char* data, size_t size) {
    AppendBytes(3, data, size);
  }
  void set_benchmark_description(const std::string& value) {
    AppendBytes(4, value.data(), value.size());
  }
  void set_benchmark_description(const char* data, size_t size) {
    AppendBytes(4, data, size);
  }
  void set_label(const std::string& value) {
    AppendBytes(5, value.data(), value.size());
  }
  void set_label(const char* data, size_t size) {
    AppendBytes(5, data, size);
  }
  void set_story_name(const std::string& value) {
    AppendBytes(6, value.data(), value.size());
  }
  void set_story_name(const char* data, size_t size) {
    AppendBytes(6, data, size);
  }
  void add_story_tags(const std::string& value) {
    AppendBytes(7, value.data(), value.size());
  }
  void add_story_tags(const char* data, size_t size) {
    AppendBytes(7, data, size);
  }
  void set_story_run_index(int32_t value) {
    AppendVarInt(8, value);
  }
  void set_had_failures(bool value) {
    AppendTinyVarInt(9, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/chrome/chrome_metadata.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_CHROME_CHROME_METADATA_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_CHROME_CHROME_METADATA_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class BackgroundTracingMetadata;
class BackgroundTracingMetadata_TriggerRule;
class BackgroundTracingMetadata_TriggerRule_HistogramRule;
class BackgroundTracingMetadata_TriggerRule_NamedRule;
enum BackgroundTracingMetadata_TriggerRule_NamedRule_EventType : int32_t;
enum BackgroundTracingMetadata_TriggerRule_TriggerType : int32_t;

enum BackgroundTracingMetadata_TriggerRule_TriggerType : int32_t {
  BackgroundTracingMetadata_TriggerRule_TriggerType_TRIGGER_UNSPECIFIED = 0,
  BackgroundTracingMetadata_TriggerRule_TriggerType_MONITOR_AND_DUMP_WHEN_SPECIFIC_HISTOGRAM_AND_VALUE = 1,
  BackgroundTracingMetadata_TriggerRule_TriggerType_MONITOR_AND_DUMP_WHEN_TRIGGER_NAMED = 2,
};

const BackgroundTracingMetadata_TriggerRule_TriggerType BackgroundTracingMetadata_TriggerRule_TriggerType_MIN = BackgroundTracingMetadata_TriggerRule_TriggerType_TRIGGER_UNSPECIFIED;
const BackgroundTracingMetadata_TriggerRule_TriggerType BackgroundTracingMetadata_TriggerRule_TriggerType_MAX = BackgroundTracingMetadata_TriggerRule_TriggerType_MONITOR_AND_DUMP_WHEN_TRIGGER_NAMED;

enum BackgroundTracingMetadata_TriggerRule_NamedRule_EventType : int32_t {
  BackgroundTracingMetadata_TriggerRule_NamedRule_EventType_UNSPECIFIED = 0,
  BackgroundTracingMetadata_TriggerRule_NamedRule_EventType_SESSION_RESTORE = 1,
  BackgroundTracingMetadata_TriggerRule_NamedRule_EventType_NAVIGATION = 2,
  BackgroundTracingMetadata_TriggerRule_NamedRule_EventType_STARTUP = 3,
  BackgroundTracingMetadata_TriggerRule_NamedRule_EventType_TEST_RULE = 1000,
};

const BackgroundTracingMetadata_TriggerRule_NamedRule_EventType BackgroundTracingMetadata_TriggerRule_NamedRule_EventType_MIN = BackgroundTracingMetadata_TriggerRule_NamedRule_EventType_UNSPECIFIED;
const BackgroundTracingMetadata_TriggerRule_NamedRule_EventType BackgroundTracingMetadata_TriggerRule_NamedRule_EventType_MAX = BackgroundTracingMetadata_TriggerRule_NamedRule_EventType_TEST_RULE;

class BackgroundTracingMetadata_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  BackgroundTracingMetadata_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BackgroundTracingMetadata_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BackgroundTracingMetadata_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_triggered_rule() const { return at<1>().valid(); }
  ::protozero::ConstBytes triggered_rule() const { return at<1>().as_bytes(); }
  bool has_active_rules() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> active_rules() const { return GetRepeated<::protozero::ConstBytes>(2); }
};

class BackgroundTracingMetadata : public ::protozero::Message {
 public:
  using Decoder = BackgroundTracingMetadata_Decoder;
  enum : int32_t {
    kTriggeredRuleFieldNumber = 1,
    kActiveRulesFieldNumber = 2,
  };
  using TriggerRule = ::perfetto::protos::pbzero::BackgroundTracingMetadata_TriggerRule;
  template <typename T = BackgroundTracingMetadata_TriggerRule> T* set_triggered_rule() {
    return BeginNestedMessage<T>(1);
  }

  template <typename T = BackgroundTracingMetadata_TriggerRule> T* add_active_rules() {
    return BeginNestedMessage<T>(2);
  }

};

class BackgroundTracingMetadata_TriggerRule_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BackgroundTracingMetadata_TriggerRule_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BackgroundTracingMetadata_TriggerRule_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BackgroundTracingMetadata_TriggerRule_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_trigger_type() const { return at<1>().valid(); }
  int32_t trigger_type() const { return at<1>().as_int32(); }
  bool has_histogram_rule() const { return at<2>().valid(); }
  ::protozero::ConstBytes histogram_rule() const { return at<2>().as_bytes(); }
  bool has_named_rule() const { return at<3>().valid(); }
  ::protozero::ConstBytes named_rule() const { return at<3>().as_bytes(); }
};

class BackgroundTracingMetadata_TriggerRule : public ::protozero::Message {
 public:
  using Decoder = BackgroundTracingMetadata_TriggerRule_Decoder;
  enum : int32_t {
    kTriggerTypeFieldNumber = 1,
    kHistogramRuleFieldNumber = 2,
    kNamedRuleFieldNumber = 3,
  };
  using HistogramRule = ::perfetto::protos::pbzero::BackgroundTracingMetadata_TriggerRule_HistogramRule;
  using NamedRule = ::perfetto::protos::pbzero::BackgroundTracingMetadata_TriggerRule_NamedRule;
  using TriggerType = ::perfetto::protos::pbzero::BackgroundTracingMetadata_TriggerRule_TriggerType;
  static const TriggerType TRIGGER_UNSPECIFIED = BackgroundTracingMetadata_TriggerRule_TriggerType_TRIGGER_UNSPECIFIED;
  static const TriggerType MONITOR_AND_DUMP_WHEN_SPECIFIC_HISTOGRAM_AND_VALUE = BackgroundTracingMetadata_TriggerRule_TriggerType_MONITOR_AND_DUMP_WHEN_SPECIFIC_HISTOGRAM_AND_VALUE;
  static const TriggerType MONITOR_AND_DUMP_WHEN_TRIGGER_NAMED = BackgroundTracingMetadata_TriggerRule_TriggerType_MONITOR_AND_DUMP_WHEN_TRIGGER_NAMED;
  void set_trigger_type(::perfetto::protos::pbzero::BackgroundTracingMetadata_TriggerRule_TriggerType value) {
    AppendTinyVarInt(1, value);
  }
  template <typename T = BackgroundTracingMetadata_TriggerRule_HistogramRule> T* set_histogram_rule() {
    return BeginNestedMessage<T>(2);
  }

  template <typename T = BackgroundTracingMetadata_TriggerRule_NamedRule> T* set_named_rule() {
    return BeginNestedMessage<T>(3);
  }

};

class BackgroundTracingMetadata_TriggerRule_NamedRule_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BackgroundTracingMetadata_TriggerRule_NamedRule_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BackgroundTracingMetadata_TriggerRule_NamedRule_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BackgroundTracingMetadata_TriggerRule_NamedRule_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_event_type() const { return at<1>().valid(); }
  int32_t event_type() const { return at<1>().as_int32(); }
};

class BackgroundTracingMetadata_TriggerRule_NamedRule : public ::protozero::Message {
 public:
  using Decoder = BackgroundTracingMetadata_TriggerRule_NamedRule_Decoder;
  enum : int32_t {
    kEventTypeFieldNumber = 1,
  };
  using EventType = ::perfetto::protos::pbzero::BackgroundTracingMetadata_TriggerRule_NamedRule_EventType;
  static const EventType UNSPECIFIED = BackgroundTracingMetadata_TriggerRule_NamedRule_EventType_UNSPECIFIED;
  static const EventType SESSION_RESTORE = BackgroundTracingMetadata_TriggerRule_NamedRule_EventType_SESSION_RESTORE;
  static const EventType NAVIGATION = BackgroundTracingMetadata_TriggerRule_NamedRule_EventType_NAVIGATION;
  static const EventType STARTUP = BackgroundTracingMetadata_TriggerRule_NamedRule_EventType_STARTUP;
  static const EventType TEST_RULE = BackgroundTracingMetadata_TriggerRule_NamedRule_EventType_TEST_RULE;
  void set_event_type(::perfetto::protos::pbzero::BackgroundTracingMetadata_TriggerRule_NamedRule_EventType value) {
    AppendVarInt(1, value);
  }
};

class BackgroundTracingMetadata_TriggerRule_HistogramRule_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BackgroundTracingMetadata_TriggerRule_HistogramRule_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BackgroundTracingMetadata_TriggerRule_HistogramRule_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BackgroundTracingMetadata_TriggerRule_HistogramRule_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_histogram_name_hash() const { return at<1>().valid(); }
  uint64_t histogram_name_hash() const { return at<1>().as_uint64(); }
  bool has_histogram_min_trigger() const { return at<2>().valid(); }
  int64_t histogram_min_trigger() const { return at<2>().as_int64(); }
  bool has_histogram_max_trigger() const { return at<3>().valid(); }
  int64_t histogram_max_trigger() const { return at<3>().as_int64(); }
};

class BackgroundTracingMetadata_TriggerRule_HistogramRule : public ::protozero::Message {
 public:
  using Decoder = BackgroundTracingMetadata_TriggerRule_HistogramRule_Decoder;
  enum : int32_t {
    kHistogramNameHashFieldNumber = 1,
    kHistogramMinTriggerFieldNumber = 2,
    kHistogramMaxTriggerFieldNumber = 3,
  };
  void set_histogram_name_hash(uint64_t value) {
    AppendFixed(1, value);
  }
  void set_histogram_min_trigger(int64_t value) {
    AppendVarInt(2, value);
  }
  void set_histogram_max_trigger(int64_t value) {
    AppendVarInt(3, value);
  }
};

class ChromeMetadataPacket_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ChromeMetadataPacket_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ChromeMetadataPacket_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ChromeMetadataPacket_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_background_tracing_metadata() const { return at<1>().valid(); }
  ::protozero::ConstBytes background_tracing_metadata() const { return at<1>().as_bytes(); }
  bool has_chrome_version_code() const { return at<2>().valid(); }
  int32_t chrome_version_code() const { return at<2>().as_int32(); }
};

class ChromeMetadataPacket : public ::protozero::Message {
 public:
  using Decoder = ChromeMetadataPacket_Decoder;
  enum : int32_t {
    kBackgroundTracingMetadataFieldNumber = 1,
    kChromeVersionCodeFieldNumber = 2,
  };
  template <typename T = BackgroundTracingMetadata> T* set_background_tracing_metadata() {
    return BeginNestedMessage<T>(1);
  }

  void set_chrome_version_code(int32_t value) {
    AppendVarInt(2, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/chrome/chrome_trace_event.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_CHROME_CHROME_TRACE_EVENT_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_CHROME_CHROME_TRACE_EVENT_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class ChromeLegacyJsonTrace;
class ChromeMetadata;
class ChromeStringTableEntry;
class ChromeTraceEvent;
class ChromeTraceEvent_Arg;
class ChromeTracedValue;
enum ChromeLegacyJsonTrace_TraceType : int32_t;
enum ChromeTracedValue_NestedType : int32_t;

enum ChromeLegacyJsonTrace_TraceType : int32_t {
  ChromeLegacyJsonTrace_TraceType_USER_TRACE = 0,
  ChromeLegacyJsonTrace_TraceType_SYSTEM_TRACE = 1,
};

const ChromeLegacyJsonTrace_TraceType ChromeLegacyJsonTrace_TraceType_MIN = ChromeLegacyJsonTrace_TraceType_USER_TRACE;
const ChromeLegacyJsonTrace_TraceType ChromeLegacyJsonTrace_TraceType_MAX = ChromeLegacyJsonTrace_TraceType_SYSTEM_TRACE;

enum ChromeTracedValue_NestedType : int32_t {
  ChromeTracedValue_NestedType_DICT = 0,
  ChromeTracedValue_NestedType_ARRAY = 1,
};

const ChromeTracedValue_NestedType ChromeTracedValue_NestedType_MIN = ChromeTracedValue_NestedType_DICT;
const ChromeTracedValue_NestedType ChromeTracedValue_NestedType_MAX = ChromeTracedValue_NestedType_ARRAY;

class ChromeEventBundle_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  ChromeEventBundle_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ChromeEventBundle_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ChromeEventBundle_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_trace_events() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> trace_events() const { return GetRepeated<::protozero::ConstBytes>(1); }
  bool has_metadata() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> metadata() const { return GetRepeated<::protozero::ConstBytes>(2); }
  bool has_legacy_ftrace_output() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstChars> legacy_ftrace_output() const { return GetRepeated<::protozero::ConstChars>(4); }
  bool has_legacy_json_trace() const { return at<5>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> legacy_json_trace() const { return GetRepeated<::protozero::ConstBytes>(5); }
  bool has_string_table() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> string_table() const { return GetRepeated<::protozero::ConstBytes>(3); }
};

class ChromeEventBundle : public ::protozero::Message {
 public:
  using Decoder = ChromeEventBundle_Decoder;
  enum : int32_t {
    kTraceEventsFieldNumber = 1,
    kMetadataFieldNumber = 2,
    kLegacyFtraceOutputFieldNumber = 4,
    kLegacyJsonTraceFieldNumber = 5,
    kStringTableFieldNumber = 3,
  };
  template <typename T = ChromeTraceEvent> T* add_trace_events() {
    return BeginNestedMessage<T>(1);
  }

  template <typename T = ChromeMetadata> T* add_metadata() {
    return BeginNestedMessage<T>(2);
  }

  void add_legacy_ftrace_output(const std::string& value) {
    AppendBytes(4, value.data(), value.size());
  }
  void add_legacy_ftrace_output(const char* data, size_t size) {
    AppendBytes(4, data, size);
  }
  template <typename T = ChromeLegacyJsonTrace> T* add_legacy_json_trace() {
    return BeginNestedMessage<T>(5);
  }

  template <typename T = ChromeStringTableEntry> T* add_string_table() {
    return BeginNestedMessage<T>(3);
  }

};

class ChromeLegacyJsonTrace_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ChromeLegacyJsonTrace_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ChromeLegacyJsonTrace_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ChromeLegacyJsonTrace_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_type() const { return at<1>().valid(); }
  int32_t type() const { return at<1>().as_int32(); }
  bool has_data() const { return at<2>().valid(); }
  ::protozero::ConstChars data() const { return at<2>().as_string(); }
};

class ChromeLegacyJsonTrace : public ::protozero::Message {
 public:
  using Decoder = ChromeLegacyJsonTrace_Decoder;
  enum : int32_t {
    kTypeFieldNumber = 1,
    kDataFieldNumber = 2,
  };
  using TraceType = ::perfetto::protos::pbzero::ChromeLegacyJsonTrace_TraceType;
  static const TraceType USER_TRACE = ChromeLegacyJsonTrace_TraceType_USER_TRACE;
  static const TraceType SYSTEM_TRACE = ChromeLegacyJsonTrace_TraceType_SYSTEM_TRACE;
  void set_type(::perfetto::protos::pbzero::ChromeLegacyJsonTrace_TraceType value) {
    AppendTinyVarInt(1, value);
  }
  void set_data(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void set_data(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
};

class ChromeMetadata_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ChromeMetadata_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ChromeMetadata_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ChromeMetadata_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_string_value() const { return at<2>().valid(); }
  ::protozero::ConstChars string_value() const { return at<2>().as_string(); }
  bool has_bool_value() const { return at<3>().valid(); }
  bool bool_value() const { return at<3>().as_bool(); }
  bool has_int_value() const { return at<4>().valid(); }
  int64_t int_value() const { return at<4>().as_int64(); }
  bool has_json_value() const { return at<5>().valid(); }
  ::protozero::ConstChars json_value() const { return at<5>().as_string(); }
};

class ChromeMetadata : public ::protozero::Message {
 public:
  using Decoder = ChromeMetadata_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kStringValueFieldNumber = 2,
    kBoolValueFieldNumber = 3,
    kIntValueFieldNumber = 4,
    kJsonValueFieldNumber = 5,
  };
  void set_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_string_value(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void set_string_value(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
  void set_bool_value(bool value) {
    AppendTinyVarInt(3, value);
  }
  void set_int_value(int64_t value) {
    AppendVarInt(4, value);
  }
  void set_json_value(const std::string& value) {
    AppendBytes(5, value.data(), value.size());
  }
  void set_json_value(const char* data, size_t size) {
    AppendBytes(5, data, size);
  }
};

class ChromeTraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/16, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  ChromeTraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ChromeTraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ChromeTraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_timestamp() const { return at<2>().valid(); }
  int64_t timestamp() const { return at<2>().as_int64(); }
  bool has_phase() const { return at<3>().valid(); }
  int32_t phase() const { return at<3>().as_int32(); }
  bool has_thread_id() const { return at<4>().valid(); }
  int32_t thread_id() const { return at<4>().as_int32(); }
  bool has_duration() const { return at<5>().valid(); }
  int64_t duration() const { return at<5>().as_int64(); }
  bool has_thread_duration() const { return at<6>().valid(); }
  int64_t thread_duration() const { return at<6>().as_int64(); }
  bool has_scope() const { return at<7>().valid(); }
  ::protozero::ConstChars scope() const { return at<7>().as_string(); }
  bool has_id() const { return at<8>().valid(); }
  uint64_t id() const { return at<8>().as_uint64(); }
  bool has_flags() const { return at<9>().valid(); }
  uint32_t flags() const { return at<9>().as_uint32(); }
  bool has_category_group_name() const { return at<10>().valid(); }
  ::protozero::ConstChars category_group_name() const { return at<10>().as_string(); }
  bool has_process_id() const { return at<11>().valid(); }
  int32_t process_id() const { return at<11>().as_int32(); }
  bool has_thread_timestamp() const { return at<12>().valid(); }
  int64_t thread_timestamp() const { return at<12>().as_int64(); }
  bool has_bind_id() const { return at<13>().valid(); }
  uint64_t bind_id() const { return at<13>().as_uint64(); }
  bool has_args() const { return at<14>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> args() const { return GetRepeated<::protozero::ConstBytes>(14); }
  bool has_name_index() const { return at<15>().valid(); }
  uint32_t name_index() const { return at<15>().as_uint32(); }
  bool has_category_group_name_index() const { return at<16>().valid(); }
  uint32_t category_group_name_index() const { return at<16>().as_uint32(); }
};

class ChromeTraceEvent : public ::protozero::Message {
 public:
  using Decoder = ChromeTraceEvent_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kTimestampFieldNumber = 2,
    kPhaseFieldNumber = 3,
    kThreadIdFieldNumber = 4,
    kDurationFieldNumber = 5,
    kThreadDurationFieldNumber = 6,
    kScopeFieldNumber = 7,
    kIdFieldNumber = 8,
    kFlagsFieldNumber = 9,
    kCategoryGroupNameFieldNumber = 10,
    kProcessIdFieldNumber = 11,
    kThreadTimestampFieldNumber = 12,
    kBindIdFieldNumber = 13,
    kArgsFieldNumber = 14,
    kNameIndexFieldNumber = 15,
    kCategoryGroupNameIndexFieldNumber = 16,
  };
  using Arg = ::perfetto::protos::pbzero::ChromeTraceEvent_Arg;
  void set_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_timestamp(int64_t value) {
    AppendVarInt(2, value);
  }
  void set_phase(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_thread_id(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_duration(int64_t value) {
    AppendVarInt(5, value);
  }
  void set_thread_duration(int64_t value) {
    AppendVarInt(6, value);
  }
  void set_scope(const std::string& value) {
    AppendBytes(7, value.data(), value.size());
  }
  void set_scope(const char* data, size_t size) {
    AppendBytes(7, data, size);
  }
  void set_id(uint64_t value) {
    AppendVarInt(8, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(9, value);
  }
  void set_category_group_name(const std::string& value) {
    AppendBytes(10, value.data(), value.size());
  }
  void set_category_group_name(const char* data, size_t size) {
    AppendBytes(10, data, size);
  }
  void set_process_id(int32_t value) {
    AppendVarInt(11, value);
  }
  void set_thread_timestamp(int64_t value) {
    AppendVarInt(12, value);
  }
  void set_bind_id(uint64_t value) {
    AppendVarInt(13, value);
  }
  template <typename T = ChromeTraceEvent_Arg> T* add_args() {
    return BeginNestedMessage<T>(14);
  }

  void set_name_index(uint32_t value) {
    AppendVarInt(15, value);
  }
  void set_category_group_name_index(uint32_t value) {
    AppendVarInt(16, value);
  }
};

class ChromeTraceEvent_Arg_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/10, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ChromeTraceEvent_Arg_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ChromeTraceEvent_Arg_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ChromeTraceEvent_Arg_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_bool_value() const { return at<2>().valid(); }
  bool bool_value() const { return at<2>().as_bool(); }
  bool has_uint_value() const { return at<3>().valid(); }
  uint64_t uint_value() const { return at<3>().as_uint64(); }
  bool has_int_value() const { return at<4>().valid(); }
  int64_t int_value() const { return at<4>().as_int64(); }
  bool has_double_value() const { return at<5>().valid(); }
  double double_value() const { return at<5>().as_double(); }
  bool has_string_value() const { return at<6>().valid(); }
  ::protozero::ConstChars string_value() const { return at<6>().as_string(); }
  bool has_pointer_value() const { return at<7>().valid(); }
  uint64_t pointer_value() const { return at<7>().as_uint64(); }
  bool has_json_value() const { return at<8>().valid(); }
  ::protozero::ConstChars json_value() const { return at<8>().as_string(); }
  bool has_traced_value() const { return at<10>().valid(); }
  ::protozero::ConstBytes traced_value() const { return at<10>().as_bytes(); }
  bool has_name_index() const { return at<9>().valid(); }
  uint32_t name_index() const { return at<9>().as_uint32(); }
};

class ChromeTraceEvent_Arg : public ::protozero::Message {
 public:
  using Decoder = ChromeTraceEvent_Arg_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kBoolValueFieldNumber = 2,
    kUintValueFieldNumber = 3,
    kIntValueFieldNumber = 4,
    kDoubleValueFieldNumber = 5,
    kStringValueFieldNumber = 6,
    kPointerValueFieldNumber = 7,
    kJsonValueFieldNumber = 8,
    kTracedValueFieldNumber = 10,
    kNameIndexFieldNumber = 9,
  };
  void set_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_bool_value(bool value) {
    AppendTinyVarInt(2, value);
  }
  void set_uint_value(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_int_value(int64_t value) {
    AppendVarInt(4, value);
  }
  void set_double_value(double value) {
    AppendFixed(5, value);
  }
  void set_string_value(const std::string& value) {
    AppendBytes(6, value.data(), value.size());
  }
  void set_string_value(const char* data, size_t size) {
    AppendBytes(6, data, size);
  }
  void set_pointer_value(uint64_t value) {
    AppendVarInt(7, value);
  }
  void set_json_value(const std::string& value) {
    AppendBytes(8, value.data(), value.size());
  }
  void set_json_value(const char* data, size_t size) {
    AppendBytes(8, data, size);
  }
  template <typename T = ChromeTracedValue> T* set_traced_value() {
    return BeginNestedMessage<T>(10);
  }

  void set_name_index(uint32_t value) {
    AppendVarInt(9, value);
  }
};

class ChromeStringTableEntry_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ChromeStringTableEntry_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ChromeStringTableEntry_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ChromeStringTableEntry_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_value() const { return at<1>().valid(); }
  ::protozero::ConstChars value() const { return at<1>().as_string(); }
  bool has_index() const { return at<2>().valid(); }
  int32_t index() const { return at<2>().as_int32(); }
};

class ChromeStringTableEntry : public ::protozero::Message {
 public:
  using Decoder = ChromeStringTableEntry_Decoder;
  enum : int32_t {
    kValueFieldNumber = 1,
    kIndexFieldNumber = 2,
  };
  void set_value(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_value(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_index(int32_t value) {
    AppendVarInt(2, value);
  }
};

class ChromeTracedValue_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  ChromeTracedValue_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ChromeTracedValue_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ChromeTracedValue_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_nested_type() const { return at<1>().valid(); }
  int32_t nested_type() const { return at<1>().as_int32(); }
  bool has_dict_keys() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstChars> dict_keys() const { return GetRepeated<::protozero::ConstChars>(2); }
  bool has_dict_values() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> dict_values() const { return GetRepeated<::protozero::ConstBytes>(3); }
  bool has_array_values() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> array_values() const { return GetRepeated<::protozero::ConstBytes>(4); }
  bool has_int_value() const { return at<5>().valid(); }
  int32_t int_value() const { return at<5>().as_int32(); }
  bool has_double_value() const { return at<6>().valid(); }
  double double_value() const { return at<6>().as_double(); }
  bool has_bool_value() const { return at<7>().valid(); }
  bool bool_value() const { return at<7>().as_bool(); }
  bool has_string_value() const { return at<8>().valid(); }
  ::protozero::ConstChars string_value() const { return at<8>().as_string(); }
};

class ChromeTracedValue : public ::protozero::Message {
 public:
  using Decoder = ChromeTracedValue_Decoder;
  enum : int32_t {
    kNestedTypeFieldNumber = 1,
    kDictKeysFieldNumber = 2,
    kDictValuesFieldNumber = 3,
    kArrayValuesFieldNumber = 4,
    kIntValueFieldNumber = 5,
    kDoubleValueFieldNumber = 6,
    kBoolValueFieldNumber = 7,
    kStringValueFieldNumber = 8,
  };
  using NestedType = ::perfetto::protos::pbzero::ChromeTracedValue_NestedType;
  static const NestedType DICT = ChromeTracedValue_NestedType_DICT;
  static const NestedType ARRAY = ChromeTracedValue_NestedType_ARRAY;
  void set_nested_type(::perfetto::protos::pbzero::ChromeTracedValue_NestedType value) {
    AppendTinyVarInt(1, value);
  }
  void add_dict_keys(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void add_dict_keys(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
  template <typename T = ChromeTracedValue> T* add_dict_values() {
    return BeginNestedMessage<T>(3);
  }

  template <typename T = ChromeTracedValue> T* add_array_values() {
    return BeginNestedMessage<T>(4);
  }

  void set_int_value(int32_t value) {
    AppendVarInt(5, value);
  }
  void set_double_value(double value) {
    AppendFixed(6, value);
  }
  void set_bool_value(bool value) {
    AppendTinyVarInt(7, value);
  }
  void set_string_value(const std::string& value) {
    AppendBytes(8, value.data(), value.size());
  }
  void set_string_value(const char* data, size_t size) {
    AppendBytes(8, data, size);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/filesystem/inode_file_map.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FILESYSTEM_INODE_FILE_MAP_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FILESYSTEM_INODE_FILE_MAP_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class InodeFileMap_Entry;
enum InodeFileMap_Entry_Type : int32_t;

enum InodeFileMap_Entry_Type : int32_t {
  InodeFileMap_Entry_Type_UNKNOWN = 0,
  InodeFileMap_Entry_Type_FILE = 1,
  InodeFileMap_Entry_Type_DIRECTORY = 2,
};

const InodeFileMap_Entry_Type InodeFileMap_Entry_Type_MIN = InodeFileMap_Entry_Type_UNKNOWN;
const InodeFileMap_Entry_Type InodeFileMap_Entry_Type_MAX = InodeFileMap_Entry_Type_DIRECTORY;

class InodeFileMap_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  InodeFileMap_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit InodeFileMap_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit InodeFileMap_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_block_device_id() const { return at<1>().valid(); }
  uint64_t block_device_id() const { return at<1>().as_uint64(); }
  bool has_mount_points() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstChars> mount_points() const { return GetRepeated<::protozero::ConstChars>(2); }
  bool has_entries() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> entries() const { return GetRepeated<::protozero::ConstBytes>(3); }
};

class InodeFileMap : public ::protozero::Message {
 public:
  using Decoder = InodeFileMap_Decoder;
  enum : int32_t {
    kBlockDeviceIdFieldNumber = 1,
    kMountPointsFieldNumber = 2,
    kEntriesFieldNumber = 3,
  };
  using Entry = ::perfetto::protos::pbzero::InodeFileMap_Entry;
  void set_block_device_id(uint64_t value) {
    AppendVarInt(1, value);
  }
  void add_mount_points(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void add_mount_points(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
  template <typename T = InodeFileMap_Entry> T* add_entries() {
    return BeginNestedMessage<T>(3);
  }

};

class InodeFileMap_Entry_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  InodeFileMap_Entry_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit InodeFileMap_Entry_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit InodeFileMap_Entry_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_inode_number() const { return at<1>().valid(); }
  uint64_t inode_number() const { return at<1>().as_uint64(); }
  bool has_paths() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstChars> paths() const { return GetRepeated<::protozero::ConstChars>(2); }
  bool has_type() const { return at<3>().valid(); }
  int32_t type() const { return at<3>().as_int32(); }
};

class InodeFileMap_Entry : public ::protozero::Message {
 public:
  using Decoder = InodeFileMap_Entry_Decoder;
  enum : int32_t {
    kInodeNumberFieldNumber = 1,
    kPathsFieldNumber = 2,
    kTypeFieldNumber = 3,
  };
  using Type = ::perfetto::protos::pbzero::InodeFileMap_Entry_Type;
  static const Type UNKNOWN = InodeFileMap_Entry_Type_UNKNOWN;
  static const Type FILE = InodeFileMap_Entry_Type_FILE;
  static const Type DIRECTORY = InodeFileMap_Entry_Type_DIRECTORY;
  void set_inode_number(uint64_t value) {
    AppendVarInt(1, value);
  }
  void add_paths(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void add_paths(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
  void set_type(::perfetto::protos::pbzero::InodeFileMap_Entry_Type value) {
    AppendTinyVarInt(3, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/ftrace/ftrace_event.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_FTRACE_EVENT_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_FTRACE_EVENT_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class AllocPagesIommuEndFtraceEvent;
class AllocPagesIommuFailFtraceEvent;
class AllocPagesIommuStartFtraceEvent;
class AllocPagesSysEndFtraceEvent;
class AllocPagesSysFailFtraceEvent;
class AllocPagesSysStartFtraceEvent;
class BinderLockFtraceEvent;
class BinderLockedFtraceEvent;
class BinderSetPriorityFtraceEvent;
class BinderTransactionAllocBufFtraceEvent;
class BinderTransactionFtraceEvent;
class BinderTransactionReceivedFtraceEvent;
class BinderUnlockFtraceEvent;
class BlockBioBackmergeFtraceEvent;
class BlockBioBounceFtraceEvent;
class BlockBioCompleteFtraceEvent;
class BlockBioFrontmergeFtraceEvent;
class BlockBioQueueFtraceEvent;
class BlockBioRemapFtraceEvent;
class BlockDirtyBufferFtraceEvent;
class BlockGetrqFtraceEvent;
class BlockPlugFtraceEvent;
class BlockRqAbortFtraceEvent;
class BlockRqCompleteFtraceEvent;
class BlockRqInsertFtraceEvent;
class BlockRqIssueFtraceEvent;
class BlockRqRemapFtraceEvent;
class BlockRqRequeueFtraceEvent;
class BlockSleeprqFtraceEvent;
class BlockSplitFtraceEvent;
class BlockTouchBufferFtraceEvent;
class BlockUnplugFtraceEvent;
class CgroupAttachTaskFtraceEvent;
class CgroupDestroyRootFtraceEvent;
class CgroupMkdirFtraceEvent;
class CgroupReleaseFtraceEvent;
class CgroupRemountFtraceEvent;
class CgroupRenameFtraceEvent;
class CgroupRmdirFtraceEvent;
class CgroupSetupRootFtraceEvent;
class CgroupTransferTasksFtraceEvent;
class ClkDisableFtraceEvent;
class ClkEnableFtraceEvent;
class ClkSetRateFtraceEvent;
class ClockDisableFtraceEvent;
class ClockEnableFtraceEvent;
class ClockSetRateFtraceEvent;
class CpuFrequencyFtraceEvent;
class CpuFrequencyLimitsFtraceEvent;
class CpuIdleFtraceEvent;
class DmaAllocContiguousRetryFtraceEvent;
class Ext4AllocDaBlocksFtraceEvent;
class Ext4AllocateBlocksFtraceEvent;
class Ext4AllocateInodeFtraceEvent;
class Ext4BeginOrderedTruncateFtraceEvent;
class Ext4CollapseRangeFtraceEvent;
class Ext4DaReleaseSpaceFtraceEvent;
class Ext4DaReserveSpaceFtraceEvent;
class Ext4DaUpdateReserveSpaceFtraceEvent;
class Ext4DaWriteBeginFtraceEvent;
class Ext4DaWriteEndFtraceEvent;
class Ext4DaWritePagesExtentFtraceEvent;
class Ext4DaWritePagesFtraceEvent;
class Ext4DirectIOEnterFtraceEvent;
class Ext4DirectIOExitFtraceEvent;
class Ext4DiscardBlocksFtraceEvent;
class Ext4DiscardPreallocationsFtraceEvent;
class Ext4DropInodeFtraceEvent;
class Ext4EsCacheExtentFtraceEvent;
class Ext4EsFindDelayedExtentRangeEnterFtraceEvent;
class Ext4EsFindDelayedExtentRangeExitFtraceEvent;
class Ext4EsInsertExtentFtraceEvent;
class Ext4EsLookupExtentEnterFtraceEvent;
class Ext4EsLookupExtentExitFtraceEvent;
class Ext4EsRemoveExtentFtraceEvent;
class Ext4EsShrinkCountFtraceEvent;
class Ext4EsShrinkFtraceEvent;
class Ext4EsShrinkScanEnterFtraceEvent;
class Ext4EsShrinkScanExitFtraceEvent;
class Ext4EvictInodeFtraceEvent;
class Ext4ExtConvertToInitializedEnterFtraceEvent;
class Ext4ExtConvertToInitializedFastpathFtraceEvent;
class Ext4ExtHandleUnwrittenExtentsFtraceEvent;
class Ext4ExtInCacheFtraceEvent;
class Ext4ExtLoadExtentFtraceEvent;
class Ext4ExtMapBlocksEnterFtraceEvent;
class Ext4ExtMapBlocksExitFtraceEvent;
class Ext4ExtPutInCacheFtraceEvent;
class Ext4ExtRemoveSpaceDoneFtraceEvent;
class Ext4ExtRemoveSpaceFtraceEvent;
class Ext4ExtRmIdxFtraceEvent;
class Ext4ExtRmLeafFtraceEvent;
class Ext4ExtShowExtentFtraceEvent;
class Ext4FallocateEnterFtraceEvent;
class Ext4FallocateExitFtraceEvent;
class Ext4FindDelallocRangeFtraceEvent;
class Ext4ForgetFtraceEvent;
class Ext4FreeBlocksFtraceEvent;
class Ext4FreeInodeFtraceEvent;
class Ext4GetImpliedClusterAllocExitFtraceEvent;
class Ext4GetReservedClusterAllocFtraceEvent;
class Ext4IndMapBlocksEnterFtraceEvent;
class Ext4IndMapBlocksExitFtraceEvent;
class Ext4InsertRangeFtraceEvent;
class Ext4InvalidatepageFtraceEvent;
class Ext4JournalStartFtraceEvent;
class Ext4JournalStartReservedFtraceEvent;
class Ext4JournalledInvalidatepageFtraceEvent;
class Ext4JournalledWriteEndFtraceEvent;
class Ext4LoadInodeBitmapFtraceEvent;
class Ext4LoadInodeFtraceEvent;
class Ext4MarkInodeDirtyFtraceEvent;
class Ext4MbBitmapLoadFtraceEvent;
class Ext4MbBuddyBitmapLoadFtraceEvent;
class Ext4MbDiscardPreallocationsFtraceEvent;
class Ext4MbNewGroupPaFtraceEvent;
class Ext4MbNewInodePaFtraceEvent;
class Ext4MbReleaseGroupPaFtraceEvent;
class Ext4MbReleaseInodePaFtraceEvent;
class Ext4MballocAllocFtraceEvent;
class Ext4MballocDiscardFtraceEvent;
class Ext4MballocFreeFtraceEvent;
class Ext4MballocPreallocFtraceEvent;
class Ext4OtherInodeUpdateTimeFtraceEvent;
class Ext4PunchHoleFtraceEvent;
class Ext4ReadBlockBitmapLoadFtraceEvent;
class Ext4ReadpageFtraceEvent;
class Ext4ReleasepageFtraceEvent;
class Ext4RemoveBlocksFtraceEvent;
class Ext4RequestBlocksFtraceEvent;
class Ext4RequestInodeFtraceEvent;
class Ext4SyncFileEnterFtraceEvent;
class Ext4SyncFileExitFtraceEvent;
class Ext4SyncFsFtraceEvent;
class Ext4TrimAllFreeFtraceEvent;
class Ext4TrimExtentFtraceEvent;
class Ext4TruncateEnterFtraceEvent;
class Ext4TruncateExitFtraceEvent;
class Ext4UnlinkEnterFtraceEvent;
class Ext4UnlinkExitFtraceEvent;
class Ext4WriteBeginFtraceEvent;
class Ext4WriteEndFtraceEvent;
class Ext4WritepageFtraceEvent;
class Ext4WritepagesFtraceEvent;
class Ext4WritepagesResultFtraceEvent;
class Ext4ZeroRangeFtraceEvent;
class F2fsDoSubmitBioFtraceEvent;
class F2fsEvictInodeFtraceEvent;
class F2fsFallocateFtraceEvent;
class F2fsGetDataBlockFtraceEvent;
class F2fsGetVictimFtraceEvent;
class F2fsIgetExitFtraceEvent;
class F2fsIgetFtraceEvent;
class F2fsNewInodeFtraceEvent;
class F2fsReadpageFtraceEvent;
class F2fsReserveNewBlockFtraceEvent;
class F2fsSetPageDirtyFtraceEvent;
class F2fsSubmitWritePageFtraceEvent;
class F2fsSyncFileEnterFtraceEvent;
class F2fsSyncFileExitFtraceEvent;
class F2fsSyncFsFtraceEvent;
class F2fsTruncateBlocksEnterFtraceEvent;
class F2fsTruncateBlocksExitFtraceEvent;
class F2fsTruncateDataBlocksRangeFtraceEvent;
class F2fsTruncateFtraceEvent;
class F2fsTruncateInodeBlocksEnterFtraceEvent;
class F2fsTruncateInodeBlocksExitFtraceEvent;
class F2fsTruncateNodeFtraceEvent;
class F2fsTruncateNodesEnterFtraceEvent;
class F2fsTruncateNodesExitFtraceEvent;
class F2fsTruncatePartialNodesFtraceEvent;
class F2fsUnlinkEnterFtraceEvent;
class F2fsUnlinkExitFtraceEvent;
class F2fsVmPageMkwriteFtraceEvent;
class F2fsWriteBeginFtraceEvent;
class F2fsWriteCheckpointFtraceEvent;
class F2fsWriteEndFtraceEvent;
class FenceDestroyFtraceEvent;
class FenceEnableSignalFtraceEvent;
class FenceInitFtraceEvent;
class FenceSignaledFtraceEvent;
class GenericFtraceEvent;
class GpuFrequencyFtraceEvent;
class I2cReadFtraceEvent;
class I2cReplyFtraceEvent;
class I2cResultFtraceEvent;
class I2cWriteFtraceEvent;
class IommuMapRangeFtraceEvent;
class IommuSecPtblMapRangeEndFtraceEvent;
class IommuSecPtblMapRangeStartFtraceEvent;
class IonAllocBufferEndFtraceEvent;
class IonAllocBufferFailFtraceEvent;
class IonAllocBufferFallbackFtraceEvent;
class IonAllocBufferStartFtraceEvent;
class IonCpAllocRetryFtraceEvent;
class IonCpSecureBufferEndFtraceEvent;
class IonCpSecureBufferStartFtraceEvent;
class IonHeapGrowFtraceEvent;
class IonHeapShrinkFtraceEvent;
class IonPrefetchingFtraceEvent;
class IonSecureCmaAddToPoolEndFtraceEvent;
class IonSecureCmaAddToPoolStartFtraceEvent;
class IonSecureCmaAllocateEndFtraceEvent;
class IonSecureCmaAllocateStartFtraceEvent;
class IonSecureCmaShrinkPoolEndFtraceEvent;
class IonSecureCmaShrinkPoolStartFtraceEvent;
class IpiEntryFtraceEvent;
class IpiExitFtraceEvent;
class IpiRaiseFtraceEvent;
class IrqHandlerEntryFtraceEvent;
class IrqHandlerExitFtraceEvent;
class KfreeFtraceEvent;
class KmallocFtraceEvent;
class KmallocNodeFtraceEvent;
class KmemCacheAllocFtraceEvent;
class KmemCacheAllocNodeFtraceEvent;
class KmemCacheFreeFtraceEvent;
class LowmemoryKillFtraceEvent;
class MdpCmdKickoffFtraceEvent;
class MdpCmdPingpongDoneFtraceEvent;
class MdpCmdReadptrDoneFtraceEvent;
class MdpCmdReleaseBwFtraceEvent;
class MdpCmdWaitPingpongFtraceEvent;
class MdpCommitFtraceEvent;
class MdpCompareBwFtraceEvent;
class MdpMisrCrcFtraceEvent;
class MdpMixerUpdateFtraceEvent;
class MdpPerfPrefillCalcFtraceEvent;
class MdpPerfSetOtFtraceEvent;
class MdpPerfSetPanicLutsFtraceEvent;
class MdpPerfSetQosLutsFtraceEvent;
class MdpPerfSetWmLevelsFtraceEvent;
class MdpPerfUpdateBusFtraceEvent;
class MdpSsppChangeFtraceEvent;
class MdpSsppSetFtraceEvent;
class MdpTraceCounterFtraceEvent;
class MdpVideoUnderrunDoneFtraceEvent;
class MigratePagesEndFtraceEvent;
class MigratePagesStartFtraceEvent;
class MigrateRetryFtraceEvent;
class MmCompactionBeginFtraceEvent;
class MmCompactionDeferCompactionFtraceEvent;
class MmCompactionDeferResetFtraceEvent;
class MmCompactionDeferredFtraceEvent;
class MmCompactionEndFtraceEvent;
class MmCompactionFinishedFtraceEvent;
class MmCompactionIsolateFreepagesFtraceEvent;
class MmCompactionIsolateMigratepagesFtraceEvent;
class MmCompactionKcompactdSleepFtraceEvent;
class MmCompactionKcompactdWakeFtraceEvent;
class MmCompactionMigratepagesFtraceEvent;
class MmCompactionSuitableFtraceEvent;
class MmCompactionTryToCompactPagesFtraceEvent;
class MmCompactionWakeupKcompactdFtraceEvent;
class MmEventRecordFtraceEvent;
class MmFilemapAddToPageCacheFtraceEvent;
class MmFilemapDeleteFromPageCacheFtraceEvent;
class MmPageAllocExtfragFtraceEvent;
class MmPageAllocFtraceEvent;
class MmPageAllocZoneLockedFtraceEvent;
class MmPageFreeBatchedFtraceEvent;
class MmPageFreeFtraceEvent;
class MmPagePcpuDrainFtraceEvent;
class MmVmscanDirectReclaimBeginFtraceEvent;
class MmVmscanDirectReclaimEndFtraceEvent;
class MmVmscanKswapdSleepFtraceEvent;
class MmVmscanKswapdWakeFtraceEvent;
class OomScoreAdjUpdateFtraceEvent;
class PrintFtraceEvent;
class RegulatorDisableCompleteFtraceEvent;
class RegulatorDisableFtraceEvent;
class RegulatorEnableCompleteFtraceEvent;
class RegulatorEnableDelayFtraceEvent;
class RegulatorEnableFtraceEvent;
class RegulatorSetVoltageCompleteFtraceEvent;
class RegulatorSetVoltageFtraceEvent;
class RotatorBwAoAsContextFtraceEvent;
class RssStatFtraceEvent;
class SchedBlockedReasonFtraceEvent;
class SchedCpuHotplugFtraceEvent;
class SchedProcessExecFtraceEvent;
class SchedProcessExitFtraceEvent;
class SchedProcessForkFtraceEvent;
class SchedProcessFreeFtraceEvent;
class SchedProcessHangFtraceEvent;
class SchedProcessWaitFtraceEvent;
class SchedSwitchFtraceEvent;
class SchedWakeupFtraceEvent;
class SchedWakeupNewFtraceEvent;
class SchedWakingFtraceEvent;
class SignalDeliverFtraceEvent;
class SignalGenerateFtraceEvent;
class SmbusReadFtraceEvent;
class SmbusReplyFtraceEvent;
class SmbusResultFtraceEvent;
class SmbusWriteFtraceEvent;
class SoftirqEntryFtraceEvent;
class SoftirqExitFtraceEvent;
class SoftirqRaiseFtraceEvent;
class SuspendResumeFtraceEvent;
class SyncPtFtraceEvent;
class SyncTimelineFtraceEvent;
class SyncWaitFtraceEvent;
class SysEnterFtraceEvent;
class SysExitFtraceEvent;
class TaskNewtaskFtraceEvent;
class TaskRenameFtraceEvent;
class TracingMarkWriteFtraceEvent;
class WorkqueueActivateWorkFtraceEvent;
class WorkqueueExecuteEndFtraceEvent;
class WorkqueueExecuteStartFtraceEvent;
class WorkqueueQueueWorkFtraceEvent;
class ZeroFtraceEvent;

class FtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/332, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  FtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit FtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit FtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_timestamp() const { return at<1>().valid(); }
  uint64_t timestamp() const { return at<1>().as_uint64(); }
  bool has_pid() const { return at<2>().valid(); }
  uint32_t pid() const { return at<2>().as_uint32(); }
  bool has_print() const { return at<3>().valid(); }
  ::protozero::ConstBytes print() const { return at<3>().as_bytes(); }
  bool has_sched_switch() const { return at<4>().valid(); }
  ::protozero::ConstBytes sched_switch() const { return at<4>().as_bytes(); }
  bool has_cpu_frequency() const { return at<11>().valid(); }
  ::protozero::ConstBytes cpu_frequency() const { return at<11>().as_bytes(); }
  bool has_cpu_frequency_limits() const { return at<12>().valid(); }
  ::protozero::ConstBytes cpu_frequency_limits() const { return at<12>().as_bytes(); }
  bool has_cpu_idle() const { return at<13>().valid(); }
  ::protozero::ConstBytes cpu_idle() const { return at<13>().as_bytes(); }
  bool has_clock_enable() const { return at<14>().valid(); }
  ::protozero::ConstBytes clock_enable() const { return at<14>().as_bytes(); }
  bool has_clock_disable() const { return at<15>().valid(); }
  ::protozero::ConstBytes clock_disable() const { return at<15>().as_bytes(); }
  bool has_clock_set_rate() const { return at<16>().valid(); }
  ::protozero::ConstBytes clock_set_rate() const { return at<16>().as_bytes(); }
  bool has_sched_wakeup() const { return at<17>().valid(); }
  ::protozero::ConstBytes sched_wakeup() const { return at<17>().as_bytes(); }
  bool has_sched_blocked_reason() const { return at<18>().valid(); }
  ::protozero::ConstBytes sched_blocked_reason() const { return at<18>().as_bytes(); }
  bool has_sched_cpu_hotplug() const { return at<19>().valid(); }
  ::protozero::ConstBytes sched_cpu_hotplug() const { return at<19>().as_bytes(); }
  bool has_sched_waking() const { return at<20>().valid(); }
  ::protozero::ConstBytes sched_waking() const { return at<20>().as_bytes(); }
  bool has_ipi_entry() const { return at<21>().valid(); }
  ::protozero::ConstBytes ipi_entry() const { return at<21>().as_bytes(); }
  bool has_ipi_exit() const { return at<22>().valid(); }
  ::protozero::ConstBytes ipi_exit() const { return at<22>().as_bytes(); }
  bool has_ipi_raise() const { return at<23>().valid(); }
  ::protozero::ConstBytes ipi_raise() const { return at<23>().as_bytes(); }
  bool has_softirq_entry() const { return at<24>().valid(); }
  ::protozero::ConstBytes softirq_entry() const { return at<24>().as_bytes(); }
  bool has_softirq_exit() const { return at<25>().valid(); }
  ::protozero::ConstBytes softirq_exit() const { return at<25>().as_bytes(); }
  bool has_softirq_raise() const { return at<26>().valid(); }
  ::protozero::ConstBytes softirq_raise() const { return at<26>().as_bytes(); }
  bool has_i2c_read() const { return at<27>().valid(); }
  ::protozero::ConstBytes i2c_read() const { return at<27>().as_bytes(); }
  bool has_i2c_write() const { return at<28>().valid(); }
  ::protozero::ConstBytes i2c_write() const { return at<28>().as_bytes(); }
  bool has_i2c_result() const { return at<29>().valid(); }
  ::protozero::ConstBytes i2c_result() const { return at<29>().as_bytes(); }
  bool has_i2c_reply() const { return at<30>().valid(); }
  ::protozero::ConstBytes i2c_reply() const { return at<30>().as_bytes(); }
  bool has_smbus_read() const { return at<31>().valid(); }
  ::protozero::ConstBytes smbus_read() const { return at<31>().as_bytes(); }
  bool has_smbus_write() const { return at<32>().valid(); }
  ::protozero::ConstBytes smbus_write() const { return at<32>().as_bytes(); }
  bool has_smbus_result() const { return at<33>().valid(); }
  ::protozero::ConstBytes smbus_result() const { return at<33>().as_bytes(); }
  bool has_smbus_reply() const { return at<34>().valid(); }
  ::protozero::ConstBytes smbus_reply() const { return at<34>().as_bytes(); }
  bool has_lowmemory_kill() const { return at<35>().valid(); }
  ::protozero::ConstBytes lowmemory_kill() const { return at<35>().as_bytes(); }
  bool has_irq_handler_entry() const { return at<36>().valid(); }
  ::protozero::ConstBytes irq_handler_entry() const { return at<36>().as_bytes(); }
  bool has_irq_handler_exit() const { return at<37>().valid(); }
  ::protozero::ConstBytes irq_handler_exit() const { return at<37>().as_bytes(); }
  bool has_sync_pt() const { return at<38>().valid(); }
  ::protozero::ConstBytes sync_pt() const { return at<38>().as_bytes(); }
  bool has_sync_timeline() const { return at<39>().valid(); }
  ::protozero::ConstBytes sync_timeline() const { return at<39>().as_bytes(); }
  bool has_sync_wait() const { return at<40>().valid(); }
  ::protozero::ConstBytes sync_wait() const { return at<40>().as_bytes(); }
  bool has_ext4_da_write_begin() const { return at<41>().valid(); }
  ::protozero::ConstBytes ext4_da_write_begin() const { return at<41>().as_bytes(); }
  bool has_ext4_da_write_end() const { return at<42>().valid(); }
  ::protozero::ConstBytes ext4_da_write_end() const { return at<42>().as_bytes(); }
  bool has_ext4_sync_file_enter() const { return at<43>().valid(); }
  ::protozero::ConstBytes ext4_sync_file_enter() const { return at<43>().as_bytes(); }
  bool has_ext4_sync_file_exit() const { return at<44>().valid(); }
  ::protozero::ConstBytes ext4_sync_file_exit() const { return at<44>().as_bytes(); }
  bool has_block_rq_issue() const { return at<45>().valid(); }
  ::protozero::ConstBytes block_rq_issue() const { return at<45>().as_bytes(); }
  bool has_mm_vmscan_direct_reclaim_begin() const { return at<46>().valid(); }
  ::protozero::ConstBytes mm_vmscan_direct_reclaim_begin() const { return at<46>().as_bytes(); }
  bool has_mm_vmscan_direct_reclaim_end() const { return at<47>().valid(); }
  ::protozero::ConstBytes mm_vmscan_direct_reclaim_end() const { return at<47>().as_bytes(); }
  bool has_mm_vmscan_kswapd_wake() const { return at<48>().valid(); }
  ::protozero::ConstBytes mm_vmscan_kswapd_wake() const { return at<48>().as_bytes(); }
  bool has_mm_vmscan_kswapd_sleep() const { return at<49>().valid(); }
  ::protozero::ConstBytes mm_vmscan_kswapd_sleep() const { return at<49>().as_bytes(); }
  bool has_binder_transaction() const { return at<50>().valid(); }
  ::protozero::ConstBytes binder_transaction() const { return at<50>().as_bytes(); }
  bool has_binder_transaction_received() const { return at<51>().valid(); }
  ::protozero::ConstBytes binder_transaction_received() const { return at<51>().as_bytes(); }
  bool has_binder_set_priority() const { return at<52>().valid(); }
  ::protozero::ConstBytes binder_set_priority() const { return at<52>().as_bytes(); }
  bool has_binder_lock() const { return at<53>().valid(); }
  ::protozero::ConstBytes binder_lock() const { return at<53>().as_bytes(); }
  bool has_binder_locked() const { return at<54>().valid(); }
  ::protozero::ConstBytes binder_locked() const { return at<54>().as_bytes(); }
  bool has_binder_unlock() const { return at<55>().valid(); }
  ::protozero::ConstBytes binder_unlock() const { return at<55>().as_bytes(); }
  bool has_workqueue_activate_work() const { return at<56>().valid(); }
  ::protozero::ConstBytes workqueue_activate_work() const { return at<56>().as_bytes(); }
  bool has_workqueue_execute_end() const { return at<57>().valid(); }
  ::protozero::ConstBytes workqueue_execute_end() const { return at<57>().as_bytes(); }
  bool has_workqueue_execute_start() const { return at<58>().valid(); }
  ::protozero::ConstBytes workqueue_execute_start() const { return at<58>().as_bytes(); }
  bool has_workqueue_queue_work() const { return at<59>().valid(); }
  ::protozero::ConstBytes workqueue_queue_work() const { return at<59>().as_bytes(); }
  bool has_regulator_disable() const { return at<60>().valid(); }
  ::protozero::ConstBytes regulator_disable() const { return at<60>().as_bytes(); }
  bool has_regulator_disable_complete() const { return at<61>().valid(); }
  ::protozero::ConstBytes regulator_disable_complete() const { return at<61>().as_bytes(); }
  bool has_regulator_enable() const { return at<62>().valid(); }
  ::protozero::ConstBytes regulator_enable() const { return at<62>().as_bytes(); }
  bool has_regulator_enable_complete() const { return at<63>().valid(); }
  ::protozero::ConstBytes regulator_enable_complete() const { return at<63>().as_bytes(); }
  bool has_regulator_enable_delay() const { return at<64>().valid(); }
  ::protozero::ConstBytes regulator_enable_delay() const { return at<64>().as_bytes(); }
  bool has_regulator_set_voltage() const { return at<65>().valid(); }
  ::protozero::ConstBytes regulator_set_voltage() const { return at<65>().as_bytes(); }
  bool has_regulator_set_voltage_complete() const { return at<66>().valid(); }
  ::protozero::ConstBytes regulator_set_voltage_complete() const { return at<66>().as_bytes(); }
  bool has_cgroup_attach_task() const { return at<67>().valid(); }
  ::protozero::ConstBytes cgroup_attach_task() const { return at<67>().as_bytes(); }
  bool has_cgroup_mkdir() const { return at<68>().valid(); }
  ::protozero::ConstBytes cgroup_mkdir() const { return at<68>().as_bytes(); }
  bool has_cgroup_remount() const { return at<69>().valid(); }
  ::protozero::ConstBytes cgroup_remount() const { return at<69>().as_bytes(); }
  bool has_cgroup_rmdir() const { return at<70>().valid(); }
  ::protozero::ConstBytes cgroup_rmdir() const { return at<70>().as_bytes(); }
  bool has_cgroup_transfer_tasks() const { return at<71>().valid(); }
  ::protozero::ConstBytes cgroup_transfer_tasks() const { return at<71>().as_bytes(); }
  bool has_cgroup_destroy_root() const { return at<72>().valid(); }
  ::protozero::ConstBytes cgroup_destroy_root() const { return at<72>().as_bytes(); }
  bool has_cgroup_release() const { return at<73>().valid(); }
  ::protozero::ConstBytes cgroup_release() const { return at<73>().as_bytes(); }
  bool has_cgroup_rename() const { return at<74>().valid(); }
  ::protozero::ConstBytes cgroup_rename() const { return at<74>().as_bytes(); }
  bool has_cgroup_setup_root() const { return at<75>().valid(); }
  ::protozero::ConstBytes cgroup_setup_root() const { return at<75>().as_bytes(); }
  bool has_mdp_cmd_kickoff() const { return at<76>().valid(); }
  ::protozero::ConstBytes mdp_cmd_kickoff() const { return at<76>().as_bytes(); }
  bool has_mdp_commit() const { return at<77>().valid(); }
  ::protozero::ConstBytes mdp_commit() const { return at<77>().as_bytes(); }
  bool has_mdp_perf_set_ot() const { return at<78>().valid(); }
  ::protozero::ConstBytes mdp_perf_set_ot() const { return at<78>().as_bytes(); }
  bool has_mdp_sspp_change() const { return at<79>().valid(); }
  ::protozero::ConstBytes mdp_sspp_change() const { return at<79>().as_bytes(); }
  bool has_tracing_mark_write() const { return at<80>().valid(); }
  ::protozero::ConstBytes tracing_mark_write() const { return at<80>().as_bytes(); }
  bool has_mdp_cmd_pingpong_done() const { return at<81>().valid(); }
  ::protozero::ConstBytes mdp_cmd_pingpong_done() const { return at<81>().as_bytes(); }
  bool has_mdp_compare_bw() const { return at<82>().valid(); }
  ::protozero::ConstBytes mdp_compare_bw() const { return at<82>().as_bytes(); }
  bool has_mdp_perf_set_panic_luts() const { return at<83>().valid(); }
  ::protozero::ConstBytes mdp_perf_set_panic_luts() const { return at<83>().as_bytes(); }
  bool has_mdp_sspp_set() const { return at<84>().valid(); }
  ::protozero::ConstBytes mdp_sspp_set() const { return at<84>().as_bytes(); }
  bool has_mdp_cmd_readptr_done() const { return at<85>().valid(); }
  ::protozero::ConstBytes mdp_cmd_readptr_done() const { return at<85>().as_bytes(); }
  bool has_mdp_misr_crc() const { return at<86>().valid(); }
  ::protozero::ConstBytes mdp_misr_crc() const { return at<86>().as_bytes(); }
  bool has_mdp_perf_set_qos_luts() const { return at<87>().valid(); }
  ::protozero::ConstBytes mdp_perf_set_qos_luts() const { return at<87>().as_bytes(); }
  bool has_mdp_trace_counter() const { return at<88>().valid(); }
  ::protozero::ConstBytes mdp_trace_counter() const { return at<88>().as_bytes(); }
  bool has_mdp_cmd_release_bw() const { return at<89>().valid(); }
  ::protozero::ConstBytes mdp_cmd_release_bw() const { return at<89>().as_bytes(); }
  bool has_mdp_mixer_update() const { return at<90>().valid(); }
  ::protozero::ConstBytes mdp_mixer_update() const { return at<90>().as_bytes(); }
  bool has_mdp_perf_set_wm_levels() const { return at<91>().valid(); }
  ::protozero::ConstBytes mdp_perf_set_wm_levels() const { return at<91>().as_bytes(); }
  bool has_mdp_video_underrun_done() const { return at<92>().valid(); }
  ::protozero::ConstBytes mdp_video_underrun_done() const { return at<92>().as_bytes(); }
  bool has_mdp_cmd_wait_pingpong() const { return at<93>().valid(); }
  ::protozero::ConstBytes mdp_cmd_wait_pingpong() const { return at<93>().as_bytes(); }
  bool has_mdp_perf_prefill_calc() const { return at<94>().valid(); }
  ::protozero::ConstBytes mdp_perf_prefill_calc() const { return at<94>().as_bytes(); }
  bool has_mdp_perf_update_bus() const { return at<95>().valid(); }
  ::protozero::ConstBytes mdp_perf_update_bus() const { return at<95>().as_bytes(); }
  bool has_rotator_bw_ao_as_context() const { return at<96>().valid(); }
  ::protozero::ConstBytes rotator_bw_ao_as_context() const { return at<96>().as_bytes(); }
  bool has_mm_filemap_add_to_page_cache() const { return at<97>().valid(); }
  ::protozero::ConstBytes mm_filemap_add_to_page_cache() const { return at<97>().as_bytes(); }
  bool has_mm_filemap_delete_from_page_cache() const { return at<98>().valid(); }
  ::protozero::ConstBytes mm_filemap_delete_from_page_cache() const { return at<98>().as_bytes(); }
  bool has_mm_compaction_begin() const { return at<99>().valid(); }
  ::protozero::ConstBytes mm_compaction_begin() const { return at<99>().as_bytes(); }
  bool has_mm_compaction_defer_compaction() const { return at<100>().valid(); }
  ::protozero::ConstBytes mm_compaction_defer_compaction() const { return at<100>().as_bytes(); }
  bool has_mm_compaction_deferred() const { return at<101>().valid(); }
  ::protozero::ConstBytes mm_compaction_deferred() const { return at<101>().as_bytes(); }
  bool has_mm_compaction_defer_reset() const { return at<102>().valid(); }
  ::protozero::ConstBytes mm_compaction_defer_reset() const { return at<102>().as_bytes(); }
  bool has_mm_compaction_end() const { return at<103>().valid(); }
  ::protozero::ConstBytes mm_compaction_end() const { return at<103>().as_bytes(); }
  bool has_mm_compaction_finished() const { return at<104>().valid(); }
  ::protozero::ConstBytes mm_compaction_finished() const { return at<104>().as_bytes(); }
  bool has_mm_compaction_isolate_freepages() const { return at<105>().valid(); }
  ::protozero::ConstBytes mm_compaction_isolate_freepages() const { return at<105>().as_bytes(); }
  bool has_mm_compaction_isolate_migratepages() const { return at<106>().valid(); }
  ::protozero::ConstBytes mm_compaction_isolate_migratepages() const { return at<106>().as_bytes(); }
  bool has_mm_compaction_kcompactd_sleep() const { return at<107>().valid(); }
  ::protozero::ConstBytes mm_compaction_kcompactd_sleep() const { return at<107>().as_bytes(); }
  bool has_mm_compaction_kcompactd_wake() const { return at<108>().valid(); }
  ::protozero::ConstBytes mm_compaction_kcompactd_wake() const { return at<108>().as_bytes(); }
  bool has_mm_compaction_migratepages() const { return at<109>().valid(); }
  ::protozero::ConstBytes mm_compaction_migratepages() const { return at<109>().as_bytes(); }
  bool has_mm_compaction_suitable() const { return at<110>().valid(); }
  ::protozero::ConstBytes mm_compaction_suitable() const { return at<110>().as_bytes(); }
  bool has_mm_compaction_try_to_compact_pages() const { return at<111>().valid(); }
  ::protozero::ConstBytes mm_compaction_try_to_compact_pages() const { return at<111>().as_bytes(); }
  bool has_mm_compaction_wakeup_kcompactd() const { return at<112>().valid(); }
  ::protozero::ConstBytes mm_compaction_wakeup_kcompactd() const { return at<112>().as_bytes(); }
  bool has_suspend_resume() const { return at<113>().valid(); }
  ::protozero::ConstBytes suspend_resume() const { return at<113>().as_bytes(); }
  bool has_sched_wakeup_new() const { return at<114>().valid(); }
  ::protozero::ConstBytes sched_wakeup_new() const { return at<114>().as_bytes(); }
  bool has_block_bio_backmerge() const { return at<115>().valid(); }
  ::protozero::ConstBytes block_bio_backmerge() const { return at<115>().as_bytes(); }
  bool has_block_bio_bounce() const { return at<116>().valid(); }
  ::protozero::ConstBytes block_bio_bounce() const { return at<116>().as_bytes(); }
  bool has_block_bio_complete() const { return at<117>().valid(); }
  ::protozero::ConstBytes block_bio_complete() const { return at<117>().as_bytes(); }
  bool has_block_bio_frontmerge() const { return at<118>().valid(); }
  ::protozero::ConstBytes block_bio_frontmerge() const { return at<118>().as_bytes(); }
  bool has_block_bio_queue() const { return at<119>().valid(); }
  ::protozero::ConstBytes block_bio_queue() const { return at<119>().as_bytes(); }
  bool has_block_bio_remap() const { return at<120>().valid(); }
  ::protozero::ConstBytes block_bio_remap() const { return at<120>().as_bytes(); }
  bool has_block_dirty_buffer() const { return at<121>().valid(); }
  ::protozero::ConstBytes block_dirty_buffer() const { return at<121>().as_bytes(); }
  bool has_block_getrq() const { return at<122>().valid(); }
  ::protozero::ConstBytes block_getrq() const { return at<122>().as_bytes(); }
  bool has_block_plug() const { return at<123>().valid(); }
  ::protozero::ConstBytes block_plug() const { return at<123>().as_bytes(); }
  bool has_block_rq_abort() const { return at<124>().valid(); }
  ::protozero::ConstBytes block_rq_abort() const { return at<124>().as_bytes(); }
  bool has_block_rq_complete() const { return at<125>().valid(); }
  ::protozero::ConstBytes block_rq_complete() const { return at<125>().as_bytes(); }
  bool has_block_rq_insert() const { return at<126>().valid(); }
  ::protozero::ConstBytes block_rq_insert() const { return at<126>().as_bytes(); }
  bool has_block_rq_remap() const { return at<128>().valid(); }
  ::protozero::ConstBytes block_rq_remap() const { return at<128>().as_bytes(); }
  bool has_block_rq_requeue() const { return at<129>().valid(); }
  ::protozero::ConstBytes block_rq_requeue() const { return at<129>().as_bytes(); }
  bool has_block_sleeprq() const { return at<130>().valid(); }
  ::protozero::ConstBytes block_sleeprq() const { return at<130>().as_bytes(); }
  bool has_block_split() const { return at<131>().valid(); }
  ::protozero::ConstBytes block_split() const { return at<131>().as_bytes(); }
  bool has_block_touch_buffer() const { return at<132>().valid(); }
  ::protozero::ConstBytes block_touch_buffer() const { return at<132>().as_bytes(); }
  bool has_block_unplug() const { return at<133>().valid(); }
  ::protozero::ConstBytes block_unplug() const { return at<133>().as_bytes(); }
  bool has_ext4_alloc_da_blocks() const { return at<134>().valid(); }
  ::protozero::ConstBytes ext4_alloc_da_blocks() const { return at<134>().as_bytes(); }
  bool has_ext4_allocate_blocks() const { return at<135>().valid(); }
  ::protozero::ConstBytes ext4_allocate_blocks() const { return at<135>().as_bytes(); }
  bool has_ext4_allocate_inode() const { return at<136>().valid(); }
  ::protozero::ConstBytes ext4_allocate_inode() const { return at<136>().as_bytes(); }
  bool has_ext4_begin_ordered_truncate() const { return at<137>().valid(); }
  ::protozero::ConstBytes ext4_begin_ordered_truncate() const { return at<137>().as_bytes(); }
  bool has_ext4_collapse_range() const { return at<138>().valid(); }
  ::protozero::ConstBytes ext4_collapse_range() const { return at<138>().as_bytes(); }
  bool has_ext4_da_release_space() const { return at<139>().valid(); }
  ::protozero::ConstBytes ext4_da_release_space() const { return at<139>().as_bytes(); }
  bool has_ext4_da_reserve_space() const { return at<140>().valid(); }
  ::protozero::ConstBytes ext4_da_reserve_space() const { return at<140>().as_bytes(); }
  bool has_ext4_da_update_reserve_space() const { return at<141>().valid(); }
  ::protozero::ConstBytes ext4_da_update_reserve_space() const { return at<141>().as_bytes(); }
  bool has_ext4_da_write_pages() const { return at<142>().valid(); }
  ::protozero::ConstBytes ext4_da_write_pages() const { return at<142>().as_bytes(); }
  bool has_ext4_da_write_pages_extent() const { return at<143>().valid(); }
  ::protozero::ConstBytes ext4_da_write_pages_extent() const { return at<143>().as_bytes(); }
  bool has_ext4_direct_io_enter() const { return at<144>().valid(); }
  ::protozero::ConstBytes ext4_direct_io_enter() const { return at<144>().as_bytes(); }
  bool has_ext4_direct_io_exit() const { return at<145>().valid(); }
  ::protozero::ConstBytes ext4_direct_io_exit() const { return at<145>().as_bytes(); }
  bool has_ext4_discard_blocks() const { return at<146>().valid(); }
  ::protozero::ConstBytes ext4_discard_blocks() const { return at<146>().as_bytes(); }
  bool has_ext4_discard_preallocations() const { return at<147>().valid(); }
  ::protozero::ConstBytes ext4_discard_preallocations() const { return at<147>().as_bytes(); }
  bool has_ext4_drop_inode() const { return at<148>().valid(); }
  ::protozero::ConstBytes ext4_drop_inode() const { return at<148>().as_bytes(); }
  bool has_ext4_es_cache_extent() const { return at<149>().valid(); }
  ::protozero::ConstBytes ext4_es_cache_extent() const { return at<149>().as_bytes(); }
  bool has_ext4_es_find_delayed_extent_range_enter() const { return at<150>().valid(); }
  ::protozero::ConstBytes ext4_es_find_delayed_extent_range_enter() const { return at<150>().as_bytes(); }
  bool has_ext4_es_find_delayed_extent_range_exit() const { return at<151>().valid(); }
  ::protozero::ConstBytes ext4_es_find_delayed_extent_range_exit() const { return at<151>().as_bytes(); }
  bool has_ext4_es_insert_extent() const { return at<152>().valid(); }
  ::protozero::ConstBytes ext4_es_insert_extent() const { return at<152>().as_bytes(); }
  bool has_ext4_es_lookup_extent_enter() const { return at<153>().valid(); }
  ::protozero::ConstBytes ext4_es_lookup_extent_enter() const { return at<153>().as_bytes(); }
  bool has_ext4_es_lookup_extent_exit() const { return at<154>().valid(); }
  ::protozero::ConstBytes ext4_es_lookup_extent_exit() const { return at<154>().as_bytes(); }
  bool has_ext4_es_remove_extent() const { return at<155>().valid(); }
  ::protozero::ConstBytes ext4_es_remove_extent() const { return at<155>().as_bytes(); }
  bool has_ext4_es_shrink() const { return at<156>().valid(); }
  ::protozero::ConstBytes ext4_es_shrink() const { return at<156>().as_bytes(); }
  bool has_ext4_es_shrink_count() const { return at<157>().valid(); }
  ::protozero::ConstBytes ext4_es_shrink_count() const { return at<157>().as_bytes(); }
  bool has_ext4_es_shrink_scan_enter() const { return at<158>().valid(); }
  ::protozero::ConstBytes ext4_es_shrink_scan_enter() const { return at<158>().as_bytes(); }
  bool has_ext4_es_shrink_scan_exit() const { return at<159>().valid(); }
  ::protozero::ConstBytes ext4_es_shrink_scan_exit() const { return at<159>().as_bytes(); }
  bool has_ext4_evict_inode() const { return at<160>().valid(); }
  ::protozero::ConstBytes ext4_evict_inode() const { return at<160>().as_bytes(); }
  bool has_ext4_ext_convert_to_initialized_enter() const { return at<161>().valid(); }
  ::protozero::ConstBytes ext4_ext_convert_to_initialized_enter() const { return at<161>().as_bytes(); }
  bool has_ext4_ext_convert_to_initialized_fastpath() const { return at<162>().valid(); }
  ::protozero::ConstBytes ext4_ext_convert_to_initialized_fastpath() const { return at<162>().as_bytes(); }
  bool has_ext4_ext_handle_unwritten_extents() const { return at<163>().valid(); }
  ::protozero::ConstBytes ext4_ext_handle_unwritten_extents() const { return at<163>().as_bytes(); }
  bool has_ext4_ext_in_cache() const { return at<164>().valid(); }
  ::protozero::ConstBytes ext4_ext_in_cache() const { return at<164>().as_bytes(); }
  bool has_ext4_ext_load_extent() const { return at<165>().valid(); }
  ::protozero::ConstBytes ext4_ext_load_extent() const { return at<165>().as_bytes(); }
  bool has_ext4_ext_map_blocks_enter() const { return at<166>().valid(); }
  ::protozero::ConstBytes ext4_ext_map_blocks_enter() const { return at<166>().as_bytes(); }
  bool has_ext4_ext_map_blocks_exit() const { return at<167>().valid(); }
  ::protozero::ConstBytes ext4_ext_map_blocks_exit() const { return at<167>().as_bytes(); }
  bool has_ext4_ext_put_in_cache() const { return at<168>().valid(); }
  ::protozero::ConstBytes ext4_ext_put_in_cache() const { return at<168>().as_bytes(); }
  bool has_ext4_ext_remove_space() const { return at<169>().valid(); }
  ::protozero::ConstBytes ext4_ext_remove_space() const { return at<169>().as_bytes(); }
  bool has_ext4_ext_remove_space_done() const { return at<170>().valid(); }
  ::protozero::ConstBytes ext4_ext_remove_space_done() const { return at<170>().as_bytes(); }
  bool has_ext4_ext_rm_idx() const { return at<171>().valid(); }
  ::protozero::ConstBytes ext4_ext_rm_idx() const { return at<171>().as_bytes(); }
  bool has_ext4_ext_rm_leaf() const { return at<172>().valid(); }
  ::protozero::ConstBytes ext4_ext_rm_leaf() const { return at<172>().as_bytes(); }
  bool has_ext4_ext_show_extent() const { return at<173>().valid(); }
  ::protozero::ConstBytes ext4_ext_show_extent() const { return at<173>().as_bytes(); }
  bool has_ext4_fallocate_enter() const { return at<174>().valid(); }
  ::protozero::ConstBytes ext4_fallocate_enter() const { return at<174>().as_bytes(); }
  bool has_ext4_fallocate_exit() const { return at<175>().valid(); }
  ::protozero::ConstBytes ext4_fallocate_exit() const { return at<175>().as_bytes(); }
  bool has_ext4_find_delalloc_range() const { return at<176>().valid(); }
  ::protozero::ConstBytes ext4_find_delalloc_range() const { return at<176>().as_bytes(); }
  bool has_ext4_forget() const { return at<177>().valid(); }
  ::protozero::ConstBytes ext4_forget() const { return at<177>().as_bytes(); }
  bool has_ext4_free_blocks() const { return at<178>().valid(); }
  ::protozero::ConstBytes ext4_free_blocks() const { return at<178>().as_bytes(); }
  bool has_ext4_free_inode() const { return at<179>().valid(); }
  ::protozero::ConstBytes ext4_free_inode() const { return at<179>().as_bytes(); }
  bool has_ext4_get_implied_cluster_alloc_exit() const { return at<180>().valid(); }
  ::protozero::ConstBytes ext4_get_implied_cluster_alloc_exit() const { return at<180>().as_bytes(); }
  bool has_ext4_get_reserved_cluster_alloc() const { return at<181>().valid(); }
  ::protozero::ConstBytes ext4_get_reserved_cluster_alloc() const { return at<181>().as_bytes(); }
  bool has_ext4_ind_map_blocks_enter() const { return at<182>().valid(); }
  ::protozero::ConstBytes ext4_ind_map_blocks_enter() const { return at<182>().as_bytes(); }
  bool has_ext4_ind_map_blocks_exit() const { return at<183>().valid(); }
  ::protozero::ConstBytes ext4_ind_map_blocks_exit() const { return at<183>().as_bytes(); }
  bool has_ext4_insert_range() const { return at<184>().valid(); }
  ::protozero::ConstBytes ext4_insert_range() const { return at<184>().as_bytes(); }
  bool has_ext4_invalidatepage() const { return at<185>().valid(); }
  ::protozero::ConstBytes ext4_invalidatepage() const { return at<185>().as_bytes(); }
  bool has_ext4_journal_start() const { return at<186>().valid(); }
  ::protozero::ConstBytes ext4_journal_start() const { return at<186>().as_bytes(); }
  bool has_ext4_journal_start_reserved() const { return at<187>().valid(); }
  ::protozero::ConstBytes ext4_journal_start_reserved() const { return at<187>().as_bytes(); }
  bool has_ext4_journalled_invalidatepage() const { return at<188>().valid(); }
  ::protozero::ConstBytes ext4_journalled_invalidatepage() const { return at<188>().as_bytes(); }
  bool has_ext4_journalled_write_end() const { return at<189>().valid(); }
  ::protozero::ConstBytes ext4_journalled_write_end() const { return at<189>().as_bytes(); }
  bool has_ext4_load_inode() const { return at<190>().valid(); }
  ::protozero::ConstBytes ext4_load_inode() const { return at<190>().as_bytes(); }
  bool has_ext4_load_inode_bitmap() const { return at<191>().valid(); }
  ::protozero::ConstBytes ext4_load_inode_bitmap() const { return at<191>().as_bytes(); }
  bool has_ext4_mark_inode_dirty() const { return at<192>().valid(); }
  ::protozero::ConstBytes ext4_mark_inode_dirty() const { return at<192>().as_bytes(); }
  bool has_ext4_mb_bitmap_load() const { return at<193>().valid(); }
  ::protozero::ConstBytes ext4_mb_bitmap_load() const { return at<193>().as_bytes(); }
  bool has_ext4_mb_buddy_bitmap_load() const { return at<194>().valid(); }
  ::protozero::ConstBytes ext4_mb_buddy_bitmap_load() const { return at<194>().as_bytes(); }
  bool has_ext4_mb_discard_preallocations() const { return at<195>().valid(); }
  ::protozero::ConstBytes ext4_mb_discard_preallocations() const { return at<195>().as_bytes(); }
  bool has_ext4_mb_new_group_pa() const { return at<196>().valid(); }
  ::protozero::ConstBytes ext4_mb_new_group_pa() const { return at<196>().as_bytes(); }
  bool has_ext4_mb_new_inode_pa() const { return at<197>().valid(); }
  ::protozero::ConstBytes ext4_mb_new_inode_pa() const { return at<197>().as_bytes(); }
  bool has_ext4_mb_release_group_pa() const { return at<198>().valid(); }
  ::protozero::ConstBytes ext4_mb_release_group_pa() const { return at<198>().as_bytes(); }
  bool has_ext4_mb_release_inode_pa() const { return at<199>().valid(); }
  ::protozero::ConstBytes ext4_mb_release_inode_pa() const { return at<199>().as_bytes(); }
  bool has_ext4_mballoc_alloc() const { return at<200>().valid(); }
  ::protozero::ConstBytes ext4_mballoc_alloc() const { return at<200>().as_bytes(); }
  bool has_ext4_mballoc_discard() const { return at<201>().valid(); }
  ::protozero::ConstBytes ext4_mballoc_discard() const { return at<201>().as_bytes(); }
  bool has_ext4_mballoc_free() const { return at<202>().valid(); }
  ::protozero::ConstBytes ext4_mballoc_free() const { return at<202>().as_bytes(); }
  bool has_ext4_mballoc_prealloc() const { return at<203>().valid(); }
  ::protozero::ConstBytes ext4_mballoc_prealloc() const { return at<203>().as_bytes(); }
  bool has_ext4_other_inode_update_time() const { return at<204>().valid(); }
  ::protozero::ConstBytes ext4_other_inode_update_time() const { return at<204>().as_bytes(); }
  bool has_ext4_punch_hole() const { return at<205>().valid(); }
  ::protozero::ConstBytes ext4_punch_hole() const { return at<205>().as_bytes(); }
  bool has_ext4_read_block_bitmap_load() const { return at<206>().valid(); }
  ::protozero::ConstBytes ext4_read_block_bitmap_load() const { return at<206>().as_bytes(); }
  bool has_ext4_readpage() const { return at<207>().valid(); }
  ::protozero::ConstBytes ext4_readpage() const { return at<207>().as_bytes(); }
  bool has_ext4_releasepage() const { return at<208>().valid(); }
  ::protozero::ConstBytes ext4_releasepage() const { return at<208>().as_bytes(); }
  bool has_ext4_remove_blocks() const { return at<209>().valid(); }
  ::protozero::ConstBytes ext4_remove_blocks() const { return at<209>().as_bytes(); }
  bool has_ext4_request_blocks() const { return at<210>().valid(); }
  ::protozero::ConstBytes ext4_request_blocks() const { return at<210>().as_bytes(); }
  bool has_ext4_request_inode() const { return at<211>().valid(); }
  ::protozero::ConstBytes ext4_request_inode() const { return at<211>().as_bytes(); }
  bool has_ext4_sync_fs() const { return at<212>().valid(); }
  ::protozero::ConstBytes ext4_sync_fs() const { return at<212>().as_bytes(); }
  bool has_ext4_trim_all_free() const { return at<213>().valid(); }
  ::protozero::ConstBytes ext4_trim_all_free() const { return at<213>().as_bytes(); }
  bool has_ext4_trim_extent() const { return at<214>().valid(); }
  ::protozero::ConstBytes ext4_trim_extent() const { return at<214>().as_bytes(); }
  bool has_ext4_truncate_enter() const { return at<215>().valid(); }
  ::protozero::ConstBytes ext4_truncate_enter() const { return at<215>().as_bytes(); }
  bool has_ext4_truncate_exit() const { return at<216>().valid(); }
  ::protozero::ConstBytes ext4_truncate_exit() const { return at<216>().as_bytes(); }
  bool has_ext4_unlink_enter() const { return at<217>().valid(); }
  ::protozero::ConstBytes ext4_unlink_enter() const { return at<217>().as_bytes(); }
  bool has_ext4_unlink_exit() const { return at<218>().valid(); }
  ::protozero::ConstBytes ext4_unlink_exit() const { return at<218>().as_bytes(); }
  bool has_ext4_write_begin() const { return at<219>().valid(); }
  ::protozero::ConstBytes ext4_write_begin() const { return at<219>().as_bytes(); }
  bool has_ext4_write_end() const { return at<230>().valid(); }
  ::protozero::ConstBytes ext4_write_end() const { return at<230>().as_bytes(); }
  bool has_ext4_writepage() const { return at<231>().valid(); }
  ::protozero::ConstBytes ext4_writepage() const { return at<231>().as_bytes(); }
  bool has_ext4_writepages() const { return at<232>().valid(); }
  ::protozero::ConstBytes ext4_writepages() const { return at<232>().as_bytes(); }
  bool has_ext4_writepages_result() const { return at<233>().valid(); }
  ::protozero::ConstBytes ext4_writepages_result() const { return at<233>().as_bytes(); }
  bool has_ext4_zero_range() const { return at<234>().valid(); }
  ::protozero::ConstBytes ext4_zero_range() const { return at<234>().as_bytes(); }
  bool has_task_newtask() const { return at<235>().valid(); }
  ::protozero::ConstBytes task_newtask() const { return at<235>().as_bytes(); }
  bool has_task_rename() const { return at<236>().valid(); }
  ::protozero::ConstBytes task_rename() const { return at<236>().as_bytes(); }
  bool has_sched_process_exec() const { return at<237>().valid(); }
  ::protozero::ConstBytes sched_process_exec() const { return at<237>().as_bytes(); }
  bool has_sched_process_exit() const { return at<238>().valid(); }
  ::protozero::ConstBytes sched_process_exit() const { return at<238>().as_bytes(); }
  bool has_sched_process_fork() const { return at<239>().valid(); }
  ::protozero::ConstBytes sched_process_fork() const { return at<239>().as_bytes(); }
  bool has_sched_process_free() const { return at<240>().valid(); }
  ::protozero::ConstBytes sched_process_free() const { return at<240>().as_bytes(); }
  bool has_sched_process_hang() const { return at<241>().valid(); }
  ::protozero::ConstBytes sched_process_hang() const { return at<241>().as_bytes(); }
  bool has_sched_process_wait() const { return at<242>().valid(); }
  ::protozero::ConstBytes sched_process_wait() const { return at<242>().as_bytes(); }
  bool has_f2fs_do_submit_bio() const { return at<243>().valid(); }
  ::protozero::ConstBytes f2fs_do_submit_bio() const { return at<243>().as_bytes(); }
  bool has_f2fs_evict_inode() const { return at<244>().valid(); }
  ::protozero::ConstBytes f2fs_evict_inode() const { return at<244>().as_bytes(); }
  bool has_f2fs_fallocate() const { return at<245>().valid(); }
  ::protozero::ConstBytes f2fs_fallocate() const { return at<245>().as_bytes(); }
  bool has_f2fs_get_data_block() const { return at<246>().valid(); }
  ::protozero::ConstBytes f2fs_get_data_block() const { return at<246>().as_bytes(); }
  bool has_f2fs_get_victim() const { return at<247>().valid(); }
  ::protozero::ConstBytes f2fs_get_victim() const { return at<247>().as_bytes(); }
  bool has_f2fs_iget() const { return at<248>().valid(); }
  ::protozero::ConstBytes f2fs_iget() const { return at<248>().as_bytes(); }
  bool has_f2fs_iget_exit() const { return at<249>().valid(); }
  ::protozero::ConstBytes f2fs_iget_exit() const { return at<249>().as_bytes(); }
  bool has_f2fs_new_inode() const { return at<250>().valid(); }
  ::protozero::ConstBytes f2fs_new_inode() const { return at<250>().as_bytes(); }
  bool has_f2fs_readpage() const { return at<251>().valid(); }
  ::protozero::ConstBytes f2fs_readpage() const { return at<251>().as_bytes(); }
  bool has_f2fs_reserve_new_block() const { return at<252>().valid(); }
  ::protozero::ConstBytes f2fs_reserve_new_block() const { return at<252>().as_bytes(); }
  bool has_f2fs_set_page_dirty() const { return at<253>().valid(); }
  ::protozero::ConstBytes f2fs_set_page_dirty() const { return at<253>().as_bytes(); }
  bool has_f2fs_submit_write_page() const { return at<254>().valid(); }
  ::protozero::ConstBytes f2fs_submit_write_page() const { return at<254>().as_bytes(); }
  bool has_f2fs_sync_file_enter() const { return at<255>().valid(); }
  ::protozero::ConstBytes f2fs_sync_file_enter() const { return at<255>().as_bytes(); }
  bool has_f2fs_sync_file_exit() const { return at<256>().valid(); }
  ::protozero::ConstBytes f2fs_sync_file_exit() const { return at<256>().as_bytes(); }
  bool has_f2fs_sync_fs() const { return at<257>().valid(); }
  ::protozero::ConstBytes f2fs_sync_fs() const { return at<257>().as_bytes(); }
  bool has_f2fs_truncate() const { return at<258>().valid(); }
  ::protozero::ConstBytes f2fs_truncate() const { return at<258>().as_bytes(); }
  bool has_f2fs_truncate_blocks_enter() const { return at<259>().valid(); }
  ::protozero::ConstBytes f2fs_truncate_blocks_enter() const { return at<259>().as_bytes(); }
  bool has_f2fs_truncate_blocks_exit() const { return at<260>().valid(); }
  ::protozero::ConstBytes f2fs_truncate_blocks_exit() const { return at<260>().as_bytes(); }
  bool has_f2fs_truncate_data_blocks_range() const { return at<261>().valid(); }
  ::protozero::ConstBytes f2fs_truncate_data_blocks_range() const { return at<261>().as_bytes(); }
  bool has_f2fs_truncate_inode_blocks_enter() const { return at<262>().valid(); }
  ::protozero::ConstBytes f2fs_truncate_inode_blocks_enter() const { return at<262>().as_bytes(); }
  bool has_f2fs_truncate_inode_blocks_exit() const { return at<263>().valid(); }
  ::protozero::ConstBytes f2fs_truncate_inode_blocks_exit() const { return at<263>().as_bytes(); }
  bool has_f2fs_truncate_node() const { return at<264>().valid(); }
  ::protozero::ConstBytes f2fs_truncate_node() const { return at<264>().as_bytes(); }
  bool has_f2fs_truncate_nodes_enter() const { return at<265>().valid(); }
  ::protozero::ConstBytes f2fs_truncate_nodes_enter() const { return at<265>().as_bytes(); }
  bool has_f2fs_truncate_nodes_exit() const { return at<266>().valid(); }
  ::protozero::ConstBytes f2fs_truncate_nodes_exit() const { return at<266>().as_bytes(); }
  bool has_f2fs_truncate_partial_nodes() const { return at<267>().valid(); }
  ::protozero::ConstBytes f2fs_truncate_partial_nodes() const { return at<267>().as_bytes(); }
  bool has_f2fs_unlink_enter() const { return at<268>().valid(); }
  ::protozero::ConstBytes f2fs_unlink_enter() const { return at<268>().as_bytes(); }
  bool has_f2fs_unlink_exit() const { return at<269>().valid(); }
  ::protozero::ConstBytes f2fs_unlink_exit() const { return at<269>().as_bytes(); }
  bool has_f2fs_vm_page_mkwrite() const { return at<270>().valid(); }
  ::protozero::ConstBytes f2fs_vm_page_mkwrite() const { return at<270>().as_bytes(); }
  bool has_f2fs_write_begin() const { return at<271>().valid(); }
  ::protozero::ConstBytes f2fs_write_begin() const { return at<271>().as_bytes(); }
  bool has_f2fs_write_checkpoint() const { return at<272>().valid(); }
  ::protozero::ConstBytes f2fs_write_checkpoint() const { return at<272>().as_bytes(); }
  bool has_f2fs_write_end() const { return at<273>().valid(); }
  ::protozero::ConstBytes f2fs_write_end() const { return at<273>().as_bytes(); }
  bool has_alloc_pages_iommu_end() const { return at<274>().valid(); }
  ::protozero::ConstBytes alloc_pages_iommu_end() const { return at<274>().as_bytes(); }
  bool has_alloc_pages_iommu_fail() const { return at<275>().valid(); }
  ::protozero::ConstBytes alloc_pages_iommu_fail() const { return at<275>().as_bytes(); }
  bool has_alloc_pages_iommu_start() const { return at<276>().valid(); }
  ::protozero::ConstBytes alloc_pages_iommu_start() const { return at<276>().as_bytes(); }
  bool has_alloc_pages_sys_end() const { return at<277>().valid(); }
  ::protozero::ConstBytes alloc_pages_sys_end() const { return at<277>().as_bytes(); }
  bool has_alloc_pages_sys_fail() const { return at<278>().valid(); }
  ::protozero::ConstBytes alloc_pages_sys_fail() const { return at<278>().as_bytes(); }
  bool has_alloc_pages_sys_start() const { return at<279>().valid(); }
  ::protozero::ConstBytes alloc_pages_sys_start() const { return at<279>().as_bytes(); }
  bool has_dma_alloc_contiguous_retry() const { return at<280>().valid(); }
  ::protozero::ConstBytes dma_alloc_contiguous_retry() const { return at<280>().as_bytes(); }
  bool has_iommu_map_range() const { return at<281>().valid(); }
  ::protozero::ConstBytes iommu_map_range() const { return at<281>().as_bytes(); }
  bool has_iommu_sec_ptbl_map_range_end() const { return at<282>().valid(); }
  ::protozero::ConstBytes iommu_sec_ptbl_map_range_end() const { return at<282>().as_bytes(); }
  bool has_iommu_sec_ptbl_map_range_start() const { return at<283>().valid(); }
  ::protozero::ConstBytes iommu_sec_ptbl_map_range_start() const { return at<283>().as_bytes(); }
  bool has_ion_alloc_buffer_end() const { return at<284>().valid(); }
  ::protozero::ConstBytes ion_alloc_buffer_end() const { return at<284>().as_bytes(); }
  bool has_ion_alloc_buffer_fail() const { return at<285>().valid(); }
  ::protozero::ConstBytes ion_alloc_buffer_fail() const { return at<285>().as_bytes(); }
  bool has_ion_alloc_buffer_fallback() const { return at<286>().valid(); }
  ::protozero::ConstBytes ion_alloc_buffer_fallback() const { return at<286>().as_bytes(); }
  bool has_ion_alloc_buffer_start() const { return at<287>().valid(); }
  ::protozero::ConstBytes ion_alloc_buffer_start() const { return at<287>().as_bytes(); }
  bool has_ion_cp_alloc_retry() const { return at<288>().valid(); }
  ::protozero::ConstBytes ion_cp_alloc_retry() const { return at<288>().as_bytes(); }
  bool has_ion_cp_secure_buffer_end() const { return at<289>().valid(); }
  ::protozero::ConstBytes ion_cp_secure_buffer_end() const { return at<289>().as_bytes(); }
  bool has_ion_cp_secure_buffer_start() const { return at<290>().valid(); }
  ::protozero::ConstBytes ion_cp_secure_buffer_start() const { return at<290>().as_bytes(); }
  bool has_ion_prefetching() const { return at<291>().valid(); }
  ::protozero::ConstBytes ion_prefetching() const { return at<291>().as_bytes(); }
  bool has_ion_secure_cma_add_to_pool_end() const { return at<292>().valid(); }
  ::protozero::ConstBytes ion_secure_cma_add_to_pool_end() const { return at<292>().as_bytes(); }
  bool has_ion_secure_cma_add_to_pool_start() const { return at<293>().valid(); }
  ::protozero::ConstBytes ion_secure_cma_add_to_pool_start() const { return at<293>().as_bytes(); }
  bool has_ion_secure_cma_allocate_end() const { return at<294>().valid(); }
  ::protozero::ConstBytes ion_secure_cma_allocate_end() const { return at<294>().as_bytes(); }
  bool has_ion_secure_cma_allocate_start() const { return at<295>().valid(); }
  ::protozero::ConstBytes ion_secure_cma_allocate_start() const { return at<295>().as_bytes(); }
  bool has_ion_secure_cma_shrink_pool_end() const { return at<296>().valid(); }
  ::protozero::ConstBytes ion_secure_cma_shrink_pool_end() const { return at<296>().as_bytes(); }
  bool has_ion_secure_cma_shrink_pool_start() const { return at<297>().valid(); }
  ::protozero::ConstBytes ion_secure_cma_shrink_pool_start() const { return at<297>().as_bytes(); }
  bool has_kfree() const { return at<298>().valid(); }
  ::protozero::ConstBytes kfree() const { return at<298>().as_bytes(); }
  bool has_kmalloc() const { return at<299>().valid(); }
  ::protozero::ConstBytes kmalloc() const { return at<299>().as_bytes(); }
  bool has_kmalloc_node() const { return at<300>().valid(); }
  ::protozero::ConstBytes kmalloc_node() const { return at<300>().as_bytes(); }
  bool has_kmem_cache_alloc() const { return at<301>().valid(); }
  ::protozero::ConstBytes kmem_cache_alloc() const { return at<301>().as_bytes(); }
  bool has_kmem_cache_alloc_node() const { return at<302>().valid(); }
  ::protozero::ConstBytes kmem_cache_alloc_node() const { return at<302>().as_bytes(); }
  bool has_kmem_cache_free() const { return at<303>().valid(); }
  ::protozero::ConstBytes kmem_cache_free() const { return at<303>().as_bytes(); }
  bool has_migrate_pages_end() const { return at<304>().valid(); }
  ::protozero::ConstBytes migrate_pages_end() const { return at<304>().as_bytes(); }
  bool has_migrate_pages_start() const { return at<305>().valid(); }
  ::protozero::ConstBytes migrate_pages_start() const { return at<305>().as_bytes(); }
  bool has_migrate_retry() const { return at<306>().valid(); }
  ::protozero::ConstBytes migrate_retry() const { return at<306>().as_bytes(); }
  bool has_mm_page_alloc() const { return at<307>().valid(); }
  ::protozero::ConstBytes mm_page_alloc() const { return at<307>().as_bytes(); }
  bool has_mm_page_alloc_extfrag() const { return at<308>().valid(); }
  ::protozero::ConstBytes mm_page_alloc_extfrag() const { return at<308>().as_bytes(); }
  bool has_mm_page_alloc_zone_locked() const { return at<309>().valid(); }
  ::protozero::ConstBytes mm_page_alloc_zone_locked() const { return at<309>().as_bytes(); }
  bool has_mm_page_free() const { return at<310>().valid(); }
  ::protozero::ConstBytes mm_page_free() const { return at<310>().as_bytes(); }
  bool has_mm_page_free_batched() const { return at<311>().valid(); }
  ::protozero::ConstBytes mm_page_free_batched() const { return at<311>().as_bytes(); }
  bool has_mm_page_pcpu_drain() const { return at<312>().valid(); }
  ::protozero::ConstBytes mm_page_pcpu_drain() const { return at<312>().as_bytes(); }
  bool has_rss_stat() const { return at<313>().valid(); }
  ::protozero::ConstBytes rss_stat() const { return at<313>().as_bytes(); }
  bool has_ion_heap_shrink() const { return at<314>().valid(); }
  ::protozero::ConstBytes ion_heap_shrink() const { return at<314>().as_bytes(); }
  bool has_ion_heap_grow() const { return at<315>().valid(); }
  ::protozero::ConstBytes ion_heap_grow() const { return at<315>().as_bytes(); }
  bool has_fence_init() const { return at<316>().valid(); }
  ::protozero::ConstBytes fence_init() const { return at<316>().as_bytes(); }
  bool has_fence_destroy() const { return at<317>().valid(); }
  ::protozero::ConstBytes fence_destroy() const { return at<317>().as_bytes(); }
  bool has_fence_enable_signal() const { return at<318>().valid(); }
  ::protozero::ConstBytes fence_enable_signal() const { return at<318>().as_bytes(); }
  bool has_fence_signaled() const { return at<319>().valid(); }
  ::protozero::ConstBytes fence_signaled() const { return at<319>().as_bytes(); }
  bool has_clk_enable() const { return at<320>().valid(); }
  ::protozero::ConstBytes clk_enable() const { return at<320>().as_bytes(); }
  bool has_clk_disable() const { return at<321>().valid(); }
  ::protozero::ConstBytes clk_disable() const { return at<321>().as_bytes(); }
  bool has_clk_set_rate() const { return at<322>().valid(); }
  ::protozero::ConstBytes clk_set_rate() const { return at<322>().as_bytes(); }
  bool has_binder_transaction_alloc_buf() const { return at<323>().valid(); }
  ::protozero::ConstBytes binder_transaction_alloc_buf() const { return at<323>().as_bytes(); }
  bool has_signal_deliver() const { return at<324>().valid(); }
  ::protozero::ConstBytes signal_deliver() const { return at<324>().as_bytes(); }
  bool has_signal_generate() const { return at<325>().valid(); }
  ::protozero::ConstBytes signal_generate() const { return at<325>().as_bytes(); }
  bool has_oom_score_adj_update() const { return at<326>().valid(); }
  ::protozero::ConstBytes oom_score_adj_update() const { return at<326>().as_bytes(); }
  bool has_generic() const { return at<327>().valid(); }
  ::protozero::ConstBytes generic() const { return at<327>().as_bytes(); }
  bool has_mm_event_record() const { return at<328>().valid(); }
  ::protozero::ConstBytes mm_event_record() const { return at<328>().as_bytes(); }
  bool has_sys_enter() const { return at<329>().valid(); }
  ::protozero::ConstBytes sys_enter() const { return at<329>().as_bytes(); }
  bool has_sys_exit() const { return at<330>().valid(); }
  ::protozero::ConstBytes sys_exit() const { return at<330>().as_bytes(); }
  bool has_zero() const { return at<331>().valid(); }
  ::protozero::ConstBytes zero() const { return at<331>().as_bytes(); }
  bool has_gpu_frequency() const { return at<332>().valid(); }
  ::protozero::ConstBytes gpu_frequency() const { return at<332>().as_bytes(); }
};

class FtraceEvent : public ::protozero::Message {
 public:
  using Decoder = FtraceEvent_Decoder;
  enum : int32_t {
    kTimestampFieldNumber = 1,
    kPidFieldNumber = 2,
    kPrintFieldNumber = 3,
    kSchedSwitchFieldNumber = 4,
    kCpuFrequencyFieldNumber = 11,
    kCpuFrequencyLimitsFieldNumber = 12,
    kCpuIdleFieldNumber = 13,
    kClockEnableFieldNumber = 14,
    kClockDisableFieldNumber = 15,
    kClockSetRateFieldNumber = 16,
    kSchedWakeupFieldNumber = 17,
    kSchedBlockedReasonFieldNumber = 18,
    kSchedCpuHotplugFieldNumber = 19,
    kSchedWakingFieldNumber = 20,
    kIpiEntryFieldNumber = 21,
    kIpiExitFieldNumber = 22,
    kIpiRaiseFieldNumber = 23,
    kSoftirqEntryFieldNumber = 24,
    kSoftirqExitFieldNumber = 25,
    kSoftirqRaiseFieldNumber = 26,
    kI2cReadFieldNumber = 27,
    kI2cWriteFieldNumber = 28,
    kI2cResultFieldNumber = 29,
    kI2cReplyFieldNumber = 30,
    kSmbusReadFieldNumber = 31,
    kSmbusWriteFieldNumber = 32,
    kSmbusResultFieldNumber = 33,
    kSmbusReplyFieldNumber = 34,
    kLowmemoryKillFieldNumber = 35,
    kIrqHandlerEntryFieldNumber = 36,
    kIrqHandlerExitFieldNumber = 37,
    kSyncPtFieldNumber = 38,
    kSyncTimelineFieldNumber = 39,
    kSyncWaitFieldNumber = 40,
    kExt4DaWriteBeginFieldNumber = 41,
    kExt4DaWriteEndFieldNumber = 42,
    kExt4SyncFileEnterFieldNumber = 43,
    kExt4SyncFileExitFieldNumber = 44,
    kBlockRqIssueFieldNumber = 45,
    kMmVmscanDirectReclaimBeginFieldNumber = 46,
    kMmVmscanDirectReclaimEndFieldNumber = 47,
    kMmVmscanKswapdWakeFieldNumber = 48,
    kMmVmscanKswapdSleepFieldNumber = 49,
    kBinderTransactionFieldNumber = 50,
    kBinderTransactionReceivedFieldNumber = 51,
    kBinderSetPriorityFieldNumber = 52,
    kBinderLockFieldNumber = 53,
    kBinderLockedFieldNumber = 54,
    kBinderUnlockFieldNumber = 55,
    kWorkqueueActivateWorkFieldNumber = 56,
    kWorkqueueExecuteEndFieldNumber = 57,
    kWorkqueueExecuteStartFieldNumber = 58,
    kWorkqueueQueueWorkFieldNumber = 59,
    kRegulatorDisableFieldNumber = 60,
    kRegulatorDisableCompleteFieldNumber = 61,
    kRegulatorEnableFieldNumber = 62,
    kRegulatorEnableCompleteFieldNumber = 63,
    kRegulatorEnableDelayFieldNumber = 64,
    kRegulatorSetVoltageFieldNumber = 65,
    kRegulatorSetVoltageCompleteFieldNumber = 66,
    kCgroupAttachTaskFieldNumber = 67,
    kCgroupMkdirFieldNumber = 68,
    kCgroupRemountFieldNumber = 69,
    kCgroupRmdirFieldNumber = 70,
    kCgroupTransferTasksFieldNumber = 71,
    kCgroupDestroyRootFieldNumber = 72,
    kCgroupReleaseFieldNumber = 73,
    kCgroupRenameFieldNumber = 74,
    kCgroupSetupRootFieldNumber = 75,
    kMdpCmdKickoffFieldNumber = 76,
    kMdpCommitFieldNumber = 77,
    kMdpPerfSetOtFieldNumber = 78,
    kMdpSsppChangeFieldNumber = 79,
    kTracingMarkWriteFieldNumber = 80,
    kMdpCmdPingpongDoneFieldNumber = 81,
    kMdpCompareBwFieldNumber = 82,
    kMdpPerfSetPanicLutsFieldNumber = 83,
    kMdpSsppSetFieldNumber = 84,
    kMdpCmdReadptrDoneFieldNumber = 85,
    kMdpMisrCrcFieldNumber = 86,
    kMdpPerfSetQosLutsFieldNumber = 87,
    kMdpTraceCounterFieldNumber = 88,
    kMdpCmdReleaseBwFieldNumber = 89,
    kMdpMixerUpdateFieldNumber = 90,
    kMdpPerfSetWmLevelsFieldNumber = 91,
    kMdpVideoUnderrunDoneFieldNumber = 92,
    kMdpCmdWaitPingpongFieldNumber = 93,
    kMdpPerfPrefillCalcFieldNumber = 94,
    kMdpPerfUpdateBusFieldNumber = 95,
    kRotatorBwAoAsContextFieldNumber = 96,
    kMmFilemapAddToPageCacheFieldNumber = 97,
    kMmFilemapDeleteFromPageCacheFieldNumber = 98,
    kMmCompactionBeginFieldNumber = 99,
    kMmCompactionDeferCompactionFieldNumber = 100,
    kMmCompactionDeferredFieldNumber = 101,
    kMmCompactionDeferResetFieldNumber = 102,
    kMmCompactionEndFieldNumber = 103,
    kMmCompactionFinishedFieldNumber = 104,
    kMmCompactionIsolateFreepagesFieldNumber = 105,
    kMmCompactionIsolateMigratepagesFieldNumber = 106,
    kMmCompactionKcompactdSleepFieldNumber = 107,
    kMmCompactionKcompactdWakeFieldNumber = 108,
    kMmCompactionMigratepagesFieldNumber = 109,
    kMmCompactionSuitableFieldNumber = 110,
    kMmCompactionTryToCompactPagesFieldNumber = 111,
    kMmCompactionWakeupKcompactdFieldNumber = 112,
    kSuspendResumeFieldNumber = 113,
    kSchedWakeupNewFieldNumber = 114,
    kBlockBioBackmergeFieldNumber = 115,
    kBlockBioBounceFieldNumber = 116,
    kBlockBioCompleteFieldNumber = 117,
    kBlockBioFrontmergeFieldNumber = 118,
    kBlockBioQueueFieldNumber = 119,
    kBlockBioRemapFieldNumber = 120,
    kBlockDirtyBufferFieldNumber = 121,
    kBlockGetrqFieldNumber = 122,
    kBlockPlugFieldNumber = 123,
    kBlockRqAbortFieldNumber = 124,
    kBlockRqCompleteFieldNumber = 125,
    kBlockRqInsertFieldNumber = 126,
    kBlockRqRemapFieldNumber = 128,
    kBlockRqRequeueFieldNumber = 129,
    kBlockSleeprqFieldNumber = 130,
    kBlockSplitFieldNumber = 131,
    kBlockTouchBufferFieldNumber = 132,
    kBlockUnplugFieldNumber = 133,
    kExt4AllocDaBlocksFieldNumber = 134,
    kExt4AllocateBlocksFieldNumber = 135,
    kExt4AllocateInodeFieldNumber = 136,
    kExt4BeginOrderedTruncateFieldNumber = 137,
    kExt4CollapseRangeFieldNumber = 138,
    kExt4DaReleaseSpaceFieldNumber = 139,
    kExt4DaReserveSpaceFieldNumber = 140,
    kExt4DaUpdateReserveSpaceFieldNumber = 141,
    kExt4DaWritePagesFieldNumber = 142,
    kExt4DaWritePagesExtentFieldNumber = 143,
    kExt4DirectIOEnterFieldNumber = 144,
    kExt4DirectIOExitFieldNumber = 145,
    kExt4DiscardBlocksFieldNumber = 146,
    kExt4DiscardPreallocationsFieldNumber = 147,
    kExt4DropInodeFieldNumber = 148,
    kExt4EsCacheExtentFieldNumber = 149,
    kExt4EsFindDelayedExtentRangeEnterFieldNumber = 150,
    kExt4EsFindDelayedExtentRangeExitFieldNumber = 151,
    kExt4EsInsertExtentFieldNumber = 152,
    kExt4EsLookupExtentEnterFieldNumber = 153,
    kExt4EsLookupExtentExitFieldNumber = 154,
    kExt4EsRemoveExtentFieldNumber = 155,
    kExt4EsShrinkFieldNumber = 156,
    kExt4EsShrinkCountFieldNumber = 157,
    kExt4EsShrinkScanEnterFieldNumber = 158,
    kExt4EsShrinkScanExitFieldNumber = 159,
    kExt4EvictInodeFieldNumber = 160,
    kExt4ExtConvertToInitializedEnterFieldNumber = 161,
    kExt4ExtConvertToInitializedFastpathFieldNumber = 162,
    kExt4ExtHandleUnwrittenExtentsFieldNumber = 163,
    kExt4ExtInCacheFieldNumber = 164,
    kExt4ExtLoadExtentFieldNumber = 165,
    kExt4ExtMapBlocksEnterFieldNumber = 166,
    kExt4ExtMapBlocksExitFieldNumber = 167,
    kExt4ExtPutInCacheFieldNumber = 168,
    kExt4ExtRemoveSpaceFieldNumber = 169,
    kExt4ExtRemoveSpaceDoneFieldNumber = 170,
    kExt4ExtRmIdxFieldNumber = 171,
    kExt4ExtRmLeafFieldNumber = 172,
    kExt4ExtShowExtentFieldNumber = 173,
    kExt4FallocateEnterFieldNumber = 174,
    kExt4FallocateExitFieldNumber = 175,
    kExt4FindDelallocRangeFieldNumber = 176,
    kExt4ForgetFieldNumber = 177,
    kExt4FreeBlocksFieldNumber = 178,
    kExt4FreeInodeFieldNumber = 179,
    kExt4GetImpliedClusterAllocExitFieldNumber = 180,
    kExt4GetReservedClusterAllocFieldNumber = 181,
    kExt4IndMapBlocksEnterFieldNumber = 182,
    kExt4IndMapBlocksExitFieldNumber = 183,
    kExt4InsertRangeFieldNumber = 184,
    kExt4InvalidatepageFieldNumber = 185,
    kExt4JournalStartFieldNumber = 186,
    kExt4JournalStartReservedFieldNumber = 187,
    kExt4JournalledInvalidatepageFieldNumber = 188,
    kExt4JournalledWriteEndFieldNumber = 189,
    kExt4LoadInodeFieldNumber = 190,
    kExt4LoadInodeBitmapFieldNumber = 191,
    kExt4MarkInodeDirtyFieldNumber = 192,
    kExt4MbBitmapLoadFieldNumber = 193,
    kExt4MbBuddyBitmapLoadFieldNumber = 194,
    kExt4MbDiscardPreallocationsFieldNumber = 195,
    kExt4MbNewGroupPaFieldNumber = 196,
    kExt4MbNewInodePaFieldNumber = 197,
    kExt4MbReleaseGroupPaFieldNumber = 198,
    kExt4MbReleaseInodePaFieldNumber = 199,
    kExt4MballocAllocFieldNumber = 200,
    kExt4MballocDiscardFieldNumber = 201,
    kExt4MballocFreeFieldNumber = 202,
    kExt4MballocPreallocFieldNumber = 203,
    kExt4OtherInodeUpdateTimeFieldNumber = 204,
    kExt4PunchHoleFieldNumber = 205,
    kExt4ReadBlockBitmapLoadFieldNumber = 206,
    kExt4ReadpageFieldNumber = 207,
    kExt4ReleasepageFieldNumber = 208,
    kExt4RemoveBlocksFieldNumber = 209,
    kExt4RequestBlocksFieldNumber = 210,
    kExt4RequestInodeFieldNumber = 211,
    kExt4SyncFsFieldNumber = 212,
    kExt4TrimAllFreeFieldNumber = 213,
    kExt4TrimExtentFieldNumber = 214,
    kExt4TruncateEnterFieldNumber = 215,
    kExt4TruncateExitFieldNumber = 216,
    kExt4UnlinkEnterFieldNumber = 217,
    kExt4UnlinkExitFieldNumber = 218,
    kExt4WriteBeginFieldNumber = 219,
    kExt4WriteEndFieldNumber = 230,
    kExt4WritepageFieldNumber = 231,
    kExt4WritepagesFieldNumber = 232,
    kExt4WritepagesResultFieldNumber = 233,
    kExt4ZeroRangeFieldNumber = 234,
    kTaskNewtaskFieldNumber = 235,
    kTaskRenameFieldNumber = 236,
    kSchedProcessExecFieldNumber = 237,
    kSchedProcessExitFieldNumber = 238,
    kSchedProcessForkFieldNumber = 239,
    kSchedProcessFreeFieldNumber = 240,
    kSchedProcessHangFieldNumber = 241,
    kSchedProcessWaitFieldNumber = 242,
    kF2fsDoSubmitBioFieldNumber = 243,
    kF2fsEvictInodeFieldNumber = 244,
    kF2fsFallocateFieldNumber = 245,
    kF2fsGetDataBlockFieldNumber = 246,
    kF2fsGetVictimFieldNumber = 247,
    kF2fsIgetFieldNumber = 248,
    kF2fsIgetExitFieldNumber = 249,
    kF2fsNewInodeFieldNumber = 250,
    kF2fsReadpageFieldNumber = 251,
    kF2fsReserveNewBlockFieldNumber = 252,
    kF2fsSetPageDirtyFieldNumber = 253,
    kF2fsSubmitWritePageFieldNumber = 254,
    kF2fsSyncFileEnterFieldNumber = 255,
    kF2fsSyncFileExitFieldNumber = 256,
    kF2fsSyncFsFieldNumber = 257,
    kF2fsTruncateFieldNumber = 258,
    kF2fsTruncateBlocksEnterFieldNumber = 259,
    kF2fsTruncateBlocksExitFieldNumber = 260,
    kF2fsTruncateDataBlocksRangeFieldNumber = 261,
    kF2fsTruncateInodeBlocksEnterFieldNumber = 262,
    kF2fsTruncateInodeBlocksExitFieldNumber = 263,
    kF2fsTruncateNodeFieldNumber = 264,
    kF2fsTruncateNodesEnterFieldNumber = 265,
    kF2fsTruncateNodesExitFieldNumber = 266,
    kF2fsTruncatePartialNodesFieldNumber = 267,
    kF2fsUnlinkEnterFieldNumber = 268,
    kF2fsUnlinkExitFieldNumber = 269,
    kF2fsVmPageMkwriteFieldNumber = 270,
    kF2fsWriteBeginFieldNumber = 271,
    kF2fsWriteCheckpointFieldNumber = 272,
    kF2fsWriteEndFieldNumber = 273,
    kAllocPagesIommuEndFieldNumber = 274,
    kAllocPagesIommuFailFieldNumber = 275,
    kAllocPagesIommuStartFieldNumber = 276,
    kAllocPagesSysEndFieldNumber = 277,
    kAllocPagesSysFailFieldNumber = 278,
    kAllocPagesSysStartFieldNumber = 279,
    kDmaAllocContiguousRetryFieldNumber = 280,
    kIommuMapRangeFieldNumber = 281,
    kIommuSecPtblMapRangeEndFieldNumber = 282,
    kIommuSecPtblMapRangeStartFieldNumber = 283,
    kIonAllocBufferEndFieldNumber = 284,
    kIonAllocBufferFailFieldNumber = 285,
    kIonAllocBufferFallbackFieldNumber = 286,
    kIonAllocBufferStartFieldNumber = 287,
    kIonCpAllocRetryFieldNumber = 288,
    kIonCpSecureBufferEndFieldNumber = 289,
    kIonCpSecureBufferStartFieldNumber = 290,
    kIonPrefetchingFieldNumber = 291,
    kIonSecureCmaAddToPoolEndFieldNumber = 292,
    kIonSecureCmaAddToPoolStartFieldNumber = 293,
    kIonSecureCmaAllocateEndFieldNumber = 294,
    kIonSecureCmaAllocateStartFieldNumber = 295,
    kIonSecureCmaShrinkPoolEndFieldNumber = 296,
    kIonSecureCmaShrinkPoolStartFieldNumber = 297,
    kKfreeFieldNumber = 298,
    kKmallocFieldNumber = 299,
    kKmallocNodeFieldNumber = 300,
    kKmemCacheAllocFieldNumber = 301,
    kKmemCacheAllocNodeFieldNumber = 302,
    kKmemCacheFreeFieldNumber = 303,
    kMigratePagesEndFieldNumber = 304,
    kMigratePagesStartFieldNumber = 305,
    kMigrateRetryFieldNumber = 306,
    kMmPageAllocFieldNumber = 307,
    kMmPageAllocExtfragFieldNumber = 308,
    kMmPageAllocZoneLockedFieldNumber = 309,
    kMmPageFreeFieldNumber = 310,
    kMmPageFreeBatchedFieldNumber = 311,
    kMmPagePcpuDrainFieldNumber = 312,
    kRssStatFieldNumber = 313,
    kIonHeapShrinkFieldNumber = 314,
    kIonHeapGrowFieldNumber = 315,
    kFenceInitFieldNumber = 316,
    kFenceDestroyFieldNumber = 317,
    kFenceEnableSignalFieldNumber = 318,
    kFenceSignaledFieldNumber = 319,
    kClkEnableFieldNumber = 320,
    kClkDisableFieldNumber = 321,
    kClkSetRateFieldNumber = 322,
    kBinderTransactionAllocBufFieldNumber = 323,
    kSignalDeliverFieldNumber = 324,
    kSignalGenerateFieldNumber = 325,
    kOomScoreAdjUpdateFieldNumber = 326,
    kGenericFieldNumber = 327,
    kMmEventRecordFieldNumber = 328,
    kSysEnterFieldNumber = 329,
    kSysExitFieldNumber = 330,
    kZeroFieldNumber = 331,
    kGpuFrequencyFieldNumber = 332,
  };
  void set_timestamp(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_pid(uint32_t value) {
    AppendVarInt(2, value);
  }
  template <typename T = PrintFtraceEvent> T* set_print() {
    return BeginNestedMessage<T>(3);
  }

  template <typename T = SchedSwitchFtraceEvent> T* set_sched_switch() {
    return BeginNestedMessage<T>(4);
  }

  template <typename T = CpuFrequencyFtraceEvent> T* set_cpu_frequency() {
    return BeginNestedMessage<T>(11);
  }

  template <typename T = CpuFrequencyLimitsFtraceEvent> T* set_cpu_frequency_limits() {
    return BeginNestedMessage<T>(12);
  }

  template <typename T = CpuIdleFtraceEvent> T* set_cpu_idle() {
    return BeginNestedMessage<T>(13);
  }

  template <typename T = ClockEnableFtraceEvent> T* set_clock_enable() {
    return BeginNestedMessage<T>(14);
  }

  template <typename T = ClockDisableFtraceEvent> T* set_clock_disable() {
    return BeginNestedMessage<T>(15);
  }

  template <typename T = ClockSetRateFtraceEvent> T* set_clock_set_rate() {
    return BeginNestedMessage<T>(16);
  }

  template <typename T = SchedWakeupFtraceEvent> T* set_sched_wakeup() {
    return BeginNestedMessage<T>(17);
  }

  template <typename T = SchedBlockedReasonFtraceEvent> T* set_sched_blocked_reason() {
    return BeginNestedMessage<T>(18);
  }

  template <typename T = SchedCpuHotplugFtraceEvent> T* set_sched_cpu_hotplug() {
    return BeginNestedMessage<T>(19);
  }

  template <typename T = SchedWakingFtraceEvent> T* set_sched_waking() {
    return BeginNestedMessage<T>(20);
  }

  template <typename T = IpiEntryFtraceEvent> T* set_ipi_entry() {
    return BeginNestedMessage<T>(21);
  }

  template <typename T = IpiExitFtraceEvent> T* set_ipi_exit() {
    return BeginNestedMessage<T>(22);
  }

  template <typename T = IpiRaiseFtraceEvent> T* set_ipi_raise() {
    return BeginNestedMessage<T>(23);
  }

  template <typename T = SoftirqEntryFtraceEvent> T* set_softirq_entry() {
    return BeginNestedMessage<T>(24);
  }

  template <typename T = SoftirqExitFtraceEvent> T* set_softirq_exit() {
    return BeginNestedMessage<T>(25);
  }

  template <typename T = SoftirqRaiseFtraceEvent> T* set_softirq_raise() {
    return BeginNestedMessage<T>(26);
  }

  template <typename T = I2cReadFtraceEvent> T* set_i2c_read() {
    return BeginNestedMessage<T>(27);
  }

  template <typename T = I2cWriteFtraceEvent> T* set_i2c_write() {
    return BeginNestedMessage<T>(28);
  }

  template <typename T = I2cResultFtraceEvent> T* set_i2c_result() {
    return BeginNestedMessage<T>(29);
  }

  template <typename T = I2cReplyFtraceEvent> T* set_i2c_reply() {
    return BeginNestedMessage<T>(30);
  }

  template <typename T = SmbusReadFtraceEvent> T* set_smbus_read() {
    return BeginNestedMessage<T>(31);
  }

  template <typename T = SmbusWriteFtraceEvent> T* set_smbus_write() {
    return BeginNestedMessage<T>(32);
  }

  template <typename T = SmbusResultFtraceEvent> T* set_smbus_result() {
    return BeginNestedMessage<T>(33);
  }

  template <typename T = SmbusReplyFtraceEvent> T* set_smbus_reply() {
    return BeginNestedMessage<T>(34);
  }

  template <typename T = LowmemoryKillFtraceEvent> T* set_lowmemory_kill() {
    return BeginNestedMessage<T>(35);
  }

  template <typename T = IrqHandlerEntryFtraceEvent> T* set_irq_handler_entry() {
    return BeginNestedMessage<T>(36);
  }

  template <typename T = IrqHandlerExitFtraceEvent> T* set_irq_handler_exit() {
    return BeginNestedMessage<T>(37);
  }

  template <typename T = SyncPtFtraceEvent> T* set_sync_pt() {
    return BeginNestedMessage<T>(38);
  }

  template <typename T = SyncTimelineFtraceEvent> T* set_sync_timeline() {
    return BeginNestedMessage<T>(39);
  }

  template <typename T = SyncWaitFtraceEvent> T* set_sync_wait() {
    return BeginNestedMessage<T>(40);
  }

  template <typename T = Ext4DaWriteBeginFtraceEvent> T* set_ext4_da_write_begin() {
    return BeginNestedMessage<T>(41);
  }

  template <typename T = Ext4DaWriteEndFtraceEvent> T* set_ext4_da_write_end() {
    return BeginNestedMessage<T>(42);
  }

  template <typename T = Ext4SyncFileEnterFtraceEvent> T* set_ext4_sync_file_enter() {
    return BeginNestedMessage<T>(43);
  }

  template <typename T = Ext4SyncFileExitFtraceEvent> T* set_ext4_sync_file_exit() {
    return BeginNestedMessage<T>(44);
  }

  template <typename T = BlockRqIssueFtraceEvent> T* set_block_rq_issue() {
    return BeginNestedMessage<T>(45);
  }

  template <typename T = MmVmscanDirectReclaimBeginFtraceEvent> T* set_mm_vmscan_direct_reclaim_begin() {
    return BeginNestedMessage<T>(46);
  }

  template <typename T = MmVmscanDirectReclaimEndFtraceEvent> T* set_mm_vmscan_direct_reclaim_end() {
    return BeginNestedMessage<T>(47);
  }

  template <typename T = MmVmscanKswapdWakeFtraceEvent> T* set_mm_vmscan_kswapd_wake() {
    return BeginNestedMessage<T>(48);
  }

  template <typename T = MmVmscanKswapdSleepFtraceEvent> T* set_mm_vmscan_kswapd_sleep() {
    return BeginNestedMessage<T>(49);
  }

  template <typename T = BinderTransactionFtraceEvent> T* set_binder_transaction() {
    return BeginNestedMessage<T>(50);
  }

  template <typename T = BinderTransactionReceivedFtraceEvent> T* set_binder_transaction_received() {
    return BeginNestedMessage<T>(51);
  }

  template <typename T = BinderSetPriorityFtraceEvent> T* set_binder_set_priority() {
    return BeginNestedMessage<T>(52);
  }

  template <typename T = BinderLockFtraceEvent> T* set_binder_lock() {
    return BeginNestedMessage<T>(53);
  }

  template <typename T = BinderLockedFtraceEvent> T* set_binder_locked() {
    return BeginNestedMessage<T>(54);
  }

  template <typename T = BinderUnlockFtraceEvent> T* set_binder_unlock() {
    return BeginNestedMessage<T>(55);
  }

  template <typename T = WorkqueueActivateWorkFtraceEvent> T* set_workqueue_activate_work() {
    return BeginNestedMessage<T>(56);
  }

  template <typename T = WorkqueueExecuteEndFtraceEvent> T* set_workqueue_execute_end() {
    return BeginNestedMessage<T>(57);
  }

  template <typename T = WorkqueueExecuteStartFtraceEvent> T* set_workqueue_execute_start() {
    return BeginNestedMessage<T>(58);
  }

  template <typename T = WorkqueueQueueWorkFtraceEvent> T* set_workqueue_queue_work() {
    return BeginNestedMessage<T>(59);
  }

  template <typename T = RegulatorDisableFtraceEvent> T* set_regulator_disable() {
    return BeginNestedMessage<T>(60);
  }

  template <typename T = RegulatorDisableCompleteFtraceEvent> T* set_regulator_disable_complete() {
    return BeginNestedMessage<T>(61);
  }

  template <typename T = RegulatorEnableFtraceEvent> T* set_regulator_enable() {
    return BeginNestedMessage<T>(62);
  }

  template <typename T = RegulatorEnableCompleteFtraceEvent> T* set_regulator_enable_complete() {
    return BeginNestedMessage<T>(63);
  }

  template <typename T = RegulatorEnableDelayFtraceEvent> T* set_regulator_enable_delay() {
    return BeginNestedMessage<T>(64);
  }

  template <typename T = RegulatorSetVoltageFtraceEvent> T* set_regulator_set_voltage() {
    return BeginNestedMessage<T>(65);
  }

  template <typename T = RegulatorSetVoltageCompleteFtraceEvent> T* set_regulator_set_voltage_complete() {
    return BeginNestedMessage<T>(66);
  }

  template <typename T = CgroupAttachTaskFtraceEvent> T* set_cgroup_attach_task() {
    return BeginNestedMessage<T>(67);
  }

  template <typename T = CgroupMkdirFtraceEvent> T* set_cgroup_mkdir() {
    return BeginNestedMessage<T>(68);
  }

  template <typename T = CgroupRemountFtraceEvent> T* set_cgroup_remount() {
    return BeginNestedMessage<T>(69);
  }

  template <typename T = CgroupRmdirFtraceEvent> T* set_cgroup_rmdir() {
    return BeginNestedMessage<T>(70);
  }

  template <typename T = CgroupTransferTasksFtraceEvent> T* set_cgroup_transfer_tasks() {
    return BeginNestedMessage<T>(71);
  }

  template <typename T = CgroupDestroyRootFtraceEvent> T* set_cgroup_destroy_root() {
    return BeginNestedMessage<T>(72);
  }

  template <typename T = CgroupReleaseFtraceEvent> T* set_cgroup_release() {
    return BeginNestedMessage<T>(73);
  }

  template <typename T = CgroupRenameFtraceEvent> T* set_cgroup_rename() {
    return BeginNestedMessage<T>(74);
  }

  template <typename T = CgroupSetupRootFtraceEvent> T* set_cgroup_setup_root() {
    return BeginNestedMessage<T>(75);
  }

  template <typename T = MdpCmdKickoffFtraceEvent> T* set_mdp_cmd_kickoff() {
    return BeginNestedMessage<T>(76);
  }

  template <typename T = MdpCommitFtraceEvent> T* set_mdp_commit() {
    return BeginNestedMessage<T>(77);
  }

  template <typename T = MdpPerfSetOtFtraceEvent> T* set_mdp_perf_set_ot() {
    return BeginNestedMessage<T>(78);
  }

  template <typename T = MdpSsppChangeFtraceEvent> T* set_mdp_sspp_change() {
    return BeginNestedMessage<T>(79);
  }

  template <typename T = TracingMarkWriteFtraceEvent> T* set_tracing_mark_write() {
    return BeginNestedMessage<T>(80);
  }

  template <typename T = MdpCmdPingpongDoneFtraceEvent> T* set_mdp_cmd_pingpong_done() {
    return BeginNestedMessage<T>(81);
  }

  template <typename T = MdpCompareBwFtraceEvent> T* set_mdp_compare_bw() {
    return BeginNestedMessage<T>(82);
  }

  template <typename T = MdpPerfSetPanicLutsFtraceEvent> T* set_mdp_perf_set_panic_luts() {
    return BeginNestedMessage<T>(83);
  }

  template <typename T = MdpSsppSetFtraceEvent> T* set_mdp_sspp_set() {
    return BeginNestedMessage<T>(84);
  }

  template <typename T = MdpCmdReadptrDoneFtraceEvent> T* set_mdp_cmd_readptr_done() {
    return BeginNestedMessage<T>(85);
  }

  template <typename T = MdpMisrCrcFtraceEvent> T* set_mdp_misr_crc() {
    return BeginNestedMessage<T>(86);
  }

  template <typename T = MdpPerfSetQosLutsFtraceEvent> T* set_mdp_perf_set_qos_luts() {
    return BeginNestedMessage<T>(87);
  }

  template <typename T = MdpTraceCounterFtraceEvent> T* set_mdp_trace_counter() {
    return BeginNestedMessage<T>(88);
  }

  template <typename T = MdpCmdReleaseBwFtraceEvent> T* set_mdp_cmd_release_bw() {
    return BeginNestedMessage<T>(89);
  }

  template <typename T = MdpMixerUpdateFtraceEvent> T* set_mdp_mixer_update() {
    return BeginNestedMessage<T>(90);
  }

  template <typename T = MdpPerfSetWmLevelsFtraceEvent> T* set_mdp_perf_set_wm_levels() {
    return BeginNestedMessage<T>(91);
  }

  template <typename T = MdpVideoUnderrunDoneFtraceEvent> T* set_mdp_video_underrun_done() {
    return BeginNestedMessage<T>(92);
  }

  template <typename T = MdpCmdWaitPingpongFtraceEvent> T* set_mdp_cmd_wait_pingpong() {
    return BeginNestedMessage<T>(93);
  }

  template <typename T = MdpPerfPrefillCalcFtraceEvent> T* set_mdp_perf_prefill_calc() {
    return BeginNestedMessage<T>(94);
  }

  template <typename T = MdpPerfUpdateBusFtraceEvent> T* set_mdp_perf_update_bus() {
    return BeginNestedMessage<T>(95);
  }

  template <typename T = RotatorBwAoAsContextFtraceEvent> T* set_rotator_bw_ao_as_context() {
    return BeginNestedMessage<T>(96);
  }

  template <typename T = MmFilemapAddToPageCacheFtraceEvent> T* set_mm_filemap_add_to_page_cache() {
    return BeginNestedMessage<T>(97);
  }

  template <typename T = MmFilemapDeleteFromPageCacheFtraceEvent> T* set_mm_filemap_delete_from_page_cache() {
    return BeginNestedMessage<T>(98);
  }

  template <typename T = MmCompactionBeginFtraceEvent> T* set_mm_compaction_begin() {
    return BeginNestedMessage<T>(99);
  }

  template <typename T = MmCompactionDeferCompactionFtraceEvent> T* set_mm_compaction_defer_compaction() {
    return BeginNestedMessage<T>(100);
  }

  template <typename T = MmCompactionDeferredFtraceEvent> T* set_mm_compaction_deferred() {
    return BeginNestedMessage<T>(101);
  }

  template <typename T = MmCompactionDeferResetFtraceEvent> T* set_mm_compaction_defer_reset() {
    return BeginNestedMessage<T>(102);
  }

  template <typename T = MmCompactionEndFtraceEvent> T* set_mm_compaction_end() {
    return BeginNestedMessage<T>(103);
  }

  template <typename T = MmCompactionFinishedFtraceEvent> T* set_mm_compaction_finished() {
    return BeginNestedMessage<T>(104);
  }

  template <typename T = MmCompactionIsolateFreepagesFtraceEvent> T* set_mm_compaction_isolate_freepages() {
    return BeginNestedMessage<T>(105);
  }

  template <typename T = MmCompactionIsolateMigratepagesFtraceEvent> T* set_mm_compaction_isolate_migratepages() {
    return BeginNestedMessage<T>(106);
  }

  template <typename T = MmCompactionKcompactdSleepFtraceEvent> T* set_mm_compaction_kcompactd_sleep() {
    return BeginNestedMessage<T>(107);
  }

  template <typename T = MmCompactionKcompactdWakeFtraceEvent> T* set_mm_compaction_kcompactd_wake() {
    return BeginNestedMessage<T>(108);
  }

  template <typename T = MmCompactionMigratepagesFtraceEvent> T* set_mm_compaction_migratepages() {
    return BeginNestedMessage<T>(109);
  }

  template <typename T = MmCompactionSuitableFtraceEvent> T* set_mm_compaction_suitable() {
    return BeginNestedMessage<T>(110);
  }

  template <typename T = MmCompactionTryToCompactPagesFtraceEvent> T* set_mm_compaction_try_to_compact_pages() {
    return BeginNestedMessage<T>(111);
  }

  template <typename T = MmCompactionWakeupKcompactdFtraceEvent> T* set_mm_compaction_wakeup_kcompactd() {
    return BeginNestedMessage<T>(112);
  }

  template <typename T = SuspendResumeFtraceEvent> T* set_suspend_resume() {
    return BeginNestedMessage<T>(113);
  }

  template <typename T = SchedWakeupNewFtraceEvent> T* set_sched_wakeup_new() {
    return BeginNestedMessage<T>(114);
  }

  template <typename T = BlockBioBackmergeFtraceEvent> T* set_block_bio_backmerge() {
    return BeginNestedMessage<T>(115);
  }

  template <typename T = BlockBioBounceFtraceEvent> T* set_block_bio_bounce() {
    return BeginNestedMessage<T>(116);
  }

  template <typename T = BlockBioCompleteFtraceEvent> T* set_block_bio_complete() {
    return BeginNestedMessage<T>(117);
  }

  template <typename T = BlockBioFrontmergeFtraceEvent> T* set_block_bio_frontmerge() {
    return BeginNestedMessage<T>(118);
  }

  template <typename T = BlockBioQueueFtraceEvent> T* set_block_bio_queue() {
    return BeginNestedMessage<T>(119);
  }

  template <typename T = BlockBioRemapFtraceEvent> T* set_block_bio_remap() {
    return BeginNestedMessage<T>(120);
  }

  template <typename T = BlockDirtyBufferFtraceEvent> T* set_block_dirty_buffer() {
    return BeginNestedMessage<T>(121);
  }

  template <typename T = BlockGetrqFtraceEvent> T* set_block_getrq() {
    return BeginNestedMessage<T>(122);
  }

  template <typename T = BlockPlugFtraceEvent> T* set_block_plug() {
    return BeginNestedMessage<T>(123);
  }

  template <typename T = BlockRqAbortFtraceEvent> T* set_block_rq_abort() {
    return BeginNestedMessage<T>(124);
  }

  template <typename T = BlockRqCompleteFtraceEvent> T* set_block_rq_complete() {
    return BeginNestedMessage<T>(125);
  }

  template <typename T = BlockRqInsertFtraceEvent> T* set_block_rq_insert() {
    return BeginNestedMessage<T>(126);
  }

  template <typename T = BlockRqRemapFtraceEvent> T* set_block_rq_remap() {
    return BeginNestedMessage<T>(128);
  }

  template <typename T = BlockRqRequeueFtraceEvent> T* set_block_rq_requeue() {
    return BeginNestedMessage<T>(129);
  }

  template <typename T = BlockSleeprqFtraceEvent> T* set_block_sleeprq() {
    return BeginNestedMessage<T>(130);
  }

  template <typename T = BlockSplitFtraceEvent> T* set_block_split() {
    return BeginNestedMessage<T>(131);
  }

  template <typename T = BlockTouchBufferFtraceEvent> T* set_block_touch_buffer() {
    return BeginNestedMessage<T>(132);
  }

  template <typename T = BlockUnplugFtraceEvent> T* set_block_unplug() {
    return BeginNestedMessage<T>(133);
  }

  template <typename T = Ext4AllocDaBlocksFtraceEvent> T* set_ext4_alloc_da_blocks() {
    return BeginNestedMessage<T>(134);
  }

  template <typename T = Ext4AllocateBlocksFtraceEvent> T* set_ext4_allocate_blocks() {
    return BeginNestedMessage<T>(135);
  }

  template <typename T = Ext4AllocateInodeFtraceEvent> T* set_ext4_allocate_inode() {
    return BeginNestedMessage<T>(136);
  }

  template <typename T = Ext4BeginOrderedTruncateFtraceEvent> T* set_ext4_begin_ordered_truncate() {
    return BeginNestedMessage<T>(137);
  }

  template <typename T = Ext4CollapseRangeFtraceEvent> T* set_ext4_collapse_range() {
    return BeginNestedMessage<T>(138);
  }

  template <typename T = Ext4DaReleaseSpaceFtraceEvent> T* set_ext4_da_release_space() {
    return BeginNestedMessage<T>(139);
  }

  template <typename T = Ext4DaReserveSpaceFtraceEvent> T* set_ext4_da_reserve_space() {
    return BeginNestedMessage<T>(140);
  }

  template <typename T = Ext4DaUpdateReserveSpaceFtraceEvent> T* set_ext4_da_update_reserve_space() {
    return BeginNestedMessage<T>(141);
  }

  template <typename T = Ext4DaWritePagesFtraceEvent> T* set_ext4_da_write_pages() {
    return BeginNestedMessage<T>(142);
  }

  template <typename T = Ext4DaWritePagesExtentFtraceEvent> T* set_ext4_da_write_pages_extent() {
    return BeginNestedMessage<T>(143);
  }

  template <typename T = Ext4DirectIOEnterFtraceEvent> T* set_ext4_direct_io_enter() {
    return BeginNestedMessage<T>(144);
  }

  template <typename T = Ext4DirectIOExitFtraceEvent> T* set_ext4_direct_io_exit() {
    return BeginNestedMessage<T>(145);
  }

  template <typename T = Ext4DiscardBlocksFtraceEvent> T* set_ext4_discard_blocks() {
    return BeginNestedMessage<T>(146);
  }

  template <typename T = Ext4DiscardPreallocationsFtraceEvent> T* set_ext4_discard_preallocations() {
    return BeginNestedMessage<T>(147);
  }

  template <typename T = Ext4DropInodeFtraceEvent> T* set_ext4_drop_inode() {
    return BeginNestedMessage<T>(148);
  }

  template <typename T = Ext4EsCacheExtentFtraceEvent> T* set_ext4_es_cache_extent() {
    return BeginNestedMessage<T>(149);
  }

  template <typename T = Ext4EsFindDelayedExtentRangeEnterFtraceEvent> T* set_ext4_es_find_delayed_extent_range_enter() {
    return BeginNestedMessage<T>(150);
  }

  template <typename T = Ext4EsFindDelayedExtentRangeExitFtraceEvent> T* set_ext4_es_find_delayed_extent_range_exit() {
    return BeginNestedMessage<T>(151);
  }

  template <typename T = Ext4EsInsertExtentFtraceEvent> T* set_ext4_es_insert_extent() {
    return BeginNestedMessage<T>(152);
  }

  template <typename T = Ext4EsLookupExtentEnterFtraceEvent> T* set_ext4_es_lookup_extent_enter() {
    return BeginNestedMessage<T>(153);
  }

  template <typename T = Ext4EsLookupExtentExitFtraceEvent> T* set_ext4_es_lookup_extent_exit() {
    return BeginNestedMessage<T>(154);
  }

  template <typename T = Ext4EsRemoveExtentFtraceEvent> T* set_ext4_es_remove_extent() {
    return BeginNestedMessage<T>(155);
  }

  template <typename T = Ext4EsShrinkFtraceEvent> T* set_ext4_es_shrink() {
    return BeginNestedMessage<T>(156);
  }

  template <typename T = Ext4EsShrinkCountFtraceEvent> T* set_ext4_es_shrink_count() {
    return BeginNestedMessage<T>(157);
  }

  template <typename T = Ext4EsShrinkScanEnterFtraceEvent> T* set_ext4_es_shrink_scan_enter() {
    return BeginNestedMessage<T>(158);
  }

  template <typename T = Ext4EsShrinkScanExitFtraceEvent> T* set_ext4_es_shrink_scan_exit() {
    return BeginNestedMessage<T>(159);
  }

  template <typename T = Ext4EvictInodeFtraceEvent> T* set_ext4_evict_inode() {
    return BeginNestedMessage<T>(160);
  }

  template <typename T = Ext4ExtConvertToInitializedEnterFtraceEvent> T* set_ext4_ext_convert_to_initialized_enter() {
    return BeginNestedMessage<T>(161);
  }

  template <typename T = Ext4ExtConvertToInitializedFastpathFtraceEvent> T* set_ext4_ext_convert_to_initialized_fastpath() {
    return BeginNestedMessage<T>(162);
  }

  template <typename T = Ext4ExtHandleUnwrittenExtentsFtraceEvent> T* set_ext4_ext_handle_unwritten_extents() {
    return BeginNestedMessage<T>(163);
  }

  template <typename T = Ext4ExtInCacheFtraceEvent> T* set_ext4_ext_in_cache() {
    return BeginNestedMessage<T>(164);
  }

  template <typename T = Ext4ExtLoadExtentFtraceEvent> T* set_ext4_ext_load_extent() {
    return BeginNestedMessage<T>(165);
  }

  template <typename T = Ext4ExtMapBlocksEnterFtraceEvent> T* set_ext4_ext_map_blocks_enter() {
    return BeginNestedMessage<T>(166);
  }

  template <typename T = Ext4ExtMapBlocksExitFtraceEvent> T* set_ext4_ext_map_blocks_exit() {
    return BeginNestedMessage<T>(167);
  }

  template <typename T = Ext4ExtPutInCacheFtraceEvent> T* set_ext4_ext_put_in_cache() {
    return BeginNestedMessage<T>(168);
  }

  template <typename T = Ext4ExtRemoveSpaceFtraceEvent> T* set_ext4_ext_remove_space() {
    return BeginNestedMessage<T>(169);
  }

  template <typename T = Ext4ExtRemoveSpaceDoneFtraceEvent> T* set_ext4_ext_remove_space_done() {
    return BeginNestedMessage<T>(170);
  }

  template <typename T = Ext4ExtRmIdxFtraceEvent> T* set_ext4_ext_rm_idx() {
    return BeginNestedMessage<T>(171);
  }

  template <typename T = Ext4ExtRmLeafFtraceEvent> T* set_ext4_ext_rm_leaf() {
    return BeginNestedMessage<T>(172);
  }

  template <typename T = Ext4ExtShowExtentFtraceEvent> T* set_ext4_ext_show_extent() {
    return BeginNestedMessage<T>(173);
  }

  template <typename T = Ext4FallocateEnterFtraceEvent> T* set_ext4_fallocate_enter() {
    return BeginNestedMessage<T>(174);
  }

  template <typename T = Ext4FallocateExitFtraceEvent> T* set_ext4_fallocate_exit() {
    return BeginNestedMessage<T>(175);
  }

  template <typename T = Ext4FindDelallocRangeFtraceEvent> T* set_ext4_find_delalloc_range() {
    return BeginNestedMessage<T>(176);
  }

  template <typename T = Ext4ForgetFtraceEvent> T* set_ext4_forget() {
    return BeginNestedMessage<T>(177);
  }

  template <typename T = Ext4FreeBlocksFtraceEvent> T* set_ext4_free_blocks() {
    return BeginNestedMessage<T>(178);
  }

  template <typename T = Ext4FreeInodeFtraceEvent> T* set_ext4_free_inode() {
    return BeginNestedMessage<T>(179);
  }

  template <typename T = Ext4GetImpliedClusterAllocExitFtraceEvent> T* set_ext4_get_implied_cluster_alloc_exit() {
    return BeginNestedMessage<T>(180);
  }

  template <typename T = Ext4GetReservedClusterAllocFtraceEvent> T* set_ext4_get_reserved_cluster_alloc() {
    return BeginNestedMessage<T>(181);
  }

  template <typename T = Ext4IndMapBlocksEnterFtraceEvent> T* set_ext4_ind_map_blocks_enter() {
    return BeginNestedMessage<T>(182);
  }

  template <typename T = Ext4IndMapBlocksExitFtraceEvent> T* set_ext4_ind_map_blocks_exit() {
    return BeginNestedMessage<T>(183);
  }

  template <typename T = Ext4InsertRangeFtraceEvent> T* set_ext4_insert_range() {
    return BeginNestedMessage<T>(184);
  }

  template <typename T = Ext4InvalidatepageFtraceEvent> T* set_ext4_invalidatepage() {
    return BeginNestedMessage<T>(185);
  }

  template <typename T = Ext4JournalStartFtraceEvent> T* set_ext4_journal_start() {
    return BeginNestedMessage<T>(186);
  }

  template <typename T = Ext4JournalStartReservedFtraceEvent> T* set_ext4_journal_start_reserved() {
    return BeginNestedMessage<T>(187);
  }

  template <typename T = Ext4JournalledInvalidatepageFtraceEvent> T* set_ext4_journalled_invalidatepage() {
    return BeginNestedMessage<T>(188);
  }

  template <typename T = Ext4JournalledWriteEndFtraceEvent> T* set_ext4_journalled_write_end() {
    return BeginNestedMessage<T>(189);
  }

  template <typename T = Ext4LoadInodeFtraceEvent> T* set_ext4_load_inode() {
    return BeginNestedMessage<T>(190);
  }

  template <typename T = Ext4LoadInodeBitmapFtraceEvent> T* set_ext4_load_inode_bitmap() {
    return BeginNestedMessage<T>(191);
  }

  template <typename T = Ext4MarkInodeDirtyFtraceEvent> T* set_ext4_mark_inode_dirty() {
    return BeginNestedMessage<T>(192);
  }

  template <typename T = Ext4MbBitmapLoadFtraceEvent> T* set_ext4_mb_bitmap_load() {
    return BeginNestedMessage<T>(193);
  }

  template <typename T = Ext4MbBuddyBitmapLoadFtraceEvent> T* set_ext4_mb_buddy_bitmap_load() {
    return BeginNestedMessage<T>(194);
  }

  template <typename T = Ext4MbDiscardPreallocationsFtraceEvent> T* set_ext4_mb_discard_preallocations() {
    return BeginNestedMessage<T>(195);
  }

  template <typename T = Ext4MbNewGroupPaFtraceEvent> T* set_ext4_mb_new_group_pa() {
    return BeginNestedMessage<T>(196);
  }

  template <typename T = Ext4MbNewInodePaFtraceEvent> T* set_ext4_mb_new_inode_pa() {
    return BeginNestedMessage<T>(197);
  }

  template <typename T = Ext4MbReleaseGroupPaFtraceEvent> T* set_ext4_mb_release_group_pa() {
    return BeginNestedMessage<T>(198);
  }

  template <typename T = Ext4MbReleaseInodePaFtraceEvent> T* set_ext4_mb_release_inode_pa() {
    return BeginNestedMessage<T>(199);
  }

  template <typename T = Ext4MballocAllocFtraceEvent> T* set_ext4_mballoc_alloc() {
    return BeginNestedMessage<T>(200);
  }

  template <typename T = Ext4MballocDiscardFtraceEvent> T* set_ext4_mballoc_discard() {
    return BeginNestedMessage<T>(201);
  }

  template <typename T = Ext4MballocFreeFtraceEvent> T* set_ext4_mballoc_free() {
    return BeginNestedMessage<T>(202);
  }

  template <typename T = Ext4MballocPreallocFtraceEvent> T* set_ext4_mballoc_prealloc() {
    return BeginNestedMessage<T>(203);
  }

  template <typename T = Ext4OtherInodeUpdateTimeFtraceEvent> T* set_ext4_other_inode_update_time() {
    return BeginNestedMessage<T>(204);
  }

  template <typename T = Ext4PunchHoleFtraceEvent> T* set_ext4_punch_hole() {
    return BeginNestedMessage<T>(205);
  }

  template <typename T = Ext4ReadBlockBitmapLoadFtraceEvent> T* set_ext4_read_block_bitmap_load() {
    return BeginNestedMessage<T>(206);
  }

  template <typename T = Ext4ReadpageFtraceEvent> T* set_ext4_readpage() {
    return BeginNestedMessage<T>(207);
  }

  template <typename T = Ext4ReleasepageFtraceEvent> T* set_ext4_releasepage() {
    return BeginNestedMessage<T>(208);
  }

  template <typename T = Ext4RemoveBlocksFtraceEvent> T* set_ext4_remove_blocks() {
    return BeginNestedMessage<T>(209);
  }

  template <typename T = Ext4RequestBlocksFtraceEvent> T* set_ext4_request_blocks() {
    return BeginNestedMessage<T>(210);
  }

  template <typename T = Ext4RequestInodeFtraceEvent> T* set_ext4_request_inode() {
    return BeginNestedMessage<T>(211);
  }

  template <typename T = Ext4SyncFsFtraceEvent> T* set_ext4_sync_fs() {
    return BeginNestedMessage<T>(212);
  }

  template <typename T = Ext4TrimAllFreeFtraceEvent> T* set_ext4_trim_all_free() {
    return BeginNestedMessage<T>(213);
  }

  template <typename T = Ext4TrimExtentFtraceEvent> T* set_ext4_trim_extent() {
    return BeginNestedMessage<T>(214);
  }

  template <typename T = Ext4TruncateEnterFtraceEvent> T* set_ext4_truncate_enter() {
    return BeginNestedMessage<T>(215);
  }

  template <typename T = Ext4TruncateExitFtraceEvent> T* set_ext4_truncate_exit() {
    return BeginNestedMessage<T>(216);
  }

  template <typename T = Ext4UnlinkEnterFtraceEvent> T* set_ext4_unlink_enter() {
    return BeginNestedMessage<T>(217);
  }

  template <typename T = Ext4UnlinkExitFtraceEvent> T* set_ext4_unlink_exit() {
    return BeginNestedMessage<T>(218);
  }

  template <typename T = Ext4WriteBeginFtraceEvent> T* set_ext4_write_begin() {
    return BeginNestedMessage<T>(219);
  }

  template <typename T = Ext4WriteEndFtraceEvent> T* set_ext4_write_end() {
    return BeginNestedMessage<T>(230);
  }

  template <typename T = Ext4WritepageFtraceEvent> T* set_ext4_writepage() {
    return BeginNestedMessage<T>(231);
  }

  template <typename T = Ext4WritepagesFtraceEvent> T* set_ext4_writepages() {
    return BeginNestedMessage<T>(232);
  }

  template <typename T = Ext4WritepagesResultFtraceEvent> T* set_ext4_writepages_result() {
    return BeginNestedMessage<T>(233);
  }

  template <typename T = Ext4ZeroRangeFtraceEvent> T* set_ext4_zero_range() {
    return BeginNestedMessage<T>(234);
  }

  template <typename T = TaskNewtaskFtraceEvent> T* set_task_newtask() {
    return BeginNestedMessage<T>(235);
  }

  template <typename T = TaskRenameFtraceEvent> T* set_task_rename() {
    return BeginNestedMessage<T>(236);
  }

  template <typename T = SchedProcessExecFtraceEvent> T* set_sched_process_exec() {
    return BeginNestedMessage<T>(237);
  }

  template <typename T = SchedProcessExitFtraceEvent> T* set_sched_process_exit() {
    return BeginNestedMessage<T>(238);
  }

  template <typename T = SchedProcessForkFtraceEvent> T* set_sched_process_fork() {
    return BeginNestedMessage<T>(239);
  }

  template <typename T = SchedProcessFreeFtraceEvent> T* set_sched_process_free() {
    return BeginNestedMessage<T>(240);
  }

  template <typename T = SchedProcessHangFtraceEvent> T* set_sched_process_hang() {
    return BeginNestedMessage<T>(241);
  }

  template <typename T = SchedProcessWaitFtraceEvent> T* set_sched_process_wait() {
    return BeginNestedMessage<T>(242);
  }

  template <typename T = F2fsDoSubmitBioFtraceEvent> T* set_f2fs_do_submit_bio() {
    return BeginNestedMessage<T>(243);
  }

  template <typename T = F2fsEvictInodeFtraceEvent> T* set_f2fs_evict_inode() {
    return BeginNestedMessage<T>(244);
  }

  template <typename T = F2fsFallocateFtraceEvent> T* set_f2fs_fallocate() {
    return BeginNestedMessage<T>(245);
  }

  template <typename T = F2fsGetDataBlockFtraceEvent> T* set_f2fs_get_data_block() {
    return BeginNestedMessage<T>(246);
  }

  template <typename T = F2fsGetVictimFtraceEvent> T* set_f2fs_get_victim() {
    return BeginNestedMessage<T>(247);
  }

  template <typename T = F2fsIgetFtraceEvent> T* set_f2fs_iget() {
    return BeginNestedMessage<T>(248);
  }

  template <typename T = F2fsIgetExitFtraceEvent> T* set_f2fs_iget_exit() {
    return BeginNestedMessage<T>(249);
  }

  template <typename T = F2fsNewInodeFtraceEvent> T* set_f2fs_new_inode() {
    return BeginNestedMessage<T>(250);
  }

  template <typename T = F2fsReadpageFtraceEvent> T* set_f2fs_readpage() {
    return BeginNestedMessage<T>(251);
  }

  template <typename T = F2fsReserveNewBlockFtraceEvent> T* set_f2fs_reserve_new_block() {
    return BeginNestedMessage<T>(252);
  }

  template <typename T = F2fsSetPageDirtyFtraceEvent> T* set_f2fs_set_page_dirty() {
    return BeginNestedMessage<T>(253);
  }

  template <typename T = F2fsSubmitWritePageFtraceEvent> T* set_f2fs_submit_write_page() {
    return BeginNestedMessage<T>(254);
  }

  template <typename T = F2fsSyncFileEnterFtraceEvent> T* set_f2fs_sync_file_enter() {
    return BeginNestedMessage<T>(255);
  }

  template <typename T = F2fsSyncFileExitFtraceEvent> T* set_f2fs_sync_file_exit() {
    return BeginNestedMessage<T>(256);
  }

  template <typename T = F2fsSyncFsFtraceEvent> T* set_f2fs_sync_fs() {
    return BeginNestedMessage<T>(257);
  }

  template <typename T = F2fsTruncateFtraceEvent> T* set_f2fs_truncate() {
    return BeginNestedMessage<T>(258);
  }

  template <typename T = F2fsTruncateBlocksEnterFtraceEvent> T* set_f2fs_truncate_blocks_enter() {
    return BeginNestedMessage<T>(259);
  }

  template <typename T = F2fsTruncateBlocksExitFtraceEvent> T* set_f2fs_truncate_blocks_exit() {
    return BeginNestedMessage<T>(260);
  }

  template <typename T = F2fsTruncateDataBlocksRangeFtraceEvent> T* set_f2fs_truncate_data_blocks_range() {
    return BeginNestedMessage<T>(261);
  }

  template <typename T = F2fsTruncateInodeBlocksEnterFtraceEvent> T* set_f2fs_truncate_inode_blocks_enter() {
    return BeginNestedMessage<T>(262);
  }

  template <typename T = F2fsTruncateInodeBlocksExitFtraceEvent> T* set_f2fs_truncate_inode_blocks_exit() {
    return BeginNestedMessage<T>(263);
  }

  template <typename T = F2fsTruncateNodeFtraceEvent> T* set_f2fs_truncate_node() {
    return BeginNestedMessage<T>(264);
  }

  template <typename T = F2fsTruncateNodesEnterFtraceEvent> T* set_f2fs_truncate_nodes_enter() {
    return BeginNestedMessage<T>(265);
  }

  template <typename T = F2fsTruncateNodesExitFtraceEvent> T* set_f2fs_truncate_nodes_exit() {
    return BeginNestedMessage<T>(266);
  }

  template <typename T = F2fsTruncatePartialNodesFtraceEvent> T* set_f2fs_truncate_partial_nodes() {
    return BeginNestedMessage<T>(267);
  }

  template <typename T = F2fsUnlinkEnterFtraceEvent> T* set_f2fs_unlink_enter() {
    return BeginNestedMessage<T>(268);
  }

  template <typename T = F2fsUnlinkExitFtraceEvent> T* set_f2fs_unlink_exit() {
    return BeginNestedMessage<T>(269);
  }

  template <typename T = F2fsVmPageMkwriteFtraceEvent> T* set_f2fs_vm_page_mkwrite() {
    return BeginNestedMessage<T>(270);
  }

  template <typename T = F2fsWriteBeginFtraceEvent> T* set_f2fs_write_begin() {
    return BeginNestedMessage<T>(271);
  }

  template <typename T = F2fsWriteCheckpointFtraceEvent> T* set_f2fs_write_checkpoint() {
    return BeginNestedMessage<T>(272);
  }

  template <typename T = F2fsWriteEndFtraceEvent> T* set_f2fs_write_end() {
    return BeginNestedMessage<T>(273);
  }

  template <typename T = AllocPagesIommuEndFtraceEvent> T* set_alloc_pages_iommu_end() {
    return BeginNestedMessage<T>(274);
  }

  template <typename T = AllocPagesIommuFailFtraceEvent> T* set_alloc_pages_iommu_fail() {
    return BeginNestedMessage<T>(275);
  }

  template <typename T = AllocPagesIommuStartFtraceEvent> T* set_alloc_pages_iommu_start() {
    return BeginNestedMessage<T>(276);
  }

  template <typename T = AllocPagesSysEndFtraceEvent> T* set_alloc_pages_sys_end() {
    return BeginNestedMessage<T>(277);
  }

  template <typename T = AllocPagesSysFailFtraceEvent> T* set_alloc_pages_sys_fail() {
    return BeginNestedMessage<T>(278);
  }

  template <typename T = AllocPagesSysStartFtraceEvent> T* set_alloc_pages_sys_start() {
    return BeginNestedMessage<T>(279);
  }

  template <typename T = DmaAllocContiguousRetryFtraceEvent> T* set_dma_alloc_contiguous_retry() {
    return BeginNestedMessage<T>(280);
  }

  template <typename T = IommuMapRangeFtraceEvent> T* set_iommu_map_range() {
    return BeginNestedMessage<T>(281);
  }

  template <typename T = IommuSecPtblMapRangeEndFtraceEvent> T* set_iommu_sec_ptbl_map_range_end() {
    return BeginNestedMessage<T>(282);
  }

  template <typename T = IommuSecPtblMapRangeStartFtraceEvent> T* set_iommu_sec_ptbl_map_range_start() {
    return BeginNestedMessage<T>(283);
  }

  template <typename T = IonAllocBufferEndFtraceEvent> T* set_ion_alloc_buffer_end() {
    return BeginNestedMessage<T>(284);
  }

  template <typename T = IonAllocBufferFailFtraceEvent> T* set_ion_alloc_buffer_fail() {
    return BeginNestedMessage<T>(285);
  }

  template <typename T = IonAllocBufferFallbackFtraceEvent> T* set_ion_alloc_buffer_fallback() {
    return BeginNestedMessage<T>(286);
  }

  template <typename T = IonAllocBufferStartFtraceEvent> T* set_ion_alloc_buffer_start() {
    return BeginNestedMessage<T>(287);
  }

  template <typename T = IonCpAllocRetryFtraceEvent> T* set_ion_cp_alloc_retry() {
    return BeginNestedMessage<T>(288);
  }

  template <typename T = IonCpSecureBufferEndFtraceEvent> T* set_ion_cp_secure_buffer_end() {
    return BeginNestedMessage<T>(289);
  }

  template <typename T = IonCpSecureBufferStartFtraceEvent> T* set_ion_cp_secure_buffer_start() {
    return BeginNestedMessage<T>(290);
  }

  template <typename T = IonPrefetchingFtraceEvent> T* set_ion_prefetching() {
    return BeginNestedMessage<T>(291);
  }

  template <typename T = IonSecureCmaAddToPoolEndFtraceEvent> T* set_ion_secure_cma_add_to_pool_end() {
    return BeginNestedMessage<T>(292);
  }

  template <typename T = IonSecureCmaAddToPoolStartFtraceEvent> T* set_ion_secure_cma_add_to_pool_start() {
    return BeginNestedMessage<T>(293);
  }

  template <typename T = IonSecureCmaAllocateEndFtraceEvent> T* set_ion_secure_cma_allocate_end() {
    return BeginNestedMessage<T>(294);
  }

  template <typename T = IonSecureCmaAllocateStartFtraceEvent> T* set_ion_secure_cma_allocate_start() {
    return BeginNestedMessage<T>(295);
  }

  template <typename T = IonSecureCmaShrinkPoolEndFtraceEvent> T* set_ion_secure_cma_shrink_pool_end() {
    return BeginNestedMessage<T>(296);
  }

  template <typename T = IonSecureCmaShrinkPoolStartFtraceEvent> T* set_ion_secure_cma_shrink_pool_start() {
    return BeginNestedMessage<T>(297);
  }

  template <typename T = KfreeFtraceEvent> T* set_kfree() {
    return BeginNestedMessage<T>(298);
  }

  template <typename T = KmallocFtraceEvent> T* set_kmalloc() {
    return BeginNestedMessage<T>(299);
  }

  template <typename T = KmallocNodeFtraceEvent> T* set_kmalloc_node() {
    return BeginNestedMessage<T>(300);
  }

  template <typename T = KmemCacheAllocFtraceEvent> T* set_kmem_cache_alloc() {
    return BeginNestedMessage<T>(301);
  }

  template <typename T = KmemCacheAllocNodeFtraceEvent> T* set_kmem_cache_alloc_node() {
    return BeginNestedMessage<T>(302);
  }

  template <typename T = KmemCacheFreeFtraceEvent> T* set_kmem_cache_free() {
    return BeginNestedMessage<T>(303);
  }

  template <typename T = MigratePagesEndFtraceEvent> T* set_migrate_pages_end() {
    return BeginNestedMessage<T>(304);
  }

  template <typename T = MigratePagesStartFtraceEvent> T* set_migrate_pages_start() {
    return BeginNestedMessage<T>(305);
  }

  template <typename T = MigrateRetryFtraceEvent> T* set_migrate_retry() {
    return BeginNestedMessage<T>(306);
  }

  template <typename T = MmPageAllocFtraceEvent> T* set_mm_page_alloc() {
    return BeginNestedMessage<T>(307);
  }

  template <typename T = MmPageAllocExtfragFtraceEvent> T* set_mm_page_alloc_extfrag() {
    return BeginNestedMessage<T>(308);
  }

  template <typename T = MmPageAllocZoneLockedFtraceEvent> T* set_mm_page_alloc_zone_locked() {
    return BeginNestedMessage<T>(309);
  }

  template <typename T = MmPageFreeFtraceEvent> T* set_mm_page_free() {
    return BeginNestedMessage<T>(310);
  }

  template <typename T = MmPageFreeBatchedFtraceEvent> T* set_mm_page_free_batched() {
    return BeginNestedMessage<T>(311);
  }

  template <typename T = MmPagePcpuDrainFtraceEvent> T* set_mm_page_pcpu_drain() {
    return BeginNestedMessage<T>(312);
  }

  template <typename T = RssStatFtraceEvent> T* set_rss_stat() {
    return BeginNestedMessage<T>(313);
  }

  template <typename T = IonHeapShrinkFtraceEvent> T* set_ion_heap_shrink() {
    return BeginNestedMessage<T>(314);
  }

  template <typename T = IonHeapGrowFtraceEvent> T* set_ion_heap_grow() {
    return BeginNestedMessage<T>(315);
  }

  template <typename T = FenceInitFtraceEvent> T* set_fence_init() {
    return BeginNestedMessage<T>(316);
  }

  template <typename T = FenceDestroyFtraceEvent> T* set_fence_destroy() {
    return BeginNestedMessage<T>(317);
  }

  template <typename T = FenceEnableSignalFtraceEvent> T* set_fence_enable_signal() {
    return BeginNestedMessage<T>(318);
  }

  template <typename T = FenceSignaledFtraceEvent> T* set_fence_signaled() {
    return BeginNestedMessage<T>(319);
  }

  template <typename T = ClkEnableFtraceEvent> T* set_clk_enable() {
    return BeginNestedMessage<T>(320);
  }

  template <typename T = ClkDisableFtraceEvent> T* set_clk_disable() {
    return BeginNestedMessage<T>(321);
  }

  template <typename T = ClkSetRateFtraceEvent> T* set_clk_set_rate() {
    return BeginNestedMessage<T>(322);
  }

  template <typename T = BinderTransactionAllocBufFtraceEvent> T* set_binder_transaction_alloc_buf() {
    return BeginNestedMessage<T>(323);
  }

  template <typename T = SignalDeliverFtraceEvent> T* set_signal_deliver() {
    return BeginNestedMessage<T>(324);
  }

  template <typename T = SignalGenerateFtraceEvent> T* set_signal_generate() {
    return BeginNestedMessage<T>(325);
  }

  template <typename T = OomScoreAdjUpdateFtraceEvent> T* set_oom_score_adj_update() {
    return BeginNestedMessage<T>(326);
  }

  template <typename T = GenericFtraceEvent> T* set_generic() {
    return BeginNestedMessage<T>(327);
  }

  template <typename T = MmEventRecordFtraceEvent> T* set_mm_event_record() {
    return BeginNestedMessage<T>(328);
  }

  template <typename T = SysEnterFtraceEvent> T* set_sys_enter() {
    return BeginNestedMessage<T>(329);
  }

  template <typename T = SysExitFtraceEvent> T* set_sys_exit() {
    return BeginNestedMessage<T>(330);
  }

  template <typename T = ZeroFtraceEvent> T* set_zero() {
    return BeginNestedMessage<T>(331);
  }

  template <typename T = GpuFrequencyFtraceEvent> T* set_gpu_frequency() {
    return BeginNestedMessage<T>(332);
  }

};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/ftrace/ftrace_event_bundle.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_FTRACE_EVENT_BUNDLE_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_FTRACE_EVENT_BUNDLE_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class FtraceEvent;
class FtraceEventBundle_CompactSched;

class FtraceEventBundle_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  FtraceEventBundle_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit FtraceEventBundle_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit FtraceEventBundle_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_cpu() const { return at<1>().valid(); }
  uint32_t cpu() const { return at<1>().as_uint32(); }
  bool has_event() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> event() const { return GetRepeated<::protozero::ConstBytes>(2); }
  bool has_lost_events() const { return at<3>().valid(); }
  bool lost_events() const { return at<3>().as_bool(); }
  bool has_compact_sched() const { return at<4>().valid(); }
  ::protozero::ConstBytes compact_sched() const { return at<4>().as_bytes(); }
};

class FtraceEventBundle : public ::protozero::Message {
 public:
  using Decoder = FtraceEventBundle_Decoder;
  enum : int32_t {
    kCpuFieldNumber = 1,
    kEventFieldNumber = 2,
    kLostEventsFieldNumber = 3,
    kCompactSchedFieldNumber = 4,
  };
  using CompactSched = ::perfetto::protos::pbzero::FtraceEventBundle_CompactSched;
  void set_cpu(uint32_t value) {
    AppendVarInt(1, value);
  }
  template <typename T = FtraceEvent> T* add_event() {
    return BeginNestedMessage<T>(2);
  }

  void set_lost_events(bool value) {
    AppendTinyVarInt(3, value);
  }
  template <typename T = FtraceEventBundle_CompactSched> T* set_compact_sched() {
    return BeginNestedMessage<T>(4);
  }

};

class FtraceEventBundle_CompactSched_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/11, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  FtraceEventBundle_CompactSched_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit FtraceEventBundle_CompactSched_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit FtraceEventBundle_CompactSched_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_intern_table() const { return at<5>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstChars> intern_table() const { return GetRepeated<::protozero::ConstChars>(5); }
  bool has_switch_timestamp() const { return at<1>().valid(); }
  ::protozero::PackedRepeatedFieldIterator<::protozero::proto_utils::ProtoWireType::kVarInt, uint64_t> switch_timestamp(bool* parse_error_ptr) const { return GetPackedRepeated<::protozero::proto_utils::ProtoWireType::kVarInt, uint64_t>(1, parse_error_ptr); }
  bool has_switch_prev_state() const { return at<2>().valid(); }
  ::protozero::PackedRepeatedFieldIterator<::protozero::proto_utils::ProtoWireType::kVarInt, int64_t> switch_prev_state(bool* parse_error_ptr) const { return GetPackedRepeated<::protozero::proto_utils::ProtoWireType::kVarInt, int64_t>(2, parse_error_ptr); }
  bool has_switch_next_pid() const { return at<3>().valid(); }
  ::protozero::PackedRepeatedFieldIterator<::protozero::proto_utils::ProtoWireType::kVarInt, int32_t> switch_next_pid(bool* parse_error_ptr) const { return GetPackedRepeated<::protozero::proto_utils::ProtoWireType::kVarInt, int32_t>(3, parse_error_ptr); }
  bool has_switch_next_prio() const { return at<4>().valid(); }
  ::protozero::PackedRepeatedFieldIterator<::protozero::proto_utils::ProtoWireType::kVarInt, int32_t> switch_next_prio(bool* parse_error_ptr) const { return GetPackedRepeated<::protozero::proto_utils::ProtoWireType::kVarInt, int32_t>(4, parse_error_ptr); }
  bool has_switch_next_comm_index() const { return at<6>().valid(); }
  ::protozero::PackedRepeatedFieldIterator<::protozero::proto_utils::ProtoWireType::kVarInt, uint32_t> switch_next_comm_index(bool* parse_error_ptr) const { return GetPackedRepeated<::protozero::proto_utils::ProtoWireType::kVarInt, uint32_t>(6, parse_error_ptr); }
  bool has_waking_timestamp() const { return at<7>().valid(); }
  ::protozero::PackedRepeatedFieldIterator<::protozero::proto_utils::ProtoWireType::kVarInt, uint64_t> waking_timestamp(bool* parse_error_ptr) const { return GetPackedRepeated<::protozero::proto_utils::ProtoWireType::kVarInt, uint64_t>(7, parse_error_ptr); }
  bool has_waking_pid() const { return at<8>().valid(); }
  ::protozero::PackedRepeatedFieldIterator<::protozero::proto_utils::ProtoWireType::kVarInt, int32_t> waking_pid(bool* parse_error_ptr) const { return GetPackedRepeated<::protozero::proto_utils::ProtoWireType::kVarInt, int32_t>(8, parse_error_ptr); }
  bool has_waking_target_cpu() const { return at<9>().valid(); }
  ::protozero::PackedRepeatedFieldIterator<::protozero::proto_utils::ProtoWireType::kVarInt, int32_t> waking_target_cpu(bool* parse_error_ptr) const { return GetPackedRepeated<::protozero::proto_utils::ProtoWireType::kVarInt, int32_t>(9, parse_error_ptr); }
  bool has_waking_prio() const { return at<10>().valid(); }
  ::protozero::PackedRepeatedFieldIterator<::protozero::proto_utils::ProtoWireType::kVarInt, int32_t> waking_prio(bool* parse_error_ptr) const { return GetPackedRepeated<::protozero::proto_utils::ProtoWireType::kVarInt, int32_t>(10, parse_error_ptr); }
  bool has_waking_comm_index() const { return at<11>().valid(); }
  ::protozero::PackedRepeatedFieldIterator<::protozero::proto_utils::ProtoWireType::kVarInt, uint32_t> waking_comm_index(bool* parse_error_ptr) const { return GetPackedRepeated<::protozero::proto_utils::ProtoWireType::kVarInt, uint32_t>(11, parse_error_ptr); }
};

class FtraceEventBundle_CompactSched : public ::protozero::Message {
 public:
  using Decoder = FtraceEventBundle_CompactSched_Decoder;
  enum : int32_t {
    kInternTableFieldNumber = 5,
    kSwitchTimestampFieldNumber = 1,
    kSwitchPrevStateFieldNumber = 2,
    kSwitchNextPidFieldNumber = 3,
    kSwitchNextPrioFieldNumber = 4,
    kSwitchNextCommIndexFieldNumber = 6,
    kWakingTimestampFieldNumber = 7,
    kWakingPidFieldNumber = 8,
    kWakingTargetCpuFieldNumber = 9,
    kWakingPrioFieldNumber = 10,
    kWakingCommIndexFieldNumber = 11,
  };
  void add_intern_table(const std::string& value) {
    AppendBytes(5, value.data(), value.size());
  }
  void add_intern_table(const char* data, size_t size) {
    AppendBytes(5, data, size);
  }
  void set_switch_timestamp(const ::protozero::PackedVarInt& packed_buffer) {
    AppendBytes(1, packed_buffer.data(), packed_buffer.size());
  }
  void set_switch_prev_state(const ::protozero::PackedVarInt& packed_buffer) {
    AppendBytes(2, packed_buffer.data(), packed_buffer.size());
  }
  void set_switch_next_pid(const ::protozero::PackedVarInt& packed_buffer) {
    AppendBytes(3, packed_buffer.data(), packed_buffer.size());
  }
  void set_switch_next_prio(const ::protozero::PackedVarInt& packed_buffer) {
    AppendBytes(4, packed_buffer.data(), packed_buffer.size());
  }
  void set_switch_next_comm_index(const ::protozero::PackedVarInt& packed_buffer) {
    AppendBytes(6, packed_buffer.data(), packed_buffer.size());
  }
  void set_waking_timestamp(const ::protozero::PackedVarInt& packed_buffer) {
    AppendBytes(7, packed_buffer.data(), packed_buffer.size());
  }
  void set_waking_pid(const ::protozero::PackedVarInt& packed_buffer) {
    AppendBytes(8, packed_buffer.data(), packed_buffer.size());
  }
  void set_waking_target_cpu(const ::protozero::PackedVarInt& packed_buffer) {
    AppendBytes(9, packed_buffer.data(), packed_buffer.size());
  }
  void set_waking_prio(const ::protozero::PackedVarInt& packed_buffer) {
    AppendBytes(10, packed_buffer.data(), packed_buffer.size());
  }
  void set_waking_comm_index(const ::protozero::PackedVarInt& packed_buffer) {
    AppendBytes(11, packed_buffer.data(), packed_buffer.size());
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/ftrace/ftrace_stats.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_FTRACE_STATS_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_FTRACE_STATS_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class FtraceCpuStats;
enum FtraceStats_Phase : int32_t;

enum FtraceStats_Phase : int32_t {
  FtraceStats_Phase_UNSPECIFIED = 0,
  FtraceStats_Phase_START_OF_TRACE = 1,
  FtraceStats_Phase_END_OF_TRACE = 2,
};

const FtraceStats_Phase FtraceStats_Phase_MIN = FtraceStats_Phase_UNSPECIFIED;
const FtraceStats_Phase FtraceStats_Phase_MAX = FtraceStats_Phase_END_OF_TRACE;

class FtraceStats_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  FtraceStats_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit FtraceStats_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit FtraceStats_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_phase() const { return at<1>().valid(); }
  int32_t phase() const { return at<1>().as_int32(); }
  bool has_cpu_stats() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> cpu_stats() const { return GetRepeated<::protozero::ConstBytes>(2); }
};

class FtraceStats : public ::protozero::Message {
 public:
  using Decoder = FtraceStats_Decoder;
  enum : int32_t {
    kPhaseFieldNumber = 1,
    kCpuStatsFieldNumber = 2,
  };
  using Phase = ::perfetto::protos::pbzero::FtraceStats_Phase;
  static const Phase UNSPECIFIED = FtraceStats_Phase_UNSPECIFIED;
  static const Phase START_OF_TRACE = FtraceStats_Phase_START_OF_TRACE;
  static const Phase END_OF_TRACE = FtraceStats_Phase_END_OF_TRACE;
  void set_phase(::perfetto::protos::pbzero::FtraceStats_Phase value) {
    AppendTinyVarInt(1, value);
  }
  template <typename T = FtraceCpuStats> T* add_cpu_stats() {
    return BeginNestedMessage<T>(2);
  }

};

class FtraceCpuStats_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/9, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  FtraceCpuStats_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit FtraceCpuStats_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit FtraceCpuStats_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_cpu() const { return at<1>().valid(); }
  uint64_t cpu() const { return at<1>().as_uint64(); }
  bool has_entries() const { return at<2>().valid(); }
  uint64_t entries() const { return at<2>().as_uint64(); }
  bool has_overrun() const { return at<3>().valid(); }
  uint64_t overrun() const { return at<3>().as_uint64(); }
  bool has_commit_overrun() const { return at<4>().valid(); }
  uint64_t commit_overrun() const { return at<4>().as_uint64(); }
  bool has_bytes_read() const { return at<5>().valid(); }
  uint64_t bytes_read() const { return at<5>().as_uint64(); }
  bool has_oldest_event_ts() const { return at<6>().valid(); }
  double oldest_event_ts() const { return at<6>().as_double(); }
  bool has_now_ts() const { return at<7>().valid(); }
  double now_ts() const { return at<7>().as_double(); }
  bool has_dropped_events() const { return at<8>().valid(); }
  uint64_t dropped_events() const { return at<8>().as_uint64(); }
  bool has_read_events() const { return at<9>().valid(); }
  uint64_t read_events() const { return at<9>().as_uint64(); }
};

class FtraceCpuStats : public ::protozero::Message {
 public:
  using Decoder = FtraceCpuStats_Decoder;
  enum : int32_t {
    kCpuFieldNumber = 1,
    kEntriesFieldNumber = 2,
    kOverrunFieldNumber = 3,
    kCommitOverrunFieldNumber = 4,
    kBytesReadFieldNumber = 5,
    kOldestEventTsFieldNumber = 6,
    kNowTsFieldNumber = 7,
    kDroppedEventsFieldNumber = 8,
    kReadEventsFieldNumber = 9,
  };
  void set_cpu(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_entries(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_overrun(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_commit_overrun(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_bytes_read(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_oldest_event_ts(double value) {
    AppendFixed(6, value);
  }
  void set_now_ts(double value) {
    AppendFixed(7, value);
  }
  void set_dropped_events(uint64_t value) {
    AppendVarInt(8, value);
  }
  void set_read_events(uint64_t value) {
    AppendVarInt(9, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/ftrace/test_bundle_wrapper.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_TEST_BUNDLE_WRAPPER_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_TEST_BUNDLE_WRAPPER_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class FtraceEventBundle;

class TestBundleWrapper_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  TestBundleWrapper_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TestBundleWrapper_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TestBundleWrapper_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_before() const { return at<1>().valid(); }
  ::protozero::ConstChars before() const { return at<1>().as_string(); }
  bool has_bundle() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> bundle() const { return GetRepeated<::protozero::ConstBytes>(2); }
  bool has_after() const { return at<3>().valid(); }
  ::protozero::ConstChars after() const { return at<3>().as_string(); }
};

class TestBundleWrapper : public ::protozero::Message {
 public:
  using Decoder = TestBundleWrapper_Decoder;
  enum : int32_t {
    kBeforeFieldNumber = 1,
    kBundleFieldNumber = 2,
    kAfterFieldNumber = 3,
  };
  void set_before(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_before(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  template <typename T = FtraceEventBundle> T* add_bundle() {
    return BeginNestedMessage<T>(2);
  }

  void set_after(const std::string& value) {
    AppendBytes(3, value.data(), value.size());
  }
  void set_after(const char* data, size_t size) {
    AppendBytes(3, data, size);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/ftrace/generic.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_GENERIC_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_GENERIC_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class GenericFtraceEvent_Field;

class GenericFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  GenericFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit GenericFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit GenericFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_event_name() const { return at<1>().valid(); }
  ::protozero::ConstChars event_name() const { return at<1>().as_string(); }
  bool has_field() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> field() const { return GetRepeated<::protozero::ConstBytes>(2); }
};

class GenericFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = GenericFtraceEvent_Decoder;
  enum : int32_t {
    kEventNameFieldNumber = 1,
    kFieldFieldNumber = 2,
  };
  using Field = ::perfetto::protos::pbzero::GenericFtraceEvent_Field;
  void set_event_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_event_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  template <typename T = GenericFtraceEvent_Field> T* add_field() {
    return BeginNestedMessage<T>(2);
  }

};

class GenericFtraceEvent_Field_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  GenericFtraceEvent_Field_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit GenericFtraceEvent_Field_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit GenericFtraceEvent_Field_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_str_value() const { return at<3>().valid(); }
  ::protozero::ConstChars str_value() const { return at<3>().as_string(); }
  bool has_int_value() const { return at<4>().valid(); }
  int64_t int_value() const { return at<4>().as_int64(); }
  bool has_uint_value() const { return at<5>().valid(); }
  uint64_t uint_value() const { return at<5>().as_uint64(); }
};

class GenericFtraceEvent_Field : public ::protozero::Message {
 public:
  using Decoder = GenericFtraceEvent_Field_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kStrValueFieldNumber = 3,
    kIntValueFieldNumber = 4,
    kUintValueFieldNumber = 5,
  };
  void set_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_str_value(const std::string& value) {
    AppendBytes(3, value.data(), value.size());
  }
  void set_str_value(const char* data, size_t size) {
    AppendBytes(3, data, size);
  }
  void set_int_value(int64_t value) {
    AppendVarInt(4, value);
  }
  void set_uint_value(uint64_t value) {
    AppendVarInt(5, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/ftrace/binder.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_BINDER_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_BINDER_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class BinderTransactionAllocBufFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BinderTransactionAllocBufFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BinderTransactionAllocBufFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BinderTransactionAllocBufFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_data_size() const { return at<1>().valid(); }
  uint64_t data_size() const { return at<1>().as_uint64(); }
  bool has_debug_id() const { return at<2>().valid(); }
  int32_t debug_id() const { return at<2>().as_int32(); }
  bool has_offsets_size() const { return at<3>().valid(); }
  uint64_t offsets_size() const { return at<3>().as_uint64(); }
};

class BinderTransactionAllocBufFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = BinderTransactionAllocBufFtraceEvent_Decoder;
  enum : int32_t {
    kDataSizeFieldNumber = 1,
    kDebugIdFieldNumber = 2,
    kOffsetsSizeFieldNumber = 3,
  };
  void set_data_size(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_debug_id(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_offsets_size(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class BinderUnlockFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BinderUnlockFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BinderUnlockFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BinderUnlockFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_tag() const { return at<1>().valid(); }
  ::protozero::ConstChars tag() const { return at<1>().as_string(); }
};

class BinderUnlockFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = BinderUnlockFtraceEvent_Decoder;
  enum : int32_t {
    kTagFieldNumber = 1,
  };
  void set_tag(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_tag(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
};

class BinderLockedFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BinderLockedFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BinderLockedFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BinderLockedFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_tag() const { return at<1>().valid(); }
  ::protozero::ConstChars tag() const { return at<1>().as_string(); }
};

class BinderLockedFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = BinderLockedFtraceEvent_Decoder;
  enum : int32_t {
    kTagFieldNumber = 1,
  };
  void set_tag(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_tag(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
};

class BinderLockFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BinderLockFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BinderLockFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BinderLockFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_tag() const { return at<1>().valid(); }
  ::protozero::ConstChars tag() const { return at<1>().as_string(); }
};

class BinderLockFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = BinderLockFtraceEvent_Decoder;
  enum : int32_t {
    kTagFieldNumber = 1,
  };
  void set_tag(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_tag(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
};

class BinderSetPriorityFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BinderSetPriorityFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BinderSetPriorityFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BinderSetPriorityFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_proc() const { return at<1>().valid(); }
  int32_t proc() const { return at<1>().as_int32(); }
  bool has_thread() const { return at<2>().valid(); }
  int32_t thread() const { return at<2>().as_int32(); }
  bool has_old_prio() const { return at<3>().valid(); }
  uint32_t old_prio() const { return at<3>().as_uint32(); }
  bool has_new_prio() const { return at<4>().valid(); }
  uint32_t new_prio() const { return at<4>().as_uint32(); }
  bool has_desired_prio() const { return at<5>().valid(); }
  uint32_t desired_prio() const { return at<5>().as_uint32(); }
};

class BinderSetPriorityFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = BinderSetPriorityFtraceEvent_Decoder;
  enum : int32_t {
    kProcFieldNumber = 1,
    kThreadFieldNumber = 2,
    kOldPrioFieldNumber = 3,
    kNewPrioFieldNumber = 4,
    kDesiredPrioFieldNumber = 5,
  };
  void set_proc(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_thread(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_old_prio(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_new_prio(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_desired_prio(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class BinderTransactionReceivedFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BinderTransactionReceivedFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BinderTransactionReceivedFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BinderTransactionReceivedFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_debug_id() const { return at<1>().valid(); }
  int32_t debug_id() const { return at<1>().as_int32(); }
};

class BinderTransactionReceivedFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = BinderTransactionReceivedFtraceEvent_Decoder;
  enum : int32_t {
    kDebugIdFieldNumber = 1,
  };
  void set_debug_id(int32_t value) {
    AppendVarInt(1, value);
  }
};

class BinderTransactionFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/7, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BinderTransactionFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BinderTransactionFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BinderTransactionFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_debug_id() const { return at<1>().valid(); }
  int32_t debug_id() const { return at<1>().as_int32(); }
  bool has_target_node() const { return at<2>().valid(); }
  int32_t target_node() const { return at<2>().as_int32(); }
  bool has_to_proc() const { return at<3>().valid(); }
  int32_t to_proc() const { return at<3>().as_int32(); }
  bool has_to_thread() const { return at<4>().valid(); }
  int32_t to_thread() const { return at<4>().as_int32(); }
  bool has_reply() const { return at<5>().valid(); }
  int32_t reply() const { return at<5>().as_int32(); }
  bool has_code() const { return at<6>().valid(); }
  uint32_t code() const { return at<6>().as_uint32(); }
  bool has_flags() const { return at<7>().valid(); }
  uint32_t flags() const { return at<7>().as_uint32(); }
};

class BinderTransactionFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = BinderTransactionFtraceEvent_Decoder;
  enum : int32_t {
    kDebugIdFieldNumber = 1,
    kTargetNodeFieldNumber = 2,
    kToProcFieldNumber = 3,
    kToThreadFieldNumber = 4,
    kReplyFieldNumber = 5,
    kCodeFieldNumber = 6,
    kFlagsFieldNumber = 7,
  };
  void set_debug_id(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_target_node(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_to_proc(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_to_thread(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_reply(int32_t value) {
    AppendVarInt(5, value);
  }
  void set_code(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(7, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/ftrace/block.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_BLOCK_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_BLOCK_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class BlockUnplugFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BlockUnplugFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BlockUnplugFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BlockUnplugFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_nr_rq() const { return at<1>().valid(); }
  int32_t nr_rq() const { return at<1>().as_int32(); }
  bool has_comm() const { return at<2>().valid(); }
  ::protozero::ConstChars comm() const { return at<2>().as_string(); }
};

class BlockUnplugFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = BlockUnplugFtraceEvent_Decoder;
  enum : int32_t {
    kNrRqFieldNumber = 1,
    kCommFieldNumber = 2,
  };
  void set_nr_rq(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_comm(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void set_comm(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
};

class BlockTouchBufferFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BlockTouchBufferFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BlockTouchBufferFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BlockTouchBufferFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_sector() const { return at<2>().valid(); }
  uint64_t sector() const { return at<2>().as_uint64(); }
  bool has_size() const { return at<3>().valid(); }
  uint64_t size() const { return at<3>().as_uint64(); }
};

class BlockTouchBufferFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = BlockTouchBufferFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kSizeFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_sector(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_size(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class BlockSplitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BlockSplitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BlockSplitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BlockSplitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_sector() const { return at<2>().valid(); }
  uint64_t sector() const { return at<2>().as_uint64(); }
  bool has_new_sector() const { return at<3>().valid(); }
  uint64_t new_sector() const { return at<3>().as_uint64(); }
  bool has_rwbs() const { return at<4>().valid(); }
  ::protozero::ConstChars rwbs() const { return at<4>().as_string(); }
  bool has_comm() const { return at<5>().valid(); }
  ::protozero::ConstChars comm() const { return at<5>().as_string(); }
};

class BlockSplitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = BlockSplitFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNewSectorFieldNumber = 3,
    kRwbsFieldNumber = 4,
    kCommFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_sector(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_new_sector(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_rwbs(const std::string& value) {
    AppendBytes(4, value.data(), value.size());
  }
  void set_rwbs(const char* data, size_t size) {
    AppendBytes(4, data, size);
  }
  void set_comm(const std::string& value) {
    AppendBytes(5, value.data(), value.size());
  }
  void set_comm(const char* data, size_t size) {
    AppendBytes(5, data, size);
  }
};

class BlockSleeprqFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BlockSleeprqFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BlockSleeprqFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BlockSleeprqFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_sector() const { return at<2>().valid(); }
  uint64_t sector() const { return at<2>().as_uint64(); }
  bool has_nr_sector() const { return at<3>().valid(); }
  uint32_t nr_sector() const { return at<3>().as_uint32(); }
  bool has_rwbs() const { return at<4>().valid(); }
  ::protozero::ConstChars rwbs() const { return at<4>().as_string(); }
  bool has_comm() const { return at<5>().valid(); }
  ::protozero::ConstChars comm() const { return at<5>().as_string(); }
};

class BlockSleeprqFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = BlockSleeprqFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
    kRwbsFieldNumber = 4,
    kCommFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_sector(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_nr_sector(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_rwbs(const std::string& value) {
    AppendBytes(4, value.data(), value.size());
  }
  void set_rwbs(const char* data, size_t size) {
    AppendBytes(4, data, size);
  }
  void set_comm(const std::string& value) {
    AppendBytes(5, value.data(), value.size());
  }
  void set_comm(const char* data, size_t size) {
    AppendBytes(5, data, size);
  }
};

class BlockRqRequeueFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BlockRqRequeueFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BlockRqRequeueFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BlockRqRequeueFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_sector() const { return at<2>().valid(); }
  uint64_t sector() const { return at<2>().as_uint64(); }
  bool has_nr_sector() const { return at<3>().valid(); }
  uint32_t nr_sector() const { return at<3>().as_uint32(); }
  bool has_errors() const { return at<4>().valid(); }
  int32_t errors() const { return at<4>().as_int32(); }
  bool has_rwbs() const { return at<5>().valid(); }
  ::protozero::ConstChars rwbs() const { return at<5>().as_string(); }
  bool has_cmd() const { return at<6>().valid(); }
  ::protozero::ConstChars cmd() const { return at<6>().as_string(); }
};

class BlockRqRequeueFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = BlockRqRequeueFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
    kErrorsFieldNumber = 4,
    kRwbsFieldNumber = 5,
    kCmdFieldNumber = 6,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_sector(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_nr_sector(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_errors(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_rwbs(const std::string& value) {
    AppendBytes(5, value.data(), value.size());
  }
  void set_rwbs(const char* data, size_t size) {
    AppendBytes(5, data, size);
  }
  void set_cmd(const std::string& value) {
    AppendBytes(6, value.data(), value.size());
  }
  void set_cmd(const char* data, size_t size) {
    AppendBytes(6, data, size);
  }
};

class BlockRqRemapFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/7, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BlockRqRemapFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BlockRqRemapFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BlockRqRemapFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_sector() const { return at<2>().valid(); }
  uint64_t sector() const { return at<2>().as_uint64(); }
  bool has_nr_sector() const { return at<3>().valid(); }
  uint32_t nr_sector() const { return at<3>().as_uint32(); }
  bool has_old_dev() const { return at<4>().valid(); }
  uint64_t old_dev() const { return at<4>().as_uint64(); }
  bool has_old_sector() const { return at<5>().valid(); }
  uint64_t old_sector() const { return at<5>().as_uint64(); }
  bool has_nr_bios() const { return at<6>().valid(); }
  uint32_t nr_bios() const { return at<6>().as_uint32(); }
  bool has_rwbs() const { return at<7>().valid(); }
  ::protozero::ConstChars rwbs() const { return at<7>().as_string(); }
};

class BlockRqRemapFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = BlockRqRemapFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
    kOldDevFieldNumber = 4,
    kOldSectorFieldNumber = 5,
    kNrBiosFieldNumber = 6,
    kRwbsFieldNumber = 7,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_sector(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_nr_sector(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_old_dev(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_old_sector(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_nr_bios(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_rwbs(const std::string& value) {
    AppendBytes(7, value.data(), value.size());
  }
  void set_rwbs(const char* data, size_t size) {
    AppendBytes(7, data, size);
  }
};

class BlockRqInsertFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/7, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BlockRqInsertFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BlockRqInsertFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BlockRqInsertFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_sector() const { return at<2>().valid(); }
  uint64_t sector() const { return at<2>().as_uint64(); }
  bool has_nr_sector() const { return at<3>().valid(); }
  uint32_t nr_sector() const { return at<3>().as_uint32(); }
  bool has_bytes() const { return at<4>().valid(); }
  uint32_t bytes() const { return at<4>().as_uint32(); }
  bool has_rwbs() const { return at<5>().valid(); }
  ::protozero::ConstChars rwbs() const { return at<5>().as_string(); }
  bool has_comm() const { return at<6>().valid(); }
  ::protozero::ConstChars comm() const { return at<6>().as_string(); }
  bool has_cmd() const { return at<7>().valid(); }
  ::protozero::ConstChars cmd() const { return at<7>().as_string(); }
};

class BlockRqInsertFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = BlockRqInsertFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
    kBytesFieldNumber = 4,
    kRwbsFieldNumber = 5,
    kCommFieldNumber = 6,
    kCmdFieldNumber = 7,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_sector(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_nr_sector(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_bytes(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_rwbs(const std::string& value) {
    AppendBytes(5, value.data(), value.size());
  }
  void set_rwbs(const char* data, size_t size) {
    AppendBytes(5, data, size);
  }
  void set_comm(const std::string& value) {
    AppendBytes(6, value.data(), value.size());
  }
  void set_comm(const char* data, size_t size) {
    AppendBytes(6, data, size);
  }
  void set_cmd(const std::string& value) {
    AppendBytes(7, value.data(), value.size());
  }
  void set_cmd(const char* data, size_t size) {
    AppendBytes(7, data, size);
  }
};

class BlockRqCompleteFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BlockRqCompleteFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BlockRqCompleteFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BlockRqCompleteFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_sector() const { return at<2>().valid(); }
  uint64_t sector() const { return at<2>().as_uint64(); }
  bool has_nr_sector() const { return at<3>().valid(); }
  uint32_t nr_sector() const { return at<3>().as_uint32(); }
  bool has_errors() const { return at<4>().valid(); }
  int32_t errors() const { return at<4>().as_int32(); }
  bool has_rwbs() const { return at<5>().valid(); }
  ::protozero::ConstChars rwbs() const { return at<5>().as_string(); }
  bool has_cmd() const { return at<6>().valid(); }
  ::protozero::ConstChars cmd() const { return at<6>().as_string(); }
};

class BlockRqCompleteFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = BlockRqCompleteFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
    kErrorsFieldNumber = 4,
    kRwbsFieldNumber = 5,
    kCmdFieldNumber = 6,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_sector(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_nr_sector(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_errors(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_rwbs(const std::string& value) {
    AppendBytes(5, value.data(), value.size());
  }
  void set_rwbs(const char* data, size_t size) {
    AppendBytes(5, data, size);
  }
  void set_cmd(const std::string& value) {
    AppendBytes(6, value.data(), value.size());
  }
  void set_cmd(const char* data, size_t size) {
    AppendBytes(6, data, size);
  }
};

class BlockRqAbortFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BlockRqAbortFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BlockRqAbortFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BlockRqAbortFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_sector() const { return at<2>().valid(); }
  uint64_t sector() const { return at<2>().as_uint64(); }
  bool has_nr_sector() const { return at<3>().valid(); }
  uint32_t nr_sector() const { return at<3>().as_uint32(); }
  bool has_errors() const { return at<4>().valid(); }
  int32_t errors() const { return at<4>().as_int32(); }
  bool has_rwbs() const { return at<5>().valid(); }
  ::protozero::ConstChars rwbs() const { return at<5>().as_string(); }
  bool has_cmd() const { return at<6>().valid(); }
  ::protozero::ConstChars cmd() const { return at<6>().as_string(); }
};

class BlockRqAbortFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = BlockRqAbortFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
    kErrorsFieldNumber = 4,
    kRwbsFieldNumber = 5,
    kCmdFieldNumber = 6,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_sector(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_nr_sector(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_errors(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_rwbs(const std::string& value) {
    AppendBytes(5, value.data(), value.size());
  }
  void set_rwbs(const char* data, size_t size) {
    AppendBytes(5, data, size);
  }
  void set_cmd(const std::string& value) {
    AppendBytes(6, value.data(), value.size());
  }
  void set_cmd(const char* data, size_t size) {
    AppendBytes(6, data, size);
  }
};

class BlockPlugFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BlockPlugFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BlockPlugFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BlockPlugFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_comm() const { return at<1>().valid(); }
  ::protozero::ConstChars comm() const { return at<1>().as_string(); }
};

class BlockPlugFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = BlockPlugFtraceEvent_Decoder;
  enum : int32_t {
    kCommFieldNumber = 1,
  };
  void set_comm(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_comm(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
};

class BlockGetrqFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BlockGetrqFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BlockGetrqFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BlockGetrqFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_sector() const { return at<2>().valid(); }
  uint64_t sector() const { return at<2>().as_uint64(); }
  bool has_nr_sector() const { return at<3>().valid(); }
  uint32_t nr_sector() const { return at<3>().as_uint32(); }
  bool has_rwbs() const { return at<4>().valid(); }
  ::protozero::ConstChars rwbs() const { return at<4>().as_string(); }
  bool has_comm() const { return at<5>().valid(); }
  ::protozero::ConstChars comm() const { return at<5>().as_string(); }
};

class BlockGetrqFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = BlockGetrqFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
    kRwbsFieldNumber = 4,
    kCommFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_sector(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_nr_sector(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_rwbs(const std::string& value) {
    AppendBytes(4, value.data(), value.size());
  }
  void set_rwbs(const char* data, size_t size) {
    AppendBytes(4, data, size);
  }
  void set_comm(const std::string& value) {
    AppendBytes(5, value.data(), value.size());
  }
  void set_comm(const char* data, size_t size) {
    AppendBytes(5, data, size);
  }
};

class BlockDirtyBufferFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BlockDirtyBufferFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BlockDirtyBufferFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BlockDirtyBufferFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_sector() const { return at<2>().valid(); }
  uint64_t sector() const { return at<2>().as_uint64(); }
  bool has_size() const { return at<3>().valid(); }
  uint64_t size() const { return at<3>().as_uint64(); }
};

class BlockDirtyBufferFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = BlockDirtyBufferFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kSizeFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_sector(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_size(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class BlockBioRemapFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BlockBioRemapFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BlockBioRemapFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BlockBioRemapFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_sector() const { return at<2>().valid(); }
  uint64_t sector() const { return at<2>().as_uint64(); }
  bool has_nr_sector() const { return at<3>().valid(); }
  uint32_t nr_sector() const { return at<3>().as_uint32(); }
  bool has_old_dev() const { return at<4>().valid(); }
  uint64_t old_dev() const { return at<4>().as_uint64(); }
  bool has_old_sector() const { return at<5>().valid(); }
  uint64_t old_sector() const { return at<5>().as_uint64(); }
  bool has_rwbs() const { return at<6>().valid(); }
  ::protozero::ConstChars rwbs() const { return at<6>().as_string(); }
};

class BlockBioRemapFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = BlockBioRemapFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
    kOldDevFieldNumber = 4,
    kOldSectorFieldNumber = 5,
    kRwbsFieldNumber = 6,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_sector(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_nr_sector(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_old_dev(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_old_sector(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_rwbs(const std::string& value) {
    AppendBytes(6, value.data(), value.size());
  }
  void set_rwbs(const char* data, size_t size) {
    AppendBytes(6, data, size);
  }
};

class BlockBioQueueFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BlockBioQueueFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BlockBioQueueFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BlockBioQueueFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_sector() const { return at<2>().valid(); }
  uint64_t sector() const { return at<2>().as_uint64(); }
  bool has_nr_sector() const { return at<3>().valid(); }
  uint32_t nr_sector() const { return at<3>().as_uint32(); }
  bool has_rwbs() const { return at<4>().valid(); }
  ::protozero::ConstChars rwbs() const { return at<4>().as_string(); }
  bool has_comm() const { return at<5>().valid(); }
  ::protozero::ConstChars comm() const { return at<5>().as_string(); }
};

class BlockBioQueueFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = BlockBioQueueFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
    kRwbsFieldNumber = 4,
    kCommFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_sector(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_nr_sector(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_rwbs(const std::string& value) {
    AppendBytes(4, value.data(), value.size());
  }
  void set_rwbs(const char* data, size_t size) {
    AppendBytes(4, data, size);
  }
  void set_comm(const std::string& value) {
    AppendBytes(5, value.data(), value.size());
  }
  void set_comm(const char* data, size_t size) {
    AppendBytes(5, data, size);
  }
};

class BlockBioFrontmergeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BlockBioFrontmergeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BlockBioFrontmergeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BlockBioFrontmergeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_sector() const { return at<2>().valid(); }
  uint64_t sector() const { return at<2>().as_uint64(); }
  bool has_nr_sector() const { return at<3>().valid(); }
  uint32_t nr_sector() const { return at<3>().as_uint32(); }
  bool has_rwbs() const { return at<4>().valid(); }
  ::protozero::ConstChars rwbs() const { return at<4>().as_string(); }
  bool has_comm() const { return at<5>().valid(); }
  ::protozero::ConstChars comm() const { return at<5>().as_string(); }
};

class BlockBioFrontmergeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = BlockBioFrontmergeFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
    kRwbsFieldNumber = 4,
    kCommFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_sector(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_nr_sector(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_rwbs(const std::string& value) {
    AppendBytes(4, value.data(), value.size());
  }
  void set_rwbs(const char* data, size_t size) {
    AppendBytes(4, data, size);
  }
  void set_comm(const std::string& value) {
    AppendBytes(5, value.data(), value.size());
  }
  void set_comm(const char* data, size_t size) {
    AppendBytes(5, data, size);
  }
};

class BlockBioCompleteFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BlockBioCompleteFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BlockBioCompleteFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BlockBioCompleteFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_sector() const { return at<2>().valid(); }
  uint64_t sector() const { return at<2>().as_uint64(); }
  bool has_nr_sector() const { return at<3>().valid(); }
  uint32_t nr_sector() const { return at<3>().as_uint32(); }
  bool has_error() const { return at<4>().valid(); }
  int32_t error() const { return at<4>().as_int32(); }
  bool has_rwbs() const { return at<5>().valid(); }
  ::protozero::ConstChars rwbs() const { return at<5>().as_string(); }
};

class BlockBioCompleteFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = BlockBioCompleteFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
    kErrorFieldNumber = 4,
    kRwbsFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_sector(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_nr_sector(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_error(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_rwbs(const std::string& value) {
    AppendBytes(5, value.data(), value.size());
  }
  void set_rwbs(const char* data, size_t size) {
    AppendBytes(5, data, size);
  }
};

class BlockBioBounceFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BlockBioBounceFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BlockBioBounceFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BlockBioBounceFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_sector() const { return at<2>().valid(); }
  uint64_t sector() const { return at<2>().as_uint64(); }
  bool has_nr_sector() const { return at<3>().valid(); }
  uint32_t nr_sector() const { return at<3>().as_uint32(); }
  bool has_rwbs() const { return at<4>().valid(); }
  ::protozero::ConstChars rwbs() const { return at<4>().as_string(); }
  bool has_comm() const { return at<5>().valid(); }
  ::protozero::ConstChars comm() const { return at<5>().as_string(); }
};

class BlockBioBounceFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = BlockBioBounceFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
    kRwbsFieldNumber = 4,
    kCommFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_sector(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_nr_sector(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_rwbs(const std::string& value) {
    AppendBytes(4, value.data(), value.size());
  }
  void set_rwbs(const char* data, size_t size) {
    AppendBytes(4, data, size);
  }
  void set_comm(const std::string& value) {
    AppendBytes(5, value.data(), value.size());
  }
  void set_comm(const char* data, size_t size) {
    AppendBytes(5, data, size);
  }
};

class BlockBioBackmergeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BlockBioBackmergeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BlockBioBackmergeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BlockBioBackmergeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_sector() const { return at<2>().valid(); }
  uint64_t sector() const { return at<2>().as_uint64(); }
  bool has_nr_sector() const { return at<3>().valid(); }
  uint32_t nr_sector() const { return at<3>().as_uint32(); }
  bool has_rwbs() const { return at<4>().valid(); }
  ::protozero::ConstChars rwbs() const { return at<4>().as_string(); }
  bool has_comm() const { return at<5>().valid(); }
  ::protozero::ConstChars comm() const { return at<5>().as_string(); }
};

class BlockBioBackmergeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = BlockBioBackmergeFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
    kRwbsFieldNumber = 4,
    kCommFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_sector(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_nr_sector(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_rwbs(const std::string& value) {
    AppendBytes(4, value.data(), value.size());
  }
  void set_rwbs(const char* data, size_t size) {
    AppendBytes(4, data, size);
  }
  void set_comm(const std::string& value) {
    AppendBytes(5, value.data(), value.size());
  }
  void set_comm(const char* data, size_t size) {
    AppendBytes(5, data, size);
  }
};

class BlockRqIssueFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/7, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BlockRqIssueFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BlockRqIssueFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BlockRqIssueFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_sector() const { return at<2>().valid(); }
  uint64_t sector() const { return at<2>().as_uint64(); }
  bool has_nr_sector() const { return at<3>().valid(); }
  uint32_t nr_sector() const { return at<3>().as_uint32(); }
  bool has_bytes() const { return at<4>().valid(); }
  uint32_t bytes() const { return at<4>().as_uint32(); }
  bool has_rwbs() const { return at<5>().valid(); }
  ::protozero::ConstChars rwbs() const { return at<5>().as_string(); }
  bool has_comm() const { return at<6>().valid(); }
  ::protozero::ConstChars comm() const { return at<6>().as_string(); }
  bool has_cmd() const { return at<7>().valid(); }
  ::protozero::ConstChars cmd() const { return at<7>().as_string(); }
};

class BlockRqIssueFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = BlockRqIssueFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
    kBytesFieldNumber = 4,
    kRwbsFieldNumber = 5,
    kCommFieldNumber = 6,
    kCmdFieldNumber = 7,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_sector(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_nr_sector(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_bytes(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_rwbs(const std::string& value) {
    AppendBytes(5, value.data(), value.size());
  }
  void set_rwbs(const char* data, size_t size) {
    AppendBytes(5, data, size);
  }
  void set_comm(const std::string& value) {
    AppendBytes(6, value.data(), value.size());
  }
  void set_comm(const char* data, size_t size) {
    AppendBytes(6, data, size);
  }
  void set_cmd(const std::string& value) {
    AppendBytes(7, value.data(), value.size());
  }
  void set_cmd(const char* data, size_t size) {
    AppendBytes(7, data, size);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/ftrace/cgroup.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_CGROUP_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_CGROUP_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class CgroupSetupRootFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  CgroupSetupRootFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit CgroupSetupRootFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit CgroupSetupRootFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_root() const { return at<1>().valid(); }
  int32_t root() const { return at<1>().as_int32(); }
  bool has_ss_mask() const { return at<2>().valid(); }
  uint32_t ss_mask() const { return at<2>().as_uint32(); }
  bool has_name() const { return at<3>().valid(); }
  ::protozero::ConstChars name() const { return at<3>().as_string(); }
};

class CgroupSetupRootFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = CgroupSetupRootFtraceEvent_Decoder;
  enum : int32_t {
    kRootFieldNumber = 1,
    kSsMaskFieldNumber = 2,
    kNameFieldNumber = 3,
  };
  void set_root(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_ss_mask(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_name(const std::string& value) {
    AppendBytes(3, value.data(), value.size());
  }
  void set_name(const char* data, size_t size) {
    AppendBytes(3, data, size);
  }
};

class CgroupRenameFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  CgroupRenameFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit CgroupRenameFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit CgroupRenameFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_root() const { return at<1>().valid(); }
  int32_t root() const { return at<1>().as_int32(); }
  bool has_id() const { return at<2>().valid(); }
  int32_t id() const { return at<2>().as_int32(); }
  bool has_cname() const { return at<3>().valid(); }
  ::protozero::ConstChars cname() const { return at<3>().as_string(); }
};

class CgroupRenameFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = CgroupRenameFtraceEvent_Decoder;
  enum : int32_t {
    kRootFieldNumber = 1,
    kIdFieldNumber = 2,
    kCnameFieldNumber = 3,
  };
  void set_root(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_id(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_cname(const std::string& value) {
    AppendBytes(3, value.data(), value.size());
  }
  void set_cname(const char* data, size_t size) {
    AppendBytes(3, data, size);
  }
};

class CgroupReleaseFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  CgroupReleaseFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit CgroupReleaseFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit CgroupReleaseFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_root() const { return at<1>().valid(); }
  int32_t root() const { return at<1>().as_int32(); }
  bool has_id() const { return at<2>().valid(); }
  int32_t id() const { return at<2>().as_int32(); }
  bool has_cname() const { return at<3>().valid(); }
  ::protozero::ConstChars cname() const { return at<3>().as_string(); }
};

class CgroupReleaseFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = CgroupReleaseFtraceEvent_Decoder;
  enum : int32_t {
    kRootFieldNumber = 1,
    kIdFieldNumber = 2,
    kCnameFieldNumber = 3,
  };
  void set_root(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_id(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_cname(const std::string& value) {
    AppendBytes(3, value.data(), value.size());
  }
  void set_cname(const char* data, size_t size) {
    AppendBytes(3, data, size);
  }
};

class CgroupDestroyRootFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  CgroupDestroyRootFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit CgroupDestroyRootFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit CgroupDestroyRootFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_root() const { return at<1>().valid(); }
  int32_t root() const { return at<1>().as_int32(); }
  bool has_ss_mask() const { return at<2>().valid(); }
  uint32_t ss_mask() const { return at<2>().as_uint32(); }
  bool has_name() const { return at<3>().valid(); }
  ::protozero::ConstChars name() const { return at<3>().as_string(); }
};

class CgroupDestroyRootFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = CgroupDestroyRootFtraceEvent_Decoder;
  enum : int32_t {
    kRootFieldNumber = 1,
    kSsMaskFieldNumber = 2,
    kNameFieldNumber = 3,
  };
  void set_root(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_ss_mask(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_name(const std::string& value) {
    AppendBytes(3, value.data(), value.size());
  }
  void set_name(const char* data, size_t size) {
    AppendBytes(3, data, size);
  }
};

class CgroupTransferTasksFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  CgroupTransferTasksFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit CgroupTransferTasksFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit CgroupTransferTasksFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dst_root() const { return at<1>().valid(); }
  int32_t dst_root() const { return at<1>().as_int32(); }
  bool has_dst_id() const { return at<2>().valid(); }
  int32_t dst_id() const { return at<2>().as_int32(); }
  bool has_pid() const { return at<3>().valid(); }
  int32_t pid() const { return at<3>().as_int32(); }
  bool has_comm() const { return at<4>().valid(); }
  ::protozero::ConstChars comm() const { return at<4>().as_string(); }
  bool has_cname() const { return at<5>().valid(); }
  ::protozero::ConstChars cname() const { return at<5>().as_string(); }
};

class CgroupTransferTasksFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = CgroupTransferTasksFtraceEvent_Decoder;
  enum : int32_t {
    kDstRootFieldNumber = 1,
    kDstIdFieldNumber = 2,
    kPidFieldNumber = 3,
    kCommFieldNumber = 4,
    kCnameFieldNumber = 5,
  };
  void set_dst_root(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_dst_id(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_pid(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_comm(const std::string& value) {
    AppendBytes(4, value.data(), value.size());
  }
  void set_comm(const char* data, size_t size) {
    AppendBytes(4, data, size);
  }
  void set_cname(const std::string& value) {
    AppendBytes(5, value.data(), value.size());
  }
  void set_cname(const char* data, size_t size) {
    AppendBytes(5, data, size);
  }
};

class CgroupRmdirFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  CgroupRmdirFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit CgroupRmdirFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit CgroupRmdirFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_root() const { return at<1>().valid(); }
  int32_t root() const { return at<1>().as_int32(); }
  bool has_id() const { return at<2>().valid(); }
  int32_t id() const { return at<2>().as_int32(); }
  bool has_cname() const { return at<3>().valid(); }
  ::protozero::ConstChars cname() const { return at<3>().as_string(); }
};

class CgroupRmdirFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = CgroupRmdirFtraceEvent_Decoder;
  enum : int32_t {
    kRootFieldNumber = 1,
    kIdFieldNumber = 2,
    kCnameFieldNumber = 3,
  };
  void set_root(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_id(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_cname(const std::string& value) {
    AppendBytes(3, value.data(), value.size());
  }
  void set_cname(const char* data, size_t size) {
    AppendBytes(3, data, size);
  }
};

class CgroupRemountFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  CgroupRemountFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit CgroupRemountFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit CgroupRemountFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_root() const { return at<1>().valid(); }
  int32_t root() const { return at<1>().as_int32(); }
  bool has_ss_mask() const { return at<2>().valid(); }
  uint32_t ss_mask() const { return at<2>().as_uint32(); }
  bool has_name() const { return at<3>().valid(); }
  ::protozero::ConstChars name() const { return at<3>().as_string(); }
};

class CgroupRemountFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = CgroupRemountFtraceEvent_Decoder;
  enum : int32_t {
    kRootFieldNumber = 1,
    kSsMaskFieldNumber = 2,
    kNameFieldNumber = 3,
  };
  void set_root(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_ss_mask(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_name(const std::string& value) {
    AppendBytes(3, value.data(), value.size());
  }
  void set_name(const char* data, size_t size) {
    AppendBytes(3, data, size);
  }
};

class CgroupMkdirFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  CgroupMkdirFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit CgroupMkdirFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit CgroupMkdirFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_root() const { return at<1>().valid(); }
  int32_t root() const { return at<1>().as_int32(); }
  bool has_id() const { return at<2>().valid(); }
  int32_t id() const { return at<2>().as_int32(); }
  bool has_cname() const { return at<3>().valid(); }
  ::protozero::ConstChars cname() const { return at<3>().as_string(); }
};

class CgroupMkdirFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = CgroupMkdirFtraceEvent_Decoder;
  enum : int32_t {
    kRootFieldNumber = 1,
    kIdFieldNumber = 2,
    kCnameFieldNumber = 3,
  };
  void set_root(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_id(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_cname(const std::string& value) {
    AppendBytes(3, value.data(), value.size());
  }
  void set_cname(const char* data, size_t size) {
    AppendBytes(3, data, size);
  }
};

class CgroupAttachTaskFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  CgroupAttachTaskFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit CgroupAttachTaskFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit CgroupAttachTaskFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dst_root() const { return at<1>().valid(); }
  int32_t dst_root() const { return at<1>().as_int32(); }
  bool has_dst_id() const { return at<2>().valid(); }
  int32_t dst_id() const { return at<2>().as_int32(); }
  bool has_pid() const { return at<3>().valid(); }
  int32_t pid() const { return at<3>().as_int32(); }
  bool has_comm() const { return at<4>().valid(); }
  ::protozero::ConstChars comm() const { return at<4>().as_string(); }
  bool has_cname() const { return at<5>().valid(); }
  ::protozero::ConstChars cname() const { return at<5>().as_string(); }
};

class CgroupAttachTaskFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = CgroupAttachTaskFtraceEvent_Decoder;
  enum : int32_t {
    kDstRootFieldNumber = 1,
    kDstIdFieldNumber = 2,
    kPidFieldNumber = 3,
    kCommFieldNumber = 4,
    kCnameFieldNumber = 5,
  };
  void set_dst_root(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_dst_id(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_pid(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_comm(const std::string& value) {
    AppendBytes(4, value.data(), value.size());
  }
  void set_comm(const char* data, size_t size) {
    AppendBytes(4, data, size);
  }
  void set_cname(const std::string& value) {
    AppendBytes(5, value.data(), value.size());
  }
  void set_cname(const char* data, size_t size) {
    AppendBytes(5, data, size);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/ftrace/clk.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_CLK_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_CLK_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class ClkSetRateFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ClkSetRateFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ClkSetRateFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ClkSetRateFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_rate() const { return at<2>().valid(); }
  uint64_t rate() const { return at<2>().as_uint64(); }
};

class ClkSetRateFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = ClkSetRateFtraceEvent_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kRateFieldNumber = 2,
  };
  void set_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_rate(uint64_t value) {
    AppendVarInt(2, value);
  }
};

class ClkDisableFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ClkDisableFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ClkDisableFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ClkDisableFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
};

class ClkDisableFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = ClkDisableFtraceEvent_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
  };
  void set_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
};

class ClkEnableFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ClkEnableFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ClkEnableFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ClkEnableFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
};

class ClkEnableFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = ClkEnableFtraceEvent_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
  };
  void set_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/ftrace/compaction.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_COMPACTION_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_COMPACTION_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class MmCompactionWakeupKcompactdFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmCompactionWakeupKcompactdFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmCompactionWakeupKcompactdFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmCompactionWakeupKcompactdFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_nid() const { return at<1>().valid(); }
  int32_t nid() const { return at<1>().as_int32(); }
  bool has_order() const { return at<2>().valid(); }
  int32_t order() const { return at<2>().as_int32(); }
  bool has_classzone_idx() const { return at<3>().valid(); }
  uint32_t classzone_idx() const { return at<3>().as_uint32(); }
};

class MmCompactionWakeupKcompactdFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmCompactionWakeupKcompactdFtraceEvent_Decoder;
  enum : int32_t {
    kNidFieldNumber = 1,
    kOrderFieldNumber = 2,
    kClasszoneIdxFieldNumber = 3,
  };
  void set_nid(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_order(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_classzone_idx(uint32_t value) {
    AppendVarInt(3, value);
  }
};

class MmCompactionTryToCompactPagesFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmCompactionTryToCompactPagesFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmCompactionTryToCompactPagesFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmCompactionTryToCompactPagesFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_order() const { return at<1>().valid(); }
  int32_t order() const { return at<1>().as_int32(); }
  bool has_gfp_mask() const { return at<2>().valid(); }
  uint32_t gfp_mask() const { return at<2>().as_uint32(); }
  bool has_mode() const { return at<3>().valid(); }
  uint32_t mode() const { return at<3>().as_uint32(); }
};

class MmCompactionTryToCompactPagesFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmCompactionTryToCompactPagesFtraceEvent_Decoder;
  enum : int32_t {
    kOrderFieldNumber = 1,
    kGfpMaskFieldNumber = 2,
    kModeFieldNumber = 3,
  };
  void set_order(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_gfp_mask(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_mode(uint32_t value) {
    AppendVarInt(3, value);
  }
};

class MmCompactionSuitableFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmCompactionSuitableFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmCompactionSuitableFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmCompactionSuitableFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_nid() const { return at<1>().valid(); }
  int32_t nid() const { return at<1>().as_int32(); }
  bool has_idx() const { return at<2>().valid(); }
  uint32_t idx() const { return at<2>().as_uint32(); }
  bool has_order() const { return at<3>().valid(); }
  int32_t order() const { return at<3>().as_int32(); }
  bool has_ret() const { return at<4>().valid(); }
  int32_t ret() const { return at<4>().as_int32(); }
};

class MmCompactionSuitableFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmCompactionSuitableFtraceEvent_Decoder;
  enum : int32_t {
    kNidFieldNumber = 1,
    kIdxFieldNumber = 2,
    kOrderFieldNumber = 3,
    kRetFieldNumber = 4,
  };
  void set_nid(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_idx(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_order(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(4, value);
  }
};

class MmCompactionMigratepagesFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmCompactionMigratepagesFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmCompactionMigratepagesFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmCompactionMigratepagesFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_nr_migrated() const { return at<1>().valid(); }
  uint64_t nr_migrated() const { return at<1>().as_uint64(); }
  bool has_nr_failed() const { return at<2>().valid(); }
  uint64_t nr_failed() const { return at<2>().as_uint64(); }
};

class MmCompactionMigratepagesFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmCompactionMigratepagesFtraceEvent_Decoder;
  enum : int32_t {
    kNrMigratedFieldNumber = 1,
    kNrFailedFieldNumber = 2,
  };
  void set_nr_migrated(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_nr_failed(uint64_t value) {
    AppendVarInt(2, value);
  }
};

class MmCompactionKcompactdWakeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmCompactionKcompactdWakeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmCompactionKcompactdWakeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmCompactionKcompactdWakeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_nid() const { return at<1>().valid(); }
  int32_t nid() const { return at<1>().as_int32(); }
  bool has_order() const { return at<2>().valid(); }
  int32_t order() const { return at<2>().as_int32(); }
  bool has_classzone_idx() const { return at<3>().valid(); }
  uint32_t classzone_idx() const { return at<3>().as_uint32(); }
};

class MmCompactionKcompactdWakeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmCompactionKcompactdWakeFtraceEvent_Decoder;
  enum : int32_t {
    kNidFieldNumber = 1,
    kOrderFieldNumber = 2,
    kClasszoneIdxFieldNumber = 3,
  };
  void set_nid(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_order(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_classzone_idx(uint32_t value) {
    AppendVarInt(3, value);
  }
};

class MmCompactionKcompactdSleepFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmCompactionKcompactdSleepFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmCompactionKcompactdSleepFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmCompactionKcompactdSleepFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_nid() const { return at<1>().valid(); }
  int32_t nid() const { return at<1>().as_int32(); }
};

class MmCompactionKcompactdSleepFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmCompactionKcompactdSleepFtraceEvent_Decoder;
  enum : int32_t {
    kNidFieldNumber = 1,
  };
  void set_nid(int32_t value) {
    AppendVarInt(1, value);
  }
};

class MmCompactionIsolateMigratepagesFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmCompactionIsolateMigratepagesFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmCompactionIsolateMigratepagesFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmCompactionIsolateMigratepagesFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_start_pfn() const { return at<1>().valid(); }
  uint64_t start_pfn() const { return at<1>().as_uint64(); }
  bool has_end_pfn() const { return at<2>().valid(); }
  uint64_t end_pfn() const { return at<2>().as_uint64(); }
  bool has_nr_scanned() const { return at<3>().valid(); }
  uint64_t nr_scanned() const { return at<3>().as_uint64(); }
  bool has_nr_taken() const { return at<4>().valid(); }
  uint64_t nr_taken() const { return at<4>().as_uint64(); }
};

class MmCompactionIsolateMigratepagesFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmCompactionIsolateMigratepagesFtraceEvent_Decoder;
  enum : int32_t {
    kStartPfnFieldNumber = 1,
    kEndPfnFieldNumber = 2,
    kNrScannedFieldNumber = 3,
    kNrTakenFieldNumber = 4,
  };
  void set_start_pfn(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_end_pfn(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_nr_scanned(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_nr_taken(uint64_t value) {
    AppendVarInt(4, value);
  }
};

class MmCompactionIsolateFreepagesFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmCompactionIsolateFreepagesFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmCompactionIsolateFreepagesFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmCompactionIsolateFreepagesFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_start_pfn() const { return at<1>().valid(); }
  uint64_t start_pfn() const { return at<1>().as_uint64(); }
  bool has_end_pfn() const { return at<2>().valid(); }
  uint64_t end_pfn() const { return at<2>().as_uint64(); }
  bool has_nr_scanned() const { return at<3>().valid(); }
  uint64_t nr_scanned() const { return at<3>().as_uint64(); }
  bool has_nr_taken() const { return at<4>().valid(); }
  uint64_t nr_taken() const { return at<4>().as_uint64(); }
};

class MmCompactionIsolateFreepagesFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmCompactionIsolateFreepagesFtraceEvent_Decoder;
  enum : int32_t {
    kStartPfnFieldNumber = 1,
    kEndPfnFieldNumber = 2,
    kNrScannedFieldNumber = 3,
    kNrTakenFieldNumber = 4,
  };
  void set_start_pfn(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_end_pfn(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_nr_scanned(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_nr_taken(uint64_t value) {
    AppendVarInt(4, value);
  }
};

class MmCompactionFinishedFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmCompactionFinishedFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmCompactionFinishedFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmCompactionFinishedFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_nid() const { return at<1>().valid(); }
  int32_t nid() const { return at<1>().as_int32(); }
  bool has_idx() const { return at<2>().valid(); }
  uint32_t idx() const { return at<2>().as_uint32(); }
  bool has_order() const { return at<3>().valid(); }
  int32_t order() const { return at<3>().as_int32(); }
  bool has_ret() const { return at<4>().valid(); }
  int32_t ret() const { return at<4>().as_int32(); }
};

class MmCompactionFinishedFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmCompactionFinishedFtraceEvent_Decoder;
  enum : int32_t {
    kNidFieldNumber = 1,
    kIdxFieldNumber = 2,
    kOrderFieldNumber = 3,
    kRetFieldNumber = 4,
  };
  void set_nid(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_idx(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_order(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(4, value);
  }
};

class MmCompactionEndFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmCompactionEndFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmCompactionEndFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmCompactionEndFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_zone_start() const { return at<1>().valid(); }
  uint64_t zone_start() const { return at<1>().as_uint64(); }
  bool has_migrate_pfn() const { return at<2>().valid(); }
  uint64_t migrate_pfn() const { return at<2>().as_uint64(); }
  bool has_free_pfn() const { return at<3>().valid(); }
  uint64_t free_pfn() const { return at<3>().as_uint64(); }
  bool has_zone_end() const { return at<4>().valid(); }
  uint64_t zone_end() const { return at<4>().as_uint64(); }
  bool has_sync() const { return at<5>().valid(); }
  uint32_t sync() const { return at<5>().as_uint32(); }
  bool has_status() const { return at<6>().valid(); }
  int32_t status() const { return at<6>().as_int32(); }
};

class MmCompactionEndFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmCompactionEndFtraceEvent_Decoder;
  enum : int32_t {
    kZoneStartFieldNumber = 1,
    kMigratePfnFieldNumber = 2,
    kFreePfnFieldNumber = 3,
    kZoneEndFieldNumber = 4,
    kSyncFieldNumber = 5,
    kStatusFieldNumber = 6,
  };
  void set_zone_start(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_migrate_pfn(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_free_pfn(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_zone_end(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_sync(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_status(int32_t value) {
    AppendVarInt(6, value);
  }
};

class MmCompactionDeferResetFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmCompactionDeferResetFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmCompactionDeferResetFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmCompactionDeferResetFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_nid() const { return at<1>().valid(); }
  int32_t nid() const { return at<1>().as_int32(); }
  bool has_idx() const { return at<2>().valid(); }
  uint32_t idx() const { return at<2>().as_uint32(); }
  bool has_order() const { return at<3>().valid(); }
  int32_t order() const { return at<3>().as_int32(); }
  bool has_considered() const { return at<4>().valid(); }
  uint32_t considered() const { return at<4>().as_uint32(); }
  bool has_defer_shift() const { return at<5>().valid(); }
  uint32_t defer_shift() const { return at<5>().as_uint32(); }
  bool has_order_failed() const { return at<6>().valid(); }
  int32_t order_failed() const { return at<6>().as_int32(); }
};

class MmCompactionDeferResetFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmCompactionDeferResetFtraceEvent_Decoder;
  enum : int32_t {
    kNidFieldNumber = 1,
    kIdxFieldNumber = 2,
    kOrderFieldNumber = 3,
    kConsideredFieldNumber = 4,
    kDeferShiftFieldNumber = 5,
    kOrderFailedFieldNumber = 6,
  };
  void set_nid(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_idx(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_order(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_considered(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_defer_shift(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_order_failed(int32_t value) {
    AppendVarInt(6, value);
  }
};

class MmCompactionDeferredFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmCompactionDeferredFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmCompactionDeferredFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmCompactionDeferredFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_nid() const { return at<1>().valid(); }
  int32_t nid() const { return at<1>().as_int32(); }
  bool has_idx() const { return at<2>().valid(); }
  uint32_t idx() const { return at<2>().as_uint32(); }
  bool has_order() const { return at<3>().valid(); }
  int32_t order() const { return at<3>().as_int32(); }
  bool has_considered() const { return at<4>().valid(); }
  uint32_t considered() const { return at<4>().as_uint32(); }
  bool has_defer_shift() const { return at<5>().valid(); }
  uint32_t defer_shift() const { return at<5>().as_uint32(); }
  bool has_order_failed() const { return at<6>().valid(); }
  int32_t order_failed() const { return at<6>().as_int32(); }
};

class MmCompactionDeferredFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmCompactionDeferredFtraceEvent_Decoder;
  enum : int32_t {
    kNidFieldNumber = 1,
    kIdxFieldNumber = 2,
    kOrderFieldNumber = 3,
    kConsideredFieldNumber = 4,
    kDeferShiftFieldNumber = 5,
    kOrderFailedFieldNumber = 6,
  };
  void set_nid(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_idx(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_order(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_considered(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_defer_shift(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_order_failed(int32_t value) {
    AppendVarInt(6, value);
  }
};

class MmCompactionDeferCompactionFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmCompactionDeferCompactionFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmCompactionDeferCompactionFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmCompactionDeferCompactionFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_nid() const { return at<1>().valid(); }
  int32_t nid() const { return at<1>().as_int32(); }
  bool has_idx() const { return at<2>().valid(); }
  uint32_t idx() const { return at<2>().as_uint32(); }
  bool has_order() const { return at<3>().valid(); }
  int32_t order() const { return at<3>().as_int32(); }
  bool has_considered() const { return at<4>().valid(); }
  uint32_t considered() const { return at<4>().as_uint32(); }
  bool has_defer_shift() const { return at<5>().valid(); }
  uint32_t defer_shift() const { return at<5>().as_uint32(); }
  bool has_order_failed() const { return at<6>().valid(); }
  int32_t order_failed() const { return at<6>().as_int32(); }
};

class MmCompactionDeferCompactionFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmCompactionDeferCompactionFtraceEvent_Decoder;
  enum : int32_t {
    kNidFieldNumber = 1,
    kIdxFieldNumber = 2,
    kOrderFieldNumber = 3,
    kConsideredFieldNumber = 4,
    kDeferShiftFieldNumber = 5,
    kOrderFailedFieldNumber = 6,
  };
  void set_nid(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_idx(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_order(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_considered(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_defer_shift(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_order_failed(int32_t value) {
    AppendVarInt(6, value);
  }
};

class MmCompactionBeginFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmCompactionBeginFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmCompactionBeginFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmCompactionBeginFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_zone_start() const { return at<1>().valid(); }
  uint64_t zone_start() const { return at<1>().as_uint64(); }
  bool has_migrate_pfn() const { return at<2>().valid(); }
  uint64_t migrate_pfn() const { return at<2>().as_uint64(); }
  bool has_free_pfn() const { return at<3>().valid(); }
  uint64_t free_pfn() const { return at<3>().as_uint64(); }
  bool has_zone_end() const { return at<4>().valid(); }
  uint64_t zone_end() const { return at<4>().as_uint64(); }
  bool has_sync() const { return at<5>().valid(); }
  uint32_t sync() const { return at<5>().as_uint32(); }
};

class MmCompactionBeginFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmCompactionBeginFtraceEvent_Decoder;
  enum : int32_t {
    kZoneStartFieldNumber = 1,
    kMigratePfnFieldNumber = 2,
    kFreePfnFieldNumber = 3,
    kZoneEndFieldNumber = 4,
    kSyncFieldNumber = 5,
  };
  void set_zone_start(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_migrate_pfn(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_free_pfn(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_zone_end(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_sync(uint32_t value) {
    AppendVarInt(5, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/ftrace/ext4.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_EXT4_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_EXT4_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class Ext4ZeroRangeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ZeroRangeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ZeroRangeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ZeroRangeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_offset() const { return at<3>().valid(); }
  int64_t offset() const { return at<3>().as_int64(); }
  bool has_len() const { return at<4>().valid(); }
  int64_t len() const { return at<4>().as_int64(); }
  bool has_mode() const { return at<5>().valid(); }
  int32_t mode() const { return at<5>().as_int32(); }
};

class Ext4ZeroRangeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ZeroRangeFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kOffsetFieldNumber = 3,
    kLenFieldNumber = 4,
    kModeFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_offset(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_len(int64_t value) {
    AppendVarInt(4, value);
  }
  void set_mode(int32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4WritepagesResultFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/7, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4WritepagesResultFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4WritepagesResultFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4WritepagesResultFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_ret() const { return at<3>().valid(); }
  int32_t ret() const { return at<3>().as_int32(); }
  bool has_pages_written() const { return at<4>().valid(); }
  int32_t pages_written() const { return at<4>().as_int32(); }
  bool has_pages_skipped() const { return at<5>().valid(); }
  int64_t pages_skipped() const { return at<5>().as_int64(); }
  bool has_writeback_index() const { return at<6>().valid(); }
  uint64_t writeback_index() const { return at<6>().as_uint64(); }
  bool has_sync_mode() const { return at<7>().valid(); }
  int32_t sync_mode() const { return at<7>().as_int32(); }
};

class Ext4WritepagesResultFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4WritepagesResultFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kRetFieldNumber = 3,
    kPagesWrittenFieldNumber = 4,
    kPagesSkippedFieldNumber = 5,
    kWritebackIndexFieldNumber = 6,
    kSyncModeFieldNumber = 7,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_pages_written(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_pages_skipped(int64_t value) {
    AppendVarInt(5, value);
  }
  void set_writeback_index(uint64_t value) {
    AppendVarInt(6, value);
  }
  void set_sync_mode(int32_t value) {
    AppendVarInt(7, value);
  }
};

class Ext4WritepagesFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/10, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4WritepagesFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4WritepagesFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4WritepagesFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_nr_to_write() const { return at<3>().valid(); }
  int64_t nr_to_write() const { return at<3>().as_int64(); }
  bool has_pages_skipped() const { return at<4>().valid(); }
  int64_t pages_skipped() const { return at<4>().as_int64(); }
  bool has_range_start() const { return at<5>().valid(); }
  int64_t range_start() const { return at<5>().as_int64(); }
  bool has_range_end() const { return at<6>().valid(); }
  int64_t range_end() const { return at<6>().as_int64(); }
  bool has_writeback_index() const { return at<7>().valid(); }
  uint64_t writeback_index() const { return at<7>().as_uint64(); }
  bool has_sync_mode() const { return at<8>().valid(); }
  int32_t sync_mode() const { return at<8>().as_int32(); }
  bool has_for_kupdate() const { return at<9>().valid(); }
  uint32_t for_kupdate() const { return at<9>().as_uint32(); }
  bool has_range_cyclic() const { return at<10>().valid(); }
  uint32_t range_cyclic() const { return at<10>().as_uint32(); }
};

class Ext4WritepagesFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4WritepagesFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kNrToWriteFieldNumber = 3,
    kPagesSkippedFieldNumber = 4,
    kRangeStartFieldNumber = 5,
    kRangeEndFieldNumber = 6,
    kWritebackIndexFieldNumber = 7,
    kSyncModeFieldNumber = 8,
    kForKupdateFieldNumber = 9,
    kRangeCyclicFieldNumber = 10,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_nr_to_write(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_pages_skipped(int64_t value) {
    AppendVarInt(4, value);
  }
  void set_range_start(int64_t value) {
    AppendVarInt(5, value);
  }
  void set_range_end(int64_t value) {
    AppendVarInt(6, value);
  }
  void set_writeback_index(uint64_t value) {
    AppendVarInt(7, value);
  }
  void set_sync_mode(int32_t value) {
    AppendVarInt(8, value);
  }
  void set_for_kupdate(uint32_t value) {
    AppendVarInt(9, value);
  }
  void set_range_cyclic(uint32_t value) {
    AppendVarInt(10, value);
  }
};

class Ext4WritepageFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4WritepageFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4WritepageFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4WritepageFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_index() const { return at<3>().valid(); }
  uint64_t index() const { return at<3>().as_uint64(); }
};

class Ext4WritepageFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4WritepageFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kIndexFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_index(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4WriteEndFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4WriteEndFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4WriteEndFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4WriteEndFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_pos() const { return at<3>().valid(); }
  int64_t pos() const { return at<3>().as_int64(); }
  bool has_len() const { return at<4>().valid(); }
  uint32_t len() const { return at<4>().as_uint32(); }
  bool has_copied() const { return at<5>().valid(); }
  uint32_t copied() const { return at<5>().as_uint32(); }
};

class Ext4WriteEndFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4WriteEndFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPosFieldNumber = 3,
    kLenFieldNumber = 4,
    kCopiedFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pos(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_copied(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4WriteBeginFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4WriteBeginFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4WriteBeginFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4WriteBeginFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_pos() const { return at<3>().valid(); }
  int64_t pos() const { return at<3>().as_int64(); }
  bool has_len() const { return at<4>().valid(); }
  uint32_t len() const { return at<4>().as_uint32(); }
  bool has_flags() const { return at<5>().valid(); }
  uint32_t flags() const { return at<5>().as_uint32(); }
};

class Ext4WriteBeginFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4WriteBeginFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPosFieldNumber = 3,
    kLenFieldNumber = 4,
    kFlagsFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pos(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4UnlinkExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4UnlinkExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4UnlinkExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4UnlinkExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_ret() const { return at<3>().valid(); }
  int32_t ret() const { return at<3>().as_int32(); }
};

class Ext4UnlinkExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4UnlinkExitFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kRetFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4UnlinkEnterFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4UnlinkEnterFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4UnlinkEnterFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4UnlinkEnterFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_parent() const { return at<3>().valid(); }
  uint64_t parent() const { return at<3>().as_uint64(); }
  bool has_size() const { return at<4>().valid(); }
  int64_t size() const { return at<4>().as_int64(); }
};

class Ext4UnlinkEnterFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4UnlinkEnterFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kParentFieldNumber = 3,
    kSizeFieldNumber = 4,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_parent(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_size(int64_t value) {
    AppendVarInt(4, value);
  }
};

class Ext4TruncateExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4TruncateExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4TruncateExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4TruncateExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_blocks() const { return at<3>().valid(); }
  uint64_t blocks() const { return at<3>().as_uint64(); }
};

class Ext4TruncateExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4TruncateExitFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kBlocksFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_blocks(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4TruncateEnterFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4TruncateEnterFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4TruncateEnterFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4TruncateEnterFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_blocks() const { return at<3>().valid(); }
  uint64_t blocks() const { return at<3>().as_uint64(); }
};

class Ext4TruncateEnterFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4TruncateEnterFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kBlocksFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_blocks(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4TrimExtentFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4TrimExtentFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4TrimExtentFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4TrimExtentFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev_major() const { return at<1>().valid(); }
  int32_t dev_major() const { return at<1>().as_int32(); }
  bool has_dev_minor() const { return at<2>().valid(); }
  int32_t dev_minor() const { return at<2>().as_int32(); }
  bool has_group() const { return at<3>().valid(); }
  uint32_t group() const { return at<3>().as_uint32(); }
  bool has_start() const { return at<4>().valid(); }
  int32_t start() const { return at<4>().as_int32(); }
  bool has_len() const { return at<5>().valid(); }
  int32_t len() const { return at<5>().as_int32(); }
};

class Ext4TrimExtentFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4TrimExtentFtraceEvent_Decoder;
  enum : int32_t {
    kDevMajorFieldNumber = 1,
    kDevMinorFieldNumber = 2,
    kGroupFieldNumber = 3,
    kStartFieldNumber = 4,
    kLenFieldNumber = 5,
  };
  void set_dev_major(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_dev_minor(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_group(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_start(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_len(int32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4TrimAllFreeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4TrimAllFreeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4TrimAllFreeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4TrimAllFreeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev_major() const { return at<1>().valid(); }
  int32_t dev_major() const { return at<1>().as_int32(); }
  bool has_dev_minor() const { return at<2>().valid(); }
  int32_t dev_minor() const { return at<2>().as_int32(); }
  bool has_group() const { return at<3>().valid(); }
  uint32_t group() const { return at<3>().as_uint32(); }
  bool has_start() const { return at<4>().valid(); }
  int32_t start() const { return at<4>().as_int32(); }
  bool has_len() const { return at<5>().valid(); }
  int32_t len() const { return at<5>().as_int32(); }
};

class Ext4TrimAllFreeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4TrimAllFreeFtraceEvent_Decoder;
  enum : int32_t {
    kDevMajorFieldNumber = 1,
    kDevMinorFieldNumber = 2,
    kGroupFieldNumber = 3,
    kStartFieldNumber = 4,
    kLenFieldNumber = 5,
  };
  void set_dev_major(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_dev_minor(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_group(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_start(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_len(int32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4SyncFsFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4SyncFsFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4SyncFsFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4SyncFsFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_wait() const { return at<2>().valid(); }
  int32_t wait() const { return at<2>().as_int32(); }
};

class Ext4SyncFsFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4SyncFsFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kWaitFieldNumber = 2,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_wait(int32_t value) {
    AppendVarInt(2, value);
  }
};

class Ext4RequestInodeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4RequestInodeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4RequestInodeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4RequestInodeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_dir() const { return at<2>().valid(); }
  uint64_t dir() const { return at<2>().as_uint64(); }
  bool has_mode() const { return at<3>().valid(); }
  uint32_t mode() const { return at<3>().as_uint32(); }
};

class Ext4RequestInodeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4RequestInodeFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kDirFieldNumber = 2,
    kModeFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_dir(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_mode(uint32_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4RequestBlocksFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/10, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4RequestBlocksFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4RequestBlocksFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4RequestBlocksFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_len() const { return at<3>().valid(); }
  uint32_t len() const { return at<3>().as_uint32(); }
  bool has_logical() const { return at<4>().valid(); }
  uint32_t logical() const { return at<4>().as_uint32(); }
  bool has_lleft() const { return at<5>().valid(); }
  uint32_t lleft() const { return at<5>().as_uint32(); }
  bool has_lright() const { return at<6>().valid(); }
  uint32_t lright() const { return at<6>().as_uint32(); }
  bool has_goal() const { return at<7>().valid(); }
  uint64_t goal() const { return at<7>().as_uint64(); }
  bool has_pleft() const { return at<8>().valid(); }
  uint64_t pleft() const { return at<8>().as_uint64(); }
  bool has_pright() const { return at<9>().valid(); }
  uint64_t pright() const { return at<9>().as_uint64(); }
  bool has_flags() const { return at<10>().valid(); }
  uint32_t flags() const { return at<10>().as_uint32(); }
};

class Ext4RequestBlocksFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4RequestBlocksFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLenFieldNumber = 3,
    kLogicalFieldNumber = 4,
    kLleftFieldNumber = 5,
    kLrightFieldNumber = 6,
    kGoalFieldNumber = 7,
    kPleftFieldNumber = 8,
    kPrightFieldNumber = 9,
    kFlagsFieldNumber = 10,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_logical(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_lleft(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_lright(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_goal(uint64_t value) {
    AppendVarInt(7, value);
  }
  void set_pleft(uint64_t value) {
    AppendVarInt(8, value);
  }
  void set_pright(uint64_t value) {
    AppendVarInt(9, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(10, value);
  }
};

class Ext4RemoveBlocksFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4RemoveBlocksFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4RemoveBlocksFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4RemoveBlocksFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_from() const { return at<3>().valid(); }
  uint32_t from() const { return at<3>().as_uint32(); }
  bool has_to() const { return at<4>().valid(); }
  uint32_t to() const { return at<4>().as_uint32(); }
  bool has_partial() const { return at<5>().valid(); }
  int64_t partial() const { return at<5>().as_int64(); }
  bool has_ee_pblk() const { return at<6>().valid(); }
  uint64_t ee_pblk() const { return at<6>().as_uint64(); }
  bool has_ee_lblk() const { return at<7>().valid(); }
  uint32_t ee_lblk() const { return at<7>().as_uint32(); }
  bool has_ee_len() const { return at<8>().valid(); }
  uint32_t ee_len() const { return at<8>().as_uint32(); }
};

class Ext4RemoveBlocksFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4RemoveBlocksFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kFromFieldNumber = 3,
    kToFieldNumber = 4,
    kPartialFieldNumber = 5,
    kEePblkFieldNumber = 6,
    kEeLblkFieldNumber = 7,
    kEeLenFieldNumber = 8,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_from(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_to(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_partial(int64_t value) {
    AppendVarInt(5, value);
  }
  void set_ee_pblk(uint64_t value) {
    AppendVarInt(6, value);
  }
  void set_ee_lblk(uint32_t value) {
    AppendVarInt(7, value);
  }
  void set_ee_len(uint32_t value) {
    AppendVarInt(8, value);
  }
};

class Ext4ReleasepageFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ReleasepageFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ReleasepageFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ReleasepageFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_index() const { return at<3>().valid(); }
  uint64_t index() const { return at<3>().as_uint64(); }
};

class Ext4ReleasepageFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ReleasepageFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kIndexFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_index(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4ReadpageFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ReadpageFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ReadpageFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ReadpageFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_index() const { return at<3>().valid(); }
  uint64_t index() const { return at<3>().as_uint64(); }
};

class Ext4ReadpageFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ReadpageFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kIndexFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_index(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4ReadBlockBitmapLoadFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ReadBlockBitmapLoadFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ReadBlockBitmapLoadFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ReadBlockBitmapLoadFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_group() const { return at<2>().valid(); }
  uint32_t group() const { return at<2>().as_uint32(); }
};

class Ext4ReadBlockBitmapLoadFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ReadBlockBitmapLoadFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kGroupFieldNumber = 2,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_group(uint32_t value) {
    AppendVarInt(2, value);
  }
};

class Ext4PunchHoleFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4PunchHoleFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4PunchHoleFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4PunchHoleFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_offset() const { return at<3>().valid(); }
  int64_t offset() const { return at<3>().as_int64(); }
  bool has_len() const { return at<4>().valid(); }
  int64_t len() const { return at<4>().as_int64(); }
  bool has_mode() const { return at<5>().valid(); }
  int32_t mode() const { return at<5>().as_int32(); }
};

class Ext4PunchHoleFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4PunchHoleFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kOffsetFieldNumber = 3,
    kLenFieldNumber = 4,
    kModeFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_offset(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_len(int64_t value) {
    AppendVarInt(4, value);
  }
  void set_mode(int32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4OtherInodeUpdateTimeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4OtherInodeUpdateTimeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4OtherInodeUpdateTimeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4OtherInodeUpdateTimeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_orig_ino() const { return at<3>().valid(); }
  uint64_t orig_ino() const { return at<3>().as_uint64(); }
  bool has_uid() const { return at<4>().valid(); }
  uint32_t uid() const { return at<4>().as_uint32(); }
  bool has_gid() const { return at<5>().valid(); }
  uint32_t gid() const { return at<5>().as_uint32(); }
  bool has_mode() const { return at<6>().valid(); }
  uint32_t mode() const { return at<6>().as_uint32(); }
};

class Ext4OtherInodeUpdateTimeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4OtherInodeUpdateTimeFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kOrigInoFieldNumber = 3,
    kUidFieldNumber = 4,
    kGidFieldNumber = 5,
    kModeFieldNumber = 6,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_orig_ino(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_uid(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_gid(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_mode(uint32_t value) {
    AppendVarInt(6, value);
  }
};

class Ext4MballocPreallocFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/10, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4MballocPreallocFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4MballocPreallocFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4MballocPreallocFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_orig_logical() const { return at<3>().valid(); }
  uint32_t orig_logical() const { return at<3>().as_uint32(); }
  bool has_orig_start() const { return at<4>().valid(); }
  int32_t orig_start() const { return at<4>().as_int32(); }
  bool has_orig_group() const { return at<5>().valid(); }
  uint32_t orig_group() const { return at<5>().as_uint32(); }
  bool has_orig_len() const { return at<6>().valid(); }
  int32_t orig_len() const { return at<6>().as_int32(); }
  bool has_result_logical() const { return at<7>().valid(); }
  uint32_t result_logical() const { return at<7>().as_uint32(); }
  bool has_result_start() const { return at<8>().valid(); }
  int32_t result_start() const { return at<8>().as_int32(); }
  bool has_result_group() const { return at<9>().valid(); }
  uint32_t result_group() const { return at<9>().as_uint32(); }
  bool has_result_len() const { return at<10>().valid(); }
  int32_t result_len() const { return at<10>().as_int32(); }
};

class Ext4MballocPreallocFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4MballocPreallocFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kOrigLogicalFieldNumber = 3,
    kOrigStartFieldNumber = 4,
    kOrigGroupFieldNumber = 5,
    kOrigLenFieldNumber = 6,
    kResultLogicalFieldNumber = 7,
    kResultStartFieldNumber = 8,
    kResultGroupFieldNumber = 9,
    kResultLenFieldNumber = 10,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_orig_logical(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_orig_start(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_orig_group(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_orig_len(int32_t value) {
    AppendVarInt(6, value);
  }
  void set_result_logical(uint32_t value) {
    AppendVarInt(7, value);
  }
  void set_result_start(int32_t value) {
    AppendVarInt(8, value);
  }
  void set_result_group(uint32_t value) {
    AppendVarInt(9, value);
  }
  void set_result_len(int32_t value) {
    AppendVarInt(10, value);
  }
};

class Ext4MballocFreeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4MballocFreeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4MballocFreeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4MballocFreeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_result_start() const { return at<3>().valid(); }
  int32_t result_start() const { return at<3>().as_int32(); }
  bool has_result_group() const { return at<4>().valid(); }
  uint32_t result_group() const { return at<4>().as_uint32(); }
  bool has_result_len() const { return at<5>().valid(); }
  int32_t result_len() const { return at<5>().as_int32(); }
};

class Ext4MballocFreeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4MballocFreeFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kResultStartFieldNumber = 3,
    kResultGroupFieldNumber = 4,
    kResultLenFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_result_start(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_result_group(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_result_len(int32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4MballocDiscardFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4MballocDiscardFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4MballocDiscardFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4MballocDiscardFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_result_start() const { return at<3>().valid(); }
  int32_t result_start() const { return at<3>().as_int32(); }
  bool has_result_group() const { return at<4>().valid(); }
  uint32_t result_group() const { return at<4>().as_uint32(); }
  bool has_result_len() const { return at<5>().valid(); }
  int32_t result_len() const { return at<5>().as_int32(); }
};

class Ext4MballocDiscardFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4MballocDiscardFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kResultStartFieldNumber = 3,
    kResultGroupFieldNumber = 4,
    kResultLenFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_result_start(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_result_group(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_result_len(int32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4MballocAllocFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/20, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4MballocAllocFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4MballocAllocFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4MballocAllocFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_orig_logical() const { return at<3>().valid(); }
  uint32_t orig_logical() const { return at<3>().as_uint32(); }
  bool has_orig_start() const { return at<4>().valid(); }
  int32_t orig_start() const { return at<4>().as_int32(); }
  bool has_orig_group() const { return at<5>().valid(); }
  uint32_t orig_group() const { return at<5>().as_uint32(); }
  bool has_orig_len() const { return at<6>().valid(); }
  int32_t orig_len() const { return at<6>().as_int32(); }
  bool has_goal_logical() const { return at<7>().valid(); }
  uint32_t goal_logical() const { return at<7>().as_uint32(); }
  bool has_goal_start() const { return at<8>().valid(); }
  int32_t goal_start() const { return at<8>().as_int32(); }
  bool has_goal_group() const { return at<9>().valid(); }
  uint32_t goal_group() const { return at<9>().as_uint32(); }
  bool has_goal_len() const { return at<10>().valid(); }
  int32_t goal_len() const { return at<10>().as_int32(); }
  bool has_result_logical() const { return at<11>().valid(); }
  uint32_t result_logical() const { return at<11>().as_uint32(); }
  bool has_result_start() const { return at<12>().valid(); }
  int32_t result_start() const { return at<12>().as_int32(); }
  bool has_result_group() const { return at<13>().valid(); }
  uint32_t result_group() const { return at<13>().as_uint32(); }
  bool has_result_len() const { return at<14>().valid(); }
  int32_t result_len() const { return at<14>().as_int32(); }
  bool has_found() const { return at<15>().valid(); }
  uint32_t found() const { return at<15>().as_uint32(); }
  bool has_groups() const { return at<16>().valid(); }
  uint32_t groups() const { return at<16>().as_uint32(); }
  bool has_buddy() const { return at<17>().valid(); }
  uint32_t buddy() const { return at<17>().as_uint32(); }
  bool has_flags() const { return at<18>().valid(); }
  uint32_t flags() const { return at<18>().as_uint32(); }
  bool has_tail() const { return at<19>().valid(); }
  uint32_t tail() const { return at<19>().as_uint32(); }
  bool has_cr() const { return at<20>().valid(); }
  uint32_t cr() const { return at<20>().as_uint32(); }
};

class Ext4MballocAllocFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4MballocAllocFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kOrigLogicalFieldNumber = 3,
    kOrigStartFieldNumber = 4,
    kOrigGroupFieldNumber = 5,
    kOrigLenFieldNumber = 6,
    kGoalLogicalFieldNumber = 7,
    kGoalStartFieldNumber = 8,
    kGoalGroupFieldNumber = 9,
    kGoalLenFieldNumber = 10,
    kResultLogicalFieldNumber = 11,
    kResultStartFieldNumber = 12,
    kResultGroupFieldNumber = 13,
    kResultLenFieldNumber = 14,
    kFoundFieldNumber = 15,
    kGroupsFieldNumber = 16,
    kBuddyFieldNumber = 17,
    kFlagsFieldNumber = 18,
    kTailFieldNumber = 19,
    kCrFieldNumber = 20,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_orig_logical(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_orig_start(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_orig_group(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_orig_len(int32_t value) {
    AppendVarInt(6, value);
  }
  void set_goal_logical(uint32_t value) {
    AppendVarInt(7, value);
  }
  void set_goal_start(int32_t value) {
    AppendVarInt(8, value);
  }
  void set_goal_group(uint32_t value) {
    AppendVarInt(9, value);
  }
  void set_goal_len(int32_t value) {
    AppendVarInt(10, value);
  }
  void set_result_logical(uint32_t value) {
    AppendVarInt(11, value);
  }
  void set_result_start(int32_t value) {
    AppendVarInt(12, value);
  }
  void set_result_group(uint32_t value) {
    AppendVarInt(13, value);
  }
  void set_result_len(int32_t value) {
    AppendVarInt(14, value);
  }
  void set_found(uint32_t value) {
    AppendVarInt(15, value);
  }
  void set_groups(uint32_t value) {
    AppendVarInt(16, value);
  }
  void set_buddy(uint32_t value) {
    AppendVarInt(17, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(18, value);
  }
  void set_tail(uint32_t value) {
    AppendVarInt(19, value);
  }
  void set_cr(uint32_t value) {
    AppendVarInt(20, value);
  }
};

class Ext4MbReleaseInodePaFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4MbReleaseInodePaFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4MbReleaseInodePaFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4MbReleaseInodePaFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_block() const { return at<3>().valid(); }
  uint64_t block() const { return at<3>().as_uint64(); }
  bool has_count() const { return at<4>().valid(); }
  uint32_t count() const { return at<4>().as_uint32(); }
};

class Ext4MbReleaseInodePaFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4MbReleaseInodePaFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kBlockFieldNumber = 3,
    kCountFieldNumber = 4,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_block(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_count(uint32_t value) {
    AppendVarInt(4, value);
  }
};

class Ext4MbReleaseGroupPaFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4MbReleaseGroupPaFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4MbReleaseGroupPaFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4MbReleaseGroupPaFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_pa_pstart() const { return at<2>().valid(); }
  uint64_t pa_pstart() const { return at<2>().as_uint64(); }
  bool has_pa_len() const { return at<3>().valid(); }
  uint32_t pa_len() const { return at<3>().as_uint32(); }
};

class Ext4MbReleaseGroupPaFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4MbReleaseGroupPaFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kPaPstartFieldNumber = 2,
    kPaLenFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_pa_pstart(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pa_len(uint32_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4MbNewInodePaFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4MbNewInodePaFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4MbNewInodePaFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4MbNewInodePaFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_pa_pstart() const { return at<3>().valid(); }
  uint64_t pa_pstart() const { return at<3>().as_uint64(); }
  bool has_pa_lstart() const { return at<4>().valid(); }
  uint64_t pa_lstart() const { return at<4>().as_uint64(); }
  bool has_pa_len() const { return at<5>().valid(); }
  uint32_t pa_len() const { return at<5>().as_uint32(); }
};

class Ext4MbNewInodePaFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4MbNewInodePaFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPaPstartFieldNumber = 3,
    kPaLstartFieldNumber = 4,
    kPaLenFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pa_pstart(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_pa_lstart(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_pa_len(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4MbNewGroupPaFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4MbNewGroupPaFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4MbNewGroupPaFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4MbNewGroupPaFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_pa_pstart() const { return at<3>().valid(); }
  uint64_t pa_pstart() const { return at<3>().as_uint64(); }
  bool has_pa_lstart() const { return at<4>().valid(); }
  uint64_t pa_lstart() const { return at<4>().as_uint64(); }
  bool has_pa_len() const { return at<5>().valid(); }
  uint32_t pa_len() const { return at<5>().as_uint32(); }
};

class Ext4MbNewGroupPaFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4MbNewGroupPaFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPaPstartFieldNumber = 3,
    kPaLstartFieldNumber = 4,
    kPaLenFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pa_pstart(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_pa_lstart(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_pa_len(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4MbDiscardPreallocationsFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4MbDiscardPreallocationsFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4MbDiscardPreallocationsFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4MbDiscardPreallocationsFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_needed() const { return at<2>().valid(); }
  int32_t needed() const { return at<2>().as_int32(); }
};

class Ext4MbDiscardPreallocationsFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4MbDiscardPreallocationsFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kNeededFieldNumber = 2,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_needed(int32_t value) {
    AppendVarInt(2, value);
  }
};

class Ext4MbBuddyBitmapLoadFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4MbBuddyBitmapLoadFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4MbBuddyBitmapLoadFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4MbBuddyBitmapLoadFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_group() const { return at<2>().valid(); }
  uint32_t group() const { return at<2>().as_uint32(); }
};

class Ext4MbBuddyBitmapLoadFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4MbBuddyBitmapLoadFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kGroupFieldNumber = 2,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_group(uint32_t value) {
    AppendVarInt(2, value);
  }
};

class Ext4MbBitmapLoadFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4MbBitmapLoadFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4MbBitmapLoadFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4MbBitmapLoadFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_group() const { return at<2>().valid(); }
  uint32_t group() const { return at<2>().as_uint32(); }
};

class Ext4MbBitmapLoadFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4MbBitmapLoadFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kGroupFieldNumber = 2,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_group(uint32_t value) {
    AppendVarInt(2, value);
  }
};

class Ext4MarkInodeDirtyFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4MarkInodeDirtyFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4MarkInodeDirtyFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4MarkInodeDirtyFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_ip() const { return at<3>().valid(); }
  uint64_t ip() const { return at<3>().as_uint64(); }
};

class Ext4MarkInodeDirtyFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4MarkInodeDirtyFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kIpFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_ip(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4LoadInodeBitmapFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4LoadInodeBitmapFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4LoadInodeBitmapFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4LoadInodeBitmapFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_group() const { return at<2>().valid(); }
  uint32_t group() const { return at<2>().as_uint32(); }
};

class Ext4LoadInodeBitmapFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4LoadInodeBitmapFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kGroupFieldNumber = 2,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_group(uint32_t value) {
    AppendVarInt(2, value);
  }
};

class Ext4LoadInodeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4LoadInodeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4LoadInodeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4LoadInodeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
};

class Ext4LoadInodeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4LoadInodeFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
};

class Ext4JournalledWriteEndFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4JournalledWriteEndFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4JournalledWriteEndFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4JournalledWriteEndFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_pos() const { return at<3>().valid(); }
  int64_t pos() const { return at<3>().as_int64(); }
  bool has_len() const { return at<4>().valid(); }
  uint32_t len() const { return at<4>().as_uint32(); }
  bool has_copied() const { return at<5>().valid(); }
  uint32_t copied() const { return at<5>().as_uint32(); }
};

class Ext4JournalledWriteEndFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4JournalledWriteEndFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPosFieldNumber = 3,
    kLenFieldNumber = 4,
    kCopiedFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pos(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_copied(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4JournalledInvalidatepageFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4JournalledInvalidatepageFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4JournalledInvalidatepageFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4JournalledInvalidatepageFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_index() const { return at<3>().valid(); }
  uint64_t index() const { return at<3>().as_uint64(); }
  bool has_offset() const { return at<4>().valid(); }
  uint64_t offset() const { return at<4>().as_uint64(); }
  bool has_length() const { return at<5>().valid(); }
  uint32_t length() const { return at<5>().as_uint32(); }
};

class Ext4JournalledInvalidatepageFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4JournalledInvalidatepageFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kIndexFieldNumber = 3,
    kOffsetFieldNumber = 4,
    kLengthFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_index(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_offset(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_length(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4JournalStartReservedFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4JournalStartReservedFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4JournalStartReservedFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4JournalStartReservedFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ip() const { return at<2>().valid(); }
  uint64_t ip() const { return at<2>().as_uint64(); }
  bool has_blocks() const { return at<3>().valid(); }
  int32_t blocks() const { return at<3>().as_int32(); }
};

class Ext4JournalStartReservedFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4JournalStartReservedFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kIpFieldNumber = 2,
    kBlocksFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ip(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_blocks(int32_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4JournalStartFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4JournalStartFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4JournalStartFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4JournalStartFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ip() const { return at<2>().valid(); }
  uint64_t ip() const { return at<2>().as_uint64(); }
  bool has_blocks() const { return at<3>().valid(); }
  int32_t blocks() const { return at<3>().as_int32(); }
  bool has_rsv_blocks() const { return at<4>().valid(); }
  int32_t rsv_blocks() const { return at<4>().as_int32(); }
  bool has_nblocks() const { return at<5>().valid(); }
  int32_t nblocks() const { return at<5>().as_int32(); }
};

class Ext4JournalStartFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4JournalStartFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kIpFieldNumber = 2,
    kBlocksFieldNumber = 3,
    kRsvBlocksFieldNumber = 4,
    kNblocksFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ip(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_blocks(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_rsv_blocks(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_nblocks(int32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4InvalidatepageFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4InvalidatepageFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4InvalidatepageFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4InvalidatepageFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_index() const { return at<3>().valid(); }
  uint64_t index() const { return at<3>().as_uint64(); }
  bool has_offset() const { return at<4>().valid(); }
  uint64_t offset() const { return at<4>().as_uint64(); }
  bool has_length() const { return at<5>().valid(); }
  uint32_t length() const { return at<5>().as_uint32(); }
};

class Ext4InvalidatepageFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4InvalidatepageFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kIndexFieldNumber = 3,
    kOffsetFieldNumber = 4,
    kLengthFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_index(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_offset(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_length(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4InsertRangeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4InsertRangeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4InsertRangeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4InsertRangeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_offset() const { return at<3>().valid(); }
  int64_t offset() const { return at<3>().as_int64(); }
  bool has_len() const { return at<4>().valid(); }
  int64_t len() const { return at<4>().as_int64(); }
};

class Ext4InsertRangeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4InsertRangeFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kOffsetFieldNumber = 3,
    kLenFieldNumber = 4,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_offset(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_len(int64_t value) {
    AppendVarInt(4, value);
  }
};

class Ext4IndMapBlocksExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4IndMapBlocksExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4IndMapBlocksExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4IndMapBlocksExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_flags() const { return at<3>().valid(); }
  uint32_t flags() const { return at<3>().as_uint32(); }
  bool has_pblk() const { return at<4>().valid(); }
  uint64_t pblk() const { return at<4>().as_uint64(); }
  bool has_lblk() const { return at<5>().valid(); }
  uint32_t lblk() const { return at<5>().as_uint32(); }
  bool has_len() const { return at<6>().valid(); }
  uint32_t len() const { return at<6>().as_uint32(); }
  bool has_mflags() const { return at<7>().valid(); }
  uint32_t mflags() const { return at<7>().as_uint32(); }
  bool has_ret() const { return at<8>().valid(); }
  int32_t ret() const { return at<8>().as_int32(); }
};

class Ext4IndMapBlocksExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4IndMapBlocksExitFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kFlagsFieldNumber = 3,
    kPblkFieldNumber = 4,
    kLblkFieldNumber = 5,
    kLenFieldNumber = 6,
    kMflagsFieldNumber = 7,
    kRetFieldNumber = 8,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_pblk(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_lblk(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_mflags(uint32_t value) {
    AppendVarInt(7, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(8, value);
  }
};

class Ext4IndMapBlocksEnterFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4IndMapBlocksEnterFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4IndMapBlocksEnterFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4IndMapBlocksEnterFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_lblk() const { return at<3>().valid(); }
  uint32_t lblk() const { return at<3>().as_uint32(); }
  bool has_len() const { return at<4>().valid(); }
  uint32_t len() const { return at<4>().as_uint32(); }
  bool has_flags() const { return at<5>().valid(); }
  uint32_t flags() const { return at<5>().as_uint32(); }
};

class Ext4IndMapBlocksEnterFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4IndMapBlocksEnterFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLblkFieldNumber = 3,
    kLenFieldNumber = 4,
    kFlagsFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_lblk(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4GetReservedClusterAllocFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4GetReservedClusterAllocFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4GetReservedClusterAllocFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4GetReservedClusterAllocFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_lblk() const { return at<3>().valid(); }
  uint32_t lblk() const { return at<3>().as_uint32(); }
  bool has_len() const { return at<4>().valid(); }
  uint32_t len() const { return at<4>().as_uint32(); }
};

class Ext4GetReservedClusterAllocFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4GetReservedClusterAllocFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLblkFieldNumber = 3,
    kLenFieldNumber = 4,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_lblk(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(4, value);
  }
};

class Ext4GetImpliedClusterAllocExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4GetImpliedClusterAllocExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4GetImpliedClusterAllocExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4GetImpliedClusterAllocExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_flags() const { return at<2>().valid(); }
  uint32_t flags() const { return at<2>().as_uint32(); }
  bool has_lblk() const { return at<3>().valid(); }
  uint32_t lblk() const { return at<3>().as_uint32(); }
  bool has_pblk() const { return at<4>().valid(); }
  uint64_t pblk() const { return at<4>().as_uint64(); }
  bool has_len() const { return at<5>().valid(); }
  uint32_t len() const { return at<5>().as_uint32(); }
  bool has_ret() const { return at<6>().valid(); }
  int32_t ret() const { return at<6>().as_int32(); }
};

class Ext4GetImpliedClusterAllocExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4GetImpliedClusterAllocExitFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kLblkFieldNumber = 3,
    kPblkFieldNumber = 4,
    kLenFieldNumber = 5,
    kRetFieldNumber = 6,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_lblk(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_pblk(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(6, value);
  }
};

class Ext4FreeInodeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4FreeInodeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4FreeInodeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4FreeInodeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_uid() const { return at<3>().valid(); }
  uint32_t uid() const { return at<3>().as_uint32(); }
  bool has_gid() const { return at<4>().valid(); }
  uint32_t gid() const { return at<4>().as_uint32(); }
  bool has_blocks() const { return at<5>().valid(); }
  uint64_t blocks() const { return at<5>().as_uint64(); }
  bool has_mode() const { return at<6>().valid(); }
  uint32_t mode() const { return at<6>().as_uint32(); }
};

class Ext4FreeInodeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4FreeInodeFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kUidFieldNumber = 3,
    kGidFieldNumber = 4,
    kBlocksFieldNumber = 5,
    kModeFieldNumber = 6,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_uid(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_gid(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_blocks(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_mode(uint32_t value) {
    AppendVarInt(6, value);
  }
};

class Ext4FreeBlocksFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4FreeBlocksFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4FreeBlocksFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4FreeBlocksFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_block() const { return at<3>().valid(); }
  uint64_t block() const { return at<3>().as_uint64(); }
  bool has_count() const { return at<4>().valid(); }
  uint64_t count() const { return at<4>().as_uint64(); }
  bool has_flags() const { return at<5>().valid(); }
  int32_t flags() const { return at<5>().as_int32(); }
  bool has_mode() const { return at<6>().valid(); }
  uint32_t mode() const { return at<6>().as_uint32(); }
};

class Ext4FreeBlocksFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4FreeBlocksFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kBlockFieldNumber = 3,
    kCountFieldNumber = 4,
    kFlagsFieldNumber = 5,
    kModeFieldNumber = 6,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_block(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_count(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_flags(int32_t value) {
    AppendVarInt(5, value);
  }
  void set_mode(uint32_t value) {
    AppendVarInt(6, value);
  }
};

class Ext4ForgetFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ForgetFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ForgetFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ForgetFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_block() const { return at<3>().valid(); }
  uint64_t block() const { return at<3>().as_uint64(); }
  bool has_is_metadata() const { return at<4>().valid(); }
  int32_t is_metadata() const { return at<4>().as_int32(); }
  bool has_mode() const { return at<5>().valid(); }
  uint32_t mode() const { return at<5>().as_uint32(); }
};

class Ext4ForgetFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ForgetFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kBlockFieldNumber = 3,
    kIsMetadataFieldNumber = 4,
    kModeFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_block(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_is_metadata(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_mode(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4FindDelallocRangeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/7, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4FindDelallocRangeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4FindDelallocRangeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4FindDelallocRangeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_from() const { return at<3>().valid(); }
  uint32_t from() const { return at<3>().as_uint32(); }
  bool has_to() const { return at<4>().valid(); }
  uint32_t to() const { return at<4>().as_uint32(); }
  bool has_reverse() const { return at<5>().valid(); }
  int32_t reverse() const { return at<5>().as_int32(); }
  bool has_found() const { return at<6>().valid(); }
  int32_t found() const { return at<6>().as_int32(); }
  bool has_found_blk() const { return at<7>().valid(); }
  uint32_t found_blk() const { return at<7>().as_uint32(); }
};

class Ext4FindDelallocRangeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4FindDelallocRangeFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kFromFieldNumber = 3,
    kToFieldNumber = 4,
    kReverseFieldNumber = 5,
    kFoundFieldNumber = 6,
    kFoundBlkFieldNumber = 7,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_from(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_to(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_reverse(int32_t value) {
    AppendVarInt(5, value);
  }
  void set_found(int32_t value) {
    AppendVarInt(6, value);
  }
  void set_found_blk(uint32_t value) {
    AppendVarInt(7, value);
  }
};

class Ext4FallocateExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4FallocateExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4FallocateExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4FallocateExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_pos() const { return at<3>().valid(); }
  int64_t pos() const { return at<3>().as_int64(); }
  bool has_blocks() const { return at<4>().valid(); }
  uint32_t blocks() const { return at<4>().as_uint32(); }
  bool has_ret() const { return at<5>().valid(); }
  int32_t ret() const { return at<5>().as_int32(); }
};

class Ext4FallocateExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4FallocateExitFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPosFieldNumber = 3,
    kBlocksFieldNumber = 4,
    kRetFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pos(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_blocks(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4FallocateEnterFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4FallocateEnterFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4FallocateEnterFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4FallocateEnterFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_offset() const { return at<3>().valid(); }
  int64_t offset() const { return at<3>().as_int64(); }
  bool has_len() const { return at<4>().valid(); }
  int64_t len() const { return at<4>().as_int64(); }
  bool has_mode() const { return at<5>().valid(); }
  int32_t mode() const { return at<5>().as_int32(); }
  bool has_pos() const { return at<6>().valid(); }
  int64_t pos() const { return at<6>().as_int64(); }
};

class Ext4FallocateEnterFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4FallocateEnterFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kOffsetFieldNumber = 3,
    kLenFieldNumber = 4,
    kModeFieldNumber = 5,
    kPosFieldNumber = 6,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_offset(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_len(int64_t value) {
    AppendVarInt(4, value);
  }
  void set_mode(int32_t value) {
    AppendVarInt(5, value);
  }
  void set_pos(int64_t value) {
    AppendVarInt(6, value);
  }
};

class Ext4ExtShowExtentFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ExtShowExtentFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ExtShowExtentFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ExtShowExtentFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_pblk() const { return at<3>().valid(); }
  uint64_t pblk() const { return at<3>().as_uint64(); }
  bool has_lblk() const { return at<4>().valid(); }
  uint32_t lblk() const { return at<4>().as_uint32(); }
  bool has_len() const { return at<5>().valid(); }
  uint32_t len() const { return at<5>().as_uint32(); }
};

class Ext4ExtShowExtentFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ExtShowExtentFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPblkFieldNumber = 3,
    kLblkFieldNumber = 4,
    kLenFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pblk(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_lblk(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4ExtRmLeafFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/7, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ExtRmLeafFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ExtRmLeafFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ExtRmLeafFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_partial() const { return at<3>().valid(); }
  int64_t partial() const { return at<3>().as_int64(); }
  bool has_start() const { return at<4>().valid(); }
  uint32_t start() const { return at<4>().as_uint32(); }
  bool has_ee_lblk() const { return at<5>().valid(); }
  uint32_t ee_lblk() const { return at<5>().as_uint32(); }
  bool has_ee_pblk() const { return at<6>().valid(); }
  uint64_t ee_pblk() const { return at<6>().as_uint64(); }
  bool has_ee_len() const { return at<7>().valid(); }
  int32_t ee_len() const { return at<7>().as_int32(); }
};

class Ext4ExtRmLeafFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ExtRmLeafFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPartialFieldNumber = 3,
    kStartFieldNumber = 4,
    kEeLblkFieldNumber = 5,
    kEePblkFieldNumber = 6,
    kEeLenFieldNumber = 7,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_partial(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_start(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_ee_lblk(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_ee_pblk(uint64_t value) {
    AppendVarInt(6, value);
  }
  void set_ee_len(int32_t value) {
    AppendVarInt(7, value);
  }
};

class Ext4ExtRmIdxFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ExtRmIdxFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ExtRmIdxFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ExtRmIdxFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_pblk() const { return at<3>().valid(); }
  uint64_t pblk() const { return at<3>().as_uint64(); }
};

class Ext4ExtRmIdxFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ExtRmIdxFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPblkFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pblk(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4ExtRemoveSpaceDoneFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/7, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ExtRemoveSpaceDoneFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ExtRemoveSpaceDoneFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ExtRemoveSpaceDoneFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_start() const { return at<3>().valid(); }
  uint32_t start() const { return at<3>().as_uint32(); }
  bool has_end() const { return at<4>().valid(); }
  uint32_t end() const { return at<4>().as_uint32(); }
  bool has_depth() const { return at<5>().valid(); }
  int32_t depth() const { return at<5>().as_int32(); }
  bool has_partial() const { return at<6>().valid(); }
  int64_t partial() const { return at<6>().as_int64(); }
  bool has_eh_entries() const { return at<7>().valid(); }
  uint32_t eh_entries() const { return at<7>().as_uint32(); }
};

class Ext4ExtRemoveSpaceDoneFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ExtRemoveSpaceDoneFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kStartFieldNumber = 3,
    kEndFieldNumber = 4,
    kDepthFieldNumber = 5,
    kPartialFieldNumber = 6,
    kEhEntriesFieldNumber = 7,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_start(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_end(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_depth(int32_t value) {
    AppendVarInt(5, value);
  }
  void set_partial(int64_t value) {
    AppendVarInt(6, value);
  }
  void set_eh_entries(uint32_t value) {
    AppendVarInt(7, value);
  }
};

class Ext4ExtRemoveSpaceFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ExtRemoveSpaceFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ExtRemoveSpaceFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ExtRemoveSpaceFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_start() const { return at<3>().valid(); }
  uint32_t start() const { return at<3>().as_uint32(); }
  bool has_end() const { return at<4>().valid(); }
  uint32_t end() const { return at<4>().as_uint32(); }
  bool has_depth() const { return at<5>().valid(); }
  int32_t depth() const { return at<5>().as_int32(); }
};

class Ext4ExtRemoveSpaceFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ExtRemoveSpaceFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kStartFieldNumber = 3,
    kEndFieldNumber = 4,
    kDepthFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_start(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_end(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_depth(int32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4ExtPutInCacheFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ExtPutInCacheFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ExtPutInCacheFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ExtPutInCacheFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_lblk() const { return at<3>().valid(); }
  uint32_t lblk() const { return at<3>().as_uint32(); }
  bool has_len() const { return at<4>().valid(); }
  uint32_t len() const { return at<4>().as_uint32(); }
  bool has_start() const { return at<5>().valid(); }
  uint64_t start() const { return at<5>().as_uint64(); }
};

class Ext4ExtPutInCacheFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ExtPutInCacheFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLblkFieldNumber = 3,
    kLenFieldNumber = 4,
    kStartFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_lblk(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_start(uint64_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4ExtMapBlocksExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ExtMapBlocksExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ExtMapBlocksExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ExtMapBlocksExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_flags() const { return at<3>().valid(); }
  uint32_t flags() const { return at<3>().as_uint32(); }
  bool has_pblk() const { return at<4>().valid(); }
  uint64_t pblk() const { return at<4>().as_uint64(); }
  bool has_lblk() const { return at<5>().valid(); }
  uint32_t lblk() const { return at<5>().as_uint32(); }
  bool has_len() const { return at<6>().valid(); }
  uint32_t len() const { return at<6>().as_uint32(); }
  bool has_mflags() const { return at<7>().valid(); }
  uint32_t mflags() const { return at<7>().as_uint32(); }
  bool has_ret() const { return at<8>().valid(); }
  int32_t ret() const { return at<8>().as_int32(); }
};

class Ext4ExtMapBlocksExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ExtMapBlocksExitFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kFlagsFieldNumber = 3,
    kPblkFieldNumber = 4,
    kLblkFieldNumber = 5,
    kLenFieldNumber = 6,
    kMflagsFieldNumber = 7,
    kRetFieldNumber = 8,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_pblk(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_lblk(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_mflags(uint32_t value) {
    AppendVarInt(7, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(8, value);
  }
};

class Ext4ExtMapBlocksEnterFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ExtMapBlocksEnterFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ExtMapBlocksEnterFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ExtMapBlocksEnterFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_lblk() const { return at<3>().valid(); }
  uint32_t lblk() const { return at<3>().as_uint32(); }
  bool has_len() const { return at<4>().valid(); }
  uint32_t len() const { return at<4>().as_uint32(); }
  bool has_flags() const { return at<5>().valid(); }
  uint32_t flags() const { return at<5>().as_uint32(); }
};

class Ext4ExtMapBlocksEnterFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ExtMapBlocksEnterFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLblkFieldNumber = 3,
    kLenFieldNumber = 4,
    kFlagsFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_lblk(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4ExtLoadExtentFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ExtLoadExtentFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ExtLoadExtentFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ExtLoadExtentFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_pblk() const { return at<3>().valid(); }
  uint64_t pblk() const { return at<3>().as_uint64(); }
  bool has_lblk() const { return at<4>().valid(); }
  uint32_t lblk() const { return at<4>().as_uint32(); }
};

class Ext4ExtLoadExtentFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ExtLoadExtentFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPblkFieldNumber = 3,
    kLblkFieldNumber = 4,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pblk(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_lblk(uint32_t value) {
    AppendVarInt(4, value);
  }
};

class Ext4ExtInCacheFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ExtInCacheFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ExtInCacheFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ExtInCacheFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_lblk() const { return at<3>().valid(); }
  uint32_t lblk() const { return at<3>().as_uint32(); }
  bool has_ret() const { return at<4>().valid(); }
  int32_t ret() const { return at<4>().as_int32(); }
};

class Ext4ExtInCacheFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ExtInCacheFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLblkFieldNumber = 3,
    kRetFieldNumber = 4,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_lblk(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(4, value);
  }
};

class Ext4ExtHandleUnwrittenExtentsFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ExtHandleUnwrittenExtentsFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ExtHandleUnwrittenExtentsFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ExtHandleUnwrittenExtentsFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_flags() const { return at<3>().valid(); }
  int32_t flags() const { return at<3>().as_int32(); }
  bool has_lblk() const { return at<4>().valid(); }
  uint32_t lblk() const { return at<4>().as_uint32(); }
  bool has_pblk() const { return at<5>().valid(); }
  uint64_t pblk() const { return at<5>().as_uint64(); }
  bool has_len() const { return at<6>().valid(); }
  uint32_t len() const { return at<6>().as_uint32(); }
  bool has_allocated() const { return at<7>().valid(); }
  uint32_t allocated() const { return at<7>().as_uint32(); }
  bool has_newblk() const { return at<8>().valid(); }
  uint64_t newblk() const { return at<8>().as_uint64(); }
};

class Ext4ExtHandleUnwrittenExtentsFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ExtHandleUnwrittenExtentsFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kFlagsFieldNumber = 3,
    kLblkFieldNumber = 4,
    kPblkFieldNumber = 5,
    kLenFieldNumber = 6,
    kAllocatedFieldNumber = 7,
    kNewblkFieldNumber = 8,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_flags(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_lblk(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_pblk(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_allocated(uint32_t value) {
    AppendVarInt(7, value);
  }
  void set_newblk(uint64_t value) {
    AppendVarInt(8, value);
  }
};

class Ext4ExtConvertToInitializedFastpathFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/10, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ExtConvertToInitializedFastpathFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ExtConvertToInitializedFastpathFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ExtConvertToInitializedFastpathFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_m_lblk() const { return at<3>().valid(); }
  uint32_t m_lblk() const { return at<3>().as_uint32(); }
  bool has_m_len() const { return at<4>().valid(); }
  uint32_t m_len() const { return at<4>().as_uint32(); }
  bool has_u_lblk() const { return at<5>().valid(); }
  uint32_t u_lblk() const { return at<5>().as_uint32(); }
  bool has_u_len() const { return at<6>().valid(); }
  uint32_t u_len() const { return at<6>().as_uint32(); }
  bool has_u_pblk() const { return at<7>().valid(); }
  uint64_t u_pblk() const { return at<7>().as_uint64(); }
  bool has_i_lblk() const { return at<8>().valid(); }
  uint32_t i_lblk() const { return at<8>().as_uint32(); }
  bool has_i_len() const { return at<9>().valid(); }
  uint32_t i_len() const { return at<9>().as_uint32(); }
  bool has_i_pblk() const { return at<10>().valid(); }
  uint64_t i_pblk() const { return at<10>().as_uint64(); }
};

class Ext4ExtConvertToInitializedFastpathFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ExtConvertToInitializedFastpathFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kMLblkFieldNumber = 3,
    kMLenFieldNumber = 4,
    kULblkFieldNumber = 5,
    kULenFieldNumber = 6,
    kUPblkFieldNumber = 7,
    kILblkFieldNumber = 8,
    kILenFieldNumber = 9,
    kIPblkFieldNumber = 10,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_m_lblk(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_m_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_u_lblk(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_u_len(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_u_pblk(uint64_t value) {
    AppendVarInt(7, value);
  }
  void set_i_lblk(uint32_t value) {
    AppendVarInt(8, value);
  }
  void set_i_len(uint32_t value) {
    AppendVarInt(9, value);
  }
  void set_i_pblk(uint64_t value) {
    AppendVarInt(10, value);
  }
};

class Ext4ExtConvertToInitializedEnterFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/7, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ExtConvertToInitializedEnterFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ExtConvertToInitializedEnterFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ExtConvertToInitializedEnterFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_m_lblk() const { return at<3>().valid(); }
  uint32_t m_lblk() const { return at<3>().as_uint32(); }
  bool has_m_len() const { return at<4>().valid(); }
  uint32_t m_len() const { return at<4>().as_uint32(); }
  bool has_u_lblk() const { return at<5>().valid(); }
  uint32_t u_lblk() const { return at<5>().as_uint32(); }
  bool has_u_len() const { return at<6>().valid(); }
  uint32_t u_len() const { return at<6>().as_uint32(); }
  bool has_u_pblk() const { return at<7>().valid(); }
  uint64_t u_pblk() const { return at<7>().as_uint64(); }
};

class Ext4ExtConvertToInitializedEnterFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ExtConvertToInitializedEnterFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kMLblkFieldNumber = 3,
    kMLenFieldNumber = 4,
    kULblkFieldNumber = 5,
    kULenFieldNumber = 6,
    kUPblkFieldNumber = 7,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_m_lblk(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_m_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_u_lblk(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_u_len(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_u_pblk(uint64_t value) {
    AppendVarInt(7, value);
  }
};

class Ext4EvictInodeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4EvictInodeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4EvictInodeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4EvictInodeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_nlink() const { return at<3>().valid(); }
  int32_t nlink() const { return at<3>().as_int32(); }
};

class Ext4EvictInodeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4EvictInodeFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kNlinkFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_nlink(int32_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4EsShrinkScanExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4EsShrinkScanExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4EsShrinkScanExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4EsShrinkScanExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_nr_shrunk() const { return at<2>().valid(); }
  int32_t nr_shrunk() const { return at<2>().as_int32(); }
  bool has_cache_cnt() const { return at<3>().valid(); }
  int32_t cache_cnt() const { return at<3>().as_int32(); }
};

class Ext4EsShrinkScanExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4EsShrinkScanExitFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kNrShrunkFieldNumber = 2,
    kCacheCntFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_nr_shrunk(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_cache_cnt(int32_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4EsShrinkScanEnterFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4EsShrinkScanEnterFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4EsShrinkScanEnterFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4EsShrinkScanEnterFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_nr_to_scan() const { return at<2>().valid(); }
  int32_t nr_to_scan() const { return at<2>().as_int32(); }
  bool has_cache_cnt() const { return at<3>().valid(); }
  int32_t cache_cnt() const { return at<3>().as_int32(); }
};

class Ext4EsShrinkScanEnterFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4EsShrinkScanEnterFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kNrToScanFieldNumber = 2,
    kCacheCntFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_nr_to_scan(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_cache_cnt(int32_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4EsShrinkCountFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4EsShrinkCountFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4EsShrinkCountFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4EsShrinkCountFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_nr_to_scan() const { return at<2>().valid(); }
  int32_t nr_to_scan() const { return at<2>().as_int32(); }
  bool has_cache_cnt() const { return at<3>().valid(); }
  int32_t cache_cnt() const { return at<3>().as_int32(); }
};

class Ext4EsShrinkCountFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4EsShrinkCountFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kNrToScanFieldNumber = 2,
    kCacheCntFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_nr_to_scan(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_cache_cnt(int32_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4EsShrinkFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4EsShrinkFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4EsShrinkFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4EsShrinkFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_nr_shrunk() const { return at<2>().valid(); }
  int32_t nr_shrunk() const { return at<2>().as_int32(); }
  bool has_scan_time() const { return at<3>().valid(); }
  uint64_t scan_time() const { return at<3>().as_uint64(); }
  bool has_nr_skipped() const { return at<4>().valid(); }
  int32_t nr_skipped() const { return at<4>().as_int32(); }
  bool has_retried() const { return at<5>().valid(); }
  int32_t retried() const { return at<5>().as_int32(); }
};

class Ext4EsShrinkFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4EsShrinkFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kNrShrunkFieldNumber = 2,
    kScanTimeFieldNumber = 3,
    kNrSkippedFieldNumber = 4,
    kRetriedFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_nr_shrunk(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_scan_time(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_nr_skipped(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_retried(int32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4EsRemoveExtentFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4EsRemoveExtentFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4EsRemoveExtentFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4EsRemoveExtentFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_lblk() const { return at<3>().valid(); }
  int64_t lblk() const { return at<3>().as_int64(); }
  bool has_len() const { return at<4>().valid(); }
  int64_t len() const { return at<4>().as_int64(); }
};

class Ext4EsRemoveExtentFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4EsRemoveExtentFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLblkFieldNumber = 3,
    kLenFieldNumber = 4,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_lblk(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_len(int64_t value) {
    AppendVarInt(4, value);
  }
};

class Ext4EsLookupExtentExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/7, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4EsLookupExtentExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4EsLookupExtentExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4EsLookupExtentExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_lblk() const { return at<3>().valid(); }
  uint32_t lblk() const { return at<3>().as_uint32(); }
  bool has_len() const { return at<4>().valid(); }
  uint32_t len() const { return at<4>().as_uint32(); }
  bool has_pblk() const { return at<5>().valid(); }
  uint64_t pblk() const { return at<5>().as_uint64(); }
  bool has_status() const { return at<6>().valid(); }
  uint64_t status() const { return at<6>().as_uint64(); }
  bool has_found() const { return at<7>().valid(); }
  int32_t found() const { return at<7>().as_int32(); }
};

class Ext4EsLookupExtentExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4EsLookupExtentExitFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLblkFieldNumber = 3,
    kLenFieldNumber = 4,
    kPblkFieldNumber = 5,
    kStatusFieldNumber = 6,
    kFoundFieldNumber = 7,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_lblk(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_pblk(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_status(uint64_t value) {
    AppendVarInt(6, value);
  }
  void set_found(int32_t value) {
    AppendVarInt(7, value);
  }
};

class Ext4EsLookupExtentEnterFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4EsLookupExtentEnterFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4EsLookupExtentEnterFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4EsLookupExtentEnterFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_lblk() const { return at<3>().valid(); }
  uint32_t lblk() const { return at<3>().as_uint32(); }
};

class Ext4EsLookupExtentEnterFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4EsLookupExtentEnterFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLblkFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_lblk(uint32_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4EsInsertExtentFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4EsInsertExtentFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4EsInsertExtentFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4EsInsertExtentFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_lblk() const { return at<3>().valid(); }
  uint32_t lblk() const { return at<3>().as_uint32(); }
  bool has_len() const { return at<4>().valid(); }
  uint32_t len() const { return at<4>().as_uint32(); }
  bool has_pblk() const { return at<5>().valid(); }
  uint64_t pblk() const { return at<5>().as_uint64(); }
  bool has_status() const { return at<6>().valid(); }
  uint64_t status() const { return at<6>().as_uint64(); }
};

class Ext4EsInsertExtentFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4EsInsertExtentFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLblkFieldNumber = 3,
    kLenFieldNumber = 4,
    kPblkFieldNumber = 5,
    kStatusFieldNumber = 6,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_lblk(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_pblk(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_status(uint64_t value) {
    AppendVarInt(6, value);
  }
};

class Ext4EsFindDelayedExtentRangeExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4EsFindDelayedExtentRangeExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4EsFindDelayedExtentRangeExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4EsFindDelayedExtentRangeExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_lblk() const { return at<3>().valid(); }
  uint32_t lblk() const { return at<3>().as_uint32(); }
  bool has_len() const { return at<4>().valid(); }
  uint32_t len() const { return at<4>().as_uint32(); }
  bool has_pblk() const { return at<5>().valid(); }
  uint64_t pblk() const { return at<5>().as_uint64(); }
  bool has_status() const { return at<6>().valid(); }
  uint64_t status() const { return at<6>().as_uint64(); }
};

class Ext4EsFindDelayedExtentRangeExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4EsFindDelayedExtentRangeExitFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLblkFieldNumber = 3,
    kLenFieldNumber = 4,
    kPblkFieldNumber = 5,
    kStatusFieldNumber = 6,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_lblk(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_pblk(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_status(uint64_t value) {
    AppendVarInt(6, value);
  }
};

class Ext4EsFindDelayedExtentRangeEnterFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4EsFindDelayedExtentRangeEnterFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4EsFindDelayedExtentRangeEnterFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4EsFindDelayedExtentRangeEnterFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_lblk() const { return at<3>().valid(); }
  uint32_t lblk() const { return at<3>().as_uint32(); }
};

class Ext4EsFindDelayedExtentRangeEnterFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4EsFindDelayedExtentRangeEnterFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLblkFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_lblk(uint32_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4EsCacheExtentFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4EsCacheExtentFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4EsCacheExtentFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4EsCacheExtentFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_lblk() const { return at<3>().valid(); }
  uint32_t lblk() const { return at<3>().as_uint32(); }
  bool has_len() const { return at<4>().valid(); }
  uint32_t len() const { return at<4>().as_uint32(); }
  bool has_pblk() const { return at<5>().valid(); }
  uint64_t pblk() const { return at<5>().as_uint64(); }
  bool has_status() const { return at<6>().valid(); }
  uint32_t status() const { return at<6>().as_uint32(); }
};

class Ext4EsCacheExtentFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4EsCacheExtentFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLblkFieldNumber = 3,
    kLenFieldNumber = 4,
    kPblkFieldNumber = 5,
    kStatusFieldNumber = 6,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_lblk(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_pblk(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_status(uint32_t value) {
    AppendVarInt(6, value);
  }
};

class Ext4DropInodeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4DropInodeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4DropInodeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4DropInodeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_drop() const { return at<3>().valid(); }
  int32_t drop() const { return at<3>().as_int32(); }
};

class Ext4DropInodeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4DropInodeFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kDropFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_drop(int32_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4DiscardPreallocationsFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4DiscardPreallocationsFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4DiscardPreallocationsFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4DiscardPreallocationsFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
};

class Ext4DiscardPreallocationsFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4DiscardPreallocationsFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
};

class Ext4DiscardBlocksFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4DiscardBlocksFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4DiscardBlocksFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4DiscardBlocksFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_blk() const { return at<2>().valid(); }
  uint64_t blk() const { return at<2>().as_uint64(); }
  bool has_count() const { return at<3>().valid(); }
  uint64_t count() const { return at<3>().as_uint64(); }
};

class Ext4DiscardBlocksFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4DiscardBlocksFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kBlkFieldNumber = 2,
    kCountFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_blk(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_count(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4DirectIOExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4DirectIOExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4DirectIOExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4DirectIOExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_pos() const { return at<3>().valid(); }
  int64_t pos() const { return at<3>().as_int64(); }
  bool has_len() const { return at<4>().valid(); }
  uint64_t len() const { return at<4>().as_uint64(); }
  bool has_rw() const { return at<5>().valid(); }
  int32_t rw() const { return at<5>().as_int32(); }
  bool has_ret() const { return at<6>().valid(); }
  int32_t ret() const { return at<6>().as_int32(); }
};

class Ext4DirectIOExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4DirectIOExitFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPosFieldNumber = 3,
    kLenFieldNumber = 4,
    kRwFieldNumber = 5,
    kRetFieldNumber = 6,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pos(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_rw(int32_t value) {
    AppendVarInt(5, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(6, value);
  }
};

class Ext4DirectIOEnterFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4DirectIOEnterFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4DirectIOEnterFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4DirectIOEnterFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_pos() const { return at<3>().valid(); }
  int64_t pos() const { return at<3>().as_int64(); }
  bool has_len() const { return at<4>().valid(); }
  uint64_t len() const { return at<4>().as_uint64(); }
  bool has_rw() const { return at<5>().valid(); }
  int32_t rw() const { return at<5>().as_int32(); }
};

class Ext4DirectIOEnterFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4DirectIOEnterFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPosFieldNumber = 3,
    kLenFieldNumber = 4,
    kRwFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pos(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_rw(int32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4DaWritePagesExtentFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4DaWritePagesExtentFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4DaWritePagesExtentFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4DaWritePagesExtentFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_lblk() const { return at<3>().valid(); }
  uint64_t lblk() const { return at<3>().as_uint64(); }
  bool has_len() const { return at<4>().valid(); }
  uint32_t len() const { return at<4>().as_uint32(); }
  bool has_flags() const { return at<5>().valid(); }
  uint32_t flags() const { return at<5>().as_uint32(); }
};

class Ext4DaWritePagesExtentFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4DaWritePagesExtentFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLblkFieldNumber = 3,
    kLenFieldNumber = 4,
    kFlagsFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_lblk(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4DaWritePagesFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/10, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4DaWritePagesFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4DaWritePagesFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4DaWritePagesFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_first_page() const { return at<3>().valid(); }
  uint64_t first_page() const { return at<3>().as_uint64(); }
  bool has_nr_to_write() const { return at<4>().valid(); }
  int64_t nr_to_write() const { return at<4>().as_int64(); }
  bool has_sync_mode() const { return at<5>().valid(); }
  int32_t sync_mode() const { return at<5>().as_int32(); }
  bool has_b_blocknr() const { return at<6>().valid(); }
  uint64_t b_blocknr() const { return at<6>().as_uint64(); }
  bool has_b_size() const { return at<7>().valid(); }
  uint32_t b_size() const { return at<7>().as_uint32(); }
  bool has_b_state() const { return at<8>().valid(); }
  uint32_t b_state() const { return at<8>().as_uint32(); }
  bool has_io_done() const { return at<9>().valid(); }
  int32_t io_done() const { return at<9>().as_int32(); }
  bool has_pages_written() const { return at<10>().valid(); }
  int32_t pages_written() const { return at<10>().as_int32(); }
};

class Ext4DaWritePagesFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4DaWritePagesFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kFirstPageFieldNumber = 3,
    kNrToWriteFieldNumber = 4,
    kSyncModeFieldNumber = 5,
    kBBlocknrFieldNumber = 6,
    kBSizeFieldNumber = 7,
    kBStateFieldNumber = 8,
    kIoDoneFieldNumber = 9,
    kPagesWrittenFieldNumber = 10,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_first_page(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_nr_to_write(int64_t value) {
    AppendVarInt(4, value);
  }
  void set_sync_mode(int32_t value) {
    AppendVarInt(5, value);
  }
  void set_b_blocknr(uint64_t value) {
    AppendVarInt(6, value);
  }
  void set_b_size(uint32_t value) {
    AppendVarInt(7, value);
  }
  void set_b_state(uint32_t value) {
    AppendVarInt(8, value);
  }
  void set_io_done(int32_t value) {
    AppendVarInt(9, value);
  }
  void set_pages_written(int32_t value) {
    AppendVarInt(10, value);
  }
};

class Ext4DaUpdateReserveSpaceFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/9, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4DaUpdateReserveSpaceFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4DaUpdateReserveSpaceFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4DaUpdateReserveSpaceFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_i_blocks() const { return at<3>().valid(); }
  uint64_t i_blocks() const { return at<3>().as_uint64(); }
  bool has_used_blocks() const { return at<4>().valid(); }
  int32_t used_blocks() const { return at<4>().as_int32(); }
  bool has_reserved_data_blocks() const { return at<5>().valid(); }
  int32_t reserved_data_blocks() const { return at<5>().as_int32(); }
  bool has_reserved_meta_blocks() const { return at<6>().valid(); }
  int32_t reserved_meta_blocks() const { return at<6>().as_int32(); }
  bool has_allocated_meta_blocks() const { return at<7>().valid(); }
  int32_t allocated_meta_blocks() const { return at<7>().as_int32(); }
  bool has_quota_claim() const { return at<8>().valid(); }
  int32_t quota_claim() const { return at<8>().as_int32(); }
  bool has_mode() const { return at<9>().valid(); }
  uint32_t mode() const { return at<9>().as_uint32(); }
};

class Ext4DaUpdateReserveSpaceFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4DaUpdateReserveSpaceFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kIBlocksFieldNumber = 3,
    kUsedBlocksFieldNumber = 4,
    kReservedDataBlocksFieldNumber = 5,
    kReservedMetaBlocksFieldNumber = 6,
    kAllocatedMetaBlocksFieldNumber = 7,
    kQuotaClaimFieldNumber = 8,
    kModeFieldNumber = 9,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_i_blocks(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_used_blocks(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_reserved_data_blocks(int32_t value) {
    AppendVarInt(5, value);
  }
  void set_reserved_meta_blocks(int32_t value) {
    AppendVarInt(6, value);
  }
  void set_allocated_meta_blocks(int32_t value) {
    AppendVarInt(7, value);
  }
  void set_quota_claim(int32_t value) {
    AppendVarInt(8, value);
  }
  void set_mode(uint32_t value) {
    AppendVarInt(9, value);
  }
};

class Ext4DaReserveSpaceFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/7, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4DaReserveSpaceFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4DaReserveSpaceFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4DaReserveSpaceFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_i_blocks() const { return at<3>().valid(); }
  uint64_t i_blocks() const { return at<3>().as_uint64(); }
  bool has_reserved_data_blocks() const { return at<4>().valid(); }
  int32_t reserved_data_blocks() const { return at<4>().as_int32(); }
  bool has_reserved_meta_blocks() const { return at<5>().valid(); }
  int32_t reserved_meta_blocks() const { return at<5>().as_int32(); }
  bool has_mode() const { return at<6>().valid(); }
  uint32_t mode() const { return at<6>().as_uint32(); }
  bool has_md_needed() const { return at<7>().valid(); }
  int32_t md_needed() const { return at<7>().as_int32(); }
};

class Ext4DaReserveSpaceFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4DaReserveSpaceFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kIBlocksFieldNumber = 3,
    kReservedDataBlocksFieldNumber = 4,
    kReservedMetaBlocksFieldNumber = 5,
    kModeFieldNumber = 6,
    kMdNeededFieldNumber = 7,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_i_blocks(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_reserved_data_blocks(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_reserved_meta_blocks(int32_t value) {
    AppendVarInt(5, value);
  }
  void set_mode(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_md_needed(int32_t value) {
    AppendVarInt(7, value);
  }
};

class Ext4DaReleaseSpaceFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4DaReleaseSpaceFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4DaReleaseSpaceFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4DaReleaseSpaceFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_i_blocks() const { return at<3>().valid(); }
  uint64_t i_blocks() const { return at<3>().as_uint64(); }
  bool has_freed_blocks() const { return at<4>().valid(); }
  int32_t freed_blocks() const { return at<4>().as_int32(); }
  bool has_reserved_data_blocks() const { return at<5>().valid(); }
  int32_t reserved_data_blocks() const { return at<5>().as_int32(); }
  bool has_reserved_meta_blocks() const { return at<6>().valid(); }
  int32_t reserved_meta_blocks() const { return at<6>().as_int32(); }
  bool has_allocated_meta_blocks() const { return at<7>().valid(); }
  int32_t allocated_meta_blocks() const { return at<7>().as_int32(); }
  bool has_mode() const { return at<8>().valid(); }
  uint32_t mode() const { return at<8>().as_uint32(); }
};

class Ext4DaReleaseSpaceFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4DaReleaseSpaceFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kIBlocksFieldNumber = 3,
    kFreedBlocksFieldNumber = 4,
    kReservedDataBlocksFieldNumber = 5,
    kReservedMetaBlocksFieldNumber = 6,
    kAllocatedMetaBlocksFieldNumber = 7,
    kModeFieldNumber = 8,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_i_blocks(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_freed_blocks(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_reserved_data_blocks(int32_t value) {
    AppendVarInt(5, value);
  }
  void set_reserved_meta_blocks(int32_t value) {
    AppendVarInt(6, value);
  }
  void set_allocated_meta_blocks(int32_t value) {
    AppendVarInt(7, value);
  }
  void set_mode(uint32_t value) {
    AppendVarInt(8, value);
  }
};

class Ext4CollapseRangeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4CollapseRangeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4CollapseRangeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4CollapseRangeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_offset() const { return at<3>().valid(); }
  int64_t offset() const { return at<3>().as_int64(); }
  bool has_len() const { return at<4>().valid(); }
  int64_t len() const { return at<4>().as_int64(); }
};

class Ext4CollapseRangeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4CollapseRangeFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kOffsetFieldNumber = 3,
    kLenFieldNumber = 4,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_offset(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_len(int64_t value) {
    AppendVarInt(4, value);
  }
};

class Ext4BeginOrderedTruncateFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4BeginOrderedTruncateFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4BeginOrderedTruncateFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4BeginOrderedTruncateFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_new_size() const { return at<3>().valid(); }
  int64_t new_size() const { return at<3>().as_int64(); }
};

class Ext4BeginOrderedTruncateFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4BeginOrderedTruncateFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kNewSizeFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_new_size(int64_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4AllocateInodeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4AllocateInodeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4AllocateInodeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4AllocateInodeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_dir() const { return at<3>().valid(); }
  uint64_t dir() const { return at<3>().as_uint64(); }
  bool has_mode() const { return at<4>().valid(); }
  uint32_t mode() const { return at<4>().as_uint32(); }
};

class Ext4AllocateInodeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4AllocateInodeFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kDirFieldNumber = 3,
    kModeFieldNumber = 4,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_dir(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_mode(uint32_t value) {
    AppendVarInt(4, value);
  }
};

class Ext4AllocateBlocksFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/11, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4AllocateBlocksFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4AllocateBlocksFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4AllocateBlocksFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_block() const { return at<3>().valid(); }
  uint64_t block() const { return at<3>().as_uint64(); }
  bool has_len() const { return at<4>().valid(); }
  uint32_t len() const { return at<4>().as_uint32(); }
  bool has_logical() const { return at<5>().valid(); }
  uint32_t logical() const { return at<5>().as_uint32(); }
  bool has_lleft() const { return at<6>().valid(); }
  uint32_t lleft() const { return at<6>().as_uint32(); }
  bool has_lright() const { return at<7>().valid(); }
  uint32_t lright() const { return at<7>().as_uint32(); }
  bool has_goal() const { return at<8>().valid(); }
  uint64_t goal() const { return at<8>().as_uint64(); }
  bool has_pleft() const { return at<9>().valid(); }
  uint64_t pleft() const { return at<9>().as_uint64(); }
  bool has_pright() const { return at<10>().valid(); }
  uint64_t pright() const { return at<10>().as_uint64(); }
  bool has_flags() const { return at<11>().valid(); }
  uint32_t flags() const { return at<11>().as_uint32(); }
};

class Ext4AllocateBlocksFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4AllocateBlocksFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kBlockFieldNumber = 3,
    kLenFieldNumber = 4,
    kLogicalFieldNumber = 5,
    kLleftFieldNumber = 6,
    kLrightFieldNumber = 7,
    kGoalFieldNumber = 8,
    kPleftFieldNumber = 9,
    kPrightFieldNumber = 10,
    kFlagsFieldNumber = 11,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_block(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_logical(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_lleft(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_lright(uint32_t value) {
    AppendVarInt(7, value);
  }
  void set_goal(uint64_t value) {
    AppendVarInt(8, value);
  }
  void set_pleft(uint64_t value) {
    AppendVarInt(9, value);
  }
  void set_pright(uint64_t value) {
    AppendVarInt(10, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(11, value);
  }
};

class Ext4AllocDaBlocksFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4AllocDaBlocksFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4AllocDaBlocksFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4AllocDaBlocksFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_data_blocks() const { return at<3>().valid(); }
  uint32_t data_blocks() const { return at<3>().as_uint32(); }
  bool has_meta_blocks() const { return at<4>().valid(); }
  uint32_t meta_blocks() const { return at<4>().as_uint32(); }
};

class Ext4AllocDaBlocksFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4AllocDaBlocksFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kDataBlocksFieldNumber = 3,
    kMetaBlocksFieldNumber = 4,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_data_blocks(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_meta_blocks(uint32_t value) {
    AppendVarInt(4, value);
  }
};

class Ext4SyncFileExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4SyncFileExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4SyncFileExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4SyncFileExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_ret() const { return at<3>().valid(); }
  int32_t ret() const { return at<3>().as_int32(); }
};

class Ext4SyncFileExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4SyncFileExitFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kRetFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4SyncFileEnterFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4SyncFileEnterFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4SyncFileEnterFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4SyncFileEnterFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_parent() const { return at<3>().valid(); }
  uint64_t parent() const { return at<3>().as_uint64(); }
  bool has_datasync() const { return at<4>().valid(); }
  int32_t datasync() const { return at<4>().as_int32(); }
};

class Ext4SyncFileEnterFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4SyncFileEnterFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kParentFieldNumber = 3,
    kDatasyncFieldNumber = 4,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_parent(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_datasync(int32_t value) {
    AppendVarInt(4, value);
  }
};

class Ext4DaWriteEndFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4DaWriteEndFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4DaWriteEndFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4DaWriteEndFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_pos() const { return at<3>().valid(); }
  int64_t pos() const { return at<3>().as_int64(); }
  bool has_len() const { return at<4>().valid(); }
  uint32_t len() const { return at<4>().as_uint32(); }
  bool has_copied() const { return at<5>().valid(); }
  uint32_t copied() const { return at<5>().as_uint32(); }
};

class Ext4DaWriteEndFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4DaWriteEndFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPosFieldNumber = 3,
    kLenFieldNumber = 4,
    kCopiedFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pos(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_copied(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4DaWriteBeginFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4DaWriteBeginFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4DaWriteBeginFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4DaWriteBeginFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_pos() const { return at<3>().valid(); }
  int64_t pos() const { return at<3>().as_int64(); }
  bool has_len() const { return at<4>().valid(); }
  uint32_t len() const { return at<4>().as_uint32(); }
  bool has_flags() const { return at<5>().valid(); }
  uint32_t flags() const { return at<5>().as_uint32(); }
};

class Ext4DaWriteBeginFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4DaWriteBeginFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPosFieldNumber = 3,
    kLenFieldNumber = 4,
    kFlagsFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pos(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(5, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/ftrace/f2fs.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_F2FS_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_F2FS_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class F2fsWriteEndFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsWriteEndFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsWriteEndFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsWriteEndFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_pos() const { return at<3>().valid(); }
  int64_t pos() const { return at<3>().as_int64(); }
  bool has_len() const { return at<4>().valid(); }
  uint32_t len() const { return at<4>().as_uint32(); }
  bool has_copied() const { return at<5>().valid(); }
  uint32_t copied() const { return at<5>().as_uint32(); }
};

class F2fsWriteEndFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsWriteEndFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPosFieldNumber = 3,
    kLenFieldNumber = 4,
    kCopiedFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pos(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_copied(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class F2fsWriteCheckpointFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsWriteCheckpointFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsWriteCheckpointFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsWriteCheckpointFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_is_umount() const { return at<2>().valid(); }
  uint32_t is_umount() const { return at<2>().as_uint32(); }
  bool has_msg() const { return at<3>().valid(); }
  ::protozero::ConstChars msg() const { return at<3>().as_string(); }
};

class F2fsWriteCheckpointFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsWriteCheckpointFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kIsUmountFieldNumber = 2,
    kMsgFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_is_umount(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_msg(const std::string& value) {
    AppendBytes(3, value.data(), value.size());
  }
  void set_msg(const char* data, size_t size) {
    AppendBytes(3, data, size);
  }
};

class F2fsWriteBeginFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsWriteBeginFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsWriteBeginFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsWriteBeginFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_pos() const { return at<3>().valid(); }
  int64_t pos() const { return at<3>().as_int64(); }
  bool has_len() const { return at<4>().valid(); }
  uint32_t len() const { return at<4>().as_uint32(); }
  bool has_flags() const { return at<5>().valid(); }
  uint32_t flags() const { return at<5>().as_uint32(); }
};

class F2fsWriteBeginFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsWriteBeginFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPosFieldNumber = 3,
    kLenFieldNumber = 4,
    kFlagsFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pos(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class F2fsVmPageMkwriteFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsVmPageMkwriteFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsVmPageMkwriteFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsVmPageMkwriteFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_type() const { return at<3>().valid(); }
  int32_t type() const { return at<3>().as_int32(); }
  bool has_dir() const { return at<4>().valid(); }
  int32_t dir() const { return at<4>().as_int32(); }
  bool has_index() const { return at<5>().valid(); }
  uint64_t index() const { return at<5>().as_uint64(); }
  bool has_dirty() const { return at<6>().valid(); }
  int32_t dirty() const { return at<6>().as_int32(); }
};

class F2fsVmPageMkwriteFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsVmPageMkwriteFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kTypeFieldNumber = 3,
    kDirFieldNumber = 4,
    kIndexFieldNumber = 5,
    kDirtyFieldNumber = 6,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_type(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_dir(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_index(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_dirty(int32_t value) {
    AppendVarInt(6, value);
  }
};

class F2fsUnlinkExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsUnlinkExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsUnlinkExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsUnlinkExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_ret() const { return at<3>().valid(); }
  int32_t ret() const { return at<3>().as_int32(); }
};

class F2fsUnlinkExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsUnlinkExitFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kRetFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(3, value);
  }
};

class F2fsUnlinkEnterFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsUnlinkEnterFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsUnlinkEnterFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsUnlinkEnterFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_size() const { return at<3>().valid(); }
  int64_t size() const { return at<3>().as_int64(); }
  bool has_blocks() const { return at<4>().valid(); }
  uint64_t blocks() const { return at<4>().as_uint64(); }
  bool has_name() const { return at<5>().valid(); }
  ::protozero::ConstChars name() const { return at<5>().as_string(); }
};

class F2fsUnlinkEnterFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsUnlinkEnterFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kSizeFieldNumber = 3,
    kBlocksFieldNumber = 4,
    kNameFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_size(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_blocks(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_name(const std::string& value) {
    AppendBytes(5, value.data(), value.size());
  }
  void set_name(const char* data, size_t size) {
    AppendBytes(5, data, size);
  }
};

class F2fsTruncatePartialNodesFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsTruncatePartialNodesFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsTruncatePartialNodesFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsTruncatePartialNodesFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_nid() const { return at<3>().valid(); }
  uint32_t nid() const { return at<3>().as_uint32(); }
  bool has_depth() const { return at<4>().valid(); }
  int32_t depth() const { return at<4>().as_int32(); }
  bool has_err() const { return at<5>().valid(); }
  int32_t err() const { return at<5>().as_int32(); }
};

class F2fsTruncatePartialNodesFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsTruncatePartialNodesFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kNidFieldNumber = 3,
    kDepthFieldNumber = 4,
    kErrFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_nid(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_depth(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_err(int32_t value) {
    AppendVarInt(5, value);
  }
};

class F2fsTruncateNodesExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsTruncateNodesExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsTruncateNodesExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsTruncateNodesExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_ret() const { return at<3>().valid(); }
  int32_t ret() const { return at<3>().as_int32(); }
};

class F2fsTruncateNodesExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsTruncateNodesExitFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kRetFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(3, value);
  }
};

class F2fsTruncateNodesEnterFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsTruncateNodesEnterFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsTruncateNodesEnterFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsTruncateNodesEnterFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_nid() const { return at<3>().valid(); }
  uint32_t nid() const { return at<3>().as_uint32(); }
  bool has_blk_addr() const { return at<4>().valid(); }
  uint32_t blk_addr() const { return at<4>().as_uint32(); }
};

class F2fsTruncateNodesEnterFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsTruncateNodesEnterFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kNidFieldNumber = 3,
    kBlkAddrFieldNumber = 4,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_nid(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_blk_addr(uint32_t value) {
    AppendVarInt(4, value);
  }
};

class F2fsTruncateNodeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsTruncateNodeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsTruncateNodeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsTruncateNodeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_nid() const { return at<3>().valid(); }
  uint32_t nid() const { return at<3>().as_uint32(); }
  bool has_blk_addr() const { return at<4>().valid(); }
  uint32_t blk_addr() const { return at<4>().as_uint32(); }
};

class F2fsTruncateNodeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsTruncateNodeFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kNidFieldNumber = 3,
    kBlkAddrFieldNumber = 4,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_nid(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_blk_addr(uint32_t value) {
    AppendVarInt(4, value);
  }
};

class F2fsTruncateInodeBlocksExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsTruncateInodeBlocksExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsTruncateInodeBlocksExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsTruncateInodeBlocksExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_ret() const { return at<3>().valid(); }
  int32_t ret() const { return at<3>().as_int32(); }
};

class F2fsTruncateInodeBlocksExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsTruncateInodeBlocksExitFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kRetFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(3, value);
  }
};

class F2fsTruncateInodeBlocksEnterFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsTruncateInodeBlocksEnterFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsTruncateInodeBlocksEnterFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsTruncateInodeBlocksEnterFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_size() const { return at<3>().valid(); }
  int64_t size() const { return at<3>().as_int64(); }
  bool has_blocks() const { return at<4>().valid(); }
  uint64_t blocks() const { return at<4>().as_uint64(); }
  bool has_from() const { return at<5>().valid(); }
  uint64_t from() const { return at<5>().as_uint64(); }
};

class F2fsTruncateInodeBlocksEnterFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsTruncateInodeBlocksEnterFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kSizeFieldNumber = 3,
    kBlocksFieldNumber = 4,
    kFromFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_size(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_blocks(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_from(uint64_t value) {
    AppendVarInt(5, value);
  }
};

class F2fsTruncateDataBlocksRangeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsTruncateDataBlocksRangeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsTruncateDataBlocksRangeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsTruncateDataBlocksRangeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_nid() const { return at<3>().valid(); }
  uint32_t nid() const { return at<3>().as_uint32(); }
  bool has_ofs() const { return at<4>().valid(); }
  uint32_t ofs() const { return at<4>().as_uint32(); }
  bool has_free() const { return at<5>().valid(); }
  int32_t free() const { return at<5>().as_int32(); }
};

class F2fsTruncateDataBlocksRangeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsTruncateDataBlocksRangeFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kNidFieldNumber = 3,
    kOfsFieldNumber = 4,
    kFreeFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_nid(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_ofs(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_free(int32_t value) {
    AppendVarInt(5, value);
  }
};

class F2fsTruncateBlocksExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsTruncateBlocksExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsTruncateBlocksExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsTruncateBlocksExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_ret() const { return at<3>().valid(); }
  int32_t ret() const { return at<3>().as_int32(); }
};

class F2fsTruncateBlocksExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsTruncateBlocksExitFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kRetFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(3, value);
  }
};

class F2fsTruncateBlocksEnterFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsTruncateBlocksEnterFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsTruncateBlocksEnterFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsTruncateBlocksEnterFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_size() const { return at<3>().valid(); }
  int64_t size() const { return at<3>().as_int64(); }
  bool has_blocks() const { return at<4>().valid(); }
  uint64_t blocks() const { return at<4>().as_uint64(); }
  bool has_from() const { return at<5>().valid(); }
  uint64_t from() const { return at<5>().as_uint64(); }
};

class F2fsTruncateBlocksEnterFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsTruncateBlocksEnterFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kSizeFieldNumber = 3,
    kBlocksFieldNumber = 4,
    kFromFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_size(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_blocks(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_from(uint64_t value) {
    AppendVarInt(5, value);
  }
};

class F2fsTruncateFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsTruncateFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsTruncateFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsTruncateFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_pino() const { return at<3>().valid(); }
  uint64_t pino() const { return at<3>().as_uint64(); }
  bool has_mode() const { return at<4>().valid(); }
  uint32_t mode() const { return at<4>().as_uint32(); }
  bool has_size() const { return at<5>().valid(); }
  int64_t size() const { return at<5>().as_int64(); }
  bool has_nlink() const { return at<6>().valid(); }
  uint32_t nlink() const { return at<6>().as_uint32(); }
  bool has_blocks() const { return at<7>().valid(); }
  uint64_t blocks() const { return at<7>().as_uint64(); }
  bool has_advise() const { return at<8>().valid(); }
  uint32_t advise() const { return at<8>().as_uint32(); }
};

class F2fsTruncateFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsTruncateFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPinoFieldNumber = 3,
    kModeFieldNumber = 4,
    kSizeFieldNumber = 5,
    kNlinkFieldNumber = 6,
    kBlocksFieldNumber = 7,
    kAdviseFieldNumber = 8,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pino(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_mode(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_size(int64_t value) {
    AppendVarInt(5, value);
  }
  void set_nlink(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_blocks(uint64_t value) {
    AppendVarInt(7, value);
  }
  void set_advise(uint32_t value) {
    AppendVarInt(8, value);
  }
};

class F2fsSyncFsFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsSyncFsFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsSyncFsFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsSyncFsFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_dirty() const { return at<2>().valid(); }
  int32_t dirty() const { return at<2>().as_int32(); }
  bool has_wait() const { return at<3>().valid(); }
  int32_t wait() const { return at<3>().as_int32(); }
};

class F2fsSyncFsFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsSyncFsFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kDirtyFieldNumber = 2,
    kWaitFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_dirty(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_wait(int32_t value) {
    AppendVarInt(3, value);
  }
};

class F2fsSyncFileExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsSyncFileExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsSyncFileExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsSyncFileExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_need_cp() const { return at<3>().valid(); }
  uint32_t need_cp() const { return at<3>().as_uint32(); }
  bool has_datasync() const { return at<4>().valid(); }
  int32_t datasync() const { return at<4>().as_int32(); }
  bool has_ret() const { return at<5>().valid(); }
  int32_t ret() const { return at<5>().as_int32(); }
};

class F2fsSyncFileExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsSyncFileExitFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kNeedCpFieldNumber = 3,
    kDatasyncFieldNumber = 4,
    kRetFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_need_cp(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_datasync(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(5, value);
  }
};

class F2fsSyncFileEnterFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsSyncFileEnterFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsSyncFileEnterFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsSyncFileEnterFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_pino() const { return at<3>().valid(); }
  uint64_t pino() const { return at<3>().as_uint64(); }
  bool has_mode() const { return at<4>().valid(); }
  uint32_t mode() const { return at<4>().as_uint32(); }
  bool has_size() const { return at<5>().valid(); }
  int64_t size() const { return at<5>().as_int64(); }
  bool has_nlink() const { return at<6>().valid(); }
  uint32_t nlink() const { return at<6>().as_uint32(); }
  bool has_blocks() const { return at<7>().valid(); }
  uint64_t blocks() const { return at<7>().as_uint64(); }
  bool has_advise() const { return at<8>().valid(); }
  uint32_t advise() const { return at<8>().as_uint32(); }
};

class F2fsSyncFileEnterFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsSyncFileEnterFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPinoFieldNumber = 3,
    kModeFieldNumber = 4,
    kSizeFieldNumber = 5,
    kNlinkFieldNumber = 6,
    kBlocksFieldNumber = 7,
    kAdviseFieldNumber = 8,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pino(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_mode(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_size(int64_t value) {
    AppendVarInt(5, value);
  }
  void set_nlink(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_blocks(uint64_t value) {
    AppendVarInt(7, value);
  }
  void set_advise(uint32_t value) {
    AppendVarInt(8, value);
  }
};

class F2fsSubmitWritePageFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsSubmitWritePageFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsSubmitWritePageFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsSubmitWritePageFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_type() const { return at<3>().valid(); }
  int32_t type() const { return at<3>().as_int32(); }
  bool has_index() const { return at<4>().valid(); }
  uint64_t index() const { return at<4>().as_uint64(); }
  bool has_block() const { return at<5>().valid(); }
  uint32_t block() const { return at<5>().as_uint32(); }
};

class F2fsSubmitWritePageFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsSubmitWritePageFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kTypeFieldNumber = 3,
    kIndexFieldNumber = 4,
    kBlockFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_type(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_index(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_block(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class F2fsSetPageDirtyFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsSetPageDirtyFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsSetPageDirtyFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsSetPageDirtyFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_type() const { return at<3>().valid(); }
  int32_t type() const { return at<3>().as_int32(); }
  bool has_dir() const { return at<4>().valid(); }
  int32_t dir() const { return at<4>().as_int32(); }
  bool has_index() const { return at<5>().valid(); }
  uint64_t index() const { return at<5>().as_uint64(); }
  bool has_dirty() const { return at<6>().valid(); }
  int32_t dirty() const { return at<6>().as_int32(); }
};

class F2fsSetPageDirtyFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsSetPageDirtyFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kTypeFieldNumber = 3,
    kDirFieldNumber = 4,
    kIndexFieldNumber = 5,
    kDirtyFieldNumber = 6,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_type(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_dir(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_index(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_dirty(int32_t value) {
    AppendVarInt(6, value);
  }
};

class F2fsReserveNewBlockFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsReserveNewBlockFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsReserveNewBlockFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsReserveNewBlockFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_nid() const { return at<2>().valid(); }
  uint32_t nid() const { return at<2>().as_uint32(); }
  bool has_ofs_in_node() const { return at<3>().valid(); }
  uint32_t ofs_in_node() const { return at<3>().as_uint32(); }
};

class F2fsReserveNewBlockFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsReserveNewBlockFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kNidFieldNumber = 2,
    kOfsInNodeFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_nid(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_ofs_in_node(uint32_t value) {
    AppendVarInt(3, value);
  }
};

class F2fsReadpageFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsReadpageFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsReadpageFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsReadpageFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_index() const { return at<3>().valid(); }
  uint64_t index() const { return at<3>().as_uint64(); }
  bool has_blkaddr() const { return at<4>().valid(); }
  uint64_t blkaddr() const { return at<4>().as_uint64(); }
  bool has_type() const { return at<5>().valid(); }
  int32_t type() const { return at<5>().as_int32(); }
};

class F2fsReadpageFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsReadpageFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kIndexFieldNumber = 3,
    kBlkaddrFieldNumber = 4,
    kTypeFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_index(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_blkaddr(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_type(int32_t value) {
    AppendVarInt(5, value);
  }
};

class F2fsNewInodeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsNewInodeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsNewInodeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsNewInodeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_ret() const { return at<3>().valid(); }
  int32_t ret() const { return at<3>().as_int32(); }
};

class F2fsNewInodeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsNewInodeFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kRetFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(3, value);
  }
};

class F2fsIgetExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsIgetExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsIgetExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsIgetExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_ret() const { return at<3>().valid(); }
  int32_t ret() const { return at<3>().as_int32(); }
};

class F2fsIgetExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsIgetExitFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kRetFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(3, value);
  }
};

class F2fsIgetFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsIgetFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsIgetFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsIgetFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_pino() const { return at<3>().valid(); }
  uint64_t pino() const { return at<3>().as_uint64(); }
  bool has_mode() const { return at<4>().valid(); }
  uint32_t mode() const { return at<4>().as_uint32(); }
  bool has_size() const { return at<5>().valid(); }
  int64_t size() const { return at<5>().as_int64(); }
  bool has_nlink() const { return at<6>().valid(); }
  uint32_t nlink() const { return at<6>().as_uint32(); }
  bool has_blocks() const { return at<7>().valid(); }
  uint64_t blocks() const { return at<7>().as_uint64(); }
  bool has_advise() const { return at<8>().valid(); }
  uint32_t advise() const { return at<8>().as_uint32(); }
};

class F2fsIgetFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsIgetFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPinoFieldNumber = 3,
    kModeFieldNumber = 4,
    kSizeFieldNumber = 5,
    kNlinkFieldNumber = 6,
    kBlocksFieldNumber = 7,
    kAdviseFieldNumber = 8,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pino(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_mode(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_size(int64_t value) {
    AppendVarInt(5, value);
  }
  void set_nlink(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_blocks(uint64_t value) {
    AppendVarInt(7, value);
  }
  void set_advise(uint32_t value) {
    AppendVarInt(8, value);
  }
};

class F2fsGetVictimFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/10, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsGetVictimFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsGetVictimFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsGetVictimFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_type() const { return at<2>().valid(); }
  int32_t type() const { return at<2>().as_int32(); }
  bool has_gc_type() const { return at<3>().valid(); }
  int32_t gc_type() const { return at<3>().as_int32(); }
  bool has_alloc_mode() const { return at<4>().valid(); }
  int32_t alloc_mode() const { return at<4>().as_int32(); }
  bool has_gc_mode() const { return at<5>().valid(); }
  int32_t gc_mode() const { return at<5>().as_int32(); }
  bool has_victim() const { return at<6>().valid(); }
  uint32_t victim() const { return at<6>().as_uint32(); }
  bool has_ofs_unit() const { return at<7>().valid(); }
  uint32_t ofs_unit() const { return at<7>().as_uint32(); }
  bool has_pre_victim() const { return at<8>().valid(); }
  uint32_t pre_victim() const { return at<8>().as_uint32(); }
  bool has_prefree() const { return at<9>().valid(); }
  uint32_t prefree() const { return at<9>().as_uint32(); }
  bool has_free() const { return at<10>().valid(); }
  uint32_t free() const { return at<10>().as_uint32(); }
};

class F2fsGetVictimFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsGetVictimFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kTypeFieldNumber = 2,
    kGcTypeFieldNumber = 3,
    kAllocModeFieldNumber = 4,
    kGcModeFieldNumber = 5,
    kVictimFieldNumber = 6,
    kOfsUnitFieldNumber = 7,
    kPreVictimFieldNumber = 8,
    kPrefreeFieldNumber = 9,
    kFreeFieldNumber = 10,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_type(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_gc_type(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_alloc_mode(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_gc_mode(int32_t value) {
    AppendVarInt(5, value);
  }
  void set_victim(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_ofs_unit(uint32_t value) {
    AppendVarInt(7, value);
  }
  void set_pre_victim(uint32_t value) {
    AppendVarInt(8, value);
  }
  void set_prefree(uint32_t value) {
    AppendVarInt(9, value);
  }
  void set_free(uint32_t value) {
    AppendVarInt(10, value);
  }
};

class F2fsGetDataBlockFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsGetDataBlockFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsGetDataBlockFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsGetDataBlockFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_iblock() const { return at<3>().valid(); }
  uint64_t iblock() const { return at<3>().as_uint64(); }
  bool has_bh_start() const { return at<4>().valid(); }
  uint64_t bh_start() const { return at<4>().as_uint64(); }
  bool has_bh_size() const { return at<5>().valid(); }
  uint64_t bh_size() const { return at<5>().as_uint64(); }
  bool has_ret() const { return at<6>().valid(); }
  int32_t ret() const { return at<6>().as_int32(); }
};

class F2fsGetDataBlockFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsGetDataBlockFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kIblockFieldNumber = 3,
    kBhStartFieldNumber = 4,
    kBhSizeFieldNumber = 5,
    kRetFieldNumber = 6,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_iblock(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_bh_start(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_bh_size(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(6, value);
  }
};

class F2fsFallocateFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsFallocateFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsFallocateFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsFallocateFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_mode() const { return at<3>().valid(); }
  int32_t mode() const { return at<3>().as_int32(); }
  bool has_offset() const { return at<4>().valid(); }
  int64_t offset() const { return at<4>().as_int64(); }
  bool has_len() const { return at<5>().valid(); }
  int64_t len() const { return at<5>().as_int64(); }
  bool has_size() const { return at<6>().valid(); }
  int64_t size() const { return at<6>().as_int64(); }
  bool has_blocks() const { return at<7>().valid(); }
  uint64_t blocks() const { return at<7>().as_uint64(); }
  bool has_ret() const { return at<8>().valid(); }
  int32_t ret() const { return at<8>().as_int32(); }
};

class F2fsFallocateFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsFallocateFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kModeFieldNumber = 3,
    kOffsetFieldNumber = 4,
    kLenFieldNumber = 5,
    kSizeFieldNumber = 6,
    kBlocksFieldNumber = 7,
    kRetFieldNumber = 8,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_mode(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_offset(int64_t value) {
    AppendVarInt(4, value);
  }
  void set_len(int64_t value) {
    AppendVarInt(5, value);
  }
  void set_size(int64_t value) {
    AppendVarInt(6, value);
  }
  void set_blocks(uint64_t value) {
    AppendVarInt(7, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(8, value);
  }
};

class F2fsEvictInodeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsEvictInodeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsEvictInodeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsEvictInodeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_pino() const { return at<3>().valid(); }
  uint64_t pino() const { return at<3>().as_uint64(); }
  bool has_mode() const { return at<4>().valid(); }
  uint32_t mode() const { return at<4>().as_uint32(); }
  bool has_size() const { return at<5>().valid(); }
  int64_t size() const { return at<5>().as_int64(); }
  bool has_nlink() const { return at<6>().valid(); }
  uint32_t nlink() const { return at<6>().as_uint32(); }
  bool has_blocks() const { return at<7>().valid(); }
  uint64_t blocks() const { return at<7>().as_uint64(); }
  bool has_advise() const { return at<8>().valid(); }
  uint32_t advise() const { return at<8>().as_uint32(); }
};

class F2fsEvictInodeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsEvictInodeFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPinoFieldNumber = 3,
    kModeFieldNumber = 4,
    kSizeFieldNumber = 5,
    kNlinkFieldNumber = 6,
    kBlocksFieldNumber = 7,
    kAdviseFieldNumber = 8,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pino(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_mode(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_size(int64_t value) {
    AppendVarInt(5, value);
  }
  void set_nlink(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_blocks(uint64_t value) {
    AppendVarInt(7, value);
  }
  void set_advise(uint32_t value) {
    AppendVarInt(8, value);
  }
};

class F2fsDoSubmitBioFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsDoSubmitBioFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsDoSubmitBioFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsDoSubmitBioFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_btype() const { return at<2>().valid(); }
  int32_t btype() const { return at<2>().as_int32(); }
  bool has_sync() const { return at<3>().valid(); }
  uint32_t sync() const { return at<3>().as_uint32(); }
  bool has_sector() const { return at<4>().valid(); }
  uint64_t sector() const { return at<4>().as_uint64(); }
  bool has_size() const { return at<5>().valid(); }
  uint32_t size() const { return at<5>().as_uint32(); }
};

class F2fsDoSubmitBioFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsDoSubmitBioFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kBtypeFieldNumber = 2,
    kSyncFieldNumber = 3,
    kSectorFieldNumber = 4,
    kSizeFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_btype(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_sync(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_sector(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_size(uint32_t value) {
    AppendVarInt(5, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/ftrace/fence.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_FENCE_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_FENCE_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class FenceSignaledFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  FenceSignaledFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit FenceSignaledFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit FenceSignaledFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_context() const { return at<1>().valid(); }
  uint32_t context() const { return at<1>().as_uint32(); }
  bool has_driver() const { return at<2>().valid(); }
  ::protozero::ConstChars driver() const { return at<2>().as_string(); }
  bool has_seqno() const { return at<3>().valid(); }
  uint32_t seqno() const { return at<3>().as_uint32(); }
  bool has_timeline() const { return at<4>().valid(); }
  ::protozero::ConstChars timeline() const { return at<4>().as_string(); }
};

class FenceSignaledFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = FenceSignaledFtraceEvent_Decoder;
  enum : int32_t {
    kContextFieldNumber = 1,
    kDriverFieldNumber = 2,
    kSeqnoFieldNumber = 3,
    kTimelineFieldNumber = 4,
  };
  void set_context(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_driver(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void set_driver(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
  void set_seqno(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_timeline(const std::string& value) {
    AppendBytes(4, value.data(), value.size());
  }
  void set_timeline(const char* data, size_t size) {
    AppendBytes(4, data, size);
  }
};

class FenceEnableSignalFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  FenceEnableSignalFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit FenceEnableSignalFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit FenceEnableSignalFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_context() const { return at<1>().valid(); }
  uint32_t context() const { return at<1>().as_uint32(); }
  bool has_driver() const { return at<2>().valid(); }
  ::protozero::ConstChars driver() const { return at<2>().as_string(); }
  bool has_seqno() const { return at<3>().valid(); }
  uint32_t seqno() const { return at<3>().as_uint32(); }
  bool has_timeline() const { return at<4>().valid(); }
  ::protozero::ConstChars timeline() const { return at<4>().as_string(); }
};

class FenceEnableSignalFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = FenceEnableSignalFtraceEvent_Decoder;
  enum : int32_t {
    kContextFieldNumber = 1,
    kDriverFieldNumber = 2,
    kSeqnoFieldNumber = 3,
    kTimelineFieldNumber = 4,
  };
  void set_context(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_driver(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void set_driver(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
  void set_seqno(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_timeline(const std::string& value) {
    AppendBytes(4, value.data(), value.size());
  }
  void set_timeline(const char* data, size_t size) {
    AppendBytes(4, data, size);
  }
};

class FenceDestroyFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  FenceDestroyFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit FenceDestroyFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit FenceDestroyFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_context() const { return at<1>().valid(); }
  uint32_t context() const { return at<1>().as_uint32(); }
  bool has_driver() const { return at<2>().valid(); }
  ::protozero::ConstChars driver() const { return at<2>().as_string(); }
  bool has_seqno() const { return at<3>().valid(); }
  uint32_t seqno() const { return at<3>().as_uint32(); }
  bool has_timeline() const { return at<4>().valid(); }
  ::protozero::ConstChars timeline() const { return at<4>().as_string(); }
};

class FenceDestroyFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = FenceDestroyFtraceEvent_Decoder;
  enum : int32_t {
    kContextFieldNumber = 1,
    kDriverFieldNumber = 2,
    kSeqnoFieldNumber = 3,
    kTimelineFieldNumber = 4,
  };
  void set_context(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_driver(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void set_driver(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
  void set_seqno(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_timeline(const std::string& value) {
    AppendBytes(4, value.data(), value.size());
  }
  void set_timeline(const char* data, size_t size) {
    AppendBytes(4, data, size);
  }
};

class FenceInitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  FenceInitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit FenceInitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit FenceInitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_context() const { return at<1>().valid(); }
  uint32_t context() const { return at<1>().as_uint32(); }
  bool has_driver() const { return at<2>().valid(); }
  ::protozero::ConstChars driver() const { return at<2>().as_string(); }
  bool has_seqno() const { return at<3>().valid(); }
  uint32_t seqno() const { return at<3>().as_uint32(); }
  bool has_timeline() const { return at<4>().valid(); }
  ::protozero::ConstChars timeline() const { return at<4>().as_string(); }
};

class FenceInitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = FenceInitFtraceEvent_Decoder;
  enum : int32_t {
    kContextFieldNumber = 1,
    kDriverFieldNumber = 2,
    kSeqnoFieldNumber = 3,
    kTimelineFieldNumber = 4,
  };
  void set_context(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_driver(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void set_driver(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
  void set_seqno(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_timeline(const std::string& value) {
    AppendBytes(4, value.data(), value.size());
  }
  void set_timeline(const char* data, size_t size) {
    AppendBytes(4, data, size);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/ftrace/filemap.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_FILEMAP_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_FILEMAP_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class MmFilemapDeleteFromPageCacheFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmFilemapDeleteFromPageCacheFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmFilemapDeleteFromPageCacheFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmFilemapDeleteFromPageCacheFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_pfn() const { return at<1>().valid(); }
  uint64_t pfn() const { return at<1>().as_uint64(); }
  bool has_i_ino() const { return at<2>().valid(); }
  uint64_t i_ino() const { return at<2>().as_uint64(); }
  bool has_index() const { return at<3>().valid(); }
  uint64_t index() const { return at<3>().as_uint64(); }
  bool has_s_dev() const { return at<4>().valid(); }
  uint64_t s_dev() const { return at<4>().as_uint64(); }
  bool has_page() const { return at<5>().valid(); }
  uint64_t page() const { return at<5>().as_uint64(); }
};

class MmFilemapDeleteFromPageCacheFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmFilemapDeleteFromPageCacheFtraceEvent_Decoder;
  enum : int32_t {
    kPfnFieldNumber = 1,
    kIInoFieldNumber = 2,
    kIndexFieldNumber = 3,
    kSDevFieldNumber = 4,
    kPageFieldNumber = 5,
  };
  void set_pfn(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_i_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_index(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_s_dev(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_page(uint64_t value) {
    AppendVarInt(5, value);
  }
};

class MmFilemapAddToPageCacheFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmFilemapAddToPageCacheFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmFilemapAddToPageCacheFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmFilemapAddToPageCacheFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_pfn() const { return at<1>().valid(); }
  uint64_t pfn() const { return at<1>().as_uint64(); }
  bool has_i_ino() const { return at<2>().valid(); }
  uint64_t i_ino() const { return at<2>().as_uint64(); }
  bool has_index() const { return at<3>().valid(); }
  uint64_t index() const { return at<3>().as_uint64(); }
  bool has_s_dev() const { return at<4>().valid(); }
  uint64_t s_dev() const { return at<4>().as_uint64(); }
  bool has_page() const { return at<5>().valid(); }
  uint64_t page() const { return at<5>().as_uint64(); }
};

class MmFilemapAddToPageCacheFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmFilemapAddToPageCacheFtraceEvent_Decoder;
  enum : int32_t {
    kPfnFieldNumber = 1,
    kIInoFieldNumber = 2,
    kIndexFieldNumber = 3,
    kSDevFieldNumber = 4,
    kPageFieldNumber = 5,
  };
  void set_pfn(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_i_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_index(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_s_dev(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_page(uint64_t value) {
    AppendVarInt(5, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/ftrace/ftrace.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_FTRACE_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_FTRACE_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class PrintFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  PrintFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit PrintFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit PrintFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_ip() const { return at<1>().valid(); }
  uint64_t ip() const { return at<1>().as_uint64(); }
  bool has_buf() const { return at<2>().valid(); }
  ::protozero::ConstChars buf() const { return at<2>().as_string(); }
};

class PrintFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = PrintFtraceEvent_Decoder;
  enum : int32_t {
    kIpFieldNumber = 1,
    kBufFieldNumber = 2,
  };
  void set_ip(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_buf(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void set_buf(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/ftrace/i2c.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_I2C_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_I2C_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class SmbusReplyFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SmbusReplyFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SmbusReplyFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SmbusReplyFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_adapter_nr() const { return at<1>().valid(); }
  int32_t adapter_nr() const { return at<1>().as_int32(); }
  bool has_addr() const { return at<2>().valid(); }
  uint32_t addr() const { return at<2>().as_uint32(); }
  bool has_flags() const { return at<3>().valid(); }
  uint32_t flags() const { return at<3>().as_uint32(); }
  bool has_command() const { return at<4>().valid(); }
  uint32_t command() const { return at<4>().as_uint32(); }
  bool has_len() const { return at<5>().valid(); }
  uint32_t len() const { return at<5>().as_uint32(); }
  bool has_protocol() const { return at<6>().valid(); }
  uint32_t protocol() const { return at<6>().as_uint32(); }
};

class SmbusReplyFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SmbusReplyFtraceEvent_Decoder;
  enum : int32_t {
    kAdapterNrFieldNumber = 1,
    kAddrFieldNumber = 2,
    kFlagsFieldNumber = 3,
    kCommandFieldNumber = 4,
    kLenFieldNumber = 5,
    kProtocolFieldNumber = 6,
  };
  void set_adapter_nr(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_addr(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_command(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_protocol(uint32_t value) {
    AppendVarInt(6, value);
  }
};

class SmbusResultFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/7, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SmbusResultFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SmbusResultFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SmbusResultFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_adapter_nr() const { return at<1>().valid(); }
  int32_t adapter_nr() const { return at<1>().as_int32(); }
  bool has_addr() const { return at<2>().valid(); }
  uint32_t addr() const { return at<2>().as_uint32(); }
  bool has_flags() const { return at<3>().valid(); }
  uint32_t flags() const { return at<3>().as_uint32(); }
  bool has_read_write() const { return at<4>().valid(); }
  uint32_t read_write() const { return at<4>().as_uint32(); }
  bool has_command() const { return at<5>().valid(); }
  uint32_t command() const { return at<5>().as_uint32(); }
  bool has_res() const { return at<6>().valid(); }
  int32_t res() const { return at<6>().as_int32(); }
  bool has_protocol() const { return at<7>().valid(); }
  uint32_t protocol() const { return at<7>().as_uint32(); }
};

class SmbusResultFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SmbusResultFtraceEvent_Decoder;
  enum : int32_t {
    kAdapterNrFieldNumber = 1,
    kAddrFieldNumber = 2,
    kFlagsFieldNumber = 3,
    kReadWriteFieldNumber = 4,
    kCommandFieldNumber = 5,
    kResFieldNumber = 6,
    kProtocolFieldNumber = 7,
  };
  void set_adapter_nr(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_addr(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_read_write(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_command(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_res(int32_t value) {
    AppendVarInt(6, value);
  }
  void set_protocol(uint32_t value) {
    AppendVarInt(7, value);
  }
};

class SmbusWriteFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SmbusWriteFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SmbusWriteFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SmbusWriteFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_adapter_nr() const { return at<1>().valid(); }
  int32_t adapter_nr() const { return at<1>().as_int32(); }
  bool has_addr() const { return at<2>().valid(); }
  uint32_t addr() const { return at<2>().as_uint32(); }
  bool has_flags() const { return at<3>().valid(); }
  uint32_t flags() const { return at<3>().as_uint32(); }
  bool has_command() const { return at<4>().valid(); }
  uint32_t command() const { return at<4>().as_uint32(); }
  bool has_len() const { return at<5>().valid(); }
  uint32_t len() const { return at<5>().as_uint32(); }
  bool has_protocol() const { return at<6>().valid(); }
  uint32_t protocol() const { return at<6>().as_uint32(); }
};

class SmbusWriteFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SmbusWriteFtraceEvent_Decoder;
  enum : int32_t {
    kAdapterNrFieldNumber = 1,
    kAddrFieldNumber = 2,
    kFlagsFieldNumber = 3,
    kCommandFieldNumber = 4,
    kLenFieldNumber = 5,
    kProtocolFieldNumber = 6,
  };
  void set_adapter_nr(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_addr(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_command(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_protocol(uint32_t value) {
    AppendVarInt(6, value);
  }
};

class SmbusReadFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SmbusReadFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SmbusReadFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SmbusReadFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_adapter_nr() const { return at<1>().valid(); }
  int32_t adapter_nr() const { return at<1>().as_int32(); }
  bool has_flags() const { return at<2>().valid(); }
  uint32_t flags() const { return at<2>().as_uint32(); }
  bool has_addr() const { return at<3>().valid(); }
  uint32_t addr() const { return at<3>().as_uint32(); }
  bool has_command() const { return at<4>().valid(); }
  uint32_t command() const { return at<4>().as_uint32(); }
  bool has_protocol() const { return at<5>().valid(); }
  uint32_t protocol() const { return at<5>().as_uint32(); }
};

class SmbusReadFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SmbusReadFtraceEvent_Decoder;
  enum : int32_t {
    kAdapterNrFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kAddrFieldNumber = 3,
    kCommandFieldNumber = 4,
    kProtocolFieldNumber = 5,
  };
  void set_adapter_nr(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_addr(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_command(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_protocol(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class I2cReplyFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  I2cReplyFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit I2cReplyFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit I2cReplyFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_adapter_nr() const { return at<1>().valid(); }
  int32_t adapter_nr() const { return at<1>().as_int32(); }
  bool has_msg_nr() const { return at<2>().valid(); }
  uint32_t msg_nr() const { return at<2>().as_uint32(); }
  bool has_addr() const { return at<3>().valid(); }
  uint32_t addr() const { return at<3>().as_uint32(); }
  bool has_flags() const { return at<4>().valid(); }
  uint32_t flags() const { return at<4>().as_uint32(); }
  bool has_len() const { return at<5>().valid(); }
  uint32_t len() const { return at<5>().as_uint32(); }
  bool has_buf() const { return at<6>().valid(); }
  uint32_t buf() const { return at<6>().as_uint32(); }
};

class I2cReplyFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = I2cReplyFtraceEvent_Decoder;
  enum : int32_t {
    kAdapterNrFieldNumber = 1,
    kMsgNrFieldNumber = 2,
    kAddrFieldNumber = 3,
    kFlagsFieldNumber = 4,
    kLenFieldNumber = 5,
    kBufFieldNumber = 6,
  };
  void set_adapter_nr(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_msg_nr(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_addr(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_buf(uint32_t value) {
    AppendVarInt(6, value);
  }
};

class I2cResultFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  I2cResultFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit I2cResultFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit I2cResultFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_adapter_nr() const { return at<1>().valid(); }
  int32_t adapter_nr() const { return at<1>().as_int32(); }
  bool has_nr_msgs() const { return at<2>().valid(); }
  uint32_t nr_msgs() const { return at<2>().as_uint32(); }
  bool has_ret() const { return at<3>().valid(); }
  int32_t ret() const { return at<3>().as_int32(); }
};

class I2cResultFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = I2cResultFtraceEvent_Decoder;
  enum : int32_t {
    kAdapterNrFieldNumber = 1,
    kNrMsgsFieldNumber = 2,
    kRetFieldNumber = 3,
  };
  void set_adapter_nr(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_nr_msgs(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(3, value);
  }
};

class I2cWriteFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  I2cWriteFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit I2cWriteFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit I2cWriteFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_adapter_nr() const { return at<1>().valid(); }
  int32_t adapter_nr() const { return at<1>().as_int32(); }
  bool has_msg_nr() const { return at<2>().valid(); }
  uint32_t msg_nr() const { return at<2>().as_uint32(); }
  bool has_addr() const { return at<3>().valid(); }
  uint32_t addr() const { return at<3>().as_uint32(); }
  bool has_flags() const { return at<4>().valid(); }
  uint32_t flags() const { return at<4>().as_uint32(); }
  bool has_len() const { return at<5>().valid(); }
  uint32_t len() const { return at<5>().as_uint32(); }
  bool has_buf() const { return at<6>().valid(); }
  uint32_t buf() const { return at<6>().as_uint32(); }
};

class I2cWriteFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = I2cWriteFtraceEvent_Decoder;
  enum : int32_t {
    kAdapterNrFieldNumber = 1,
    kMsgNrFieldNumber = 2,
    kAddrFieldNumber = 3,
    kFlagsFieldNumber = 4,
    kLenFieldNumber = 5,
    kBufFieldNumber = 6,
  };
  void set_adapter_nr(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_msg_nr(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_addr(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_buf(uint32_t value) {
    AppendVarInt(6, value);
  }
};

class I2cReadFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  I2cReadFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit I2cReadFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit I2cReadFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_adapter_nr() const { return at<1>().valid(); }
  int32_t adapter_nr() const { return at<1>().as_int32(); }
  bool has_msg_nr() const { return at<2>().valid(); }
  uint32_t msg_nr() const { return at<2>().as_uint32(); }
  bool has_addr() const { return at<3>().valid(); }
  uint32_t addr() const { return at<3>().as_uint32(); }
  bool has_flags() const { return at<4>().valid(); }
  uint32_t flags() const { return at<4>().as_uint32(); }
  bool has_len() const { return at<5>().valid(); }
  uint32_t len() const { return at<5>().as_uint32(); }
};

class I2cReadFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = I2cReadFtraceEvent_Decoder;
  enum : int32_t {
    kAdapterNrFieldNumber = 1,
    kMsgNrFieldNumber = 2,
    kAddrFieldNumber = 3,
    kFlagsFieldNumber = 4,
    kLenFieldNumber = 5,
  };
  void set_adapter_nr(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_msg_nr(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_addr(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(5, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/ftrace/ipi.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_IPI_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_IPI_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class IpiRaiseFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IpiRaiseFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IpiRaiseFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IpiRaiseFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_target_cpus() const { return at<1>().valid(); }
  uint32_t target_cpus() const { return at<1>().as_uint32(); }
  bool has_reason() const { return at<2>().valid(); }
  ::protozero::ConstChars reason() const { return at<2>().as_string(); }
};

class IpiRaiseFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IpiRaiseFtraceEvent_Decoder;
  enum : int32_t {
    kTargetCpusFieldNumber = 1,
    kReasonFieldNumber = 2,
  };
  void set_target_cpus(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_reason(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void set_reason(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
};

class IpiExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IpiExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IpiExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IpiExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_reason() const { return at<1>().valid(); }
  ::protozero::ConstChars reason() const { return at<1>().as_string(); }
};

class IpiExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IpiExitFtraceEvent_Decoder;
  enum : int32_t {
    kReasonFieldNumber = 1,
  };
  void set_reason(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_reason(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
};

class IpiEntryFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IpiEntryFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IpiEntryFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IpiEntryFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_reason() const { return at<1>().valid(); }
  ::protozero::ConstChars reason() const { return at<1>().as_string(); }
};

class IpiEntryFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IpiEntryFtraceEvent_Decoder;
  enum : int32_t {
    kReasonFieldNumber = 1,
  };
  void set_reason(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_reason(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/ftrace/irq.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_IRQ_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_IRQ_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class IrqHandlerExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IrqHandlerExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IrqHandlerExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IrqHandlerExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_irq() const { return at<1>().valid(); }
  int32_t irq() const { return at<1>().as_int32(); }
  bool has_ret() const { return at<2>().valid(); }
  int32_t ret() const { return at<2>().as_int32(); }
};

class IrqHandlerExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IrqHandlerExitFtraceEvent_Decoder;
  enum : int32_t {
    kIrqFieldNumber = 1,
    kRetFieldNumber = 2,
  };
  void set_irq(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(2, value);
  }
};

class IrqHandlerEntryFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IrqHandlerEntryFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IrqHandlerEntryFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IrqHandlerEntryFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_irq() const { return at<1>().valid(); }
  int32_t irq() const { return at<1>().as_int32(); }
  bool has_name() const { return at<2>().valid(); }
  ::protozero::ConstChars name() const { return at<2>().as_string(); }
  bool has_handler() const { return at<3>().valid(); }
  uint32_t handler() const { return at<3>().as_uint32(); }
};

class IrqHandlerEntryFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IrqHandlerEntryFtraceEvent_Decoder;
  enum : int32_t {
    kIrqFieldNumber = 1,
    kNameFieldNumber = 2,
    kHandlerFieldNumber = 3,
  };
  void set_irq(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_name(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void set_name(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
  void set_handler(uint32_t value) {
    AppendVarInt(3, value);
  }
};

class SoftirqRaiseFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SoftirqRaiseFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SoftirqRaiseFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SoftirqRaiseFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_vec() const { return at<1>().valid(); }
  uint32_t vec() const { return at<1>().as_uint32(); }
};

class SoftirqRaiseFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SoftirqRaiseFtraceEvent_Decoder;
  enum : int32_t {
    kVecFieldNumber = 1,
  };
  void set_vec(uint32_t value) {
    AppendVarInt(1, value);
  }
};

class SoftirqExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SoftirqExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SoftirqExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SoftirqExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_vec() const { return at<1>().valid(); }
  uint32_t vec() const { return at<1>().as_uint32(); }
};

class SoftirqExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SoftirqExitFtraceEvent_Decoder;
  enum : int32_t {
    kVecFieldNumber = 1,
  };
  void set_vec(uint32_t value) {
    AppendVarInt(1, value);
  }
};

class SoftirqEntryFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SoftirqEntryFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SoftirqEntryFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SoftirqEntryFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_vec() const { return at<1>().valid(); }
  uint32_t vec() const { return at<1>().as_uint32(); }
};

class SoftirqEntryFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SoftirqEntryFtraceEvent_Decoder;
  enum : int32_t {
    kVecFieldNumber = 1,
  };
  void set_vec(uint32_t value) {
    AppendVarInt(1, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/ftrace/kmem.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_KMEM_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_KMEM_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class IonHeapGrowFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IonHeapGrowFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IonHeapGrowFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IonHeapGrowFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_heap_name() const { return at<1>().valid(); }
  ::protozero::ConstChars heap_name() const { return at<1>().as_string(); }
  bool has_len() const { return at<2>().valid(); }
  uint64_t len() const { return at<2>().as_uint64(); }
  bool has_total_allocated() const { return at<3>().valid(); }
  int64_t total_allocated() const { return at<3>().as_int64(); }
};

class IonHeapGrowFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IonHeapGrowFtraceEvent_Decoder;
  enum : int32_t {
    kHeapNameFieldNumber = 1,
    kLenFieldNumber = 2,
    kTotalAllocatedFieldNumber = 3,
  };
  void set_heap_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_heap_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_len(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_total_allocated(int64_t value) {
    AppendVarInt(3, value);
  }
};

class IonHeapShrinkFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IonHeapShrinkFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IonHeapShrinkFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IonHeapShrinkFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_heap_name() const { return at<1>().valid(); }
  ::protozero::ConstChars heap_name() const { return at<1>().as_string(); }
  bool has_len() const { return at<2>().valid(); }
  uint64_t len() const { return at<2>().as_uint64(); }
  bool has_total_allocated() const { return at<3>().valid(); }
  int64_t total_allocated() const { return at<3>().as_int64(); }
};

class IonHeapShrinkFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IonHeapShrinkFtraceEvent_Decoder;
  enum : int32_t {
    kHeapNameFieldNumber = 1,
    kLenFieldNumber = 2,
    kTotalAllocatedFieldNumber = 3,
  };
  void set_heap_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_heap_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_len(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_total_allocated(int64_t value) {
    AppendVarInt(3, value);
  }
};

class RssStatFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  RssStatFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit RssStatFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit RssStatFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_member() const { return at<1>().valid(); }
  int32_t member() const { return at<1>().as_int32(); }
  bool has_size() const { return at<2>().valid(); }
  int64_t size() const { return at<2>().as_int64(); }
};

class RssStatFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = RssStatFtraceEvent_Decoder;
  enum : int32_t {
    kMemberFieldNumber = 1,
    kSizeFieldNumber = 2,
  };
  void set_member(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_size(int64_t value) {
    AppendVarInt(2, value);
  }
};

class MmPagePcpuDrainFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmPagePcpuDrainFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmPagePcpuDrainFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmPagePcpuDrainFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_migratetype() const { return at<1>().valid(); }
  int32_t migratetype() const { return at<1>().as_int32(); }
  bool has_order() const { return at<2>().valid(); }
  uint32_t order() const { return at<2>().as_uint32(); }
  bool has_page() const { return at<3>().valid(); }
  uint64_t page() const { return at<3>().as_uint64(); }
  bool has_pfn() const { return at<4>().valid(); }
  uint64_t pfn() const { return at<4>().as_uint64(); }
};

class MmPagePcpuDrainFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmPagePcpuDrainFtraceEvent_Decoder;
  enum : int32_t {
    kMigratetypeFieldNumber = 1,
    kOrderFieldNumber = 2,
    kPageFieldNumber = 3,
    kPfnFieldNumber = 4,
  };
  void set_migratetype(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_order(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_page(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_pfn(uint64_t value) {
    AppendVarInt(4, value);
  }
};

class MmPageFreeBatchedFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmPageFreeBatchedFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmPageFreeBatchedFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmPageFreeBatchedFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_cold() const { return at<1>().valid(); }
  int32_t cold() const { return at<1>().as_int32(); }
  bool has_page() const { return at<2>().valid(); }
  uint64_t page() const { return at<2>().as_uint64(); }
  bool has_pfn() const { return at<3>().valid(); }
  uint64_t pfn() const { return at<3>().as_uint64(); }
};

class MmPageFreeBatchedFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmPageFreeBatchedFtraceEvent_Decoder;
  enum : int32_t {
    kColdFieldNumber = 1,
    kPageFieldNumber = 2,
    kPfnFieldNumber = 3,
  };
  void set_cold(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_page(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pfn(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class MmPageFreeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmPageFreeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmPageFreeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmPageFreeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_order() const { return at<1>().valid(); }
  uint32_t order() const { return at<1>().as_uint32(); }
  bool has_page() const { return at<2>().valid(); }
  uint64_t page() const { return at<2>().as_uint64(); }
  bool has_pfn() const { return at<3>().valid(); }
  uint64_t pfn() const { return at<3>().as_uint64(); }
};

class MmPageFreeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmPageFreeFtraceEvent_Decoder;
  enum : int32_t {
    kOrderFieldNumber = 1,
    kPageFieldNumber = 2,
    kPfnFieldNumber = 3,
  };
  void set_order(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_page(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pfn(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class MmPageAllocZoneLockedFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmPageAllocZoneLockedFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmPageAllocZoneLockedFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmPageAllocZoneLockedFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_migratetype() const { return at<1>().valid(); }
  int32_t migratetype() const { return at<1>().as_int32(); }
  bool has_order() const { return at<2>().valid(); }
  uint32_t order() const { return at<2>().as_uint32(); }
  bool has_page() const { return at<3>().valid(); }
  uint64_t page() const { return at<3>().as_uint64(); }
  bool has_pfn() const { return at<4>().valid(); }
  uint64_t pfn() const { return at<4>().as_uint64(); }
};

class MmPageAllocZoneLockedFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmPageAllocZoneLockedFtraceEvent_Decoder;
  enum : int32_t {
    kMigratetypeFieldNumber = 1,
    kOrderFieldNumber = 2,
    kPageFieldNumber = 3,
    kPfnFieldNumber = 4,
  };
  void set_migratetype(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_order(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_page(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_pfn(uint64_t value) {
    AppendVarInt(4, value);
  }
};

class MmPageAllocExtfragFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/7, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmPageAllocExtfragFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmPageAllocExtfragFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmPageAllocExtfragFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_alloc_migratetype() const { return at<1>().valid(); }
  int32_t alloc_migratetype() const { return at<1>().as_int32(); }
  bool has_alloc_order() const { return at<2>().valid(); }
  int32_t alloc_order() const { return at<2>().as_int32(); }
  bool has_fallback_migratetype() const { return at<3>().valid(); }
  int32_t fallback_migratetype() const { return at<3>().as_int32(); }
  bool has_fallback_order() const { return at<4>().valid(); }
  int32_t fallback_order() const { return at<4>().as_int32(); }
  bool has_page() const { return at<5>().valid(); }
  uint64_t page() const { return at<5>().as_uint64(); }
  bool has_change_ownership() const { return at<6>().valid(); }
  int32_t change_ownership() const { return at<6>().as_int32(); }
  bool has_pfn() const { return at<7>().valid(); }
  uint64_t pfn() const { return at<7>().as_uint64(); }
};

class MmPageAllocExtfragFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmPageAllocExtfragFtraceEvent_Decoder;
  enum : int32_t {
    kAllocMigratetypeFieldNumber = 1,
    kAllocOrderFieldNumber = 2,
    kFallbackMigratetypeFieldNumber = 3,
    kFallbackOrderFieldNumber = 4,
    kPageFieldNumber = 5,
    kChangeOwnershipFieldNumber = 6,
    kPfnFieldNumber = 7,
  };
  void set_alloc_migratetype(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_alloc_order(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_fallback_migratetype(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_fallback_order(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_page(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_change_ownership(int32_t value) {
    AppendVarInt(6, value);
  }
  void set_pfn(uint64_t value) {
    AppendVarInt(7, value);
  }
};

class MmPageAllocFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmPageAllocFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmPageAllocFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmPageAllocFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_gfp_flags() const { return at<1>().valid(); }
  uint32_t gfp_flags() const { return at<1>().as_uint32(); }
  bool has_migratetype() const { return at<2>().valid(); }
  int32_t migratetype() const { return at<2>().as_int32(); }
  bool has_order() const { return at<3>().valid(); }
  uint32_t order() const { return at<3>().as_uint32(); }
  bool has_page() const { return at<4>().valid(); }
  uint64_t page() const { return at<4>().as_uint64(); }
  bool has_pfn() const { return at<5>().valid(); }
  uint64_t pfn() const { return at<5>().as_uint64(); }
};

class MmPageAllocFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmPageAllocFtraceEvent_Decoder;
  enum : int32_t {
    kGfpFlagsFieldNumber = 1,
    kMigratetypeFieldNumber = 2,
    kOrderFieldNumber = 3,
    kPageFieldNumber = 4,
    kPfnFieldNumber = 5,
  };
  void set_gfp_flags(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_migratetype(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_order(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_page(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_pfn(uint64_t value) {
    AppendVarInt(5, value);
  }
};

class MigrateRetryFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MigrateRetryFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MigrateRetryFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MigrateRetryFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_tries() const { return at<1>().valid(); }
  int32_t tries() const { return at<1>().as_int32(); }
};

class MigrateRetryFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MigrateRetryFtraceEvent_Decoder;
  enum : int32_t {
    kTriesFieldNumber = 1,
  };
  void set_tries(int32_t value) {
    AppendVarInt(1, value);
  }
};

class MigratePagesStartFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MigratePagesStartFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MigratePagesStartFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MigratePagesStartFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_mode() const { return at<1>().valid(); }
  int32_t mode() const { return at<1>().as_int32(); }
};

class MigratePagesStartFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MigratePagesStartFtraceEvent_Decoder;
  enum : int32_t {
    kModeFieldNumber = 1,
  };
  void set_mode(int32_t value) {
    AppendVarInt(1, value);
  }
};

class MigratePagesEndFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MigratePagesEndFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MigratePagesEndFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MigratePagesEndFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_mode() const { return at<1>().valid(); }
  int32_t mode() const { return at<1>().as_int32(); }
};

class MigratePagesEndFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MigratePagesEndFtraceEvent_Decoder;
  enum : int32_t {
    kModeFieldNumber = 1,
  };
  void set_mode(int32_t value) {
    AppendVarInt(1, value);
  }
};

class KmemCacheFreeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  KmemCacheFreeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit KmemCacheFreeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit KmemCacheFreeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_call_site() const { return at<1>().valid(); }
  uint64_t call_site() const { return at<1>().as_uint64(); }
  bool has_ptr() const { return at<2>().valid(); }
  uint64_t ptr() const { return at<2>().as_uint64(); }
};

class KmemCacheFreeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = KmemCacheFreeFtraceEvent_Decoder;
  enum : int32_t {
    kCallSiteFieldNumber = 1,
    kPtrFieldNumber = 2,
  };
  void set_call_site(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ptr(uint64_t value) {
    AppendVarInt(2, value);
  }
};

class KmemCacheAllocNodeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  KmemCacheAllocNodeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit KmemCacheAllocNodeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit KmemCacheAllocNodeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_bytes_alloc() const { return at<1>().valid(); }
  uint64_t bytes_alloc() const { return at<1>().as_uint64(); }
  bool has_bytes_req() const { return at<2>().valid(); }
  uint64_t bytes_req() const { return at<2>().as_uint64(); }
  bool has_call_site() const { return at<3>().valid(); }
  uint64_t call_site() const { return at<3>().as_uint64(); }
  bool has_gfp_flags() const { return at<4>().valid(); }
  uint32_t gfp_flags() const { return at<4>().as_uint32(); }
  bool has_node() const { return at<5>().valid(); }
  int32_t node() const { return at<5>().as_int32(); }
  bool has_ptr() const { return at<6>().valid(); }
  uint64_t ptr() const { return at<6>().as_uint64(); }
};

class KmemCacheAllocNodeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = KmemCacheAllocNodeFtraceEvent_Decoder;
  enum : int32_t {
    kBytesAllocFieldNumber = 1,
    kBytesReqFieldNumber = 2,
    kCallSiteFieldNumber = 3,
    kGfpFlagsFieldNumber = 4,
    kNodeFieldNumber = 5,
    kPtrFieldNumber = 6,
  };
  void set_bytes_alloc(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_bytes_req(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_call_site(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_gfp_flags(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_node(int32_t value) {
    AppendVarInt(5, value);
  }
  void set_ptr(uint64_t value) {
    AppendVarInt(6, value);
  }
};

class KmemCacheAllocFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  KmemCacheAllocFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit KmemCacheAllocFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit KmemCacheAllocFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_bytes_alloc() const { return at<1>().valid(); }
  uint64_t bytes_alloc() const { return at<1>().as_uint64(); }
  bool has_bytes_req() const { return at<2>().valid(); }
  uint64_t bytes_req() const { return at<2>().as_uint64(); }
  bool has_call_site() const { return at<3>().valid(); }
  uint64_t call_site() const { return at<3>().as_uint64(); }
  bool has_gfp_flags() const { return at<4>().valid(); }
  uint32_t gfp_flags() const { return at<4>().as_uint32(); }
  bool has_ptr() const { return at<5>().valid(); }
  uint64_t ptr() const { return at<5>().as_uint64(); }
};

class KmemCacheAllocFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = KmemCacheAllocFtraceEvent_Decoder;
  enum : int32_t {
    kBytesAllocFieldNumber = 1,
    kBytesReqFieldNumber = 2,
    kCallSiteFieldNumber = 3,
    kGfpFlagsFieldNumber = 4,
    kPtrFieldNumber = 5,
  };
  void set_bytes_alloc(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_bytes_req(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_call_site(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_gfp_flags(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_ptr(uint64_t value) {
    AppendVarInt(5, value);
  }
};

class KmallocNodeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  KmallocNodeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit KmallocNodeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit KmallocNodeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_bytes_alloc() const { return at<1>().valid(); }
  uint64_t bytes_alloc() const { return at<1>().as_uint64(); }
  bool has_bytes_req() const { return at<2>().valid(); }
  uint64_t bytes_req() const { return at<2>().as_uint64(); }
  bool has_call_site() const { return at<3>().valid(); }
  uint64_t call_site() const { return at<3>().as_uint64(); }
  bool has_gfp_flags() const { return at<4>().valid(); }
  uint32_t gfp_flags() const { return at<4>().as_uint32(); }
  bool has_node() const { return at<5>().valid(); }
  int32_t node() const { return at<5>().as_int32(); }
  bool has_ptr() const { return at<6>().valid(); }
  uint64_t ptr() const { return at<6>().as_uint64(); }
};

class KmallocNodeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = KmallocNodeFtraceEvent_Decoder;
  enum : int32_t {
    kBytesAllocFieldNumber = 1,
    kBytesReqFieldNumber = 2,
    kCallSiteFieldNumber = 3,
    kGfpFlagsFieldNumber = 4,
    kNodeFieldNumber = 5,
    kPtrFieldNumber = 6,
  };
  void set_bytes_alloc(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_bytes_req(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_call_site(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_gfp_flags(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_node(int32_t value) {
    AppendVarInt(5, value);
  }
  void set_ptr(uint64_t value) {
    AppendVarInt(6, value);
  }
};

class KmallocFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  KmallocFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit KmallocFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit KmallocFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_bytes_alloc() const { return at<1>().valid(); }
  uint64_t bytes_alloc() const { return at<1>().as_uint64(); }
  bool has_bytes_req() const { return at<2>().valid(); }
  uint64_t bytes_req() const { return at<2>().as_uint64(); }
  bool has_call_site() const { return at<3>().valid(); }
  uint64_t call_site() const { return at<3>().as_uint64(); }
  bool has_gfp_flags() const { return at<4>().valid(); }
  uint32_t gfp_flags() const { return at<4>().as_uint32(); }
  bool has_ptr() const { return at<5>().valid(); }
  uint64_t ptr() const { return at<5>().as_uint64(); }
};

class KmallocFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = KmallocFtraceEvent_Decoder;
  enum : int32_t {
    kBytesAllocFieldNumber = 1,
    kBytesReqFieldNumber = 2,
    kCallSiteFieldNumber = 3,
    kGfpFlagsFieldNumber = 4,
    kPtrFieldNumber = 5,
  };
  void set_bytes_alloc(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_bytes_req(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_call_site(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_gfp_flags(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_ptr(uint64_t value) {
    AppendVarInt(5, value);
  }
};

class KfreeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  KfreeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit KfreeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit KfreeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_call_site() const { return at<1>().valid(); }
  uint64_t call_site() const { return at<1>().as_uint64(); }
  bool has_ptr() const { return at<2>().valid(); }
  uint64_t ptr() const { return at<2>().as_uint64(); }
};

class KfreeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = KfreeFtraceEvent_Decoder;
  enum : int32_t {
    kCallSiteFieldNumber = 1,
    kPtrFieldNumber = 2,
  };
  void set_call_site(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ptr(uint64_t value) {
    AppendVarInt(2, value);
  }
};

class IonSecureCmaShrinkPoolStartFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IonSecureCmaShrinkPoolStartFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IonSecureCmaShrinkPoolStartFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IonSecureCmaShrinkPoolStartFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_drained_size() const { return at<1>().valid(); }
  uint64_t drained_size() const { return at<1>().as_uint64(); }
  bool has_skipped_size() const { return at<2>().valid(); }
  uint64_t skipped_size() const { return at<2>().as_uint64(); }
};

class IonSecureCmaShrinkPoolStartFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IonSecureCmaShrinkPoolStartFtraceEvent_Decoder;
  enum : int32_t {
    kDrainedSizeFieldNumber = 1,
    kSkippedSizeFieldNumber = 2,
  };
  void set_drained_size(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_skipped_size(uint64_t value) {
    AppendVarInt(2, value);
  }
};

class IonSecureCmaShrinkPoolEndFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IonSecureCmaShrinkPoolEndFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IonSecureCmaShrinkPoolEndFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IonSecureCmaShrinkPoolEndFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_drained_size() const { return at<1>().valid(); }
  uint64_t drained_size() const { return at<1>().as_uint64(); }
  bool has_skipped_size() const { return at<2>().valid(); }
  uint64_t skipped_size() const { return at<2>().as_uint64(); }
};

class IonSecureCmaShrinkPoolEndFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IonSecureCmaShrinkPoolEndFtraceEvent_Decoder;
  enum : int32_t {
    kDrainedSizeFieldNumber = 1,
    kSkippedSizeFieldNumber = 2,
  };
  void set_drained_size(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_skipped_size(uint64_t value) {
    AppendVarInt(2, value);
  }
};

class IonSecureCmaAllocateStartFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IonSecureCmaAllocateStartFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IonSecureCmaAllocateStartFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IonSecureCmaAllocateStartFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_align() const { return at<1>().valid(); }
  uint64_t align() const { return at<1>().as_uint64(); }
  bool has_flags() const { return at<2>().valid(); }
  uint64_t flags() const { return at<2>().as_uint64(); }
  bool has_heap_name() const { return at<3>().valid(); }
  ::protozero::ConstChars heap_name() const { return at<3>().as_string(); }
  bool has_len() const { return at<4>().valid(); }
  uint64_t len() const { return at<4>().as_uint64(); }
};

class IonSecureCmaAllocateStartFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IonSecureCmaAllocateStartFtraceEvent_Decoder;
  enum : int32_t {
    kAlignFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kHeapNameFieldNumber = 3,
    kLenFieldNumber = 4,
  };
  void set_align(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_flags(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_heap_name(const std::string& value) {
    AppendBytes(3, value.data(), value.size());
  }
  void set_heap_name(const char* data, size_t size) {
    AppendBytes(3, data, size);
  }
  void set_len(uint64_t value) {
    AppendVarInt(4, value);
  }
};

class IonSecureCmaAllocateEndFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IonSecureCmaAllocateEndFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IonSecureCmaAllocateEndFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IonSecureCmaAllocateEndFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_align() const { return at<1>().valid(); }
  uint64_t align() const { return at<1>().as_uint64(); }
  bool has_flags() const { return at<2>().valid(); }
  uint64_t flags() const { return at<2>().as_uint64(); }
  bool has_heap_name() const { return at<3>().valid(); }
  ::protozero::ConstChars heap_name() const { return at<3>().as_string(); }
  bool has_len() const { return at<4>().valid(); }
  uint64_t len() const { return at<4>().as_uint64(); }
};

class IonSecureCmaAllocateEndFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IonSecureCmaAllocateEndFtraceEvent_Decoder;
  enum : int32_t {
    kAlignFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kHeapNameFieldNumber = 3,
    kLenFieldNumber = 4,
  };
  void set_align(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_flags(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_heap_name(const std::string& value) {
    AppendBytes(3, value.data(), value.size());
  }
  void set_heap_name(const char* data, size_t size) {
    AppendBytes(3, data, size);
  }
  void set_len(uint64_t value) {
    AppendVarInt(4, value);
  }
};

class IonSecureCmaAddToPoolStartFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IonSecureCmaAddToPoolStartFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IonSecureCmaAddToPoolStartFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IonSecureCmaAddToPoolStartFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_is_prefetch() const { return at<1>().valid(); }
  uint32_t is_prefetch() const { return at<1>().as_uint32(); }
  bool has_len() const { return at<2>().valid(); }
  uint64_t len() const { return at<2>().as_uint64(); }
  bool has_pool_total() const { return at<3>().valid(); }
  int32_t pool_total() const { return at<3>().as_int32(); }
};

class IonSecureCmaAddToPoolStartFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IonSecureCmaAddToPoolStartFtraceEvent_Decoder;
  enum : int32_t {
    kIsPrefetchFieldNumber = 1,
    kLenFieldNumber = 2,
    kPoolTotalFieldNumber = 3,
  };
  void set_is_prefetch(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_len(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pool_total(int32_t value) {
    AppendVarInt(3, value);
  }
};

class IonSecureCmaAddToPoolEndFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IonSecureCmaAddToPoolEndFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IonSecureCmaAddToPoolEndFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IonSecureCmaAddToPoolEndFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_is_prefetch() const { return at<1>().valid(); }
  uint32_t is_prefetch() const { return at<1>().as_uint32(); }
  bool has_len() const { return at<2>().valid(); }
  uint64_t len() const { return at<2>().as_uint64(); }
  bool has_pool_total() const { return at<3>().valid(); }
  int32_t pool_total() const { return at<3>().as_int32(); }
};

class IonSecureCmaAddToPoolEndFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IonSecureCmaAddToPoolEndFtraceEvent_Decoder;
  enum : int32_t {
    kIsPrefetchFieldNumber = 1,
    kLenFieldNumber = 2,
    kPoolTotalFieldNumber = 3,
  };
  void set_is_prefetch(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_len(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pool_total(int32_t value) {
    AppendVarInt(3, value);
  }
};

class IonPrefetchingFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IonPrefetchingFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IonPrefetchingFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IonPrefetchingFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_len() const { return at<1>().valid(); }
  uint64_t len() const { return at<1>().as_uint64(); }
};

class IonPrefetchingFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IonPrefetchingFtraceEvent_Decoder;
  enum : int32_t {
    kLenFieldNumber = 1,
  };
  void set_len(uint64_t value) {
    AppendVarInt(1, value);
  }
};

class IonCpSecureBufferStartFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IonCpSecureBufferStartFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IonCpSecureBufferStartFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IonCpSecureBufferStartFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_align() const { return at<1>().valid(); }
  uint64_t align() const { return at<1>().as_uint64(); }
  bool has_flags() const { return at<2>().valid(); }
  uint64_t flags() const { return at<2>().as_uint64(); }
  bool has_heap_name() const { return at<3>().valid(); }
  ::protozero::ConstChars heap_name() const { return at<3>().as_string(); }
  bool has_len() const { return at<4>().valid(); }
  uint64_t len() const { return at<4>().as_uint64(); }
};

class IonCpSecureBufferStartFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IonCpSecureBufferStartFtraceEvent_Decoder;
  enum : int32_t {
    kAlignFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kHeapNameFieldNumber = 3,
    kLenFieldNumber = 4,
  };
  void set_align(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_flags(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_heap_name(const std::string& value) {
    AppendBytes(3, value.data(), value.size());
  }
  void set_heap_name(const char* data, size_t size) {
    AppendBytes(3, data, size);
  }
  void set_len(uint64_t value) {
    AppendVarInt(4, value);
  }
};

class IonCpSecureBufferEndFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IonCpSecureBufferEndFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IonCpSecureBufferEndFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IonCpSecureBufferEndFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_align() const { return at<1>().valid(); }
  uint64_t align() const { return at<1>().as_uint64(); }
  bool has_flags() const { return at<2>().valid(); }
  uint64_t flags() const { return at<2>().as_uint64(); }
  bool has_heap_name() const { return at<3>().valid(); }
  ::protozero::ConstChars heap_name() const { return at<3>().as_string(); }
  bool has_len() const { return at<4>().valid(); }
  uint64_t len() const { return at<4>().as_uint64(); }
};

class IonCpSecureBufferEndFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IonCpSecureBufferEndFtraceEvent_Decoder;
  enum : int32_t {
    kAlignFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kHeapNameFieldNumber = 3,
    kLenFieldNumber = 4,
  };
  void set_align(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_flags(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_heap_name(const std::string& value) {
    AppendBytes(3, value.data(), value.size());
  }
  void set_heap_name(const char* data, size_t size) {
    AppendBytes(3, data, size);
  }
  void set_len(uint64_t value) {
    AppendVarInt(4, value);
  }
};

class IonCpAllocRetryFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IonCpAllocRetryFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IonCpAllocRetryFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IonCpAllocRetryFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_tries() const { return at<1>().valid(); }
  int32_t tries() const { return at<1>().as_int32(); }
};

class IonCpAllocRetryFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IonCpAllocRetryFtraceEvent_Decoder;
  enum : int32_t {
    kTriesFieldNumber = 1,
  };
  void set_tries(int32_t value) {
    AppendVarInt(1, value);
  }
};

class IonAllocBufferStartFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IonAllocBufferStartFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IonAllocBufferStartFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IonAllocBufferStartFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_client_name() const { return at<1>().valid(); }
  ::protozero::ConstChars client_name() const { return at<1>().as_string(); }
  bool has_flags() const { return at<2>().valid(); }
  uint32_t flags() const { return at<2>().as_uint32(); }
  bool has_heap_name() const { return at<3>().valid(); }
  ::protozero::ConstChars heap_name() const { return at<3>().as_string(); }
  bool has_len() const { return at<4>().valid(); }
  uint64_t len() const { return at<4>().as_uint64(); }
  bool has_mask() const { return at<5>().valid(); }
  uint32_t mask() const { return at<5>().as_uint32(); }
};

class IonAllocBufferStartFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IonAllocBufferStartFtraceEvent_Decoder;
  enum : int32_t {
    kClientNameFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kHeapNameFieldNumber = 3,
    kLenFieldNumber = 4,
    kMaskFieldNumber = 5,
  };
  void set_client_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_client_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_heap_name(const std::string& value) {
    AppendBytes(3, value.data(), value.size());
  }
  void set_heap_name(const char* data, size_t size) {
    AppendBytes(3, data, size);
  }
  void set_len(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_mask(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class IonAllocBufferFallbackFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IonAllocBufferFallbackFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IonAllocBufferFallbackFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IonAllocBufferFallbackFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_client_name() const { return at<1>().valid(); }
  ::protozero::ConstChars client_name() const { return at<1>().as_string(); }
  bool has_error() const { return at<2>().valid(); }
  int64_t error() const { return at<2>().as_int64(); }
  bool has_flags() const { return at<3>().valid(); }
  uint32_t flags() const { return at<3>().as_uint32(); }
  bool has_heap_name() const { return at<4>().valid(); }
  ::protozero::ConstChars heap_name() const { return at<4>().as_string(); }
  bool has_len() const { return at<5>().valid(); }
  uint64_t len() const { return at<5>().as_uint64(); }
  bool has_mask() const { return at<6>().valid(); }
  uint32_t mask() const { return at<6>().as_uint32(); }
};

class IonAllocBufferFallbackFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IonAllocBufferFallbackFtraceEvent_Decoder;
  enum : int32_t {
    kClientNameFieldNumber = 1,
    kErrorFieldNumber = 2,
    kFlagsFieldNumber = 3,
    kHeapNameFieldNumber = 4,
    kLenFieldNumber = 5,
    kMaskFieldNumber = 6,
  };
  void set_client_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_client_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_error(int64_t value) {
    AppendVarInt(2, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_heap_name(const std::string& value) {
    AppendBytes(4, value.data(), value.size());
  }
  void set_heap_name(const char* data, size_t size) {
    AppendBytes(4, data, size);
  }
  void set_len(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_mask(uint32_t value) {
    AppendVarInt(6, value);
  }
};

class IonAllocBufferFailFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IonAllocBufferFailFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IonAllocBufferFailFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IonAllocBufferFailFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_client_name() const { return at<1>().valid(); }
  ::protozero::ConstChars client_name() const { return at<1>().as_string(); }
  bool has_error() const { return at<2>().valid(); }
  int64_t error() const { return at<2>().as_int64(); }
  bool has_flags() const { return at<3>().valid(); }
  uint32_t flags() const { return at<3>().as_uint32(); }
  bool has_heap_name() const { return at<4>().valid(); }
  ::protozero::ConstChars heap_name() const { return at<4>().as_string(); }
  bool has_len() const { return at<5>().valid(); }
  uint64_t len() const { return at<5>().as_uint64(); }
  bool has_mask() const { return at<6>().valid(); }
  uint32_t mask() const { return at<6>().as_uint32(); }
};

class IonAllocBufferFailFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IonAllocBufferFailFtraceEvent_Decoder;
  enum : int32_t {
    kClientNameFieldNumber = 1,
    kErrorFieldNumber = 2,
    kFlagsFieldNumber = 3,
    kHeapNameFieldNumber = 4,
    kLenFieldNumber = 5,
    kMaskFieldNumber = 6,
  };
  void set_client_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_client_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_error(int64_t value) {
    AppendVarInt(2, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_heap_name(const std::string& value) {
    AppendBytes(4, value.data(), value.size());
  }
  void set_heap_name(const char* data, size_t size) {
    AppendBytes(4, data, size);
  }
  void set_len(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_mask(uint32_t value) {
    AppendVarInt(6, value);
  }
};

class IonAllocBufferEndFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IonAllocBufferEndFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IonAllocBufferEndFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IonAllocBufferEndFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_client_name() const { return at<1>().valid(); }
  ::protozero::ConstChars client_name() const { return at<1>().as_string(); }
  bool has_flags() const { return at<2>().valid(); }
  uint32_t flags() const { return at<2>().as_uint32(); }
  bool has_heap_name() const { return at<3>().valid(); }
  ::protozero::ConstChars heap_name() const { return at<3>().as_string(); }
  bool has_len() const { return at<4>().valid(); }
  uint64_t len() const { return at<4>().as_uint64(); }
  bool has_mask() const { return at<5>().valid(); }
  uint32_t mask() const { return at<5>().as_uint32(); }
};

class IonAllocBufferEndFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IonAllocBufferEndFtraceEvent_Decoder;
  enum : int32_t {
    kClientNameFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kHeapNameFieldNumber = 3,
    kLenFieldNumber = 4,
    kMaskFieldNumber = 5,
  };
  void set_client_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_client_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_heap_name(const std::string& value) {
    AppendBytes(3, value.data(), value.size());
  }
  void set_heap_name(const char* data, size_t size) {
    AppendBytes(3, data, size);
  }
  void set_len(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_mask(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class IommuSecPtblMapRangeStartFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IommuSecPtblMapRangeStartFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IommuSecPtblMapRangeStartFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IommuSecPtblMapRangeStartFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_len() const { return at<1>().valid(); }
  uint64_t len() const { return at<1>().as_uint64(); }
  bool has_num() const { return at<2>().valid(); }
  int32_t num() const { return at<2>().as_int32(); }
  bool has_pa() const { return at<3>().valid(); }
  uint32_t pa() const { return at<3>().as_uint32(); }
  bool has_sec_id() const { return at<4>().valid(); }
  int32_t sec_id() const { return at<4>().as_int32(); }
  bool has_va() const { return at<5>().valid(); }
  uint64_t va() const { return at<5>().as_uint64(); }
};

class IommuSecPtblMapRangeStartFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IommuSecPtblMapRangeStartFtraceEvent_Decoder;
  enum : int32_t {
    kLenFieldNumber = 1,
    kNumFieldNumber = 2,
    kPaFieldNumber = 3,
    kSecIdFieldNumber = 4,
    kVaFieldNumber = 5,
  };
  void set_len(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_num(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_pa(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_sec_id(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_va(uint64_t value) {
    AppendVarInt(5, value);
  }
};

class IommuSecPtblMapRangeEndFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IommuSecPtblMapRangeEndFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IommuSecPtblMapRangeEndFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IommuSecPtblMapRangeEndFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_len() const { return at<1>().valid(); }
  uint64_t len() const { return at<1>().as_uint64(); }
  bool has_num() const { return at<2>().valid(); }
  int32_t num() const { return at<2>().as_int32(); }
  bool has_pa() const { return at<3>().valid(); }
  uint32_t pa() const { return at<3>().as_uint32(); }
  bool has_sec_id() const { return at<4>().valid(); }
  int32_t sec_id() const { return at<4>().as_int32(); }
  bool has_va() const { return at<5>().valid(); }
  uint64_t va() const { return at<5>().as_uint64(); }
};

class IommuSecPtblMapRangeEndFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IommuSecPtblMapRangeEndFtraceEvent_Decoder;
  enum : int32_t {
    kLenFieldNumber = 1,
    kNumFieldNumber = 2,
    kPaFieldNumber = 3,
    kSecIdFieldNumber = 4,
    kVaFieldNumber = 5,
  };
  void set_len(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_num(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_pa(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_sec_id(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_va(uint64_t value) {
    AppendVarInt(5, value);
  }
};

class IommuMapRangeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IommuMapRangeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IommuMapRangeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IommuMapRangeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_chunk_size() const { return at<1>().valid(); }
  uint64_t chunk_size() const { return at<1>().as_uint64(); }
  bool has_len() const { return at<2>().valid(); }
  uint64_t len() const { return at<2>().as_uint64(); }
  bool has_pa() const { return at<3>().valid(); }
  uint64_t pa() const { return at<3>().as_uint64(); }
  bool has_va() const { return at<4>().valid(); }
  uint64_t va() const { return at<4>().as_uint64(); }
};

class IommuMapRangeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IommuMapRangeFtraceEvent_Decoder;
  enum : int32_t {
    kChunkSizeFieldNumber = 1,
    kLenFieldNumber = 2,
    kPaFieldNumber = 3,
    kVaFieldNumber = 4,
  };
  void set_chunk_size(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_len(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pa(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_va(uint64_t value) {
    AppendVarInt(4, value);
  }
};

class DmaAllocContiguousRetryFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  DmaAllocContiguousRetryFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit DmaAllocContiguousRetryFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit DmaAllocContiguousRetryFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_tries() const { return at<1>().valid(); }
  int32_t tries() const { return at<1>().as_int32(); }
};

class DmaAllocContiguousRetryFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = DmaAllocContiguousRetryFtraceEvent_Decoder;
  enum : int32_t {
    kTriesFieldNumber = 1,
  };
  void set_tries(int32_t value) {
    AppendVarInt(1, value);
  }
};

class AllocPagesSysStartFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  AllocPagesSysStartFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit AllocPagesSysStartFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit AllocPagesSysStartFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_gfp_flags() const { return at<1>().valid(); }
  uint32_t gfp_flags() const { return at<1>().as_uint32(); }
  bool has_order() const { return at<2>().valid(); }
  uint32_t order() const { return at<2>().as_uint32(); }
};

class AllocPagesSysStartFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = AllocPagesSysStartFtraceEvent_Decoder;
  enum : int32_t {
    kGfpFlagsFieldNumber = 1,
    kOrderFieldNumber = 2,
  };
  void set_gfp_flags(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_order(uint32_t value) {
    AppendVarInt(2, value);
  }
};

class AllocPagesSysFailFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  AllocPagesSysFailFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit AllocPagesSysFailFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit AllocPagesSysFailFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_gfp_flags() const { return at<1>().valid(); }
  uint32_t gfp_flags() const { return at<1>().as_uint32(); }
  bool has_order() const { return at<2>().valid(); }
  uint32_t order() const { return at<2>().as_uint32(); }
};

class AllocPagesSysFailFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = AllocPagesSysFailFtraceEvent_Decoder;
  enum : int32_t {
    kGfpFlagsFieldNumber = 1,
    kOrderFieldNumber = 2,
  };
  void set_gfp_flags(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_order(uint32_t value) {
    AppendVarInt(2, value);
  }
};

class AllocPagesSysEndFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  AllocPagesSysEndFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit AllocPagesSysEndFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit AllocPagesSysEndFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_gfp_flags() const { return at<1>().valid(); }
  uint32_t gfp_flags() const { return at<1>().as_uint32(); }
  bool has_order() const { return at<2>().valid(); }
  uint32_t order() const { return at<2>().as_uint32(); }
};

class AllocPagesSysEndFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = AllocPagesSysEndFtraceEvent_Decoder;
  enum : int32_t {
    kGfpFlagsFieldNumber = 1,
    kOrderFieldNumber = 2,
  };
  void set_gfp_flags(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_order(uint32_t value) {
    AppendVarInt(2, value);
  }
};

class AllocPagesIommuStartFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  AllocPagesIommuStartFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit AllocPagesIommuStartFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit AllocPagesIommuStartFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_gfp_flags() const { return at<1>().valid(); }
  uint32_t gfp_flags() const { return at<1>().as_uint32(); }
  bool has_order() const { return at<2>().valid(); }
  uint32_t order() const { return at<2>().as_uint32(); }
};

class AllocPagesIommuStartFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = AllocPagesIommuStartFtraceEvent_Decoder;
  enum : int32_t {
    kGfpFlagsFieldNumber = 1,
    kOrderFieldNumber = 2,
  };
  void set_gfp_flags(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_order(uint32_t value) {
    AppendVarInt(2, value);
  }
};

class AllocPagesIommuFailFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  AllocPagesIommuFailFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit AllocPagesIommuFailFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit AllocPagesIommuFailFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_gfp_flags() const { return at<1>().valid(); }
  uint32_t gfp_flags() const { return at<1>().as_uint32(); }
  bool has_order() const { return at<2>().valid(); }
  uint32_t order() const { return at<2>().as_uint32(); }
};

class AllocPagesIommuFailFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = AllocPagesIommuFailFtraceEvent_Decoder;
  enum : int32_t {
    kGfpFlagsFieldNumber = 1,
    kOrderFieldNumber = 2,
  };
  void set_gfp_flags(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_order(uint32_t value) {
    AppendVarInt(2, value);
  }
};

class AllocPagesIommuEndFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  AllocPagesIommuEndFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit AllocPagesIommuEndFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit AllocPagesIommuEndFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_gfp_flags() const { return at<1>().valid(); }
  uint32_t gfp_flags() const { return at<1>().as_uint32(); }
  bool has_order() const { return at<2>().valid(); }
  uint32_t order() const { return at<2>().as_uint32(); }
};

class AllocPagesIommuEndFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = AllocPagesIommuEndFtraceEvent_Decoder;
  enum : int32_t {
    kGfpFlagsFieldNumber = 1,
    kOrderFieldNumber = 2,
  };
  void set_gfp_flags(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_order(uint32_t value) {
    AppendVarInt(2, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/ftrace/lowmemorykiller.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_LOWMEMORYKILLER_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_LOWMEMORYKILLER_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class LowmemoryKillFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  LowmemoryKillFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit LowmemoryKillFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit LowmemoryKillFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_comm() const { return at<1>().valid(); }
  ::protozero::ConstChars comm() const { return at<1>().as_string(); }
  bool has_pid() const { return at<2>().valid(); }
  int32_t pid() const { return at<2>().as_int32(); }
  bool has_pagecache_size() const { return at<3>().valid(); }
  int64_t pagecache_size() const { return at<3>().as_int64(); }
  bool has_pagecache_limit() const { return at<4>().valid(); }
  int64_t pagecache_limit() const { return at<4>().as_int64(); }
  bool has_free() const { return at<5>().valid(); }
  int64_t free() const { return at<5>().as_int64(); }
};

class LowmemoryKillFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = LowmemoryKillFtraceEvent_Decoder;
  enum : int32_t {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
    kPagecacheSizeFieldNumber = 3,
    kPagecacheLimitFieldNumber = 4,
    kFreeFieldNumber = 5,
  };
  void set_comm(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_comm(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_pid(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_pagecache_size(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_pagecache_limit(int64_t value) {
    AppendVarInt(4, value);
  }
  void set_free(int64_t value) {
    AppendVarInt(5, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/ftrace/mdss.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_MDSS_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_MDSS_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class RotatorBwAoAsContextFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  RotatorBwAoAsContextFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit RotatorBwAoAsContextFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit RotatorBwAoAsContextFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_state() const { return at<1>().valid(); }
  uint32_t state() const { return at<1>().as_uint32(); }
};

class RotatorBwAoAsContextFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = RotatorBwAoAsContextFtraceEvent_Decoder;
  enum : int32_t {
    kStateFieldNumber = 1,
  };
  void set_state(uint32_t value) {
    AppendVarInt(1, value);
  }
};

class MdpPerfUpdateBusFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpPerfUpdateBusFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpPerfUpdateBusFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpPerfUpdateBusFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_client() const { return at<1>().valid(); }
  int32_t client() const { return at<1>().as_int32(); }
  bool has_ab_quota() const { return at<2>().valid(); }
  uint64_t ab_quota() const { return at<2>().as_uint64(); }
  bool has_ib_quota() const { return at<3>().valid(); }
  uint64_t ib_quota() const { return at<3>().as_uint64(); }
};

class MdpPerfUpdateBusFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpPerfUpdateBusFtraceEvent_Decoder;
  enum : int32_t {
    kClientFieldNumber = 1,
    kAbQuotaFieldNumber = 2,
    kIbQuotaFieldNumber = 3,
  };
  void set_client(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_ab_quota(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_ib_quota(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class MdpPerfPrefillCalcFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/10, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpPerfPrefillCalcFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpPerfPrefillCalcFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpPerfPrefillCalcFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_pnum() const { return at<1>().valid(); }
  uint32_t pnum() const { return at<1>().as_uint32(); }
  bool has_latency_buf() const { return at<2>().valid(); }
  uint32_t latency_buf() const { return at<2>().as_uint32(); }
  bool has_ot() const { return at<3>().valid(); }
  uint32_t ot() const { return at<3>().as_uint32(); }
  bool has_y_buf() const { return at<4>().valid(); }
  uint32_t y_buf() const { return at<4>().as_uint32(); }
  bool has_y_scaler() const { return at<5>().valid(); }
  uint32_t y_scaler() const { return at<5>().as_uint32(); }
  bool has_pp_lines() const { return at<6>().valid(); }
  uint32_t pp_lines() const { return at<6>().as_uint32(); }
  bool has_pp_bytes() const { return at<7>().valid(); }
  uint32_t pp_bytes() const { return at<7>().as_uint32(); }
  bool has_post_sc() const { return at<8>().valid(); }
  uint32_t post_sc() const { return at<8>().as_uint32(); }
  bool has_fbc_bytes() const { return at<9>().valid(); }
  uint32_t fbc_bytes() const { return at<9>().as_uint32(); }
  bool has_prefill_bytes() const { return at<10>().valid(); }
  uint32_t prefill_bytes() const { return at<10>().as_uint32(); }
};

class MdpPerfPrefillCalcFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpPerfPrefillCalcFtraceEvent_Decoder;
  enum : int32_t {
    kPnumFieldNumber = 1,
    kLatencyBufFieldNumber = 2,
    kOtFieldNumber = 3,
    kYBufFieldNumber = 4,
    kYScalerFieldNumber = 5,
    kPpLinesFieldNumber = 6,
    kPpBytesFieldNumber = 7,
    kPostScFieldNumber = 8,
    kFbcBytesFieldNumber = 9,
    kPrefillBytesFieldNumber = 10,
  };
  void set_pnum(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_latency_buf(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_ot(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_y_buf(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_y_scaler(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_pp_lines(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_pp_bytes(uint32_t value) {
    AppendVarInt(7, value);
  }
  void set_post_sc(uint32_t value) {
    AppendVarInt(8, value);
  }
  void set_fbc_bytes(uint32_t value) {
    AppendVarInt(9, value);
  }
  void set_prefill_bytes(uint32_t value) {
    AppendVarInt(10, value);
  }
};

class MdpCmdWaitPingpongFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpCmdWaitPingpongFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpCmdWaitPingpongFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpCmdWaitPingpongFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_ctl_num() const { return at<1>().valid(); }
  uint32_t ctl_num() const { return at<1>().as_uint32(); }
  bool has_kickoff_cnt() const { return at<2>().valid(); }
  int32_t kickoff_cnt() const { return at<2>().as_int32(); }
};

class MdpCmdWaitPingpongFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpCmdWaitPingpongFtraceEvent_Decoder;
  enum : int32_t {
    kCtlNumFieldNumber = 1,
    kKickoffCntFieldNumber = 2,
  };
  void set_ctl_num(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_kickoff_cnt(int32_t value) {
    AppendVarInt(2, value);
  }
};

class MdpVideoUnderrunDoneFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpVideoUnderrunDoneFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpVideoUnderrunDoneFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpVideoUnderrunDoneFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_ctl_num() const { return at<1>().valid(); }
  uint32_t ctl_num() const { return at<1>().as_uint32(); }
  bool has_underrun_cnt() const { return at<2>().valid(); }
  uint32_t underrun_cnt() const { return at<2>().as_uint32(); }
};

class MdpVideoUnderrunDoneFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpVideoUnderrunDoneFtraceEvent_Decoder;
  enum : int32_t {
    kCtlNumFieldNumber = 1,
    kUnderrunCntFieldNumber = 2,
  };
  void set_ctl_num(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_underrun_cnt(uint32_t value) {
    AppendVarInt(2, value);
  }
};

class MdpPerfSetWmLevelsFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpPerfSetWmLevelsFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpPerfSetWmLevelsFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpPerfSetWmLevelsFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_pnum() const { return at<1>().valid(); }
  uint32_t pnum() const { return at<1>().as_uint32(); }
  bool has_use_space() const { return at<2>().valid(); }
  uint32_t use_space() const { return at<2>().as_uint32(); }
  bool has_priority_bytes() const { return at<3>().valid(); }
  uint32_t priority_bytes() const { return at<3>().as_uint32(); }
  bool has_wm0() const { return at<4>().valid(); }
  uint32_t wm0() const { return at<4>().as_uint32(); }
  bool has_wm1() const { return at<5>().valid(); }
  uint32_t wm1() const { return at<5>().as_uint32(); }
  bool has_wm2() const { return at<6>().valid(); }
  uint32_t wm2() const { return at<6>().as_uint32(); }
  bool has_mb_cnt() const { return at<7>().valid(); }
  uint32_t mb_cnt() const { return at<7>().as_uint32(); }
  bool has_mb_size() const { return at<8>().valid(); }
  uint32_t mb_size() const { return at<8>().as_uint32(); }
};

class MdpPerfSetWmLevelsFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpPerfSetWmLevelsFtraceEvent_Decoder;
  enum : int32_t {
    kPnumFieldNumber = 1,
    kUseSpaceFieldNumber = 2,
    kPriorityBytesFieldNumber = 3,
    kWm0FieldNumber = 4,
    kWm1FieldNumber = 5,
    kWm2FieldNumber = 6,
    kMbCntFieldNumber = 7,
    kMbSizeFieldNumber = 8,
  };
  void set_pnum(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_use_space(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_priority_bytes(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_wm0(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_wm1(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_wm2(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_mb_cnt(uint32_t value) {
    AppendVarInt(7, value);
  }
  void set_mb_size(uint32_t value) {
    AppendVarInt(8, value);
  }
};

class MdpMixerUpdateFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpMixerUpdateFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpMixerUpdateFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpMixerUpdateFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_mixer_num() const { return at<1>().valid(); }
  uint32_t mixer_num() const { return at<1>().as_uint32(); }
};

class MdpMixerUpdateFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpMixerUpdateFtraceEvent_Decoder;
  enum : int32_t {
    kMixerNumFieldNumber = 1,
  };
  void set_mixer_num(uint32_t value) {
    AppendVarInt(1, value);
  }
};

class MdpCmdReleaseBwFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpCmdReleaseBwFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpCmdReleaseBwFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpCmdReleaseBwFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_ctl_num() const { return at<1>().valid(); }
  uint32_t ctl_num() const { return at<1>().as_uint32(); }
};

class MdpCmdReleaseBwFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpCmdReleaseBwFtraceEvent_Decoder;
  enum : int32_t {
    kCtlNumFieldNumber = 1,
  };
  void set_ctl_num(uint32_t value) {
    AppendVarInt(1, value);
  }
};

class MdpTraceCounterFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpTraceCounterFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpTraceCounterFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpTraceCounterFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_pid() const { return at<1>().valid(); }
  int32_t pid() const { return at<1>().as_int32(); }
  bool has_counter_name() const { return at<2>().valid(); }
  ::protozero::ConstChars counter_name() const { return at<2>().as_string(); }
  bool has_value() const { return at<3>().valid(); }
  int32_t value() const { return at<3>().as_int32(); }
};

class MdpTraceCounterFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpTraceCounterFtraceEvent_Decoder;
  enum : int32_t {
    kPidFieldNumber = 1,
    kCounterNameFieldNumber = 2,
    kValueFieldNumber = 3,
  };
  void set_pid(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_counter_name(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void set_counter_name(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
  void set_value(int32_t value) {
    AppendVarInt(3, value);
  }
};

class MdpPerfSetQosLutsFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/7, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpPerfSetQosLutsFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpPerfSetQosLutsFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpPerfSetQosLutsFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_pnum() const { return at<1>().valid(); }
  uint32_t pnum() const { return at<1>().as_uint32(); }
  bool has_fmt() const { return at<2>().valid(); }
  uint32_t fmt() const { return at<2>().as_uint32(); }
  bool has_intf() const { return at<3>().valid(); }
  uint32_t intf() const { return at<3>().as_uint32(); }
  bool has_rot() const { return at<4>().valid(); }
  uint32_t rot() const { return at<4>().as_uint32(); }
  bool has_fl() const { return at<5>().valid(); }
  uint32_t fl() const { return at<5>().as_uint32(); }
  bool has_lut() const { return at<6>().valid(); }
  uint32_t lut() const { return at<6>().as_uint32(); }
  bool has_linear() const { return at<7>().valid(); }
  uint32_t linear() const { return at<7>().as_uint32(); }
};

class MdpPerfSetQosLutsFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpPerfSetQosLutsFtraceEvent_Decoder;
  enum : int32_t {
    kPnumFieldNumber = 1,
    kFmtFieldNumber = 2,
    kIntfFieldNumber = 3,
    kRotFieldNumber = 4,
    kFlFieldNumber = 5,
    kLutFieldNumber = 6,
    kLinearFieldNumber = 7,
  };
  void set_pnum(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_fmt(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_intf(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_rot(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_fl(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_lut(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_linear(uint32_t value) {
    AppendVarInt(7, value);
  }
};

class MdpMisrCrcFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpMisrCrcFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpMisrCrcFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpMisrCrcFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_block_id() const { return at<1>().valid(); }
  uint32_t block_id() const { return at<1>().as_uint32(); }
  bool has_vsync_cnt() const { return at<2>().valid(); }
  uint32_t vsync_cnt() const { return at<2>().as_uint32(); }
  bool has_crc() const { return at<3>().valid(); }
  uint32_t crc() const { return at<3>().as_uint32(); }
};

class MdpMisrCrcFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpMisrCrcFtraceEvent_Decoder;
  enum : int32_t {
    kBlockIdFieldNumber = 1,
    kVsyncCntFieldNumber = 2,
    kCrcFieldNumber = 3,
  };
  void set_block_id(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_vsync_cnt(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_crc(uint32_t value) {
    AppendVarInt(3, value);
  }
};

class MdpCmdReadptrDoneFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpCmdReadptrDoneFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpCmdReadptrDoneFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpCmdReadptrDoneFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_ctl_num() const { return at<1>().valid(); }
  uint32_t ctl_num() const { return at<1>().as_uint32(); }
  bool has_koff_cnt() const { return at<2>().valid(); }
  int32_t koff_cnt() const { return at<2>().as_int32(); }
};

class MdpCmdReadptrDoneFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpCmdReadptrDoneFtraceEvent_Decoder;
  enum : int32_t {
    kCtlNumFieldNumber = 1,
    kKoffCntFieldNumber = 2,
  };
  void set_ctl_num(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_koff_cnt(int32_t value) {
    AppendVarInt(2, value);
  }
};

class MdpSsppSetFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/16, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpSsppSetFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpSsppSetFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpSsppSetFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_num() const { return at<1>().valid(); }
  uint32_t num() const { return at<1>().as_uint32(); }
  bool has_play_cnt() const { return at<2>().valid(); }
  uint32_t play_cnt() const { return at<2>().as_uint32(); }
  bool has_mixer() const { return at<3>().valid(); }
  uint32_t mixer() const { return at<3>().as_uint32(); }
  bool has_stage() const { return at<4>().valid(); }
  uint32_t stage() const { return at<4>().as_uint32(); }
  bool has_flags() const { return at<5>().valid(); }
  uint32_t flags() const { return at<5>().as_uint32(); }
  bool has_format() const { return at<6>().valid(); }
  uint32_t format() const { return at<6>().as_uint32(); }
  bool has_img_w() const { return at<7>().valid(); }
  uint32_t img_w() const { return at<7>().as_uint32(); }
  bool has_img_h() const { return at<8>().valid(); }
  uint32_t img_h() const { return at<8>().as_uint32(); }
  bool has_src_x() const { return at<9>().valid(); }
  uint32_t src_x() const { return at<9>().as_uint32(); }
  bool has_src_y() const { return at<10>().valid(); }
  uint32_t src_y() const { return at<10>().as_uint32(); }
  bool has_src_w() const { return at<11>().valid(); }
  uint32_t src_w() const { return at<11>().as_uint32(); }
  bool has_src_h() const { return at<12>().valid(); }
  uint32_t src_h() const { return at<12>().as_uint32(); }
  bool has_dst_x() const { return at<13>().valid(); }
  uint32_t dst_x() const { return at<13>().as_uint32(); }
  bool has_dst_y() const { return at<14>().valid(); }
  uint32_t dst_y() const { return at<14>().as_uint32(); }
  bool has_dst_w() const { return at<15>().valid(); }
  uint32_t dst_w() const { return at<15>().as_uint32(); }
  bool has_dst_h() const { return at<16>().valid(); }
  uint32_t dst_h() const { return at<16>().as_uint32(); }
};

class MdpSsppSetFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpSsppSetFtraceEvent_Decoder;
  enum : int32_t {
    kNumFieldNumber = 1,
    kPlayCntFieldNumber = 2,
    kMixerFieldNumber = 3,
    kStageFieldNumber = 4,
    kFlagsFieldNumber = 5,
    kFormatFieldNumber = 6,
    kImgWFieldNumber = 7,
    kImgHFieldNumber = 8,
    kSrcXFieldNumber = 9,
    kSrcYFieldNumber = 10,
    kSrcWFieldNumber = 11,
    kSrcHFieldNumber = 12,
    kDstXFieldNumber = 13,
    kDstYFieldNumber = 14,
    kDstWFieldNumber = 15,
    kDstHFieldNumber = 16,
  };
  void set_num(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_play_cnt(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_mixer(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_stage(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_format(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_img_w(uint32_t value) {
    AppendVarInt(7, value);
  }
  void set_img_h(uint32_t value) {
    AppendVarInt(8, value);
  }
  void set_src_x(uint32_t value) {
    AppendVarInt(9, value);
  }
  void set_src_y(uint32_t value) {
    AppendVarInt(10, value);
  }
  void set_src_w(uint32_t value) {
    AppendVarInt(11, value);
  }
  void set_src_h(uint32_t value) {
    AppendVarInt(12, value);
  }
  void set_dst_x(uint32_t value) {
    AppendVarInt(13, value);
  }
  void set_dst_y(uint32_t value) {
    AppendVarInt(14, value);
  }
  void set_dst_w(uint32_t value) {
    AppendVarInt(15, value);
  }
  void set_dst_h(uint32_t value) {
    AppendVarInt(16, value);
  }
};

class MdpPerfSetPanicLutsFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpPerfSetPanicLutsFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpPerfSetPanicLutsFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpPerfSetPanicLutsFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_pnum() const { return at<1>().valid(); }
  uint32_t pnum() const { return at<1>().as_uint32(); }
  bool has_fmt() const { return at<2>().valid(); }
  uint32_t fmt() const { return at<2>().as_uint32(); }
  bool has_mode() const { return at<3>().valid(); }
  uint32_t mode() const { return at<3>().as_uint32(); }
  bool has_panic_lut() const { return at<4>().valid(); }
  uint32_t panic_lut() const { return at<4>().as_uint32(); }
  bool has_robust_lut() const { return at<5>().valid(); }
  uint32_t robust_lut() const { return at<5>().as_uint32(); }
};

class MdpPerfSetPanicLutsFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpPerfSetPanicLutsFtraceEvent_Decoder;
  enum : int32_t {
    kPnumFieldNumber = 1,
    kFmtFieldNumber = 2,
    kModeFieldNumber = 3,
    kPanicLutFieldNumber = 4,
    kRobustLutFieldNumber = 5,
  };
  void set_pnum(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_fmt(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_mode(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_panic_lut(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_robust_lut(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class MdpCompareBwFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpCompareBwFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpCompareBwFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpCompareBwFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_new_ab() const { return at<1>().valid(); }
  uint64_t new_ab() const { return at<1>().as_uint64(); }
  bool has_new_ib() const { return at<2>().valid(); }
  uint64_t new_ib() const { return at<2>().as_uint64(); }
  bool has_new_wb() const { return at<3>().valid(); }
  uint64_t new_wb() const { return at<3>().as_uint64(); }
  bool has_old_ab() const { return at<4>().valid(); }
  uint64_t old_ab() const { return at<4>().as_uint64(); }
  bool has_old_ib() const { return at<5>().valid(); }
  uint64_t old_ib() const { return at<5>().as_uint64(); }
  bool has_old_wb() const { return at<6>().valid(); }
  uint64_t old_wb() const { return at<6>().as_uint64(); }
  bool has_params_changed() const { return at<7>().valid(); }
  uint32_t params_changed() const { return at<7>().as_uint32(); }
  bool has_update_bw() const { return at<8>().valid(); }
  uint32_t update_bw() const { return at<8>().as_uint32(); }
};

class MdpCompareBwFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpCompareBwFtraceEvent_Decoder;
  enum : int32_t {
    kNewAbFieldNumber = 1,
    kNewIbFieldNumber = 2,
    kNewWbFieldNumber = 3,
    kOldAbFieldNumber = 4,
    kOldIbFieldNumber = 5,
    kOldWbFieldNumber = 6,
    kParamsChangedFieldNumber = 7,
    kUpdateBwFieldNumber = 8,
  };
  void set_new_ab(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_new_ib(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_new_wb(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_old_ab(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_old_ib(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_old_wb(uint64_t value) {
    AppendVarInt(6, value);
  }
  void set_params_changed(uint32_t value) {
    AppendVarInt(7, value);
  }
  void set_update_bw(uint32_t value) {
    AppendVarInt(8, value);
  }
};

class MdpCmdPingpongDoneFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpCmdPingpongDoneFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpCmdPingpongDoneFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpCmdPingpongDoneFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_ctl_num() const { return at<1>().valid(); }
  uint32_t ctl_num() const { return at<1>().as_uint32(); }
  bool has_intf_num() const { return at<2>().valid(); }
  uint32_t intf_num() const { return at<2>().as_uint32(); }
  bool has_pp_num() const { return at<3>().valid(); }
  uint32_t pp_num() const { return at<3>().as_uint32(); }
  bool has_koff_cnt() const { return at<4>().valid(); }
  int32_t koff_cnt() const { return at<4>().as_int32(); }
};

class MdpCmdPingpongDoneFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpCmdPingpongDoneFtraceEvent_Decoder;
  enum : int32_t {
    kCtlNumFieldNumber = 1,
    kIntfNumFieldNumber = 2,
    kPpNumFieldNumber = 3,
    kKoffCntFieldNumber = 4,
  };
  void set_ctl_num(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_intf_num(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_pp_num(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_koff_cnt(int32_t value) {
    AppendVarInt(4, value);
  }
};

class TracingMarkWriteFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TracingMarkWriteFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TracingMarkWriteFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TracingMarkWriteFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_pid() const { return at<1>().valid(); }
  int32_t pid() const { return at<1>().as_int32(); }
  bool has_trace_name() const { return at<2>().valid(); }
  ::protozero::ConstChars trace_name() const { return at<2>().as_string(); }
  bool has_trace_begin() const { return at<3>().valid(); }
  uint32_t trace_begin() const { return at<3>().as_uint32(); }
};

class TracingMarkWriteFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = TracingMarkWriteFtraceEvent_Decoder;
  enum : int32_t {
    kPidFieldNumber = 1,
    kTraceNameFieldNumber = 2,
    kTraceBeginFieldNumber = 3,
  };
  void set_pid(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_trace_name(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void set_trace_name(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
  void set_trace_begin(uint32_t value) {
    AppendVarInt(3, value);
  }
};

class MdpSsppChangeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/16, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpSsppChangeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpSsppChangeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpSsppChangeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_num() const { return at<1>().valid(); }
  uint32_t num() const { return at<1>().as_uint32(); }
  bool has_play_cnt() const { return at<2>().valid(); }
  uint32_t play_cnt() const { return at<2>().as_uint32(); }
  bool has_mixer() const { return at<3>().valid(); }
  uint32_t mixer() const { return at<3>().as_uint32(); }
  bool has_stage() const { return at<4>().valid(); }
  uint32_t stage() const { return at<4>().as_uint32(); }
  bool has_flags() const { return at<5>().valid(); }
  uint32_t flags() const { return at<5>().as_uint32(); }
  bool has_format() const { return at<6>().valid(); }
  uint32_t format() const { return at<6>().as_uint32(); }
  bool has_img_w() const { return at<7>().valid(); }
  uint32_t img_w() const { return at<7>().as_uint32(); }
  bool has_img_h() const { return at<8>().valid(); }
  uint32_t img_h() const { return at<8>().as_uint32(); }
  bool has_src_x() const { return at<9>().valid(); }
  uint32_t src_x() const { return at<9>().as_uint32(); }
  bool has_src_y() const { return at<10>().valid(); }
  uint32_t src_y() const { return at<10>().as_uint32(); }
  bool has_src_w() const { return at<11>().valid(); }
  uint32_t src_w() const { return at<11>().as_uint32(); }
  bool has_src_h() const { return at<12>().valid(); }
  uint32_t src_h() const { return at<12>().as_uint32(); }
  bool has_dst_x() const { return at<13>().valid(); }
  uint32_t dst_x() const { return at<13>().as_uint32(); }
  bool has_dst_y() const { return at<14>().valid(); }
  uint32_t dst_y() const { return at<14>().as_uint32(); }
  bool has_dst_w() const { return at<15>().valid(); }
  uint32_t dst_w() const { return at<15>().as_uint32(); }
  bool has_dst_h() const { return at<16>().valid(); }
  uint32_t dst_h() const { return at<16>().as_uint32(); }
};

class MdpSsppChangeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpSsppChangeFtraceEvent_Decoder;
  enum : int32_t {
    kNumFieldNumber = 1,
    kPlayCntFieldNumber = 2,
    kMixerFieldNumber = 3,
    kStageFieldNumber = 4,
    kFlagsFieldNumber = 5,
    kFormatFieldNumber = 6,
    kImgWFieldNumber = 7,
    kImgHFieldNumber = 8,
    kSrcXFieldNumber = 9,
    kSrcYFieldNumber = 10,
    kSrcWFieldNumber = 11,
    kSrcHFieldNumber = 12,
    kDstXFieldNumber = 13,
    kDstYFieldNumber = 14,
    kDstWFieldNumber = 15,
    kDstHFieldNumber = 16,
  };
  void set_num(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_play_cnt(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_mixer(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_stage(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_format(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_img_w(uint32_t value) {
    AppendVarInt(7, value);
  }
  void set_img_h(uint32_t value) {
    AppendVarInt(8, value);
  }
  void set_src_x(uint32_t value) {
    AppendVarInt(9, value);
  }
  void set_src_y(uint32_t value) {
    AppendVarInt(10, value);
  }
  void set_src_w(uint32_t value) {
    AppendVarInt(11, value);
  }
  void set_src_h(uint32_t value) {
    AppendVarInt(12, value);
  }
  void set_dst_x(uint32_t value) {
    AppendVarInt(13, value);
  }
  void set_dst_y(uint32_t value) {
    AppendVarInt(14, value);
  }
  void set_dst_w(uint32_t value) {
    AppendVarInt(15, value);
  }
  void set_dst_h(uint32_t value) {
    AppendVarInt(16, value);
  }
};

class MdpPerfSetOtFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpPerfSetOtFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpPerfSetOtFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpPerfSetOtFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_pnum() const { return at<1>().valid(); }
  uint32_t pnum() const { return at<1>().as_uint32(); }
  bool has_xin_id() const { return at<2>().valid(); }
  uint32_t xin_id() const { return at<2>().as_uint32(); }
  bool has_rd_lim() const { return at<3>().valid(); }
  uint32_t rd_lim() const { return at<3>().as_uint32(); }
  bool has_is_vbif_rt() const { return at<4>().valid(); }
  uint32_t is_vbif_rt() const { return at<4>().as_uint32(); }
};

class MdpPerfSetOtFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpPerfSetOtFtraceEvent_Decoder;
  enum : int32_t {
    kPnumFieldNumber = 1,
    kXinIdFieldNumber = 2,
    kRdLimFieldNumber = 3,
    kIsVbifRtFieldNumber = 4,
  };
  void set_pnum(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_xin_id(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_rd_lim(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_is_vbif_rt(uint32_t value) {
    AppendVarInt(4, value);
  }
};

class MdpCommitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpCommitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpCommitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpCommitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_num() const { return at<1>().valid(); }
  uint32_t num() const { return at<1>().as_uint32(); }
  bool has_play_cnt() const { return at<2>().valid(); }
  uint32_t play_cnt() const { return at<2>().as_uint32(); }
  bool has_clk_rate() const { return at<3>().valid(); }
  uint32_t clk_rate() const { return at<3>().as_uint32(); }
  bool has_bandwidth() const { return at<4>().valid(); }
  uint64_t bandwidth() const { return at<4>().as_uint64(); }
};

class MdpCommitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpCommitFtraceEvent_Decoder;
  enum : int32_t {
    kNumFieldNumber = 1,
    kPlayCntFieldNumber = 2,
    kClkRateFieldNumber = 3,
    kBandwidthFieldNumber = 4,
  };
  void set_num(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_play_cnt(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_clk_rate(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_bandwidth(uint64_t value) {
    AppendVarInt(4, value);
  }
};

class MdpCmdKickoffFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpCmdKickoffFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpCmdKickoffFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpCmdKickoffFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_ctl_num() const { return at<1>().valid(); }
  uint32_t ctl_num() const { return at<1>().as_uint32(); }
  bool has_kickoff_cnt() const { return at<2>().valid(); }
  int32_t kickoff_cnt() const { return at<2>().as_int32(); }
};

class MdpCmdKickoffFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpCmdKickoffFtraceEvent_Decoder;
  enum : int32_t {
    kCtlNumFieldNumber = 1,
    kKickoffCntFieldNumber = 2,
  };
  void set_ctl_num(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_kickoff_cnt(int32_t value) {
    AppendVarInt(2, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/ftrace/mm_event.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_MM_EVENT_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_MM_EVENT_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class MmEventRecordFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmEventRecordFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmEventRecordFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmEventRecordFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_avg_lat() const { return at<1>().valid(); }
  uint32_t avg_lat() const { return at<1>().as_uint32(); }
  bool has_count() const { return at<2>().valid(); }
  uint32_t count() const { return at<2>().as_uint32(); }
  bool has_max_lat() const { return at<3>().valid(); }
  uint32_t max_lat() const { return at<3>().as_uint32(); }
  bool has_type() const { return at<4>().valid(); }
  uint32_t type() const { return at<4>().as_uint32(); }
};

class MmEventRecordFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmEventRecordFtraceEvent_Decoder;
  enum : int32_t {
    kAvgLatFieldNumber = 1,
    kCountFieldNumber = 2,
    kMaxLatFieldNumber = 3,
    kTypeFieldNumber = 4,
  };
  void set_avg_lat(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_count(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_max_lat(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_type(uint32_t value) {
    AppendVarInt(4, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/ftrace/oom.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_OOM_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_OOM_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class OomScoreAdjUpdateFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  OomScoreAdjUpdateFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit OomScoreAdjUpdateFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit OomScoreAdjUpdateFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_comm() const { return at<1>().valid(); }
  ::protozero::ConstChars comm() const { return at<1>().as_string(); }
  bool has_oom_score_adj() const { return at<2>().valid(); }
  int32_t oom_score_adj() const { return at<2>().as_int32(); }
  bool has_pid() const { return at<3>().valid(); }
  int32_t pid() const { return at<3>().as_int32(); }
};

class OomScoreAdjUpdateFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = OomScoreAdjUpdateFtraceEvent_Decoder;
  enum : int32_t {
    kCommFieldNumber = 1,
    kOomScoreAdjFieldNumber = 2,
    kPidFieldNumber = 3,
  };
  void set_comm(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_comm(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_oom_score_adj(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_pid(int32_t value) {
    AppendVarInt(3, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/ftrace/power.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_POWER_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_POWER_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class GpuFrequencyFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  GpuFrequencyFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit GpuFrequencyFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit GpuFrequencyFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_gpu_id() const { return at<1>().valid(); }
  uint32_t gpu_id() const { return at<1>().as_uint32(); }
  bool has_state() const { return at<2>().valid(); }
  uint32_t state() const { return at<2>().as_uint32(); }
};

class GpuFrequencyFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = GpuFrequencyFtraceEvent_Decoder;
  enum : int32_t {
    kGpuIdFieldNumber = 1,
    kStateFieldNumber = 2,
  };
  void set_gpu_id(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_state(uint32_t value) {
    AppendVarInt(2, value);
  }
};

class SuspendResumeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SuspendResumeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SuspendResumeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SuspendResumeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_action() const { return at<1>().valid(); }
  ::protozero::ConstChars action() const { return at<1>().as_string(); }
  bool has_val() const { return at<2>().valid(); }
  int32_t val() const { return at<2>().as_int32(); }
  bool has_start() const { return at<3>().valid(); }
  uint32_t start() const { return at<3>().as_uint32(); }
};

class SuspendResumeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SuspendResumeFtraceEvent_Decoder;
  enum : int32_t {
    kActionFieldNumber = 1,
    kValFieldNumber = 2,
    kStartFieldNumber = 3,
  };
  void set_action(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_action(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_val(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_start(uint32_t value) {
    AppendVarInt(3, value);
  }
};

class ClockSetRateFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ClockSetRateFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ClockSetRateFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ClockSetRateFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_state() const { return at<2>().valid(); }
  uint64_t state() const { return at<2>().as_uint64(); }
  bool has_cpu_id() const { return at<3>().valid(); }
  uint64_t cpu_id() const { return at<3>().as_uint64(); }
};

class ClockSetRateFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = ClockSetRateFtraceEvent_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kStateFieldNumber = 2,
    kCpuIdFieldNumber = 3,
  };
  void set_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_state(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_cpu_id(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class ClockDisableFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ClockDisableFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ClockDisableFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ClockDisableFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_state() const { return at<2>().valid(); }
  uint64_t state() const { return at<2>().as_uint64(); }
  bool has_cpu_id() const { return at<3>().valid(); }
  uint64_t cpu_id() const { return at<3>().as_uint64(); }
};

class ClockDisableFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = ClockDisableFtraceEvent_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kStateFieldNumber = 2,
    kCpuIdFieldNumber = 3,
  };
  void set_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_state(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_cpu_id(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class ClockEnableFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ClockEnableFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ClockEnableFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ClockEnableFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_state() const { return at<2>().valid(); }
  uint64_t state() const { return at<2>().as_uint64(); }
  bool has_cpu_id() const { return at<3>().valid(); }
  uint64_t cpu_id() const { return at<3>().as_uint64(); }
};

class ClockEnableFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = ClockEnableFtraceEvent_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kStateFieldNumber = 2,
    kCpuIdFieldNumber = 3,
  };
  void set_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_state(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_cpu_id(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class CpuIdleFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  CpuIdleFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit CpuIdleFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit CpuIdleFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_state() const { return at<1>().valid(); }
  uint32_t state() const { return at<1>().as_uint32(); }
  bool has_cpu_id() const { return at<2>().valid(); }
  uint32_t cpu_id() const { return at<2>().as_uint32(); }
};

class CpuIdleFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = CpuIdleFtraceEvent_Decoder;
  enum : int32_t {
    kStateFieldNumber = 1,
    kCpuIdFieldNumber = 2,
  };
  void set_state(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_cpu_id(uint32_t value) {
    AppendVarInt(2, value);
  }
};

class CpuFrequencyLimitsFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  CpuFrequencyLimitsFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit CpuFrequencyLimitsFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit CpuFrequencyLimitsFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_min_freq() const { return at<1>().valid(); }
  uint32_t min_freq() const { return at<1>().as_uint32(); }
  bool has_max_freq() const { return at<2>().valid(); }
  uint32_t max_freq() const { return at<2>().as_uint32(); }
  bool has_cpu_id() const { return at<3>().valid(); }
  uint32_t cpu_id() const { return at<3>().as_uint32(); }
};

class CpuFrequencyLimitsFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = CpuFrequencyLimitsFtraceEvent_Decoder;
  enum : int32_t {
    kMinFreqFieldNumber = 1,
    kMaxFreqFieldNumber = 2,
    kCpuIdFieldNumber = 3,
  };
  void set_min_freq(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_max_freq(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_cpu_id(uint32_t value) {
    AppendVarInt(3, value);
  }
};

class CpuFrequencyFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  CpuFrequencyFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit CpuFrequencyFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit CpuFrequencyFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_state() const { return at<1>().valid(); }
  uint32_t state() const { return at<1>().as_uint32(); }
  bool has_cpu_id() const { return at<2>().valid(); }
  uint32_t cpu_id() const { return at<2>().as_uint32(); }
};

class CpuFrequencyFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = CpuFrequencyFtraceEvent_Decoder;
  enum : int32_t {
    kStateFieldNumber = 1,
    kCpuIdFieldNumber = 2,
  };
  void set_state(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_cpu_id(uint32_t value) {
    AppendVarInt(2, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/ftrace/raw_syscalls.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_RAW_SYSCALLS_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_RAW_SYSCALLS_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class SysExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SysExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SysExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SysExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_id() const { return at<1>().valid(); }
  int64_t id() const { return at<1>().as_int64(); }
  bool has_ret() const { return at<2>().valid(); }
  int64_t ret() const { return at<2>().as_int64(); }
};

class SysExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SysExitFtraceEvent_Decoder;
  enum : int32_t {
    kIdFieldNumber = 1,
    kRetFieldNumber = 2,
  };
  void set_id(int64_t value) {
    AppendVarInt(1, value);
  }
  void set_ret(int64_t value) {
    AppendVarInt(2, value);
  }
};

class SysEnterFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SysEnterFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SysEnterFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SysEnterFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_id() const { return at<1>().valid(); }
  int64_t id() const { return at<1>().as_int64(); }
};

class SysEnterFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SysEnterFtraceEvent_Decoder;
  enum : int32_t {
    kIdFieldNumber = 1,
  };
  void set_id(int64_t value) {
    AppendVarInt(1, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/ftrace/regulator.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_REGULATOR_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_REGULATOR_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class RegulatorSetVoltageCompleteFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  RegulatorSetVoltageCompleteFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit RegulatorSetVoltageCompleteFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit RegulatorSetVoltageCompleteFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_val() const { return at<2>().valid(); }
  uint32_t val() const { return at<2>().as_uint32(); }
};

class RegulatorSetVoltageCompleteFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = RegulatorSetVoltageCompleteFtraceEvent_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kValFieldNumber = 2,
  };
  void set_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_val(uint32_t value) {
    AppendVarInt(2, value);
  }
};

class RegulatorSetVoltageFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  RegulatorSetVoltageFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit RegulatorSetVoltageFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit RegulatorSetVoltageFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_min() const { return at<2>().valid(); }
  int32_t min() const { return at<2>().as_int32(); }
  bool has_max() const { return at<3>().valid(); }
  int32_t max() const { return at<3>().as_int32(); }
};

class RegulatorSetVoltageFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = RegulatorSetVoltageFtraceEvent_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kMinFieldNumber = 2,
    kMaxFieldNumber = 3,
  };
  void set_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_min(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_max(int32_t value) {
    AppendVarInt(3, value);
  }
};

class RegulatorEnableDelayFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  RegulatorEnableDelayFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit RegulatorEnableDelayFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit RegulatorEnableDelayFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
};

class RegulatorEnableDelayFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = RegulatorEnableDelayFtraceEvent_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
  };
  void set_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
};

class RegulatorEnableCompleteFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  RegulatorEnableCompleteFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit RegulatorEnableCompleteFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit RegulatorEnableCompleteFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
};

class RegulatorEnableCompleteFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = RegulatorEnableCompleteFtraceEvent_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
  };
  void set_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
};

class RegulatorEnableFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  RegulatorEnableFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit RegulatorEnableFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit RegulatorEnableFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
};

class RegulatorEnableFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = RegulatorEnableFtraceEvent_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
  };
  void set_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
};

class RegulatorDisableCompleteFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  RegulatorDisableCompleteFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit RegulatorDisableCompleteFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit RegulatorDisableCompleteFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
};

class RegulatorDisableCompleteFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = RegulatorDisableCompleteFtraceEvent_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
  };
  void set_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
};

class RegulatorDisableFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  RegulatorDisableFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit RegulatorDisableFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit RegulatorDisableFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
};

class RegulatorDisableFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = RegulatorDisableFtraceEvent_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
  };
  void set_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/ftrace/sched.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_SCHED_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_SCHED_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class SchedProcessWaitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SchedProcessWaitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SchedProcessWaitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SchedProcessWaitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_comm() const { return at<1>().valid(); }
  ::protozero::ConstChars comm() const { return at<1>().as_string(); }
  bool has_pid() const { return at<2>().valid(); }
  int32_t pid() const { return at<2>().as_int32(); }
  bool has_prio() const { return at<3>().valid(); }
  int32_t prio() const { return at<3>().as_int32(); }
};

class SchedProcessWaitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SchedProcessWaitFtraceEvent_Decoder;
  enum : int32_t {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
    kPrioFieldNumber = 3,
  };
  void set_comm(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_comm(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_pid(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_prio(int32_t value) {
    AppendVarInt(3, value);
  }
};

class SchedProcessHangFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SchedProcessHangFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SchedProcessHangFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SchedProcessHangFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_comm() const { return at<1>().valid(); }
  ::protozero::ConstChars comm() const { return at<1>().as_string(); }
  bool has_pid() const { return at<2>().valid(); }
  int32_t pid() const { return at<2>().as_int32(); }
};

class SchedProcessHangFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SchedProcessHangFtraceEvent_Decoder;
  enum : int32_t {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
  };
  void set_comm(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_comm(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_pid(int32_t value) {
    AppendVarInt(2, value);
  }
};

class SchedProcessFreeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SchedProcessFreeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SchedProcessFreeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SchedProcessFreeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_comm() const { return at<1>().valid(); }
  ::protozero::ConstChars comm() const { return at<1>().as_string(); }
  bool has_pid() const { return at<2>().valid(); }
  int32_t pid() const { return at<2>().as_int32(); }
  bool has_prio() const { return at<3>().valid(); }
  int32_t prio() const { return at<3>().as_int32(); }
};

class SchedProcessFreeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SchedProcessFreeFtraceEvent_Decoder;
  enum : int32_t {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
    kPrioFieldNumber = 3,
  };
  void set_comm(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_comm(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_pid(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_prio(int32_t value) {
    AppendVarInt(3, value);
  }
};

class SchedProcessForkFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SchedProcessForkFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SchedProcessForkFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SchedProcessForkFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_parent_comm() const { return at<1>().valid(); }
  ::protozero::ConstChars parent_comm() const { return at<1>().as_string(); }
  bool has_parent_pid() const { return at<2>().valid(); }
  int32_t parent_pid() const { return at<2>().as_int32(); }
  bool has_child_comm() const { return at<3>().valid(); }
  ::protozero::ConstChars child_comm() const { return at<3>().as_string(); }
  bool has_child_pid() const { return at<4>().valid(); }
  int32_t child_pid() const { return at<4>().as_int32(); }
};

class SchedProcessForkFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SchedProcessForkFtraceEvent_Decoder;
  enum : int32_t {
    kParentCommFieldNumber = 1,
    kParentPidFieldNumber = 2,
    kChildCommFieldNumber = 3,
    kChildPidFieldNumber = 4,
  };
  void set_parent_comm(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_parent_comm(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_parent_pid(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_child_comm(const std::string& value) {
    AppendBytes(3, value.data(), value.size());
  }
  void set_child_comm(const char* data, size_t size) {
    AppendBytes(3, data, size);
  }
  void set_child_pid(int32_t value) {
    AppendVarInt(4, value);
  }
};

class SchedProcessExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SchedProcessExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SchedProcessExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SchedProcessExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_comm() const { return at<1>().valid(); }
  ::protozero::ConstChars comm() const { return at<1>().as_string(); }
  bool has_pid() const { return at<2>().valid(); }
  int32_t pid() const { return at<2>().as_int32(); }
  bool has_tgid() const { return at<3>().valid(); }
  int32_t tgid() const { return at<3>().as_int32(); }
  bool has_prio() const { return at<4>().valid(); }
  int32_t prio() const { return at<4>().as_int32(); }
};

class SchedProcessExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SchedProcessExitFtraceEvent_Decoder;
  enum : int32_t {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
    kTgidFieldNumber = 3,
    kPrioFieldNumber = 4,
  };
  void set_comm(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_comm(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_pid(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_tgid(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_prio(int32_t value) {
    AppendVarInt(4, value);
  }
};

class SchedProcessExecFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SchedProcessExecFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SchedProcessExecFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SchedProcessExecFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_filename() const { return at<1>().valid(); }
  ::protozero::ConstChars filename() const { return at<1>().as_string(); }
  bool has_pid() const { return at<2>().valid(); }
  int32_t pid() const { return at<2>().as_int32(); }
  bool has_old_pid() const { return at<3>().valid(); }
  int32_t old_pid() const { return at<3>().as_int32(); }
};

class SchedProcessExecFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SchedProcessExecFtraceEvent_Decoder;
  enum : int32_t {
    kFilenameFieldNumber = 1,
    kPidFieldNumber = 2,
    kOldPidFieldNumber = 3,
  };
  void set_filename(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_filename(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_pid(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_old_pid(int32_t value) {
    AppendVarInt(3, value);
  }
};

class SchedWakeupNewFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SchedWakeupNewFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SchedWakeupNewFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SchedWakeupNewFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_comm() const { return at<1>().valid(); }
  ::protozero::ConstChars comm() const { return at<1>().as_string(); }
  bool has_pid() const { return at<2>().valid(); }
  int32_t pid() const { return at<2>().as_int32(); }
  bool has_prio() const { return at<3>().valid(); }
  int32_t prio() const { return at<3>().as_int32(); }
  bool has_success() const { return at<4>().valid(); }
  int32_t success() const { return at<4>().as_int32(); }
  bool has_target_cpu() const { return at<5>().valid(); }
  int32_t target_cpu() const { return at<5>().as_int32(); }
};

class SchedWakeupNewFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SchedWakeupNewFtraceEvent_Decoder;
  enum : int32_t {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
    kPrioFieldNumber = 3,
    kSuccessFieldNumber = 4,
    kTargetCpuFieldNumber = 5,
  };
  void set_comm(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_comm(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_pid(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_prio(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_success(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_target_cpu(int32_t value) {
    AppendVarInt(5, value);
  }
};

class SchedWakingFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SchedWakingFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SchedWakingFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SchedWakingFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_comm() const { return at<1>().valid(); }
  ::protozero::ConstChars comm() const { return at<1>().as_string(); }
  bool has_pid() const { return at<2>().valid(); }
  int32_t pid() const { return at<2>().as_int32(); }
  bool has_prio() const { return at<3>().valid(); }
  int32_t prio() const { return at<3>().as_int32(); }
  bool has_success() const { return at<4>().valid(); }
  int32_t success() const { return at<4>().as_int32(); }
  bool has_target_cpu() const { return at<5>().valid(); }
  int32_t target_cpu() const { return at<5>().as_int32(); }
};

class SchedWakingFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SchedWakingFtraceEvent_Decoder;
  enum : int32_t {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
    kPrioFieldNumber = 3,
    kSuccessFieldNumber = 4,
    kTargetCpuFieldNumber = 5,
  };
  void set_comm(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_comm(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_pid(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_prio(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_success(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_target_cpu(int32_t value) {
    AppendVarInt(5, value);
  }
};

class SchedCpuHotplugFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SchedCpuHotplugFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SchedCpuHotplugFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SchedCpuHotplugFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_affected_cpu() const { return at<1>().valid(); }
  int32_t affected_cpu() const { return at<1>().as_int32(); }
  bool has_error() const { return at<2>().valid(); }
  int32_t error() const { return at<2>().as_int32(); }
  bool has_status() const { return at<3>().valid(); }
  int32_t status() const { return at<3>().as_int32(); }
};

class SchedCpuHotplugFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SchedCpuHotplugFtraceEvent_Decoder;
  enum : int32_t {
    kAffectedCpuFieldNumber = 1,
    kErrorFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  void set_affected_cpu(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_error(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_status(int32_t value) {
    AppendVarInt(3, value);
  }
};

class SchedBlockedReasonFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SchedBlockedReasonFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SchedBlockedReasonFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SchedBlockedReasonFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_pid() const { return at<1>().valid(); }
  int32_t pid() const { return at<1>().as_int32(); }
  bool has_caller() const { return at<2>().valid(); }
  uint64_t caller() const { return at<2>().as_uint64(); }
  bool has_io_wait() const { return at<3>().valid(); }
  uint32_t io_wait() const { return at<3>().as_uint32(); }
};

class SchedBlockedReasonFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SchedBlockedReasonFtraceEvent_Decoder;
  enum : int32_t {
    kPidFieldNumber = 1,
    kCallerFieldNumber = 2,
    kIoWaitFieldNumber = 3,
  };
  void set_pid(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_caller(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_io_wait(uint32_t value) {
    AppendVarInt(3, value);
  }
};

class SchedWakeupFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SchedWakeupFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SchedWakeupFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SchedWakeupFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_comm() const { return at<1>().valid(); }
  ::protozero::ConstChars comm() const { return at<1>().as_string(); }
  bool has_pid() const { return at<2>().valid(); }
  int32_t pid() const { return at<2>().as_int32(); }
  bool has_prio() const { return at<3>().valid(); }
  int32_t prio() const { return at<3>().as_int32(); }
  bool has_success() const { return at<4>().valid(); }
  int32_t success() const { return at<4>().as_int32(); }
  bool has_target_cpu() const { return at<5>().valid(); }
  int32_t target_cpu() const { return at<5>().as_int32(); }
};

class SchedWakeupFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SchedWakeupFtraceEvent_Decoder;
  enum : int32_t {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
    kPrioFieldNumber = 3,
    kSuccessFieldNumber = 4,
    kTargetCpuFieldNumber = 5,
  };
  void set_comm(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_comm(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_pid(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_prio(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_success(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_target_cpu(int32_t value) {
    AppendVarInt(5, value);
  }
};

class SchedSwitchFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/7, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SchedSwitchFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SchedSwitchFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SchedSwitchFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_prev_comm() const { return at<1>().valid(); }
  ::protozero::ConstChars prev_comm() const { return at<1>().as_string(); }
  bool has_prev_pid() const { return at<2>().valid(); }
  int32_t prev_pid() const { return at<2>().as_int32(); }
  bool has_prev_prio() const { return at<3>().valid(); }
  int32_t prev_prio() const { return at<3>().as_int32(); }
  bool has_prev_state() const { return at<4>().valid(); }
  int64_t prev_state() const { return at<4>().as_int64(); }
  bool has_next_comm() const { return at<5>().valid(); }
  ::protozero::ConstChars next_comm() const { return at<5>().as_string(); }
  bool has_next_pid() const { return at<6>().valid(); }
  int32_t next_pid() const { return at<6>().as_int32(); }
  bool has_next_prio() const { return at<7>().valid(); }
  int32_t next_prio() const { return at<7>().as_int32(); }
};

class SchedSwitchFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SchedSwitchFtraceEvent_Decoder;
  enum : int32_t {
    kPrevCommFieldNumber = 1,
    kPrevPidFieldNumber = 2,
    kPrevPrioFieldNumber = 3,
    kPrevStateFieldNumber = 4,
    kNextCommFieldNumber = 5,
    kNextPidFieldNumber = 6,
    kNextPrioFieldNumber = 7,
  };
  void set_prev_comm(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_prev_comm(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_prev_pid(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_prev_prio(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_prev_state(int64_t value) {
    AppendVarInt(4, value);
  }
  void set_next_comm(const std::string& value) {
    AppendBytes(5, value.data(), value.size());
  }
  void set_next_comm(const char* data, size_t size) {
    AppendBytes(5, data, size);
  }
  void set_next_pid(int32_t value) {
    AppendVarInt(6, value);
  }
  void set_next_prio(int32_t value) {
    AppendVarInt(7, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/ftrace/signal.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_SIGNAL_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_SIGNAL_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class SignalGenerateFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SignalGenerateFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SignalGenerateFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SignalGenerateFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_code() const { return at<1>().valid(); }
  int32_t code() const { return at<1>().as_int32(); }
  bool has_comm() const { return at<2>().valid(); }
  ::protozero::ConstChars comm() const { return at<2>().as_string(); }
  bool has_group() const { return at<3>().valid(); }
  int32_t group() const { return at<3>().as_int32(); }
  bool has_pid() const { return at<4>().valid(); }
  int32_t pid() const { return at<4>().as_int32(); }
  bool has_result() const { return at<5>().valid(); }
  int32_t result() const { return at<5>().as_int32(); }
  bool has_sig() const { return at<6>().valid(); }
  int32_t sig() const { return at<6>().as_int32(); }
};

class SignalGenerateFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SignalGenerateFtraceEvent_Decoder;
  enum : int32_t {
    kCodeFieldNumber = 1,
    kCommFieldNumber = 2,
    kGroupFieldNumber = 3,
    kPidFieldNumber = 4,
    kResultFieldNumber = 5,
    kSigFieldNumber = 6,
  };
  void set_code(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_comm(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void set_comm(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
  void set_group(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_pid(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_result(int32_t value) {
    AppendVarInt(5, value);
  }
  void set_sig(int32_t value) {
    AppendVarInt(6, value);
  }
};

class SignalDeliverFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SignalDeliverFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SignalDeliverFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SignalDeliverFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_code() const { return at<1>().valid(); }
  int32_t code() const { return at<1>().as_int32(); }
  bool has_sa_flags() const { return at<2>().valid(); }
  uint64_t sa_flags() const { return at<2>().as_uint64(); }
  bool has_sig() const { return at<3>().valid(); }
  int32_t sig() const { return at<3>().as_int32(); }
};

class SignalDeliverFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SignalDeliverFtraceEvent_Decoder;
  enum : int32_t {
    kCodeFieldNumber = 1,
    kSaFlagsFieldNumber = 2,
    kSigFieldNumber = 3,
  };
  void set_code(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_sa_flags(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_sig(int32_t value) {
    AppendVarInt(3, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/ftrace/sync.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_SYNC_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_SYNC_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class SyncWaitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SyncWaitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SyncWaitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SyncWaitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_status() const { return at<2>().valid(); }
  int32_t status() const { return at<2>().as_int32(); }
  bool has_begin() const { return at<3>().valid(); }
  uint32_t begin() const { return at<3>().as_uint32(); }
};

class SyncWaitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SyncWaitFtraceEvent_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kStatusFieldNumber = 2,
    kBeginFieldNumber = 3,
  };
  void set_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_status(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_begin(uint32_t value) {
    AppendVarInt(3, value);
  }
};

class SyncTimelineFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SyncTimelineFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SyncTimelineFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SyncTimelineFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_value() const { return at<2>().valid(); }
  ::protozero::ConstChars value() const { return at<2>().as_string(); }
};

class SyncTimelineFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SyncTimelineFtraceEvent_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  void set_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_value(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void set_value(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
};

class SyncPtFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SyncPtFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SyncPtFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SyncPtFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_timeline() const { return at<1>().valid(); }
  ::protozero::ConstChars timeline() const { return at<1>().as_string(); }
  bool has_value() const { return at<2>().valid(); }
  ::protozero::ConstChars value() const { return at<2>().as_string(); }
};

class SyncPtFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SyncPtFtraceEvent_Decoder;
  enum : int32_t {
    kTimelineFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  void set_timeline(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_timeline(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_value(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void set_value(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/ftrace/systrace.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_SYSTRACE_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_SYSTRACE_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class ZeroFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ZeroFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ZeroFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ZeroFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_flag() const { return at<1>().valid(); }
  int32_t flag() const { return at<1>().as_int32(); }
  bool has_name() const { return at<2>().valid(); }
  ::protozero::ConstChars name() const { return at<2>().as_string(); }
  bool has_pid() const { return at<3>().valid(); }
  int32_t pid() const { return at<3>().as_int32(); }
  bool has_value() const { return at<4>().valid(); }
  int64_t value() const { return at<4>().as_int64(); }
};

class ZeroFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = ZeroFtraceEvent_Decoder;
  enum : int32_t {
    kFlagFieldNumber = 1,
    kNameFieldNumber = 2,
    kPidFieldNumber = 3,
    kValueFieldNumber = 4,
  };
  void set_flag(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_name(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void set_name(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
  void set_pid(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_value(int64_t value) {
    AppendVarInt(4, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/ftrace/task.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_TASK_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_TASK_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class TaskRenameFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TaskRenameFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TaskRenameFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TaskRenameFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_pid() const { return at<1>().valid(); }
  int32_t pid() const { return at<1>().as_int32(); }
  bool has_oldcomm() const { return at<2>().valid(); }
  ::protozero::ConstChars oldcomm() const { return at<2>().as_string(); }
  bool has_newcomm() const { return at<3>().valid(); }
  ::protozero::ConstChars newcomm() const { return at<3>().as_string(); }
  bool has_oom_score_adj() const { return at<4>().valid(); }
  int32_t oom_score_adj() const { return at<4>().as_int32(); }
};

class TaskRenameFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = TaskRenameFtraceEvent_Decoder;
  enum : int32_t {
    kPidFieldNumber = 1,
    kOldcommFieldNumber = 2,
    kNewcommFieldNumber = 3,
    kOomScoreAdjFieldNumber = 4,
  };
  void set_pid(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_oldcomm(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void set_oldcomm(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
  void set_newcomm(const std::string& value) {
    AppendBytes(3, value.data(), value.size());
  }
  void set_newcomm(const char* data, size_t size) {
    AppendBytes(3, data, size);
  }
  void set_oom_score_adj(int32_t value) {
    AppendVarInt(4, value);
  }
};

class TaskNewtaskFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TaskNewtaskFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TaskNewtaskFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TaskNewtaskFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_pid() const { return at<1>().valid(); }
  int32_t pid() const { return at<1>().as_int32(); }
  bool has_comm() const { return at<2>().valid(); }
  ::protozero::ConstChars comm() const { return at<2>().as_string(); }
  bool has_clone_flags() const { return at<3>().valid(); }
  uint64_t clone_flags() const { return at<3>().as_uint64(); }
  bool has_oom_score_adj() const { return at<4>().valid(); }
  int32_t oom_score_adj() const { return at<4>().as_int32(); }
};

class TaskNewtaskFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = TaskNewtaskFtraceEvent_Decoder;
  enum : int32_t {
    kPidFieldNumber = 1,
    kCommFieldNumber = 2,
    kCloneFlagsFieldNumber = 3,
    kOomScoreAdjFieldNumber = 4,
  };
  void set_pid(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_comm(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void set_comm(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
  void set_clone_flags(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_oom_score_adj(int32_t value) {
    AppendVarInt(4, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/ftrace/vmscan.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_VMSCAN_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_VMSCAN_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class MmVmscanKswapdSleepFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmVmscanKswapdSleepFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmVmscanKswapdSleepFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmVmscanKswapdSleepFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_nid() const { return at<1>().valid(); }
  int32_t nid() const { return at<1>().as_int32(); }
};

class MmVmscanKswapdSleepFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmVmscanKswapdSleepFtraceEvent_Decoder;
  enum : int32_t {
    kNidFieldNumber = 1,
  };
  void set_nid(int32_t value) {
    AppendVarInt(1, value);
  }
};

class MmVmscanKswapdWakeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmVmscanKswapdWakeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmVmscanKswapdWakeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmVmscanKswapdWakeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_nid() const { return at<1>().valid(); }
  int32_t nid() const { return at<1>().as_int32(); }
  bool has_order() const { return at<2>().valid(); }
  int32_t order() const { return at<2>().as_int32(); }
};

class MmVmscanKswapdWakeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmVmscanKswapdWakeFtraceEvent_Decoder;
  enum : int32_t {
    kNidFieldNumber = 1,
    kOrderFieldNumber = 2,
  };
  void set_nid(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_order(int32_t value) {
    AppendVarInt(2, value);
  }
};

class MmVmscanDirectReclaimEndFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmVmscanDirectReclaimEndFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmVmscanDirectReclaimEndFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmVmscanDirectReclaimEndFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_nr_reclaimed() const { return at<1>().valid(); }
  uint64_t nr_reclaimed() const { return at<1>().as_uint64(); }
};

class MmVmscanDirectReclaimEndFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmVmscanDirectReclaimEndFtraceEvent_Decoder;
  enum : int32_t {
    kNrReclaimedFieldNumber = 1,
  };
  void set_nr_reclaimed(uint64_t value) {
    AppendVarInt(1, value);
  }
};

class MmVmscanDirectReclaimBeginFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmVmscanDirectReclaimBeginFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmVmscanDirectReclaimBeginFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmVmscanDirectReclaimBeginFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_order() const { return at<1>().valid(); }
  int32_t order() const { return at<1>().as_int32(); }
  bool has_may_writepage() const { return at<2>().valid(); }
  int32_t may_writepage() const { return at<2>().as_int32(); }
  bool has_gfp_flags() const { return at<3>().valid(); }
  uint32_t gfp_flags() const { return at<3>().as_uint32(); }
};

class MmVmscanDirectReclaimBeginFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmVmscanDirectReclaimBeginFtraceEvent_Decoder;
  enum : int32_t {
    kOrderFieldNumber = 1,
    kMayWritepageFieldNumber = 2,
    kGfpFlagsFieldNumber = 3,
  };
  void set_order(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_may_writepage(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_gfp_flags(uint32_t value) {
    AppendVarInt(3, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/ftrace/workqueue.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_WORKQUEUE_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_WORKQUEUE_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class WorkqueueQueueWorkFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  WorkqueueQueueWorkFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit WorkqueueQueueWorkFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit WorkqueueQueueWorkFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_work() const { return at<1>().valid(); }
  uint64_t work() const { return at<1>().as_uint64(); }
  bool has_function() const { return at<2>().valid(); }
  uint64_t function() const { return at<2>().as_uint64(); }
  bool has_workqueue() const { return at<3>().valid(); }
  uint64_t workqueue() const { return at<3>().as_uint64(); }
  bool has_req_cpu() const { return at<4>().valid(); }
  uint32_t req_cpu() const { return at<4>().as_uint32(); }
  bool has_cpu() const { return at<5>().valid(); }
  uint32_t cpu() const { return at<5>().as_uint32(); }
};

class WorkqueueQueueWorkFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = WorkqueueQueueWorkFtraceEvent_Decoder;
  enum : int32_t {
    kWorkFieldNumber = 1,
    kFunctionFieldNumber = 2,
    kWorkqueueFieldNumber = 3,
    kReqCpuFieldNumber = 4,
    kCpuFieldNumber = 5,
  };
  void set_work(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_function(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_workqueue(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_req_cpu(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_cpu(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class WorkqueueExecuteStartFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  WorkqueueExecuteStartFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit WorkqueueExecuteStartFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit WorkqueueExecuteStartFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_work() const { return at<1>().valid(); }
  uint64_t work() const { return at<1>().as_uint64(); }
  bool has_function() const { return at<2>().valid(); }
  uint64_t function() const { return at<2>().as_uint64(); }
};

class WorkqueueExecuteStartFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = WorkqueueExecuteStartFtraceEvent_Decoder;
  enum : int32_t {
    kWorkFieldNumber = 1,
    kFunctionFieldNumber = 2,
  };
  void set_work(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_function(uint64_t value) {
    AppendVarInt(2, value);
  }
};

class WorkqueueExecuteEndFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  WorkqueueExecuteEndFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit WorkqueueExecuteEndFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit WorkqueueExecuteEndFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_work() const { return at<1>().valid(); }
  uint64_t work() const { return at<1>().as_uint64(); }
};

class WorkqueueExecuteEndFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = WorkqueueExecuteEndFtraceEvent_Decoder;
  enum : int32_t {
    kWorkFieldNumber = 1,
  };
  void set_work(uint64_t value) {
    AppendVarInt(1, value);
  }
};

class WorkqueueActivateWorkFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  WorkqueueActivateWorkFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit WorkqueueActivateWorkFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit WorkqueueActivateWorkFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_work() const { return at<1>().valid(); }
  uint64_t work() const { return at<1>().as_uint64(); }
};

class WorkqueueActivateWorkFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = WorkqueueActivateWorkFtraceEvent_Decoder;
  enum : int32_t {
    kWorkFieldNumber = 1,
  };
  void set_work(uint64_t value) {
    AppendVarInt(1, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/gpu/gpu_counter_event.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_GPU_GPU_COUNTER_EVENT_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_GPU_GPU_COUNTER_EVENT_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class GpuCounterDescriptor;
class GpuCounterEvent_GpuCounter;

class GpuCounterEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  GpuCounterEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit GpuCounterEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit GpuCounterEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_counter_descriptor() const { return at<1>().valid(); }
  ::protozero::ConstBytes counter_descriptor() const { return at<1>().as_bytes(); }
  bool has_counters() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> counters() const { return GetRepeated<::protozero::ConstBytes>(2); }
  bool has_gpu_id() const { return at<3>().valid(); }
  int32_t gpu_id() const { return at<3>().as_int32(); }
};

class GpuCounterEvent : public ::protozero::Message {
 public:
  using Decoder = GpuCounterEvent_Decoder;
  enum : int32_t {
    kCounterDescriptorFieldNumber = 1,
    kCountersFieldNumber = 2,
    kGpuIdFieldNumber = 3,
  };
  using GpuCounter = ::perfetto::protos::pbzero::GpuCounterEvent_GpuCounter;
  template <typename T = GpuCounterDescriptor> T* set_counter_descriptor() {
    return BeginNestedMessage<T>(1);
  }

  template <typename T = GpuCounterEvent_GpuCounter> T* add_counters() {
    return BeginNestedMessage<T>(2);
  }

  void set_gpu_id(int32_t value) {
    AppendVarInt(3, value);
  }
};

class GpuCounterEvent_GpuCounter_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  GpuCounterEvent_GpuCounter_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit GpuCounterEvent_GpuCounter_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit GpuCounterEvent_GpuCounter_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_counter_id() const { return at<1>().valid(); }
  uint32_t counter_id() const { return at<1>().as_uint32(); }
  bool has_int_value() const { return at<2>().valid(); }
  int64_t int_value() const { return at<2>().as_int64(); }
  bool has_double_value() const { return at<3>().valid(); }
  double double_value() const { return at<3>().as_double(); }
};

class GpuCounterEvent_GpuCounter : public ::protozero::Message {
 public:
  using Decoder = GpuCounterEvent_GpuCounter_Decoder;
  enum : int32_t {
    kCounterIdFieldNumber = 1,
    kIntValueFieldNumber = 2,
    kDoubleValueFieldNumber = 3,
  };
  void set_counter_id(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_int_value(int64_t value) {
    AppendVarInt(2, value);
  }
  void set_double_value(double value) {
    AppendFixed(3, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/gpu/gpu_log.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_GPU_GPU_LOG_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_GPU_GPU_LOG_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

enum GpuLog_Severity : int32_t;

enum GpuLog_Severity : int32_t {
  GpuLog_Severity_LOG_SEVERITY_UNSPECIFIED = 0,
  GpuLog_Severity_LOG_SEVERITY_VERBOSE = 1,
  GpuLog_Severity_LOG_SEVERITY_DEBUG = 2,
  GpuLog_Severity_LOG_SEVERITY_INFO = 3,
  GpuLog_Severity_LOG_SEVERITY_WARNING = 4,
  GpuLog_Severity_LOG_SEVERITY_ERROR = 5,
};

const GpuLog_Severity GpuLog_Severity_MIN = GpuLog_Severity_LOG_SEVERITY_UNSPECIFIED;
const GpuLog_Severity GpuLog_Severity_MAX = GpuLog_Severity_LOG_SEVERITY_ERROR;

class GpuLog_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  GpuLog_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit GpuLog_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit GpuLog_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_severity() const { return at<1>().valid(); }
  int32_t severity() const { return at<1>().as_int32(); }
  bool has_tag() const { return at<2>().valid(); }
  ::protozero::ConstChars tag() const { return at<2>().as_string(); }
  bool has_log_message() const { return at<3>().valid(); }
  ::protozero::ConstChars log_message() const { return at<3>().as_string(); }
};

class GpuLog : public ::protozero::Message {
 public:
  using Decoder = GpuLog_Decoder;
  enum : int32_t {
    kSeverityFieldNumber = 1,
    kTagFieldNumber = 2,
    kLogMessageFieldNumber = 3,
  };
  using Severity = ::perfetto::protos::pbzero::GpuLog_Severity;
  static const Severity LOG_SEVERITY_UNSPECIFIED = GpuLog_Severity_LOG_SEVERITY_UNSPECIFIED;
  static const Severity LOG_SEVERITY_VERBOSE = GpuLog_Severity_LOG_SEVERITY_VERBOSE;
  static const Severity LOG_SEVERITY_DEBUG = GpuLog_Severity_LOG_SEVERITY_DEBUG;
  static const Severity LOG_SEVERITY_INFO = GpuLog_Severity_LOG_SEVERITY_INFO;
  static const Severity LOG_SEVERITY_WARNING = GpuLog_Severity_LOG_SEVERITY_WARNING;
  static const Severity LOG_SEVERITY_ERROR = GpuLog_Severity_LOG_SEVERITY_ERROR;
  void set_severity(::perfetto::protos::pbzero::GpuLog_Severity value) {
    AppendTinyVarInt(1, value);
  }
  void set_tag(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void set_tag(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
  void set_log_message(const std::string& value) {
    AppendBytes(3, value.data(), value.size());
  }
  void set_log_message(const char* data, size_t size) {
    AppendBytes(3, data, size);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/gpu/gpu_render_stage_event.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_GPU_GPU_RENDER_STAGE_EVENT_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_GPU_GPU_RENDER_STAGE_EVENT_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class GpuRenderStageEvent_ExtraData;
class GpuRenderStageEvent_Specifications;
class GpuRenderStageEvent_Specifications_ContextSpec;
class GpuRenderStageEvent_Specifications_Description;

class GpuRenderStageEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/12, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  GpuRenderStageEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit GpuRenderStageEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit GpuRenderStageEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_event_id() const { return at<1>().valid(); }
  uint64_t event_id() const { return at<1>().as_uint64(); }
  bool has_duration() const { return at<2>().valid(); }
  uint64_t duration() const { return at<2>().as_uint64(); }
  bool has_hw_queue_id() const { return at<3>().valid(); }
  int32_t hw_queue_id() const { return at<3>().as_int32(); }
  bool has_stage_id() const { return at<4>().valid(); }
  int32_t stage_id() const { return at<4>().as_int32(); }
  bool has_context() const { return at<5>().valid(); }
  uint64_t context() const { return at<5>().as_uint64(); }
  bool has_render_target_handle() const { return at<8>().valid(); }
  uint64_t render_target_handle() const { return at<8>().as_uint64(); }
  bool has_render_pass_handle() const { return at<9>().valid(); }
  uint64_t render_pass_handle() const { return at<9>().as_uint64(); }
  bool has_command_buffer_handle() const { return at<12>().valid(); }
  uint64_t command_buffer_handle() const { return at<12>().as_uint64(); }
  bool has_submission_id() const { return at<10>().valid(); }
  uint32_t submission_id() const { return at<10>().as_uint32(); }
  bool has_extra_data() const { return at<6>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> extra_data() const { return GetRepeated<::protozero::ConstBytes>(6); }
  bool has_specifications() const { return at<7>().valid(); }
  ::protozero::ConstBytes specifications() const { return at<7>().as_bytes(); }
  bool has_gpu_id() const { return at<11>().valid(); }
  int32_t gpu_id() const { return at<11>().as_int32(); }
};

class GpuRenderStageEvent : public ::protozero::Message {
 public:
  using Decoder = GpuRenderStageEvent_Decoder;
  enum : int32_t {
    kEventIdFieldNumber = 1,
    kDurationFieldNumber = 2,
    kHwQueueIdFieldNumber = 3,
    kStageIdFieldNumber = 4,
    kContextFieldNumber = 5,
    kRenderTargetHandleFieldNumber = 8,
    kRenderPassHandleFieldNumber = 9,
    kCommandBufferHandleFieldNumber = 12,
    kSubmissionIdFieldNumber = 10,
    kExtraDataFieldNumber = 6,
    kSpecificationsFieldNumber = 7,
    kGpuIdFieldNumber = 11,
  };
  using ExtraData = ::perfetto::protos::pbzero::GpuRenderStageEvent_ExtraData;
  using Specifications = ::perfetto::protos::pbzero::GpuRenderStageEvent_Specifications;
  void set_event_id(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_duration(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_hw_queue_id(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_stage_id(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_context(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_render_target_handle(uint64_t value) {
    AppendVarInt(8, value);
  }
  void set_render_pass_handle(uint64_t value) {
    AppendVarInt(9, value);
  }
  void set_command_buffer_handle(uint64_t value) {
    AppendVarInt(12, value);
  }
  void set_submission_id(uint32_t value) {
    AppendVarInt(10, value);
  }
  template <typename T = GpuRenderStageEvent_ExtraData> T* add_extra_data() {
    return BeginNestedMessage<T>(6);
  }

  template <typename T = GpuRenderStageEvent_Specifications> T* set_specifications() {
    return BeginNestedMessage<T>(7);
  }

  void set_gpu_id(int32_t value) {
    AppendVarInt(11, value);
  }
};

class GpuRenderStageEvent_Specifications_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  GpuRenderStageEvent_Specifications_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit GpuRenderStageEvent_Specifications_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit GpuRenderStageEvent_Specifications_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_context_spec() const { return at<1>().valid(); }
  ::protozero::ConstBytes context_spec() const { return at<1>().as_bytes(); }
  bool has_hw_queue() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> hw_queue() const { return GetRepeated<::protozero::ConstBytes>(2); }
  bool has_stage() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> stage() const { return GetRepeated<::protozero::ConstBytes>(3); }
};

class GpuRenderStageEvent_Specifications : public ::protozero::Message {
 public:
  using Decoder = GpuRenderStageEvent_Specifications_Decoder;
  enum : int32_t {
    kContextSpecFieldNumber = 1,
    kHwQueueFieldNumber = 2,
    kStageFieldNumber = 3,
  };
  using ContextSpec = ::perfetto::protos::pbzero::GpuRenderStageEvent_Specifications_ContextSpec;
  using Description = ::perfetto::protos::pbzero::GpuRenderStageEvent_Specifications_Description;
  template <typename T = GpuRenderStageEvent_Specifications_ContextSpec> T* set_context_spec() {
    return BeginNestedMessage<T>(1);
  }

  template <typename T = GpuRenderStageEvent_Specifications_Description> T* add_hw_queue() {
    return BeginNestedMessage<T>(2);
  }

  template <typename T = GpuRenderStageEvent_Specifications_Description> T* add_stage() {
    return BeginNestedMessage<T>(3);
  }

};

class GpuRenderStageEvent_Specifications_Description_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  GpuRenderStageEvent_Specifications_Description_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit GpuRenderStageEvent_Specifications_Description_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit GpuRenderStageEvent_Specifications_Description_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_description() const { return at<2>().valid(); }
  ::protozero::ConstChars description() const { return at<2>().as_string(); }
};

class GpuRenderStageEvent_Specifications_Description : public ::protozero::Message {
 public:
  using Decoder = GpuRenderStageEvent_Specifications_Description_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kDescriptionFieldNumber = 2,
  };
  void set_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_description(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void set_description(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
};

class GpuRenderStageEvent_Specifications_ContextSpec_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  GpuRenderStageEvent_Specifications_ContextSpec_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit GpuRenderStageEvent_Specifications_ContextSpec_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit GpuRenderStageEvent_Specifications_ContextSpec_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_context() const { return at<1>().valid(); }
  uint64_t context() const { return at<1>().as_uint64(); }
  bool has_pid() const { return at<2>().valid(); }
  int32_t pid() const { return at<2>().as_int32(); }
};

class GpuRenderStageEvent_Specifications_ContextSpec : public ::protozero::Message {
 public:
  using Decoder = GpuRenderStageEvent_Specifications_ContextSpec_Decoder;
  enum : int32_t {
    kContextFieldNumber = 1,
    kPidFieldNumber = 2,
  };
  void set_context(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_pid(int32_t value) {
    AppendVarInt(2, value);
  }
};

class GpuRenderStageEvent_ExtraData_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  GpuRenderStageEvent_ExtraData_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit GpuRenderStageEvent_ExtraData_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit GpuRenderStageEvent_ExtraData_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_value() const { return at<2>().valid(); }
  ::protozero::ConstChars value() const { return at<2>().as_string(); }
};

class GpuRenderStageEvent_ExtraData : public ::protozero::Message {
 public:
  using Decoder = GpuRenderStageEvent_ExtraData_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  void set_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_value(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void set_value(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/gpu/vulkan_memory_event.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_GPU_VULKAN_MEMORY_EVENT_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_GPU_VULKAN_MEMORY_EVENT_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class VulkanMemoryEventAnnotation;
enum VulkanMemoryEvent_AllocationScope : int32_t;
enum VulkanMemoryEvent_Operation : int32_t;
enum VulkanMemoryEvent_Source : int32_t;

enum VulkanMemoryEvent_Source : int32_t {
  VulkanMemoryEvent_Source_SOURCE_UNSPECIFIED = 0,
  VulkanMemoryEvent_Source_SOURCE_DRIVER = 1,
  VulkanMemoryEvent_Source_SOURCE_DEVICE = 2,
  VulkanMemoryEvent_Source_SOURCE_DEVICE_MEMORY = 3,
  VulkanMemoryEvent_Source_SOURCE_BUFFER = 4,
  VulkanMemoryEvent_Source_SOURCE_IMAGE = 5,
};

const VulkanMemoryEvent_Source VulkanMemoryEvent_Source_MIN = VulkanMemoryEvent_Source_SOURCE_UNSPECIFIED;
const VulkanMemoryEvent_Source VulkanMemoryEvent_Source_MAX = VulkanMemoryEvent_Source_SOURCE_IMAGE;

enum VulkanMemoryEvent_Operation : int32_t {
  VulkanMemoryEvent_Operation_OP_UNSPECIFIED = 0,
  VulkanMemoryEvent_Operation_OP_CREATE = 1,
  VulkanMemoryEvent_Operation_OP_DESTROY = 2,
  VulkanMemoryEvent_Operation_OP_BIND = 3,
  VulkanMemoryEvent_Operation_OP_DESTROY_BOUND = 4,
  VulkanMemoryEvent_Operation_OP_ANNOTATIONS = 5,
};

const VulkanMemoryEvent_Operation VulkanMemoryEvent_Operation_MIN = VulkanMemoryEvent_Operation_OP_UNSPECIFIED;
const VulkanMemoryEvent_Operation VulkanMemoryEvent_Operation_MAX = VulkanMemoryEvent_Operation_OP_ANNOTATIONS;

enum VulkanMemoryEvent_AllocationScope : int32_t {
  VulkanMemoryEvent_AllocationScope_SCOPE_UNSPECIFIED = 0,
  VulkanMemoryEvent_AllocationScope_SCOPE_COMMAND = 1,
  VulkanMemoryEvent_AllocationScope_SCOPE_OBJECT = 2,
  VulkanMemoryEvent_AllocationScope_SCOPE_CACHE = 3,
  VulkanMemoryEvent_AllocationScope_SCOPE_DEVICE = 4,
  VulkanMemoryEvent_AllocationScope_SCOPE_INSTANCE = 5,
};

const VulkanMemoryEvent_AllocationScope VulkanMemoryEvent_AllocationScope_MIN = VulkanMemoryEvent_AllocationScope_SCOPE_UNSPECIFIED;
const VulkanMemoryEvent_AllocationScope VulkanMemoryEvent_AllocationScope_MAX = VulkanMemoryEvent_AllocationScope_SCOPE_INSTANCE;

class VulkanMemoryEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/20, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  VulkanMemoryEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit VulkanMemoryEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit VulkanMemoryEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_source() const { return at<1>().valid(); }
  int32_t source() const { return at<1>().as_int32(); }
  bool has_operation() const { return at<2>().valid(); }
  int32_t operation() const { return at<2>().as_int32(); }
  bool has_timestamp() const { return at<3>().valid(); }
  int64_t timestamp() const { return at<3>().as_int64(); }
  bool has_pid() const { return at<4>().valid(); }
  uint32_t pid() const { return at<4>().as_uint32(); }
  bool has_memory_address() const { return at<5>().valid(); }
  uint64_t memory_address() const { return at<5>().as_uint64(); }
  bool has_memory_size() const { return at<6>().valid(); }
  uint64_t memory_size() const { return at<6>().as_uint64(); }
  bool has_caller_iid() const { return at<7>().valid(); }
  uint64_t caller_iid() const { return at<7>().as_uint64(); }
  bool has_allocation_scope() const { return at<8>().valid(); }
  int32_t allocation_scope() const { return at<8>().as_int32(); }
  bool has_annotations() const { return at<9>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> annotations() const { return GetRepeated<::protozero::ConstBytes>(9); }
  bool has_device() const { return at<16>().valid(); }
  uint64_t device() const { return at<16>().as_uint64(); }
  bool has_device_memory() const { return at<17>().valid(); }
  uint64_t device_memory() const { return at<17>().as_uint64(); }
  bool has_memory_type() const { return at<18>().valid(); }
  uint32_t memory_type() const { return at<18>().as_uint32(); }
  bool has_heap() const { return at<19>().valid(); }
  uint32_t heap() const { return at<19>().as_uint32(); }
  bool has_object_handle() const { return at<20>().valid(); }
  uint64_t object_handle() const { return at<20>().as_uint64(); }
};

class VulkanMemoryEvent : public ::protozero::Message {
 public:
  using Decoder = VulkanMemoryEvent_Decoder;
  enum : int32_t {
    kSourceFieldNumber = 1,
    kOperationFieldNumber = 2,
    kTimestampFieldNumber = 3,
    kPidFieldNumber = 4,
    kMemoryAddressFieldNumber = 5,
    kMemorySizeFieldNumber = 6,
    kCallerIidFieldNumber = 7,
    kAllocationScopeFieldNumber = 8,
    kAnnotationsFieldNumber = 9,
    kDeviceFieldNumber = 16,
    kDeviceMemoryFieldNumber = 17,
    kMemoryTypeFieldNumber = 18,
    kHeapFieldNumber = 19,
    kObjectHandleFieldNumber = 20,
  };
  using Source = ::perfetto::protos::pbzero::VulkanMemoryEvent_Source;
  using Operation = ::perfetto::protos::pbzero::VulkanMemoryEvent_Operation;
  using AllocationScope = ::perfetto::protos::pbzero::VulkanMemoryEvent_AllocationScope;
  static const Source SOURCE_UNSPECIFIED = VulkanMemoryEvent_Source_SOURCE_UNSPECIFIED;
  static const Source SOURCE_DRIVER = VulkanMemoryEvent_Source_SOURCE_DRIVER;
  static const Source SOURCE_DEVICE = VulkanMemoryEvent_Source_SOURCE_DEVICE;
  static const Source SOURCE_DEVICE_MEMORY = VulkanMemoryEvent_Source_SOURCE_DEVICE_MEMORY;
  static const Source SOURCE_BUFFER = VulkanMemoryEvent_Source_SOURCE_BUFFER;
  static const Source SOURCE_IMAGE = VulkanMemoryEvent_Source_SOURCE_IMAGE;
  static const Operation OP_UNSPECIFIED = VulkanMemoryEvent_Operation_OP_UNSPECIFIED;
  static const Operation OP_CREATE = VulkanMemoryEvent_Operation_OP_CREATE;
  static const Operation OP_DESTROY = VulkanMemoryEvent_Operation_OP_DESTROY;
  static const Operation OP_BIND = VulkanMemoryEvent_Operation_OP_BIND;
  static const Operation OP_DESTROY_BOUND = VulkanMemoryEvent_Operation_OP_DESTROY_BOUND;
  static const Operation OP_ANNOTATIONS = VulkanMemoryEvent_Operation_OP_ANNOTATIONS;
  static const AllocationScope SCOPE_UNSPECIFIED = VulkanMemoryEvent_AllocationScope_SCOPE_UNSPECIFIED;
  static const AllocationScope SCOPE_COMMAND = VulkanMemoryEvent_AllocationScope_SCOPE_COMMAND;
  static const AllocationScope SCOPE_OBJECT = VulkanMemoryEvent_AllocationScope_SCOPE_OBJECT;
  static const AllocationScope SCOPE_CACHE = VulkanMemoryEvent_AllocationScope_SCOPE_CACHE;
  static const AllocationScope SCOPE_DEVICE = VulkanMemoryEvent_AllocationScope_SCOPE_DEVICE;
  static const AllocationScope SCOPE_INSTANCE = VulkanMemoryEvent_AllocationScope_SCOPE_INSTANCE;
  void set_source(::perfetto::protos::pbzero::VulkanMemoryEvent_Source value) {
    AppendTinyVarInt(1, value);
  }
  void set_operation(::perfetto::protos::pbzero::VulkanMemoryEvent_Operation value) {
    AppendTinyVarInt(2, value);
  }
  void set_timestamp(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_pid(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_memory_address(uint64_t value) {
    AppendFixed(5, value);
  }
  void set_memory_size(uint64_t value) {
    AppendVarInt(6, value);
  }
  void set_caller_iid(uint64_t value) {
    AppendVarInt(7, value);
  }
  void set_allocation_scope(::perfetto::protos::pbzero::VulkanMemoryEvent_AllocationScope value) {
    AppendTinyVarInt(8, value);
  }
  template <typename T = VulkanMemoryEventAnnotation> T* add_annotations() {
    return BeginNestedMessage<T>(9);
  }

  void set_device(uint64_t value) {
    AppendFixed(16, value);
  }
  void set_device_memory(uint64_t value) {
    AppendFixed(17, value);
  }
  void set_memory_type(uint32_t value) {
    AppendVarInt(18, value);
  }
  void set_heap(uint32_t value) {
    AppendVarInt(19, value);
  }
  void set_object_handle(uint64_t value) {
    AppendFixed(20, value);
  }
};

class VulkanMemoryEventAnnotation_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  VulkanMemoryEventAnnotation_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit VulkanMemoryEventAnnotation_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit VulkanMemoryEventAnnotation_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_key_iid() const { return at<1>().valid(); }
  uint64_t key_iid() const { return at<1>().as_uint64(); }
  bool has_int_value() const { return at<2>().valid(); }
  int64_t int_value() const { return at<2>().as_int64(); }
  bool has_double_value() const { return at<3>().valid(); }
  double double_value() const { return at<3>().as_double(); }
  bool has_string_iid() const { return at<4>().valid(); }
  uint64_t string_iid() const { return at<4>().as_uint64(); }
};

class VulkanMemoryEventAnnotation : public ::protozero::Message {
 public:
  using Decoder = VulkanMemoryEventAnnotation_Decoder;
  enum : int32_t {
    kKeyIidFieldNumber = 1,
    kIntValueFieldNumber = 2,
    kDoubleValueFieldNumber = 3,
    kStringIidFieldNumber = 4,
  };
  void set_key_iid(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_int_value(int64_t value) {
    AppendVarInt(2, value);
  }
  void set_double_value(double value) {
    AppendFixed(3, value);
  }
  void set_string_iid(uint64_t value) {
    AppendVarInt(4, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/profiling/heap_graph.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_PROFILING_HEAP_GRAPH_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_PROFILING_HEAP_GRAPH_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class HeapGraphObject;
class HeapGraphRoot;
class InternedString;
class ObfuscatedClass;
class ObfuscatedMember;
enum HeapGraphRoot_Type : int32_t;

enum HeapGraphRoot_Type : int32_t {
  HeapGraphRoot_Type_ROOT_UNKNOWN = 0,
  HeapGraphRoot_Type_ROOT_JNI_GLOBAL = 1,
  HeapGraphRoot_Type_ROOT_JNI_LOCAL = 2,
  HeapGraphRoot_Type_ROOT_JAVA_FRAME = 3,
  HeapGraphRoot_Type_ROOT_NATIVE_STACK = 4,
  HeapGraphRoot_Type_ROOT_STICKY_CLASS = 5,
  HeapGraphRoot_Type_ROOT_THREAD_BLOCK = 6,
  HeapGraphRoot_Type_ROOT_MONITOR_USED = 7,
  HeapGraphRoot_Type_ROOT_THREAD_OBJECT = 8,
  HeapGraphRoot_Type_ROOT_INTERNED_STRING = 9,
  HeapGraphRoot_Type_ROOT_FINALIZING = 10,
  HeapGraphRoot_Type_ROOT_DEBUGGER = 11,
  HeapGraphRoot_Type_ROOT_REFERENCE_CLEANUP = 12,
  HeapGraphRoot_Type_ROOT_VM_INTERNAL = 13,
  HeapGraphRoot_Type_ROOT_JNI_MONITOR = 14,
};

const HeapGraphRoot_Type HeapGraphRoot_Type_MIN = HeapGraphRoot_Type_ROOT_UNKNOWN;
const HeapGraphRoot_Type HeapGraphRoot_Type_MAX = HeapGraphRoot_Type_ROOT_JNI_MONITOR;

class HeapGraph_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/7, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  HeapGraph_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit HeapGraph_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit HeapGraph_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_pid() const { return at<1>().valid(); }
  int32_t pid() const { return at<1>().as_int32(); }
  bool has_objects() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> objects() const { return GetRepeated<::protozero::ConstBytes>(2); }
  bool has_roots() const { return at<7>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> roots() const { return GetRepeated<::protozero::ConstBytes>(7); }
  bool has_type_names() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> type_names() const { return GetRepeated<::protozero::ConstBytes>(3); }
  bool has_field_names() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> field_names() const { return GetRepeated<::protozero::ConstBytes>(4); }
  bool has_continued() const { return at<5>().valid(); }
  bool continued() const { return at<5>().as_bool(); }
  bool has_index() const { return at<6>().valid(); }
  uint64_t index() const { return at<6>().as_uint64(); }
};

class HeapGraph : public ::protozero::Message {
 public:
  using Decoder = HeapGraph_Decoder;
  enum : int32_t {
    kPidFieldNumber = 1,
    kObjectsFieldNumber = 2,
    kRootsFieldNumber = 7,
    kTypeNamesFieldNumber = 3,
    kFieldNamesFieldNumber = 4,
    kContinuedFieldNumber = 5,
    kIndexFieldNumber = 6,
  };
  void set_pid(int32_t value) {
    AppendVarInt(1, value);
  }
  template <typename T = HeapGraphObject> T* add_objects() {
    return BeginNestedMessage<T>(2);
  }

  template <typename T = HeapGraphRoot> T* add_roots() {
    return BeginNestedMessage<T>(7);
  }

  template <typename T = InternedString> T* add_type_names() {
    return BeginNestedMessage<T>(3);
  }

  template <typename T = InternedString> T* add_field_names() {
    return BeginNestedMessage<T>(4);
  }

  void set_continued(bool value) {
    AppendTinyVarInt(5, value);
  }
  void set_index(uint64_t value) {
    AppendVarInt(6, value);
  }
};

class HeapGraphObject_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  HeapGraphObject_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit HeapGraphObject_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit HeapGraphObject_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_id() const { return at<1>().valid(); }
  uint64_t id() const { return at<1>().as_uint64(); }
  bool has_type_id() const { return at<2>().valid(); }
  uint64_t type_id() const { return at<2>().as_uint64(); }
  bool has_self_size() const { return at<3>().valid(); }
  uint64_t self_size() const { return at<3>().as_uint64(); }
  bool has_reference_field_id() const { return at<4>().valid(); }
  ::protozero::PackedRepeatedFieldIterator<::protozero::proto_utils::ProtoWireType::kVarInt, uint64_t> reference_field_id(bool* parse_error_ptr) const { return GetPackedRepeated<::protozero::proto_utils::ProtoWireType::kVarInt, uint64_t>(4, parse_error_ptr); }
  bool has_reference_object_id() const { return at<5>().valid(); }
  ::protozero::PackedRepeatedFieldIterator<::protozero::proto_utils::ProtoWireType::kVarInt, uint64_t> reference_object_id(bool* parse_error_ptr) const { return GetPackedRepeated<::protozero::proto_utils::ProtoWireType::kVarInt, uint64_t>(5, parse_error_ptr); }
};

class HeapGraphObject : public ::protozero::Message {
 public:
  using Decoder = HeapGraphObject_Decoder;
  enum : int32_t {
    kIdFieldNumber = 1,
    kTypeIdFieldNumber = 2,
    kSelfSizeFieldNumber = 3,
    kReferenceFieldIdFieldNumber = 4,
    kReferenceObjectIdFieldNumber = 5,
  };
  void set_id(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_type_id(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_self_size(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_reference_field_id(const ::protozero::PackedVarInt& packed_buffer) {
    AppendBytes(4, packed_buffer.data(), packed_buffer.size());
  }
  void set_reference_object_id(const ::protozero::PackedVarInt& packed_buffer) {
    AppendBytes(5, packed_buffer.data(), packed_buffer.size());
  }
};

class HeapGraphRoot_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  HeapGraphRoot_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit HeapGraphRoot_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit HeapGraphRoot_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_object_ids() const { return at<1>().valid(); }
  ::protozero::PackedRepeatedFieldIterator<::protozero::proto_utils::ProtoWireType::kVarInt, uint64_t> object_ids(bool* parse_error_ptr) const { return GetPackedRepeated<::protozero::proto_utils::ProtoWireType::kVarInt, uint64_t>(1, parse_error_ptr); }
  bool has_root_type() const { return at<2>().valid(); }
  int32_t root_type() const { return at<2>().as_int32(); }
};

class HeapGraphRoot : public ::protozero::Message {
 public:
  using Decoder = HeapGraphRoot_Decoder;
  enum : int32_t {
    kObjectIdsFieldNumber = 1,
    kRootTypeFieldNumber = 2,
  };
  using Type = ::perfetto::protos::pbzero::HeapGraphRoot_Type;
  static const Type ROOT_UNKNOWN = HeapGraphRoot_Type_ROOT_UNKNOWN;
  static const Type ROOT_JNI_GLOBAL = HeapGraphRoot_Type_ROOT_JNI_GLOBAL;
  static const Type ROOT_JNI_LOCAL = HeapGraphRoot_Type_ROOT_JNI_LOCAL;
  static const Type ROOT_JAVA_FRAME = HeapGraphRoot_Type_ROOT_JAVA_FRAME;
  static const Type ROOT_NATIVE_STACK = HeapGraphRoot_Type_ROOT_NATIVE_STACK;
  static const Type ROOT_STICKY_CLASS = HeapGraphRoot_Type_ROOT_STICKY_CLASS;
  static const Type ROOT_THREAD_BLOCK = HeapGraphRoot_Type_ROOT_THREAD_BLOCK;
  static const Type ROOT_MONITOR_USED = HeapGraphRoot_Type_ROOT_MONITOR_USED;
  static const Type ROOT_THREAD_OBJECT = HeapGraphRoot_Type_ROOT_THREAD_OBJECT;
  static const Type ROOT_INTERNED_STRING = HeapGraphRoot_Type_ROOT_INTERNED_STRING;
  static const Type ROOT_FINALIZING = HeapGraphRoot_Type_ROOT_FINALIZING;
  static const Type ROOT_DEBUGGER = HeapGraphRoot_Type_ROOT_DEBUGGER;
  static const Type ROOT_REFERENCE_CLEANUP = HeapGraphRoot_Type_ROOT_REFERENCE_CLEANUP;
  static const Type ROOT_VM_INTERNAL = HeapGraphRoot_Type_ROOT_VM_INTERNAL;
  static const Type ROOT_JNI_MONITOR = HeapGraphRoot_Type_ROOT_JNI_MONITOR;
  void set_object_ids(const ::protozero::PackedVarInt& packed_buffer) {
    AppendBytes(1, packed_buffer.data(), packed_buffer.size());
  }
  void set_root_type(::perfetto::protos::pbzero::HeapGraphRoot_Type value) {
    AppendTinyVarInt(2, value);
  }
};

class DeobfuscationMapping_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  DeobfuscationMapping_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit DeobfuscationMapping_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit DeobfuscationMapping_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_package_name() const { return at<1>().valid(); }
  ::protozero::ConstChars package_name() const { return at<1>().as_string(); }
  bool has_version_code() const { return at<2>().valid(); }
  int64_t version_code() const { return at<2>().as_int64(); }
  bool has_obfuscated_classes() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> obfuscated_classes() const { return GetRepeated<::protozero::ConstBytes>(3); }
};

class DeobfuscationMapping : public ::protozero::Message {
 public:
  using Decoder = DeobfuscationMapping_Decoder;
  enum : int32_t {
    kPackageNameFieldNumber = 1,
    kVersionCodeFieldNumber = 2,
    kObfuscatedClassesFieldNumber = 3,
  };
  void set_package_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_package_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_version_code(int64_t value) {
    AppendVarInt(2, value);
  }
  template <typename T = ObfuscatedClass> T* add_obfuscated_classes() {
    return BeginNestedMessage<T>(3);
  }

};

class ObfuscatedClass_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  ObfuscatedClass_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ObfuscatedClass_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ObfuscatedClass_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_obfuscated_name() const { return at<1>().valid(); }
  ::protozero::ConstChars obfuscated_name() const { return at<1>().as_string(); }
  bool has_deobfuscated_name() const { return at<2>().valid(); }
  ::protozero::ConstChars deobfuscated_name() const { return at<2>().as_string(); }
  bool has_obfuscated_members() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> obfuscated_members() const { return GetRepeated<::protozero::ConstBytes>(3); }
};

class ObfuscatedClass : public ::protozero::Message {
 public:
  using Decoder = ObfuscatedClass_Decoder;
  enum : int32_t {
    kObfuscatedNameFieldNumber = 1,
    kDeobfuscatedNameFieldNumber = 2,
    kObfuscatedMembersFieldNumber = 3,
  };
  void set_obfuscated_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_obfuscated_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_deobfuscated_name(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void set_deobfuscated_name(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
  template <typename T = ObfuscatedMember> T* add_obfuscated_members() {
    return BeginNestedMessage<T>(3);
  }

};

class ObfuscatedMember_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ObfuscatedMember_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ObfuscatedMember_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ObfuscatedMember_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_obfuscated_name() const { return at<1>().valid(); }
  ::protozero::ConstChars obfuscated_name() const { return at<1>().as_string(); }
  bool has_deobfuscated_name() const { return at<2>().valid(); }
  ::protozero::ConstChars deobfuscated_name() const { return at<2>().as_string(); }
};

class ObfuscatedMember : public ::protozero::Message {
 public:
  using Decoder = ObfuscatedMember_Decoder;
  enum : int32_t {
    kObfuscatedNameFieldNumber = 1,
    kDeobfuscatedNameFieldNumber = 2,
  };
  void set_obfuscated_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_obfuscated_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_deobfuscated_name(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void set_deobfuscated_name(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/profiling/profile_common.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_PROFILING_PROFILE_COMMON_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_PROFILING_PROFILE_COMMON_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class AddressSymbols;
class Line;

class Callstack_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  Callstack_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Callstack_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Callstack_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_iid() const { return at<1>().valid(); }
  uint64_t iid() const { return at<1>().as_uint64(); }
  bool has_frame_ids() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<uint64_t> frame_ids() const { return GetRepeated<uint64_t>(2); }
};

class Callstack : public ::protozero::Message {
 public:
  using Decoder = Callstack_Decoder;
  enum : int32_t {
    kIidFieldNumber = 1,
    kFrameIdsFieldNumber = 2,
  };
  void set_iid(uint64_t value) {
    AppendVarInt(1, value);
  }
  void add_frame_ids(uint64_t value) {
    AppendVarInt(2, value);
  }
};

class Frame_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Frame_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Frame_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Frame_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_iid() const { return at<1>().valid(); }
  uint64_t iid() const { return at<1>().as_uint64(); }
  bool has_function_name_id() const { return at<2>().valid(); }
  uint64_t function_name_id() const { return at<2>().as_uint64(); }
  bool has_mapping_id() const { return at<3>().valid(); }
  uint64_t mapping_id() const { return at<3>().as_uint64(); }
  bool has_rel_pc() const { return at<4>().valid(); }
  uint64_t rel_pc() const { return at<4>().as_uint64(); }
};

class Frame : public ::protozero::Message {
 public:
  using Decoder = Frame_Decoder;
  enum : int32_t {
    kIidFieldNumber = 1,
    kFunctionNameIdFieldNumber = 2,
    kMappingIdFieldNumber = 3,
    kRelPcFieldNumber = 4,
  };
  void set_iid(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_function_name_id(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_mapping_id(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_rel_pc(uint64_t value) {
    AppendVarInt(4, value);
  }
};

class Mapping_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  Mapping_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Mapping_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Mapping_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_iid() const { return at<1>().valid(); }
  uint64_t iid() const { return at<1>().as_uint64(); }
  bool has_build_id() const { return at<2>().valid(); }
  uint64_t build_id() const { return at<2>().as_uint64(); }
  bool has_exact_offset() const { return at<8>().valid(); }
  uint64_t exact_offset() const { return at<8>().as_uint64(); }
  bool has_start_offset() const { return at<3>().valid(); }
  uint64_t start_offset() const { return at<3>().as_uint64(); }
  bool has_start() const { return at<4>().valid(); }
  uint64_t start() const { return at<4>().as_uint64(); }
  bool has_end() const { return at<5>().valid(); }
  uint64_t end() const { return at<5>().as_uint64(); }
  bool has_load_bias() const { return at<6>().valid(); }
  uint64_t load_bias() const { return at<6>().as_uint64(); }
  bool has_path_string_ids() const { return at<7>().valid(); }
  ::protozero::RepeatedFieldIterator<uint64_t> path_string_ids() const { return GetRepeated<uint64_t>(7); }
};

class Mapping : public ::protozero::Message {
 public:
  using Decoder = Mapping_Decoder;
  enum : int32_t {
    kIidFieldNumber = 1,
    kBuildIdFieldNumber = 2,
    kExactOffsetFieldNumber = 8,
    kStartOffsetFieldNumber = 3,
    kStartFieldNumber = 4,
    kEndFieldNumber = 5,
    kLoadBiasFieldNumber = 6,
    kPathStringIdsFieldNumber = 7,
  };
  void set_iid(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_build_id(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_exact_offset(uint64_t value) {
    AppendVarInt(8, value);
  }
  void set_start_offset(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_start(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_end(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_load_bias(uint64_t value) {
    AppendVarInt(6, value);
  }
  void add_path_string_ids(uint64_t value) {
    AppendVarInt(7, value);
  }
};

class ModuleSymbols_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  ModuleSymbols_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ModuleSymbols_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ModuleSymbols_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_path() const { return at<1>().valid(); }
  ::protozero::ConstChars path() const { return at<1>().as_string(); }
  bool has_build_id() const { return at<2>().valid(); }
  ::protozero::ConstChars build_id() const { return at<2>().as_string(); }
  bool has_address_symbols() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> address_symbols() const { return GetRepeated<::protozero::ConstBytes>(3); }
};

class ModuleSymbols : public ::protozero::Message {
 public:
  using Decoder = ModuleSymbols_Decoder;
  enum : int32_t {
    kPathFieldNumber = 1,
    kBuildIdFieldNumber = 2,
    kAddressSymbolsFieldNumber = 3,
  };
  void set_path(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_path(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_build_id(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void set_build_id(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
  template <typename T = AddressSymbols> T* add_address_symbols() {
    return BeginNestedMessage<T>(3);
  }

};

class AddressSymbols_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  AddressSymbols_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit AddressSymbols_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit AddressSymbols_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_address() const { return at<1>().valid(); }
  uint64_t address() const { return at<1>().as_uint64(); }
  bool has_lines() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> lines() const { return GetRepeated<::protozero::ConstBytes>(2); }
};

class AddressSymbols : public ::protozero::Message {
 public:
  using Decoder = AddressSymbols_Decoder;
  enum : int32_t {
    kAddressFieldNumber = 1,
    kLinesFieldNumber = 2,
  };
  void set_address(uint64_t value) {
    AppendVarInt(1, value);
  }
  template <typename T = Line> T* add_lines() {
    return BeginNestedMessage<T>(2);
  }

};

class Line_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Line_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Line_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Line_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_function_name() const { return at<1>().valid(); }
  ::protozero::ConstChars function_name() const { return at<1>().as_string(); }
  bool has_source_file_name() const { return at<2>().valid(); }
  ::protozero::ConstChars source_file_name() const { return at<2>().as_string(); }
  bool has_line_number() const { return at<3>().valid(); }
  uint32_t line_number() const { return at<3>().as_uint32(); }
};

class Line : public ::protozero::Message {
 public:
  using Decoder = Line_Decoder;
  enum : int32_t {
    kFunctionNameFieldNumber = 1,
    kSourceFileNameFieldNumber = 2,
    kLineNumberFieldNumber = 3,
  };
  void set_function_name(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_function_name(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_source_file_name(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void set_source_file_name(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
  void set_line_number(uint32_t value) {
    AppendVarInt(3, value);
  }
};

class ProfiledFrameSymbols_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  ProfiledFrameSymbols_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ProfiledFrameSymbols_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ProfiledFrameSymbols_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_frame_iid() const { return at<1>().valid(); }
  uint64_t frame_iid() const { return at<1>().as_uint64(); }
  bool has_function_name_id() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<uint64_t> function_name_id() const { return GetRepeated<uint64_t>(2); }
  bool has_file_name_id() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator<uint64_t> file_name_id() const { return GetRepeated<uint64_t>(3); }
  bool has_line_number() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator<uint32_t> line_number() const { return GetRepeated<uint32_t>(4); }
};

class ProfiledFrameSymbols : public ::protozero::Message {
 public:
  using Decoder = ProfiledFrameSymbols_Decoder;
  enum : int32_t {
    kFrameIidFieldNumber = 1,
    kFunctionNameIdFieldNumber = 2,
    kFileNameIdFieldNumber = 3,
    kLineNumberFieldNumber = 4,
  };
  void set_frame_iid(uint64_t value) {
    AppendVarInt(1, value);
  }
  void add_function_name_id(uint64_t value) {
    AppendVarInt(2, value);
  }
  void add_file_name_id(uint64_t value) {
    AppendVarInt(3, value);
  }
  void add_line_number(uint32_t value) {
    AppendVarInt(4, value);
  }
};

class InternedString_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  InternedString_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit InternedString_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit InternedString_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_iid() const { return at<1>().valid(); }
  uint64_t iid() const { return at<1>().as_uint64(); }
  bool has_str() const { return at<2>().valid(); }
  ::protozero::ConstBytes str() const { return at<2>().as_bytes(); }
};

class InternedString : public ::protozero::Message {
 public:
  using Decoder = InternedString_Decoder;
  enum : int32_t {
    kIidFieldNumber = 1,
    kStrFieldNumber = 2,
  };
  void set_iid(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_str(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void set_str(const uint8_t* data, size_t size) {
    AppendBytes(2, data, size);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/profiling/profile_packet.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_PROFILING_PROFILE_PACKET_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_PROFILING_PROFILE_PACKET_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class Callstack;
class Frame;
class InternedString;
class Mapping;
class ProfilePacket_HeapSample;
class ProfilePacket_Histogram;
class ProfilePacket_Histogram_Bucket;
class ProfilePacket_ProcessHeapSamples;
class ProfilePacket_ProcessStats;

class StreamingProfilePacket_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  StreamingProfilePacket_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit StreamingProfilePacket_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit StreamingProfilePacket_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_callstack_iid() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<uint64_t> callstack_iid() const { return GetRepeated<uint64_t>(1); }
  bool has_timestamp_delta_us() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<int64_t> timestamp_delta_us() const { return GetRepeated<int64_t>(2); }
};

class StreamingProfilePacket : public ::protozero::Message {
 public:
  using Decoder = StreamingProfilePacket_Decoder;
  enum : int32_t {
    kCallstackIidFieldNumber = 1,
    kTimestampDeltaUsFieldNumber = 2,
  };
  void add_callstack_iid(uint64_t value) {
    AppendVarInt(1, value);
  }
  void add_timestamp_delta_us(int64_t value) {
    AppendVarInt(2, value);
  }
};

class ProfilePacket_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/7, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  ProfilePacket_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ProfilePacket_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ProfilePacket_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_strings() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> strings() const { return GetRepeated<::protozero::ConstBytes>(1); }
  bool has_mappings() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> mappings() const { return GetRepeated<::protozero::ConstBytes>(4); }
  bool has_frames() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> frames() const { return GetRepeated<::protozero::ConstBytes>(2); }
  bool has_callstacks() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> callstacks() const { return GetRepeated<::protozero::ConstBytes>(3); }
  bool has_process_dumps() const { return at<5>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> process_dumps() const { return GetRepeated<::protozero::ConstBytes>(5); }
  bool has_continued() const { return at<6>().valid(); }
  bool continued() const { return at<6>().as_bool(); }
  bool has_index() const { return at<7>().valid(); }
  uint64_t index() const { return at<7>().as_uint64(); }
};

class ProfilePacket : public ::protozero::Message {
 public:
  using Decoder = ProfilePacket_Decoder;
  enum : int32_t {
    kStringsFieldNumber = 1,
    kMappingsFieldNumber = 4,
    kFramesFieldNumber = 2,
    kCallstacksFieldNumber = 3,
    kProcessDumpsFieldNumber = 5,
    kContinuedFieldNumber = 6,
    kIndexFieldNumber = 7,
  };
  using HeapSample = ::perfetto::protos::pbzero::ProfilePacket_HeapSample;
  using Histogram = ::perfetto::protos::pbzero::ProfilePacket_Histogram;
  using ProcessStats = ::perfetto::protos::pbzero::ProfilePacket_ProcessStats;
  using ProcessHeapSamples = ::perfetto::protos::pbzero::ProfilePacket_ProcessHeapSamples;
  template <typename T = InternedString> T* add_strings() {
    return BeginNestedMessage<T>(1);
  }

  template <typename T = Mapping> T* add_mappings() {
    return BeginNestedMessage<T>(4);
  }

  template <typename T = Frame> T* add_frames() {
    return BeginNestedMessage<T>(2);
  }

  template <typename T = Callstack> T* add_callstacks() {
    return BeginNestedMessage<T>(3);
  }

  template <typename T = ProfilePacket_ProcessHeapSamples> T* add_process_dumps() {
    return BeginNestedMessage<T>(5);
  }

  void set_continued(bool value) {
    AppendTinyVarInt(6, value);
  }
  void set_index(uint64_t value) {
    AppendVarInt(7, value);
  }
};

class ProfilePacket_ProcessHeapSamples_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/9, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  ProfilePacket_ProcessHeapSamples_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ProfilePacket_ProcessHeapSamples_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ProfilePacket_ProcessHeapSamples_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_pid() const { return at<1>().valid(); }
  uint64_t pid() const { return at<1>().as_uint64(); }
  bool has_from_startup() const { return at<3>().valid(); }
  bool from_startup() const { return at<3>().as_bool(); }
  bool has_rejected_concurrent() const { return at<4>().valid(); }
  bool rejected_concurrent() const { return at<4>().as_bool(); }
  bool has_disconnected() const { return at<6>().valid(); }
  bool disconnected() const { return at<6>().as_bool(); }
  bool has_buffer_overran() const { return at<7>().valid(); }
  bool buffer_overran() const { return at<7>().as_bool(); }
  bool has_buffer_corrupted() const { return at<8>().valid(); }
  bool buffer_corrupted() const { return at<8>().as_bool(); }
  bool has_timestamp() const { return at<9>().valid(); }
  uint64_t timestamp() const { return at<9>().as_uint64(); }
  bool has_stats() const { return at<5>().valid(); }
  ::protozero::ConstBytes stats() const { return at<5>().as_bytes(); }
  bool has_samples() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> samples() const { return GetRepeated<::protozero::ConstBytes>(2); }
};

class ProfilePacket_ProcessHeapSamples : public ::protozero::Message {
 public:
  using Decoder = ProfilePacket_ProcessHeapSamples_Decoder;
  enum : int32_t {
    kPidFieldNumber = 1,
    kFromStartupFieldNumber = 3,
    kRejectedConcurrentFieldNumber = 4,
    kDisconnectedFieldNumber = 6,
    kBufferOverranFieldNumber = 7,
    kBufferCorruptedFieldNumber = 8,
    kTimestampFieldNumber = 9,
    kStatsFieldNumber = 5,
    kSamplesFieldNumber = 2,
  };
  void set_pid(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_from_startup(bool value) {
    AppendTinyVarInt(3, value);
  }
  void set_rejected_concurrent(bool value) {
    AppendTinyVarInt(4, value);
  }
  void set_disconnected(bool value) {
    AppendTinyVarInt(6, value);
  }
  void set_buffer_overran(bool value) {
    AppendTinyVarInt(7, value);
  }
  void set_buffer_corrupted(bool value) {
    AppendTinyVarInt(8, value);
  }
  void set_timestamp(uint64_t value) {
    AppendVarInt(9, value);
  }
  template <typename T = ProfilePacket_ProcessStats> T* set_stats() {
    return BeginNestedMessage<T>(5);
  }

  template <typename T = ProfilePacket_HeapSample> T* add_samples() {
    return BeginNestedMessage<T>(2);
  }

};

class ProfilePacket_ProcessStats_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ProfilePacket_ProcessStats_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ProfilePacket_ProcessStats_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ProfilePacket_ProcessStats_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_unwinding_errors() const { return at<1>().valid(); }
  uint64_t unwinding_errors() const { return at<1>().as_uint64(); }
  bool has_heap_samples() const { return at<2>().valid(); }
  uint64_t heap_samples() const { return at<2>().as_uint64(); }
  bool has_map_reparses() const { return at<3>().valid(); }
  uint64_t map_reparses() const { return at<3>().as_uint64(); }
  bool has_unwinding_time_us() const { return at<4>().valid(); }
  ::protozero::ConstBytes unwinding_time_us() const { return at<4>().as_bytes(); }
  bool has_total_unwinding_time_us() const { return at<5>().valid(); }
  uint64_t total_unwinding_time_us() const { return at<5>().as_uint64(); }
};

class ProfilePacket_ProcessStats : public ::protozero::Message {
 public:
  using Decoder = ProfilePacket_ProcessStats_Decoder;
  enum : int32_t {
    kUnwindingErrorsFieldNumber = 1,
    kHeapSamplesFieldNumber = 2,
    kMapReparsesFieldNumber = 3,
    kUnwindingTimeUsFieldNumber = 4,
    kTotalUnwindingTimeUsFieldNumber = 5,
  };
  void set_unwinding_errors(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_heap_samples(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_map_reparses(uint64_t value) {
    AppendVarInt(3, value);
  }
  template <typename T = ProfilePacket_Histogram> T* set_unwinding_time_us() {
    return BeginNestedMessage<T>(4);
  }

  void set_total_unwinding_time_us(uint64_t value) {
    AppendVarInt(5, value);
  }
};

class ProfilePacket_Histogram_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  ProfilePacket_Histogram_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ProfilePacket_Histogram_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ProfilePacket_Histogram_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_buckets() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> buckets() const { return GetRepeated<::protozero::ConstBytes>(1); }
};

class ProfilePacket_Histogram : public ::protozero::Message {
 public:
  using Decoder = ProfilePacket_Histogram_Decoder;
  enum : int32_t {
    kBucketsFieldNumber = 1,
  };
  using Bucket = ::perfetto::protos::pbzero::ProfilePacket_Histogram_Bucket;
  template <typename T = ProfilePacket_Histogram_Bucket> T* add_buckets() {
    return BeginNestedMessage<T>(1);
  }

};

class ProfilePacket_Histogram_Bucket_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ProfilePacket_Histogram_Bucket_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ProfilePacket_Histogram_Bucket_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ProfilePacket_Histogram_Bucket_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_upper_limit() const { return at<1>().valid(); }
  uint64_t upper_limit() const { return at<1>().as_uint64(); }
  bool has_max_bucket() const { return at<2>().valid(); }
  bool max_bucket() const { return at<2>().as_bool(); }
  bool has_count() const { return at<3>().valid(); }
  uint64_t count() const { return at<3>().as_uint64(); }
};

class ProfilePacket_Histogram_Bucket : public ::protozero::Message {
 public:
  using Decoder = ProfilePacket_Histogram_Bucket_Decoder;
  enum : int32_t {
    kUpperLimitFieldNumber = 1,
    kMaxBucketFieldNumber = 2,
    kCountFieldNumber = 3,
  };
  void set_upper_limit(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_max_bucket(bool value) {
    AppendTinyVarInt(2, value);
  }
  void set_count(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class ProfilePacket_HeapSample_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ProfilePacket_HeapSample_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ProfilePacket_HeapSample_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ProfilePacket_HeapSample_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_callstack_id() const { return at<1>().valid(); }
  uint64_t callstack_id() const { return at<1>().as_uint64(); }
  bool has_self_allocated() const { return at<2>().valid(); }
  uint64_t self_allocated() const { return at<2>().as_uint64(); }
  bool has_self_freed() const { return at<3>().valid(); }
  uint64_t self_freed() const { return at<3>().as_uint64(); }
  bool has_self_idle() const { return at<7>().valid(); }
  uint64_t self_idle() const { return at<7>().as_uint64(); }
  bool has_self_max() const { return at<8>().valid(); }
  uint64_t self_max() const { return at<8>().as_uint64(); }
  bool has_timestamp() const { return at<4>().valid(); }
  uint64_t timestamp() const { return at<4>().as_uint64(); }
  bool has_alloc_count() const { return at<5>().valid(); }
  uint64_t alloc_count() const { return at<5>().as_uint64(); }
  bool has_free_count() const { return at<6>().valid(); }
  uint64_t free_count() const { return at<6>().as_uint64(); }
};

class ProfilePacket_HeapSample : public ::protozero::Message {
 public:
  using Decoder = ProfilePacket_HeapSample_Decoder;
  enum : int32_t {
    kCallstackIdFieldNumber = 1,
    kSelfAllocatedFieldNumber = 2,
    kSelfFreedFieldNumber = 3,
    kSelfIdleFieldNumber = 7,
    kSelfMaxFieldNumber = 8,
    kTimestampFieldNumber = 4,
    kAllocCountFieldNumber = 5,
    kFreeCountFieldNumber = 6,
  };
  void set_callstack_id(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_self_allocated(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_self_freed(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_self_idle(uint64_t value) {
    AppendVarInt(7, value);
  }
  void set_self_max(uint64_t value) {
    AppendVarInt(8, value);
  }
  void set_timestamp(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_alloc_count(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_free_count(uint64_t value) {
    AppendVarInt(6, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/track_event/debug_annotation.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACK_EVENT_DEBUG_ANNOTATION_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACK_EVENT_DEBUG_ANNOTATION_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class DebugAnnotation_NestedValue;
enum DebugAnnotation_NestedValue_NestedType : int32_t;

enum DebugAnnotation_NestedValue_NestedType : int32_t {
  DebugAnnotation_NestedValue_NestedType_UNSPECIFIED = 0,
  DebugAnnotation_NestedValue_NestedType_DICT = 1,
  DebugAnnotation_NestedValue_NestedType_ARRAY = 2,
};

const DebugAnnotation_NestedValue_NestedType DebugAnnotation_NestedValue_NestedType_MIN = DebugAnnotation_NestedValue_NestedType_UNSPECIFIED;
const DebugAnnotation_NestedValue_NestedType DebugAnnotation_NestedValue_NestedType_MAX = DebugAnnotation_NestedValue_NestedType_ARRAY;

class DebugAnnotationName_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  DebugAnnotationName_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit DebugAnnotationName_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit DebugAnnotationName_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_iid() const { return at<1>().valid(); }
  uint64_t iid() const { return at<1>().as_uint64(); }
  bool has_name() const { return at<2>().valid(); }
  ::protozero::ConstChars name() const { return at<2>().as_string(); }
};

class DebugAnnotationName : public ::protozero::Message {
 public:
  using Decoder = DebugAnnotationName_Decoder;
  enum : int32_t {
    kIidFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  void set_iid(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_name(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void set_name(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
};

class DebugAnnotation_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/10, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  DebugAnnotation_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit DebugAnnotation_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit DebugAnnotation_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name_iid() const { return at<1>().valid(); }
  uint64_t name_iid() const { return at<1>().as_uint64(); }
  bool has_name() const { return at<10>().valid(); }
  ::protozero::ConstChars name() const { return at<10>().as_string(); }
  bool has_bool_value() const { return at<2>().valid(); }
  bool bool_value() const { return at<2>().as_bool(); }
  bool has_uint_value() const { return at<3>().valid(); }
  uint64_t uint_value() const { return at<3>().as_uint64(); }
  bool has_int_value() const { return at<4>().valid(); }
  int64_t int_value() const { return at<4>().as_int64(); }
  bool has_double_value() const { return at<5>().valid(); }
  double double_value() const { return at<5>().as_double(); }
  bool has_string_value() const { return at<6>().valid(); }
  ::protozero::ConstChars string_value() const { return at<6>().as_string(); }
  bool has_pointer_value() const { return at<7>().valid(); }
  uint64_t pointer_value() const { return at<7>().as_uint64(); }
  bool has_nested_value() const { return at<8>().valid(); }
  ::protozero::ConstBytes nested_value() const { return at<8>().as_bytes(); }
  bool has_legacy_json_value() const { return at<9>().valid(); }
  ::protozero::ConstChars legacy_json_value() const { return at<9>().as_string(); }
};

class DebugAnnotation : public ::protozero::Message {
 public:
  using Decoder = DebugAnnotation_Decoder;
  enum : int32_t {
    kNameIidFieldNumber = 1,
    kNameFieldNumber = 10,
    kBoolValueFieldNumber = 2,
    kUintValueFieldNumber = 3,
    kIntValueFieldNumber = 4,
    kDoubleValueFieldNumber = 5,
    kStringValueFieldNumber = 6,
    kPointerValueFieldNumber = 7,
    kNestedValueFieldNumber = 8,
    kLegacyJsonValueFieldNumber = 9,
  };
  using NestedValue = ::perfetto::protos::pbzero::DebugAnnotation_NestedValue;
  void set_name_iid(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_name(const std::string& value) {
    AppendBytes(10, value.data(), value.size());
  }
  void set_name(const char* data, size_t size) {
    AppendBytes(10, data, size);
  }
  void set_bool_value(bool value) {
    AppendTinyVarInt(2, value);
  }
  void set_uint_value(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_int_value(int64_t value) {
    AppendVarInt(4, value);
  }
  void set_double_value(double value) {
    AppendFixed(5, value);
  }
  void set_string_value(const std::string& value) {
    AppendBytes(6, value.data(), value.size());
  }
  void set_string_value(const char* data, size_t size) {
    AppendBytes(6, data, size);
  }
  void set_pointer_value(uint64_t value) {
    AppendVarInt(7, value);
  }
  template <typename T = DebugAnnotation_NestedValue> T* set_nested_value() {
    return BeginNestedMessage<T>(8);
  }

  void set_legacy_json_value(const std::string& value) {
    AppendBytes(9, value.data(), value.size());
  }
  void set_legacy_json_value(const char* data, size_t size) {
    AppendBytes(9, data, size);
  }
};

class DebugAnnotation_NestedValue_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  DebugAnnotation_NestedValue_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit DebugAnnotation_NestedValue_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit DebugAnnotation_NestedValue_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_nested_type() const { return at<1>().valid(); }
  int32_t nested_type() const { return at<1>().as_int32(); }
  bool has_dict_keys() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstChars> dict_keys() const { return GetRepeated<::protozero::ConstChars>(2); }
  bool has_dict_values() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> dict_values() const { return GetRepeated<::protozero::ConstBytes>(3); }
  bool has_array_values() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> array_values() const { return GetRepeated<::protozero::ConstBytes>(4); }
  bool has_int_value() const { return at<5>().valid(); }
  int64_t int_value() const { return at<5>().as_int64(); }
  bool has_double_value() const { return at<6>().valid(); }
  double double_value() const { return at<6>().as_double(); }
  bool has_bool_value() const { return at<7>().valid(); }
  bool bool_value() const { return at<7>().as_bool(); }
  bool has_string_value() const { return at<8>().valid(); }
  ::protozero::ConstChars string_value() const { return at<8>().as_string(); }
};

class DebugAnnotation_NestedValue : public ::protozero::Message {
 public:
  using Decoder = DebugAnnotation_NestedValue_Decoder;
  enum : int32_t {
    kNestedTypeFieldNumber = 1,
    kDictKeysFieldNumber = 2,
    kDictValuesFieldNumber = 3,
    kArrayValuesFieldNumber = 4,
    kIntValueFieldNumber = 5,
    kDoubleValueFieldNumber = 6,
    kBoolValueFieldNumber = 7,
    kStringValueFieldNumber = 8,
  };
  using NestedType = ::perfetto::protos::pbzero::DebugAnnotation_NestedValue_NestedType;
  static const NestedType UNSPECIFIED = DebugAnnotation_NestedValue_NestedType_UNSPECIFIED;
  static const NestedType DICT = DebugAnnotation_NestedValue_NestedType_DICT;
  static const NestedType ARRAY = DebugAnnotation_NestedValue_NestedType_ARRAY;
  void set_nested_type(::perfetto::protos::pbzero::DebugAnnotation_NestedValue_NestedType value) {
    AppendTinyVarInt(1, value);
  }
  void add_dict_keys(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void add_dict_keys(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
  template <typename T = DebugAnnotation_NestedValue> T* add_dict_values() {
    return BeginNestedMessage<T>(3);
  }

  template <typename T = DebugAnnotation_NestedValue> T* add_array_values() {
    return BeginNestedMessage<T>(4);
  }

  void set_int_value(int64_t value) {
    AppendVarInt(5, value);
  }
  void set_double_value(double value) {
    AppendFixed(6, value);
  }
  void set_bool_value(bool value) {
    AppendTinyVarInt(7, value);
  }
  void set_string_value(const std::string& value) {
    AppendBytes(8, value.data(), value.size());
  }
  void set_string_value(const char* data, size_t size) {
    AppendBytes(8, data, size);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/track_event/log_message.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACK_EVENT_LOG_MESSAGE_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACK_EVENT_LOG_MESSAGE_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class LogMessageBody_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  LogMessageBody_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit LogMessageBody_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit LogMessageBody_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_iid() const { return at<1>().valid(); }
  uint64_t iid() const { return at<1>().as_uint64(); }
  bool has_body() const { return at<2>().valid(); }
  ::protozero::ConstChars body() const { return at<2>().as_string(); }
};

class LogMessageBody : public ::protozero::Message {
 public:
  using Decoder = LogMessageBody_Decoder;
  enum : int32_t {
    kIidFieldNumber = 1,
    kBodyFieldNumber = 2,
  };
  void set_iid(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_body(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void set_body(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
};

class LogMessage_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  LogMessage_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit LogMessage_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit LogMessage_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_source_location_iid() const { return at<1>().valid(); }
  uint64_t source_location_iid() const { return at<1>().as_uint64(); }
  bool has_body_iid() const { return at<2>().valid(); }
  uint64_t body_iid() const { return at<2>().as_uint64(); }
};

class LogMessage : public ::protozero::Message {
 public:
  using Decoder = LogMessage_Decoder;
  enum : int32_t {
    kSourceLocationIidFieldNumber = 1,
    kBodyIidFieldNumber = 2,
  };
  void set_source_location_iid(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_body_iid(uint64_t value) {
    AppendVarInt(2, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/track_event/process_descriptor.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACK_EVENT_PROCESS_DESCRIPTOR_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACK_EVENT_PROCESS_DESCRIPTOR_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

enum ProcessDescriptor_ChromeProcessType : int32_t;

enum ProcessDescriptor_ChromeProcessType : int32_t {
  ProcessDescriptor_ChromeProcessType_PROCESS_UNSPECIFIED = 0,
  ProcessDescriptor_ChromeProcessType_PROCESS_BROWSER = 1,
  ProcessDescriptor_ChromeProcessType_PROCESS_RENDERER = 2,
  ProcessDescriptor_ChromeProcessType_PROCESS_UTILITY = 3,
  ProcessDescriptor_ChromeProcessType_PROCESS_ZYGOTE = 4,
  ProcessDescriptor_ChromeProcessType_PROCESS_SANDBOX_HELPER = 5,
  ProcessDescriptor_ChromeProcessType_PROCESS_GPU = 6,
  ProcessDescriptor_ChromeProcessType_PROCESS_PPAPI_PLUGIN = 7,
  ProcessDescriptor_ChromeProcessType_PROCESS_PPAPI_BROKER = 8,
};

const ProcessDescriptor_ChromeProcessType ProcessDescriptor_ChromeProcessType_MIN = ProcessDescriptor_ChromeProcessType_PROCESS_UNSPECIFIED;
const ProcessDescriptor_ChromeProcessType ProcessDescriptor_ChromeProcessType_MAX = ProcessDescriptor_ChromeProcessType_PROCESS_PPAPI_BROKER;

class ProcessDescriptor_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  ProcessDescriptor_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ProcessDescriptor_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ProcessDescriptor_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_pid() const { return at<1>().valid(); }
  int32_t pid() const { return at<1>().as_int32(); }
  bool has_cmdline() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstChars> cmdline() const { return GetRepeated<::protozero::ConstChars>(2); }
  bool has_chrome_process_type() const { return at<4>().valid(); }
  int32_t chrome_process_type() const { return at<4>().as_int32(); }
  bool has_process_priority() const { return at<5>().valid(); }
  int32_t process_priority() const { return at<5>().as_int32(); }
  bool has_legacy_sort_index() const { return at<3>().valid(); }
  int32_t legacy_sort_index() const { return at<3>().as_int32(); }
};

class ProcessDescriptor : public ::protozero::Message {
 public:
  using Decoder = ProcessDescriptor_Decoder;
  enum : int32_t {
    kPidFieldNumber = 1,
    kCmdlineFieldNumber = 2,
    kChromeProcessTypeFieldNumber = 4,
    kProcessPriorityFieldNumber = 5,
    kLegacySortIndexFieldNumber = 3,
  };
  using ChromeProcessType = ::perfetto::protos::pbzero::ProcessDescriptor_ChromeProcessType;
  static const ChromeProcessType PROCESS_UNSPECIFIED = ProcessDescriptor_ChromeProcessType_PROCESS_UNSPECIFIED;
  static const ChromeProcessType PROCESS_BROWSER = ProcessDescriptor_ChromeProcessType_PROCESS_BROWSER;
  static const ChromeProcessType PROCESS_RENDERER = ProcessDescriptor_ChromeProcessType_PROCESS_RENDERER;
  static const ChromeProcessType PROCESS_UTILITY = ProcessDescriptor_ChromeProcessType_PROCESS_UTILITY;
  static const ChromeProcessType PROCESS_ZYGOTE = ProcessDescriptor_ChromeProcessType_PROCESS_ZYGOTE;
  static const ChromeProcessType PROCESS_SANDBOX_HELPER = ProcessDescriptor_ChromeProcessType_PROCESS_SANDBOX_HELPER;
  static const ChromeProcessType PROCESS_GPU = ProcessDescriptor_ChromeProcessType_PROCESS_GPU;
  static const ChromeProcessType PROCESS_PPAPI_PLUGIN = ProcessDescriptor_ChromeProcessType_PROCESS_PPAPI_PLUGIN;
  static const ChromeProcessType PROCESS_PPAPI_BROKER = ProcessDescriptor_ChromeProcessType_PROCESS_PPAPI_BROKER;
  void set_pid(int32_t value) {
    AppendVarInt(1, value);
  }
  void add_cmdline(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void add_cmdline(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
  void set_chrome_process_type(::perfetto::protos::pbzero::ProcessDescriptor_ChromeProcessType value) {
    AppendTinyVarInt(4, value);
  }
  void set_process_priority(int32_t value) {
    AppendVarInt(5, value);
  }
  void set_legacy_sort_index(int32_t value) {
    AppendVarInt(3, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/track_event/source_location.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACK_EVENT_SOURCE_LOCATION_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACK_EVENT_SOURCE_LOCATION_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class SourceLocation_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SourceLocation_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SourceLocation_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SourceLocation_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_iid() const { return at<1>().valid(); }
  uint64_t iid() const { return at<1>().as_uint64(); }
  bool has_file_name() const { return at<2>().valid(); }
  ::protozero::ConstChars file_name() const { return at<2>().as_string(); }
  bool has_function_name() const { return at<3>().valid(); }
  ::protozero::ConstChars function_name() const { return at<3>().as_string(); }
  bool has_line_number() const { return at<4>().valid(); }
  uint32_t line_number() const { return at<4>().as_uint32(); }
};

class SourceLocation : public ::protozero::Message {
 public:
  using Decoder = SourceLocation_Decoder;
  enum : int32_t {
    kIidFieldNumber = 1,
    kFileNameFieldNumber = 2,
    kFunctionNameFieldNumber = 3,
    kLineNumberFieldNumber = 4,
  };
  void set_iid(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_file_name(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void set_file_name(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
  void set_function_name(const std::string& value) {
    AppendBytes(3, value.data(), value.size());
  }
  void set_function_name(const char* data, size_t size) {
    AppendBytes(3, data, size);
  }
  void set_line_number(uint32_t value) {
    AppendVarInt(4, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/track_event/task_execution.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACK_EVENT_TASK_EXECUTION_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACK_EVENT_TASK_EXECUTION_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class TaskExecution_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TaskExecution_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TaskExecution_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TaskExecution_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_posted_from_iid() const { return at<1>().valid(); }
  uint64_t posted_from_iid() const { return at<1>().as_uint64(); }
};

class TaskExecution : public ::protozero::Message {
 public:
  using Decoder = TaskExecution_Decoder;
  enum : int32_t {
    kPostedFromIidFieldNumber = 1,
  };
  void set_posted_from_iid(uint64_t value) {
    AppendVarInt(1, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/track_event/thread_descriptor.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACK_EVENT_THREAD_DESCRIPTOR_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACK_EVENT_THREAD_DESCRIPTOR_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

enum ThreadDescriptor_ChromeThreadType : int32_t;

enum ThreadDescriptor_ChromeThreadType : int32_t {
  ThreadDescriptor_ChromeThreadType_CHROME_THREAD_UNSPECIFIED = 0,
  ThreadDescriptor_ChromeThreadType_CHROME_THREAD_MAIN = 1,
  ThreadDescriptor_ChromeThreadType_CHROME_THREAD_IO = 2,
  ThreadDescriptor_ChromeThreadType_CHROME_THREAD_POOL_BG_WORKER = 3,
  ThreadDescriptor_ChromeThreadType_CHROME_THREAD_POOL_FG_WORKER = 4,
  ThreadDescriptor_ChromeThreadType_CHROME_THREAD_POOL_FB_BLOCKING = 5,
  ThreadDescriptor_ChromeThreadType_CHROME_THREAD_POOL_BG_BLOCKING = 6,
  ThreadDescriptor_ChromeThreadType_CHROME_THREAD_POOL_SERVICE = 7,
  ThreadDescriptor_ChromeThreadType_CHROME_THREAD_COMPOSITOR = 8,
  ThreadDescriptor_ChromeThreadType_CHROME_THREAD_VIZ_COMPOSITOR = 9,
  ThreadDescriptor_ChromeThreadType_CHROME_THREAD_COMPOSITOR_WORKER = 10,
  ThreadDescriptor_ChromeThreadType_CHROME_THREAD_SERVICE_WORKER = 11,
  ThreadDescriptor_ChromeThreadType_CHROME_THREAD_MEMORY_INFRA = 50,
  ThreadDescriptor_ChromeThreadType_CHROME_THREAD_SAMPLING_PROFILER = 51,
};

const ThreadDescriptor_ChromeThreadType ThreadDescriptor_ChromeThreadType_MIN = ThreadDescriptor_ChromeThreadType_CHROME_THREAD_UNSPECIFIED;
const ThreadDescriptor_ChromeThreadType ThreadDescriptor_ChromeThreadType_MAX = ThreadDescriptor_ChromeThreadType_CHROME_THREAD_SAMPLING_PROFILER;

class ThreadDescriptor_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ThreadDescriptor_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ThreadDescriptor_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ThreadDescriptor_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_pid() const { return at<1>().valid(); }
  int32_t pid() const { return at<1>().as_int32(); }
  bool has_tid() const { return at<2>().valid(); }
  int32_t tid() const { return at<2>().as_int32(); }
  bool has_thread_name() const { return at<5>().valid(); }
  ::protozero::ConstChars thread_name() const { return at<5>().as_string(); }
  bool has_chrome_thread_type() const { return at<4>().valid(); }
  int32_t chrome_thread_type() const { return at<4>().as_int32(); }
  bool has_reference_timestamp_us() const { return at<6>().valid(); }
  int64_t reference_timestamp_us() const { return at<6>().as_int64(); }
  bool has_reference_thread_time_us() const { return at<7>().valid(); }
  int64_t reference_thread_time_us() const { return at<7>().as_int64(); }
  bool has_reference_thread_instruction_count() const { return at<8>().valid(); }
  int64_t reference_thread_instruction_count() const { return at<8>().as_int64(); }
  bool has_legacy_sort_index() const { return at<3>().valid(); }
  int32_t legacy_sort_index() const { return at<3>().as_int32(); }
};

class ThreadDescriptor : public ::protozero::Message {
 public:
  using Decoder = ThreadDescriptor_Decoder;
  enum : int32_t {
    kPidFieldNumber = 1,
    kTidFieldNumber = 2,
    kThreadNameFieldNumber = 5,
    kChromeThreadTypeFieldNumber = 4,
    kReferenceTimestampUsFieldNumber = 6,
    kReferenceThreadTimeUsFieldNumber = 7,
    kReferenceThreadInstructionCountFieldNumber = 8,
    kLegacySortIndexFieldNumber = 3,
  };
  using ChromeThreadType = ::perfetto::protos::pbzero::ThreadDescriptor_ChromeThreadType;
  static const ChromeThreadType CHROME_THREAD_UNSPECIFIED = ThreadDescriptor_ChromeThreadType_CHROME_THREAD_UNSPECIFIED;
  static const ChromeThreadType CHROME_THREAD_MAIN = ThreadDescriptor_ChromeThreadType_CHROME_THREAD_MAIN;
  static const ChromeThreadType CHROME_THREAD_IO = ThreadDescriptor_ChromeThreadType_CHROME_THREAD_IO;
  static const ChromeThreadType CHROME_THREAD_POOL_BG_WORKER = ThreadDescriptor_ChromeThreadType_CHROME_THREAD_POOL_BG_WORKER;
  static const ChromeThreadType CHROME_THREAD_POOL_FG_WORKER = ThreadDescriptor_ChromeThreadType_CHROME_THREAD_POOL_FG_WORKER;
  static const ChromeThreadType CHROME_THREAD_POOL_FB_BLOCKING = ThreadDescriptor_ChromeThreadType_CHROME_THREAD_POOL_FB_BLOCKING;
  static const ChromeThreadType CHROME_THREAD_POOL_BG_BLOCKING = ThreadDescriptor_ChromeThreadType_CHROME_THREAD_POOL_BG_BLOCKING;
  static const ChromeThreadType CHROME_THREAD_POOL_SERVICE = ThreadDescriptor_ChromeThreadType_CHROME_THREAD_POOL_SERVICE;
  static const ChromeThreadType CHROME_THREAD_COMPOSITOR = ThreadDescriptor_ChromeThreadType_CHROME_THREAD_COMPOSITOR;
  static const ChromeThreadType CHROME_THREAD_VIZ_COMPOSITOR = ThreadDescriptor_ChromeThreadType_CHROME_THREAD_VIZ_COMPOSITOR;
  static const ChromeThreadType CHROME_THREAD_COMPOSITOR_WORKER = ThreadDescriptor_ChromeThreadType_CHROME_THREAD_COMPOSITOR_WORKER;
  static const ChromeThreadType CHROME_THREAD_SERVICE_WORKER = ThreadDescriptor_ChromeThreadType_CHROME_THREAD_SERVICE_WORKER;
  static const ChromeThreadType CHROME_THREAD_MEMORY_INFRA = ThreadDescriptor_ChromeThreadType_CHROME_THREAD_MEMORY_INFRA;
  static const ChromeThreadType CHROME_THREAD_SAMPLING_PROFILER = ThreadDescriptor_ChromeThreadType_CHROME_THREAD_SAMPLING_PROFILER;
  void set_pid(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_tid(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_thread_name(const std::string& value) {
    AppendBytes(5, value.data(), value.size());
  }
  void set_thread_name(const char* data, size_t size) {
    AppendBytes(5, data, size);
  }
  void set_chrome_thread_type(::perfetto::protos::pbzero::ThreadDescriptor_ChromeThreadType value) {
    AppendTinyVarInt(4, value);
  }
  void set_reference_timestamp_us(int64_t value) {
    AppendVarInt(6, value);
  }
  void set_reference_thread_time_us(int64_t value) {
    AppendVarInt(7, value);
  }
  void set_reference_thread_instruction_count(int64_t value) {
    AppendVarInt(8, value);
  }
  void set_legacy_sort_index(int32_t value) {
    AppendVarInt(3, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/track_event/track_descriptor.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACK_EVENT_TRACK_DESCRIPTOR_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACK_EVENT_TRACK_DESCRIPTOR_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class ProcessDescriptor;
class ThreadDescriptor;

class TrackDescriptor_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TrackDescriptor_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TrackDescriptor_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TrackDescriptor_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_uuid() const { return at<1>().valid(); }
  uint64_t uuid() const { return at<1>().as_uint64(); }
  bool has_name() const { return at<2>().valid(); }
  ::protozero::ConstChars name() const { return at<2>().as_string(); }
  bool has_process() const { return at<3>().valid(); }
  ::protozero::ConstBytes process() const { return at<3>().as_bytes(); }
  bool has_thread() const { return at<4>().valid(); }
  ::protozero::ConstBytes thread() const { return at<4>().as_bytes(); }
};

class TrackDescriptor : public ::protozero::Message {
 public:
  using Decoder = TrackDescriptor_Decoder;
  enum : int32_t {
    kUuidFieldNumber = 1,
    kNameFieldNumber = 2,
    kProcessFieldNumber = 3,
    kThreadFieldNumber = 4,
  };
  void set_uuid(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_name(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void set_name(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
  template <typename T = ProcessDescriptor> T* set_process() {
    return BeginNestedMessage<T>(3);
  }

  template <typename T = ThreadDescriptor> T* set_thread() {
    return BeginNestedMessage<T>(4);
  }

};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/track_event/track_event.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACK_EVENT_TRACK_EVENT_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACK_EVENT_TRACK_EVENT_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class DebugAnnotation;
class LogMessage;
class TaskExecution;
class TrackEvent_LegacyEvent;
enum TrackEvent_LegacyEvent_FlowDirection : int32_t;
enum TrackEvent_LegacyEvent_InstantEventScope : int32_t;
enum TrackEvent_Type : int32_t;

enum TrackEvent_Type : int32_t {
  TrackEvent_Type_TYPE_UNSPECIFIED = 0,
  TrackEvent_Type_TYPE_SLICE_BEGIN = 1,
  TrackEvent_Type_TYPE_SLICE_END = 2,
  TrackEvent_Type_TYPE_INSTANT = 3,
};

const TrackEvent_Type TrackEvent_Type_MIN = TrackEvent_Type_TYPE_UNSPECIFIED;
const TrackEvent_Type TrackEvent_Type_MAX = TrackEvent_Type_TYPE_INSTANT;

enum TrackEvent_LegacyEvent_FlowDirection : int32_t {
  TrackEvent_LegacyEvent_FlowDirection_FLOW_UNSPECIFIED = 0,
  TrackEvent_LegacyEvent_FlowDirection_FLOW_IN = 1,
  TrackEvent_LegacyEvent_FlowDirection_FLOW_OUT = 2,
  TrackEvent_LegacyEvent_FlowDirection_FLOW_INOUT = 3,
};

const TrackEvent_LegacyEvent_FlowDirection TrackEvent_LegacyEvent_FlowDirection_MIN = TrackEvent_LegacyEvent_FlowDirection_FLOW_UNSPECIFIED;
const TrackEvent_LegacyEvent_FlowDirection TrackEvent_LegacyEvent_FlowDirection_MAX = TrackEvent_LegacyEvent_FlowDirection_FLOW_INOUT;

enum TrackEvent_LegacyEvent_InstantEventScope : int32_t {
  TrackEvent_LegacyEvent_InstantEventScope_SCOPE_UNSPECIFIED = 0,
  TrackEvent_LegacyEvent_InstantEventScope_SCOPE_GLOBAL = 1,
  TrackEvent_LegacyEvent_InstantEventScope_SCOPE_PROCESS = 2,
  TrackEvent_LegacyEvent_InstantEventScope_SCOPE_THREAD = 3,
};

const TrackEvent_LegacyEvent_InstantEventScope TrackEvent_LegacyEvent_InstantEventScope_MIN = TrackEvent_LegacyEvent_InstantEventScope_SCOPE_UNSPECIFIED;
const TrackEvent_LegacyEvent_InstantEventScope TrackEvent_LegacyEvent_InstantEventScope_MAX = TrackEvent_LegacyEvent_InstantEventScope_SCOPE_THREAD;

class EventName_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  EventName_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit EventName_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit EventName_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_iid() const { return at<1>().valid(); }
  uint64_t iid() const { return at<1>().as_uint64(); }
  bool has_name() const { return at<2>().valid(); }
  ::protozero::ConstChars name() const { return at<2>().as_string(); }
};

class EventName : public ::protozero::Message {
 public:
  using Decoder = EventName_Decoder;
  enum : int32_t {
    kIidFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  void set_iid(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_name(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void set_name(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
};

class EventCategory_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  EventCategory_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit EventCategory_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit EventCategory_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_iid() const { return at<1>().valid(); }
  uint64_t iid() const { return at<1>().as_uint64(); }
  bool has_name() const { return at<2>().valid(); }
  ::protozero::ConstChars name() const { return at<2>().as_string(); }
};

class EventCategory : public ::protozero::Message {
 public:
  using Decoder = EventCategory_Decoder;
  enum : int32_t {
    kIidFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  void set_iid(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_name(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void set_name(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
};

class TrackEventDefaults_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/10, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TrackEventDefaults_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TrackEventDefaults_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TrackEventDefaults_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_track_uuid() const { return at<10>().valid(); }
  uint64_t track_uuid() const { return at<10>().as_uint64(); }
};

class TrackEventDefaults : public ::protozero::Message {
 public:
  using Decoder = TrackEventDefaults_Decoder;
  enum : int32_t {
    kTrackUuidFieldNumber = 10,
  };
  void set_track_uuid(uint64_t value) {
    AppendVarInt(10, value);
  }
};

class TrackEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/23, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  TrackEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TrackEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TrackEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_category_iids() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator<uint64_t> category_iids() const { return GetRepeated<uint64_t>(3); }
  bool has_categories() const { return at<22>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstChars> categories() const { return GetRepeated<::protozero::ConstChars>(22); }
  bool has_name_iid() const { return at<10>().valid(); }
  uint64_t name_iid() const { return at<10>().as_uint64(); }
  bool has_name() const { return at<23>().valid(); }
  ::protozero::ConstChars name() const { return at<23>().as_string(); }
  bool has_type() const { return at<9>().valid(); }
  int32_t type() const { return at<9>().as_int32(); }
  bool has_track_uuid() const { return at<11>().valid(); }
  uint64_t track_uuid() const { return at<11>().as_uint64(); }
  bool has_thread_time_delta_us() const { return at<2>().valid(); }
  int64_t thread_time_delta_us() const { return at<2>().as_int64(); }
  bool has_thread_time_absolute_us() const { return at<17>().valid(); }
  int64_t thread_time_absolute_us() const { return at<17>().as_int64(); }
  bool has_thread_instruction_count_delta() const { return at<8>().valid(); }
  int64_t thread_instruction_count_delta() const { return at<8>().as_int64(); }
  bool has_thread_instruction_count_absolute() const { return at<20>().valid(); }
  int64_t thread_instruction_count_absolute() const { return at<20>().as_int64(); }
  bool has_debug_annotations() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> debug_annotations() const { return GetRepeated<::protozero::ConstBytes>(4); }
  bool has_task_execution() const { return at<5>().valid(); }
  ::protozero::ConstBytes task_execution() const { return at<5>().as_bytes(); }
  bool has_log_message() const { return at<21>().valid(); }
  ::protozero::ConstBytes log_message() const { return at<21>().as_bytes(); }
  bool has_timestamp_delta_us() const { return at<1>().valid(); }
  int64_t timestamp_delta_us() const { return at<1>().as_int64(); }
  bool has_timestamp_absolute_us() const { return at<16>().valid(); }
  int64_t timestamp_absolute_us() const { return at<16>().as_int64(); }
  bool has_legacy_event() const { return at<6>().valid(); }
  ::protozero::ConstBytes legacy_event() const { return at<6>().as_bytes(); }
};

class TrackEvent : public ::protozero::Message {
 public:
  using Decoder = TrackEvent_Decoder;
  enum : int32_t {
    kCategoryIidsFieldNumber = 3,
    kCategoriesFieldNumber = 22,
    kNameIidFieldNumber = 10,
    kNameFieldNumber = 23,
    kTypeFieldNumber = 9,
    kTrackUuidFieldNumber = 11,
    kThreadTimeDeltaUsFieldNumber = 2,
    kThreadTimeAbsoluteUsFieldNumber = 17,
    kThreadInstructionCountDeltaFieldNumber = 8,
    kThreadInstructionCountAbsoluteFieldNumber = 20,
    kDebugAnnotationsFieldNumber = 4,
    kTaskExecutionFieldNumber = 5,
    kLogMessageFieldNumber = 21,
    kTimestampDeltaUsFieldNumber = 1,
    kTimestampAbsoluteUsFieldNumber = 16,
    kLegacyEventFieldNumber = 6,
  };
  using LegacyEvent = ::perfetto::protos::pbzero::TrackEvent_LegacyEvent;
  using Type = ::perfetto::protos::pbzero::TrackEvent_Type;
  static const Type TYPE_UNSPECIFIED = TrackEvent_Type_TYPE_UNSPECIFIED;
  static const Type TYPE_SLICE_BEGIN = TrackEvent_Type_TYPE_SLICE_BEGIN;
  static const Type TYPE_SLICE_END = TrackEvent_Type_TYPE_SLICE_END;
  static const Type TYPE_INSTANT = TrackEvent_Type_TYPE_INSTANT;
  void add_category_iids(uint64_t value) {
    AppendVarInt(3, value);
  }
  void add_categories(const std::string& value) {
    AppendBytes(22, value.data(), value.size());
  }
  void add_categories(const char* data, size_t size) {
    AppendBytes(22, data, size);
  }
  void set_name_iid(uint64_t value) {
    AppendVarInt(10, value);
  }
  void set_name(const std::string& value) {
    AppendBytes(23, value.data(), value.size());
  }
  void set_name(const char* data, size_t size) {
    AppendBytes(23, data, size);
  }
  void set_type(::perfetto::protos::pbzero::TrackEvent_Type value) {
    AppendTinyVarInt(9, value);
  }
  void set_track_uuid(uint64_t value) {
    AppendVarInt(11, value);
  }
  void set_thread_time_delta_us(int64_t value) {
    AppendVarInt(2, value);
  }
  void set_thread_time_absolute_us(int64_t value) {
    AppendVarInt(17, value);
  }
  void set_thread_instruction_count_delta(int64_t value) {
    AppendVarInt(8, value);
  }
  void set_thread_instruction_count_absolute(int64_t value) {
    AppendVarInt(20, value);
  }
  template <typename T = DebugAnnotation> T* add_debug_annotations() {
    return BeginNestedMessage<T>(4);
  }

  template <typename T = TaskExecution> T* set_task_execution() {
    return BeginNestedMessage<T>(5);
  }

  template <typename T = LogMessage> T* set_log_message() {
    return BeginNestedMessage<T>(21);
  }

  void set_timestamp_delta_us(int64_t value) {
    AppendVarInt(1, value);
  }
  void set_timestamp_absolute_us(int64_t value) {
    AppendVarInt(16, value);
  }
  template <typename T = TrackEvent_LegacyEvent> T* set_legacy_event() {
    return BeginNestedMessage<T>(6);
  }

};

class TrackEvent_LegacyEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/19, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TrackEvent_LegacyEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TrackEvent_LegacyEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TrackEvent_LegacyEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name_iid() const { return at<1>().valid(); }
  uint64_t name_iid() const { return at<1>().as_uint64(); }
  bool has_phase() const { return at<2>().valid(); }
  int32_t phase() const { return at<2>().as_int32(); }
  bool has_duration_us() const { return at<3>().valid(); }
  int64_t duration_us() const { return at<3>().as_int64(); }
  bool has_thread_duration_us() const { return at<4>().valid(); }
  int64_t thread_duration_us() const { return at<4>().as_int64(); }
  bool has_thread_instruction_delta() const { return at<15>().valid(); }
  int64_t thread_instruction_delta() const { return at<15>().as_int64(); }
  bool has_unscoped_id() const { return at<6>().valid(); }
  uint64_t unscoped_id() const { return at<6>().as_uint64(); }
  bool has_local_id() const { return at<10>().valid(); }
  uint64_t local_id() const { return at<10>().as_uint64(); }
  bool has_global_id() const { return at<11>().valid(); }
  uint64_t global_id() const { return at<11>().as_uint64(); }
  bool has_id_scope() const { return at<7>().valid(); }
  ::protozero::ConstChars id_scope() const { return at<7>().as_string(); }
  bool has_use_async_tts() const { return at<9>().valid(); }
  bool use_async_tts() const { return at<9>().as_bool(); }
  bool has_bind_id() const { return at<8>().valid(); }
  uint64_t bind_id() const { return at<8>().as_uint64(); }
  bool has_bind_to_enclosing() const { return at<12>().valid(); }
  bool bind_to_enclosing() const { return at<12>().as_bool(); }
  bool has_flow_direction() const { return at<13>().valid(); }
  int32_t flow_direction() const { return at<13>().as_int32(); }
  bool has_instant_event_scope() const { return at<14>().valid(); }
  int32_t instant_event_scope() const { return at<14>().as_int32(); }
  bool has_pid_override() const { return at<18>().valid(); }
  int32_t pid_override() const { return at<18>().as_int32(); }
  bool has_tid_override() const { return at<19>().valid(); }
  int32_t tid_override() const { return at<19>().as_int32(); }
};

class TrackEvent_LegacyEvent : public ::protozero::Message {
 public:
  using Decoder = TrackEvent_LegacyEvent_Decoder;
  enum : int32_t {
    kNameIidFieldNumber = 1,
    kPhaseFieldNumber = 2,
    kDurationUsFieldNumber = 3,
    kThreadDurationUsFieldNumber = 4,
    kThreadInstructionDeltaFieldNumber = 15,
    kUnscopedIdFieldNumber = 6,
    kLocalIdFieldNumber = 10,
    kGlobalIdFieldNumber = 11,
    kIdScopeFieldNumber = 7,
    kUseAsyncTtsFieldNumber = 9,
    kBindIdFieldNumber = 8,
    kBindToEnclosingFieldNumber = 12,
    kFlowDirectionFieldNumber = 13,
    kInstantEventScopeFieldNumber = 14,
    kPidOverrideFieldNumber = 18,
    kTidOverrideFieldNumber = 19,
  };
  using FlowDirection = ::perfetto::protos::pbzero::TrackEvent_LegacyEvent_FlowDirection;
  using InstantEventScope = ::perfetto::protos::pbzero::TrackEvent_LegacyEvent_InstantEventScope;
  static const FlowDirection FLOW_UNSPECIFIED = TrackEvent_LegacyEvent_FlowDirection_FLOW_UNSPECIFIED;
  static const FlowDirection FLOW_IN = TrackEvent_LegacyEvent_FlowDirection_FLOW_IN;
  static const FlowDirection FLOW_OUT = TrackEvent_LegacyEvent_FlowDirection_FLOW_OUT;
  static const FlowDirection FLOW_INOUT = TrackEvent_LegacyEvent_FlowDirection_FLOW_INOUT;
  static const InstantEventScope SCOPE_UNSPECIFIED = TrackEvent_LegacyEvent_InstantEventScope_SCOPE_UNSPECIFIED;
  static const InstantEventScope SCOPE_GLOBAL = TrackEvent_LegacyEvent_InstantEventScope_SCOPE_GLOBAL;
  static const InstantEventScope SCOPE_PROCESS = TrackEvent_LegacyEvent_InstantEventScope_SCOPE_PROCESS;
  static const InstantEventScope SCOPE_THREAD = TrackEvent_LegacyEvent_InstantEventScope_SCOPE_THREAD;
  void set_name_iid(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_phase(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_duration_us(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_thread_duration_us(int64_t value) {
    AppendVarInt(4, value);
  }
  void set_thread_instruction_delta(int64_t value) {
    AppendVarInt(15, value);
  }
  void set_unscoped_id(uint64_t value) {
    AppendVarInt(6, value);
  }
  void set_local_id(uint64_t value) {
    AppendVarInt(10, value);
  }
  void set_global_id(uint64_t value) {
    AppendVarInt(11, value);
  }
  void set_id_scope(const std::string& value) {
    AppendBytes(7, value.data(), value.size());
  }
  void set_id_scope(const char* data, size_t size) {
    AppendBytes(7, data, size);
  }
  void set_use_async_tts(bool value) {
    AppendTinyVarInt(9, value);
  }
  void set_bind_id(uint64_t value) {
    AppendVarInt(8, value);
  }
  void set_bind_to_enclosing(bool value) {
    AppendTinyVarInt(12, value);
  }
  void set_flow_direction(::perfetto::protos::pbzero::TrackEvent_LegacyEvent_FlowDirection value) {
    AppendTinyVarInt(13, value);
  }
  void set_instant_event_scope(::perfetto::protos::pbzero::TrackEvent_LegacyEvent_InstantEventScope value) {
    AppendTinyVarInt(14, value);
  }
  void set_pid_override(int32_t value) {
    AppendVarInt(18, value);
  }
  void set_tid_override(int32_t value) {
    AppendVarInt(19, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/interned_data/interned_data.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_INTERNED_DATA_INTERNED_DATA_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_INTERNED_DATA_INTERNED_DATA_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class Callstack;
class DebugAnnotationName;
class EventCategory;
class EventName;
class Frame;
class InternedString;
class LogMessageBody;
class Mapping;
class ProfiledFrameSymbols;
class SourceLocation;

class InternedData_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/22, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  InternedData_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit InternedData_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit InternedData_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_event_categories() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> event_categories() const { return GetRepeated<::protozero::ConstBytes>(1); }
  bool has_event_names() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> event_names() const { return GetRepeated<::protozero::ConstBytes>(2); }
  bool has_debug_annotation_names() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> debug_annotation_names() const { return GetRepeated<::protozero::ConstBytes>(3); }
  bool has_source_locations() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> source_locations() const { return GetRepeated<::protozero::ConstBytes>(4); }
  bool has_log_message_body() const { return at<20>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> log_message_body() const { return GetRepeated<::protozero::ConstBytes>(20); }
  bool has_build_ids() const { return at<16>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> build_ids() const { return GetRepeated<::protozero::ConstBytes>(16); }
  bool has_mapping_paths() const { return at<17>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> mapping_paths() const { return GetRepeated<::protozero::ConstBytes>(17); }
  bool has_source_paths() const { return at<18>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> source_paths() const { return GetRepeated<::protozero::ConstBytes>(18); }
  bool has_function_names() const { return at<5>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> function_names() const { return GetRepeated<::protozero::ConstBytes>(5); }
  bool has_profiled_frame_symbols() const { return at<21>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> profiled_frame_symbols() const { return GetRepeated<::protozero::ConstBytes>(21); }
  bool has_mappings() const { return at<19>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> mappings() const { return GetRepeated<::protozero::ConstBytes>(19); }
  bool has_frames() const { return at<6>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> frames() const { return GetRepeated<::protozero::ConstBytes>(6); }
  bool has_callstacks() const { return at<7>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> callstacks() const { return GetRepeated<::protozero::ConstBytes>(7); }
  bool has_vulkan_memory_keys() const { return at<22>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> vulkan_memory_keys() const { return GetRepeated<::protozero::ConstBytes>(22); }
};

class InternedData : public ::protozero::Message {
 public:
  using Decoder = InternedData_Decoder;
  enum : int32_t {
    kEventCategoriesFieldNumber = 1,
    kEventNamesFieldNumber = 2,
    kDebugAnnotationNamesFieldNumber = 3,
    kSourceLocationsFieldNumber = 4,
    kLogMessageBodyFieldNumber = 20,
    kBuildIdsFieldNumber = 16,
    kMappingPathsFieldNumber = 17,
    kSourcePathsFieldNumber = 18,
    kFunctionNamesFieldNumber = 5,
    kProfiledFrameSymbolsFieldNumber = 21,
    kMappingsFieldNumber = 19,
    kFramesFieldNumber = 6,
    kCallstacksFieldNumber = 7,
    kVulkanMemoryKeysFieldNumber = 22,
  };
  template <typename T = EventCategory> T* add_event_categories() {
    return BeginNestedMessage<T>(1);
  }

  template <typename T = EventName> T* add_event_names() {
    return BeginNestedMessage<T>(2);
  }

  template <typename T = DebugAnnotationName> T* add_debug_annotation_names() {
    return BeginNestedMessage<T>(3);
  }

  template <typename T = SourceLocation> T* add_source_locations() {
    return BeginNestedMessage<T>(4);
  }

  template <typename T = LogMessageBody> T* add_log_message_body() {
    return BeginNestedMessage<T>(20);
  }

  template <typename T = InternedString> T* add_build_ids() {
    return BeginNestedMessage<T>(16);
  }

  template <typename T = InternedString> T* add_mapping_paths() {
    return BeginNestedMessage<T>(17);
  }

  template <typename T = InternedString> T* add_source_paths() {
    return BeginNestedMessage<T>(18);
  }

  template <typename T = InternedString> T* add_function_names() {
    return BeginNestedMessage<T>(5);
  }

  template <typename T = ProfiledFrameSymbols> T* add_profiled_frame_symbols() {
    return BeginNestedMessage<T>(21);
  }

  template <typename T = Mapping> T* add_mappings() {
    return BeginNestedMessage<T>(19);
  }

  template <typename T = Frame> T* add_frames() {
    return BeginNestedMessage<T>(6);
  }

  template <typename T = Callstack> T* add_callstacks() {
    return BeginNestedMessage<T>(7);
  }

  template <typename T = InternedString> T* add_vulkan_memory_keys() {
    return BeginNestedMessage<T>(22);
  }

};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/perfetto/perfetto_metatrace.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_PERFETTO_PERFETTO_METATRACE_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_PERFETTO_PERFETTO_METATRACE_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class PerfettoMetatrace_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  PerfettoMetatrace_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit PerfettoMetatrace_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit PerfettoMetatrace_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_event_id() const { return at<1>().valid(); }
  uint32_t event_id() const { return at<1>().as_uint32(); }
  bool has_counter_id() const { return at<2>().valid(); }
  uint32_t counter_id() const { return at<2>().as_uint32(); }
  bool has_event_duration_ns() const { return at<3>().valid(); }
  uint32_t event_duration_ns() const { return at<3>().as_uint32(); }
  bool has_counter_value() const { return at<4>().valid(); }
  int32_t counter_value() const { return at<4>().as_int32(); }
  bool has_thread_id() const { return at<5>().valid(); }
  uint32_t thread_id() const { return at<5>().as_uint32(); }
  bool has_has_overruns() const { return at<6>().valid(); }
  bool has_overruns() const { return at<6>().as_bool(); }
};

class PerfettoMetatrace : public ::protozero::Message {
 public:
  using Decoder = PerfettoMetatrace_Decoder;
  enum : int32_t {
    kEventIdFieldNumber = 1,
    kCounterIdFieldNumber = 2,
    kEventDurationNsFieldNumber = 3,
    kCounterValueFieldNumber = 4,
    kThreadIdFieldNumber = 5,
    kHasOverrunsFieldNumber = 6,
  };
  void set_event_id(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_counter_id(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_event_duration_ns(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_counter_value(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_thread_id(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_has_overruns(bool value) {
    AppendTinyVarInt(6, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/power/battery_counters.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_POWER_BATTERY_COUNTERS_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_POWER_BATTERY_COUNTERS_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class BatteryCounters_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BatteryCounters_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BatteryCounters_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BatteryCounters_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_charge_counter_uah() const { return at<1>().valid(); }
  int64_t charge_counter_uah() const { return at<1>().as_int64(); }
  bool has_capacity_percent() const { return at<2>().valid(); }
  float capacity_percent() const { return at<2>().as_float(); }
  bool has_current_ua() const { return at<3>().valid(); }
  int64_t current_ua() const { return at<3>().as_int64(); }
  bool has_current_avg_ua() const { return at<4>().valid(); }
  int64_t current_avg_ua() const { return at<4>().as_int64(); }
};

class BatteryCounters : public ::protozero::Message {
 public:
  using Decoder = BatteryCounters_Decoder;
  enum : int32_t {
    kChargeCounterUahFieldNumber = 1,
    kCapacityPercentFieldNumber = 2,
    kCurrentUaFieldNumber = 3,
    kCurrentAvgUaFieldNumber = 4,
  };
  void set_charge_counter_uah(int64_t value) {
    AppendVarInt(1, value);
  }
  void set_capacity_percent(float value) {
    AppendFixed(2, value);
  }
  void set_current_ua(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_current_avg_ua(int64_t value) {
    AppendVarInt(4, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/power/power_rails.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_POWER_POWER_RAILS_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_POWER_POWER_RAILS_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class PowerRails_EnergyData;
class PowerRails_RailDescriptor;

class PowerRails_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  PowerRails_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit PowerRails_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit PowerRails_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_rail_descriptor() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> rail_descriptor() const { return GetRepeated<::protozero::ConstBytes>(1); }
  bool has_energy_data() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> energy_data() const { return GetRepeated<::protozero::ConstBytes>(2); }
};

class PowerRails : public ::protozero::Message {
 public:
  using Decoder = PowerRails_Decoder;
  enum : int32_t {
    kRailDescriptorFieldNumber = 1,
    kEnergyDataFieldNumber = 2,
  };
  using RailDescriptor = ::perfetto::protos::pbzero::PowerRails_RailDescriptor;
  using EnergyData = ::perfetto::protos::pbzero::PowerRails_EnergyData;
  template <typename T = PowerRails_RailDescriptor> T* add_rail_descriptor() {
    return BeginNestedMessage<T>(1);
  }

  template <typename T = PowerRails_EnergyData> T* add_energy_data() {
    return BeginNestedMessage<T>(2);
  }

};

class PowerRails_EnergyData_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  PowerRails_EnergyData_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit PowerRails_EnergyData_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit PowerRails_EnergyData_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_index() const { return at<1>().valid(); }
  uint32_t index() const { return at<1>().as_uint32(); }
  bool has_timestamp_ms() const { return at<2>().valid(); }
  uint64_t timestamp_ms() const { return at<2>().as_uint64(); }
  bool has_energy() const { return at<3>().valid(); }
  uint64_t energy() const { return at<3>().as_uint64(); }
};

class PowerRails_EnergyData : public ::protozero::Message {
 public:
  using Decoder = PowerRails_EnergyData_Decoder;
  enum : int32_t {
    kIndexFieldNumber = 1,
    kTimestampMsFieldNumber = 2,
    kEnergyFieldNumber = 3,
  };
  void set_index(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_timestamp_ms(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_energy(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class PowerRails_RailDescriptor_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  PowerRails_RailDescriptor_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit PowerRails_RailDescriptor_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit PowerRails_RailDescriptor_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_index() const { return at<1>().valid(); }
  uint32_t index() const { return at<1>().as_uint32(); }
  bool has_rail_name() const { return at<2>().valid(); }
  ::protozero::ConstChars rail_name() const { return at<2>().as_string(); }
  bool has_subsys_name() const { return at<3>().valid(); }
  ::protozero::ConstChars subsys_name() const { return at<3>().as_string(); }
  bool has_sampling_rate() const { return at<4>().valid(); }
  uint32_t sampling_rate() const { return at<4>().as_uint32(); }
};

class PowerRails_RailDescriptor : public ::protozero::Message {
 public:
  using Decoder = PowerRails_RailDescriptor_Decoder;
  enum : int32_t {
    kIndexFieldNumber = 1,
    kRailNameFieldNumber = 2,
    kSubsysNameFieldNumber = 3,
    kSamplingRateFieldNumber = 4,
  };
  void set_index(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_rail_name(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void set_rail_name(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
  void set_subsys_name(const std::string& value) {
    AppendBytes(3, value.data(), value.size());
  }
  void set_subsys_name(const char* data, size_t size) {
    AppendBytes(3, data, size);
  }
  void set_sampling_rate(uint32_t value) {
    AppendVarInt(4, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/ps/process_stats.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_PS_PROCESS_STATS_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_PS_PROCESS_STATS_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class ProcessStats_Process;

class ProcessStats_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  ProcessStats_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ProcessStats_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ProcessStats_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_processes() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> processes() const { return GetRepeated<::protozero::ConstBytes>(1); }
  bool has_collection_end_timestamp() const { return at<2>().valid(); }
  uint64_t collection_end_timestamp() const { return at<2>().as_uint64(); }
};

class ProcessStats : public ::protozero::Message {
 public:
  using Decoder = ProcessStats_Decoder;
  enum : int32_t {
    kProcessesFieldNumber = 1,
    kCollectionEndTimestampFieldNumber = 2,
  };
  using Process = ::perfetto::protos::pbzero::ProcessStats_Process;
  template <typename T = ProcessStats_Process> T* add_processes() {
    return BeginNestedMessage<T>(1);
  }

  void set_collection_end_timestamp(uint64_t value) {
    AppendVarInt(2, value);
  }
};

class ProcessStats_Process_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/10, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ProcessStats_Process_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ProcessStats_Process_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ProcessStats_Process_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_pid() const { return at<1>().valid(); }
  int32_t pid() const { return at<1>().as_int32(); }
  bool has_vm_size_kb() const { return at<2>().valid(); }
  uint64_t vm_size_kb() const { return at<2>().as_uint64(); }
  bool has_vm_rss_kb() const { return at<3>().valid(); }
  uint64_t vm_rss_kb() const { return at<3>().as_uint64(); }
  bool has_rss_anon_kb() const { return at<4>().valid(); }
  uint64_t rss_anon_kb() const { return at<4>().as_uint64(); }
  bool has_rss_file_kb() const { return at<5>().valid(); }
  uint64_t rss_file_kb() const { return at<5>().as_uint64(); }
  bool has_rss_shmem_kb() const { return at<6>().valid(); }
  uint64_t rss_shmem_kb() const { return at<6>().as_uint64(); }
  bool has_vm_swap_kb() const { return at<7>().valid(); }
  uint64_t vm_swap_kb() const { return at<7>().as_uint64(); }
  bool has_vm_locked_kb() const { return at<8>().valid(); }
  uint64_t vm_locked_kb() const { return at<8>().as_uint64(); }
  bool has_vm_hwm_kb() const { return at<9>().valid(); }
  uint64_t vm_hwm_kb() const { return at<9>().as_uint64(); }
  bool has_oom_score_adj() const { return at<10>().valid(); }
  int64_t oom_score_adj() const { return at<10>().as_int64(); }
};

class ProcessStats_Process : public ::protozero::Message {
 public:
  using Decoder = ProcessStats_Process_Decoder;
  enum : int32_t {
    kPidFieldNumber = 1,
    kVmSizeKbFieldNumber = 2,
    kVmRssKbFieldNumber = 3,
    kRssAnonKbFieldNumber = 4,
    kRssFileKbFieldNumber = 5,
    kRssShmemKbFieldNumber = 6,
    kVmSwapKbFieldNumber = 7,
    kVmLockedKbFieldNumber = 8,
    kVmHwmKbFieldNumber = 9,
    kOomScoreAdjFieldNumber = 10,
  };
  void set_pid(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_vm_size_kb(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_vm_rss_kb(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_rss_anon_kb(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_rss_file_kb(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_rss_shmem_kb(uint64_t value) {
    AppendVarInt(6, value);
  }
  void set_vm_swap_kb(uint64_t value) {
    AppendVarInt(7, value);
  }
  void set_vm_locked_kb(uint64_t value) {
    AppendVarInt(8, value);
  }
  void set_vm_hwm_kb(uint64_t value) {
    AppendVarInt(9, value);
  }
  void set_oom_score_adj(int64_t value) {
    AppendVarInt(10, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/ps/process_tree.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_PS_PROCESS_TREE_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_PS_PROCESS_TREE_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class ProcessTree_Process;
class ProcessTree_Thread;

class ProcessTree_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  ProcessTree_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ProcessTree_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ProcessTree_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_processes() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> processes() const { return GetRepeated<::protozero::ConstBytes>(1); }
  bool has_threads() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> threads() const { return GetRepeated<::protozero::ConstBytes>(2); }
  bool has_collection_end_timestamp() const { return at<3>().valid(); }
  uint64_t collection_end_timestamp() const { return at<3>().as_uint64(); }
};

class ProcessTree : public ::protozero::Message {
 public:
  using Decoder = ProcessTree_Decoder;
  enum : int32_t {
    kProcessesFieldNumber = 1,
    kThreadsFieldNumber = 2,
    kCollectionEndTimestampFieldNumber = 3,
  };
  using Thread = ::perfetto::protos::pbzero::ProcessTree_Thread;
  using Process = ::perfetto::protos::pbzero::ProcessTree_Process;
  template <typename T = ProcessTree_Process> T* add_processes() {
    return BeginNestedMessage<T>(1);
  }

  template <typename T = ProcessTree_Thread> T* add_threads() {
    return BeginNestedMessage<T>(2);
  }

  void set_collection_end_timestamp(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class ProcessTree_Process_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  ProcessTree_Process_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ProcessTree_Process_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ProcessTree_Process_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_pid() const { return at<1>().valid(); }
  int32_t pid() const { return at<1>().as_int32(); }
  bool has_ppid() const { return at<2>().valid(); }
  int32_t ppid() const { return at<2>().as_int32(); }
  bool has_cmdline() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstChars> cmdline() const { return GetRepeated<::protozero::ConstChars>(3); }
  bool has_threads_deprecated() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> threads_deprecated() const { return GetRepeated<::protozero::ConstBytes>(4); }
  bool has_uid() const { return at<5>().valid(); }
  int32_t uid() const { return at<5>().as_int32(); }
};

class ProcessTree_Process : public ::protozero::Message {
 public:
  using Decoder = ProcessTree_Process_Decoder;
  enum : int32_t {
    kPidFieldNumber = 1,
    kPpidFieldNumber = 2,
    kCmdlineFieldNumber = 3,
    kThreadsDeprecatedFieldNumber = 4,
    kUidFieldNumber = 5,
  };
  void set_pid(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_ppid(int32_t value) {
    AppendVarInt(2, value);
  }
  void add_cmdline(const std::string& value) {
    AppendBytes(3, value.data(), value.size());
  }
  void add_cmdline(const char* data, size_t size) {
    AppendBytes(3, data, size);
  }
  template <typename T = ProcessTree_Thread> T* add_threads_deprecated() {
    return BeginNestedMessage<T>(4);
  }

  void set_uid(int32_t value) {
    AppendVarInt(5, value);
  }
};

class ProcessTree_Thread_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ProcessTree_Thread_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ProcessTree_Thread_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ProcessTree_Thread_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_tid() const { return at<1>().valid(); }
  int32_t tid() const { return at<1>().as_int32(); }
  bool has_tgid() const { return at<3>().valid(); }
  int32_t tgid() const { return at<3>().as_int32(); }
  bool has_name() const { return at<2>().valid(); }
  ::protozero::ConstChars name() const { return at<2>().as_string(); }
};

class ProcessTree_Thread : public ::protozero::Message {
 public:
  using Decoder = ProcessTree_Thread_Decoder;
  enum : int32_t {
    kTidFieldNumber = 1,
    kTgidFieldNumber = 3,
    kNameFieldNumber = 2,
  };
  void set_tid(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_tgid(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_name(const std::string& value) {
    AppendBytes(2, value.data(), value.size());
  }
  void set_name(const char* data, size_t size) {
    AppendBytes(2, data, size);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/sys_stats/sys_stats.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_SYS_STATS_SYS_STATS_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_SYS_STATS_SYS_STATS_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class SysStats_CpuTimes;
class SysStats_InterruptCount;
class SysStats_MeminfoValue;
class SysStats_VmstatValue;
enum MeminfoCounters : int32_t;
enum VmstatCounters : int32_t;

class SysStats_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/9, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  SysStats_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SysStats_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SysStats_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_meminfo() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> meminfo() const { return GetRepeated<::protozero::ConstBytes>(1); }
  bool has_vmstat() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> vmstat() const { return GetRepeated<::protozero::ConstBytes>(2); }
  bool has_cpu_stat() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> cpu_stat() const { return GetRepeated<::protozero::ConstBytes>(3); }
  bool has_num_forks() const { return at<4>().valid(); }
  uint64_t num_forks() const { return at<4>().as_uint64(); }
  bool has_num_irq_total() const { return at<5>().valid(); }
  uint64_t num_irq_total() const { return at<5>().as_uint64(); }
  bool has_num_irq() const { return at<6>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> num_irq() const { return GetRepeated<::protozero::ConstBytes>(6); }
  bool has_num_softirq_total() const { return at<7>().valid(); }
  uint64_t num_softirq_total() const { return at<7>().as_uint64(); }
  bool has_num_softirq() const { return at<8>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> num_softirq() const { return GetRepeated<::protozero::ConstBytes>(8); }
  bool has_collection_end_timestamp() const { return at<9>().valid(); }
  uint64_t collection_end_timestamp() const { return at<9>().as_uint64(); }
};

class SysStats : public ::protozero::Message {
 public:
  using Decoder = SysStats_Decoder;
  enum : int32_t {
    kMeminfoFieldNumber = 1,
    kVmstatFieldNumber = 2,
    kCpuStatFieldNumber = 3,
    kNumForksFieldNumber = 4,
    kNumIrqTotalFieldNumber = 5,
    kNumIrqFieldNumber = 6,
    kNumSoftirqTotalFieldNumber = 7,
    kNumSoftirqFieldNumber = 8,
    kCollectionEndTimestampFieldNumber = 9,
  };
  using MeminfoValue = ::perfetto::protos::pbzero::SysStats_MeminfoValue;
  using VmstatValue = ::perfetto::protos::pbzero::SysStats_VmstatValue;
  using CpuTimes = ::perfetto::protos::pbzero::SysStats_CpuTimes;
  using InterruptCount = ::perfetto::protos::pbzero::SysStats_InterruptCount;
  template <typename T = SysStats_MeminfoValue> T* add_meminfo() {
    return BeginNestedMessage<T>(1);
  }

  template <typename T = SysStats_VmstatValue> T* add_vmstat() {
    return BeginNestedMessage<T>(2);
  }

  template <typename T = SysStats_CpuTimes> T* add_cpu_stat() {
    return BeginNestedMessage<T>(3);
  }

  void set_num_forks(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_num_irq_total(uint64_t value) {
    AppendVarInt(5, value);
  }
  template <typename T = SysStats_InterruptCount> T* add_num_irq() {
    return BeginNestedMessage<T>(6);
  }

  void set_num_softirq_total(uint64_t value) {
    AppendVarInt(7, value);
  }
  template <typename T = SysStats_InterruptCount> T* add_num_softirq() {
    return BeginNestedMessage<T>(8);
  }

  void set_collection_end_timestamp(uint64_t value) {
    AppendVarInt(9, value);
  }
};

class SysStats_InterruptCount_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SysStats_InterruptCount_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SysStats_InterruptCount_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SysStats_InterruptCount_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_irq() const { return at<1>().valid(); }
  int32_t irq() const { return at<1>().as_int32(); }
  bool has_count() const { return at<2>().valid(); }
  uint64_t count() const { return at<2>().as_uint64(); }
};

class SysStats_InterruptCount : public ::protozero::Message {
 public:
  using Decoder = SysStats_InterruptCount_Decoder;
  enum : int32_t {
    kIrqFieldNumber = 1,
    kCountFieldNumber = 2,
  };
  void set_irq(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_count(uint64_t value) {
    AppendVarInt(2, value);
  }
};

class SysStats_CpuTimes_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SysStats_CpuTimes_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SysStats_CpuTimes_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SysStats_CpuTimes_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_cpu_id() const { return at<1>().valid(); }
  uint32_t cpu_id() const { return at<1>().as_uint32(); }
  bool has_user_ns() const { return at<2>().valid(); }
  uint64_t user_ns() const { return at<2>().as_uint64(); }
  bool has_user_ice_ns() const { return at<3>().valid(); }
  uint64_t user_ice_ns() const { return at<3>().as_uint64(); }
  bool has_system_mode_ns() const { return at<4>().valid(); }
  uint64_t system_mode_ns() const { return at<4>().as_uint64(); }
  bool has_idle_ns() const { return at<5>().valid(); }
  uint64_t idle_ns() const { return at<5>().as_uint64(); }
  bool has_io_wait_ns() const { return at<6>().valid(); }
  uint64_t io_wait_ns() const { return at<6>().as_uint64(); }
  bool has_irq_ns() const { return at<7>().valid(); }
  uint64_t irq_ns() const { return at<7>().as_uint64(); }
  bool has_softirq_ns() const { return at<8>().valid(); }
  uint64_t softirq_ns() const { return at<8>().as_uint64(); }
};

class SysStats_CpuTimes : public ::protozero::Message {
 public:
  using Decoder = SysStats_CpuTimes_Decoder;
  enum : int32_t {
    kCpuIdFieldNumber = 1,
    kUserNsFieldNumber = 2,
    kUserIceNsFieldNumber = 3,
    kSystemModeNsFieldNumber = 4,
    kIdleNsFieldNumber = 5,
    kIoWaitNsFieldNumber = 6,
    kIrqNsFieldNumber = 7,
    kSoftirqNsFieldNumber = 8,
  };
  void set_cpu_id(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_user_ns(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_user_ice_ns(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_system_mode_ns(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_idle_ns(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_io_wait_ns(uint64_t value) {
    AppendVarInt(6, value);
  }
  void set_irq_ns(uint64_t value) {
    AppendVarInt(7, value);
  }
  void set_softirq_ns(uint64_t value) {
    AppendVarInt(8, value);
  }
};

class SysStats_VmstatValue_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SysStats_VmstatValue_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SysStats_VmstatValue_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SysStats_VmstatValue_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_key() const { return at<1>().valid(); }
  int32_t key() const { return at<1>().as_int32(); }
  bool has_value() const { return at<2>().valid(); }
  uint64_t value() const { return at<2>().as_uint64(); }
};

class SysStats_VmstatValue : public ::protozero::Message {
 public:
  using Decoder = SysStats_VmstatValue_Decoder;
  enum : int32_t {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  void set_key(::perfetto::protos::pbzero::VmstatCounters value) {
    AppendTinyVarInt(1, value);
  }
  void set_value(uint64_t value) {
    AppendVarInt(2, value);
  }
};

class SysStats_MeminfoValue_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SysStats_MeminfoValue_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SysStats_MeminfoValue_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SysStats_MeminfoValue_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_key() const { return at<1>().valid(); }
  int32_t key() const { return at<1>().as_int32(); }
  bool has_value() const { return at<2>().valid(); }
  uint64_t value() const { return at<2>().as_uint64(); }
};

class SysStats_MeminfoValue : public ::protozero::Message {
 public:
  using Decoder = SysStats_MeminfoValue_Decoder;
  enum : int32_t {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  void set_key(::perfetto::protos::pbzero::MeminfoCounters value) {
    AppendTinyVarInt(1, value);
  }
  void set_value(uint64_t value) {
    AppendVarInt(2, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/trace_packet_defaults.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACE_PACKET_DEFAULTS_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACE_PACKET_DEFAULTS_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class TrackEventDefaults;

class TracePacketDefaults_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/58, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TracePacketDefaults_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TracePacketDefaults_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TracePacketDefaults_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_timestamp_clock_id() const { return at<58>().valid(); }
  uint32_t timestamp_clock_id() const { return at<58>().as_uint32(); }
  bool has_track_event_defaults() const { return at<11>().valid(); }
  ::protozero::ConstBytes track_event_defaults() const { return at<11>().as_bytes(); }
};

class TracePacketDefaults : public ::protozero::Message {
 public:
  using Decoder = TracePacketDefaults_Decoder;
  enum : int32_t {
    kTimestampClockIdFieldNumber = 58,
    kTrackEventDefaultsFieldNumber = 11,
  };
  void set_timestamp_clock_id(uint32_t value) {
    AppendVarInt(58, value);
  }
  template <typename T = TrackEventDefaults> T* set_track_event_defaults() {
    return BeginNestedMessage<T>(11);
  }

};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/test_event.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TEST_EVENT_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TEST_EVENT_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class TestEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TestEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TestEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TestEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_str() const { return at<1>().valid(); }
  ::protozero::ConstChars str() const { return at<1>().as_string(); }
  bool has_seq_value() const { return at<2>().valid(); }
  uint32_t seq_value() const { return at<2>().as_uint32(); }
};

class TestEvent : public ::protozero::Message {
 public:
  using Decoder = TestEvent_Decoder;
  enum : int32_t {
    kStrFieldNumber = 1,
    kSeqValueFieldNumber = 2,
  };
  void set_str(const std::string& value) {
    AppendBytes(1, value.data(), value.size());
  }
  void set_str(const char* data, size_t size) {
    AppendBytes(1, data, size);
  }
  void set_seq_value(uint32_t value) {
    AppendVarInt(2, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/trace_packet.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACE_PACKET_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACE_PACKET_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class AndroidLogPacket;
class BatteryCounters;
class ChromeBenchmarkMetadata;
class ChromeEventBundle;
class ChromeMetadataPacket;
class ClockSnapshot;
class DeobfuscationMapping;
class FtraceEventBundle;
class FtraceStats;
class GpuCounterEvent;
class GpuLog;
class GpuRenderStageEvent;
class GraphicsFrameEvent;
class HeapGraph;
class InodeFileMap;
class InternedData;
class ModuleSymbols;
class PackagesList;
class PerfettoMetatrace;
class PowerRails;
class ProcessDescriptor;
class ProcessStats;
class ProcessTree;
class ProfilePacket;
class ProfiledFrameSymbols;
class StreamingProfilePacket;
class SysStats;
class SystemInfo;
class TestEvent;
class ThreadDescriptor;
class TraceConfig;
class TracePacketDefaults;
class TraceStats;
class TrackDescriptor;
class TrackEvent;
class Trigger;
class VulkanMemoryEvent;

enum TracePacket_SequenceFlags : int32_t {
  TracePacket_SequenceFlags_SEQ_UNSPECIFIED = 0,
  TracePacket_SequenceFlags_SEQ_INCREMENTAL_STATE_CLEARED = 1,
  TracePacket_SequenceFlags_SEQ_NEEDS_INCREMENTAL_STATE = 2,
};

const TracePacket_SequenceFlags TracePacket_SequenceFlags_MIN = TracePacket_SequenceFlags_SEQ_UNSPECIFIED;
const TracePacket_SequenceFlags TracePacket_SequenceFlags_MAX = TracePacket_SequenceFlags_SEQ_NEEDS_INCREMENTAL_STATE;

class TracePacket_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/900, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TracePacket_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TracePacket_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TracePacket_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_timestamp() const { return at<8>().valid(); }
  uint64_t timestamp() const { return at<8>().as_uint64(); }
  bool has_timestamp_clock_id() const { return at<58>().valid(); }
  uint32_t timestamp_clock_id() const { return at<58>().as_uint32(); }
  bool has_ftrace_events() const { return at<1>().valid(); }
  ::protozero::ConstBytes ftrace_events() const { return at<1>().as_bytes(); }
  bool has_process_tree() const { return at<2>().valid(); }
  ::protozero::ConstBytes process_tree() const { return at<2>().as_bytes(); }
  bool has_process_stats() const { return at<9>().valid(); }
  ::protozero::ConstBytes process_stats() const { return at<9>().as_bytes(); }
  bool has_inode_file_map() const { return at<4>().valid(); }
  ::protozero::ConstBytes inode_file_map() const { return at<4>().as_bytes(); }
  bool has_chrome_events() const { return at<5>().valid(); }
  ::protozero::ConstBytes chrome_events() const { return at<5>().as_bytes(); }
  bool has_clock_snapshot() const { return at<6>().valid(); }
  ::protozero::ConstBytes clock_snapshot() const { return at<6>().as_bytes(); }
  bool has_sys_stats() const { return at<7>().valid(); }
  ::protozero::ConstBytes sys_stats() const { return at<7>().as_bytes(); }
  bool has_track_event() const { return at<11>().valid(); }
  ::protozero::ConstBytes track_event() const { return at<11>().as_bytes(); }
  bool has_trace_config() const { return at<33>().valid(); }
  ::protozero::ConstBytes trace_config() const { return at<33>().as_bytes(); }
  bool has_ftrace_stats() const { return at<34>().valid(); }
  ::protozero::ConstBytes ftrace_stats() const { return at<34>().as_bytes(); }
  bool has_trace_stats() const { return at<35>().valid(); }
  ::protozero::ConstBytes trace_stats() const { return at<35>().as_bytes(); }
  bool has_profile_packet() const { return at<37>().valid(); }
  ::protozero::ConstBytes profile_packet() const { return at<37>().as_bytes(); }
  bool has_battery() const { return at<38>().valid(); }
  ::protozero::ConstBytes battery() const { return at<38>().as_bytes(); }
  bool has_power_rails() const { return at<40>().valid(); }
  ::protozero::ConstBytes power_rails() const { return at<40>().as_bytes(); }
  bool has_android_log() const { return at<39>().valid(); }
  ::protozero::ConstBytes android_log() const { return at<39>().as_bytes(); }
  bool has_system_info() const { return at<45>().valid(); }
  ::protozero::ConstBytes system_info() const { return at<45>().as_bytes(); }
  bool has_trigger() const { return at<46>().valid(); }
  ::protozero::ConstBytes trigger() const { return at<46>().as_bytes(); }
  bool has_packages_list() const { return at<47>().valid(); }
  ::protozero::ConstBytes packages_list() const { return at<47>().as_bytes(); }
  bool has_chrome_benchmark_metadata() const { return at<48>().valid(); }
  ::protozero::ConstBytes chrome_benchmark_metadata() const { return at<48>().as_bytes(); }
  bool has_perfetto_metatrace() const { return at<49>().valid(); }
  ::protozero::ConstBytes perfetto_metatrace() const { return at<49>().as_bytes(); }
  bool has_chrome_metadata() const { return at<51>().valid(); }
  ::protozero::ConstBytes chrome_metadata() const { return at<51>().as_bytes(); }
  bool has_gpu_counter_event() const { return at<52>().valid(); }
  ::protozero::ConstBytes gpu_counter_event() const { return at<52>().as_bytes(); }
  bool has_gpu_render_stage_event() const { return at<53>().valid(); }
  ::protozero::ConstBytes gpu_render_stage_event() const { return at<53>().as_bytes(); }
  bool has_streaming_profile_packet() const { return at<54>().valid(); }
  ::protozero::ConstBytes streaming_profile_packet() const { return at<54>().as_bytes(); }
  bool has_heap_graph() const { return at<56>().valid(); }
  ::protozero::ConstBytes heap_graph() const { return at<56>().as_bytes(); }
  bool has_graphics_frame_event() const { return at<57>().valid(); }
  ::protozero::ConstBytes graphics_frame_event() const { return at<57>().as_bytes(); }
  bool has_vulkan_memory_event() const { return at<62>().valid(); }
  ::protozero::ConstBytes vulkan_memory_event() const { return at<62>().as_bytes(); }
  bool has_gpu_log() const { return at<63>().valid(); }
  ::protozero::ConstBytes gpu_log() const { return at<63>().as_bytes(); }
  bool has_profiled_frame_symbols() const { return at<55>().valid(); }
  ::protozero::ConstBytes profiled_frame_symbols() const { return at<55>().as_bytes(); }
  bool has_module_symbols() const { return at<61>().valid(); }
  ::protozero::ConstBytes module_symbols() const { return at<61>().as_bytes(); }
  bool has_deobfuscation_mapping() const { return at<64>().valid(); }
  ::protozero::ConstBytes deobfuscation_mapping() const { return at<64>().as_bytes(); }
  bool has_track_descriptor() const { return at<60>().valid(); }
  ::protozero::ConstBytes track_descriptor() const { return at<60>().as_bytes(); }
  bool has_process_descriptor() const { return at<43>().valid(); }
  ::protozero::ConstBytes process_descriptor() const { return at<43>().as_bytes(); }
  bool has_thread_descriptor() const { return at<44>().valid(); }
  ::protozero::ConstBytes thread_descriptor() const { return at<44>().as_bytes(); }
  bool has_synchronization_marker() const { return at<36>().valid(); }
  ::protozero::ConstBytes synchronization_marker() const { return at<36>().as_bytes(); }
  bool has_compressed_packets() const { return at<50>().valid(); }
  ::protozero::ConstBytes compressed_packets() const { return at<50>().as_bytes(); }
  bool has_for_testing() const { return at<900>().valid(); }
  ::protozero::ConstBytes for_testing() const { return at<900>().as_bytes(); }
  bool has_trusted_uid() const { return at<3>().valid(); }
  int32_t trusted_uid() const { return at<3>().as_int32(); }
  bool has_trusted_packet_sequence_id() const { return at<10>().valid(); }
  uint32_t trusted_packet_sequence_id() const { return at<10>().as_uint32(); }
  bool has_interned_data() const { return at<12>().valid(); }
  ::protozero::ConstBytes interned_data() const { return at<12>().as_bytes(); }
  bool has_sequence_flags() const { return at<13>().valid(); }
  uint32_t sequence_flags() const { return at<13>().as_uint32(); }
  bool has_incremental_state_cleared() const { return at<41>().valid(); }
  bool incremental_state_cleared() const { return at<41>().as_bool(); }
  bool has_trace_packet_defaults() const { return at<59>().valid(); }
  ::protozero::ConstBytes trace_packet_defaults() const { return at<59>().as_bytes(); }
  bool has_previous_packet_dropped() const { return at<42>().valid(); }
  bool previous_packet_dropped() const { return at<42>().as_bool(); }
};

class TracePacket : public ::protozero::Message {
 public:
  using Decoder = TracePacket_Decoder;
  enum : int32_t {
    kTimestampFieldNumber = 8,
    kTimestampClockIdFieldNumber = 58,
    kFtraceEventsFieldNumber = 1,
    kProcessTreeFieldNumber = 2,
    kProcessStatsFieldNumber = 9,
    kInodeFileMapFieldNumber = 4,
    kChromeEventsFieldNumber = 5,
    kClockSnapshotFieldNumber = 6,
    kSysStatsFieldNumber = 7,
    kTrackEventFieldNumber = 11,
    kTraceConfigFieldNumber = 33,
    kFtraceStatsFieldNumber = 34,
    kTraceStatsFieldNumber = 35,
    kProfilePacketFieldNumber = 37,
    kBatteryFieldNumber = 38,
    kPowerRailsFieldNumber = 40,
    kAndroidLogFieldNumber = 39,
    kSystemInfoFieldNumber = 45,
    kTriggerFieldNumber = 46,
    kPackagesListFieldNumber = 47,
    kChromeBenchmarkMetadataFieldNumber = 48,
    kPerfettoMetatraceFieldNumber = 49,
    kChromeMetadataFieldNumber = 51,
    kGpuCounterEventFieldNumber = 52,
    kGpuRenderStageEventFieldNumber = 53,
    kStreamingProfilePacketFieldNumber = 54,
    kHeapGraphFieldNumber = 56,
    kGraphicsFrameEventFieldNumber = 57,
    kVulkanMemoryEventFieldNumber = 62,
    kGpuLogFieldNumber = 63,
    kProfiledFrameSymbolsFieldNumber = 55,
    kModuleSymbolsFieldNumber = 61,
    kDeobfuscationMappingFieldNumber = 64,
    kTrackDescriptorFieldNumber = 60,
    kProcessDescriptorFieldNumber = 43,
    kThreadDescriptorFieldNumber = 44,
    kSynchronizationMarkerFieldNumber = 36,
    kCompressedPacketsFieldNumber = 50,
    kForTestingFieldNumber = 900,
    kTrustedUidFieldNumber = 3,
    kTrustedPacketSequenceIdFieldNumber = 10,
    kInternedDataFieldNumber = 12,
    kSequenceFlagsFieldNumber = 13,
    kIncrementalStateClearedFieldNumber = 41,
    kTracePacketDefaultsFieldNumber = 59,
    kPreviousPacketDroppedFieldNumber = 42,
  };
  using SequenceFlags = ::perfetto::protos::pbzero::TracePacket_SequenceFlags;
  static const SequenceFlags SEQ_UNSPECIFIED = TracePacket_SequenceFlags_SEQ_UNSPECIFIED;
  static const SequenceFlags SEQ_INCREMENTAL_STATE_CLEARED = TracePacket_SequenceFlags_SEQ_INCREMENTAL_STATE_CLEARED;
  static const SequenceFlags SEQ_NEEDS_INCREMENTAL_STATE = TracePacket_SequenceFlags_SEQ_NEEDS_INCREMENTAL_STATE;
  void set_timestamp(uint64_t value) {
    AppendVarInt(8, value);
  }
  void set_timestamp_clock_id(uint32_t value) {
    AppendVarInt(58, value);
  }
  template <typename T = FtraceEventBundle> T* set_ftrace_events() {
    return BeginNestedMessage<T>(1);
  }

  template <typename T = ProcessTree> T* set_process_tree() {
    return BeginNestedMessage<T>(2);
  }

  template <typename T = ProcessStats> T* set_process_stats() {
    return BeginNestedMessage<T>(9);
  }

  template <typename T = InodeFileMap> T* set_inode_file_map() {
    return BeginNestedMessage<T>(4);
  }

  template <typename T = ChromeEventBundle> T* set_chrome_events() {
    return BeginNestedMessage<T>(5);
  }

  template <typename T = ClockSnapshot> T* set_clock_snapshot() {
    return BeginNestedMessage<T>(6);
  }

  template <typename T = SysStats> T* set_sys_stats() {
    return BeginNestedMessage<T>(7);
  }

  template <typename T = TrackEvent> T* set_track_event() {
    return BeginNestedMessage<T>(11);
  }

  template <typename T = TraceConfig> T* set_trace_config() {
    return BeginNestedMessage<T>(33);
  }

  template <typename T = FtraceStats> T* set_ftrace_stats() {
    return BeginNestedMessage<T>(34);
  }

  template <typename T = TraceStats> T* set_trace_stats() {
    return BeginNestedMessage<T>(35);
  }

  template <typename T = ProfilePacket> T* set_profile_packet() {
    return BeginNestedMessage<T>(37);
  }

  template <typename T = BatteryCounters> T* set_battery() {
    return BeginNestedMessage<T>(38);
  }

  template <typename T = PowerRails> T* set_power_rails() {
    return BeginNestedMessage<T>(40);
  }

  template <typename T = AndroidLogPacket> T* set_android_log() {
    return BeginNestedMessage<T>(39);
  }

  template <typename T = SystemInfo> T* set_system_info() {
    return BeginNestedMessage<T>(45);
  }

  template <typename T = Trigger> T* set_trigger() {
    return BeginNestedMessage<T>(46);
  }

  template <typename T = PackagesList> T* set_packages_list() {
    return BeginNestedMessage<T>(47);
  }

  template <typename T = ChromeBenchmarkMetadata> T* set_chrome_benchmark_metadata() {
    return BeginNestedMessage<T>(48);
  }

  template <typename T = PerfettoMetatrace> T* set_perfetto_metatrace() {
    return BeginNestedMessage<T>(49);
  }

  template <typename T = ChromeMetadataPacket> T* set_chrome_metadata() {
    return BeginNestedMessage<T>(51);
  }

  template <typename T = GpuCounterEvent> T* set_gpu_counter_event() {
    return BeginNestedMessage<T>(52);
  }

  template <typename T = GpuRenderStageEvent> T* set_gpu_render_stage_event() {
    return BeginNestedMessage<T>(53);
  }

  template <typename T = StreamingProfilePacket> T* set_streaming_profile_packet() {
    return BeginNestedMessage<T>(54);
  }

  template <typename T = HeapGraph> T* set_heap_graph() {
    return BeginNestedMessage<T>(56);
  }

  template <typename T = GraphicsFrameEvent> T* set_graphics_frame_event() {
    return BeginNestedMessage<T>(57);
  }

  template <typename T = VulkanMemoryEvent> T* set_vulkan_memory_event() {
    return BeginNestedMessage<T>(62);
  }

  template <typename T = GpuLog> T* set_gpu_log() {
    return BeginNestedMessage<T>(63);
  }

  template <typename T = ProfiledFrameSymbols> T* set_profiled_frame_symbols() {
    return BeginNestedMessage<T>(55);
  }

  template <typename T = ModuleSymbols> T* set_module_symbols() {
    return BeginNestedMessage<T>(61);
  }

  template <typename T = DeobfuscationMapping> T* set_deobfuscation_mapping() {
    return BeginNestedMessage<T>(64);
  }

  template <typename T = TrackDescriptor> T* set_track_descriptor() {
    return BeginNestedMessage<T>(60);
  }

  template <typename T = ProcessDescriptor> T* set_process_descriptor() {
    return BeginNestedMessage<T>(43);
  }

  template <typename T = ThreadDescriptor> T* set_thread_descriptor() {
    return BeginNestedMessage<T>(44);
  }

  void set_synchronization_marker(const std::string& value) {
    AppendBytes(36, value.data(), value.size());
  }
  void set_synchronization_marker(const uint8_t* data, size_t size) {
    AppendBytes(36, data, size);
  }
  void set_compressed_packets(const std::string& value) {
    AppendBytes(50, value.data(), value.size());
  }
  void set_compressed_packets(const uint8_t* data, size_t size) {
    AppendBytes(50, data, size);
  }
  template <typename T = TestEvent> T* set_for_testing() {
    return BeginNestedMessage<T>(900);
  }

  void set_trusted_uid(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_trusted_packet_sequence_id(uint32_t value) {
    AppendVarInt(10, value);
  }
  template <typename T = InternedData> T* set_interned_data() {
    return BeginNestedMessage<T>(12);
  }

  void set_sequence_flags(uint32_t value) {
    AppendVarInt(13, value);
  }
  void set_incremental_state_cleared(bool value) {
    AppendTinyVarInt(41, value);
  }
  template <typename T = TracePacketDefaults> T* set_trace_packet_defaults() {
    return BeginNestedMessage<T>(59);
  }

  void set_previous_packet_dropped(bool value) {
    AppendTinyVarInt(42, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated.16011/gen/protos/perfetto/trace/trace.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACE_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACE_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class TracePacket;

class Trace_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  Trace_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Trace_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Trace_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_packet() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator<::protozero::ConstBytes> packet() const { return GetRepeated<::protozero::ConstBytes>(1); }
};

class Trace : public ::protozero::Message {
 public:
  using Decoder = Trace_Decoder;
  enum : int32_t {
    kPacketFieldNumber = 1,
  };
  template <typename T = TracePacket> T* add_packet() {
    return BeginNestedMessage<T>(1);
  }

};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: include/perfetto/protozero/contiguous_memory_range.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_PROTOZERO_CONTIGUOUS_MEMORY_RANGE_H_
#define INCLUDE_PERFETTO_PROTOZERO_CONTIGUOUS_MEMORY_RANGE_H_

#include <assert.h>
#include <stddef.h>
#include <stdint.h>

namespace protozero {

// Keep this struct trivially constructible (no ctors, no default initializers).
struct ContiguousMemoryRange {
  uint8_t* begin;
  uint8_t* end;  // STL style: one byte past the end of the buffer.

  inline bool is_valid() const { return begin != nullptr; }
  inline void reset() { begin = nullptr; }
  inline size_t size() { return static_cast<size_t>(end - begin); }
};

}  // namespace protozero

#endif  // INCLUDE_PERFETTO_PROTOZERO_CONTIGUOUS_MEMORY_RANGE_H_
// gen_amalgamated begin header: include/perfetto/protozero/copyable_ptr.h
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_PROTOZERO_COPYABLE_PTR_H_
#define INCLUDE_PERFETTO_PROTOZERO_COPYABLE_PTR_H_

#include <memory>

namespace protozero {

// This class is essentially a std::vector<T> of fixed size = 1.
// It's a pointer wrapper with deep copying and deep equality comparison.
// At all effects this wrapper behaves like the underlying T, with the exception
// of the heap indirection.
// Conversely to a std::unique_ptr, the pointer will be always valid, never
// null. The problem it solves is the following: when generating C++ classes
// from proto files, we want to keep each header hermetic (i.e. not #include
// headers of dependent types). As such we can't directly instantiate T
// field members but we can instead rely on pointers, so only the .cc file needs
// to see the actual definition of T. If the generated classes were move-only we
// could just use a unique_ptr there. But they aren't, hence this wrapper.
// Converesely to unique_ptr, this wrapper:
// - Default constructs the T instance in its constructor.
// - Implements deep comparison in operator== instead of pointer comparison.
template <typename T>
class CopyablePtr {
 public:
  CopyablePtr() : ptr_(new T()) {}
  ~CopyablePtr() = default;

  // Copy operators.
  CopyablePtr(const CopyablePtr& other) : ptr_(new T(*other.ptr_)) {}
  CopyablePtr& operator=(const CopyablePtr& other) {
    *ptr_ = *other.ptr_;
    return *this;
  }

  // Move operators.
  CopyablePtr(CopyablePtr&& other) noexcept : ptr_(std::move(other.ptr_)) {
    other.ptr_.reset(new T());
  }

  CopyablePtr& operator=(CopyablePtr&& other) {
    ptr_ = std::move(other.ptr_);
    other.ptr_.reset(new T());
    return *this;
  }

  T* get() { return ptr_.get(); }
  const T* get() const { return ptr_.get(); }

  T* operator->() { return ptr_.get(); }
  const T* operator->() const { return ptr_.get(); }

  T& operator*() { return *ptr_; }
  const T& operator*() const { return *ptr_; }

  friend bool operator==(const CopyablePtr& lhs, const CopyablePtr& rhs) {
    return *lhs == *rhs;
  }

  friend bool operator!=(const CopyablePtr& lhs, const CopyablePtr& rhs) {
    // In theory the underlying type might have a special operator!=
    // implementation which is not just !(x == y). Respect that.
    return *lhs != *rhs;
  }

 private:
  std::unique_ptr<T> ptr_;
};

}  // namespace protozero

#endif  // INCLUDE_PERFETTO_PROTOZERO_COPYABLE_PTR_H_
// gen_amalgamated begin header: include/perfetto/protozero/cpp_message_obj.h
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_PROTOZERO_CPP_MESSAGE_OBJ_H_
#define INCLUDE_PERFETTO_PROTOZERO_CPP_MESSAGE_OBJ_H_

#include <stdint.h>

#include <string>
#include <vector>

// gen_amalgamated expanded: #include "perfetto/base/export.h"

namespace protozero {

// Base class for generated .gen.h classes, which are full C++ objects that
// support both ser and deserialization (but are not zero-copy).
// This is only used by the "cpp" targets not the "pbzero" ones.
class PERFETTO_EXPORT CppMessageObj {
 public:
  virtual ~CppMessageObj();
  virtual std::string SerializeAsString() const = 0;
  virtual std::vector<uint8_t> SerializeAsArray() const = 0;
  virtual bool ParseFromArray(const void*, size_t) = 0;

  bool ParseFromString(const std::string& str) {
    return ParseFromArray(str.data(), str.size());
  }
};

}  // namespace protozero

#endif  // INCLUDE_PERFETTO_PROTOZERO_CPP_MESSAGE_OBJ_H_
// gen_amalgamated begin header: include/perfetto/protozero/field.h
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_PROTOZERO_FIELD_H_
#define INCLUDE_PERFETTO_PROTOZERO_FIELD_H_

#include <stdint.h>

#include <string>

// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/protozero/contiguous_memory_range.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace protozero {

struct ConstBytes {
  std::string ToStdString() const {
    return std::string(reinterpret_cast<const char*>(data), size);
  }

  const uint8_t* data;
  size_t size;
};

struct ConstChars {
  // Allow implicit conversion to perfetto's base::StringView without depending
  // on perfetto/base or viceversa.
  static constexpr bool kConvertibleToStringView = true;
  std::string ToStdString() const { return std::string(data, size); }

  const char* data;
  size_t size;
};

// A protobuf field decoded by the protozero proto decoders. It exposes
// convenience accessors with minimal debug checks.
// This class is used both by the iterator-based ProtoDecoder and by the
// one-shot TypedProtoDecoder.
// If the field is not valid the accessors consistently return zero-integers or
// null strings.
class Field {
 public:
  bool valid() const { return id_ != 0; }
  uint16_t id() const { return id_; }
  explicit operator bool() const { return valid(); }

  proto_utils::ProtoWireType type() const {
    auto res = static_cast<proto_utils::ProtoWireType>(type_);
    PERFETTO_DCHECK(res == proto_utils::ProtoWireType::kVarInt ||
                    res == proto_utils::ProtoWireType::kLengthDelimited ||
                    res == proto_utils::ProtoWireType::kFixed32 ||
                    res == proto_utils::ProtoWireType::kFixed64);
    return res;
  }

  bool as_bool() const {
    PERFETTO_DCHECK(!valid() || type() == proto_utils::ProtoWireType::kVarInt);
    return static_cast<bool>(int_value_);
  }

  uint32_t as_uint32() const {
    PERFETTO_DCHECK(!valid() || type() == proto_utils::ProtoWireType::kVarInt ||
                    type() == proto_utils::ProtoWireType::kFixed32);
    return static_cast<uint32_t>(int_value_);
  }

  int32_t as_int32() const {
    PERFETTO_DCHECK(!valid() || type() == proto_utils::ProtoWireType::kVarInt ||
                    type() == proto_utils::ProtoWireType::kFixed32);
    return static_cast<int32_t>(int_value_);
  }

  int32_t as_sint32() const {
    PERFETTO_DCHECK(!valid() || type() == proto_utils::ProtoWireType::kVarInt);
    return proto_utils::ZigZagDecode(static_cast<uint32_t>(int_value_));
  }

  uint64_t as_uint64() const {
    PERFETTO_DCHECK(!valid() || type() == proto_utils::ProtoWireType::kVarInt ||
                    type() == proto_utils::ProtoWireType::kFixed32 ||
                    type() == proto_utils::ProtoWireType::kFixed64);
    return int_value_;
  }

  int64_t as_int64() const {
    PERFETTO_DCHECK(!valid() || type() == proto_utils::ProtoWireType::kVarInt ||
                    type() == proto_utils::ProtoWireType::kFixed32 ||
                    type() == proto_utils::ProtoWireType::kFixed64);
    return static_cast<int64_t>(int_value_);
  }

  int64_t as_sint64() const {
    PERFETTO_DCHECK(!valid() || type() == proto_utils::ProtoWireType::kVarInt);
    return proto_utils::ZigZagDecode(static_cast<uint64_t>(int_value_));
  }

  float as_float() const {
    PERFETTO_DCHECK(!valid() || type() == proto_utils::ProtoWireType::kFixed32);
    float res;
    uint32_t value32 = static_cast<uint32_t>(int_value_);
    memcpy(&res, &value32, sizeof(res));
    return res;
  }

  double as_double() const {
    PERFETTO_DCHECK(!valid() || type() == proto_utils::ProtoWireType::kFixed64);
    double res;
    memcpy(&res, &int_value_, sizeof(res));
    return res;
  }

  ConstChars as_string() const {
    PERFETTO_DCHECK(!valid() ||
                    type() == proto_utils::ProtoWireType::kLengthDelimited);
    return ConstChars{reinterpret_cast<const char*>(data()), size_};
  }

  std::string as_std_string() const { return as_string().ToStdString(); }

  ConstBytes as_bytes() const {
    PERFETTO_DCHECK(!valid() ||
                    type() == proto_utils::ProtoWireType::kLengthDelimited);
    return ConstBytes{data(), size_};
  }

  const uint8_t* data() const {
    PERFETTO_DCHECK(!valid() ||
                    type() == proto_utils::ProtoWireType::kLengthDelimited);
    return reinterpret_cast<const uint8_t*>(int_value_);
  }

  size_t size() const {
    PERFETTO_DCHECK(!valid() ||
                    type() == proto_utils::ProtoWireType::kLengthDelimited);
    return size_;
  }

  uint64_t raw_int_value() const { return int_value_; }

  void initialize(uint16_t id,
                  uint8_t type,
                  uint64_t int_value,
                  uint32_t size) {
    id_ = id;
    type_ = type;
    int_value_ = int_value;
    size_ = size;
  }

  // For use with templates. This is used by RepeatedFieldIterator::operator*().
  void get(bool* val) const { *val = as_bool(); }
  void get(uint32_t* val) const { *val = as_uint32(); }
  void get(int32_t* val) const { *val = as_int32(); }
  void get(uint64_t* val) const { *val = as_uint64(); }
  void get(int64_t* val) const { *val = as_int64(); }
  void get(float* val) const { *val = as_float(); }
  void get(double* val) const { *val = as_double(); }
  void get(std::string* val) const { *val = as_std_string(); }
  void get(ConstChars* val) const { *val = as_string(); }
  void get(ConstBytes* val) const { *val = as_bytes(); }
  void get_signed(int32_t* val) const { *val = as_sint32(); }
  void get_signed(int64_t* val) const { *val = as_sint64(); }

  // For enum types.
  template <typename T,
            typename = typename std::enable_if<std::is_enum<T>::value, T>::type>
  void get(T* val) const {
    *val = static_cast<T>(as_int32());
  }

  // Serializes the field back into a proto-encoded byte stream and appends it
  // to |dst|. |dst| is resized accordingly.
  void SerializeAndAppendTo(std::string* dst);

 private:
  // Fields are deliberately not initialized to keep the class trivially
  // constructible. It makes a large perf difference for ProtoDecoder.

  uint64_t int_value_;  // In kLengthDelimited this contains the data() addr.
  uint32_t size_;       // Only valid when when type == kLengthDelimited.
  uint16_t id_;         // Proto field ordinal.
  uint8_t type_;        // proto_utils::ProtoWireType.
};

// The Field struct is used in a lot of perf-sensitive contexts.
static_assert(sizeof(Field) == 16, "Field struct too big");

}  // namespace protozero

#endif  // INCLUDE_PERFETTO_PROTOZERO_FIELD_H_
// gen_amalgamated begin header: include/perfetto/protozero/message.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_PROTOZERO_MESSAGE_H_
#define INCLUDE_PERFETTO_PROTOZERO_MESSAGE_H_

#include <assert.h>
#include <stdint.h>
#include <string.h>

#include <string>
#include <type_traits>

// gen_amalgamated expanded: #include "perfetto/base/export.h"
// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/protozero/contiguous_memory_range.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"
// gen_amalgamated expanded: #include "perfetto/protozero/scattered_stream_writer.h"

namespace perfetto {
namespace shm_fuzz {
class FakeProducer;
}  // namespace shm_fuzz
}  // namespace perfetto

namespace protozero {

class MessageHandleBase;

// Base class extended by the proto C++ stubs generated by the ProtoZero
// compiler. This class provides the minimal runtime required to support
// append-only operations and is designed for performance. None of the methods
// require any dynamic memory allocation.
class PERFETTO_EXPORT Message {
 public:
  friend class MessageHandleBase;

  // Adjust the |nested_messages_arena_| size when changing this, or the
  // static_assert in the .cc file will bark.
  static constexpr uint32_t kMaxNestingDepth = 10;

  // Ctor and Dtor of Message are never called, with the exeception
  // of root (non-nested) messages. Nested messages are allocated via placement
  // new in the |nested_messages_arena_| and implictly destroyed when the arena
  // of the root message goes away. This is fine as long as all the fields are
  // PODs, which is checked by the static_assert in the ctor (see the Reset()
  // method in the .cc file).
  Message() = default;

  // Clears up the state, allowing the message to be reused as a fresh one.
  void Reset(ScatteredStreamWriter*);

  // Commits all the changes to the buffer (backfills the size field of this and
  // all nested messages) and seals the message. Returns the size of the message
  // (and all nested sub-messages), without taking into account any chunking.
  // Finalize is idempotent and can be called several times w/o side effects.
  uint32_t Finalize();

  // Optional. If is_valid() == true, the corresponding memory region (its
  // length == proto_utils::kMessageLengthFieldSize) is backfilled with the size
  // of this message (minus |size_already_written| below). This is the mechanism
  // used by messages to backfill their corresponding size field in the parent
  // message.
  uint8_t* size_field() const { return size_field_; }
  void set_size_field(uint8_t* size_field) { size_field_ = size_field; }

  // This is to deal with case of backfilling the size of a root (non-nested)
  // message which is split into multiple chunks. Upon finalization only the
  // partial size that lies in the last chunk has to be backfilled.
  void inc_size_already_written(uint32_t sz) { size_already_written_ += sz; }

  Message* nested_message() { return nested_message_; }

  bool is_finalized() const { return finalized_; }

#if PERFETTO_DCHECK_IS_ON()
  void set_handle(MessageHandleBase* handle) { handle_ = handle; }
#endif

  // Proto types: uint64, uint32, int64, int32, bool, enum.
  template <typename T>
  void AppendVarInt(uint32_t field_id, T value) {
    if (nested_message_)
      EndNestedMessage();

    uint8_t buffer[proto_utils::kMaxSimpleFieldEncodedSize];
    uint8_t* pos = buffer;

    pos = proto_utils::WriteVarInt(proto_utils::MakeTagVarInt(field_id), pos);
    // WriteVarInt encodes signed values in two's complement form.
    pos = proto_utils::WriteVarInt(value, pos);
    WriteToStream(buffer, pos);
  }

  // Proto types: sint64, sint32.
  template <typename T>
  void AppendSignedVarInt(uint32_t field_id, T value) {
    AppendVarInt(field_id, proto_utils::ZigZagEncode(value));
  }

  // Proto types: bool, enum (small).
  // Faster version of AppendVarInt for tiny numbers.
  void AppendTinyVarInt(uint32_t field_id, int32_t value) {
    PERFETTO_DCHECK(0 <= value && value < 0x80);
    if (nested_message_)
      EndNestedMessage();

    uint8_t buffer[proto_utils::kMaxSimpleFieldEncodedSize];
    uint8_t* pos = buffer;
    // MakeTagVarInt gets super optimized here for constexpr.
    pos = proto_utils::WriteVarInt(proto_utils::MakeTagVarInt(field_id), pos);
    *pos++ = static_cast<uint8_t>(value);
    WriteToStream(buffer, pos);
  }

  // Proto types: fixed64, sfixed64, fixed32, sfixed32, double, float.
  template <typename T>
  void AppendFixed(uint32_t field_id, T value) {
    if (nested_message_)
      EndNestedMessage();

    uint8_t buffer[proto_utils::kMaxSimpleFieldEncodedSize];
    uint8_t* pos = buffer;

    pos = proto_utils::WriteVarInt(proto_utils::MakeTagFixed<T>(field_id), pos);
    memcpy(pos, &value, sizeof(T));
    pos += sizeof(T);
    // TODO: Optimize memcpy performance, see http://crbug.com/624311 .
    WriteToStream(buffer, pos);
  }

  void AppendString(uint32_t field_id, const char* str);

  void AppendString(uint32_t field_id, const std::string& str) {
    AppendBytes(field_id, str.data(), str.size());
  }

  void AppendBytes(uint32_t field_id, const void* value, size_t size);

  // Append raw bytes for a field, using the supplied |ranges| to
  // copy from |num_ranges| individual buffers.
  size_t AppendScatteredBytes(uint32_t field_id,
                              ContiguousMemoryRange* ranges,
                              size_t num_ranges);

  // Begins a nested message, using the static storage provided by the parent
  // class (see comment in |nested_messages_arena_|). The nested message ends
  // either when Finalize() is called or when any other Append* method is called
  // in the parent class.
  // The template argument T is supposed to be a stub class auto generated from
  // a .proto, hence a subclass of Message.
  template <class T>
  T* BeginNestedMessage(uint32_t field_id) {
    // This is to prevent subclasses (which should be autogenerated, though), to
    // introduce extra state fields (which wouldn't be initialized by Reset()).
    static_assert(std::is_base_of<Message, T>::value,
                  "T must be a subclass of Message");
    static_assert(sizeof(T) == sizeof(Message),
                  "Message subclasses cannot introduce extra state.");
    T* message = reinterpret_cast<T*>(nested_messages_arena_);
    BeginNestedMessageInternal(field_id, message);
    return message;
  }

  ScatteredStreamWriter* stream_writer_for_testing() { return stream_writer_; }

  // Appends some raw bytes to the message. The use-case for this is preserving
  // unknown fields in the decode -> re-encode path of xxx.gen.cc classes
  // generated by the cppgen_plugin.cc.
  // The caller needs to guarantee that the appended data is properly
  // proto-encoded and each field has a proto preamble.
  void AppendRawProtoBytes(const void* data, size_t size) {
    const uint8_t* src = reinterpret_cast<const uint8_t*>(data);
    WriteToStream(src, src + size);
  }

 private:
  Message(const Message&) = delete;
  Message& operator=(const Message&) = delete;

  void BeginNestedMessageInternal(uint32_t field_id, Message*);

  // Called by Finalize and Append* methods.
  void EndNestedMessage();

  void WriteToStream(const uint8_t* src_begin, const uint8_t* src_end) {
    PERFETTO_DCHECK(!finalized_);
    PERFETTO_DCHECK(src_begin <= src_end);
    const uint32_t size = static_cast<uint32_t>(src_end - src_begin);
    stream_writer_->WriteBytes(src_begin, size);
    size_ += size;
  }

  // Only POD fields are allowed. This class's dtor is never called.
  // See the comment on the static_assert in the corresponding .cc file.

  // The stream writer interface used for the serialization.
  ScatteredStreamWriter* stream_writer_;

  uint8_t* size_field_;

  // Keeps track of the size of the current message.
  uint32_t size_;

  // See comment for inc_size_already_written().
  uint32_t size_already_written_;

  // When true, no more changes to the message are allowed. This is to DCHECK
  // attempts of writing to a message which has been Finalize()-d.
  bool finalized_;

  // Used to detect attemps to create messages with a nesting level >
  // kMaxNestingDepth. |nesting_depth_| == 0 for root (non-nested) messages.
  uint8_t nesting_depth_;

#if PERFETTO_DCHECK_IS_ON()
  // Current generation of message. Incremented on Reset.
  // Used to detect stale handles.
  uint32_t generation_;

  MessageHandleBase* handle_;
#endif

  // Pointer to the last child message created through BeginNestedMessage(), if
  // any, nullptr otherwise. There is no need to keep track of more than one
  // message per nesting level as the proto-zero API contract mandates that
  // nested fields can be filled only in a stacked fashion. In other words,
  // nested messages are finalized and sealed when any other field is set in the
  // parent message (or the parent message itself is finalized) and cannot be
  // accessed anymore afterwards.
  // TODO(primiano): optimization: I think that nested_message_, when non-null.
  // will always be @ (this) + offsetof(nested_messages_arena_).
  Message* nested_message_;

  // The root message owns the storage for all its nested messages, up to a max
  // of kMaxNestingDepth levels (see the .cc file). Note that the boundaries of
  // the arena are meaningful only for the root message.
  // Unfortunately we cannot put the sizeof() math here because we cannot sizeof
  // the current class in a header. However the .cc file has a static_assert
  // that guarantees that (see the Reset() method in the .cc file).
  alignas(sizeof(void*)) uint8_t nested_messages_arena_[512];

  // DO NOT add any fields below |nested_messages_arena_|. The memory layout of
  // nested messages would overflow the storage allocated by the root message.
};

}  // namespace protozero

#endif  // INCLUDE_PERFETTO_PROTOZERO_MESSAGE_H_
// gen_amalgamated begin header: include/perfetto/protozero/message_handle.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_PROTOZERO_MESSAGE_HANDLE_H_
#define INCLUDE_PERFETTO_PROTOZERO_MESSAGE_HANDLE_H_

#include <functional>

// gen_amalgamated expanded: #include "perfetto/base/export.h"
// gen_amalgamated expanded: #include "perfetto/protozero/message.h"

namespace protozero {

class Message;

// MessageHandle allows to decouple the lifetime of a proto message
// from the underlying storage. It gives the following guarantees:
// - The underlying message is finalized (if still alive) if the handle goes
//   out of scope.
// - In Debug / DCHECK_ALWAYS_ON builds, the handle becomes null once the
//   message is finalized. This is to enforce the append-only API. For instance
//   when adding two repeated messages, the addition of the 2nd one forces
//   the finalization of the first.
// Think about this as a WeakPtr<Message> which calls
// Message::Finalize() when going out of scope.

class PERFETTO_EXPORT MessageHandleBase {
 public:
  class FinalizationListener {
   public:
    virtual ~FinalizationListener();
    virtual void OnMessageFinalized(Message* message) = 0;
  };

  ~MessageHandleBase();

  // Move-only type.
  MessageHandleBase(MessageHandleBase&&) noexcept;
  MessageHandleBase& operator=(MessageHandleBase&&);
  explicit operator bool() const {
#if PERFETTO_DCHECK_IS_ON()
    PERFETTO_DCHECK(!message_ || generation_ == message_->generation_);
#endif
    return !!message_;
  }

  void set_finalization_listener(FinalizationListener* listener) {
    listener_ = listener;
  }

 protected:
  explicit MessageHandleBase(Message* = nullptr);
  Message* operator->() const {
#if PERFETTO_DCHECK_IS_ON()
    PERFETTO_DCHECK(!message_ || generation_ == message_->generation_);
#endif
    return message_;
  }
  Message& operator*() const { return *(operator->()); }

 private:
  friend class Message;
  MessageHandleBase(const MessageHandleBase&) = delete;
  MessageHandleBase& operator=(const MessageHandleBase&) = delete;

  void reset_message() {
    // This is called by Message::Finalize().
    PERFETTO_DCHECK(message_->is_finalized());
    message_ = nullptr;
    listener_ = nullptr;
  }

  void Move(MessageHandleBase&&);

  void FinalizeMessage() {
    // |message_| and |listener_| may be cleared by reset_message() during
    // Message::Finalize().
    auto* listener = listener_;
    auto* message = message_;
    message->Finalize();
    if (listener)
      listener->OnMessageFinalized(message);
  }

  Message* message_;
  FinalizationListener* listener_ = nullptr;
#if PERFETTO_DCHECK_IS_ON()
  uint32_t generation_;
#endif
};

template <typename T>
class MessageHandle : public MessageHandleBase {
 public:
  MessageHandle() : MessageHandle(nullptr) {}
  explicit MessageHandle(T* message) : MessageHandleBase(message) {}

  T& operator*() const {
    return static_cast<T&>(MessageHandleBase::operator*());
  }

  T* operator->() const {
    return static_cast<T*>(MessageHandleBase::operator->());
  }
};

}  // namespace protozero

#endif  // INCLUDE_PERFETTO_PROTOZERO_MESSAGE_HANDLE_H_
// gen_amalgamated begin header: include/perfetto/protozero/packed_repeated_fields.h
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_PROTOZERO_PACKED_REPEATED_FIELDS_H_
#define INCLUDE_PERFETTO_PROTOZERO_PACKED_REPEATED_FIELDS_H_

#include <stdint.h>

#include <array>
#include <memory>
#include <type_traits>

// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace protozero {

// This file contains classes used when encoding packed repeated fields.
// To encode such a field, the caller is first expected to accumulate all of the
// values in one of the following types (depending on the wire type of the
// individual elements), defined below:
// * protozero::PackedVarInt
// * protozero::PackedFixedSizeInt</*element_type=*/ uint32_t>
// Then that buffer is passed to the protozero-generated setters as an argument.
// After calling the setter, the buffer can be destroyed.
//
// An example of encoding a packed field:
//   protozero::HeapBuffered<protozero::Message> msg;
//   protozero::PackedVarInt buf;
//   buf.Append(42);
//   buf.Append(-1);
//   msg->set_fieldname(buf);
//   msg.SerializeAsString();

class PackedBufferBase {
 public:
  PackedBufferBase() { Reset(); }

  // Copy or move is disabled due to pointers to stack addresses.
  PackedBufferBase(const PackedBufferBase&) = delete;
  PackedBufferBase(PackedBufferBase&&) = delete;
  PackedBufferBase& operator=(const PackedBufferBase&) = delete;
  PackedBufferBase& operator=(PackedBufferBase&&) = delete;

  void Reset();

  const uint8_t* data() const { return storage_begin_; }

  size_t size() const {
    return static_cast<size_t>(write_ptr_ - storage_begin_);
  }

 protected:
  void GrowIfNeeded() {
    PERFETTO_DCHECK(write_ptr_ >= storage_begin_ && write_ptr_ <= storage_end_);
    if (PERFETTO_UNLIKELY(write_ptr_ + kMaxElementSize > storage_end_)) {
      GrowSlowpath();
    }
  }

  void GrowSlowpath();

  // max(uint64_t varint encoding, biggest fixed type (uint64)).
  static constexpr size_t kMaxElementSize = 10;

  // So sizeof(this) == 8k.
  static constexpr size_t kOnStackStorageSize = 8192 - 32;

  uint8_t* storage_begin_;
  uint8_t* storage_end_;
  uint8_t* write_ptr_;
  std::unique_ptr<uint8_t[]> heap_buf_;
  alignas(uint64_t) uint8_t stack_buf_[kOnStackStorageSize];
};

class PackedVarInt : public PackedBufferBase {
 public:
  template <typename T>
  void Append(T value) {
    GrowIfNeeded();
    write_ptr_ = proto_utils::WriteVarInt(value, write_ptr_);
  }
};

template <typename T /* e.g. uint32_t for Fixed32 */>
class PackedFixedSizeInt : public PackedBufferBase {
 public:
  void Append(T value) {
    static_assert(sizeof(T) == 4 || sizeof(T) == 8,
                  "PackedFixedSizeInt should be used only with 32/64-bit ints");
    static_assert(sizeof(T) <= kMaxElementSize,
                  "kMaxElementSize needs to be updated");
    GrowIfNeeded();
    PERFETTO_DCHECK(reinterpret_cast<size_t>(write_ptr_) % alignof(T) == 0);
    memcpy(reinterpret_cast<T*>(write_ptr_), &value, sizeof(T));
    write_ptr_ += sizeof(T);
  }
};

}  // namespace protozero

#endif  // INCLUDE_PERFETTO_PROTOZERO_PACKED_REPEATED_FIELDS_H_
// gen_amalgamated begin header: include/perfetto/protozero/proto_decoder.h
/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_PROTOZERO_PROTO_DECODER_H_
#define INCLUDE_PERFETTO_PROTOZERO_PROTO_DECODER_H_

#include <stdint.h>
#include <array>
#include <memory>
#include <vector>

// gen_amalgamated expanded: #include "perfetto/base/compiler.h"
// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/protozero/field.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace protozero {

// A generic protobuf decoder. Doesn't require any knowledge about the proto
// schema. It tokenizes fields, retrieves their ID and type and exposes
// accessors to retrieve its values.
// It does NOT recurse in nested submessages, instead it just computes their
// boundaries, recursion is left to the caller.
// This class is designed to be used in perf-sensitive contexts. It does not
// allocate and does not perform any proto semantic checks (e.g. repeated /
// required / optional). It's supposedly safe wrt out-of-bounds memory accesses
// (see proto_decoder_fuzzer.cc).
// This class serves also as a building block for TypedProtoDecoder, used when
// the schema is known at compile time.
class ProtoDecoder {
 public:
  // Creates a ProtoDecoder using the given |buffer| with size |length| bytes.
  ProtoDecoder(const void* buffer, size_t length)
      : begin_(reinterpret_cast<const uint8_t*>(buffer)),
        end_(begin_ + length),
        read_ptr_(begin_) {}
  ProtoDecoder(const std::string& str) : ProtoDecoder(str.data(), str.size()) {}
  ProtoDecoder(const ConstBytes& cb) : ProtoDecoder(cb.data, cb.size) {}

  // Reads the next field from the buffer and advances the read cursor. If a
  // full field cannot be read, the returned Field will be invalid (i.e.
  // field.valid() == false).
  Field ReadField();

  // Finds the first field with the given id. Doesn't affect the read cursor.
  Field FindField(uint32_t field_id);

  // Resets the read cursor to the start of the buffer.
  void Reset() { read_ptr_ = begin_; }

  // Resets the read cursor to the given position (must be within the buffer).
  void Reset(const uint8_t* pos) {
    PERFETTO_DCHECK(pos >= begin_ && pos < end_);
    read_ptr_ = pos;
  }

  // Returns the position of read cursor, relative to the start of the buffer.
  size_t read_offset() const { return static_cast<size_t>(read_ptr_ - begin_); }

  size_t bytes_left() const {
    PERFETTO_DCHECK(read_ptr_ <= end_);
    return static_cast<size_t>(end_ - read_ptr_);
  }

  const uint8_t* begin() const { return begin_; }
  const uint8_t* end() const { return end_; }

 protected:
  const uint8_t* const begin_;
  const uint8_t* const end_;
  const uint8_t* read_ptr_ = nullptr;
};

// An iterator-like class used to iterate through repeated fields. Used by
// TypedProtoDecoder. The iteration sequence is a bit counter-intuitive due to
// the fact that fields_[field_id] holds the *last* value of the field, not the
// first, but the remaining storage holds repeated fields in FIFO order.
// Assume that we push the 10,11,12 into a repeated field with ID=1.
//
// Decoder memory layout:  [  fields storage  ] [ repeated fields storage ]
// 1st iteration:           10
// 2nd iteration:           11                   10
// 3rd iteration:           12                   10 11
//
// We start the iteration @ fields_[num_fields], which is the start of the
// repeated fields storage, proceed until the end and lastly jump @ fields_[id].
template <typename T>
class RepeatedFieldIterator {
 public:
  RepeatedFieldIterator(uint32_t field_id,
                        const Field* begin,
                        const Field* end,
                        const Field* last)
      : field_id_(field_id), iter_(begin), end_(end), last_(last) {
    FindNextMatchingId();
  }

  explicit operator bool() const { return iter_ != end_; }
  const Field& field() const { return *iter_; }

  T operator*() const {
    T val{};
    iter_->get(&val);
    return val;
  }
  const Field* operator->() const { return iter_; }

  RepeatedFieldIterator& operator++() {
    PERFETTO_DCHECK(iter_ != end_);
    if (iter_ == last_) {
      iter_ = end_;
      return *this;
    }
    ++iter_;
    FindNextMatchingId();
    return *this;
  }

  RepeatedFieldIterator operator++(int) {
    PERFETTO_DCHECK(iter_ != end_);
    RepeatedFieldIterator it(*this);
    ++(*this);
    return it;
  }

 private:
  void FindNextMatchingId() {
    PERFETTO_DCHECK(iter_ != last_);
    for (; iter_ != end_; ++iter_) {
      if (iter_->id() == field_id_)
        return;
    }
    iter_ = last_->valid() ? last_ : end_;
  }

  uint32_t field_id_;

  // Initially points to the beginning of the repeated field storage, then is
  // incremented as we call operator++().
  const Field* iter_;

  // Always points to fields_[size_], i.e. past the end of the storage.
  const Field* end_;

  // Always points to fields_[field_id].
  const Field* last_;
};

// As RepeatedFieldIterator, but allows iterating over a packed repeated field
// (which will be initially stored as a single length-delimited field).
// See |GetPackedRepeatedField| for details.
//
// Assumes little endianness, and that the input buffers are well formed -
// containing an exact multiple of encoded elements.
template <proto_utils::ProtoWireType wire_type, typename CppType>
class PackedRepeatedFieldIterator {
 public:
  PackedRepeatedFieldIterator(const uint8_t* data_begin,
                              size_t size,
                              bool* parse_error_ptr)
      : data_end_(data_begin ? data_begin + size : nullptr),
        read_ptr_(data_begin),
        parse_error_(parse_error_ptr) {
    using proto_utils::ProtoWireType;
    static_assert(wire_type == ProtoWireType::kVarInt ||
                      wire_type == ProtoWireType::kFixed32 ||
                      wire_type == ProtoWireType::kFixed64,
                  "invalid type");

    PERFETTO_DCHECK(parse_error_ptr);

    // Either the field is unset (and there are no data pointer), or the field
    // is set with a zero length payload. Mark the iterator as invalid in both
    // cases.
    if (size == 0) {
      curr_value_valid_ = false;
      return;
    }

    if ((wire_type == ProtoWireType::kFixed32 && (size % 4) != 0) ||
        (wire_type == ProtoWireType::kFixed64 && (size % 8) != 0)) {
      *parse_error_ = true;
      curr_value_valid_ = false;
      return;
    }

    ++(*this);
  }

  const CppType operator*() const { return curr_value_; }
  explicit operator bool() const { return curr_value_valid_; }

  PackedRepeatedFieldIterator& operator++() {
    using proto_utils::ProtoWireType;

    if (PERFETTO_UNLIKELY(!curr_value_valid_))
      return *this;

    if (PERFETTO_UNLIKELY(read_ptr_ == data_end_)) {
      curr_value_valid_ = false;
      return *this;
    }

    if (wire_type == ProtoWireType::kVarInt) {
      uint64_t new_value = 0;
      const uint8_t* new_pos =
          proto_utils::ParseVarInt(read_ptr_, data_end_, &new_value);

      if (PERFETTO_UNLIKELY(new_pos == read_ptr_)) {
        // Failed to decode the varint (probably incomplete buffer).
        *parse_error_ = true;
        curr_value_valid_ = false;
      } else {
        read_ptr_ = new_pos;
        curr_value_ = static_cast<CppType>(new_value);
      }
    } else {  // kFixed32 or kFixed64
      constexpr size_t kStep = wire_type == ProtoWireType::kFixed32 ? 4 : 8;

      // NB: the raw buffer is not guaranteed to be aligned, so neither are
      // these copies.
      memcpy(&curr_value_, read_ptr_, sizeof(CppType));
      read_ptr_ += kStep;
    }

    return *this;
  }

  PackedRepeatedFieldIterator operator++(int) {
    PackedRepeatedFieldIterator it(*this);
    ++(*this);
    return it;
  }

 private:
  // Might be null if the backing proto field isn't set.
  const uint8_t* const data_end_;

  // The iterator looks ahead by an element, so |curr_value| holds the value
  // to be returned when the caller dereferences the iterator, and |read_ptr_|
  // points at the start of the next element to be decoded.
  // |read_ptr_| might be null if the backing proto field isn't set.
  const uint8_t* read_ptr_;
  CppType curr_value_ = 0;

  // Set to false once we've exhausted the iterator, or encountered an error.
  bool curr_value_valid_ = true;

  // Where to set parsing errors, supplied by the caller.
  bool* const parse_error_;
};

// This decoder loads all fields upfront, without recursing in nested messages.
// It is used as a base class for typed decoders generated by the pbzero plugin.
// The split between TypedProtoDecoderBase and TypedProtoDecoder<> is to have
// unique definition of functions like ParseAllFields() and ExpandHeapStorage().
// The storage (either on-stack or on-heap) for this class is organized as
// follows:
// |-------------------------- fields_ ----------------------|
// [ field 0 (invalid) ] [ fields 1 .. N ] [ repeated fields ]
//                                        ^                  ^
//                                        num_fields_        size_
class TypedProtoDecoderBase : public ProtoDecoder {
 public:
  // If the field |id| is known at compile time, prefer the templated
  // specialization at<kFieldNumber>().
  const Field& Get(uint32_t id) const {
    return PERFETTO_LIKELY(id < num_fields_) ? fields_[id] : fields_[0];
  }

  // Returns an object that allows to iterate over all instances of a repeated
  // field given its id. Example usage:
  //   for (auto it = decoder.GetRepeated<int32_t>(N); it; ++it) { ... }
  template <typename T>
  RepeatedFieldIterator<T> GetRepeated(uint32_t field_id) const {
    return RepeatedFieldIterator<T>(field_id, &fields_[num_fields_],
                                    &fields_[size_], &fields_[field_id]);
  }

  // Returns an objects that allows to iterate over all entries of a packed
  // repeated field given its id and type. The |wire_type| is necessary for
  // decoding the packed field, the |cpp_type| is for convenience & stronger
  // typing.
  //
  // The caller must also supply a pointer to a bool that is set to true if the
  // packed buffer is found to be malformed while iterating (so you need to
  // exhaust the iterator if you want to check the full extent of the buffer).
  //
  // Note that unlike standard protobuf parsers, protozero does not allow
  // treating of packed repeated fields as non-packed and vice-versa (therefore
  // not making the packed option forwards and backwards compatible). So
  // the caller needs to use the right accessor for correct results.
  template <proto_utils::ProtoWireType wire_type, typename cpp_type>
  PackedRepeatedFieldIterator<wire_type, cpp_type> GetPackedRepeated(
      uint32_t field_id,
      bool* parse_error_location) const {
    const Field& field = Get(field_id);
    if (field.valid()) {
      return PackedRepeatedFieldIterator<wire_type, cpp_type>(
          field.data(), field.size(), parse_error_location);
    } else {
      return PackedRepeatedFieldIterator<wire_type, cpp_type>(
          nullptr, 0, parse_error_location);
    }
  }

 protected:
  TypedProtoDecoderBase(Field* storage,
                        uint32_t num_fields,
                        uint32_t capacity,
                        const uint8_t* buffer,
                        size_t length)
      : ProtoDecoder(buffer, length),
        fields_(storage),
        num_fields_(num_fields),
        size_(num_fields),
        capacity_(capacity) {
    // The reason why Field needs to be trivially de/constructible is to avoid
    // implicit initializers on all the ~1000 entries. We need it to initialize
    // only on the first |max_field_id| fields, the remaining capacity doesn't
    // require initialization.
    static_assert(std::is_trivially_constructible<Field>::value &&
                      std::is_trivially_destructible<Field>::value &&
                      std::is_trivial<Field>::value,
                  "Field must be a trivial aggregate type");
    memset(fields_, 0, sizeof(Field) * num_fields_);
  }

  void ParseAllFields();

  // Called when the default on-stack storage is exhausted and new repeated
  // fields need to be pushed.
  void ExpandHeapStorage();

  // Used only in presence of a large number of repeated fields, when the
  // default on-stack storage is exhausted.
  std::unique_ptr<Field[]> heap_storage_;

  // Points to the storage, either on-stack (default, provided by the template
  // specialization) or |heap_storage_| after ExpandHeapStorage() is called, in
  // case of a large number of repeated fields.
  Field* fields_;

  // Number of fields without accounting repeated storage. This is equal to
  // MAX_FIELD_ID + 1 (to account for the invalid 0th field).
  // This value is always <= size_ (and hence <= capacity);
  uint32_t num_fields_;

  // Number of active |fields_| entries. This is initially equal to the highest
  // number of fields for the message (num_fields_ == MAX_FIELD_ID + 1) and can
  // grow up to |capacity_| in the case of repeated fields.
  uint32_t size_;

  // Initially equal to kFieldsCapacity of the TypedProtoDecoder
  // specialization. Can grow when falling back on heap-based storage, in which
  // case it represents the size (#fields with each entry of a repeated field
  // counted individually) of the |heap_storage_| array.
  uint32_t capacity_;
};

// Template class instantiated by the auto-generated decoder classes declared in
// xxx.pbzero.h files.
template <int MAX_FIELD_ID, bool HAS_NONPACKED_REPEATED_FIELDS>
class TypedProtoDecoder : public TypedProtoDecoderBase {
 public:
  TypedProtoDecoder(const uint8_t* buffer, size_t length)
      : TypedProtoDecoderBase(on_stack_storage_,
                              /*num_fields=*/MAX_FIELD_ID + 1,
                              kCapacity,
                              buffer,
                              length) {
    static_assert(MAX_FIELD_ID <= kMaxDecoderFieldId, "Field ordinal too high");
    TypedProtoDecoderBase::ParseAllFields();
  }

  template <uint32_t FIELD_ID>
  const Field& at() const {
    static_assert(FIELD_ID <= MAX_FIELD_ID, "FIELD_ID > MAX_FIELD_ID");
    return fields_[FIELD_ID];
  }

  TypedProtoDecoder(TypedProtoDecoder&& other) noexcept
      : TypedProtoDecoderBase(std::move(other)) {
    // If the moved-from decoder was using on-stack storage, we need to update
    // our pointer to point to this decoder's on-stack storage.
    if (fields_ == other.on_stack_storage_) {
      fields_ = on_stack_storage_;
      memcpy(on_stack_storage_, other.on_stack_storage_,
             sizeof(on_stack_storage_));
    }
  }

 private:
  // In the case of non-repeated fields, this constant defines the highest field
  // id we are able to decode. This is to limit the on-stack storage.
  // In the case of repeated fields, this constant defines the max number of
  // repeated fields that we'll be able to store before falling back on the
  // heap. Keep this value in sync with the one in protozero_generator.cc.
  static constexpr size_t kMaxDecoderFieldId = 999;

  // If we the message has no repeated fields we need at most N Field entries
  // in the on-stack storage, where N is the highest field id.
  // Otherwise we need some room to store repeated fields.
  static constexpr size_t kCapacity =
      1 + (HAS_NONPACKED_REPEATED_FIELDS ? kMaxDecoderFieldId : MAX_FIELD_ID);

  Field on_stack_storage_[kCapacity];
};

}  // namespace protozero

#endif  // INCLUDE_PERFETTO_PROTOZERO_PROTO_DECODER_H_
// gen_amalgamated begin header: include/perfetto/protozero/proto_utils.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_PROTOZERO_PROTO_UTILS_H_
#define INCLUDE_PERFETTO_PROTOZERO_PROTO_UTILS_H_

#include <inttypes.h>
#include <stddef.h>

#include <type_traits>

// gen_amalgamated expanded: #include "perfetto/base/logging.h"

namespace protozero {
namespace proto_utils {

// See https://developers.google.com/protocol-buffers/docs/encoding wire types.
// This is a type encoded into the proto that provides just enough info to
// find the length of the following value.
enum class ProtoWireType : uint32_t {
  kVarInt = 0,
  kFixed64 = 1,
  kLengthDelimited = 2,
  kFixed32 = 5,
};

// This is the type defined in the proto for each field. This information
// is used to decide the translation strategy when writing the trace.
enum class ProtoSchemaType {
  kUnknown = 0,
  kDouble,
  kFloat,
  kInt64,
  kUint64,
  kInt32,
  kFixed64,
  kFixed32,
  kBool,
  kString,
  kGroup,  // Deprecated (proto2 only)
  kMessage,
  kBytes,
  kUint32,
  kEnum,
  kSfixed32,
  kSfixed64,
  kSint32,
  kSint64,
};

inline const char* ProtoSchemaToString(ProtoSchemaType v) {
  switch (v) {
    case ProtoSchemaType::kUnknown:
      return "unknown";
    case ProtoSchemaType::kDouble:
      return "double";
    case ProtoSchemaType::kFloat:
      return "float";
    case ProtoSchemaType::kInt64:
      return "int64";
    case ProtoSchemaType::kUint64:
      return "uint64";
    case ProtoSchemaType::kInt32:
      return "int32";
    case ProtoSchemaType::kFixed64:
      return "fixed64";
    case ProtoSchemaType::kFixed32:
      return "fixed32";
    case ProtoSchemaType::kBool:
      return "bool";
    case ProtoSchemaType::kString:
      return "string";
    case ProtoSchemaType::kGroup:
      return "group";
    case ProtoSchemaType::kMessage:
      return "message";
    case ProtoSchemaType::kBytes:
      return "bytes";
    case ProtoSchemaType::kUint32:
      return "uint32";
    case ProtoSchemaType::kEnum:
      return "enum";
    case ProtoSchemaType::kSfixed32:
      return "sfixed32";
    case ProtoSchemaType::kSfixed64:
      return "sfixed64";
    case ProtoSchemaType::kSint32:
      return "sint32";
    case ProtoSchemaType::kSint64:
      return "sint64";
  }
  // For gcc:
  PERFETTO_DCHECK(false);
  return "";
}

// Maximum message size supported: 256 MiB (4 x 7-bit due to varint encoding).
constexpr size_t kMessageLengthFieldSize = 4;
constexpr size_t kMaxMessageLength = (1u << (kMessageLengthFieldSize * 7)) - 1;

// Field tag is encoded as 32-bit varint (5 bytes at most).
// Largest value of simple (not length-delimited) field is 64-bit varint
// (10 bytes at most). 15 bytes buffer is enough to store a simple field.
constexpr size_t kMaxTagEncodedSize = 5;
constexpr size_t kMaxSimpleFieldEncodedSize = kMaxTagEncodedSize + 10;

// Proto types: (int|uint|sint)(32|64), bool, enum.
constexpr uint32_t MakeTagVarInt(uint32_t field_id) {
  return (field_id << 3) | static_cast<uint32_t>(ProtoWireType::kVarInt);
}

// Proto types: fixed64, sfixed64, fixed32, sfixed32, double, float.
template <typename T>
constexpr uint32_t MakeTagFixed(uint32_t field_id) {
  static_assert(sizeof(T) == 8 || sizeof(T) == 4, "Value must be 4 or 8 bytes");
  return (field_id << 3) |
         static_cast<uint32_t>((sizeof(T) == 8 ? ProtoWireType::kFixed64
                                               : ProtoWireType::kFixed32));
}

// Proto types: string, bytes, embedded messages.
constexpr uint32_t MakeTagLengthDelimited(uint32_t field_id) {
  return (field_id << 3) |
         static_cast<uint32_t>(ProtoWireType::kLengthDelimited);
}

// Proto types: sint64, sint32.
template <typename T>
inline typename std::make_unsigned<T>::type ZigZagEncode(T value) {
  using UnsignedType = typename std::make_unsigned<T>::type;

  // Right-shift of negative values is implementation specific.
  // Assert the implementation does what we expect, which is that shifting any
  // positive value by sizeof(T) * 8 - 1 gives an all 0 bitmap, and a negative
  // value gives and all 1 bitmap.
  constexpr uint64_t kUnsignedZero = 0u;
  constexpr int64_t kNegativeOne = -1;
  constexpr int64_t kPositiveOne = 1;
  static_assert(static_cast<uint64_t>(kNegativeOne >> 63) == ~kUnsignedZero,
                "implementation does not support assumed rightshift");
  static_assert(static_cast<uint64_t>(kPositiveOne >> 63) == kUnsignedZero,
                "implementation does not support assumed rightshift");

  return (static_cast<UnsignedType>(value) << 1) ^
         static_cast<UnsignedType>(value >> (sizeof(T) * 8 - 1));
}

// Proto types: sint64, sint32.
template <typename T>
inline typename std::make_signed<T>::type ZigZagDecode(T value) {
  using UnsignedType = typename std::make_unsigned<T>::type;
  auto u_value = static_cast<UnsignedType>(value);
  return static_cast<typename std::make_signed<T>::type>(
      ((u_value >> 1) ^ -(u_value & 1)));
}

template <typename T>
inline uint8_t* WriteVarInt(T value, uint8_t* target) {
  // If value is <= 0 we must first sign extend to int64_t (see [1]).
  // Finally we always cast to an unsigned value to to avoid arithmetic
  // (sign expanding) shifts in the while loop.
  // [1]: "If you use int32 or int64 as the type for a negative number, the
  // resulting varint is always ten bytes long".
  // - developers.google.com/protocol-buffers/docs/encoding
  // So for each input type we do the following casts:
  // uintX_t -> uintX_t -> uintX_t
  // int8_t  -> int64_t -> uint64_t
  // int16_t -> int64_t -> uint64_t
  // int32_t -> int64_t -> uint64_t
  // int64_t -> int64_t -> uint64_t
  using MaybeExtendedType =
      typename std::conditional<std::is_unsigned<T>::value, T, int64_t>::type;
  using UnsignedType = typename std::make_unsigned<MaybeExtendedType>::type;

  MaybeExtendedType extended_value = static_cast<MaybeExtendedType>(value);
  UnsignedType unsigned_value = static_cast<UnsignedType>(extended_value);

  while (unsigned_value >= 0x80) {
    *target++ = static_cast<uint8_t>(unsigned_value) | 0x80;
    unsigned_value >>= 7;
  }
  *target = static_cast<uint8_t>(unsigned_value);
  return target + 1;
}

// Writes a fixed-size redundant encoding of the given |value|. This is
// used to backfill fixed-size reservations for the length field using a
// non-canonical varint encoding (e.g. \x81\x80\x80\x00 instead of \x01).
// See https://github.com/google/protobuf/issues/1530.
// In particular, this is used for nested messages. The size of a nested message
// is not known until all its field have been written. |kMessageLengthFieldSize|
// bytes are reserved to encode the size field and backfilled at the end.
inline void WriteRedundantVarInt(uint32_t value, uint8_t* buf) {
  for (size_t i = 0; i < kMessageLengthFieldSize; ++i) {
    const uint8_t msb = (i < kMessageLengthFieldSize - 1) ? 0x80 : 0;
    buf[i] = static_cast<uint8_t>(value) | msb;
    value >>= 7;
  }
}

template <uint32_t field_id>
void StaticAssertSingleBytePreamble() {
  static_assert(field_id < 16,
                "Proto field id too big to fit in a single byte preamble");
}

// Parses a VarInt from the encoded buffer [start, end). |end| is STL-style and
// points one byte past the end of buffer.
// The parsed int value is stored in the output arg |value|. Returns a pointer
// to the next unconsumed byte (so start < retval <= end) or |start| if the
// VarInt could not be fully parsed because there was not enough space in the
// buffer.
inline const uint8_t* ParseVarInt(const uint8_t* start,
                                  const uint8_t* end,
                                  uint64_t* out_value) {
  const uint8_t* pos = start;
  uint64_t value = 0;
  for (uint32_t shift = 0; pos < end && shift < 64u; shift += 7) {
    // Cache *pos into |cur_byte| to prevent that the compiler dereferences the
    // pointer twice (here and in the if() below) due to char* aliasing rules.
    uint8_t cur_byte = *pos++;
    value |= static_cast<uint64_t>(cur_byte & 0x7f) << shift;
    if ((cur_byte & 0x80) == 0) {
      // In valid cases we get here.
      *out_value = value;
      return pos;
    }
  }
  *out_value = 0;
  return start;
}

}  // namespace proto_utils
}  // namespace protozero

#endif  // INCLUDE_PERFETTO_PROTOZERO_PROTO_UTILS_H_
// gen_amalgamated begin header: include/perfetto/protozero/scattered_heap_buffer.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_PROTOZERO_SCATTERED_HEAP_BUFFER_H_
#define INCLUDE_PERFETTO_PROTOZERO_SCATTERED_HEAP_BUFFER_H_

#include <memory>
#include <string>
#include <vector>

// gen_amalgamated expanded: #include "perfetto/base/export.h"
// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/protozero/scattered_stream_writer.h"

namespace protozero {

class Message;

class PERFETTO_EXPORT ScatteredHeapBuffer
    : public protozero::ScatteredStreamWriter::Delegate {
 public:
  class PERFETTO_EXPORT Slice {
   public:
    Slice();
    explicit Slice(size_t size);
    Slice(Slice&& slice) noexcept;
    ~Slice();
    Slice& operator=(Slice&&);

    inline protozero::ContiguousMemoryRange GetTotalRange() const {
      return {buffer_.get(), buffer_.get() + size_};
    }

    inline protozero::ContiguousMemoryRange GetUsedRange() const {
      return {buffer_.get(), buffer_.get() + size_ - unused_bytes_};
    }

    uint8_t* start() const { return buffer_.get(); }
    size_t size() const { return size_; }
    size_t unused_bytes() const { return unused_bytes_; }
    void set_unused_bytes(size_t unused_bytes) {
      PERFETTO_DCHECK(unused_bytes_ <= size_);
      unused_bytes_ = unused_bytes;
    }

    void Clear();

   private:
    std::unique_ptr<uint8_t[]> buffer_;
    size_t size_;
    size_t unused_bytes_;
  };

  ScatteredHeapBuffer(size_t initial_slice_size_bytes = 128,
                      size_t maximum_slice_size_bytes = 128 * 1024);
  ~ScatteredHeapBuffer() override;

  // protozero::ScatteredStreamWriter::Delegate implementation.
  protozero::ContiguousMemoryRange GetNewBuffer() override;

  // Stitch all the slices into a single contiguous buffer.
  std::vector<uint8_t> StitchSlices();

  // Note that the returned ranges point back to this buffer and thus cannot
  // outlive it.
  std::vector<protozero::ContiguousMemoryRange> GetRanges();

  const std::vector<Slice>& slices() const { return slices_; }

  void set_writer(protozero::ScatteredStreamWriter* writer) {
    writer_ = writer;
  }

  // Update unused_bytes() of the current |Slice| based on the writer's state.
  void AdjustUsedSizeOfCurrentSlice();

  // Returns the total size the slices occupy in heap memory (including unused).
  size_t GetTotalSize();

  // Reset the contents of this buffer but retain one slice allocation (if it
  // exists) to be reused for future writes.
  void Reset();

 private:
  size_t next_slice_size_;
  const size_t maximum_slice_size_;
  protozero::ScatteredStreamWriter* writer_ = nullptr;
  std::vector<Slice> slices_;

  // Used to keep an allocated slice around after this buffer is reset.
  Slice cached_slice_;
};

// Helper function to create heap-based protozero messages in one line.
// Useful when manually serializing a protozero message (primarily in
// tests/utilities). So instead of the following:
//   protozero::MyMessage msg;
//   protozero::ScatteredHeapBuffer shb;
//   protozero::ScatteredStreamWriter writer(&shb);
//   shb.set_writer(&writer);
//   msg.Reset(&writer);
//   ...
// You can write:
//   protozero::HeapBuffered<protozero::MyMessage> msg;
//   msg->set_stuff(...);
//   msg.SerializeAsString();
template <typename T = ::protozero::Message>
class HeapBuffered {
 public:
  HeapBuffered() : HeapBuffered(4096, 4096) {}
  HeapBuffered(size_t initial_slice_size_bytes, size_t maximum_slice_size_bytes)
      : shb_(initial_slice_size_bytes, maximum_slice_size_bytes),
        writer_(&shb_) {
    shb_.set_writer(&writer_);
    msg_.Reset(&writer_);
  }

  // This can't be neither copied nor moved because Message hands out pointers
  // to itself when creating submessages.
  HeapBuffered(const HeapBuffered&) = delete;
  HeapBuffered& operator=(const HeapBuffered&) = delete;
  HeapBuffered(HeapBuffered&&) = delete;
  HeapBuffered& operator=(HeapBuffered&&) = delete;

  T* get() { return &msg_; }
  T* operator->() { return &msg_; }

  bool empty() const { return shb_.slices().empty(); }

  std::vector<uint8_t> SerializeAsArray() {
    msg_.Finalize();
    return shb_.StitchSlices();
  }

  std::string SerializeAsString() {
    auto vec = SerializeAsArray();
    return std::string(reinterpret_cast<const char*>(vec.data()), vec.size());
  }

  std::vector<protozero::ContiguousMemoryRange> GetRanges() {
    msg_.Finalize();
    return shb_.GetRanges();
  }

  void Reset() {
    shb_.Reset();
    writer_.Reset(protozero::ContiguousMemoryRange{});
    msg_.Reset(&writer_);
    PERFETTO_DCHECK(empty());
  }

 private:
  ScatteredHeapBuffer shb_;
  ScatteredStreamWriter writer_;
  T msg_;
};

}  // namespace protozero

#endif  // INCLUDE_PERFETTO_PROTOZERO_SCATTERED_HEAP_BUFFER_H_
// gen_amalgamated begin header: include/perfetto/protozero/scattered_stream_null_delegate.h
/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_PROTOZERO_SCATTERED_STREAM_NULL_DELEGATE_H_
#define INCLUDE_PERFETTO_PROTOZERO_SCATTERED_STREAM_NULL_DELEGATE_H_

#include <memory>
#include <vector>

// gen_amalgamated expanded: #include "perfetto/base/export.h"
// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/protozero/contiguous_memory_range.h"
// gen_amalgamated expanded: #include "perfetto/protozero/scattered_stream_writer.h"

namespace protozero {

class PERFETTO_EXPORT ScatteredStreamWriterNullDelegate
    : public ScatteredStreamWriter::Delegate {
 public:
  explicit ScatteredStreamWriterNullDelegate(size_t chunk_size);
  ~ScatteredStreamWriterNullDelegate() override;

  // protozero::ScatteredStreamWriter::Delegate implementation.
  ContiguousMemoryRange GetNewBuffer() override;

 private:
  const size_t chunk_size_;
  std::unique_ptr<uint8_t[]> chunk_;
};

}  // namespace protozero

#endif  // INCLUDE_PERFETTO_PROTOZERO_SCATTERED_STREAM_NULL_DELEGATE_H_
// gen_amalgamated begin header: include/perfetto/protozero/scattered_stream_writer.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_PROTOZERO_SCATTERED_STREAM_WRITER_H_
#define INCLUDE_PERFETTO_PROTOZERO_SCATTERED_STREAM_WRITER_H_

#include <assert.h>
#include <stddef.h>
#include <stdint.h>
#include <string.h>

// gen_amalgamated expanded: #include "perfetto/base/compiler.h"
// gen_amalgamated expanded: #include "perfetto/base/export.h"
// gen_amalgamated expanded: #include "perfetto/protozero/contiguous_memory_range.h"

namespace protozero {

// This class deals with the following problem: append-only proto messages want
// to write a stream of bytes, without caring about the implementation of the
// underlying buffer (which concretely will be either the trace ring buffer
// or a heap-allocated buffer). The main deal is: proto messages don't know in
// advance what their size will be.
// Due to the tracing buffer being split into fixed-size chunks, on some
// occasions, these writes need to be spread over two (or more) non-contiguous
// chunks of memory. Similarly, when the buffer is backed by the heap, we want
// to avoid realloc() calls, as they might cause a full copy of the contents
// of the buffer.
// The purpose of this class is to abstract away the non-contiguous write logic.
// This class knows how to deal with writes as long as they fall in the same
// ContiguousMemoryRange and defers the chunk-chaining logic to the Delegate.
class PERFETTO_EXPORT ScatteredStreamWriter {
 public:
  class PERFETTO_EXPORT Delegate {
   public:
    virtual ~Delegate();
    virtual ContiguousMemoryRange GetNewBuffer() = 0;
  };

  explicit ScatteredStreamWriter(Delegate* delegate);
  ~ScatteredStreamWriter();

  inline void WriteByte(uint8_t value) {
    if (write_ptr_ >= cur_range_.end)
      Extend();
    *write_ptr_++ = value;
  }

  // Assumes that the caller checked that there is enough headroom.
  // TODO(primiano): perf optimization, this is a tracing hot path. The
  // compiler can make strong optimization on memcpy if the size arg is a
  // constexpr. Make a templated variant of this for fixed-size writes.
  // TODO(primiano): restrict / noalias might also help.
  inline void WriteBytesUnsafe(const uint8_t* src, size_t size) {
    uint8_t* const end = write_ptr_ + size;
    assert(end <= cur_range_.end);
    memcpy(write_ptr_, src, size);
    write_ptr_ = end;
  }

  inline void WriteBytes(const uint8_t* src, size_t size) {
    uint8_t* const end = write_ptr_ + size;
    if (PERFETTO_LIKELY(end <= cur_range_.end))
      return WriteBytesUnsafe(src, size);
    WriteBytesSlowPath(src, size);
  }

  void WriteBytesSlowPath(const uint8_t* src, size_t size);

  // Reserves a fixed amount of bytes to be backfilled later. The reserved range
  // is guaranteed to be contiguous and not span across chunks. |size| has to be
  // <= than the size of a new buffer returned by the Delegate::GetNewBuffer().
  uint8_t* ReserveBytes(size_t size);

  // Fast (but unsafe) version of the above. The caller must have previously
  // checked that there are at least |size| contiguous bytes available.
  // Returns only the start pointer of the reservation.
  uint8_t* ReserveBytesUnsafe(size_t size) {
    uint8_t* begin = write_ptr_;
    write_ptr_ += size;
    assert(write_ptr_ <= cur_range_.end);
    return begin;
  }

  // Resets the buffer boundaries and the write pointer to the given |range|.
  // Subsequent WriteByte(s) will write into |range|.
  void Reset(ContiguousMemoryRange range);

  // Number of contiguous free bytes in |cur_range_| that can be written without
  // requesting a new buffer.
  size_t bytes_available() const {
    return static_cast<size_t>(cur_range_.end - write_ptr_);
  }

  uint8_t* write_ptr() const { return write_ptr_; }

  uint64_t written() const {
    return written_previously_ +
           static_cast<uint64_t>(write_ptr_ - cur_range_.begin);
  }

 private:
  ScatteredStreamWriter(const ScatteredStreamWriter&) = delete;
  ScatteredStreamWriter& operator=(const ScatteredStreamWriter&) = delete;

  void Extend();

  Delegate* const delegate_;
  ContiguousMemoryRange cur_range_;
  uint8_t* write_ptr_;
  uint64_t written_previously_ = 0;
};

}  // namespace protozero

#endif  // INCLUDE_PERFETTO_PROTOZERO_SCATTERED_STREAM_WRITER_H_
// gen_amalgamated begin header: include/perfetto/protozero/static_buffer.h
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_PROTOZERO_STATIC_BUFFER_H_
#define INCLUDE_PERFETTO_PROTOZERO_STATIC_BUFFER_H_

#include <memory>
#include <string>
#include <vector>

// gen_amalgamated expanded: #include "perfetto/base/export.h"
// gen_amalgamated expanded: #include "perfetto/protozero/scattered_stream_writer.h"

namespace protozero {

class Message;

// A simple implementation of ScatteredStreamWriter::Delegate backed by a
// fixed-size buffer. It doesn't support expansion. The caller needs to ensure
// to never write more than the size of the buffer. Will CHECK() otherwise.
class PERFETTO_EXPORT StaticBufferDelegate
    : public ScatteredStreamWriter::Delegate {
 public:
  StaticBufferDelegate(uint8_t* buf, size_t len) : range_{buf, buf + len} {}
  ~StaticBufferDelegate() override;

  // ScatteredStreamWriter::Delegate implementation.
  ContiguousMemoryRange GetNewBuffer() override;

  ContiguousMemoryRange const range_;
  bool get_new_buffer_called_once_ = false;
};

// Helper function to create protozero messages backed by a fixed-size buffer
// in one line. You can write:
//   protozero::Static<protozero::MyMessage> msg(buf.data(), buf.size());
//   msg->set_stuff(...);
//   size_t bytes_encoded = msg.Finalize();
template <typename T /* protozero::Message */>
class StaticBuffered {
 public:
  StaticBuffered(void* buf, size_t len)
      : delegate_(reinterpret_cast<uint8_t*>(buf), len), writer_(&delegate_) {
    msg_.Reset(&writer_);
  }

  // This can't be neither copied nor moved because Message hands out pointers
  // to itself when creating submessages.
  StaticBuffered(const StaticBuffered&) = delete;
  StaticBuffered& operator=(const StaticBuffered&) = delete;
  StaticBuffered(StaticBuffered&&) = delete;
  StaticBuffered& operator=(StaticBuffered&&) = delete;

  T* get() { return &msg_; }
  T* operator->() { return &msg_; }

  // The lack of a size() method is deliberate. It's to prevent that one
  // accidentally calls size() before Finalize().

  // Returns the number of encoded bytes (<= the size passed in the ctor).
  size_t Finalize() {
    msg_.Finalize();
    return static_cast<size_t>(writer_.write_ptr() - delegate_.range_.begin);
  }

 private:
  StaticBufferDelegate delegate_;
  ScatteredStreamWriter writer_;
  T msg_;
};

// Helper function to create stack-based protozero messages in one line.
// You can write:
//   protozero::StackBuffered<protozero::MyMessage, 16> msg;
//   msg->set_stuff(...);
//   size_t bytes_encoded = msg.Finalize();
template <typename T /* protozero::Message */, size_t N>
class StackBuffered : public StaticBuffered<T> {
 public:
  StackBuffered() : StaticBuffered<T>(&buf_[0], N) {}

 private:
  uint8_t buf_[N];  // Deliberately not initialized.
};

}  // namespace protozero

#endif  // INCLUDE_PERFETTO_PROTOZERO_STATIC_BUFFER_H_

