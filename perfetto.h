// Copyright (C) 2019 The Android Open Source Project
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// This file is automatically generated by gen_amalgamated. Do not edit.

// gen_amalgamated begin header: include/perfetto/tracing.h
// gen_amalgamated begin header: include/perfetto/tracing/core/data_source_config.h
// gen_amalgamated begin header: include/perfetto/base/copyable_ptr.h
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_BASE_COPYABLE_PTR_H_
#define INCLUDE_PERFETTO_BASE_COPYABLE_PTR_H_

#include <memory>

namespace perfetto {
namespace base {

// This class is essentially a std::vector<T> of fixed size = 1.
// It's a pointer wrapper with deep copying and deep equality comparison.
// At all effects this wrapper behaves like the underlying T, with the exception
// of the heap indirection.
// Conversely to a std::unique_ptr, the pointer will be always valid, never
// null. The problem it solves is the following: when generating C++ classes
// from proto files, we want to keep each header hermetic (i.e. not #include
// headers of dependent types). As such we can't directly instantiate T
// field members but we can instead rely on pointers, so only the .cc file needs
// to see the actual definition of T. If the generated classes were move-only we
// could just use a unique_ptr there. But they aren't, hence this wrapper.
// Converesely to unique_ptr, this wrapper:
// - Default constructs the T instance in its constructor.
// - Implements deep comparison in operator== instead of pointer comparison.
template <typename T>
class CopyablePtr {
 public:
  CopyablePtr() : ptr_(new T()) {}
  ~CopyablePtr() = default;

  // Copy operators.
  CopyablePtr(const CopyablePtr& other) : ptr_(new T(*other.ptr_)) {}
  CopyablePtr& operator=(const CopyablePtr& other) {
    *ptr_ = *other.ptr_;
    return *this;
  }

  // Move operators.
  CopyablePtr(CopyablePtr&& other) noexcept : ptr_(std::move(other.ptr_)) {
    other.ptr_.reset(new T());
  }

  CopyablePtr& operator=(CopyablePtr&& other) {
    ptr_ = std::move(other.ptr_);
    other.ptr_.reset(new T());
    return *this;
  }

  T* get() { return ptr_.get(); }
  const T* get() const { return ptr_.get(); }

  T* operator->() { return ptr_.get(); }
  const T* operator->() const { return ptr_.get(); }

  T& operator*() { return *ptr_; }
  const T& operator*() const { return *ptr_; }

  friend bool operator==(const CopyablePtr& lhs, const CopyablePtr& rhs) {
    return *lhs == *rhs;
  }

  friend bool operator!=(const CopyablePtr& lhs, const CopyablePtr& rhs) {
    // In theory the underlying type might have a special operator!=
    // implementation which is not just !(x == y). Respect that.
    return *lhs != *rhs;
  }

 private:
  std::unique_ptr<T> ptr_;
};

}  // namespace base
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_BASE_COPYABLE_PTR_H_
// gen_amalgamated begin header: include/perfetto/base/export.h
// gen_amalgamated begin header: include/perfetto/base/build_config.h
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/build_config/perfetto_build_flags.h
// Generated by ../../gn/write_buildflag_header.py

// fix_include_guards: off
#ifndef GEN_BUILD_CONFIG_PERFETTO_BUILD_FLAGS_H_
#define GEN_BUILD_CONFIG_PERFETTO_BUILD_FLAGS_H_

// clang-format off
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_ANDROID_BUILD() (0)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_CHROMIUM_BUILD() (0)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_STANDALONE_BUILD() (0)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_START_DAEMONS() (1)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_IPC() (1)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_WATCHDOG() (0)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_COMPONENT_BUILD() (0)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_FORCE_DLOG_ON() (0)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_FORCE_DLOG_OFF() (0)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_VERSION_GEN() (0)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_TP_LINENOISE() (0)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_TP_JSON() (1)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_TP_PERCENTILE() (0)

// clang-format on
#endif  // GEN_BUILD_CONFIG_PERFETTO_BUILD_FLAGS_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_BASE_BUILD_CONFIG_H_
#define INCLUDE_PERFETTO_BASE_BUILD_CONFIG_H_

// Allows to define build flags that give a compiler error if the header that
// defined the flag is not included, instead of silently ignoring the #if block.
#define PERFETTO_BUILDFLAG_CAT_INDIRECT(a, b) a##b
#define PERFETTO_BUILDFLAG_CAT(a, b) PERFETTO_BUILDFLAG_CAT_INDIRECT(a, b)
#define PERFETTO_BUILDFLAG(flag) \
  (PERFETTO_BUILDFLAG_CAT(PERFETTO_BUILDFLAG_DEFINE_, flag)())

#if defined(__ANDROID__)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_ANDROID() 1
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_MACOSX() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_LINUX() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WIN() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WASM() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_FUCHSIA() 0
#elif defined(__APPLE__)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_ANDROID() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_MACOSX() 1
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_LINUX() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WIN() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WASM() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_FUCHSIA() 0
#elif defined(__linux__)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_ANDROID() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_MACOSX() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_LINUX() 1
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WIN() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WASM() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_FUCHSIA() 0
#elif defined(_WIN32)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_ANDROID() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_MACOSX() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_LINUX() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WIN() 1
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WASM() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_FUCHSIA() 0
#elif defined(__EMSCRIPTEN__)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_ANDROID() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_MACOSX() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_LINUX() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WIN() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WASM() 1
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_FUCHSIA() 0
#elif defined(__Fuchsia__)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_ANDROID() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_MACOSX() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_LINUX() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WIN() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WASM() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_FUCHSIA() 1
#else
#error OS not supported (see build_config.h)
#endif

#if defined(__clang__)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_COMPILER_CLANG() 1
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_COMPILER_GCC() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_COMPILER_MSVC() 0
#elif defined(__GNUC__) // Careful: Clang also defines this!
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_COMPILER_CLANG() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_COMPILER_GCC() 1
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_COMPILER_MSVC() 0
#elif defined(_MSC_VER)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_COMPILER_CLANG() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_COMPILER_GCC() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_COMPILER_MSVC() 1
#else
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_COMPILER_CLANG() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_COMPILER_GCC() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_COMPILER_MSVC() 0
#endif

#if defined(PERFETTO_BUILD_WITH_ANDROID_USERDEBUG)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_ANDROID_USERDEBUG_BUILD() 1
#else
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_ANDROID_USERDEBUG_BUILD() 0
#endif

// perfetto_build_flags.h contains the tweakable build flags defined via GN.
// - In GN builds (e.g., standalone, chromium, v8) this file is generated at
//   build time via the gen_rule //gn/gen_buildflags.
// - In Android in-tree builds, this file is generated by tools/gen_android_bp
//   and checked in into include/perfetto/base/build_configs/android_tree/. The
//   default cflags add this path to the default include path.
// - Similarly, in bazel builds, this file is generated by tools/gen_bazel and
//   checked in into include/perfetto/base/build_configs/bazel/.
// - In amaglamated builds, this file is generated by tools/gen_amalgamated and
//   added to the amalgamated headers.
// gen_amalgamated expanded: #include "perfetto_build_flags.h"  // no-include-violation-check

#endif  // INCLUDE_PERFETTO_BASE_BUILD_CONFIG_H_
/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_BASE_EXPORT_H_
#define INCLUDE_PERFETTO_BASE_EXPORT_H_

// gen_amalgamated expanded: #include "perfetto/base/build_config.h"

#if PERFETTO_BUILDFLAG(PERFETTO_COMPONENT_BUILD)

#if PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)

#if defined(PERFETTO_IMPLEMENTATION)
#define PERFETTO_EXPORT __declspec(dllexport)
#else
#define PERFETTO_EXPORT __declspec(dllimport)
#endif

#else  // PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)

#if defined(PERFETTO_IMPLEMENTATION)
#define PERFETTO_EXPORT __attribute__((visibility("default")))
#else
#define PERFETTO_EXPORT
#endif

#endif  // PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)

#else  // !PERFETTO_BUILDFLAG(PERFETTO_COMPONENT_BUILD)

#define PERFETTO_EXPORT

#endif  // PERFETTO_BUILDFLAG(PERFETTO_COMPONENT_BUILD)

#endif  // INCLUDE_PERFETTO_BASE_EXPORT_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*******************************************************************************
 * AUTOGENERATED - DO NOT EDIT
 *******************************************************************************
 * This file has been generated from the protobuf message
 * protos/perfetto/config/data_source_config.proto
 * by
 * ../../tools/proto_to_cpp/proto_to_cpp.cc.
 * If you need to make changes here, change the .proto file and then run
 * ./tools/gen_tracing_cpp_headers_from_protos
 */

#ifndef INCLUDE_PERFETTO_TRACING_CORE_DATA_SOURCE_CONFIG_H_
#define INCLUDE_PERFETTO_TRACING_CORE_DATA_SOURCE_CONFIG_H_

#include <stdint.h>
#include <string>
#include <type_traits>
#include <vector>

// gen_amalgamated expanded: #include "perfetto/base/copyable_ptr.h"
// gen_amalgamated expanded: #include "perfetto/base/export.h"

// Forward declarations for protobuf types.
namespace perfetto {
namespace protos {
class DataSourceConfig;
class ChromeConfig;
class TestConfig;
class TestConfig_DummyFields;
}  // namespace protos
}  // namespace perfetto

namespace perfetto {
class DataSourceConfig;
class ChromeConfig;
class TestConfig;

class PERFETTO_EXPORT DataSourceConfig {
 public:
  DataSourceConfig();
  ~DataSourceConfig();
  DataSourceConfig(DataSourceConfig&&) noexcept;
  DataSourceConfig& operator=(DataSourceConfig&&);
  DataSourceConfig(const DataSourceConfig&);
  DataSourceConfig& operator=(const DataSourceConfig&);
  bool operator==(const DataSourceConfig&) const;
  bool operator!=(const DataSourceConfig& other) const {
    return !(*this == other);
  }

  // Raw proto decoding.
  void ParseRawProto(const std::string&);
  // Conversion methods from/to the corresponding protobuf types.
  void FromProto(const perfetto::protos::DataSourceConfig&);
  void ToProto(perfetto::protos::DataSourceConfig*) const;

  const std::string& name() const { return name_; }
  void set_name(const std::string& value) { name_ = value; }

  uint32_t target_buffer() const { return target_buffer_; }
  void set_target_buffer(uint32_t value) { target_buffer_ = value; }

  uint32_t trace_duration_ms() const { return trace_duration_ms_; }
  void set_trace_duration_ms(uint32_t value) { trace_duration_ms_ = value; }

  uint32_t stop_timeout_ms() const { return stop_timeout_ms_; }
  void set_stop_timeout_ms(uint32_t value) { stop_timeout_ms_ = value; }

  bool enable_extra_guardrails() const { return enable_extra_guardrails_; }
  void set_enable_extra_guardrails(bool value) {
    enable_extra_guardrails_ = value;
  }

  uint64_t tracing_session_id() const { return tracing_session_id_; }
  void set_tracing_session_id(uint64_t value) { tracing_session_id_ = value; }

  const std::string& ftrace_config_raw() const { return ftrace_config_; }
  void set_ftrace_config_raw(const std::string& raw) { ftrace_config_ = raw; }

  const std::string& inode_file_config_raw() const {
    return inode_file_config_;
  }
  void set_inode_file_config_raw(const std::string& raw) {
    inode_file_config_ = raw;
  }

  const std::string& process_stats_config_raw() const {
    return process_stats_config_;
  }
  void set_process_stats_config_raw(const std::string& raw) {
    process_stats_config_ = raw;
  }

  const std::string& sys_stats_config_raw() const { return sys_stats_config_; }
  void set_sys_stats_config_raw(const std::string& raw) {
    sys_stats_config_ = raw;
  }

  const std::string& heapprofd_config_raw() const { return heapprofd_config_; }
  void set_heapprofd_config_raw(const std::string& raw) {
    heapprofd_config_ = raw;
  }

  const std::string& android_power_config_raw() const {
    return android_power_config_;
  }
  void set_android_power_config_raw(const std::string& raw) {
    android_power_config_ = raw;
  }

  const std::string& android_log_config_raw() const {
    return android_log_config_;
  }
  void set_android_log_config_raw(const std::string& raw) {
    android_log_config_ = raw;
  }

  const std::string& gpu_counter_config_raw() const {
    return gpu_counter_config_;
  }
  void set_gpu_counter_config_raw(const std::string& raw) {
    gpu_counter_config_ = raw;
  }

  const std::string& packages_list_config_raw() const {
    return packages_list_config_;
  }
  void set_packages_list_config_raw(const std::string& raw) {
    packages_list_config_ = raw;
  }

  const ChromeConfig& chrome_config() const { return *chrome_config_; }
  ChromeConfig* mutable_chrome_config() { return chrome_config_.get(); }

  const std::string& legacy_config() const { return legacy_config_; }
  void set_legacy_config(const std::string& value) { legacy_config_ = value; }

  const TestConfig& for_testing() const { return *for_testing_; }
  TestConfig* mutable_for_testing() { return for_testing_.get(); }

 private:
  std::string name_{};
  uint32_t target_buffer_{};
  uint32_t trace_duration_ms_{};
  uint32_t stop_timeout_ms_{};
  bool enable_extra_guardrails_{};
  uint64_t tracing_session_id_{};
  std::string ftrace_config_;         // [lazy=true]
  std::string inode_file_config_;     // [lazy=true]
  std::string process_stats_config_;  // [lazy=true]
  std::string sys_stats_config_;      // [lazy=true]
  std::string heapprofd_config_;      // [lazy=true]
  std::string android_power_config_;  // [lazy=true]
  std::string android_log_config_;    // [lazy=true]
  std::string gpu_counter_config_;    // [lazy=true]
  std::string packages_list_config_;  // [lazy=true]
  ::perfetto::base::CopyablePtr<ChromeConfig> chrome_config_;
  std::string legacy_config_{};
  ::perfetto::base::CopyablePtr<TestConfig> for_testing_;

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;
};

}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_TRACING_CORE_DATA_SOURCE_CONFIG_H_
// gen_amalgamated begin header: include/perfetto/tracing/core/data_source_descriptor.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*******************************************************************************
 * AUTOGENERATED - DO NOT EDIT
 *******************************************************************************
 * This file has been generated from the protobuf message
 * protos/perfetto/common/data_source_descriptor.proto
 * by
 * ../../tools/proto_to_cpp/proto_to_cpp.cc.
 * If you need to make changes here, change the .proto file and then run
 * ./tools/gen_tracing_cpp_headers_from_protos
 */

#ifndef INCLUDE_PERFETTO_TRACING_CORE_DATA_SOURCE_DESCRIPTOR_H_
#define INCLUDE_PERFETTO_TRACING_CORE_DATA_SOURCE_DESCRIPTOR_H_

#include <stdint.h>
#include <string>
#include <type_traits>
#include <vector>

// gen_amalgamated expanded: #include "perfetto/base/copyable_ptr.h"
// gen_amalgamated expanded: #include "perfetto/base/export.h"

// Forward declarations for protobuf types.
namespace perfetto {
namespace protos {
class DataSourceDescriptor;
}
}  // namespace perfetto

namespace perfetto {
class DataSourceDescriptor;

class PERFETTO_EXPORT DataSourceDescriptor {
 public:
  DataSourceDescriptor();
  ~DataSourceDescriptor();
  DataSourceDescriptor(DataSourceDescriptor&&) noexcept;
  DataSourceDescriptor& operator=(DataSourceDescriptor&&);
  DataSourceDescriptor(const DataSourceDescriptor&);
  DataSourceDescriptor& operator=(const DataSourceDescriptor&);
  bool operator==(const DataSourceDescriptor&) const;
  bool operator!=(const DataSourceDescriptor& other) const {
    return !(*this == other);
  }

  // Raw proto decoding.
  void ParseRawProto(const std::string&);
  // Conversion methods from/to the corresponding protobuf types.
  void FromProto(const perfetto::protos::DataSourceDescriptor&);
  void ToProto(perfetto::protos::DataSourceDescriptor*) const;

  const std::string& name() const { return name_; }
  void set_name(const std::string& value) { name_ = value; }

  bool will_notify_on_stop() const { return will_notify_on_stop_; }
  void set_will_notify_on_stop(bool value) { will_notify_on_stop_ = value; }

  bool will_notify_on_start() const { return will_notify_on_start_; }
  void set_will_notify_on_start(bool value) { will_notify_on_start_ = value; }

  bool handles_incremental_state_clear() const {
    return handles_incremental_state_clear_;
  }
  void set_handles_incremental_state_clear(bool value) {
    handles_incremental_state_clear_ = value;
  }

  const std::string& gpu_counter_descriptor_raw() const {
    return gpu_counter_descriptor_;
  }
  void set_gpu_counter_descriptor_raw(const std::string& raw) {
    gpu_counter_descriptor_ = raw;
  }

  const std::string& track_event_descriptor_raw() const {
    return track_event_descriptor_;
  }
  void set_track_event_descriptor_raw(const std::string& raw) {
    track_event_descriptor_ = raw;
  }

 private:
  std::string name_{};
  bool will_notify_on_stop_{};
  bool will_notify_on_start_{};
  bool handles_incremental_state_clear_{};
  std::string gpu_counter_descriptor_;  // [lazy=true]
  std::string track_event_descriptor_;  // [lazy=true]

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;
};

}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_TRACING_CORE_DATA_SOURCE_DESCRIPTOR_H_
// gen_amalgamated begin header: include/perfetto/tracing/core/trace_config.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*******************************************************************************
 * AUTOGENERATED - DO NOT EDIT
 *******************************************************************************
 * This file has been generated from the protobuf message
 * protos/perfetto/config/trace_config.proto
 * by
 * ../../tools/proto_to_cpp/proto_to_cpp.cc.
 * If you need to make changes here, change the .proto file and then run
 * ./tools/gen_tracing_cpp_headers_from_protos
 */

#ifndef INCLUDE_PERFETTO_TRACING_CORE_TRACE_CONFIG_H_
#define INCLUDE_PERFETTO_TRACING_CORE_TRACE_CONFIG_H_

#include <stdint.h>
#include <string>
#include <type_traits>
#include <vector>

// gen_amalgamated expanded: #include "perfetto/base/copyable_ptr.h"
// gen_amalgamated expanded: #include "perfetto/base/export.h"

// Forward declarations for protobuf types.
namespace perfetto {
namespace protos {
class TraceConfig;
class TraceConfig_BufferConfig;
class TraceConfig_DataSource;
class DataSourceConfig;
class ChromeConfig;
class TestConfig;
class TestConfig_DummyFields;
class TraceConfig_BuiltinDataSource;
class TraceConfig_ProducerConfig;
class TraceConfig_StatsdMetadata;
class TraceConfig_GuardrailOverrides;
class TraceConfig_TriggerConfig;
class TraceConfig_TriggerConfig_Trigger;
class TraceConfig_IncrementalStateConfig;
class TraceConfig_IncidentReportConfig;
}  // namespace protos
}  // namespace perfetto

namespace perfetto {
class TraceConfig;
class DataSourceConfig;
class ChromeConfig;
class TestConfig;

class PERFETTO_EXPORT TraceConfig {
 public:
  class PERFETTO_EXPORT BufferConfig {
   public:
    enum FillPolicy {
      UNSPECIFIED = 0,
      RING_BUFFER = 1,
      DISCARD = 2,
    };
    BufferConfig();
    ~BufferConfig();
    BufferConfig(BufferConfig&&) noexcept;
    BufferConfig& operator=(BufferConfig&&);
    BufferConfig(const BufferConfig&);
    BufferConfig& operator=(const BufferConfig&);
    bool operator==(const BufferConfig&) const;
    bool operator!=(const BufferConfig& other) const {
      return !(*this == other);
    }

    // Raw proto decoding.
    void ParseRawProto(const std::string&);
    // Conversion methods from/to the corresponding protobuf types.
    void FromProto(const perfetto::protos::TraceConfig_BufferConfig&);
    void ToProto(perfetto::protos::TraceConfig_BufferConfig*) const;

    uint32_t size_kb() const { return size_kb_; }
    void set_size_kb(uint32_t value) { size_kb_ = value; }

    FillPolicy fill_policy() const { return fill_policy_; }
    void set_fill_policy(FillPolicy value) { fill_policy_ = value; }

   private:
    uint32_t size_kb_{};
    FillPolicy fill_policy_{};

    // Allows to preserve unknown protobuf fields for compatibility
    // with future versions of .proto files.
    std::string unknown_fields_;
  };

  class PERFETTO_EXPORT DataSource {
   public:
    DataSource();
    ~DataSource();
    DataSource(DataSource&&) noexcept;
    DataSource& operator=(DataSource&&);
    DataSource(const DataSource&);
    DataSource& operator=(const DataSource&);
    bool operator==(const DataSource&) const;
    bool operator!=(const DataSource& other) const { return !(*this == other); }

    // Raw proto decoding.
    void ParseRawProto(const std::string&);
    // Conversion methods from/to the corresponding protobuf types.
    void FromProto(const perfetto::protos::TraceConfig_DataSource&);
    void ToProto(perfetto::protos::TraceConfig_DataSource*) const;

    const DataSourceConfig& config() const { return *config_; }
    DataSourceConfig* mutable_config() { return config_.get(); }

    int producer_name_filter_size() const {
      return static_cast<int>(producer_name_filter_.size());
    }
    const std::vector<std::string>& producer_name_filter() const {
      return producer_name_filter_;
    }
    std::vector<std::string>* mutable_producer_name_filter() {
      return &producer_name_filter_;
    }
    void clear_producer_name_filter() { producer_name_filter_.clear(); }
    std::string* add_producer_name_filter() {
      producer_name_filter_.emplace_back();
      return &producer_name_filter_.back();
    }

   private:
    ::perfetto::base::CopyablePtr<DataSourceConfig> config_;
    std::vector<std::string> producer_name_filter_;

    // Allows to preserve unknown protobuf fields for compatibility
    // with future versions of .proto files.
    std::string unknown_fields_;
  };

  class PERFETTO_EXPORT BuiltinDataSource {
   public:
    BuiltinDataSource();
    ~BuiltinDataSource();
    BuiltinDataSource(BuiltinDataSource&&) noexcept;
    BuiltinDataSource& operator=(BuiltinDataSource&&);
    BuiltinDataSource(const BuiltinDataSource&);
    BuiltinDataSource& operator=(const BuiltinDataSource&);
    bool operator==(const BuiltinDataSource&) const;
    bool operator!=(const BuiltinDataSource& other) const {
      return !(*this == other);
    }

    // Raw proto decoding.
    void ParseRawProto(const std::string&);
    // Conversion methods from/to the corresponding protobuf types.
    void FromProto(const perfetto::protos::TraceConfig_BuiltinDataSource&);
    void ToProto(perfetto::protos::TraceConfig_BuiltinDataSource*) const;

    bool disable_clock_snapshotting() const {
      return disable_clock_snapshotting_;
    }
    void set_disable_clock_snapshotting(bool value) {
      disable_clock_snapshotting_ = value;
    }

    bool disable_trace_config() const { return disable_trace_config_; }
    void set_disable_trace_config(bool value) { disable_trace_config_ = value; }

    bool disable_system_info() const { return disable_system_info_; }
    void set_disable_system_info(bool value) { disable_system_info_ = value; }

   private:
    bool disable_clock_snapshotting_{};
    bool disable_trace_config_{};
    bool disable_system_info_{};

    // Allows to preserve unknown protobuf fields for compatibility
    // with future versions of .proto files.
    std::string unknown_fields_;
  };

  enum LockdownModeOperation {
    LOCKDOWN_UNCHANGED = 0,
    LOCKDOWN_CLEAR = 1,
    LOCKDOWN_SET = 2,
  };

  class PERFETTO_EXPORT ProducerConfig {
   public:
    ProducerConfig();
    ~ProducerConfig();
    ProducerConfig(ProducerConfig&&) noexcept;
    ProducerConfig& operator=(ProducerConfig&&);
    ProducerConfig(const ProducerConfig&);
    ProducerConfig& operator=(const ProducerConfig&);
    bool operator==(const ProducerConfig&) const;
    bool operator!=(const ProducerConfig& other) const {
      return !(*this == other);
    }

    // Raw proto decoding.
    void ParseRawProto(const std::string&);
    // Conversion methods from/to the corresponding protobuf types.
    void FromProto(const perfetto::protos::TraceConfig_ProducerConfig&);
    void ToProto(perfetto::protos::TraceConfig_ProducerConfig*) const;

    const std::string& producer_name() const { return producer_name_; }
    void set_producer_name(const std::string& value) { producer_name_ = value; }

    uint32_t shm_size_kb() const { return shm_size_kb_; }
    void set_shm_size_kb(uint32_t value) { shm_size_kb_ = value; }

    uint32_t page_size_kb() const { return page_size_kb_; }
    void set_page_size_kb(uint32_t value) { page_size_kb_ = value; }

   private:
    std::string producer_name_{};
    uint32_t shm_size_kb_{};
    uint32_t page_size_kb_{};

    // Allows to preserve unknown protobuf fields for compatibility
    // with future versions of .proto files.
    std::string unknown_fields_;
  };

  class PERFETTO_EXPORT StatsdMetadata {
   public:
    StatsdMetadata();
    ~StatsdMetadata();
    StatsdMetadata(StatsdMetadata&&) noexcept;
    StatsdMetadata& operator=(StatsdMetadata&&);
    StatsdMetadata(const StatsdMetadata&);
    StatsdMetadata& operator=(const StatsdMetadata&);
    bool operator==(const StatsdMetadata&) const;
    bool operator!=(const StatsdMetadata& other) const {
      return !(*this == other);
    }

    // Raw proto decoding.
    void ParseRawProto(const std::string&);
    // Conversion methods from/to the corresponding protobuf types.
    void FromProto(const perfetto::protos::TraceConfig_StatsdMetadata&);
    void ToProto(perfetto::protos::TraceConfig_StatsdMetadata*) const;

    int64_t triggering_alert_id() const { return triggering_alert_id_; }
    void set_triggering_alert_id(int64_t value) {
      triggering_alert_id_ = value;
    }

    int32_t triggering_config_uid() const { return triggering_config_uid_; }
    void set_triggering_config_uid(int32_t value) {
      triggering_config_uid_ = value;
    }

    int64_t triggering_config_id() const { return triggering_config_id_; }
    void set_triggering_config_id(int64_t value) {
      triggering_config_id_ = value;
    }

    int64_t triggering_subscription_id() const {
      return triggering_subscription_id_;
    }
    void set_triggering_subscription_id(int64_t value) {
      triggering_subscription_id_ = value;
    }

   private:
    int64_t triggering_alert_id_{};
    int32_t triggering_config_uid_{};
    int64_t triggering_config_id_{};
    int64_t triggering_subscription_id_{};

    // Allows to preserve unknown protobuf fields for compatibility
    // with future versions of .proto files.
    std::string unknown_fields_;
  };

  class PERFETTO_EXPORT GuardrailOverrides {
   public:
    GuardrailOverrides();
    ~GuardrailOverrides();
    GuardrailOverrides(GuardrailOverrides&&) noexcept;
    GuardrailOverrides& operator=(GuardrailOverrides&&);
    GuardrailOverrides(const GuardrailOverrides&);
    GuardrailOverrides& operator=(const GuardrailOverrides&);
    bool operator==(const GuardrailOverrides&) const;
    bool operator!=(const GuardrailOverrides& other) const {
      return !(*this == other);
    }

    // Raw proto decoding.
    void ParseRawProto(const std::string&);
    // Conversion methods from/to the corresponding protobuf types.
    void FromProto(const perfetto::protos::TraceConfig_GuardrailOverrides&);
    void ToProto(perfetto::protos::TraceConfig_GuardrailOverrides*) const;

    uint64_t max_upload_per_day_bytes() const {
      return max_upload_per_day_bytes_;
    }
    void set_max_upload_per_day_bytes(uint64_t value) {
      max_upload_per_day_bytes_ = value;
    }

   private:
    uint64_t max_upload_per_day_bytes_{};

    // Allows to preserve unknown protobuf fields for compatibility
    // with future versions of .proto files.
    std::string unknown_fields_;
  };

  class PERFETTO_EXPORT TriggerConfig {
   public:
    enum TriggerMode {
      UNSPECIFIED = 0,
      START_TRACING = 1,
      STOP_TRACING = 2,
    };

    class PERFETTO_EXPORT Trigger {
     public:
      Trigger();
      ~Trigger();
      Trigger(Trigger&&) noexcept;
      Trigger& operator=(Trigger&&);
      Trigger(const Trigger&);
      Trigger& operator=(const Trigger&);
      bool operator==(const Trigger&) const;
      bool operator!=(const Trigger& other) const { return !(*this == other); }

      // Raw proto decoding.
      void ParseRawProto(const std::string&);
      // Conversion methods from/to the corresponding protobuf types.
      void FromProto(
          const perfetto::protos::TraceConfig_TriggerConfig_Trigger&);
      void ToProto(perfetto::protos::TraceConfig_TriggerConfig_Trigger*) const;

      const std::string& name() const { return name_; }
      void set_name(const std::string& value) { name_ = value; }

      const std::string& producer_name_regex() const {
        return producer_name_regex_;
      }
      void set_producer_name_regex(const std::string& value) {
        producer_name_regex_ = value;
      }

      uint32_t stop_delay_ms() const { return stop_delay_ms_; }
      void set_stop_delay_ms(uint32_t value) { stop_delay_ms_ = value; }

     private:
      std::string name_{};
      std::string producer_name_regex_{};
      uint32_t stop_delay_ms_{};

      // Allows to preserve unknown protobuf fields for compatibility
      // with future versions of .proto files.
      std::string unknown_fields_;
    };

    TriggerConfig();
    ~TriggerConfig();
    TriggerConfig(TriggerConfig&&) noexcept;
    TriggerConfig& operator=(TriggerConfig&&);
    TriggerConfig(const TriggerConfig&);
    TriggerConfig& operator=(const TriggerConfig&);
    bool operator==(const TriggerConfig&) const;
    bool operator!=(const TriggerConfig& other) const {
      return !(*this == other);
    }

    // Raw proto decoding.
    void ParseRawProto(const std::string&);
    // Conversion methods from/to the corresponding protobuf types.
    void FromProto(const perfetto::protos::TraceConfig_TriggerConfig&);
    void ToProto(perfetto::protos::TraceConfig_TriggerConfig*) const;

    TriggerMode trigger_mode() const { return trigger_mode_; }
    void set_trigger_mode(TriggerMode value) { trigger_mode_ = value; }

    int triggers_size() const { return static_cast<int>(triggers_.size()); }
    const std::vector<Trigger>& triggers() const { return triggers_; }
    std::vector<Trigger>* mutable_triggers() { return &triggers_; }
    void clear_triggers() { triggers_.clear(); }
    Trigger* add_triggers() {
      triggers_.emplace_back();
      return &triggers_.back();
    }

    uint32_t trigger_timeout_ms() const { return trigger_timeout_ms_; }
    void set_trigger_timeout_ms(uint32_t value) { trigger_timeout_ms_ = value; }

   private:
    TriggerMode trigger_mode_{};
    std::vector<Trigger> triggers_;
    uint32_t trigger_timeout_ms_{};

    // Allows to preserve unknown protobuf fields for compatibility
    // with future versions of .proto files.
    std::string unknown_fields_;
  };

  class PERFETTO_EXPORT IncrementalStateConfig {
   public:
    IncrementalStateConfig();
    ~IncrementalStateConfig();
    IncrementalStateConfig(IncrementalStateConfig&&) noexcept;
    IncrementalStateConfig& operator=(IncrementalStateConfig&&);
    IncrementalStateConfig(const IncrementalStateConfig&);
    IncrementalStateConfig& operator=(const IncrementalStateConfig&);
    bool operator==(const IncrementalStateConfig&) const;
    bool operator!=(const IncrementalStateConfig& other) const {
      return !(*this == other);
    }

    // Raw proto decoding.
    void ParseRawProto(const std::string&);
    // Conversion methods from/to the corresponding protobuf types.
    void FromProto(const perfetto::protos::TraceConfig_IncrementalStateConfig&);
    void ToProto(perfetto::protos::TraceConfig_IncrementalStateConfig*) const;

    uint32_t clear_period_ms() const { return clear_period_ms_; }
    void set_clear_period_ms(uint32_t value) { clear_period_ms_ = value; }

   private:
    uint32_t clear_period_ms_{};

    // Allows to preserve unknown protobuf fields for compatibility
    // with future versions of .proto files.
    std::string unknown_fields_;
  };

  enum CompressionType {
    COMPRESSION_TYPE_UNSPECIFIED = 0,
    COMPRESSION_TYPE_DEFLATE = 1,
  };

  class PERFETTO_EXPORT IncidentReportConfig {
   public:
    IncidentReportConfig();
    ~IncidentReportConfig();
    IncidentReportConfig(IncidentReportConfig&&) noexcept;
    IncidentReportConfig& operator=(IncidentReportConfig&&);
    IncidentReportConfig(const IncidentReportConfig&);
    IncidentReportConfig& operator=(const IncidentReportConfig&);
    bool operator==(const IncidentReportConfig&) const;
    bool operator!=(const IncidentReportConfig& other) const {
      return !(*this == other);
    }

    // Raw proto decoding.
    void ParseRawProto(const std::string&);
    // Conversion methods from/to the corresponding protobuf types.
    void FromProto(const perfetto::protos::TraceConfig_IncidentReportConfig&);
    void ToProto(perfetto::protos::TraceConfig_IncidentReportConfig*) const;

    const std::string& destination_package() const {
      return destination_package_;
    }
    void set_destination_package(const std::string& value) {
      destination_package_ = value;
    }

    const std::string& destination_class() const { return destination_class_; }
    void set_destination_class(const std::string& value) {
      destination_class_ = value;
    }

    int32_t privacy_level() const { return privacy_level_; }
    void set_privacy_level(int32_t value) { privacy_level_ = value; }

    bool skip_dropbox() const { return skip_dropbox_; }
    void set_skip_dropbox(bool value) { skip_dropbox_ = value; }

   private:
    std::string destination_package_{};
    std::string destination_class_{};
    int32_t privacy_level_{};
    bool skip_dropbox_{};

    // Allows to preserve unknown protobuf fields for compatibility
    // with future versions of .proto files.
    std::string unknown_fields_;
  };

  TraceConfig();
  ~TraceConfig();
  TraceConfig(TraceConfig&&) noexcept;
  TraceConfig& operator=(TraceConfig&&);
  TraceConfig(const TraceConfig&);
  TraceConfig& operator=(const TraceConfig&);
  bool operator==(const TraceConfig&) const;
  bool operator!=(const TraceConfig& other) const { return !(*this == other); }

  // Raw proto decoding.
  void ParseRawProto(const std::string&);
  // Conversion methods from/to the corresponding protobuf types.
  void FromProto(const perfetto::protos::TraceConfig&);
  void ToProto(perfetto::protos::TraceConfig*) const;

  int buffers_size() const { return static_cast<int>(buffers_.size()); }
  const std::vector<BufferConfig>& buffers() const { return buffers_; }
  std::vector<BufferConfig>* mutable_buffers() { return &buffers_; }
  void clear_buffers() { buffers_.clear(); }
  BufferConfig* add_buffers() {
    buffers_.emplace_back();
    return &buffers_.back();
  }

  int data_sources_size() const {
    return static_cast<int>(data_sources_.size());
  }
  const std::vector<DataSource>& data_sources() const { return data_sources_; }
  std::vector<DataSource>* mutable_data_sources() { return &data_sources_; }
  void clear_data_sources() { data_sources_.clear(); }
  DataSource* add_data_sources() {
    data_sources_.emplace_back();
    return &data_sources_.back();
  }

  const BuiltinDataSource& builtin_data_sources() const {
    return *builtin_data_sources_;
  }
  BuiltinDataSource* mutable_builtin_data_sources() {
    return builtin_data_sources_.get();
  }

  uint32_t duration_ms() const { return duration_ms_; }
  void set_duration_ms(uint32_t value) { duration_ms_ = value; }

  bool enable_extra_guardrails() const { return enable_extra_guardrails_; }
  void set_enable_extra_guardrails(bool value) {
    enable_extra_guardrails_ = value;
  }

  LockdownModeOperation lockdown_mode() const { return lockdown_mode_; }
  void set_lockdown_mode(LockdownModeOperation value) {
    lockdown_mode_ = value;
  }

  int producers_size() const { return static_cast<int>(producers_.size()); }
  const std::vector<ProducerConfig>& producers() const { return producers_; }
  std::vector<ProducerConfig>* mutable_producers() { return &producers_; }
  void clear_producers() { producers_.clear(); }
  ProducerConfig* add_producers() {
    producers_.emplace_back();
    return &producers_.back();
  }

  const StatsdMetadata& statsd_metadata() const { return *statsd_metadata_; }
  StatsdMetadata* mutable_statsd_metadata() { return statsd_metadata_.get(); }

  bool write_into_file() const { return write_into_file_; }
  void set_write_into_file(bool value) { write_into_file_ = value; }

  uint32_t file_write_period_ms() const { return file_write_period_ms_; }
  void set_file_write_period_ms(uint32_t value) {
    file_write_period_ms_ = value;
  }

  uint64_t max_file_size_bytes() const { return max_file_size_bytes_; }
  void set_max_file_size_bytes(uint64_t value) { max_file_size_bytes_ = value; }

  const GuardrailOverrides& guardrail_overrides() const {
    return *guardrail_overrides_;
  }
  GuardrailOverrides* mutable_guardrail_overrides() {
    return guardrail_overrides_.get();
  }

  bool deferred_start() const { return deferred_start_; }
  void set_deferred_start(bool value) { deferred_start_ = value; }

  uint32_t flush_period_ms() const { return flush_period_ms_; }
  void set_flush_period_ms(uint32_t value) { flush_period_ms_ = value; }

  uint32_t flush_timeout_ms() const { return flush_timeout_ms_; }
  void set_flush_timeout_ms(uint32_t value) { flush_timeout_ms_ = value; }

  uint32_t data_source_stop_timeout_ms() const {
    return data_source_stop_timeout_ms_;
  }
  void set_data_source_stop_timeout_ms(uint32_t value) {
    data_source_stop_timeout_ms_ = value;
  }

  bool notify_traceur() const { return notify_traceur_; }
  void set_notify_traceur(bool value) { notify_traceur_ = value; }

  const TriggerConfig& trigger_config() const { return *trigger_config_; }
  TriggerConfig* mutable_trigger_config() { return trigger_config_.get(); }

  int activate_triggers_size() const {
    return static_cast<int>(activate_triggers_.size());
  }
  const std::vector<std::string>& activate_triggers() const {
    return activate_triggers_;
  }
  std::vector<std::string>* mutable_activate_triggers() {
    return &activate_triggers_;
  }
  void clear_activate_triggers() { activate_triggers_.clear(); }
  std::string* add_activate_triggers() {
    activate_triggers_.emplace_back();
    return &activate_triggers_.back();
  }

  const IncrementalStateConfig& incremental_state_config() const {
    return *incremental_state_config_;
  }
  IncrementalStateConfig* mutable_incremental_state_config() {
    return incremental_state_config_.get();
  }

  bool allow_user_build_tracing() const { return allow_user_build_tracing_; }
  void set_allow_user_build_tracing(bool value) {
    allow_user_build_tracing_ = value;
  }

  const std::string& unique_session_name() const {
    return unique_session_name_;
  }
  void set_unique_session_name(const std::string& value) {
    unique_session_name_ = value;
  }

  CompressionType compression_type() const { return compression_type_; }
  void set_compression_type(CompressionType value) {
    compression_type_ = value;
  }

  const IncidentReportConfig& incident_report_config() const {
    return *incident_report_config_;
  }
  IncidentReportConfig* mutable_incident_report_config() {
    return incident_report_config_.get();
  }

  const std::string& trace_uuid() const { return trace_uuid_; }
  void set_trace_uuid(const std::string& value) { trace_uuid_ = value; }
  void set_trace_uuid(const void* p, size_t s) {
    trace_uuid_.assign(reinterpret_cast<const char*>(p), s);
  }

 private:
  std::vector<BufferConfig> buffers_;
  std::vector<DataSource> data_sources_;
  ::perfetto::base::CopyablePtr<BuiltinDataSource> builtin_data_sources_;
  uint32_t duration_ms_{};
  bool enable_extra_guardrails_{};
  LockdownModeOperation lockdown_mode_{};
  std::vector<ProducerConfig> producers_;
  ::perfetto::base::CopyablePtr<StatsdMetadata> statsd_metadata_;
  bool write_into_file_{};
  uint32_t file_write_period_ms_{};
  uint64_t max_file_size_bytes_{};
  ::perfetto::base::CopyablePtr<GuardrailOverrides> guardrail_overrides_;
  bool deferred_start_{};
  uint32_t flush_period_ms_{};
  uint32_t flush_timeout_ms_{};
  uint32_t data_source_stop_timeout_ms_{};
  bool notify_traceur_{};
  ::perfetto::base::CopyablePtr<TriggerConfig> trigger_config_;
  std::vector<std::string> activate_triggers_;
  ::perfetto::base::CopyablePtr<IncrementalStateConfig>
      incremental_state_config_;
  bool allow_user_build_tracing_{};
  std::string unique_session_name_{};
  CompressionType compression_type_{};
  ::perfetto::base::CopyablePtr<IncidentReportConfig> incident_report_config_;
  std::string trace_uuid_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;
};

}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_TRACING_CORE_TRACE_CONFIG_H_
// gen_amalgamated begin header: include/perfetto/tracing/data_source.h
// gen_amalgamated begin header: include/perfetto/base/compiler.h
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_BASE_COMPILER_H_
#define INCLUDE_PERFETTO_BASE_COMPILER_H_

#include <type_traits>

#define PERFETTO_LIKELY(_x) __builtin_expect(!!(_x), 1)
#define PERFETTO_UNLIKELY(_x) __builtin_expect(!!(_x), 0)

#if defined(__GNUC__) || defined(__clang__)
#define PERFETTO_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
#define PERFETTO_WARN_UNUSED_RESULT
#endif

#if defined(__clang__)
#define PERFETTO_ALWAYS_INLINE __attribute__((__always_inline__))
#else
// GCC is too pedantic and often fails with the error:
// "always_inline function might not be inlinable"
#define PERFETTO_ALWAYS_INLINE
#endif

// TODO(lalitm): is_trivially_constructible is currently not available
// in some environments we build in. Reenable when that environment supports
// this.
#if defined(__GLIBCXX__)
#define PERFETTO_IS_TRIVIALLY_CONSTRUCTIBLE(T) true
#else
#define PERFETTO_IS_TRIVIALLY_CONSTRUCTIBLE(T) \
  std::is_trivially_constructible<T>::value
#endif

// TODO(lalitm): is_trivially_copyable is currently not available
// in some environments we build in. Reenable when that environment supports
// this.
#if defined(__GLIBCXX__)
#define PERFETTO_IS_TRIVIALLY_COPYABLE(T) true
#else
#define PERFETTO_IS_TRIVIALLY_COPYABLE(T) std::is_trivially_copyable<T>::value
#endif

namespace perfetto {
namespace base {

template <typename... T>
inline void ignore_result(const T&...) {}

}  // namespace base
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_BASE_COMPILER_H_
// gen_amalgamated begin header: include/perfetto/protozero/message.h
// gen_amalgamated begin header: include/perfetto/base/logging.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_BASE_LOGGING_H_
#define INCLUDE_PERFETTO_BASE_LOGGING_H_

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>  // For strerror.

// gen_amalgamated expanded: #include "perfetto/base/build_config.h"
// gen_amalgamated expanded: #include "perfetto/base/compiler.h"

// TODO(primiano): movee this to base/build_config.h, turn into
// PERFETTO_BUILDFLAG(DCHECK_IS_ON) and update call sites to use that instead.
#if defined(NDEBUG) && !defined(DCHECK_ALWAYS_ON)
#define PERFETTO_DCHECK_IS_ON() 0
#else
#define PERFETTO_DCHECK_IS_ON() 1
#endif

#if PERFETTO_BUILDFLAG(PERFETTO_FORCE_DLOG_ON)
#define PERFETTO_DLOG_IS_ON() 1
#elif PERFETTO_BUILDFLAG(PERFETTO_FORCE_DLOG_OFF)
#define PERFETTO_DLOG_IS_ON() 0
#else
#define PERFETTO_DLOG_IS_ON() PERFETTO_DCHECK_IS_ON()
#endif

#if defined(PERFETTO_ANDROID_ASYNC_SAFE_LOG)
#if !PERFETTO_BUILDFLAG(PERFETTO_OS_ANDROID) || \
    !PERFETTO_BUILDFLAG(PERFETTO_ANDROID_BUILD)
#error "Async-safe logging is limited to Android tree builds"
#endif
// For binaries which need a very lightweight logging implementation.
// Note that this header is incompatible with android/log.h.
#include <async_safe/log.h>
#elif PERFETTO_BUILDFLAG(PERFETTO_OS_ANDROID)
// Normal android logging.
#include <android/log.h>
#endif

#if !PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)
#include <unistd.h>
#endif

namespace perfetto {
namespace base {

// Constexpr functions to extract basename(__FILE__), e.g.: ../foo/f.c -> f.c .
constexpr const char* StrEnd(const char* s) {
  return *s ? StrEnd(s + 1) : s;
}

constexpr const char* BasenameRecursive(const char* s,
                                        const char* begin,
                                        const char* end) {
  return (*s == '/' && s < end)
             ? (s + 1)
             : ((s > begin) ? BasenameRecursive(s - 1, begin, end) : s);
}

constexpr const char* Basename(const char* str) {
  return BasenameRecursive(StrEnd(str), str, StrEnd(str));
}

#define PERFETTO_LOG_LINE__(x) #x
#define PERFETTO_LOG_LINE_(x) PERFETTO_LOG_LINE__(x)
#define PERFETTO_LOG_LINE PERFETTO_LOG_LINE_(__LINE__)

enum LogLev { kLogDebug = 0, kLogInfo, kLogImportant, kLogError };
#if PERFETTO_BUILDFLAG(PERFETTO_OS_WIN) || PERFETTO_BUILDFLAG(PERFETTO_OS_WASM)
// The escape sequences don't work in a Windows command prompt.
#define PERFETTO_XLOG_STDERR(level, fmt, ...)                              \
  fprintf(stderr, "%-24.24s " fmt "\n",                                    \
          ::perfetto::base::Basename(__FILE__ "(" PERFETTO_LOG_LINE "):"), \
          ##__VA_ARGS__)
#else
constexpr const char* kLogFmt[] = {"\x1b[2m", "\x1b[39m", "\x1b[32m\x1b[1m",
                                   "\x1b[31m"};

#define PERFETTO_XLOG_STDERR(level, fmt, ...)                         \
  fprintf(stderr, "\x1b[90m%-24.24s\x1b[0m %s" fmt "\x1b[0m\n",       \
          ::perfetto::base::Basename(__FILE__ ":" PERFETTO_LOG_LINE), \
          ::perfetto::base::kLogFmt[::perfetto::base::LogLev::level], \
          ##__VA_ARGS__)
#endif

#if PERFETTO_BUILDFLAG(PERFETTO_OS_ANDROID) && \
    defined(PERFETTO_ANDROID_ASYNC_SAFE_LOG)
#define PERFETTO_XLOG(level, fmt, ...)                                         \
  do {                                                                         \
    async_safe_format_log(                                                     \
        (ANDROID_LOG_DEBUG + ::perfetto::base::LogLev::level), "perfetto",     \
        "%s " fmt, ::perfetto::base::Basename(__FILE__ ":" PERFETTO_LOG_LINE), \
        ##__VA_ARGS__);                                                        \
  } while (0)
#elif PERFETTO_BUILDFLAG(PERFETTO_OS_ANDROID)
// Standard logging marco on Android - log to both stderr and logcat. When part
// of the Android tree, stderr points to /dev/null so logcat is the only way to
// get some logging.
#define PERFETTO_XLOG(level, fmt, ...)                                         \
  do {                                                                         \
    __android_log_print(                                                       \
        (ANDROID_LOG_DEBUG + ::perfetto::base::LogLev::level), "perfetto",     \
        "%s " fmt, ::perfetto::base::Basename(__FILE__ ":" PERFETTO_LOG_LINE), \
        ##__VA_ARGS__);                                                        \
    PERFETTO_XLOG_STDERR(level, fmt, ##__VA_ARGS__);                           \
  } while (0)
#else
#define PERFETTO_XLOG PERFETTO_XLOG_STDERR
#endif

#define PERFETTO_IMMEDIATE_CRASH() \
  do {                             \
    __builtin_trap();              \
    __builtin_unreachable();       \
  } while (0)

#define PERFETTO_LOG(fmt, ...) PERFETTO_XLOG(kLogInfo, fmt, ##__VA_ARGS__)
#define PERFETTO_ILOG(fmt, ...) PERFETTO_XLOG(kLogImportant, fmt, ##__VA_ARGS__)
#define PERFETTO_ELOG(fmt, ...) PERFETTO_XLOG(kLogError, fmt, ##__VA_ARGS__)
#define PERFETTO_FATAL(fmt, ...)       \
  do {                                 \
    PERFETTO_PLOG(fmt, ##__VA_ARGS__); \
    PERFETTO_IMMEDIATE_CRASH();        \
  } while (0)

#define PERFETTO_PLOG(x, ...) \
  PERFETTO_ELOG(x " (errno: %d, %s)", ##__VA_ARGS__, errno, strerror(errno))

#if PERFETTO_DLOG_IS_ON()

#define PERFETTO_DLOG(fmt, ...) PERFETTO_XLOG(kLogDebug, fmt, ##__VA_ARGS__)

#define PERFETTO_DPLOG(x, ...) \
  PERFETTO_DLOG(x " (errno: %d, %s)", ##__VA_ARGS__, errno, strerror(errno))

#else

#define PERFETTO_DLOG(...) ::perfetto::base::ignore_result(__VA_ARGS__)
#define PERFETTO_DPLOG(...) ::perfetto::base::ignore_result(__VA_ARGS__)

#endif  // PERFETTO_DLOG_IS_ON()

#if PERFETTO_DCHECK_IS_ON()

#define PERFETTO_DCHECK(x)                           \
  do {                                               \
    if (PERFETTO_UNLIKELY(!(x))) {                   \
      PERFETTO_PLOG("%s", "PERFETTO_CHECK(" #x ")"); \
      PERFETTO_IMMEDIATE_CRASH();                    \
    }                                                \
  } while (0)

#define PERFETTO_DFATAL(fmt, ...)      \
  do {                                 \
    PERFETTO_PLOG(fmt, ##__VA_ARGS__); \
    PERFETTO_IMMEDIATE_CRASH();        \
  } while (0)

#define PERFETTO_DFATAL_OR_ELOG(...) PERFETTO_DFATAL(__VA_ARGS__)

#else

#define PERFETTO_DCHECK(x) \
  do {                     \
  } while (false && (x))

#define PERFETTO_DFATAL(...) ::perfetto::base::ignore_result(__VA_ARGS__)
#define PERFETTO_DFATAL_OR_ELOG(...) PERFETTO_ELOG(__VA_ARGS__)

#endif  // PERFETTO_DCHECK_IS_ON()

#if PERFETTO_DCHECK_IS_ON()
#define PERFETTO_CHECK(x) PERFETTO_DCHECK(x)
#else
#define PERFETTO_CHECK(x)                            \
  do {                                               \
    if (PERFETTO_UNLIKELY(!(x))) {                   \
      PERFETTO_PLOG("%s", "PERFETTO_CHECK(" #x ")"); \
      PERFETTO_IMMEDIATE_CRASH();                    \
    }                                                \
  } while (0)

#endif  // PERFETTO_DCHECK_IS_ON()

}  // namespace base
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_BASE_LOGGING_H_
// gen_amalgamated begin header: include/perfetto/protozero/contiguous_memory_range.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_PROTOZERO_CONTIGUOUS_MEMORY_RANGE_H_
#define INCLUDE_PERFETTO_PROTOZERO_CONTIGUOUS_MEMORY_RANGE_H_

#include <assert.h>
#include <stddef.h>
#include <stdint.h>

namespace protozero {

// Keep this struct trivially constructible (no ctors, no default initializers).
struct ContiguousMemoryRange {
  uint8_t* begin;
  uint8_t* end;  // STL style: one byte past the end of the buffer.

  inline bool is_valid() const { return begin != nullptr; }
  inline void reset() { begin = nullptr; }
  inline size_t size() { return static_cast<size_t>(end - begin); }
};

}  // namespace protozero

#endif  // INCLUDE_PERFETTO_PROTOZERO_CONTIGUOUS_MEMORY_RANGE_H_
// gen_amalgamated begin header: include/perfetto/protozero/proto_utils.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_PROTOZERO_PROTO_UTILS_H_
#define INCLUDE_PERFETTO_PROTOZERO_PROTO_UTILS_H_

#include <inttypes.h>
#include <stddef.h>

#include <type_traits>

// gen_amalgamated expanded: #include "perfetto/base/logging.h"

namespace protozero {
namespace proto_utils {

// See https://developers.google.com/protocol-buffers/docs/encoding wire types.
// This is a type encoded into the proto that provides just enough info to
// find the length of the following value.
enum class ProtoWireType : uint32_t {
  kVarInt = 0,
  kFixed64 = 1,
  kLengthDelimited = 2,
  kFixed32 = 5,
};

// This is the type defined in the proto for each field. This information
// is used to decide the translation strategy when writing the trace.
enum class ProtoSchemaType {
  kUnknown = 0,
  kDouble,
  kFloat,
  kInt64,
  kUint64,
  kInt32,
  kFixed64,
  kFixed32,
  kBool,
  kString,
  kGroup,  // Deprecated (proto2 only)
  kMessage,
  kBytes,
  kUint32,
  kEnum,
  kSfixed32,
  kSfixed64,
  kSint32,
  kSint64,
};

inline const char* ProtoSchemaToString(ProtoSchemaType v) {
  switch (v) {
    case ProtoSchemaType::kUnknown:
      return "unknown";
    case ProtoSchemaType::kDouble:
      return "double";
    case ProtoSchemaType::kFloat:
      return "float";
    case ProtoSchemaType::kInt64:
      return "int64";
    case ProtoSchemaType::kUint64:
      return "uint64";
    case ProtoSchemaType::kInt32:
      return "int32";
    case ProtoSchemaType::kFixed64:
      return "fixed64";
    case ProtoSchemaType::kFixed32:
      return "fixed32";
    case ProtoSchemaType::kBool:
      return "bool";
    case ProtoSchemaType::kString:
      return "string";
    case ProtoSchemaType::kGroup:
      return "group";
    case ProtoSchemaType::kMessage:
      return "message";
    case ProtoSchemaType::kBytes:
      return "bytes";
    case ProtoSchemaType::kUint32:
      return "uint32";
    case ProtoSchemaType::kEnum:
      return "enum";
    case ProtoSchemaType::kSfixed32:
      return "sfixed32";
    case ProtoSchemaType::kSfixed64:
      return "sfixed64";
    case ProtoSchemaType::kSint32:
      return "sint32";
    case ProtoSchemaType::kSint64:
      return "sint64";
  }
  // For gcc:
  PERFETTO_DCHECK(false);
  return "";
}

// Maximum message size supported: 256 MiB (4 x 7-bit due to varint encoding).
constexpr size_t kMessageLengthFieldSize = 4;
constexpr size_t kMaxMessageLength = (1u << (kMessageLengthFieldSize * 7)) - 1;

// Field tag is encoded as 32-bit varint (5 bytes at most).
// Largest value of simple (not length-delimited) field is 64-bit varint
// (10 bytes at most). 15 bytes buffer is enough to store a simple field.
constexpr size_t kMaxTagEncodedSize = 5;
constexpr size_t kMaxSimpleFieldEncodedSize = kMaxTagEncodedSize + 10;

// Proto types: (int|uint|sint)(32|64), bool, enum.
constexpr uint32_t MakeTagVarInt(uint32_t field_id) {
  return (field_id << 3) | static_cast<uint32_t>(ProtoWireType::kVarInt);
}

// Proto types: fixed64, sfixed64, fixed32, sfixed32, double, float.
template <typename T>
constexpr uint32_t MakeTagFixed(uint32_t field_id) {
  static_assert(sizeof(T) == 8 || sizeof(T) == 4, "Value must be 4 or 8 bytes");
  return (field_id << 3) |
         static_cast<uint32_t>((sizeof(T) == 8 ? ProtoWireType::kFixed64
                                               : ProtoWireType::kFixed32));
}

// Proto types: string, bytes, embedded messages.
constexpr uint32_t MakeTagLengthDelimited(uint32_t field_id) {
  return (field_id << 3) |
         static_cast<uint32_t>(ProtoWireType::kLengthDelimited);
}

// Proto types: sint64, sint32.
template <typename T>
inline typename std::make_unsigned<T>::type ZigZagEncode(T value) {
  return static_cast<typename std::make_unsigned<T>::type>(
      (value << 1) ^ (value >> (sizeof(T) * 8 - 1)));
}

template <typename T>
inline uint8_t* WriteVarInt(T value, uint8_t* target) {
  // If value is <= 0 we must first sign extend to int64_t (see [1]).
  // Finally we always cast to an unsigned value to to avoid arithmetic
  // (sign expanding) shifts in the while loop.
  // [1]: "If you use int32 or int64 as the type for a negative number, the
  // resulting varint is always ten bytes long".
  // - developers.google.com/protocol-buffers/docs/encoding
  // So for each input type we do the following casts:
  // uintX_t -> uintX_t -> uintX_t
  // int8_t  -> int64_t -> uint64_t
  // int16_t -> int64_t -> uint64_t
  // int32_t -> int64_t -> uint64_t
  // int64_t -> int64_t -> uint64_t
  using MaybeExtendedType =
      typename std::conditional<std::is_unsigned<T>::value, T, int64_t>::type;
  using UnsignedType = typename std::make_unsigned<MaybeExtendedType>::type;

  MaybeExtendedType extended_value = static_cast<MaybeExtendedType>(value);
  UnsignedType unsigned_value = static_cast<UnsignedType>(extended_value);

  while (unsigned_value >= 0x80) {
    *target++ = static_cast<uint8_t>(unsigned_value) | 0x80;
    unsigned_value >>= 7;
  }
  *target = static_cast<uint8_t>(unsigned_value);
  return target + 1;
}

// Writes a fixed-size redundant encoding of the given |value|. This is
// used to backfill fixed-size reservations for the length field using a
// non-canonical varint encoding (e.g. \x81\x80\x80\x00 instead of \x01).
// See https://github.com/google/protobuf/issues/1530.
// In particular, this is used for nested messages. The size of a nested message
// is not known until all its field have been written. |kMessageLengthFieldSize|
// bytes are reserved to encode the size field and backfilled at the end.
inline void WriteRedundantVarInt(uint32_t value, uint8_t* buf) {
  for (size_t i = 0; i < kMessageLengthFieldSize; ++i) {
    const uint8_t msb = (i < kMessageLengthFieldSize - 1) ? 0x80 : 0;
    buf[i] = static_cast<uint8_t>(value) | msb;
    value >>= 7;
  }
}

template <uint32_t field_id>
void StaticAssertSingleBytePreamble() {
  static_assert(field_id < 16,
                "Proto field id too big to fit in a single byte preamble");
}

// Parses a VarInt from the encoded buffer [start, end). |end| is STL-style and
// points one byte past the end of buffer.
// The parsed int value is stored in the output arg |value|. Returns a pointer
// to the next unconsumed byte (so start < retval <= end) or |start| if the
// VarInt could not be fully parsed because there was not enough space in the
// buffer.
inline const uint8_t* ParseVarInt(const uint8_t* start,
                                  const uint8_t* end,
                                  uint64_t* value) {
  const uint8_t* pos = start;
  uint64_t shift = 0;
  *value = 0;
  do {
    if (PERFETTO_UNLIKELY(pos >= end)) {
      *value = 0;
      return start;
    }
    PERFETTO_DCHECK(shift < 64ull);
    *value |= static_cast<uint64_t>(*pos & 0x7f) << shift;
    shift += 7;
  } while (*pos++ & 0x80);
  return pos;
}

}  // namespace proto_utils
}  // namespace protozero

#endif  // INCLUDE_PERFETTO_PROTOZERO_PROTO_UTILS_H_
// gen_amalgamated begin header: include/perfetto/protozero/scattered_stream_writer.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_PROTOZERO_SCATTERED_STREAM_WRITER_H_
#define INCLUDE_PERFETTO_PROTOZERO_SCATTERED_STREAM_WRITER_H_

#include <assert.h>
#include <stddef.h>
#include <stdint.h>
#include <string.h>

// gen_amalgamated expanded: #include "perfetto/base/compiler.h"
// gen_amalgamated expanded: #include "perfetto/base/export.h"
// gen_amalgamated expanded: #include "perfetto/protozero/contiguous_memory_range.h"

namespace protozero {

// This class deals with the following problem: append-only proto messages want
// to write a stream of bytes, without caring about the implementation of the
// underlying buffer (which concretely will be either the trace ring buffer
// or a heap-allocated buffer). The main deal is: proto messages don't know in
// advance what their size will be.
// Due to the tracing buffer being split into fixed-size chunks, on some
// occasions, these writes need to be spread over two (or more) non-contiguous
// chunks of memory. Similarly, when the buffer is backed by the heap, we want
// to avoid realloc() calls, as they might cause a full copy of the contents
// of the buffer.
// The purpose of this class is to abstract away the non-contiguous write logic.
// This class knows how to deal with writes as long as they fall in the same
// ContiguousMemoryRange and defers the chunk-chaining logic to the Delegate.
class PERFETTO_EXPORT ScatteredStreamWriter {
 public:
  class PERFETTO_EXPORT Delegate {
   public:
    virtual ~Delegate();
    virtual ContiguousMemoryRange GetNewBuffer() = 0;
  };

  explicit ScatteredStreamWriter(Delegate* delegate);
  ~ScatteredStreamWriter();

  inline void WriteByte(uint8_t value) {
    if (write_ptr_ >= cur_range_.end)
      Extend();
    *write_ptr_++ = value;
  }

  // Assumes that the caller checked that there is enough headroom.
  // TODO(primiano): perf optimization, this is a tracing hot path. The
  // compiler can make strong optimization on memcpy if the size arg is a
  // constexpr. Make a templated variant of this for fixed-size writes.
  // TODO(primiano): restrict / noalias might also help.
  inline void WriteBytesUnsafe(const uint8_t* src, size_t size) {
    uint8_t* const end = write_ptr_ + size;
    assert(end <= cur_range_.end);
    memcpy(write_ptr_, src, size);
    write_ptr_ = end;
  }

  inline void WriteBytes(const uint8_t* src, size_t size) {
    uint8_t* const end = write_ptr_ + size;
    if (PERFETTO_LIKELY(end <= cur_range_.end))
      return WriteBytesUnsafe(src, size);
    WriteBytesSlowPath(src, size);
  }

  void WriteBytesSlowPath(const uint8_t* src, size_t size);

  // Reserves a fixed amount of bytes to be backfilled later. The reserved range
  // is guaranteed to be contiguous and not span across chunks. |size| has to be
  // <= than the size of a new buffer returned by the Delegate::GetNewBuffer().
  uint8_t* ReserveBytes(size_t size);

  // Fast (but unsafe) version of the above. The caller must have previously
  // checked that there are at least |size| contiguous bytes available.
  // Returns only the start pointer of the reservation.
  uint8_t* ReserveBytesUnsafe(size_t size) {
    uint8_t* begin = write_ptr_;
    write_ptr_ += size;
    assert(write_ptr_ <= cur_range_.end);
    return begin;
  }

  // Resets the buffer boundaries and the write pointer to the given |range|.
  // Subsequent WriteByte(s) will write into |range|.
  void Reset(ContiguousMemoryRange range);

  // Number of contiguous free bytes in |cur_range_| that can be written without
  // requesting a new buffer.
  size_t bytes_available() const {
    return static_cast<size_t>(cur_range_.end - write_ptr_);
  }

  uint8_t* write_ptr() const { return write_ptr_; }

  uint64_t written() const {
    return written_previously_ +
           static_cast<uint64_t>(write_ptr_ - cur_range_.begin);
  }

 private:
  ScatteredStreamWriter(const ScatteredStreamWriter&) = delete;
  ScatteredStreamWriter& operator=(const ScatteredStreamWriter&) = delete;

  void Extend();

  Delegate* const delegate_;
  ContiguousMemoryRange cur_range_;
  uint8_t* write_ptr_;
  uint64_t written_previously_ = 0;
};

}  // namespace protozero

#endif  // INCLUDE_PERFETTO_PROTOZERO_SCATTERED_STREAM_WRITER_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_PROTOZERO_MESSAGE_H_
#define INCLUDE_PERFETTO_PROTOZERO_MESSAGE_H_

#include <assert.h>
#include <stdint.h>
#include <string.h>

#include <type_traits>

// gen_amalgamated expanded: #include "perfetto/base/export.h"
// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/protozero/contiguous_memory_range.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"
// gen_amalgamated expanded: #include "perfetto/protozero/scattered_stream_writer.h"

namespace perfetto {
namespace shm_fuzz {
class FakeProducer;
}  // namespace shm_fuzz
}  // namespace perfetto

namespace protozero {

class MessageHandleBase;

// Base class extended by the proto C++ stubs generated by the ProtoZero
// compiler. This class provides the minimal runtime required to support
// append-only operations and is designed for performance. None of the methods
// require any dynamic memory allocation.
class PERFETTO_EXPORT Message {
 public:
  friend class MessageHandleBase;

  // Adjust the |nested_messages_arena_| size when changing this, or the
  // static_assert in the .cc file will bark.
  static constexpr uint32_t kMaxNestingDepth = 10;

  // Ctor and Dtor of Message are never called, with the exeception
  // of root (non-nested) messages. Nested messages are allocated via placement
  // new in the |nested_messages_arena_| and implictly destroyed when the arena
  // of the root message goes away. This is fine as long as all the fields are
  // PODs, which is checked by the static_assert in the ctor (see the Reset()
  // method in the .cc file).
  Message() = default;

  // Clears up the state, allowing the message to be reused as a fresh one.
  void Reset(ScatteredStreamWriter*);

  // Commits all the changes to the buffer (backfills the size field of this and
  // all nested messages) and seals the message. Returns the size of the message
  // (and all nested sub-messages), without taking into account any chunking.
  // Finalize is idempotent and can be called several times w/o side effects.
  uint32_t Finalize();

  // Optional. If is_valid() == true, the corresponding memory region (its
  // length == proto_utils::kMessageLengthFieldSize) is backfilled with the size
  // of this message (minus |size_already_written| below). This is the mechanism
  // used by messages to backfill their corresponding size field in the parent
  // message.
  uint8_t* size_field() const { return size_field_; }
  void set_size_field(uint8_t* size_field) { size_field_ = size_field; }

  // This is to deal with case of backfilling the size of a root (non-nested)
  // message which is split into multiple chunks. Upon finalization only the
  // partial size that lies in the last chunk has to be backfilled.
  void inc_size_already_written(uint32_t sz) { size_already_written_ += sz; }

  Message* nested_message() { return nested_message_; }

  bool is_finalized() const { return finalized_; }

#if PERFETTO_DCHECK_IS_ON()
  void set_handle(MessageHandleBase* handle) { handle_ = handle; }
#endif

  // Proto types: uint64, uint32, int64, int32, bool, enum.
  template <typename T>
  void AppendVarInt(uint32_t field_id, T value) {
    if (nested_message_)
      EndNestedMessage();

    uint8_t buffer[proto_utils::kMaxSimpleFieldEncodedSize];
    uint8_t* pos = buffer;

    pos = proto_utils::WriteVarInt(proto_utils::MakeTagVarInt(field_id), pos);
    // WriteVarInt encodes signed values in two's complement form.
    pos = proto_utils::WriteVarInt(value, pos);
    WriteToStream(buffer, pos);
  }

  // Proto types: sint64, sint32.
  template <typename T>
  void AppendSignedVarInt(uint32_t field_id, T value) {
    AppendVarInt(field_id, proto_utils::ZigZagEncode(value));
  }

  // Proto types: bool, enum (small).
  // Faster version of AppendVarInt for tiny numbers.
  void AppendTinyVarInt(uint32_t field_id, int32_t value) {
    PERFETTO_DCHECK(0 <= value && value < 0x80);
    if (nested_message_)
      EndNestedMessage();

    uint8_t buffer[proto_utils::kMaxSimpleFieldEncodedSize];
    uint8_t* pos = buffer;
    // MakeTagVarInt gets super optimized here for constexpr.
    pos = proto_utils::WriteVarInt(proto_utils::MakeTagVarInt(field_id), pos);
    *pos++ = static_cast<uint8_t>(value);
    WriteToStream(buffer, pos);
  }

  // Proto types: fixed64, sfixed64, fixed32, sfixed32, double, float.
  template <typename T>
  void AppendFixed(uint32_t field_id, T value) {
    if (nested_message_)
      EndNestedMessage();

    uint8_t buffer[proto_utils::kMaxSimpleFieldEncodedSize];
    uint8_t* pos = buffer;

    pos = proto_utils::WriteVarInt(proto_utils::MakeTagFixed<T>(field_id), pos);
    memcpy(pos, &value, sizeof(T));
    pos += sizeof(T);
    // TODO: Optimize memcpy performance, see http://crbug.com/624311 .
    WriteToStream(buffer, pos);
  }

  void AppendString(uint32_t field_id, const char* str);
  void AppendBytes(uint32_t field_id, const void* value, size_t size);

  // Append raw bytes for a field, using the supplied |ranges| to
  // copy from |num_ranges| individual buffers.
  size_t AppendScatteredBytes(uint32_t field_id,
                              ContiguousMemoryRange* ranges,
                              size_t num_ranges);

  // Begins a nested message, using the static storage provided by the parent
  // class (see comment in |nested_messages_arena_|). The nested message ends
  // either when Finalize() is called or when any other Append* method is called
  // in the parent class.
  // The template argument T is supposed to be a stub class auto generated from
  // a .proto, hence a subclass of Message.
  template <class T>
  T* BeginNestedMessage(uint32_t field_id) {
    // This is to prevent subclasses (which should be autogenerated, though), to
    // introduce extra state fields (which wouldn't be initialized by Reset()).
    static_assert(std::is_base_of<Message, T>::value,
                  "T must be a subclass of Message");
    static_assert(sizeof(T) == sizeof(Message),
                  "Message subclasses cannot introduce extra state.");
    T* message = reinterpret_cast<T*>(nested_messages_arena_);
    BeginNestedMessageInternal(field_id, message);
    return message;
  }

  ScatteredStreamWriter* stream_writer_for_testing() { return stream_writer_; }

 private:
  Message(const Message&) = delete;
  Message& operator=(const Message&) = delete;

  void BeginNestedMessageInternal(uint32_t field_id, Message*);

  // Called by Finalize and Append* methods.
  void EndNestedMessage();

  void WriteToStream(const uint8_t* src_begin, const uint8_t* src_end) {
    PERFETTO_DCHECK(!finalized_);
    PERFETTO_DCHECK(src_begin <= src_end);
    const uint32_t size = static_cast<uint32_t>(src_end - src_begin);
    stream_writer_->WriteBytes(src_begin, size);
    size_ += size;
  }

  // Only POD fields are allowed. This class's dtor is never called.
  // See the comment on the static_assert in the corresponding .cc file.

  // The stream writer interface used for the serialization.
  ScatteredStreamWriter* stream_writer_;

  uint8_t* size_field_;

  // Keeps track of the size of the current message.
  uint32_t size_;

  // See comment for inc_size_already_written().
  uint32_t size_already_written_;

  // When true, no more changes to the message are allowed. This is to DCHECK
  // attempts of writing to a message which has been Finalize()-d.
  bool finalized_;

  // Used to detect attemps to create messages with a nesting level >
  // kMaxNestingDepth. |nesting_depth_| == 0 for root (non-nested) messages.
  uint8_t nesting_depth_;

#if PERFETTO_DCHECK_IS_ON()
  // Current generation of message. Incremented on Reset.
  // Used to detect stale handles.
  uint32_t generation_;

  MessageHandleBase* handle_;
#endif

  // Pointer to the last child message created through BeginNestedMessage(), if
  // any, nullptr otherwise. There is no need to keep track of more than one
  // message per nesting level as the proto-zero API contract mandates that
  // nested fields can be filled only in a stacked fashion. In other words,
  // nested messages are finalized and sealed when any other field is set in the
  // parent message (or the parent message itself is finalized) and cannot be
  // accessed anymore afterwards.
  // TODO(primiano): optimization: I think that nested_message_, when non-null.
  // will always be @ (this) + offsetof(nested_messages_arena_).
  Message* nested_message_;

  // The root message owns the storage for all its nested messages, up to a max
  // of kMaxNestingDepth levels (see the .cc file). Note that the boundaries of
  // the arena are meaningful only for the root message.
  // Unfortunately we cannot put the sizeof() math here because we cannot sizeof
  // the current class in a header. However the .cc file has a static_assert
  // that guarantees that (see the Reset() method in the .cc file).
  alignas(sizeof(void*)) uint8_t nested_messages_arena_[512];

  // DO NOT add any fields below |nested_messages_arena_|. The memory layout of
  // nested messages would overflow the storage allocated by the root message.
};

}  // namespace protozero

#endif  // INCLUDE_PERFETTO_PROTOZERO_MESSAGE_H_
// gen_amalgamated begin header: include/perfetto/protozero/message_handle.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_PROTOZERO_MESSAGE_HANDLE_H_
#define INCLUDE_PERFETTO_PROTOZERO_MESSAGE_HANDLE_H_

#include <functional>

// gen_amalgamated expanded: #include "perfetto/base/export.h"
// gen_amalgamated expanded: #include "perfetto/protozero/message.h"

namespace protozero {

class Message;

// MessageHandle allows to decouple the lifetime of a proto message
// from the underlying storage. It gives the following guarantees:
// - The underlying message is finalized (if still alive) if the handle goes
//   out of scope.
// - In Debug / DCHECK_ALWAYS_ON builds, the handle becomes null once the
//   message is finalized. This is to enforce the append-only API. For instance
//   when adding two repeated messages, the addition of the 2nd one forces
//   the finalization of the first.
// Think about this as a WeakPtr<Message> which calls
// Message::Finalize() when going out of scope.

class PERFETTO_EXPORT MessageHandleBase {
 public:
  class FinalizationListener {
   public:
    virtual ~FinalizationListener();
    virtual void OnMessageFinalized(Message* message) = 0;
  };

  ~MessageHandleBase();

  // Move-only type.
  MessageHandleBase(MessageHandleBase&&) noexcept;
  MessageHandleBase& operator=(MessageHandleBase&&);
  explicit operator bool() const {
#if PERFETTO_DCHECK_IS_ON()
    PERFETTO_DCHECK(!message_ || generation_ == message_->generation_);
#endif
    return !!message_;
  }

  void set_finalization_listener(FinalizationListener* listener) {
    listener_ = listener;
  }

 protected:
  explicit MessageHandleBase(Message* = nullptr);
  Message* operator->() const {
#if PERFETTO_DCHECK_IS_ON()
    PERFETTO_DCHECK(!message_ || generation_ == message_->generation_);
#endif
    return message_;
  }
  Message& operator*() const { return *(operator->()); }

 private:
  friend class Message;
  MessageHandleBase(const MessageHandleBase&) = delete;
  MessageHandleBase& operator=(const MessageHandleBase&) = delete;

  void reset_message() {
    // This is called by Message::Finalize().
    PERFETTO_DCHECK(message_->is_finalized());
    message_ = nullptr;
    listener_ = nullptr;
  }

  void Move(MessageHandleBase&&);

  void FinalizeMessage() {
    // |message_| and |listener_| may be cleared by reset_message() during
    // Message::Finalize().
    auto* listener = listener_;
    auto* message = message_;
    message->Finalize();
    if (listener)
      listener->OnMessageFinalized(message);
  }

  Message* message_;
  FinalizationListener* listener_ = nullptr;
#if PERFETTO_DCHECK_IS_ON()
  uint32_t generation_;
#endif
};

template <typename T>
class MessageHandle : public MessageHandleBase {
 public:
  MessageHandle() : MessageHandle(nullptr) {}
  explicit MessageHandle(T* message) : MessageHandleBase(message) {}

  T& operator*() const {
    return static_cast<T&>(MessageHandleBase::operator*());
  }

  T* operator->() const {
    return static_cast<T*>(MessageHandleBase::operator->());
  }
};

}  // namespace protozero

#endif  // INCLUDE_PERFETTO_PROTOZERO_MESSAGE_HANDLE_H_
// gen_amalgamated begin header: include/perfetto/tracing/internal/basic_types.h
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_TRACING_INTERNAL_BASIC_TYPES_H_
#define INCLUDE_PERFETTO_TRACING_INTERNAL_BASIC_TYPES_H_

#include <stddef.h>
#include <stdint.h>

namespace perfetto {
namespace internal {

// A static_assert in tracing_muxer_impl.cc guarantees that this stays in sync
// with the definition in tracing/core/basic_types.h
using BufferId = uint16_t;

// This is a direct index in the TracingMuxer::backends_ vector.
// Backends are only added and never removed.
using TracingBackendId = size_t;

// Max numbers of data sources that can be registered in a process.
constexpr size_t kMaxDataSources = 32;

// Max instances for each data source type. This typically matches the
// "max number of concurrent tracing sessions". However remember that a data
// source can be instantiated more than once within one tracing session by
// creating two entries for it in the trace config.
constexpr size_t kMaxDataSourceInstances = 8;

}  // namespace internal
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_TRACING_INTERNAL_BASIC_TYPES_H_
// gen_amalgamated begin header: include/perfetto/tracing/internal/data_source_internal.h
// gen_amalgamated begin header: include/perfetto/tracing/trace_writer_base.h
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_TRACING_TRACE_WRITER_BASE_H_
#define INCLUDE_PERFETTO_TRACING_TRACE_WRITER_BASE_H_

// gen_amalgamated expanded: #include "perfetto/protozero/message_handle.h"

namespace perfetto {

namespace protos {
namespace pbzero {
class TracePacket;
}  // namespace pbzero
}  // namespace protos

// The bare-minimum subset of the TraceWriter interface that is exposed as a
// fully public API.
// See comments in /include/perfetto/ext/tracing/core/trace_writer.h.
class TraceWriterBase {
 public:
  virtual ~TraceWriterBase();

  virtual protozero::MessageHandle<protos::pbzero::TracePacket>
  NewTracePacket() = 0;

  virtual void Flush(std::function<void()> callback = {}) = 0;
};

}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_TRACING_TRACE_WRITER_BASE_H_
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_TRACING_INTERNAL_DATA_SOURCE_INTERNAL_H_
#define INCLUDE_PERFETTO_TRACING_INTERNAL_DATA_SOURCE_INTERNAL_H_

#include <stddef.h>
#include <stdint.h>

#include <array>
#include <atomic>
#include <functional>
#include <memory>
#include <mutex>

// No perfetto headers (other than tracing/api and protozero) should be here.
// gen_amalgamated expanded: #include "perfetto/tracing/internal/basic_types.h"
// gen_amalgamated expanded: #include "perfetto/tracing/trace_writer_base.h"

namespace perfetto {

class DataSourceBase;
class TraceWriterBase;

namespace internal {

class TracingTLS;

// This maintains the internal state of a data source instance that is used only
// to implement the tracing mechanics and is not exposed to the API client.
// There is one of these object per DataSource instance (up to
// kMaxDataSourceInstances).
struct DataSourceState {
  // This boolean flag determines whether the DataSource::Trace() method should
  // do something or be a no-op. This flag doesn't give the full guarantee
  // that tracing data will be visible in the trace, it just makes it so that
  // the client attemps writing trace data and interacting with the service.
  // For instance, when a tracing session ends the service will reject data
  // commits that arrive too late even if the producer hasn't received the stop
  // IPC message.
  // This flag is set right before calling OnStart() and cleared right before
  // calling OnStop(), unless using HandleStopAsynchronously() (see comments
  // in data_source.h).
  // Keep this flag as the first field. This allows the compiler to directly
  // dereference the DataSourceState* pointer in the trace fast-path without
  // doing extra pointr arithmetic.
  bool trace_lambda_enabled = false;

  // The central buffer id that all TraceWriter(s) created by this data source
  // must target.
  BufferId buffer_id = 0;

  // The index within TracingMuxerImpl.backends_. Practically it allows to
  // lookup the Producer object, and hence the IPC channel, for this data
  // source.
  TracingBackendId backend_id = 0;

  // The instance id as assigned by the tracing service. Note that because a
  // process can be connected to >1 services, this ID is not globally unique but
  // is only unique within the scope of its backend.
  // Only the tuple (backend_id, data_source_instance_id) is globally unique.
  uint64_t data_source_instance_id = 0;

  // This lock is not held to implement Trace() and it's used only if the trace
  // code wants to access its own data source state.
  // This is to prevent that accessing the data source on an arbitrary embedder
  // thread races with the internal IPC thread destroying the data source
  // because of a end-of-tracing notification from the service.
  std::recursive_mutex lock;
  std::unique_ptr<DataSourceBase> data_source;
};

// This is to allow lazy-initialization and avoid static initializers and
// at-exit destructors. All the entries are initialized via placement-new when
// DataSource::Register() is called, see TracingMuxerImpl::RegisterDataSource().
struct DataSourceStateStorage {
  alignas(DataSourceState) char storage[sizeof(DataSourceState)]{};
};

// Per-DataSource-type global state.
struct DataSourceStaticState {
  uint32_t index =
      kMaxDataSources;  // Unique ID, assigned at registration time.

  // A bitmap that tells about the validity of each |instances| entry. When the
  // i-th bit of the bitmap it's set, instances[i] is valid.
  std::atomic<uint32_t> valid_instances{};
  std::array<DataSourceStateStorage, kMaxDataSourceInstances> instances{};

  // Can be used with a cached |valid_instances| bitmap.
  DataSourceState* TryGetCached(uint32_t cached_bitmap, size_t n) {
    return cached_bitmap & (1 << n)
               ? reinterpret_cast<DataSourceState*>(&instances[n])
               : nullptr;
  }

  DataSourceState* TryGet(size_t n) {
    return TryGetCached(valid_instances.load(std::memory_order_acquire), n);
  }

  void CompilerAsserts() {
    static_assert(sizeof(valid_instances.load()) * 8 >= kMaxDataSourceInstances,
                  "kMaxDataSourceInstances too high");
  }
};

// Per-DataSource-instance thread-local state.
struct DataSourceInstanceThreadLocalState {
  using IncrementalStatePointer = std::unique_ptr<void, void (*)(void*)>;

  void Reset() {
    trace_writer.reset();
    incremental_state.reset();
    backend_id = 0;
    buffer_id = 0;
  }

  std::unique_ptr<TraceWriterBase> trace_writer;
  IncrementalStatePointer incremental_state = {nullptr, [](void*) {}};
  TracingBackendId backend_id;
  BufferId buffer_id;
};

// Per-DataSource-type thread-local state.
struct DataSourceThreadLocalState {
  DataSourceStaticState* static_state = nullptr;

  // Pointer to the parent tls object that holds us. Used to retrieve the
  // generation, which is per-global-TLS and not per data-source.
  TracingTLS* root_tls = nullptr;

  // One entry per each data source instance.
  std::array<DataSourceInstanceThreadLocalState, kMaxDataSourceInstances>
      per_instance{};
};

}  // namespace internal
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_TRACING_INTERNAL_DATA_SOURCE_INTERNAL_H_
// gen_amalgamated begin header: include/perfetto/tracing/internal/tracing_muxer.h
// gen_amalgamated begin header: include/perfetto/tracing/internal/tracing_tls.h
// gen_amalgamated begin header: include/perfetto/tracing/platform.h
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_TRACING_PLATFORM_H_
#define INCLUDE_PERFETTO_TRACING_PLATFORM_H_

#include <stddef.h>
#include <stdint.h>

#include <functional>
#include <memory>

// gen_amalgamated expanded: #include "perfetto/base/export.h"

namespace perfetto {

namespace base {
class TaskRunner;
}  // namespace base

// This abstract class is used to abstract dependencies on platform-specific
// primitives that cannot be implemented by the perfetto codebase and must be
// provided or overridden by the embedder.
// This is, for instance, for cases where we want to use some particular
// base:: class in Chrome and provide instead POSIX fallbacks for other
// embedders.

// Base class for thread-local objects. This is to get a basic object vtable and
// delegate destruction to the embedder. See Platform::CreateThreadLocalObject.
class PlatformThreadLocalObject {
 public:
  // Implemented by perfetto internal code. The embedder must call this when
  // implementing GetOrCreateThreadLocalObject() to create an instance for the
  // first time on each thread.
  static std::unique_ptr<PlatformThreadLocalObject> CreateInstance();
  virtual ~PlatformThreadLocalObject();
};

class PERFETTO_EXPORT Platform {
 public:
  // Embedders can use this unless they have custom needs (e.g. Chrome wanting
  // to use its own base class for TLS).
  static Platform* GetDefaultPlatform();

  virtual ~Platform();

  // Creates a thread-local object. The embedder must:
  // - Create an instance per-thread calling ThreadLocalObject::CreateInstance.
  // - Own the lifetime of the returned object as long as the thread is alive.
  // - Destroy it when the thread exits.
  // Perfetto requires only one thread-local object overall (obviously, one
  // instance per-thread) from the embedder.
  using ThreadLocalObject = ::perfetto::PlatformThreadLocalObject;
  virtual ThreadLocalObject* GetOrCreateThreadLocalObject() = 0;

  // Creates a sequenced task runner. The easiest implementation is to create
  // a new thread (e.g. use base::ThreadTaskRunner) but this can also be
  // implemented in some more clever way (e.g. using chromiums's scheduler).
  struct CreateTaskRunnerArgs {};
  virtual std::unique_ptr<base::TaskRunner> CreateTaskRunner(
      const CreateTaskRunnerArgs&) = 0;

  // Used to derive the producer name. Mostly relevant when using the
  // kSystemBackend mode. It can be an arbitrary string when using the
  // in-process mode.
  virtual std::string GetCurrentProcessName() = 0;
};

}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_TRACING_PLATFORM_H_
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_TRACING_INTERNAL_TRACING_TLS_H_
#define INCLUDE_PERFETTO_TRACING_INTERNAL_TRACING_TLS_H_

#include <array>
#include <memory>

// gen_amalgamated expanded: #include "perfetto/tracing/internal/basic_types.h"
// gen_amalgamated expanded: #include "perfetto/tracing/internal/data_source_internal.h"
// gen_amalgamated expanded: #include "perfetto/tracing/platform.h"

namespace perfetto {

class TraceWriterBase;

namespace internal {

// Organization of the thread-local storage
// ----------------------------------------
// First of all, remember the cardinality of the problem: at any point in time
// there are M data sources registered (i.e. number of subclasses of DataSource)
// and up to N concurrent instances for each data source, so up to M * N total
// data source instances around.
// Each data source instance can be accessed by T threads (no upper bound).
// We can safely put hard limits both to M and N (i.e. say that we support at
// most 32 data source types per process and up to 8 concurrent instances).
//
// We want to make it so from the Platform viewpoint, we use only one global
// TLS object, so T instances in total, one per thread, regardless of M and N.
// This allows to deal with at-thread-exit destruction only in one place, rather
// than N, M or M * N.
//
// Visually:
//                     [    Thread 1   ] [    Thread 2   ] [    Thread T   ]
//                     +---------------+ +---------------+ +---------------+
// Data source Foo     |               | |               | |               |
//  Instance 1         |     TLS       | |     TLS       | |     TLS       |
//  Instance 2         |    Object     | |    Object     | |    Object     |
//  Instance 3         |               | |               | |               |
//                     |               | |               | |               |
// Data source Bar     |               | |               | |               |
//  Instance 1         |               | |               | |               |
//  Instance 2         |               | |               | |               |
//                     +---------------+ +---------------+ +---------------+
//
// Each TLS Object is organized as an array of M DataSourceThreadLocalState.
// Each DSTLS itself is an array of up to N per-instance objects.
// The only per-instance object for now is the TraceWriter.
// So for each data source, for each instance, for each thread we keep one
// TraceWriter.
// The lookup is O(1): Given the TLS object, the TraceWriter is just tls[M][N].
class TracingTLS : public Platform::ThreadLocalObject {
 public:
  ~TracingTLS() override;

  // This is checked against TraceMuxerImpl's global generation counter to
  // handle destruction of TraceWriter(s) that belong to data sources that
  // have been stopped. When the two numbers diverge, a scan of all the
  // thread-local TraceWriter(s) is issued.
  uint32_t generation = 0;

  std::array<DataSourceThreadLocalState, kMaxDataSources> data_sources_tls{};
};

}  // namespace internal
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_TRACING_INTERNAL_TRACING_TLS_H_
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_TRACING_INTERNAL_TRACING_MUXER_H_
#define INCLUDE_PERFETTO_TRACING_INTERNAL_TRACING_MUXER_H_

#include <atomic>
#include <memory>

// gen_amalgamated expanded: #include "perfetto/base/export.h"
// gen_amalgamated expanded: #include "perfetto/tracing/internal/basic_types.h"
// gen_amalgamated expanded: #include "perfetto/tracing/internal/tracing_tls.h"
// gen_amalgamated expanded: #include "perfetto/tracing/platform.h"

namespace perfetto {

class DataSourceBase;
class DataSourceDescriptor;
class TraceWriterBase;
struct TracingInitArgs;
class TracingSession;

namespace internal {

struct DataSourceStaticState;

// This class acts as a bridge between the public API methods and the
// TracingBackend(s). It exposes a simplified view of the world to the API
// methods, so that they don't have to care about the multiplicity of backends.
// It handles all the bookkeeping to map data source instances and trace writers
// to the various backends.
// See tracing_muxer_impl.h for the full picture. This class contains only the
// fewer fields and methods that need to be exposed to public/ headers. Fields
// and methods that are required to implement them should go into
// src/tracing/internal/tracing_muxer_impl.h instead: that one can pull in
// perfetto headers outside of public, this one cannot.
class PERFETTO_EXPORT TracingMuxer {
 public:
  static TracingMuxer* Get() { return instance_; }

  virtual ~TracingMuxer();

  TracingTLS* GetOrCreateTracingTLS() {
    return static_cast<TracingTLS*>(platform_->GetOrCreateThreadLocalObject());
  }

  // Note that the returned object is one per-thread per-data-source-type, NOT
  // per data-soruce *instance*.
  DataSourceThreadLocalState* GetOrCreateDataSourceTLS(
      DataSourceStaticState* static_state) {
    TracingTLS* root_tls = GetOrCreateTracingTLS();
    auto* ds_tls = &root_tls->data_sources_tls[static_state->index];

    // The per-type TLS is either zero-initialized or must have been initialized
    // for this specific data source type. We keep re-initializing as the
    // initialization is idempotent and not worth the code for extra checks.
    assert(!ds_tls->static_state || ds_tls->static_state == static_state);
    ds_tls->static_state = static_state;
    assert(!ds_tls->root_tls || ds_tls->root_tls == root_tls);
    ds_tls->root_tls = root_tls;
    return ds_tls;
  }

  // This method can fail and return false if trying to register more than
  // kMaxDataSources types.
  using DataSourceFactory = std::function<std::unique_ptr<DataSourceBase>()>;
  virtual bool RegisterDataSource(const DataSourceDescriptor&,
                                  DataSourceFactory,
                                  DataSourceStaticState*) = 0;

  // It identifies the right backend and forwards the call to it.
  // The returned TraceWriter must be used within the same sequence (for most
  // projects this means "same thread"). Alternatively the client needs to take
  // care of using synchronization primitives to prevent concurrent accesses.
  virtual std::unique_ptr<TraceWriterBase> CreateTraceWriter(
      DataSourceState*) = 0;

  virtual void DestroyStoppedTraceWritersForCurrentThread() = 0;

  uint32_t generation(std::memory_order ord) { return generation_.load(ord); }

 protected:
  explicit TracingMuxer(Platform* platform) : platform_(platform) {}

  static TracingMuxer* instance_;
  Platform* const platform_ = nullptr;

  // Incremented every time a data source is destroyed. See tracing_tls.h.
  std::atomic<uint32_t> generation_{};
};

}  // namespace internal
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_TRACING_INTERNAL_TRACING_MUXER_H_
// gen_amalgamated begin header: include/perfetto/tracing/locked_handle.h
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_TRACING_LOCKED_HANDLE_H_
#define INCLUDE_PERFETTO_TRACING_LOCKED_HANDLE_H_

#include <mutex>

namespace perfetto {

// This is used for GetDataSourceLocked(), in the (rare) case where the
// tracing code wants to access the state of its data source from the Trace()
// method.
template <typename T>
class LockedHandle {
 public:
  LockedHandle(std::recursive_mutex* mtx, T* obj) : lock_(*mtx), obj_(obj) {}
  LockedHandle() = default;  // For the invalid case.
  LockedHandle(LockedHandle&&) = default;
  LockedHandle& operator=(LockedHandle&&) = default;

  bool valid() const { return obj_; }
  explicit operator bool() const { return valid(); }

  T* operator->() {
    assert(valid());
    return obj_;
  }

  T& operator*() { return *(this->operator->()); }

 private:
  std::unique_lock<std::recursive_mutex> lock_;
  T* obj_ = nullptr;
};

}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_TRACING_LOCKED_HANDLE_H_
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/trace_packet.pbzero.h
// gen_amalgamated begin header: include/perfetto/protozero/packed_repeated_fields.h
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_PROTOZERO_PACKED_REPEATED_FIELDS_H_
#define INCLUDE_PERFETTO_PROTOZERO_PACKED_REPEATED_FIELDS_H_

#include <stdint.h>

#include <array>

// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace protozero {

// This file contains classes used when encoding packed repeated fields.
// To encode such a field, the caller is first expected to accumulate all of the
// values in one of the following types (depending on the wire type of the
// individual elements), defined below:
// * protozero::PackedVarIntBuffer
// * protozero::PackedFixedSizeBuffer</*element_type=*/ uint32_t>
// Then that buffer is passed to the protozero-generated setters as an argument.
// After calling the setter, the buffer can be destroyed.
//
// The buffer classes by themselves do not own the raw memory used to hold the
// accumulated values, so they need to be instantiated via a subclass that
// implements the storage. This file provides one such type, StackAllocated, for
// buffering the values using the stack.
//
// An example of encoding a packed field:
//   protozero::HeapBuffered<protozero::Message> msg;
//   // stack buffer holding up to 128 varints
//   protozero::StackAllocated<protozero::PackedVarIntBuffer, 128> buf;
//   buf.Append(42);
//   buf.Append(-1);
//   msg->set_fieldname(buf);
//   msg.SerializeAsString();
class PackedVarIntBuffer {
 public:
  // worst case encoded size per varint
  using StorageElementType = std::array<uint8_t, 10>;

  template <typename T>
  void Append(T value) {
    PERFETTO_CHECK(++element_size_ <= element_capacity_);
    write_ptr_ = proto_utils::WriteVarInt(value, write_ptr_);
  }

  const uint8_t* data() const { return storage_begin_; }

  size_t size() const {
    return static_cast<size_t>(write_ptr_ - storage_begin_);
  }

 protected:
  PackedVarIntBuffer(StorageElementType* storage, size_t storage_capacity)
      : storage_begin_(reinterpret_cast<uint8_t*>(storage)),
        write_ptr_(reinterpret_cast<uint8_t*>(storage)),
        element_capacity_(storage_capacity) {}

 private:
  // Storage will consist of an array of StorageElementType, but we treat it as
  // a contiguous uint8_t buffer. Note that the varints will not be aligned with
  // StorageElementType boundaries.
  uint8_t* const storage_begin_;
  uint8_t* write_ptr_;

  size_t element_size_ = 0;
  const size_t element_capacity_;
};

template <typename ElementType>
class PackedFixedSizeBuffer {
 public:
  // The template type parameter is the same as the storage type, so one
  // of the type names is used in all places for consistency.
  using StorageElementType = ElementType;

  void Append(StorageElementType value) {
    PERFETTO_CHECK(write_ptr_ < storage_end_);
    *(write_ptr_++) = value;
  }

  const uint8_t* data() const {
    return reinterpret_cast<const uint8_t*>(storage_begin_);
  }

  size_t size() const {
    return static_cast<size_t>(reinterpret_cast<uint8_t*>(write_ptr_) -
                               reinterpret_cast<uint8_t*>(storage_begin_));
  }

 protected:
  PackedFixedSizeBuffer(StorageElementType* storage,
                        size_t max_storage_elements)
      : storage_begin_(storage),
        storage_end_(storage + max_storage_elements),
        write_ptr_(storage) {
    static_assert(
        sizeof(StorageElementType) == 4 || sizeof(StorageElementType) == 8,
        "invalid type width");
  }

 private:
  StorageElementType* const storage_begin_;
  StorageElementType* const storage_end_;
  StorageElementType* write_ptr_;
};

template <typename PackedBuffer, size_t MaxNumElements>
class StackAllocated : public PackedBuffer {
 public:
  StackAllocated() : PackedBuffer(storage_, MaxNumElements) {}

 private:
  typename PackedBuffer::StorageElementType storage_[MaxNumElements];
};

}  // namespace protozero

#endif  // INCLUDE_PERFETTO_PROTOZERO_PACKED_REPEATED_FIELDS_H_
// gen_amalgamated begin header: include/perfetto/protozero/proto_decoder.h
// gen_amalgamated begin header: include/perfetto/protozero/field.h
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_PROTOZERO_FIELD_H_
#define INCLUDE_PERFETTO_PROTOZERO_FIELD_H_

#include <stdint.h>

#include <string>

// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/protozero/contiguous_memory_range.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace protozero {

struct ConstBytes {
  const uint8_t* data;
  size_t size;
};

struct ConstChars {
  // Allow implicit conversion to perfetto's base::StringView without depending
  // on perfetto/base or viceversa.
  static constexpr bool kConvertibleToStringView = true;
  std::string ToStdString() const { return std::string(data, size); }

  const char* data;
  size_t size;
};

// A protobuf field decoded by the protozero proto decoders. It exposes
// convenience accessors with minimal debug checks.
// This class is used both by the iterator-based ProtoDecoder and by the
// one-shot TypedProtoDecoder.
// If the field is not valid the accessors consistently return zero-integers or
// null strings.
class Field {
 public:
  inline bool valid() const { return id_ != 0; }
  inline uint16_t id() const { return id_; }
  explicit inline operator bool() const { return valid(); }

  inline proto_utils::ProtoWireType type() const {
    auto res = static_cast<proto_utils::ProtoWireType>(type_);
    PERFETTO_DCHECK(res == proto_utils::ProtoWireType::kVarInt ||
                    res == proto_utils::ProtoWireType::kLengthDelimited ||
                    res == proto_utils::ProtoWireType::kFixed32 ||
                    res == proto_utils::ProtoWireType::kFixed64);
    return res;
  }

  inline bool as_bool() const {
    PERFETTO_DCHECK(!valid() || type() == proto_utils::ProtoWireType::kVarInt);
    return static_cast<bool>(int_value_);
  }

  inline uint32_t as_uint32() const {
    PERFETTO_DCHECK(!valid() || type() == proto_utils::ProtoWireType::kVarInt ||
                    type() == proto_utils::ProtoWireType::kFixed32);
    return static_cast<uint32_t>(int_value_);
  }

  inline int32_t as_int32() const {
    PERFETTO_DCHECK(!valid() || type() == proto_utils::ProtoWireType::kVarInt ||
                    type() == proto_utils::ProtoWireType::kFixed32);
    return static_cast<int32_t>(int_value_);
  }

  inline uint64_t as_uint64() const {
    PERFETTO_DCHECK(!valid() || type() == proto_utils::ProtoWireType::kVarInt ||
                    type() == proto_utils::ProtoWireType::kFixed32 ||
                    type() == proto_utils::ProtoWireType::kFixed64);
    return int_value_;
  }

  inline int64_t as_int64() const {
    PERFETTO_DCHECK(!valid() || type() == proto_utils::ProtoWireType::kVarInt ||
                    type() == proto_utils::ProtoWireType::kFixed32 ||
                    type() == proto_utils::ProtoWireType::kFixed64);
    return static_cast<int64_t>(int_value_);
  }

  inline float as_float() const {
    PERFETTO_DCHECK(!valid() || type() == proto_utils::ProtoWireType::kFixed32);
    float res;
    uint32_t value32 = static_cast<uint32_t>(int_value_);
    memcpy(&res, &value32, sizeof(res));
    return res;
  }

  inline double as_double() const {
    PERFETTO_DCHECK(!valid() || type() == proto_utils::ProtoWireType::kFixed64);
    double res;
    memcpy(&res, &int_value_, sizeof(res));
    return res;
  }

  inline ConstChars as_string() const {
    PERFETTO_DCHECK(!valid() ||
                    type() == proto_utils::ProtoWireType::kLengthDelimited);
    return ConstChars{reinterpret_cast<const char*>(data()), size_};
  }

  inline std::string as_std_string() const { return as_string().ToStdString(); }

  inline ConstBytes as_bytes() const {
    PERFETTO_DCHECK(!valid() ||
                    type() == proto_utils::ProtoWireType::kLengthDelimited);
    return ConstBytes{data(), size_};
  }

  inline const uint8_t* data() const {
    PERFETTO_DCHECK(!valid() ||
                    type() == proto_utils::ProtoWireType::kLengthDelimited);
    return reinterpret_cast<const uint8_t*>(int_value_);
  }

  inline size_t size() const {
    PERFETTO_DCHECK(!valid() ||
                    type() == proto_utils::ProtoWireType::kLengthDelimited);
    return size_;
  }

  inline uint64_t raw_int_value() const { return int_value_; }

  inline void initialize(uint16_t id,
                         uint8_t type,
                         uint64_t int_value,
                         uint32_t size) {
    id_ = id;
    type_ = type;
    int_value_ = int_value;
    size_ = size;
  }

 private:
  // Fields are deliberately not initialized to keep the class trivially
  // constructible. It makes a large perf difference for ProtoDecoder.

  uint64_t int_value_;  // In kLengthDelimited this contains the data() addr.
  uint32_t size_;       // Only valid when when type == kLengthDelimited.
  uint16_t id_;         // Proto field ordinal.
  uint8_t type_;        // proto_utils::ProtoWireType.
};

// The Field struct is used in a lot of perf-sensitive contexts.
static_assert(sizeof(Field) == 16, "Field struct too big");

}  // namespace protozero

#endif  // INCLUDE_PERFETTO_PROTOZERO_FIELD_H_
/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_PROTOZERO_PROTO_DECODER_H_
#define INCLUDE_PERFETTO_PROTOZERO_PROTO_DECODER_H_

#include <stdint.h>
#include <array>
#include <memory>
#include <vector>

// gen_amalgamated expanded: #include "perfetto/base/compiler.h"
// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/protozero/field.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace protozero {

// A generic protobuf decoder. Doesn't require any knowledge about the proto
// schema. It tokenizes fields, retrieves their ID and type and exposes
// accessors to retrieve its values.
// It does NOT recurse in nested submessages, instead it just computes their
// boundaries, recursion is left to the caller.
// This class is designed to be used in perf-sensitive contexts. It does not
// allocate and does not perform any proto semantic checks (e.g. repeated /
// required / optional). It's supposedly safe wrt out-of-bounds memory accesses
// (see proto_decoder_fuzzer.cc).
// This class serves also as a building block for TypedProtoDecoder, used when
// the schema is known at compile time.
class ProtoDecoder {
 public:
  // Creates a ProtoDecoder using the given |buffer| with size |length| bytes.
  inline ProtoDecoder(const uint8_t* buffer, size_t length)
      : begin_(buffer), end_(buffer + length), read_ptr_(buffer) {}

  // Reads the next field from the buffer and advances the read cursor. If a
  // full field cannot be read, the returned Field will be invalid (i.e.
  // field.valid() == false).
  Field ReadField();

  // Finds the first field with the given id. Doesn't affect the read cursor.
  Field FindField(uint32_t field_id);

  // Resets the read cursor to the start of the buffer.
  inline void Reset() { read_ptr_ = begin_; }

  // Resets the read cursor to the given position (must be within the buffer).
  inline void Reset(const uint8_t* pos) {
    PERFETTO_DCHECK(pos >= begin_ && pos < end_);
    read_ptr_ = pos;
  }

  // Returns the position of read cursor, relative to the start of the buffer.
  inline size_t read_offset() const {
    return static_cast<size_t>(read_ptr_ - begin_);
  }

  inline size_t bytes_left() const {
    PERFETTO_DCHECK(read_ptr_ <= end_);
    return static_cast<size_t>(end_ - read_ptr_);
  }

  const uint8_t* begin() const { return begin_; }
  const uint8_t* end() const { return end_; }

 protected:
  const uint8_t* const begin_;
  const uint8_t* const end_;
  const uint8_t* read_ptr_ = nullptr;
};

// An iterator-like class used to iterate through repeated fields. Used by
// TypedProtoDecoder. The iteration sequence is a bit counter-intuitive due to
// the fact that fields_[field_id] holds the *last* value of the field, not the
// first, but the remaining storage holds repeated fields in FIFO order.
// Assume that we push the 10,11,12 into a repeated field with ID=1.
//
// Decoder memory layout:  [  fields storage  ] [ repeated fields storage ]
// 1st iteration:           10
// 2nd iteration:           11                   10
// 3rd iteration:           12                   10 11
//
// We start the iteration @ fields_[num_fields], which is the start of the
// repeated fields storage, proceed until the end and lastly jump @ fields_[id].
class RepeatedFieldIterator {
 public:
  RepeatedFieldIterator(uint32_t field_id,
                        const Field* begin,
                        const Field* end,
                        const Field* last)
      : field_id_(field_id), iter_(begin), end_(end), last_(last) {
    FindNextMatchingId();
  }

  inline const Field* operator->() const { return &*iter_; }
  inline const Field& operator*() const { return *iter_; }
  inline explicit operator bool() const { return iter_ != end_; }

  RepeatedFieldIterator& operator++() {
    PERFETTO_DCHECK(iter_ != end_);
    if (iter_ == last_) {
      iter_ = end_;
      return *this;
    }
    ++iter_;
    FindNextMatchingId();
    return *this;
  }

  RepeatedFieldIterator operator++(int) {
    PERFETTO_DCHECK(iter_ != end_);
    RepeatedFieldIterator it(*this);
    ++(*this);
    return it;
  }

 private:
  inline void FindNextMatchingId() {
    PERFETTO_DCHECK(iter_ != last_);
    for (; iter_ != end_; ++iter_) {
      if (iter_->id() == field_id_)
        return;
    }
    iter_ = last_->valid() ? last_ : end_;
  }

  uint32_t field_id_;

  // Initially points to the beginning of the repeated field storage, then is
  // incremented as we call operator++().
  const Field* iter_;

  // Always points to fields_[size_], i.e. past the end of the storage.
  const Field* end_;

  // Always points to fields_[field_id].
  const Field* last_;
};

// As RepeatedFieldIterator, but allows iterating over a packed repeated field
// (which will be initially stored as a single length-delimited field).
// See |GetPackedRepeatedField| for details.
//
// Assumes little endianness, and that the input buffers are well formed -
// containing an exact multiple of encoded elements.
template <proto_utils::ProtoWireType wire_type, typename CppType>
class PackedRepeatedFieldIterator {
 public:
  PackedRepeatedFieldIterator(const uint8_t* data_begin,
                              size_t size,
                              bool* parse_error_ptr)
      : data_end_(data_begin ? data_begin + size : nullptr),
        read_ptr_(data_begin),
        parse_error_(parse_error_ptr) {
    using proto_utils::ProtoWireType;
    static_assert(wire_type == ProtoWireType::kVarInt ||
                      wire_type == ProtoWireType::kFixed32 ||
                      wire_type == ProtoWireType::kFixed64,
                  "invalid type");

    PERFETTO_DCHECK(parse_error_ptr);

    // Either the field is unset (and there are no data pointer), or the field
    // is set with a zero length payload. Mark the iterator as invalid in both
    // cases.
    if (size == 0) {
      curr_value_valid_ = false;
      return;
    }

    if ((wire_type == ProtoWireType::kFixed32 && (size % 4) != 0) ||
        (wire_type == ProtoWireType::kFixed64 && (size % 8) != 0)) {
      *parse_error_ = true;
      curr_value_valid_ = false;
      return;
    }

    ++(*this);
  }

  inline const CppType operator*() const { return curr_value_; }
  inline explicit operator bool() const { return curr_value_valid_; }

  PackedRepeatedFieldIterator& operator++() {
    using proto_utils::ProtoWireType;

    if (PERFETTO_UNLIKELY(!curr_value_valid_))
      return *this;

    if (PERFETTO_UNLIKELY(read_ptr_ == data_end_)) {
      curr_value_valid_ = false;
      return *this;
    }

    if (wire_type == ProtoWireType::kVarInt) {
      uint64_t new_value = 0;
      const uint8_t* new_pos =
          proto_utils::ParseVarInt(read_ptr_, data_end_, &new_value);

      if (PERFETTO_UNLIKELY(new_pos == read_ptr_)) {
        // Failed to decode the varint (probably incomplete buffer).
        *parse_error_ = true;
        curr_value_valid_ = false;
      } else {
        read_ptr_ = new_pos;
        curr_value_ = static_cast<CppType>(new_value);
      }
    } else {  // kFixed32 or kFixed64
      constexpr size_t kStep = wire_type == ProtoWireType::kFixed32 ? 4 : 8;

      // NB: the raw buffer is not guaranteed to be aligned, so neither are
      // these copies.
      memcpy(&curr_value_, read_ptr_, sizeof(CppType));
      read_ptr_ += kStep;
    }

    return *this;
  }

  PackedRepeatedFieldIterator operator++(int) {
    PackedRepeatedFieldIterator it(*this);
    ++(*this);
    return it;
  }

 private:
  // Might be null if the backing proto field isn't set.
  const uint8_t* const data_end_;

  // The iterator looks ahead by an element, so |curr_value| holds the value
  // to be returned when the caller dereferences the iterator, and |read_ptr_|
  // points at the start of the next element to be decoded.
  // |read_ptr_| might be null if the backing proto field isn't set.
  const uint8_t* read_ptr_;
  CppType curr_value_ = 0;

  // Set to false once we've exhausted the iterator, or encountered an error.
  bool curr_value_valid_ = true;

  // Where to set parsing errors, supplied by the caller.
  bool* const parse_error_;
};

// This decoder loads all fields upfront, without recursing in nested messages.
// It is used as a base class for typed decoders generated by the pbzero plugin.
// The split between TypedProtoDecoderBase and TypedProtoDecoder<> is to have
// unique definition of functions like ParseAllFields() and ExpandHeapStorage().
// The storage (either on-stack or on-heap) for this class is organized as
// follows:
// |-------------------------- fields_ ----------------------|
// [ field 0 (invalid) ] [ fields 1 .. N ] [ repeated fields ]
//                                        ^                  ^
//                                        num_fields_        size_
class TypedProtoDecoderBase : public ProtoDecoder {
 public:
  // If the field |id| is known at compile time, prefer the templated
  // specialization at<kFieldNumber>().
  inline const Field& Get(uint32_t id) const {
    return PERFETTO_LIKELY(id < num_fields_) ? fields_[id] : fields_[0];
  }

  // Returns an object that allows to iterate over all instances of a repeated
  // field given its id. Example usage:
  //   for (auto it = decoder.GetRepeated(N); it; ++it) { ... }
  inline RepeatedFieldIterator GetRepeated(uint32_t field_id) const {
    return RepeatedFieldIterator(field_id, &fields_[num_fields_],
                                 &fields_[size_], &fields_[field_id]);
  }

  // Returns an objects that allows to iterate over all entries of a packed
  // repeated field given its id and type. The |wire_type| is necessary for
  // decoding the packed field, the |cpp_type| is for convenience & stronger
  // typing.
  //
  // The caller must also supply a pointer to a bool that is set to true if the
  // packed buffer is found to be malformed while iterating (so you need to
  // exhaust the iterator if you want to check the full extent of the buffer).
  //
  // Note that unlike standard protobuf parsers, protozero does not allow
  // treating of packed repeated fields as non-packed and vice-versa (therefore
  // not making the packed option forwards and backwards compatible). So
  // the caller needs to use the right accessor for correct results.
  template <proto_utils::ProtoWireType wire_type, typename cpp_type>
  inline PackedRepeatedFieldIterator<wire_type, cpp_type> GetPackedRepeated(
      uint32_t field_id,
      bool* parse_error_location) const {
    const Field& field = Get(field_id);
    if (field.valid()) {
      return PackedRepeatedFieldIterator<wire_type, cpp_type>(
          field.data(), field.size(), parse_error_location);
    } else {
      return PackedRepeatedFieldIterator<wire_type, cpp_type>(
          nullptr, 0, parse_error_location);
    }
  }

 protected:
  TypedProtoDecoderBase(Field* storage,
                        uint32_t num_fields,
                        uint32_t capacity,
                        const uint8_t* buffer,
                        size_t length)
      : ProtoDecoder(buffer, length),
        fields_(storage),
        num_fields_(num_fields),
        size_(num_fields),
        capacity_(capacity) {
    // The reason why Field needs to be trivially de/constructible is to avoid
    // implicit initializers on all the ~1000 entries. We need it to initialize
    // only on the first |max_field_id| fields, the remaining capacity doesn't
    // require initialization.
    static_assert(PERFETTO_IS_TRIVIALLY_CONSTRUCTIBLE(Field) &&
                      std::is_trivially_destructible<Field>::value &&
                      std::is_trivial<Field>::value,
                  "Field must be a trivial aggregate type");
    memset(fields_, 0, sizeof(Field) * num_fields_);
  }

  void ParseAllFields();

  // Called when the default on-stack storage is exhausted and new repeated
  // fields need to be pushed.
  void ExpandHeapStorage();

  // Used only in presence of a large number of repeated fields, when the
  // default on-stack storage is exhausted.
  std::unique_ptr<Field[]> heap_storage_;

  // Points to the storage, either on-stack (default, provided by the template
  // specialization) or |heap_storage_| after ExpandHeapStorage() is called, in
  // case of a large number of repeated fields.
  Field* fields_;

  // Number of fields without accounting repeated storage. This is equal to
  // MAX_FIELD_ID + 1 (to account for the invalid 0th field).
  // This value is always <= size_ (and hence <= capacity);
  uint32_t num_fields_;

  // Number of active |fields_| entries. This is initially equal to the highest
  // number of fields for the message (num_fields_ == MAX_FIELD_ID + 1) and can
  // grow up to |capacity_| in the case of repeated fields.
  uint32_t size_;

  // Initially equal to kFieldsCapacity of the TypedProtoDecoder
  // specialization. Can grow when falling back on heap-based storage, in which
  // case it represents the size (#fields with each entry of a repeated field
  // counted individually) of the |heap_storage_| array.
  uint32_t capacity_;
};

// Template class instantiated by the auto-generated decoder classes declared in
// xxx.pbzero.h files.
template <int MAX_FIELD_ID, bool HAS_NONPACKED_REPEATED_FIELDS>
class TypedProtoDecoder : public TypedProtoDecoderBase {
 public:
  TypedProtoDecoder(const uint8_t* buffer, size_t length)
      : TypedProtoDecoderBase(on_stack_storage_,
                              /*num_fields=*/MAX_FIELD_ID + 1,
                              kCapacity,
                              buffer,
                              length) {
    static_assert(MAX_FIELD_ID <= kMaxDecoderFieldId, "Field ordinal too high");
    TypedProtoDecoderBase::ParseAllFields();
  }

  template <uint32_t FIELD_ID>
  inline const Field& at() const {
    static_assert(FIELD_ID <= MAX_FIELD_ID, "FIELD_ID > MAX_FIELD_ID");
    return fields_[FIELD_ID];
  }

  TypedProtoDecoder(TypedProtoDecoder&& other) noexcept
      : TypedProtoDecoderBase(std::move(other)) {
    // If the moved-from decoder was using on-stack storage, we need to update
    // our pointer to point to this decoder's on-stack storage.
    if (fields_ == other.on_stack_storage_) {
      fields_ = on_stack_storage_;
      memcpy(on_stack_storage_, other.on_stack_storage_,
             sizeof(on_stack_storage_));
    }
  }

 private:
  // In the case of non-repeated fields, this constant defines the highest field
  // id we are able to decode. This is to limit the on-stack storage.
  // In the case of repeated fields, this constant defines the max number of
  // repeated fields that we'll be able to store before falling back on the
  // heap. Keep this value in sync with the one in protozero_generator.cc.
  static constexpr size_t kMaxDecoderFieldId = 999;

  // If we the message has no repeated fields we need at most N Field entries
  // in the on-stack storage, where N is the highest field id.
  // Otherwise we need some room to store repeated fields.
  static constexpr size_t kCapacity =
      1 + (HAS_NONPACKED_REPEATED_FIELDS ? kMaxDecoderFieldId : MAX_FIELD_ID);

  Field on_stack_storage_[kCapacity];
};

}  // namespace protozero

#endif  // INCLUDE_PERFETTO_PROTOZERO_PROTO_DECODER_H_
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACE_PACKET_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACE_PACKET_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class AndroidLogPacket;
class AppendedData;
class BatteryCounters;
class ChromeBenchmarkMetadata;
class ChromeEventBundle;
class ChromeMetadataPacket;
class ClockSnapshot;
class FtraceEventBundle;
class FtraceStats;
class GpuCounterEvent;
class GpuRenderStageEvent;
class GraphicsFrameEvent;
class HeapGraph;
class InodeFileMap;
class InternedData;
class PackagesList;
class PerfettoMetatrace;
class PowerRails;
class ProcessDescriptor;
class ProcessStats;
class ProcessTree;
class ProfilePacket;
class ProfiledFrameSymbols;
class StreamingProfilePacket;
class SysStats;
class SystemInfo;
class TestEvent;
class ThreadDescriptor;
class TraceConfig;
class TracePacketDefaults;
class TraceStats;
class TrackDescriptor;
class TrackEvent;
class Trigger;

enum TracePacket_SequenceFlags : int32_t {
  TracePacket_SequenceFlags_SEQ_UNSPECIFIED = 0,
  TracePacket_SequenceFlags_SEQ_INCREMENTAL_STATE_CLEARED = 1,
  TracePacket_SequenceFlags_SEQ_NEEDS_INCREMENTAL_STATE = 2,
};

const TracePacket_SequenceFlags TracePacket_SequenceFlags_MIN = TracePacket_SequenceFlags_SEQ_UNSPECIFIED;
const TracePacket_SequenceFlags TracePacket_SequenceFlags_MAX = TracePacket_SequenceFlags_SEQ_NEEDS_INCREMENTAL_STATE;

class TracePacket_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/900, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TracePacket_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TracePacket_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TracePacket_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_timestamp() const { return at<8>().valid(); }
  uint64_t timestamp() const { return at<8>().as_uint64(); }
  bool has_timestamp_clock_id() const { return at<58>().valid(); }
  uint32_t timestamp_clock_id() const { return at<58>().as_uint32(); }
  bool has_ftrace_events() const { return at<1>().valid(); }
  ::protozero::ConstBytes ftrace_events() const { return at<1>().as_bytes(); }
  bool has_process_tree() const { return at<2>().valid(); }
  ::protozero::ConstBytes process_tree() const { return at<2>().as_bytes(); }
  bool has_process_stats() const { return at<9>().valid(); }
  ::protozero::ConstBytes process_stats() const { return at<9>().as_bytes(); }
  bool has_inode_file_map() const { return at<4>().valid(); }
  ::protozero::ConstBytes inode_file_map() const { return at<4>().as_bytes(); }
  bool has_chrome_events() const { return at<5>().valid(); }
  ::protozero::ConstBytes chrome_events() const { return at<5>().as_bytes(); }
  bool has_clock_snapshot() const { return at<6>().valid(); }
  ::protozero::ConstBytes clock_snapshot() const { return at<6>().as_bytes(); }
  bool has_sys_stats() const { return at<7>().valid(); }
  ::protozero::ConstBytes sys_stats() const { return at<7>().as_bytes(); }
  bool has_track_event() const { return at<11>().valid(); }
  ::protozero::ConstBytes track_event() const { return at<11>().as_bytes(); }
  bool has_trace_config() const { return at<33>().valid(); }
  ::protozero::ConstBytes trace_config() const { return at<33>().as_bytes(); }
  bool has_ftrace_stats() const { return at<34>().valid(); }
  ::protozero::ConstBytes ftrace_stats() const { return at<34>().as_bytes(); }
  bool has_trace_stats() const { return at<35>().valid(); }
  ::protozero::ConstBytes trace_stats() const { return at<35>().as_bytes(); }
  bool has_profile_packet() const { return at<37>().valid(); }
  ::protozero::ConstBytes profile_packet() const { return at<37>().as_bytes(); }
  bool has_battery() const { return at<38>().valid(); }
  ::protozero::ConstBytes battery() const { return at<38>().as_bytes(); }
  bool has_power_rails() const { return at<40>().valid(); }
  ::protozero::ConstBytes power_rails() const { return at<40>().as_bytes(); }
  bool has_android_log() const { return at<39>().valid(); }
  ::protozero::ConstBytes android_log() const { return at<39>().as_bytes(); }
  bool has_system_info() const { return at<45>().valid(); }
  ::protozero::ConstBytes system_info() const { return at<45>().as_bytes(); }
  bool has_trigger() const { return at<46>().valid(); }
  ::protozero::ConstBytes trigger() const { return at<46>().as_bytes(); }
  bool has_packages_list() const { return at<47>().valid(); }
  ::protozero::ConstBytes packages_list() const { return at<47>().as_bytes(); }
  bool has_chrome_benchmark_metadata() const { return at<48>().valid(); }
  ::protozero::ConstBytes chrome_benchmark_metadata() const { return at<48>().as_bytes(); }
  bool has_perfetto_metatrace() const { return at<49>().valid(); }
  ::protozero::ConstBytes perfetto_metatrace() const { return at<49>().as_bytes(); }
  bool has_chrome_metadata() const { return at<51>().valid(); }
  ::protozero::ConstBytes chrome_metadata() const { return at<51>().as_bytes(); }
  bool has_gpu_counter_event() const { return at<52>().valid(); }
  ::protozero::ConstBytes gpu_counter_event() const { return at<52>().as_bytes(); }
  bool has_gpu_render_stage_event() const { return at<53>().valid(); }
  ::protozero::ConstBytes gpu_render_stage_event() const { return at<53>().as_bytes(); }
  bool has_streaming_profile_packet() const { return at<54>().valid(); }
  ::protozero::ConstBytes streaming_profile_packet() const { return at<54>().as_bytes(); }
  bool has_heap_graph() const { return at<56>().valid(); }
  ::protozero::ConstBytes heap_graph() const { return at<56>().as_bytes(); }
  bool has_graphics_frame_event() const { return at<57>().valid(); }
  ::protozero::ConstBytes graphics_frame_event() const { return at<57>().as_bytes(); }
  bool has_profiled_frame_symbols() const { return at<55>().valid(); }
  ::protozero::ConstBytes profiled_frame_symbols() const { return at<55>().as_bytes(); }
  bool has_track_descriptor() const { return at<60>().valid(); }
  ::protozero::ConstBytes track_descriptor() const { return at<60>().as_bytes(); }
  bool has_process_descriptor() const { return at<43>().valid(); }
  ::protozero::ConstBytes process_descriptor() const { return at<43>().as_bytes(); }
  bool has_thread_descriptor() const { return at<44>().valid(); }
  ::protozero::ConstBytes thread_descriptor() const { return at<44>().as_bytes(); }
  bool has_synchronization_marker() const { return at<36>().valid(); }
  ::protozero::ConstBytes synchronization_marker() const { return at<36>().as_bytes(); }
  bool has_compressed_packets() const { return at<50>().valid(); }
  ::protozero::ConstBytes compressed_packets() const { return at<50>().as_bytes(); }
  bool has_for_testing() const { return at<900>().valid(); }
  ::protozero::ConstBytes for_testing() const { return at<900>().as_bytes(); }
  bool has_trusted_uid() const { return at<3>().valid(); }
  int32_t trusted_uid() const { return at<3>().as_int32(); }
  bool has_trusted_packet_sequence_id() const { return at<10>().valid(); }
  uint32_t trusted_packet_sequence_id() const { return at<10>().as_uint32(); }
  bool has_interned_data() const { return at<12>().valid(); }
  ::protozero::ConstBytes interned_data() const { return at<12>().as_bytes(); }
  bool has_appended_data() const { return at<61>().valid(); }
  ::protozero::ConstBytes appended_data() const { return at<61>().as_bytes(); }
  bool has_sequence_flags() const { return at<13>().valid(); }
  uint32_t sequence_flags() const { return at<13>().as_uint32(); }
  bool has_incremental_state_cleared() const { return at<41>().valid(); }
  bool incremental_state_cleared() const { return at<41>().as_bool(); }
  bool has_trace_packet_defaults() const { return at<59>().valid(); }
  ::protozero::ConstBytes trace_packet_defaults() const { return at<59>().as_bytes(); }
  bool has_previous_packet_dropped() const { return at<42>().valid(); }
  bool previous_packet_dropped() const { return at<42>().as_bool(); }
};

class TracePacket : public ::protozero::Message {
 public:
  using Decoder = TracePacket_Decoder;
  enum : int32_t {
    kTimestampFieldNumber = 8,
    kTimestampClockIdFieldNumber = 58,
    kFtraceEventsFieldNumber = 1,
    kProcessTreeFieldNumber = 2,
    kProcessStatsFieldNumber = 9,
    kInodeFileMapFieldNumber = 4,
    kChromeEventsFieldNumber = 5,
    kClockSnapshotFieldNumber = 6,
    kSysStatsFieldNumber = 7,
    kTrackEventFieldNumber = 11,
    kTraceConfigFieldNumber = 33,
    kFtraceStatsFieldNumber = 34,
    kTraceStatsFieldNumber = 35,
    kProfilePacketFieldNumber = 37,
    kBatteryFieldNumber = 38,
    kPowerRailsFieldNumber = 40,
    kAndroidLogFieldNumber = 39,
    kSystemInfoFieldNumber = 45,
    kTriggerFieldNumber = 46,
    kPackagesListFieldNumber = 47,
    kChromeBenchmarkMetadataFieldNumber = 48,
    kPerfettoMetatraceFieldNumber = 49,
    kChromeMetadataFieldNumber = 51,
    kGpuCounterEventFieldNumber = 52,
    kGpuRenderStageEventFieldNumber = 53,
    kStreamingProfilePacketFieldNumber = 54,
    kHeapGraphFieldNumber = 56,
    kGraphicsFrameEventFieldNumber = 57,
    kProfiledFrameSymbolsFieldNumber = 55,
    kTrackDescriptorFieldNumber = 60,
    kProcessDescriptorFieldNumber = 43,
    kThreadDescriptorFieldNumber = 44,
    kSynchronizationMarkerFieldNumber = 36,
    kCompressedPacketsFieldNumber = 50,
    kForTestingFieldNumber = 900,
    kTrustedUidFieldNumber = 3,
    kTrustedPacketSequenceIdFieldNumber = 10,
    kInternedDataFieldNumber = 12,
    kAppendedDataFieldNumber = 61,
    kSequenceFlagsFieldNumber = 13,
    kIncrementalStateClearedFieldNumber = 41,
    kTracePacketDefaultsFieldNumber = 59,
    kPreviousPacketDroppedFieldNumber = 42,
  };
  using SequenceFlags = ::perfetto::protos::pbzero::TracePacket_SequenceFlags;
  static const SequenceFlags SEQ_UNSPECIFIED = TracePacket_SequenceFlags_SEQ_UNSPECIFIED;
  static const SequenceFlags SEQ_INCREMENTAL_STATE_CLEARED = TracePacket_SequenceFlags_SEQ_INCREMENTAL_STATE_CLEARED;
  static const SequenceFlags SEQ_NEEDS_INCREMENTAL_STATE = TracePacket_SequenceFlags_SEQ_NEEDS_INCREMENTAL_STATE;
  void set_timestamp(uint64_t value) {
    AppendVarInt(8, value);
  }
  void set_timestamp_clock_id(uint32_t value) {
    AppendVarInt(58, value);
  }
  template <typename T = FtraceEventBundle> T* set_ftrace_events() {
    return BeginNestedMessage<T>(1);
  }

  template <typename T = ProcessTree> T* set_process_tree() {
    return BeginNestedMessage<T>(2);
  }

  template <typename T = ProcessStats> T* set_process_stats() {
    return BeginNestedMessage<T>(9);
  }

  template <typename T = InodeFileMap> T* set_inode_file_map() {
    return BeginNestedMessage<T>(4);
  }

  template <typename T = ChromeEventBundle> T* set_chrome_events() {
    return BeginNestedMessage<T>(5);
  }

  template <typename T = ClockSnapshot> T* set_clock_snapshot() {
    return BeginNestedMessage<T>(6);
  }

  template <typename T = SysStats> T* set_sys_stats() {
    return BeginNestedMessage<T>(7);
  }

  template <typename T = TrackEvent> T* set_track_event() {
    return BeginNestedMessage<T>(11);
  }

  template <typename T = TraceConfig> T* set_trace_config() {
    return BeginNestedMessage<T>(33);
  }

  template <typename T = FtraceStats> T* set_ftrace_stats() {
    return BeginNestedMessage<T>(34);
  }

  template <typename T = TraceStats> T* set_trace_stats() {
    return BeginNestedMessage<T>(35);
  }

  template <typename T = ProfilePacket> T* set_profile_packet() {
    return BeginNestedMessage<T>(37);
  }

  template <typename T = BatteryCounters> T* set_battery() {
    return BeginNestedMessage<T>(38);
  }

  template <typename T = PowerRails> T* set_power_rails() {
    return BeginNestedMessage<T>(40);
  }

  template <typename T = AndroidLogPacket> T* set_android_log() {
    return BeginNestedMessage<T>(39);
  }

  template <typename T = SystemInfo> T* set_system_info() {
    return BeginNestedMessage<T>(45);
  }

  template <typename T = Trigger> T* set_trigger() {
    return BeginNestedMessage<T>(46);
  }

  template <typename T = PackagesList> T* set_packages_list() {
    return BeginNestedMessage<T>(47);
  }

  template <typename T = ChromeBenchmarkMetadata> T* set_chrome_benchmark_metadata() {
    return BeginNestedMessage<T>(48);
  }

  template <typename T = PerfettoMetatrace> T* set_perfetto_metatrace() {
    return BeginNestedMessage<T>(49);
  }

  template <typename T = ChromeMetadataPacket> T* set_chrome_metadata() {
    return BeginNestedMessage<T>(51);
  }

  template <typename T = GpuCounterEvent> T* set_gpu_counter_event() {
    return BeginNestedMessage<T>(52);
  }

  template <typename T = GpuRenderStageEvent> T* set_gpu_render_stage_event() {
    return BeginNestedMessage<T>(53);
  }

  template <typename T = StreamingProfilePacket> T* set_streaming_profile_packet() {
    return BeginNestedMessage<T>(54);
  }

  template <typename T = HeapGraph> T* set_heap_graph() {
    return BeginNestedMessage<T>(56);
  }

  template <typename T = GraphicsFrameEvent> T* set_graphics_frame_event() {
    return BeginNestedMessage<T>(57);
  }

  template <typename T = ProfiledFrameSymbols> T* set_profiled_frame_symbols() {
    return BeginNestedMessage<T>(55);
  }

  template <typename T = TrackDescriptor> T* set_track_descriptor() {
    return BeginNestedMessage<T>(60);
  }

  template <typename T = ProcessDescriptor> T* set_process_descriptor() {
    return BeginNestedMessage<T>(43);
  }

  template <typename T = ThreadDescriptor> T* set_thread_descriptor() {
    return BeginNestedMessage<T>(44);
  }

  void set_synchronization_marker(const uint8_t* data, size_t size) {
    AppendBytes(36, data, size);
  }
  void set_compressed_packets(const uint8_t* data, size_t size) {
    AppendBytes(50, data, size);
  }
  template <typename T = TestEvent> T* set_for_testing() {
    return BeginNestedMessage<T>(900);
  }

  void set_trusted_uid(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_trusted_packet_sequence_id(uint32_t value) {
    AppendVarInt(10, value);
  }
  template <typename T = InternedData> T* set_interned_data() {
    return BeginNestedMessage<T>(12);
  }

  template <typename T = AppendedData> T* set_appended_data() {
    return BeginNestedMessage<T>(61);
  }

  void set_sequence_flags(uint32_t value) {
    AppendVarInt(13, value);
  }
  void set_incremental_state_cleared(bool value) {
    AppendTinyVarInt(41, value);
  }
  template <typename T = TracePacketDefaults> T* set_trace_packet_defaults() {
    return BeginNestedMessage<T>(59);
  }

  void set_previous_packet_dropped(bool value) {
    AppendTinyVarInt(42, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_TRACING_DATA_SOURCE_H_
#define INCLUDE_PERFETTO_TRACING_DATA_SOURCE_H_

// This header contains the key class (DataSource) that a producer app should
// override in order to create a custom data source that gets tracing Start/Stop
// notifications and emits tracing data.

#include <assert.h>
#include <stddef.h>
#include <stdint.h>

#include <array>
#include <atomic>
#include <functional>
#include <memory>
#include <mutex>

// gen_amalgamated expanded: #include "perfetto/base/compiler.h"
// gen_amalgamated expanded: #include "perfetto/base/export.h"
// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/message_handle.h"
// gen_amalgamated expanded: #include "perfetto/tracing/internal/basic_types.h"
// gen_amalgamated expanded: #include "perfetto/tracing/internal/data_source_internal.h"
// gen_amalgamated expanded: #include "perfetto/tracing/internal/tracing_muxer.h"
// gen_amalgamated expanded: #include "perfetto/tracing/locked_handle.h"
// gen_amalgamated expanded: #include "perfetto/tracing/trace_writer_base.h"
// gen_amalgamated expanded: #include "protos/perfetto/trace/trace_packet.pbzero.h"

namespace perfetto {

class DataSourceConfig;

// Base class with the virtual methods to get start/stop notifications.
// Embedders are supposed to derive the templated version below, not this one.
class PERFETTO_EXPORT DataSourceBase {
 public:
  virtual ~DataSourceBase();

  // TODO(primiano): change the const& args below to be pointers instead. It
  // makes it more awkward to handle output arguments and require mutable(s).
  // This requires synchronizing a breaking API change for existing embedders.

  // OnSetup() is invoked when tracing is configured. In most cases this happens
  // just before starting the trace. In the case of deferred start (see
  // deferred_start in trace_config.proto) start might happen later.
  class SetupArgs {
   public:
    // This is valid only within the scope of the OnSetup() call and must not
    // be retained.
    const DataSourceConfig* config = nullptr;
  };
  virtual void OnSetup(const SetupArgs&);

  class StartArgs {};
  virtual void OnStart(const StartArgs&);

  class StopArgs {
   public:
    virtual ~StopArgs();

    // HandleAsynchronously() can optionally be called to defer the tracing
    // session stop and write tracing data just before stopping.
    // This function returns a closure that must be invoked after the last
    // trace events have been emitted. The returned closure can be called from
    // any thread. The caller also needs to explicitly call TraceContext.Flush()
    // from the last Trace() lambda invocation because no other implicit flushes
    // will happen after the stop signal.
    // When this function is called, the tracing service will defer the stop of
    // the tracing session until the returned closure is invoked.
    // However, the caller cannot hang onto this closure for too long. The
    // tracing service will forcefully stop the tracing session without waiting
    // for pending producers after TraceConfig.data_source_stop_timeout_ms
    // (default: 5s, can be overridden by Consumers when starting a trace).
    // If the closure is called after this timeout an error will be logged and
    // the trace data emitted will not be present in the trace. No other
    // functional side effects (e.g. crashes or corruptions) will happen. In
    // other words, it is fine to accidentally hold onto this closure for too
    // long but, if that happens, some tracing data will be lost.
    virtual std::function<void()> HandleStopAsynchronously() const = 0;
  };
  virtual void OnStop(const StopArgs&);
};

// Templated base class meant to be derived by embedders to create a custom data
// source. DataSourceType must be the type of the derived class itself, e.g.:
// class MyDataSource : public DataSourceBase<MyDataSource> {...}.
//
// |IncrementalStateType| can optionally be used store custom per-sequence
// incremental data (e.g., interning tables). It should have a Clear() method
// for when incremental state needs to be cleared. See
// TraceContext::GetIncrementalState().
template <typename DataSourceType, typename IncrementalStateType = void>
class DataSource : public DataSourceBase {
 public:
  // Argument passed to the lambda function passed to Trace() (below).
  class TraceContext {
   public:
    using TracePacketHandle =
        ::protozero::MessageHandle<::perfetto::protos::pbzero::TracePacket>;

    TraceContext(TraceContext&&) noexcept = default;
    ~TraceContext() = default;

    TracePacketHandle NewTracePacket() {
      return tls_inst_->trace_writer->NewTracePacket();
    }

    // Forces a commit of the thread-local tracing data written so far to the
    // service. This is almost never required (tracing data is periodically
    // committed as trace pages are filled up) and has a non-negligible
    // performance hit (requires an IPC + refresh of the current thread-local
    // chunk). The only case when this should be used is when handling OnStop()
    // asynchronously, to ensure sure that the data is committed before the
    // Stop timeout expires.
    // The TracePacketHandle obtained by the last NewTracePacket() call must be
    // finalized before calling Flush() (either implicitly by going out of scope
    // or by explicitly calling Finalize()).
    // |cb| is an optional callback. When non-null it will request the
    // service to ACK the flush and will be invoked on an internal thread after
    // the service has  acknowledged it. The callback might be NEVER INVOKED if
    // the service crashes or the IPC connection is dropped.
    void Flush(std::function<void()> cb = {}) {
      tls_inst_->trace_writer->Flush(cb);
    }

    // Returns a RAII handle to access the data source instance, guaranteeing
    // that it won't be deleted on another thread (because of trace stopping)
    // while accessing it from within the Trace() lambda.
    // The returned handle can be invalid (nullptr) if tracing is stopped
    // immediately before calling this. The caller is supposed to check for its
    // validity before using it. After checking, the handle is guaranteed to
    // remain valid until the handle goes out of scope.
    LockedHandle<DataSourceType> GetDataSourceLocked() {
      auto* internal_state = static_state_.TryGet(instance_index_);
      if (!internal_state)
        return LockedHandle<DataSourceType>();
      return LockedHandle<DataSourceType>(
          &internal_state->lock,
          static_cast<DataSourceType*>(internal_state->data_source.get()));
    }

    IncrementalStateType* GetIncrementalState() {
      return reinterpret_cast<IncrementalStateType*>(
          tls_inst_->incremental_state.get());
    }

   private:
    friend class DataSource;
    TraceContext(internal::DataSourceInstanceThreadLocalState* tls_inst,
                 uint32_t instance_index)
        : tls_inst_(tls_inst), instance_index_(instance_index) {}
    TraceContext(const TraceContext&) = delete;
    TraceContext& operator=(const TraceContext&) = delete;

    internal::DataSourceInstanceThreadLocalState* const tls_inst_;
    uint32_t const instance_index_;
  };

  // The main tracing method. Tracing code should call this passing a lambda as
  // argument, with the following signature: void(TraceContext).
  // The lambda will be called synchronously (i.e., always before Trace()
  // returns) only if tracing is enabled and the data source has been enabled in
  // the tracing config.
  // The lambda can be called more than once per Trace() call, in the case of
  // concurrent tracing sessions (or even if the data source is instantiated
  // twice within the same trace config).
  template <typename Lambda>
  static void Trace(Lambda tracing_fn) {
    constexpr auto kMaxDataSourceInstances = internal::kMaxDataSourceInstances;

    // |instances| is a per-class bitmap that tells:
    // 1. If the data source is enabled at all.
    // 2. The index of the slot within |valid_instances| that holds the instance
    //    state. In turn this allows to map the data source to the tracing
    //    session and buffers.
    // memory_order_relaxed is okay because:
    // - |instances| is re-read with an acquire barrier below if this succeeds.
    // - The code between this point and the acquire-load is based on static
    //    storage which has indefinite lifetime.
    auto instances =
        static_state_.valid_instances.load(std::memory_order_relaxed);

    // This is the tracing fast-path. Bail out immediately if tracing is not
    // enabled (or tracing is enabled but not for this data source).
    if (PERFETTO_LIKELY(!instances))
      return;

    // TODO(primiano): all the stuff below should be outlined. Or at least
    // we should have some compile-time traits like kOptimizeBinarySize /
    // kOptimizeTracingLatency.

    // See tracing_muxer.h for the structure of the TLS.
    auto* tracing_impl = internal::TracingMuxer::Get();
    if (PERFETTO_UNLIKELY(!tls_state_))
      tls_state_ = tracing_impl->GetOrCreateDataSourceTLS(&static_state_);

    // TracingTLS::generation is a global monotonic counter that is incremented
    // every time a tracing session is stopped. We use that as a signal to force
    // a slow-path garbage collection of all the trace writers for the current
    // thread and to destroy the ones that belong to tracing sessions that have
    // ended. This is to avoid having too many TraceWriter instances alive, each
    // holding onto one chunk of the shared memory buffer.
    // Rationale why memory_order_relaxed should be fine:
    // - The TraceWriter object that we use is always constructed and destructed
    //   on the current thread. There is no risk of accessing a half-initialized
    //   TraceWriter (which would be really bad).
    // - In the worst case, in the case of a race on the generation check, we
    //   might end up using a TraceWriter for the same data source that belongs
    //   to a stopped session. This is not really wrong, as we don't give any
    //   guarantee on the global atomicity of the stop. In the worst case the
    //   service will reject the data commit if this arrives too late.

    if (PERFETTO_UNLIKELY(
            tls_state_->root_tls->generation !=
            tracing_impl->generation(std::memory_order_relaxed))) {
      // Will update root_tls->generation.
      tracing_impl->DestroyStoppedTraceWritersForCurrentThread();
    }

    for (uint32_t i = 0; i < kMaxDataSourceInstances; i++) {
      internal::DataSourceState* instance_state =
          static_state_.TryGetCached(instances, i);
      if (!instance_state)
        continue;

      // Even if we passed the check above, the DataSourceInstance might be
      // still destroyed concurrently while this code runs. The code below is
      // designed to deal with such race, as follows:
      // - We don't access the user-defined data source instance state. The only
      //   bits of state we use are |backend_id| and |buffer_id|.
      // - Beyond those two integers, we access only the TraceWriter here. The
      //   TraceWriter is always safe because it lives on the TLS.
      // - |instance_state| is backed by static storage, so the pointer is
      //   always valid, even after the data source instance is destroyed.
      // - In the case of a race-on-destruction, we'll still see the latest
      //   backend_id and buffer_id and in the worst case keep trying writing
      //   into the tracing shared memory buffer after stopped. But this isn't
      //   really any worse than the case of the stop IPC being delayed by the
      //   kernel scheduler. The tracing service is robust against data commit
      //   attemps made after tracing is stopped.
      // There is a theoretical race that would case the wrong behavior w.r.t
      // writing data in the wrong buffer, but it's so rare that we ignore it:
      // if the data source is stopped and started kMaxDataSourceInstances
      // times (so that the same id is recycled) while we are in this function,
      // we might end up reusing the old data source's backend_id and buffer_id
      // for the new one, because we don't see the generation change past this
      // point. But stopping and starting tracing (even once) takes so much
      // handshaking to make this extremely unrealistic.

      auto& tls_inst = tls_state_->per_instance[i];
      if (PERFETTO_UNLIKELY(!tls_inst.trace_writer)) {
        // Here we need an acquire barrier, which matches the release-store made
        // by TracingMuxerImpl::SetupDataSource(), to ensure that the backend_id
        // and buffer_id are consistent.
        instances =
            static_state_.valid_instances.load(std::memory_order_acquire);
        instance_state = static_state_.TryGetCached(instances, i);
        if (!instance_state || !instance_state->trace_lambda_enabled)
          return;
        tls_inst.backend_id = instance_state->backend_id;
        tls_inst.buffer_id = instance_state->buffer_id;
        tls_inst.trace_writer = tracing_impl->CreateTraceWriter(instance_state);
        CreateIncrementalState(&tls_inst,
                               static_cast<IncrementalStateType*>(nullptr));

        // Even in the case of out-of-IDs, SharedMemoryArbiterImpl returns a
        // NullTraceWriter. The returned pointer should never be null.
        assert(tls_inst.trace_writer);
      }

      tracing_fn(TraceContext(&tls_inst, i));
    }
  }

  // Registers the data source on all tracing backends, including ones that
  // connect after the registration. Doing so enables the data source to receive
  // Setup/Start/Stop notifications and makes the Trace() method work when
  // tracing is enabled and the data source is selected.
  // This must be called after Tracing::Initialize().
  // The caller must also use the DEFINE_DATA_SOURCE_STATIC_MEMBERS() macro
  // documented below.
  // Can return false to signal failure if attemping to register more than
  // kMaxDataSources (32) data sources types.
  static bool Register(const DataSourceDescriptor& descriptor) {
    // Silences -Wunused-variable warning in case the trace method is not used
    // by the translation unit that declares the data source.
    (void)static_state_;
    (void)tls_state_;

    auto factory = [] {
      return std::unique_ptr<DataSourceBase>(new DataSourceType());
    };
    auto* tracing_impl = internal::TracingMuxer::Get();
    return tracing_impl->RegisterDataSource(descriptor, factory,
                                            &static_state_);
  }

 private:
  // Create the user provided incremental state in the given thread-local
  // storage. Note: The second parameter here is used to specialize the case
  // where there is no incremental state type.
  template <typename T>
  static void CreateIncrementalState(
      internal::DataSourceInstanceThreadLocalState* tls_inst,
      const T*) {
    PERFETTO_DCHECK(!tls_inst->incremental_state);
    tls_inst->incremental_state =
        internal::DataSourceInstanceThreadLocalState::IncrementalStatePointer(
            reinterpret_cast<void*>(new T()),
            [](void* p) { delete reinterpret_cast<T*>(p); });
  }
  static void CreateIncrementalState(
      internal::DataSourceInstanceThreadLocalState*,
      const void*) {}

  // Static state. Accessed by the static Trace() method fastpaths.
  static internal::DataSourceStaticState static_state_;

  // This TLS object is a cached raw pointer and has deliberately no destructor.
  // The Platform implementation is supposed to create and manage the lifetime
  // of the Platform::ThreadLocalObject and take care of destroying it.
  // This is because non-POD thread_local variables have subtleties (global
  // destructors) that we need to defer to the embedder. In chromium's platform
  // implementation, for instance, the tls slot is implemented using
  // chromium's base::ThreadLocalStorage.
  static thread_local internal::DataSourceThreadLocalState* tls_state_;
};

}  // namespace perfetto

// If a data source is used across translation units, this declaration must be
// placed into the header file defining the data source.
#define PERFETTO_DECLARE_DATA_SOURCE_STATIC_MEMBERS(...)       \
  template <>                                                  \
  perfetto::internal::DataSourceStaticState                    \
      perfetto::DataSource<__VA_ARGS__>::static_state_;        \
  template <>                                                  \
  thread_local perfetto::internal::DataSourceThreadLocalState* \
      perfetto::DataSource<__VA_ARGS__>::tls_state_

// The API client must use this in a translation unit. This is because it needs
// to instantiate the static storage for the datasource to allow the fastpath
// enabled check.
#define PERFETTO_DEFINE_DATA_SOURCE_STATIC_MEMBERS(...)        \
  template <>                                                  \
  perfetto::internal::DataSourceStaticState                    \
      perfetto::DataSource<__VA_ARGS__>::static_state_{};      \
  template <>                                                  \
  thread_local perfetto::internal::DataSourceThreadLocalState* \
      perfetto::DataSource<__VA_ARGS__>::tls_state_ = nullptr

#endif  // INCLUDE_PERFETTO_TRACING_DATA_SOURCE_H_
// gen_amalgamated begin header: include/perfetto/tracing/tracing.h
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_TRACING_TRACING_H_
#define INCLUDE_PERFETTO_TRACING_TRACING_H_

#include <stddef.h>
#include <stdint.h>

#include <functional>
#include <memory>
#include <string>
#include <vector>

// gen_amalgamated expanded: #include "perfetto/base/export.h"
// gen_amalgamated expanded: #include "perfetto/base/logging.h"

namespace perfetto {

class TracingBackend;
class Platform;
class TraceConfig;
class TracingSession;  // Declared below.

enum BackendType : uint32_t {
  kUnspecifiedBackend = 0,

  // Connects to a previously-initialized perfetto tracing backend for
  // in-process. If the in-process backend has not been previously initialized
  // it will do so and create the tracing service on a dedicated thread.
  kInProcessBackend = 1 << 0,

  // Connects to the system tracing service (e.g. on Linux/Android/Mac uses a
  // named UNIX socket).
  kSystemBackend = 1 << 1,

  // Used to provide a custom IPC transport to connect to the service.
  // TracingInitArgs::custom_backend must be non-null and point to an
  // indefinitely lived instance.
  kCustomBackend = 1 << 2,
};

struct TracingInitArgs {
  uint32_t backends = 0;                     // One or more BackendFlags.
  TracingBackend* custom_backend = nullptr;  // [Optional].

  // [Optional] Platform implementation. It allows the embedder to take control
  // of platform-specific bits like thread creation and TLS slot handling. If
  // not set it will use Platform::GetDefaultPlatform().
  Platform* platform = nullptr;

  // [Optional] Tune the size of the shared memory buffer between the current
  // process and the service backend(s). This is a trade-off between memory
  // footprint and the ability to sustain bursts of trace writes (see comments
  // in shared_memory_abi.h).
  // If set, the value must be a multiple of 4KB. The value can be ignored if
  // larger than kMaxShmSize (32MB) or not a multiple of 4KB.
  uint32_t shmem_size_hint_kb = 0;

  // [Optional] Specifies the preferred size of each page in the shmem buffer.
  // This is a trade-off between IPC overhead and fragmentation/efficiency of
  // the shmem buffer in presence of multiple writer threads.
  // Must be one of [4, 8, 16, 32].
  uint32_t shmem_page_size_hint_kb = 0;

 protected:
  friend class Tracing;
  bool dcheck_is_on_ = PERFETTO_DCHECK_IS_ON();
};

// The entry-point for using perfetto.
class PERFETTO_EXPORT Tracing {
 public:
  // Initializes Perfetto with the given backends in the calling process and/or
  // with a user-provided backend. Can only be called once.
  static void Initialize(const TracingInitArgs&);

  // Start a new tracing session using the given tracing backend. Use
  // |kUnspecifiedBackend| to select an available backend automatically.
  // For the moment this can be used only when initializing tracing in
  // kInProcess mode. For the system mode use the 'bin/perfetto' cmdline client.
  static std::unique_ptr<TracingSession> NewTrace(
      BackendType = kUnspecifiedBackend);

 private:
  Tracing() = delete;
};

class PERFETTO_EXPORT TracingSession {
 public:
  virtual ~TracingSession();

  // Configure the session passing the trace config.
  // If a writable file handle is given through |fd|, the trace will
  // automatically written to that file. Otherwise you should call ReadTrace()
  // to retrieve the trace data. This call does not take ownership of |fd|.
  // TODO(primiano): add an error callback.
  virtual void Setup(const TraceConfig&, int fd = -1) = 0;

  // Enable tracing asynchronously.
  virtual void Start() = 0;

  // Enable tracing and block until tracing has started. Note that if data
  // sources are registered after this call was initiated, the call may return
  // before the additional data sources have started. Also, if other producers
  // (e.g., with system-wide tracing) have registered data sources without start
  // notification support, this call may return before those data sources have
  // started.
  virtual void StartBlocking() = 0;

  // Disable tracing asynchronously.
  // Use SetOnStopCallback() to get a notification when the tracing session is
  // fully stopped and all data sources have acked.
  virtual void Stop() = 0;

  // Disable tracing and block until tracing has stopped.
  virtual void StopBlocking() = 0;

  // This callback will be invoked when tracing is disabled.
  // This can happen either when explicitly calling TracingSession.Stop() or
  // when the trace reaches its |duration_ms| time limit.
  // This callback will be invoked on an internal perfetto thread.
  virtual void SetOnStopCallback(std::function<void()>) = 0;

  // Struct passed as argument to the callback passed to ReadTrace().
  // [data, size] is guaranteed to contain 1 or more full trace packets, which
  // can be decoded using trace.proto. No partial or truncated packets are
  // exposed. If the trace is empty this returns a zero-sized nullptr with
  // |has_more| == true to signal EOF.
  // This callback will be invoked on an internal perfetto thread.
  struct ReadTraceCallbackArgs {
    const char* data = nullptr;
    size_t size = 0;

    // When false, this will be the last invocation of the callback for this
    // read cycle.
    bool has_more = false;
  };

  // Reads back the trace data (raw protobuf-encoded bytes) asynchronously.
  // Can be called at any point during the trace, typically but not necessarily,
  // after stopping. Reading the trace data is a destructive operation w.r.t.
  // contents of the trace buffer and is not idempotent.
  // A single ReadTrace() call can yield >1 callback invocations, until
  // |has_more| is true.
  using ReadTraceCallback = std::function<void(ReadTraceCallbackArgs)>;
  virtual void ReadTrace(ReadTraceCallback) = 0;

  // Synchronous version of ReadTrace(). It blocks the calling thread until all
  // the trace contents are read. This is slow and inefficient (involves more
  // copies) and is mainly intended for testing.
  std::vector<char> ReadTraceBlocking();
};

}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_TRACING_TRACING_H_
// gen_amalgamated begin header: include/perfetto/tracing/tracing_backend.h
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_TRACING_TRACING_BACKEND_H_
#define INCLUDE_PERFETTO_TRACING_TRACING_BACKEND_H_

#include <memory>
#include <string>

// The embedder can (but doesn't have to) extend the TracingBackend class and
// pass as an argument to Tracing::Initialize(kCustomBackend) to override the
// way to reach the service. This is for peculiar cases where the embedder has
// a multi-process architecture and wants to override the IPC transport. The
// real use-case for this at the time of writing is chromium (+ Mojo IPC).
// Extending this class requires depending on the full set of perfetto headers
// (not just /public/). Contact the team before doing so as the non-public
// headers are not guaranteed to be API stable.

namespace perfetto {

namespace base {
class TaskRunner;
}

// These classes are declared in headers outside of /public/.
class Consumer;
class ConsumerEndpoint;
class Producer;
class ProducerEndpoint;

class TracingBackend {
 public:
  virtual ~TracingBackend();

  // Connects a Producer instance and obtains a ProducerEndpoint, which is
  // essentially a 1:1 channel between one Producer and the Service.
  // To disconnect just destroy the returned endpoint object. It is safe to
  // destroy the Producer once Producer::OnDisconnect() has been invoked.
  struct ConnectProducerArgs {
    std::string producer_name;

    // The Producer object that will receive calls like Start/StopDataSource().
    // The caller has to guarantee that this object is valid as long as the
    // returned ProducerEndpoint is alive.
    Producer* producer = nullptr;

    // The task runner where the Producer methods will be called onto.
    // The caller has to guarantee that the passed TaskRunner is valid as long
    // as the returned ProducerEndpoint is alive.
    ::perfetto::base::TaskRunner* task_runner = nullptr;

    // These get propagated from TracingInitArgs and are optionally provided by
    // the client when calling Tracing::Initialize().
    uint32_t shmem_size_hint_bytes = 0;
    uint32_t shmem_page_size_hint_bytes = 0;
  };

  virtual std::unique_ptr<ProducerEndpoint> ConnectProducer(
      const ConnectProducerArgs&) = 0;

  // As above, for the Consumer-side.
  struct ConnectConsumerArgs {
    // The Consumer object that will receive calls like OnTracingDisabled(),
    // OnTraceData().
    Consumer* consumer{};

    // The task runner where the Consumer methods will be called onto.
    ::perfetto::base::TaskRunner* task_runner{};
  };
  virtual std::unique_ptr<ConsumerEndpoint> ConnectConsumer(
      const ConnectConsumerArgs&) = 0;
};

}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_TRACING_TRACING_BACKEND_H_
// gen_amalgamated begin header: include/perfetto/tracing/track_event.h
// gen_amalgamated begin header: include/perfetto/base/time.h
/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_BASE_TIME_H_
#define INCLUDE_PERFETTO_BASE_TIME_H_

#include <time.h>

#include <chrono>

// gen_amalgamated expanded: #include "perfetto/base/build_config.h"
// gen_amalgamated expanded: #include "perfetto/base/logging.h"

#if PERFETTO_BUILDFLAG(PERFETTO_OS_MACOSX)
#include <mach/mach_init.h>
#include <mach/mach_port.h>
#include <mach/mach_time.h>
#include <mach/thread_act.h>
#endif

#if PERFETTO_BUILDFLAG(PERFETTO_OS_WASM)
#include <emscripten/emscripten.h>
#endif

namespace perfetto {
namespace base {

using TimeSeconds = std::chrono::seconds;
using TimeMillis = std::chrono::milliseconds;
using TimeNanos = std::chrono::nanoseconds;

inline TimeNanos FromPosixTimespec(const struct timespec& ts) {
  return TimeNanos(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

void SleepMicroseconds(unsigned interval_us);

#if PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)

TimeNanos GetWallTimeNs();
TimeNanos GetThreadCPUTimeNs();

// TODO: Clock that counts time during suspend is not implemented on Windows.
inline TimeNanos GetBootTimeNs() {
  return GetWallTimeNs();
}

#elif PERFETTO_BUILDFLAG(PERFETTO_OS_MACOSX)

inline TimeNanos GetWallTimeNs() {
  auto init_time_factor = []() -> uint64_t {
    mach_timebase_info_data_t timebase_info;
    mach_timebase_info(&timebase_info);
    return timebase_info.numer / timebase_info.denom;
  };

  static uint64_t monotonic_timebase_factor = init_time_factor();
  return TimeNanos(mach_absolute_time() * monotonic_timebase_factor);
}

// TODO: Clock that counts time during suspend is not implemented on Mac.
inline TimeNanos GetBootTimeNs() {
  return GetWallTimeNs();
}

inline TimeNanos GetThreadCPUTimeNs() {
  mach_port_t this_thread = mach_thread_self();
  mach_msg_type_number_t count = THREAD_BASIC_INFO_COUNT;
  thread_basic_info_data_t info{};
  kern_return_t kr =
      thread_info(this_thread, THREAD_BASIC_INFO,
                  reinterpret_cast<thread_info_t>(&info), &count);
  mach_port_deallocate(mach_task_self(), this_thread);

  if (kr != KERN_SUCCESS) {
    PERFETTO_DFATAL("Failed to get CPU time.");
    return TimeNanos(0);
  }
  return TimeNanos(info.user_time.seconds * 1000000000LL +
                   info.user_time.microseconds * 1000LL +
                   info.system_time.seconds * 1000000000LL +
                   info.system_time.microseconds * 1000LL);
}

#elif PERFETTO_BUILDFLAG(PERFETTO_OS_WASM)

inline TimeNanos GetWallTimeNs() {
  return TimeNanos(static_cast<uint64_t>(emscripten_get_now()) * 1000000);
}

inline TimeNanos GetThreadCPUTimeNs() {
  return TimeNanos(0);
}

// TODO: Clock that counts time during suspend is not implemented on WASM.
inline TimeNanos GetBootTimeNs() {
  return GetWallTimeNs();
}

#else

constexpr clockid_t kWallTimeClockSource = CLOCK_MONOTONIC;

inline TimeNanos GetTimeInternalNs(clockid_t clk_id) {
  struct timespec ts = {};
  PERFETTO_CHECK(clock_gettime(clk_id, &ts) == 0);
  return FromPosixTimespec(ts);
}

// Return ns from boot. Conversely to GetWallTimeNs, this clock counts also time
// during suspend (when supported).
inline TimeNanos GetBootTimeNs() {
  // Determine if CLOCK_BOOTTIME is available on the first call.
  static const clockid_t kBootTimeClockSource = [] {
    struct timespec ts = {};
    int res = clock_gettime(CLOCK_BOOTTIME, &ts);
    return res == 0 ? CLOCK_BOOTTIME : kWallTimeClockSource;
  }();
  return GetTimeInternalNs(kBootTimeClockSource);
}

inline TimeNanos GetWallTimeNs() {
  return GetTimeInternalNs(kWallTimeClockSource);
}

inline TimeNanos GetThreadCPUTimeNs() {
  return GetTimeInternalNs(CLOCK_THREAD_CPUTIME_ID);
}

#endif

inline TimeMillis GetWallTimeMs() {
  return std::chrono::duration_cast<TimeMillis>(GetWallTimeNs());
}

inline TimeSeconds GetWallTimeS() {
  return std::chrono::duration_cast<TimeSeconds>(GetWallTimeNs());
}

inline struct timespec ToPosixTimespec(TimeMillis time) {
  struct timespec ts {};
  const long time_s = static_cast<long>(time.count() / 1000);
  ts.tv_sec = time_s;
  ts.tv_nsec = (static_cast<long>(time.count()) - time_s * 1000L) * 1000000L;
  return ts;
}

}  // namespace base
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_BASE_TIME_H_
// gen_amalgamated begin header: include/perfetto/tracing/internal/track_event_data_source.h
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/track_event/track_event.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACK_EVENT_TRACK_EVENT_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACK_EVENT_TRACK_EVENT_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class DebugAnnotation;
class LogMessage;
class TaskExecution;
class TrackEvent_LegacyEvent;
enum TrackEvent_LegacyEvent_FlowDirection : int32_t;
enum TrackEvent_LegacyEvent_InstantEventScope : int32_t;
enum TrackEvent_Type : int32_t;

enum TrackEvent_Type : int32_t {
  TrackEvent_Type_TYPE_UNSPECIFIED = 0,
  TrackEvent_Type_TYPE_SLICE_BEGIN = 1,
  TrackEvent_Type_TYPE_SLICE_END = 2,
  TrackEvent_Type_TYPE_INSTANT = 3,
};

const TrackEvent_Type TrackEvent_Type_MIN = TrackEvent_Type_TYPE_UNSPECIFIED;
const TrackEvent_Type TrackEvent_Type_MAX = TrackEvent_Type_TYPE_INSTANT;

enum TrackEvent_LegacyEvent_FlowDirection : int32_t {
  TrackEvent_LegacyEvent_FlowDirection_FLOW_UNSPECIFIED = 0,
  TrackEvent_LegacyEvent_FlowDirection_FLOW_IN = 1,
  TrackEvent_LegacyEvent_FlowDirection_FLOW_OUT = 2,
  TrackEvent_LegacyEvent_FlowDirection_FLOW_INOUT = 3,
};

const TrackEvent_LegacyEvent_FlowDirection TrackEvent_LegacyEvent_FlowDirection_MIN = TrackEvent_LegacyEvent_FlowDirection_FLOW_UNSPECIFIED;
const TrackEvent_LegacyEvent_FlowDirection TrackEvent_LegacyEvent_FlowDirection_MAX = TrackEvent_LegacyEvent_FlowDirection_FLOW_INOUT;

enum TrackEvent_LegacyEvent_InstantEventScope : int32_t {
  TrackEvent_LegacyEvent_InstantEventScope_SCOPE_UNSPECIFIED = 0,
  TrackEvent_LegacyEvent_InstantEventScope_SCOPE_GLOBAL = 1,
  TrackEvent_LegacyEvent_InstantEventScope_SCOPE_PROCESS = 2,
  TrackEvent_LegacyEvent_InstantEventScope_SCOPE_THREAD = 3,
};

const TrackEvent_LegacyEvent_InstantEventScope TrackEvent_LegacyEvent_InstantEventScope_MIN = TrackEvent_LegacyEvent_InstantEventScope_SCOPE_UNSPECIFIED;
const TrackEvent_LegacyEvent_InstantEventScope TrackEvent_LegacyEvent_InstantEventScope_MAX = TrackEvent_LegacyEvent_InstantEventScope_SCOPE_THREAD;

class EventName_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  EventName_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit EventName_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit EventName_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_iid() const { return at<1>().valid(); }
  uint64_t iid() const { return at<1>().as_uint64(); }
  bool has_name() const { return at<2>().valid(); }
  ::protozero::ConstChars name() const { return at<2>().as_string(); }
};

class EventName : public ::protozero::Message {
 public:
  using Decoder = EventName_Decoder;
  enum : int32_t {
    kIidFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  void set_iid(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_name(const char* value) {
    AppendString(2, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_name(const char* value, size_t size) {
    AppendBytes(2, value, size);
  }
};

class EventCategory_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  EventCategory_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit EventCategory_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit EventCategory_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_iid() const { return at<1>().valid(); }
  uint64_t iid() const { return at<1>().as_uint64(); }
  bool has_name() const { return at<2>().valid(); }
  ::protozero::ConstChars name() const { return at<2>().as_string(); }
};

class EventCategory : public ::protozero::Message {
 public:
  using Decoder = EventCategory_Decoder;
  enum : int32_t {
    kIidFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  void set_iid(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_name(const char* value) {
    AppendString(2, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_name(const char* value, size_t size) {
    AppendBytes(2, value, size);
  }
};

class TrackEventDefaults_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/10, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TrackEventDefaults_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TrackEventDefaults_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TrackEventDefaults_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_track_uuid() const { return at<10>().valid(); }
  uint64_t track_uuid() const { return at<10>().as_uint64(); }
};

class TrackEventDefaults : public ::protozero::Message {
 public:
  using Decoder = TrackEventDefaults_Decoder;
  enum : int32_t {
    kTrackUuidFieldNumber = 10,
  };
  void set_track_uuid(uint64_t value) {
    AppendVarInt(10, value);
  }
};

class TrackEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/23, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  TrackEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TrackEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TrackEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_timestamp_delta_us() const { return at<1>().valid(); }
  int64_t timestamp_delta_us() const { return at<1>().as_int64(); }
  bool has_timestamp_absolute_us() const { return at<16>().valid(); }
  int64_t timestamp_absolute_us() const { return at<16>().as_int64(); }
  bool has_thread_time_delta_us() const { return at<2>().valid(); }
  int64_t thread_time_delta_us() const { return at<2>().as_int64(); }
  bool has_thread_time_absolute_us() const { return at<17>().valid(); }
  int64_t thread_time_absolute_us() const { return at<17>().as_int64(); }
  bool has_thread_instruction_count_delta() const { return at<8>().valid(); }
  int64_t thread_instruction_count_delta() const { return at<8>().as_int64(); }
  bool has_thread_instruction_count_absolute() const { return at<20>().valid(); }
  int64_t thread_instruction_count_absolute() const { return at<20>().as_int64(); }
  bool has_category_iids() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator category_iids() const { return GetRepeated(3); }
  bool has_categories() const { return at<22>().valid(); }
  ::protozero::RepeatedFieldIterator categories() const { return GetRepeated(22); }
  bool has_name_iid() const { return at<10>().valid(); }
  uint64_t name_iid() const { return at<10>().as_uint64(); }
  bool has_name() const { return at<23>().valid(); }
  ::protozero::ConstChars name() const { return at<23>().as_string(); }
  bool has_type() const { return at<9>().valid(); }
  int32_t type() const { return at<9>().as_int32(); }
  bool has_track_uuid() const { return at<11>().valid(); }
  uint64_t track_uuid() const { return at<11>().as_uint64(); }
  bool has_debug_annotations() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator debug_annotations() const { return GetRepeated(4); }
  bool has_task_execution() const { return at<5>().valid(); }
  ::protozero::ConstBytes task_execution() const { return at<5>().as_bytes(); }
  bool has_log_message() const { return at<21>().valid(); }
  ::protozero::ConstBytes log_message() const { return at<21>().as_bytes(); }
  bool has_legacy_event() const { return at<6>().valid(); }
  ::protozero::ConstBytes legacy_event() const { return at<6>().as_bytes(); }
};

class TrackEvent : public ::protozero::Message {
 public:
  using Decoder = TrackEvent_Decoder;
  enum : int32_t {
    kTimestampDeltaUsFieldNumber = 1,
    kTimestampAbsoluteUsFieldNumber = 16,
    kThreadTimeDeltaUsFieldNumber = 2,
    kThreadTimeAbsoluteUsFieldNumber = 17,
    kThreadInstructionCountDeltaFieldNumber = 8,
    kThreadInstructionCountAbsoluteFieldNumber = 20,
    kCategoryIidsFieldNumber = 3,
    kCategoriesFieldNumber = 22,
    kNameIidFieldNumber = 10,
    kNameFieldNumber = 23,
    kTypeFieldNumber = 9,
    kTrackUuidFieldNumber = 11,
    kDebugAnnotationsFieldNumber = 4,
    kTaskExecutionFieldNumber = 5,
    kLogMessageFieldNumber = 21,
    kLegacyEventFieldNumber = 6,
  };
  using LegacyEvent = ::perfetto::protos::pbzero::TrackEvent_LegacyEvent;
  using Type = ::perfetto::protos::pbzero::TrackEvent_Type;
  static const Type TYPE_UNSPECIFIED = TrackEvent_Type_TYPE_UNSPECIFIED;
  static const Type TYPE_SLICE_BEGIN = TrackEvent_Type_TYPE_SLICE_BEGIN;
  static const Type TYPE_SLICE_END = TrackEvent_Type_TYPE_SLICE_END;
  static const Type TYPE_INSTANT = TrackEvent_Type_TYPE_INSTANT;
  void set_timestamp_delta_us(int64_t value) {
    AppendVarInt(1, value);
  }
  void set_timestamp_absolute_us(int64_t value) {
    AppendVarInt(16, value);
  }
  void set_thread_time_delta_us(int64_t value) {
    AppendVarInt(2, value);
  }
  void set_thread_time_absolute_us(int64_t value) {
    AppendVarInt(17, value);
  }
  void set_thread_instruction_count_delta(int64_t value) {
    AppendVarInt(8, value);
  }
  void set_thread_instruction_count_absolute(int64_t value) {
    AppendVarInt(20, value);
  }
  void add_category_iids(uint64_t value) {
    AppendVarInt(3, value);
  }
  void add_categories(const char* value) {
    AppendString(22, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void add_categories(const char* value, size_t size) {
    AppendBytes(22, value, size);
  }
  void set_name_iid(uint64_t value) {
    AppendVarInt(10, value);
  }
  void set_name(const char* value) {
    AppendString(23, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_name(const char* value, size_t size) {
    AppendBytes(23, value, size);
  }
  void set_type(::perfetto::protos::pbzero::TrackEvent_Type value) {
    AppendTinyVarInt(9, value);
  }
  void set_track_uuid(uint64_t value) {
    AppendVarInt(11, value);
  }
  template <typename T = DebugAnnotation> T* add_debug_annotations() {
    return BeginNestedMessage<T>(4);
  }

  template <typename T = TaskExecution> T* set_task_execution() {
    return BeginNestedMessage<T>(5);
  }

  template <typename T = LogMessage> T* set_log_message() {
    return BeginNestedMessage<T>(21);
  }

  template <typename T = TrackEvent_LegacyEvent> T* set_legacy_event() {
    return BeginNestedMessage<T>(6);
  }

};

class TrackEvent_LegacyEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/19, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TrackEvent_LegacyEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TrackEvent_LegacyEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TrackEvent_LegacyEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name_iid() const { return at<1>().valid(); }
  uint64_t name_iid() const { return at<1>().as_uint64(); }
  bool has_phase() const { return at<2>().valid(); }
  int32_t phase() const { return at<2>().as_int32(); }
  bool has_duration_us() const { return at<3>().valid(); }
  int64_t duration_us() const { return at<3>().as_int64(); }
  bool has_thread_duration_us() const { return at<4>().valid(); }
  int64_t thread_duration_us() const { return at<4>().as_int64(); }
  bool has_thread_instruction_delta() const { return at<15>().valid(); }
  int64_t thread_instruction_delta() const { return at<15>().as_int64(); }
  bool has_unscoped_id() const { return at<6>().valid(); }
  uint64_t unscoped_id() const { return at<6>().as_uint64(); }
  bool has_local_id() const { return at<10>().valid(); }
  uint64_t local_id() const { return at<10>().as_uint64(); }
  bool has_global_id() const { return at<11>().valid(); }
  uint64_t global_id() const { return at<11>().as_uint64(); }
  bool has_id_scope() const { return at<7>().valid(); }
  ::protozero::ConstChars id_scope() const { return at<7>().as_string(); }
  bool has_use_async_tts() const { return at<9>().valid(); }
  bool use_async_tts() const { return at<9>().as_bool(); }
  bool has_bind_id() const { return at<8>().valid(); }
  uint64_t bind_id() const { return at<8>().as_uint64(); }
  bool has_bind_to_enclosing() const { return at<12>().valid(); }
  bool bind_to_enclosing() const { return at<12>().as_bool(); }
  bool has_flow_direction() const { return at<13>().valid(); }
  int32_t flow_direction() const { return at<13>().as_int32(); }
  bool has_instant_event_scope() const { return at<14>().valid(); }
  int32_t instant_event_scope() const { return at<14>().as_int32(); }
  bool has_pid_override() const { return at<18>().valid(); }
  int32_t pid_override() const { return at<18>().as_int32(); }
  bool has_tid_override() const { return at<19>().valid(); }
  int32_t tid_override() const { return at<19>().as_int32(); }
};

class TrackEvent_LegacyEvent : public ::protozero::Message {
 public:
  using Decoder = TrackEvent_LegacyEvent_Decoder;
  enum : int32_t {
    kNameIidFieldNumber = 1,
    kPhaseFieldNumber = 2,
    kDurationUsFieldNumber = 3,
    kThreadDurationUsFieldNumber = 4,
    kThreadInstructionDeltaFieldNumber = 15,
    kUnscopedIdFieldNumber = 6,
    kLocalIdFieldNumber = 10,
    kGlobalIdFieldNumber = 11,
    kIdScopeFieldNumber = 7,
    kUseAsyncTtsFieldNumber = 9,
    kBindIdFieldNumber = 8,
    kBindToEnclosingFieldNumber = 12,
    kFlowDirectionFieldNumber = 13,
    kInstantEventScopeFieldNumber = 14,
    kPidOverrideFieldNumber = 18,
    kTidOverrideFieldNumber = 19,
  };
  using FlowDirection = ::perfetto::protos::pbzero::TrackEvent_LegacyEvent_FlowDirection;
  using InstantEventScope = ::perfetto::protos::pbzero::TrackEvent_LegacyEvent_InstantEventScope;
  static const FlowDirection FLOW_UNSPECIFIED = TrackEvent_LegacyEvent_FlowDirection_FLOW_UNSPECIFIED;
  static const FlowDirection FLOW_IN = TrackEvent_LegacyEvent_FlowDirection_FLOW_IN;
  static const FlowDirection FLOW_OUT = TrackEvent_LegacyEvent_FlowDirection_FLOW_OUT;
  static const FlowDirection FLOW_INOUT = TrackEvent_LegacyEvent_FlowDirection_FLOW_INOUT;
  static const InstantEventScope SCOPE_UNSPECIFIED = TrackEvent_LegacyEvent_InstantEventScope_SCOPE_UNSPECIFIED;
  static const InstantEventScope SCOPE_GLOBAL = TrackEvent_LegacyEvent_InstantEventScope_SCOPE_GLOBAL;
  static const InstantEventScope SCOPE_PROCESS = TrackEvent_LegacyEvent_InstantEventScope_SCOPE_PROCESS;
  static const InstantEventScope SCOPE_THREAD = TrackEvent_LegacyEvent_InstantEventScope_SCOPE_THREAD;
  void set_name_iid(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_phase(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_duration_us(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_thread_duration_us(int64_t value) {
    AppendVarInt(4, value);
  }
  void set_thread_instruction_delta(int64_t value) {
    AppendVarInt(15, value);
  }
  void set_unscoped_id(uint64_t value) {
    AppendVarInt(6, value);
  }
  void set_local_id(uint64_t value) {
    AppendVarInt(10, value);
  }
  void set_global_id(uint64_t value) {
    AppendVarInt(11, value);
  }
  void set_id_scope(const char* value) {
    AppendString(7, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_id_scope(const char* value, size_t size) {
    AppendBytes(7, value, size);
  }
  void set_use_async_tts(bool value) {
    AppendTinyVarInt(9, value);
  }
  void set_bind_id(uint64_t value) {
    AppendVarInt(8, value);
  }
  void set_bind_to_enclosing(bool value) {
    AppendTinyVarInt(12, value);
  }
  void set_flow_direction(::perfetto::protos::pbzero::TrackEvent_LegacyEvent_FlowDirection value) {
    AppendTinyVarInt(13, value);
  }
  void set_instant_event_scope(::perfetto::protos::pbzero::TrackEvent_LegacyEvent_InstantEventScope value) {
    AppendTinyVarInt(14, value);
  }
  void set_pid_override(int32_t value) {
    AppendVarInt(18, value);
  }
  void set_tid_override(int32_t value) {
    AppendVarInt(19, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_TRACING_INTERNAL_TRACK_EVENT_DATA_SOURCE_H_
#define INCLUDE_PERFETTO_TRACING_INTERNAL_TRACK_EVENT_DATA_SOURCE_H_

// gen_amalgamated expanded: #include "perfetto/tracing/data_source.h"
// gen_amalgamated expanded: #include "protos/perfetto/trace/track_event/track_event.pbzero.h"

#include <unordered_map>

namespace perfetto {
class TrackEvent;

namespace internal {

struct TrackEventIncrementalState {
  bool was_cleared = true;

  // Interned data.
  // TODO(skyostil): Replace this with something more clever that supports
  // dynamic strings too.
  std::unordered_map<const char*, uint64_t> event_names;
  std::unordered_map<const char*, uint64_t> categories;
};

class TrackEventDataSource
    : public DataSource<TrackEventDataSource, TrackEventIncrementalState> {
 public:
  void OnSetup(const SetupArgs&) override;
  void OnStart(const StartArgs&) override;
  void OnStop(const StopArgs&) override;

 private:
  friend class perfetto::TrackEvent;

  static void WriteEvent(const char* category,
                         const char* name,
                         perfetto::protos::pbzero::TrackEvent::Type type) {
    Trace([category, name, type](TraceContext ctx) {
      WriteEventImpl(std::move(ctx), category, name, type);
    });
  }

  // Outlined to reduce binary size.
  static void WriteEventImpl(TraceContext ctx,
                             const char* category,
                             const char* name,
                             perfetto::protos::pbzero::TrackEvent::Type type);

  static void WriteSequenceDescriptors(
      internal::TrackEventDataSource::TraceContext*,
      uint64_t timestamp);
};

}  // namespace internal

}  // namespace perfetto

PERFETTO_DECLARE_DATA_SOURCE_STATIC_MEMBERS(
    perfetto::internal::TrackEventDataSource,
    perfetto::internal::TrackEventIncrementalState);

#endif  // INCLUDE_PERFETTO_TRACING_INTERNAL_TRACK_EVENT_DATA_SOURCE_H_
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_TRACING_TRACK_EVENT_H_
#define INCLUDE_PERFETTO_TRACING_TRACK_EVENT_H_

// gen_amalgamated expanded: #include "perfetto/base/time.h"
// gen_amalgamated expanded: #include "perfetto/tracing/internal/track_event_data_source.h"
// gen_amalgamated expanded: #include "protos/perfetto/trace/track_event/track_event.pbzero.h"

namespace perfetto {

// Track events are time-based markers that an application can use to construct
// a timeline of its operation.
class TrackEvent {
 public:
  // Initializes the track event data source. Must be called before any other
  // method on this class.
  static void Initialize();

  // Returns the current tracing clock in nanoseconds.
  static uint64_t GetTimeNs() {
    // TODO(skyostil): Consider using boot time where available.
    return static_cast<uint64_t>(perfetto::base::GetWallTimeNs().count());
  }

  // Begin a slice on the current thread. |category| and |name| are free-form
  // strings that describe the event. Both |category| and |name| must be
  // statically allocated.
  static void Begin(const char* category, const char* name) {
    internal::TrackEventDataSource::WriteEvent(
        category, name, perfetto::protos::pbzero::TrackEvent::TYPE_SLICE_BEGIN);
  }

  // End a slice on the current thread.
  static void End(const char* category) {
    internal::TrackEventDataSource::WriteEvent(
        category, nullptr,
        perfetto::protos::pbzero::TrackEvent::TYPE_SLICE_END);
  }

  // TODO(skyostil): Add per-category enable/disable.
  // TODO(skyostil): Add arguments.
  // TODO(skyostil): Add scoped events.
  // TODO(skyostil): Add async events.
  // TODO(skyostil): Add flow events.
  // TODO(skyostil): Add instant events.
  // TODO(skyostil): Add counters.

  static void Flush() {
    internal::TrackEventDataSource::Trace(
        [&](internal::TrackEventDataSource::TraceContext ctx) { ctx.Flush(); });
  }
};

}  // namespace perfetto

PERFETTO_DECLARE_DATA_SOURCE_STATIC_MEMBERS(
    perfetto::internal::TrackEventDataSource,
    perfetto::internal::TrackEventIncrementalState);

#endif  // INCLUDE_PERFETTO_TRACING_TRACK_EVENT_H_
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_TRACING_H_
#define INCLUDE_PERFETTO_TRACING_H_

// This headers wraps all the headers necessary to use the public Perfetto
// Tracing API. Embedders should preferrably use this one header to avoid having
// to figure out the various set of header required for each class.
// The only exception to this should be large projects where build time is a
// concern (e.g. chromium), which migh prefer sticking to strict IWYU.

// gen_amalgamated expanded: #include "perfetto/tracing/core/data_source_config.h"
// gen_amalgamated expanded: #include "perfetto/tracing/core/data_source_descriptor.h"
// gen_amalgamated expanded: #include "perfetto/tracing/core/trace_config.h"
// gen_amalgamated expanded: #include "perfetto/tracing/data_source.h"
// gen_amalgamated expanded: #include "perfetto/tracing/platform.h"
// gen_amalgamated expanded: #include "perfetto/tracing/tracing.h"
// gen_amalgamated expanded: #include "perfetto/tracing/tracing_backend.h"
// gen_amalgamated expanded: #include "perfetto/tracing/track_event.h"

#endif  // INCLUDE_PERFETTO_TRACING_H_
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/common/android_log_constants.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_COMMON_ANDROID_LOG_CONSTANTS_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_COMMON_ANDROID_LOG_CONSTANTS_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


enum AndroidLogId : int32_t {
  LID_DEFAULT = 0,
  LID_RADIO = 1,
  LID_EVENTS = 2,
  LID_SYSTEM = 3,
  LID_CRASH = 4,
  LID_STATS = 5,
  LID_SECURITY = 6,
  LID_KERNEL = 7,
};

const AndroidLogId AndroidLogId_MIN = LID_DEFAULT;
const AndroidLogId AndroidLogId_MAX = LID_KERNEL;

enum AndroidLogPriority : int32_t {
  PRIO_UNSPECIFIED = 0,
  PRIO_UNUSED = 1,
  PRIO_VERBOSE = 2,
  PRIO_DEBUG = 3,
  PRIO_INFO = 4,
  PRIO_WARN = 5,
  PRIO_ERROR = 6,
  PRIO_FATAL = 7,
};

const AndroidLogPriority AndroidLogPriority_MIN = PRIO_UNSPECIFIED;
const AndroidLogPriority AndroidLogPriority_MAX = PRIO_FATAL;

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/common/commit_data_request.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_COMMON_COMMIT_DATA_REQUEST_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_COMMON_COMMIT_DATA_REQUEST_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class CommitDataRequest_ChunkToPatch;
class CommitDataRequest_ChunkToPatch_Patch;
class CommitDataRequest_ChunksToMove;

class CommitDataRequest_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  CommitDataRequest_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit CommitDataRequest_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit CommitDataRequest_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_chunks_to_move() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator chunks_to_move() const { return GetRepeated(1); }
  bool has_chunks_to_patch() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator chunks_to_patch() const { return GetRepeated(2); }
  bool has_flush_request_id() const { return at<3>().valid(); }
  uint64_t flush_request_id() const { return at<3>().as_uint64(); }
};

class CommitDataRequest : public ::protozero::Message {
 public:
  using Decoder = CommitDataRequest_Decoder;
  enum : int32_t {
    kChunksToMoveFieldNumber = 1,
    kChunksToPatchFieldNumber = 2,
    kFlushRequestIdFieldNumber = 3,
  };
  using ChunksToMove = ::perfetto::protos::pbzero::CommitDataRequest_ChunksToMove;
  using ChunkToPatch = ::perfetto::protos::pbzero::CommitDataRequest_ChunkToPatch;
  template <typename T = CommitDataRequest_ChunksToMove> T* add_chunks_to_move() {
    return BeginNestedMessage<T>(1);
  }

  template <typename T = CommitDataRequest_ChunkToPatch> T* add_chunks_to_patch() {
    return BeginNestedMessage<T>(2);
  }

  void set_flush_request_id(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class CommitDataRequest_ChunkToPatch_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  CommitDataRequest_ChunkToPatch_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit CommitDataRequest_ChunkToPatch_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit CommitDataRequest_ChunkToPatch_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_target_buffer() const { return at<1>().valid(); }
  uint32_t target_buffer() const { return at<1>().as_uint32(); }
  bool has_writer_id() const { return at<2>().valid(); }
  uint32_t writer_id() const { return at<2>().as_uint32(); }
  bool has_chunk_id() const { return at<3>().valid(); }
  uint32_t chunk_id() const { return at<3>().as_uint32(); }
  bool has_patches() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator patches() const { return GetRepeated(4); }
  bool has_has_more_patches() const { return at<5>().valid(); }
  bool has_more_patches() const { return at<5>().as_bool(); }
};

class CommitDataRequest_ChunkToPatch : public ::protozero::Message {
 public:
  using Decoder = CommitDataRequest_ChunkToPatch_Decoder;
  enum : int32_t {
    kTargetBufferFieldNumber = 1,
    kWriterIdFieldNumber = 2,
    kChunkIdFieldNumber = 3,
    kPatchesFieldNumber = 4,
    kHasMorePatchesFieldNumber = 5,
  };
  using Patch = ::perfetto::protos::pbzero::CommitDataRequest_ChunkToPatch_Patch;
  void set_target_buffer(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_writer_id(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_chunk_id(uint32_t value) {
    AppendVarInt(3, value);
  }
  template <typename T = CommitDataRequest_ChunkToPatch_Patch> T* add_patches() {
    return BeginNestedMessage<T>(4);
  }

  void set_has_more_patches(bool value) {
    AppendTinyVarInt(5, value);
  }
};

class CommitDataRequest_ChunkToPatch_Patch_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  CommitDataRequest_ChunkToPatch_Patch_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit CommitDataRequest_ChunkToPatch_Patch_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit CommitDataRequest_ChunkToPatch_Patch_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_offset() const { return at<1>().valid(); }
  uint32_t offset() const { return at<1>().as_uint32(); }
  bool has_data() const { return at<2>().valid(); }
  ::protozero::ConstBytes data() const { return at<2>().as_bytes(); }
};

class CommitDataRequest_ChunkToPatch_Patch : public ::protozero::Message {
 public:
  using Decoder = CommitDataRequest_ChunkToPatch_Patch_Decoder;
  enum : int32_t {
    kOffsetFieldNumber = 1,
    kDataFieldNumber = 2,
  };
  void set_offset(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_data(const uint8_t* data, size_t size) {
    AppendBytes(2, data, size);
  }
};

class CommitDataRequest_ChunksToMove_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  CommitDataRequest_ChunksToMove_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit CommitDataRequest_ChunksToMove_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit CommitDataRequest_ChunksToMove_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_page() const { return at<1>().valid(); }
  uint32_t page() const { return at<1>().as_uint32(); }
  bool has_chunk() const { return at<2>().valid(); }
  uint32_t chunk() const { return at<2>().as_uint32(); }
  bool has_target_buffer() const { return at<3>().valid(); }
  uint32_t target_buffer() const { return at<3>().as_uint32(); }
};

class CommitDataRequest_ChunksToMove : public ::protozero::Message {
 public:
  using Decoder = CommitDataRequest_ChunksToMove_Decoder;
  enum : int32_t {
    kPageFieldNumber = 1,
    kChunkFieldNumber = 2,
    kTargetBufferFieldNumber = 3,
  };
  void set_page(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_chunk(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_target_buffer(uint32_t value) {
    AppendVarInt(3, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/common/data_source_descriptor.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_COMMON_DATA_SOURCE_DESCRIPTOR_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_COMMON_DATA_SOURCE_DESCRIPTOR_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class GpuCounterDescriptor;
class TrackEventDescriptor;

class DataSourceDescriptor_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  DataSourceDescriptor_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit DataSourceDescriptor_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit DataSourceDescriptor_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_will_notify_on_stop() const { return at<2>().valid(); }
  bool will_notify_on_stop() const { return at<2>().as_bool(); }
  bool has_will_notify_on_start() const { return at<3>().valid(); }
  bool will_notify_on_start() const { return at<3>().as_bool(); }
  bool has_handles_incremental_state_clear() const { return at<4>().valid(); }
  bool handles_incremental_state_clear() const { return at<4>().as_bool(); }
  bool has_gpu_counter_descriptor() const { return at<5>().valid(); }
  ::protozero::ConstBytes gpu_counter_descriptor() const { return at<5>().as_bytes(); }
  bool has_track_event_descriptor() const { return at<6>().valid(); }
  ::protozero::ConstBytes track_event_descriptor() const { return at<6>().as_bytes(); }
};

class DataSourceDescriptor : public ::protozero::Message {
 public:
  using Decoder = DataSourceDescriptor_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kWillNotifyOnStopFieldNumber = 2,
    kWillNotifyOnStartFieldNumber = 3,
    kHandlesIncrementalStateClearFieldNumber = 4,
    kGpuCounterDescriptorFieldNumber = 5,
    kTrackEventDescriptorFieldNumber = 6,
  };
  void set_name(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_name(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_will_notify_on_stop(bool value) {
    AppendTinyVarInt(2, value);
  }
  void set_will_notify_on_start(bool value) {
    AppendTinyVarInt(3, value);
  }
  void set_handles_incremental_state_clear(bool value) {
    AppendTinyVarInt(4, value);
  }
  template <typename T = GpuCounterDescriptor> T* set_gpu_counter_descriptor() {
    return BeginNestedMessage<T>(5);
  }

  template <typename T = TrackEventDescriptor> T* set_track_event_descriptor() {
    return BeginNestedMessage<T>(6);
  }

};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/common/descriptor.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_COMMON_DESCRIPTOR_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_COMMON_DESCRIPTOR_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class DescriptorProto;
class DescriptorProto_ReservedRange;
class EnumDescriptorProto;
class EnumValueDescriptorProto;
class FieldDescriptorProto;
class FileDescriptorProto;
class OneofDescriptorProto;
class OneofOptions;
enum FieldDescriptorProto_Label : int32_t;
enum FieldDescriptorProto_Type : int32_t;

enum FieldDescriptorProto_Type : int32_t {
  FieldDescriptorProto_Type_TYPE_DOUBLE = 1,
  FieldDescriptorProto_Type_TYPE_FLOAT = 2,
  FieldDescriptorProto_Type_TYPE_INT64 = 3,
  FieldDescriptorProto_Type_TYPE_UINT64 = 4,
  FieldDescriptorProto_Type_TYPE_INT32 = 5,
  FieldDescriptorProto_Type_TYPE_FIXED64 = 6,
  FieldDescriptorProto_Type_TYPE_FIXED32 = 7,
  FieldDescriptorProto_Type_TYPE_BOOL = 8,
  FieldDescriptorProto_Type_TYPE_STRING = 9,
  FieldDescriptorProto_Type_TYPE_GROUP = 10,
  FieldDescriptorProto_Type_TYPE_MESSAGE = 11,
  FieldDescriptorProto_Type_TYPE_BYTES = 12,
  FieldDescriptorProto_Type_TYPE_UINT32 = 13,
  FieldDescriptorProto_Type_TYPE_ENUM = 14,
  FieldDescriptorProto_Type_TYPE_SFIXED32 = 15,
  FieldDescriptorProto_Type_TYPE_SFIXED64 = 16,
  FieldDescriptorProto_Type_TYPE_SINT32 = 17,
  FieldDescriptorProto_Type_TYPE_SINT64 = 18,
};

const FieldDescriptorProto_Type FieldDescriptorProto_Type_MIN = FieldDescriptorProto_Type_TYPE_DOUBLE;
const FieldDescriptorProto_Type FieldDescriptorProto_Type_MAX = FieldDescriptorProto_Type_TYPE_SINT64;

enum FieldDescriptorProto_Label : int32_t {
  FieldDescriptorProto_Label_LABEL_OPTIONAL = 1,
  FieldDescriptorProto_Label_LABEL_REQUIRED = 2,
  FieldDescriptorProto_Label_LABEL_REPEATED = 3,
};

const FieldDescriptorProto_Label FieldDescriptorProto_Label_MIN = FieldDescriptorProto_Label_LABEL_OPTIONAL;
const FieldDescriptorProto_Label FieldDescriptorProto_Label_MAX = FieldDescriptorProto_Label_LABEL_REPEATED;

class OneofOptions_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/0, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  OneofOptions_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit OneofOptions_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit OneofOptions_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
};

class OneofOptions : public ::protozero::Message {
 public:
  using Decoder = OneofOptions_Decoder;
};

class EnumValueDescriptorProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  EnumValueDescriptorProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit EnumValueDescriptorProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit EnumValueDescriptorProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_number() const { return at<2>().valid(); }
  int32_t number() const { return at<2>().as_int32(); }
};

class EnumValueDescriptorProto : public ::protozero::Message {
 public:
  using Decoder = EnumValueDescriptorProto_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kNumberFieldNumber = 2,
  };
  void set_name(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_name(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_number(int32_t value) {
    AppendVarInt(2, value);
  }
};

class EnumDescriptorProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  EnumDescriptorProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit EnumDescriptorProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit EnumDescriptorProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_value() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator value() const { return GetRepeated(2); }
  bool has_reserved_name() const { return at<5>().valid(); }
  ::protozero::RepeatedFieldIterator reserved_name() const { return GetRepeated(5); }
};

class EnumDescriptorProto : public ::protozero::Message {
 public:
  using Decoder = EnumDescriptorProto_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
    kReservedNameFieldNumber = 5,
  };
  void set_name(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_name(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  template <typename T = EnumValueDescriptorProto> T* add_value() {
    return BeginNestedMessage<T>(2);
  }

  void add_reserved_name(const char* value) {
    AppendString(5, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void add_reserved_name(const char* value, size_t size) {
    AppendBytes(5, value, size);
  }
};

class OneofDescriptorProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  OneofDescriptorProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit OneofDescriptorProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit OneofDescriptorProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_options() const { return at<2>().valid(); }
  ::protozero::ConstBytes options() const { return at<2>().as_bytes(); }
};

class OneofDescriptorProto : public ::protozero::Message {
 public:
  using Decoder = OneofDescriptorProto_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kOptionsFieldNumber = 2,
  };
  void set_name(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_name(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  template <typename T = OneofOptions> T* set_options() {
    return BeginNestedMessage<T>(2);
  }

};

class FieldDescriptorProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/9, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  FieldDescriptorProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit FieldDescriptorProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit FieldDescriptorProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_number() const { return at<3>().valid(); }
  int32_t number() const { return at<3>().as_int32(); }
  bool has_label() const { return at<4>().valid(); }
  int32_t label() const { return at<4>().as_int32(); }
  bool has_type() const { return at<5>().valid(); }
  int32_t type() const { return at<5>().as_int32(); }
  bool has_type_name() const { return at<6>().valid(); }
  ::protozero::ConstChars type_name() const { return at<6>().as_string(); }
  bool has_extendee() const { return at<2>().valid(); }
  ::protozero::ConstChars extendee() const { return at<2>().as_string(); }
  bool has_default_value() const { return at<7>().valid(); }
  ::protozero::ConstChars default_value() const { return at<7>().as_string(); }
  bool has_oneof_index() const { return at<9>().valid(); }
  int32_t oneof_index() const { return at<9>().as_int32(); }
};

class FieldDescriptorProto : public ::protozero::Message {
 public:
  using Decoder = FieldDescriptorProto_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kNumberFieldNumber = 3,
    kLabelFieldNumber = 4,
    kTypeFieldNumber = 5,
    kTypeNameFieldNumber = 6,
    kExtendeeFieldNumber = 2,
    kDefaultValueFieldNumber = 7,
    kOneofIndexFieldNumber = 9,
  };
  using Type = ::perfetto::protos::pbzero::FieldDescriptorProto_Type;
  using Label = ::perfetto::protos::pbzero::FieldDescriptorProto_Label;
  static const Type TYPE_DOUBLE = FieldDescriptorProto_Type_TYPE_DOUBLE;
  static const Type TYPE_FLOAT = FieldDescriptorProto_Type_TYPE_FLOAT;
  static const Type TYPE_INT64 = FieldDescriptorProto_Type_TYPE_INT64;
  static const Type TYPE_UINT64 = FieldDescriptorProto_Type_TYPE_UINT64;
  static const Type TYPE_INT32 = FieldDescriptorProto_Type_TYPE_INT32;
  static const Type TYPE_FIXED64 = FieldDescriptorProto_Type_TYPE_FIXED64;
  static const Type TYPE_FIXED32 = FieldDescriptorProto_Type_TYPE_FIXED32;
  static const Type TYPE_BOOL = FieldDescriptorProto_Type_TYPE_BOOL;
  static const Type TYPE_STRING = FieldDescriptorProto_Type_TYPE_STRING;
  static const Type TYPE_GROUP = FieldDescriptorProto_Type_TYPE_GROUP;
  static const Type TYPE_MESSAGE = FieldDescriptorProto_Type_TYPE_MESSAGE;
  static const Type TYPE_BYTES = FieldDescriptorProto_Type_TYPE_BYTES;
  static const Type TYPE_UINT32 = FieldDescriptorProto_Type_TYPE_UINT32;
  static const Type TYPE_ENUM = FieldDescriptorProto_Type_TYPE_ENUM;
  static const Type TYPE_SFIXED32 = FieldDescriptorProto_Type_TYPE_SFIXED32;
  static const Type TYPE_SFIXED64 = FieldDescriptorProto_Type_TYPE_SFIXED64;
  static const Type TYPE_SINT32 = FieldDescriptorProto_Type_TYPE_SINT32;
  static const Type TYPE_SINT64 = FieldDescriptorProto_Type_TYPE_SINT64;
  static const Label LABEL_OPTIONAL = FieldDescriptorProto_Label_LABEL_OPTIONAL;
  static const Label LABEL_REQUIRED = FieldDescriptorProto_Label_LABEL_REQUIRED;
  static const Label LABEL_REPEATED = FieldDescriptorProto_Label_LABEL_REPEATED;
  void set_name(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_name(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_number(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_label(::perfetto::protos::pbzero::FieldDescriptorProto_Label value) {
    AppendTinyVarInt(4, value);
  }
  void set_type(::perfetto::protos::pbzero::FieldDescriptorProto_Type value) {
    AppendTinyVarInt(5, value);
  }
  void set_type_name(const char* value) {
    AppendString(6, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_type_name(const char* value, size_t size) {
    AppendBytes(6, value, size);
  }
  void set_extendee(const char* value) {
    AppendString(2, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_extendee(const char* value, size_t size) {
    AppendBytes(2, value, size);
  }
  void set_default_value(const char* value) {
    AppendString(7, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_default_value(const char* value, size_t size) {
    AppendBytes(7, value, size);
  }
  void set_oneof_index(int32_t value) {
    AppendVarInt(9, value);
  }
};

class DescriptorProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/10, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  DescriptorProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit DescriptorProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit DescriptorProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_field() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator field() const { return GetRepeated(2); }
  bool has_extension() const { return at<6>().valid(); }
  ::protozero::RepeatedFieldIterator extension() const { return GetRepeated(6); }
  bool has_nested_type() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator nested_type() const { return GetRepeated(3); }
  bool has_enum_type() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator enum_type() const { return GetRepeated(4); }
  bool has_oneof_decl() const { return at<8>().valid(); }
  ::protozero::RepeatedFieldIterator oneof_decl() const { return GetRepeated(8); }
  bool has_reserved_range() const { return at<9>().valid(); }
  ::protozero::RepeatedFieldIterator reserved_range() const { return GetRepeated(9); }
  bool has_reserved_name() const { return at<10>().valid(); }
  ::protozero::RepeatedFieldIterator reserved_name() const { return GetRepeated(10); }
};

class DescriptorProto : public ::protozero::Message {
 public:
  using Decoder = DescriptorProto_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kFieldFieldNumber = 2,
    kExtensionFieldNumber = 6,
    kNestedTypeFieldNumber = 3,
    kEnumTypeFieldNumber = 4,
    kOneofDeclFieldNumber = 8,
    kReservedRangeFieldNumber = 9,
    kReservedNameFieldNumber = 10,
  };
  using ReservedRange = ::perfetto::protos::pbzero::DescriptorProto_ReservedRange;
  void set_name(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_name(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  template <typename T = FieldDescriptorProto> T* add_field() {
    return BeginNestedMessage<T>(2);
  }

  template <typename T = FieldDescriptorProto> T* add_extension() {
    return BeginNestedMessage<T>(6);
  }

  template <typename T = DescriptorProto> T* add_nested_type() {
    return BeginNestedMessage<T>(3);
  }

  template <typename T = EnumDescriptorProto> T* add_enum_type() {
    return BeginNestedMessage<T>(4);
  }

  template <typename T = OneofDescriptorProto> T* add_oneof_decl() {
    return BeginNestedMessage<T>(8);
  }

  template <typename T = DescriptorProto_ReservedRange> T* add_reserved_range() {
    return BeginNestedMessage<T>(9);
  }

  void add_reserved_name(const char* value) {
    AppendString(10, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void add_reserved_name(const char* value, size_t size) {
    AppendBytes(10, value, size);
  }
};

class DescriptorProto_ReservedRange_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  DescriptorProto_ReservedRange_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit DescriptorProto_ReservedRange_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit DescriptorProto_ReservedRange_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_start() const { return at<1>().valid(); }
  int32_t start() const { return at<1>().as_int32(); }
  bool has_end() const { return at<2>().valid(); }
  int32_t end() const { return at<2>().as_int32(); }
};

class DescriptorProto_ReservedRange : public ::protozero::Message {
 public:
  using Decoder = DescriptorProto_ReservedRange_Decoder;
  enum : int32_t {
    kStartFieldNumber = 1,
    kEndFieldNumber = 2,
  };
  void set_start(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_end(int32_t value) {
    AppendVarInt(2, value);
  }
};

class FileDescriptorProto_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/11, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  FileDescriptorProto_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit FileDescriptorProto_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit FileDescriptorProto_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_package() const { return at<2>().valid(); }
  ::protozero::ConstChars package() const { return at<2>().as_string(); }
  bool has_dependency() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator dependency() const { return GetRepeated(3); }
  bool has_public_dependency() const { return at<10>().valid(); }
  ::protozero::RepeatedFieldIterator public_dependency() const { return GetRepeated(10); }
  bool has_weak_dependency() const { return at<11>().valid(); }
  ::protozero::RepeatedFieldIterator weak_dependency() const { return GetRepeated(11); }
  bool has_message_type() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator message_type() const { return GetRepeated(4); }
  bool has_enum_type() const { return at<5>().valid(); }
  ::protozero::RepeatedFieldIterator enum_type() const { return GetRepeated(5); }
  bool has_extension() const { return at<7>().valid(); }
  ::protozero::RepeatedFieldIterator extension() const { return GetRepeated(7); }
};

class FileDescriptorProto : public ::protozero::Message {
 public:
  using Decoder = FileDescriptorProto_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kPackageFieldNumber = 2,
    kDependencyFieldNumber = 3,
    kPublicDependencyFieldNumber = 10,
    kWeakDependencyFieldNumber = 11,
    kMessageTypeFieldNumber = 4,
    kEnumTypeFieldNumber = 5,
    kExtensionFieldNumber = 7,
  };
  void set_name(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_name(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_package(const char* value) {
    AppendString(2, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_package(const char* value, size_t size) {
    AppendBytes(2, value, size);
  }
  void add_dependency(const char* value) {
    AppendString(3, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void add_dependency(const char* value, size_t size) {
    AppendBytes(3, value, size);
  }
  void add_public_dependency(int32_t value) {
    AppendVarInt(10, value);
  }
  void add_weak_dependency(int32_t value) {
    AppendVarInt(11, value);
  }
  template <typename T = DescriptorProto> T* add_message_type() {
    return BeginNestedMessage<T>(4);
  }

  template <typename T = EnumDescriptorProto> T* add_enum_type() {
    return BeginNestedMessage<T>(5);
  }

  template <typename T = FieldDescriptorProto> T* add_extension() {
    return BeginNestedMessage<T>(7);
  }

};

class FileDescriptorSet_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  FileDescriptorSet_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit FileDescriptorSet_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit FileDescriptorSet_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_file() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator file() const { return GetRepeated(1); }
};

class FileDescriptorSet : public ::protozero::Message {
 public:
  using Decoder = FileDescriptorSet_Decoder;
  enum : int32_t {
    kFileFieldNumber = 1,
  };
  template <typename T = FileDescriptorProto> T* add_file() {
    return BeginNestedMessage<T>(1);
  }

};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/common/gpu_counter_descriptor.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_COMMON_GPU_COUNTER_DESCRIPTOR_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_COMMON_GPU_COUNTER_DESCRIPTOR_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class GpuCounterDescriptor_GpuCounterBlock;
class GpuCounterDescriptor_GpuCounterSpec;
enum GpuCounterDescriptor_MeasureUnit : int32_t;

enum GpuCounterDescriptor_MeasureUnit : int32_t {
  GpuCounterDescriptor_MeasureUnit_NONE = 0,
  GpuCounterDescriptor_MeasureUnit_BIT = 1,
  GpuCounterDescriptor_MeasureUnit_KILOBIT = 2,
  GpuCounterDescriptor_MeasureUnit_MEGABIT = 3,
  GpuCounterDescriptor_MeasureUnit_GIGABIT = 4,
  GpuCounterDescriptor_MeasureUnit_TERABIT = 5,
  GpuCounterDescriptor_MeasureUnit_PETABIT = 6,
  GpuCounterDescriptor_MeasureUnit_BYTE = 7,
  GpuCounterDescriptor_MeasureUnit_KILOBYTE = 8,
  GpuCounterDescriptor_MeasureUnit_MEGABYTE = 9,
  GpuCounterDescriptor_MeasureUnit_GIGABYTE = 10,
  GpuCounterDescriptor_MeasureUnit_TERABYTE = 11,
  GpuCounterDescriptor_MeasureUnit_PETABYTE = 12,
  GpuCounterDescriptor_MeasureUnit_HERTZ = 13,
  GpuCounterDescriptor_MeasureUnit_KILOHERTZ = 14,
  GpuCounterDescriptor_MeasureUnit_MEGAHERTZ = 15,
  GpuCounterDescriptor_MeasureUnit_GIGAHERTZ = 16,
  GpuCounterDescriptor_MeasureUnit_TERAHERTZ = 17,
  GpuCounterDescriptor_MeasureUnit_PETAHERTZ = 18,
  GpuCounterDescriptor_MeasureUnit_NANOSECOND = 19,
  GpuCounterDescriptor_MeasureUnit_MICROSECOND = 20,
  GpuCounterDescriptor_MeasureUnit_MILLISECOND = 21,
  GpuCounterDescriptor_MeasureUnit_SECOND = 22,
  GpuCounterDescriptor_MeasureUnit_MINUTE = 23,
  GpuCounterDescriptor_MeasureUnit_HOUR = 24,
  GpuCounterDescriptor_MeasureUnit_VERTEX = 25,
  GpuCounterDescriptor_MeasureUnit_PIXEL = 26,
  GpuCounterDescriptor_MeasureUnit_TRIANGLE = 27,
  GpuCounterDescriptor_MeasureUnit_MILLIWATT = 28,
  GpuCounterDescriptor_MeasureUnit_WATT = 29,
  GpuCounterDescriptor_MeasureUnit_KILOWATT = 30,
  GpuCounterDescriptor_MeasureUnit_JOULE = 31,
  GpuCounterDescriptor_MeasureUnit_VOLT = 32,
  GpuCounterDescriptor_MeasureUnit_AMPERE = 33,
  GpuCounterDescriptor_MeasureUnit_CELSIUS = 34,
  GpuCounterDescriptor_MeasureUnit_FAHRENHEIT = 35,
  GpuCounterDescriptor_MeasureUnit_KELVIN = 36,
  GpuCounterDescriptor_MeasureUnit_PERCENT = 37,
};

const GpuCounterDescriptor_MeasureUnit GpuCounterDescriptor_MeasureUnit_MIN = GpuCounterDescriptor_MeasureUnit_NONE;
const GpuCounterDescriptor_MeasureUnit GpuCounterDescriptor_MeasureUnit_MAX = GpuCounterDescriptor_MeasureUnit_PERCENT;

class GpuCounterDescriptor_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  GpuCounterDescriptor_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit GpuCounterDescriptor_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit GpuCounterDescriptor_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_specs() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator specs() const { return GetRepeated(1); }
  bool has_blocks() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator blocks() const { return GetRepeated(2); }
  bool has_min_sampling_period_ns() const { return at<3>().valid(); }
  uint64_t min_sampling_period_ns() const { return at<3>().as_uint64(); }
  bool has_max_sampling_period_ns() const { return at<4>().valid(); }
  uint64_t max_sampling_period_ns() const { return at<4>().as_uint64(); }
  bool has_supports_instrumented_sampling() const { return at<5>().valid(); }
  bool supports_instrumented_sampling() const { return at<5>().as_bool(); }
};

class GpuCounterDescriptor : public ::protozero::Message {
 public:
  using Decoder = GpuCounterDescriptor_Decoder;
  enum : int32_t {
    kSpecsFieldNumber = 1,
    kBlocksFieldNumber = 2,
    kMinSamplingPeriodNsFieldNumber = 3,
    kMaxSamplingPeriodNsFieldNumber = 4,
    kSupportsInstrumentedSamplingFieldNumber = 5,
  };
  using GpuCounterSpec = ::perfetto::protos::pbzero::GpuCounterDescriptor_GpuCounterSpec;
  using GpuCounterBlock = ::perfetto::protos::pbzero::GpuCounterDescriptor_GpuCounterBlock;
  using MeasureUnit = ::perfetto::protos::pbzero::GpuCounterDescriptor_MeasureUnit;
  static const MeasureUnit NONE = GpuCounterDescriptor_MeasureUnit_NONE;
  static const MeasureUnit BIT = GpuCounterDescriptor_MeasureUnit_BIT;
  static const MeasureUnit KILOBIT = GpuCounterDescriptor_MeasureUnit_KILOBIT;
  static const MeasureUnit MEGABIT = GpuCounterDescriptor_MeasureUnit_MEGABIT;
  static const MeasureUnit GIGABIT = GpuCounterDescriptor_MeasureUnit_GIGABIT;
  static const MeasureUnit TERABIT = GpuCounterDescriptor_MeasureUnit_TERABIT;
  static const MeasureUnit PETABIT = GpuCounterDescriptor_MeasureUnit_PETABIT;
  static const MeasureUnit BYTE = GpuCounterDescriptor_MeasureUnit_BYTE;
  static const MeasureUnit KILOBYTE = GpuCounterDescriptor_MeasureUnit_KILOBYTE;
  static const MeasureUnit MEGABYTE = GpuCounterDescriptor_MeasureUnit_MEGABYTE;
  static const MeasureUnit GIGABYTE = GpuCounterDescriptor_MeasureUnit_GIGABYTE;
  static const MeasureUnit TERABYTE = GpuCounterDescriptor_MeasureUnit_TERABYTE;
  static const MeasureUnit PETABYTE = GpuCounterDescriptor_MeasureUnit_PETABYTE;
  static const MeasureUnit HERTZ = GpuCounterDescriptor_MeasureUnit_HERTZ;
  static const MeasureUnit KILOHERTZ = GpuCounterDescriptor_MeasureUnit_KILOHERTZ;
  static const MeasureUnit MEGAHERTZ = GpuCounterDescriptor_MeasureUnit_MEGAHERTZ;
  static const MeasureUnit GIGAHERTZ = GpuCounterDescriptor_MeasureUnit_GIGAHERTZ;
  static const MeasureUnit TERAHERTZ = GpuCounterDescriptor_MeasureUnit_TERAHERTZ;
  static const MeasureUnit PETAHERTZ = GpuCounterDescriptor_MeasureUnit_PETAHERTZ;
  static const MeasureUnit NANOSECOND = GpuCounterDescriptor_MeasureUnit_NANOSECOND;
  static const MeasureUnit MICROSECOND = GpuCounterDescriptor_MeasureUnit_MICROSECOND;
  static const MeasureUnit MILLISECOND = GpuCounterDescriptor_MeasureUnit_MILLISECOND;
  static const MeasureUnit SECOND = GpuCounterDescriptor_MeasureUnit_SECOND;
  static const MeasureUnit MINUTE = GpuCounterDescriptor_MeasureUnit_MINUTE;
  static const MeasureUnit HOUR = GpuCounterDescriptor_MeasureUnit_HOUR;
  static const MeasureUnit VERTEX = GpuCounterDescriptor_MeasureUnit_VERTEX;
  static const MeasureUnit PIXEL = GpuCounterDescriptor_MeasureUnit_PIXEL;
  static const MeasureUnit TRIANGLE = GpuCounterDescriptor_MeasureUnit_TRIANGLE;
  static const MeasureUnit MILLIWATT = GpuCounterDescriptor_MeasureUnit_MILLIWATT;
  static const MeasureUnit WATT = GpuCounterDescriptor_MeasureUnit_WATT;
  static const MeasureUnit KILOWATT = GpuCounterDescriptor_MeasureUnit_KILOWATT;
  static const MeasureUnit JOULE = GpuCounterDescriptor_MeasureUnit_JOULE;
  static const MeasureUnit VOLT = GpuCounterDescriptor_MeasureUnit_VOLT;
  static const MeasureUnit AMPERE = GpuCounterDescriptor_MeasureUnit_AMPERE;
  static const MeasureUnit CELSIUS = GpuCounterDescriptor_MeasureUnit_CELSIUS;
  static const MeasureUnit FAHRENHEIT = GpuCounterDescriptor_MeasureUnit_FAHRENHEIT;
  static const MeasureUnit KELVIN = GpuCounterDescriptor_MeasureUnit_KELVIN;
  static const MeasureUnit PERCENT = GpuCounterDescriptor_MeasureUnit_PERCENT;
  template <typename T = GpuCounterDescriptor_GpuCounterSpec> T* add_specs() {
    return BeginNestedMessage<T>(1);
  }

  template <typename T = GpuCounterDescriptor_GpuCounterBlock> T* add_blocks() {
    return BeginNestedMessage<T>(2);
  }

  void set_min_sampling_period_ns(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_max_sampling_period_ns(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_supports_instrumented_sampling(bool value) {
    AppendTinyVarInt(5, value);
  }
};

class GpuCounterDescriptor_GpuCounterBlock_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  GpuCounterDescriptor_GpuCounterBlock_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit GpuCounterDescriptor_GpuCounterBlock_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit GpuCounterDescriptor_GpuCounterBlock_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_block_id() const { return at<1>().valid(); }
  uint32_t block_id() const { return at<1>().as_uint32(); }
  bool has_block_capacity() const { return at<2>().valid(); }
  uint32_t block_capacity() const { return at<2>().as_uint32(); }
  bool has_name() const { return at<3>().valid(); }
  ::protozero::ConstChars name() const { return at<3>().as_string(); }
  bool has_description() const { return at<4>().valid(); }
  ::protozero::ConstChars description() const { return at<4>().as_string(); }
  bool has_counter_ids() const { return at<5>().valid(); }
  ::protozero::RepeatedFieldIterator counter_ids() const { return GetRepeated(5); }
};

class GpuCounterDescriptor_GpuCounterBlock : public ::protozero::Message {
 public:
  using Decoder = GpuCounterDescriptor_GpuCounterBlock_Decoder;
  enum : int32_t {
    kBlockIdFieldNumber = 1,
    kBlockCapacityFieldNumber = 2,
    kNameFieldNumber = 3,
    kDescriptionFieldNumber = 4,
    kCounterIdsFieldNumber = 5,
  };
  void set_block_id(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_block_capacity(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_name(const char* value) {
    AppendString(3, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_name(const char* value, size_t size) {
    AppendBytes(3, value, size);
  }
  void set_description(const char* value) {
    AppendString(4, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_description(const char* value, size_t size) {
    AppendBytes(4, value, size);
  }
  void add_counter_ids(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class GpuCounterDescriptor_GpuCounterSpec_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/9, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  GpuCounterDescriptor_GpuCounterSpec_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit GpuCounterDescriptor_GpuCounterSpec_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit GpuCounterDescriptor_GpuCounterSpec_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_counter_id() const { return at<1>().valid(); }
  uint32_t counter_id() const { return at<1>().as_uint32(); }
  bool has_name() const { return at<2>().valid(); }
  ::protozero::ConstChars name() const { return at<2>().as_string(); }
  bool has_description() const { return at<3>().valid(); }
  ::protozero::ConstChars description() const { return at<3>().as_string(); }
  bool has_int_peak_value() const { return at<5>().valid(); }
  int64_t int_peak_value() const { return at<5>().as_int64(); }
  bool has_double_peak_value() const { return at<6>().valid(); }
  double double_peak_value() const { return at<6>().as_double(); }
  bool has_numerator_units() const { return at<7>().valid(); }
  ::protozero::RepeatedFieldIterator numerator_units() const { return GetRepeated(7); }
  bool has_denominator_units() const { return at<8>().valid(); }
  ::protozero::RepeatedFieldIterator denominator_units() const { return GetRepeated(8); }
  bool has_select_by_default() const { return at<9>().valid(); }
  bool select_by_default() const { return at<9>().as_bool(); }
};

class GpuCounterDescriptor_GpuCounterSpec : public ::protozero::Message {
 public:
  using Decoder = GpuCounterDescriptor_GpuCounterSpec_Decoder;
  enum : int32_t {
    kCounterIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kDescriptionFieldNumber = 3,
    kIntPeakValueFieldNumber = 5,
    kDoublePeakValueFieldNumber = 6,
    kNumeratorUnitsFieldNumber = 7,
    kDenominatorUnitsFieldNumber = 8,
    kSelectByDefaultFieldNumber = 9,
  };
  void set_counter_id(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_name(const char* value) {
    AppendString(2, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_name(const char* value, size_t size) {
    AppendBytes(2, value, size);
  }
  void set_description(const char* value) {
    AppendString(3, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_description(const char* value, size_t size) {
    AppendBytes(3, value, size);
  }
  void set_int_peak_value(int64_t value) {
    AppendVarInt(5, value);
  }
  void set_double_peak_value(double value) {
    AppendFixed(6, value);
  }
  void add_numerator_units(::perfetto::protos::pbzero::GpuCounterDescriptor_MeasureUnit value) {
    AppendTinyVarInt(7, value);
  }
  void add_denominator_units(::perfetto::protos::pbzero::GpuCounterDescriptor_MeasureUnit value) {
    AppendTinyVarInt(8, value);
  }
  void set_select_by_default(bool value) {
    AppendTinyVarInt(9, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/common/observable_events.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_COMMON_OBSERVABLE_EVENTS_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_COMMON_OBSERVABLE_EVENTS_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class ObservableEvents_DataSourceInstanceStateChange;
enum ObservableEvents_DataSourceInstanceState : int32_t;

enum ObservableEvents_Type : int32_t {
  ObservableEvents_Type_TYPE_UNSPECIFIED = 0,
  ObservableEvents_Type_TYPE_DATA_SOURCES_INSTANCES = 1,
};

const ObservableEvents_Type ObservableEvents_Type_MIN = ObservableEvents_Type_TYPE_UNSPECIFIED;
const ObservableEvents_Type ObservableEvents_Type_MAX = ObservableEvents_Type_TYPE_DATA_SOURCES_INSTANCES;

enum ObservableEvents_DataSourceInstanceState : int32_t {
  ObservableEvents_DataSourceInstanceState_DATA_SOURCE_INSTANCE_STATE_STOPPED = 1,
  ObservableEvents_DataSourceInstanceState_DATA_SOURCE_INSTANCE_STATE_STARTED = 2,
};

const ObservableEvents_DataSourceInstanceState ObservableEvents_DataSourceInstanceState_MIN = ObservableEvents_DataSourceInstanceState_DATA_SOURCE_INSTANCE_STATE_STOPPED;
const ObservableEvents_DataSourceInstanceState ObservableEvents_DataSourceInstanceState_MAX = ObservableEvents_DataSourceInstanceState_DATA_SOURCE_INSTANCE_STATE_STARTED;

class ObservableEvents_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  ObservableEvents_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ObservableEvents_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ObservableEvents_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_instance_state_changes() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator instance_state_changes() const { return GetRepeated(1); }
};

class ObservableEvents : public ::protozero::Message {
 public:
  using Decoder = ObservableEvents_Decoder;
  enum : int32_t {
    kInstanceStateChangesFieldNumber = 1,
  };
  using DataSourceInstanceStateChange = ::perfetto::protos::pbzero::ObservableEvents_DataSourceInstanceStateChange;
  using Type = ::perfetto::protos::pbzero::ObservableEvents_Type;
  using DataSourceInstanceState = ::perfetto::protos::pbzero::ObservableEvents_DataSourceInstanceState;
  static const Type TYPE_UNSPECIFIED = ObservableEvents_Type_TYPE_UNSPECIFIED;
  static const Type TYPE_DATA_SOURCES_INSTANCES = ObservableEvents_Type_TYPE_DATA_SOURCES_INSTANCES;
  static const DataSourceInstanceState DATA_SOURCE_INSTANCE_STATE_STOPPED = ObservableEvents_DataSourceInstanceState_DATA_SOURCE_INSTANCE_STATE_STOPPED;
  static const DataSourceInstanceState DATA_SOURCE_INSTANCE_STATE_STARTED = ObservableEvents_DataSourceInstanceState_DATA_SOURCE_INSTANCE_STATE_STARTED;
  template <typename T = ObservableEvents_DataSourceInstanceStateChange> T* add_instance_state_changes() {
    return BeginNestedMessage<T>(1);
  }

};

class ObservableEvents_DataSourceInstanceStateChange_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ObservableEvents_DataSourceInstanceStateChange_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ObservableEvents_DataSourceInstanceStateChange_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ObservableEvents_DataSourceInstanceStateChange_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_producer_name() const { return at<1>().valid(); }
  ::protozero::ConstChars producer_name() const { return at<1>().as_string(); }
  bool has_data_source_name() const { return at<2>().valid(); }
  ::protozero::ConstChars data_source_name() const { return at<2>().as_string(); }
  bool has_state() const { return at<3>().valid(); }
  int32_t state() const { return at<3>().as_int32(); }
};

class ObservableEvents_DataSourceInstanceStateChange : public ::protozero::Message {
 public:
  using Decoder = ObservableEvents_DataSourceInstanceStateChange_Decoder;
  enum : int32_t {
    kProducerNameFieldNumber = 1,
    kDataSourceNameFieldNumber = 2,
    kStateFieldNumber = 3,
  };
  void set_producer_name(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_producer_name(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_data_source_name(const char* value) {
    AppendString(2, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_data_source_name(const char* value, size_t size) {
    AppendBytes(2, value, size);
  }
  void set_state(::perfetto::protos::pbzero::ObservableEvents_DataSourceInstanceState value) {
    AppendTinyVarInt(3, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/common/sys_stats_counters.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_COMMON_SYS_STATS_COUNTERS_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_COMMON_SYS_STATS_COUNTERS_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


enum MeminfoCounters : int32_t {
  MEMINFO_UNSPECIFIED = 0,
  MEMINFO_MEM_TOTAL = 1,
  MEMINFO_MEM_FREE = 2,
  MEMINFO_MEM_AVAILABLE = 3,
  MEMINFO_BUFFERS = 4,
  MEMINFO_CACHED = 5,
  MEMINFO_SWAP_CACHED = 6,
  MEMINFO_ACTIVE = 7,
  MEMINFO_INACTIVE = 8,
  MEMINFO_ACTIVE_ANON = 9,
  MEMINFO_INACTIVE_ANON = 10,
  MEMINFO_ACTIVE_FILE = 11,
  MEMINFO_INACTIVE_FILE = 12,
  MEMINFO_UNEVICTABLE = 13,
  MEMINFO_MLOCKED = 14,
  MEMINFO_SWAP_TOTAL = 15,
  MEMINFO_SWAP_FREE = 16,
  MEMINFO_DIRTY = 17,
  MEMINFO_WRITEBACK = 18,
  MEMINFO_ANON_PAGES = 19,
  MEMINFO_MAPPED = 20,
  MEMINFO_SHMEM = 21,
  MEMINFO_SLAB = 22,
  MEMINFO_SLAB_RECLAIMABLE = 23,
  MEMINFO_SLAB_UNRECLAIMABLE = 24,
  MEMINFO_KERNEL_STACK = 25,
  MEMINFO_PAGE_TABLES = 26,
  MEMINFO_COMMIT_LIMIT = 27,
  MEMINFO_COMMITED_AS = 28,
  MEMINFO_VMALLOC_TOTAL = 29,
  MEMINFO_VMALLOC_USED = 30,
  MEMINFO_VMALLOC_CHUNK = 31,
  MEMINFO_CMA_TOTAL = 32,
  MEMINFO_CMA_FREE = 33,
};

const MeminfoCounters MeminfoCounters_MIN = MEMINFO_UNSPECIFIED;
const MeminfoCounters MeminfoCounters_MAX = MEMINFO_CMA_FREE;

enum VmstatCounters : int32_t {
  VMSTAT_UNSPECIFIED = 0,
  VMSTAT_NR_FREE_PAGES = 1,
  VMSTAT_NR_ALLOC_BATCH = 2,
  VMSTAT_NR_INACTIVE_ANON = 3,
  VMSTAT_NR_ACTIVE_ANON = 4,
  VMSTAT_NR_INACTIVE_FILE = 5,
  VMSTAT_NR_ACTIVE_FILE = 6,
  VMSTAT_NR_UNEVICTABLE = 7,
  VMSTAT_NR_MLOCK = 8,
  VMSTAT_NR_ANON_PAGES = 9,
  VMSTAT_NR_MAPPED = 10,
  VMSTAT_NR_FILE_PAGES = 11,
  VMSTAT_NR_DIRTY = 12,
  VMSTAT_NR_WRITEBACK = 13,
  VMSTAT_NR_SLAB_RECLAIMABLE = 14,
  VMSTAT_NR_SLAB_UNRECLAIMABLE = 15,
  VMSTAT_NR_PAGE_TABLE_PAGES = 16,
  VMSTAT_NR_KERNEL_STACK = 17,
  VMSTAT_NR_OVERHEAD = 18,
  VMSTAT_NR_UNSTABLE = 19,
  VMSTAT_NR_BOUNCE = 20,
  VMSTAT_NR_VMSCAN_WRITE = 21,
  VMSTAT_NR_VMSCAN_IMMEDIATE_RECLAIM = 22,
  VMSTAT_NR_WRITEBACK_TEMP = 23,
  VMSTAT_NR_ISOLATED_ANON = 24,
  VMSTAT_NR_ISOLATED_FILE = 25,
  VMSTAT_NR_SHMEM = 26,
  VMSTAT_NR_DIRTIED = 27,
  VMSTAT_NR_WRITTEN = 28,
  VMSTAT_NR_PAGES_SCANNED = 29,
  VMSTAT_WORKINGSET_REFAULT = 30,
  VMSTAT_WORKINGSET_ACTIVATE = 31,
  VMSTAT_WORKINGSET_NODERECLAIM = 32,
  VMSTAT_NR_ANON_TRANSPARENT_HUGEPAGES = 33,
  VMSTAT_NR_FREE_CMA = 34,
  VMSTAT_NR_SWAPCACHE = 35,
  VMSTAT_NR_DIRTY_THRESHOLD = 36,
  VMSTAT_NR_DIRTY_BACKGROUND_THRESHOLD = 37,
  VMSTAT_PGPGIN = 38,
  VMSTAT_PGPGOUT = 39,
  VMSTAT_PGPGOUTCLEAN = 40,
  VMSTAT_PSWPIN = 41,
  VMSTAT_PSWPOUT = 42,
  VMSTAT_PGALLOC_DMA = 43,
  VMSTAT_PGALLOC_NORMAL = 44,
  VMSTAT_PGALLOC_MOVABLE = 45,
  VMSTAT_PGFREE = 46,
  VMSTAT_PGACTIVATE = 47,
  VMSTAT_PGDEACTIVATE = 48,
  VMSTAT_PGFAULT = 49,
  VMSTAT_PGMAJFAULT = 50,
  VMSTAT_PGREFILL_DMA = 51,
  VMSTAT_PGREFILL_NORMAL = 52,
  VMSTAT_PGREFILL_MOVABLE = 53,
  VMSTAT_PGSTEAL_KSWAPD_DMA = 54,
  VMSTAT_PGSTEAL_KSWAPD_NORMAL = 55,
  VMSTAT_PGSTEAL_KSWAPD_MOVABLE = 56,
  VMSTAT_PGSTEAL_DIRECT_DMA = 57,
  VMSTAT_PGSTEAL_DIRECT_NORMAL = 58,
  VMSTAT_PGSTEAL_DIRECT_MOVABLE = 59,
  VMSTAT_PGSCAN_KSWAPD_DMA = 60,
  VMSTAT_PGSCAN_KSWAPD_NORMAL = 61,
  VMSTAT_PGSCAN_KSWAPD_MOVABLE = 62,
  VMSTAT_PGSCAN_DIRECT_DMA = 63,
  VMSTAT_PGSCAN_DIRECT_NORMAL = 64,
  VMSTAT_PGSCAN_DIRECT_MOVABLE = 65,
  VMSTAT_PGSCAN_DIRECT_THROTTLE = 66,
  VMSTAT_PGINODESTEAL = 67,
  VMSTAT_SLABS_SCANNED = 68,
  VMSTAT_KSWAPD_INODESTEAL = 69,
  VMSTAT_KSWAPD_LOW_WMARK_HIT_QUICKLY = 70,
  VMSTAT_KSWAPD_HIGH_WMARK_HIT_QUICKLY = 71,
  VMSTAT_PAGEOUTRUN = 72,
  VMSTAT_ALLOCSTALL = 73,
  VMSTAT_PGROTATED = 74,
  VMSTAT_DROP_PAGECACHE = 75,
  VMSTAT_DROP_SLAB = 76,
  VMSTAT_PGMIGRATE_SUCCESS = 77,
  VMSTAT_PGMIGRATE_FAIL = 78,
  VMSTAT_COMPACT_MIGRATE_SCANNED = 79,
  VMSTAT_COMPACT_FREE_SCANNED = 80,
  VMSTAT_COMPACT_ISOLATED = 81,
  VMSTAT_COMPACT_STALL = 82,
  VMSTAT_COMPACT_FAIL = 83,
  VMSTAT_COMPACT_SUCCESS = 84,
  VMSTAT_COMPACT_DAEMON_WAKE = 85,
  VMSTAT_UNEVICTABLE_PGS_CULLED = 86,
  VMSTAT_UNEVICTABLE_PGS_SCANNED = 87,
  VMSTAT_UNEVICTABLE_PGS_RESCUED = 88,
  VMSTAT_UNEVICTABLE_PGS_MLOCKED = 89,
  VMSTAT_UNEVICTABLE_PGS_MUNLOCKED = 90,
  VMSTAT_UNEVICTABLE_PGS_CLEARED = 91,
  VMSTAT_UNEVICTABLE_PGS_STRANDED = 92,
  VMSTAT_NR_ZSPAGES = 93,
  VMSTAT_NR_ION_HEAP = 94,
  VMSTAT_NR_GPU_HEAP = 95,
};

const VmstatCounters VmstatCounters_MIN = VMSTAT_UNSPECIFIED;
const VmstatCounters VmstatCounters_MAX = VMSTAT_NR_GPU_HEAP;

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/common/trace_stats.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_COMMON_TRACE_STATS_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_COMMON_TRACE_STATS_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class TraceStats_BufferStats;

class TraceStats_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/10, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  TraceStats_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TraceStats_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TraceStats_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_buffer_stats() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator buffer_stats() const { return GetRepeated(1); }
  bool has_producers_connected() const { return at<2>().valid(); }
  uint32_t producers_connected() const { return at<2>().as_uint32(); }
  bool has_producers_seen() const { return at<3>().valid(); }
  uint64_t producers_seen() const { return at<3>().as_uint64(); }
  bool has_data_sources_registered() const { return at<4>().valid(); }
  uint32_t data_sources_registered() const { return at<4>().as_uint32(); }
  bool has_data_sources_seen() const { return at<5>().valid(); }
  uint64_t data_sources_seen() const { return at<5>().as_uint64(); }
  bool has_tracing_sessions() const { return at<6>().valid(); }
  uint32_t tracing_sessions() const { return at<6>().as_uint32(); }
  bool has_total_buffers() const { return at<7>().valid(); }
  uint32_t total_buffers() const { return at<7>().as_uint32(); }
  bool has_chunks_discarded() const { return at<8>().valid(); }
  uint64_t chunks_discarded() const { return at<8>().as_uint64(); }
  bool has_patches_discarded() const { return at<9>().valid(); }
  uint64_t patches_discarded() const { return at<9>().as_uint64(); }
  bool has_invalid_packets() const { return at<10>().valid(); }
  uint64_t invalid_packets() const { return at<10>().as_uint64(); }
};

class TraceStats : public ::protozero::Message {
 public:
  using Decoder = TraceStats_Decoder;
  enum : int32_t {
    kBufferStatsFieldNumber = 1,
    kProducersConnectedFieldNumber = 2,
    kProducersSeenFieldNumber = 3,
    kDataSourcesRegisteredFieldNumber = 4,
    kDataSourcesSeenFieldNumber = 5,
    kTracingSessionsFieldNumber = 6,
    kTotalBuffersFieldNumber = 7,
    kChunksDiscardedFieldNumber = 8,
    kPatchesDiscardedFieldNumber = 9,
    kInvalidPacketsFieldNumber = 10,
  };
  using BufferStats = ::perfetto::protos::pbzero::TraceStats_BufferStats;
  template <typename T = TraceStats_BufferStats> T* add_buffer_stats() {
    return BeginNestedMessage<T>(1);
  }

  void set_producers_connected(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_producers_seen(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_data_sources_registered(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_data_sources_seen(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_tracing_sessions(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_total_buffers(uint32_t value) {
    AppendVarInt(7, value);
  }
  void set_chunks_discarded(uint64_t value) {
    AppendVarInt(8, value);
  }
  void set_patches_discarded(uint64_t value) {
    AppendVarInt(9, value);
  }
  void set_invalid_packets(uint64_t value) {
    AppendVarInt(10, value);
  }
};

class TraceStats_BufferStats_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/19, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TraceStats_BufferStats_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TraceStats_BufferStats_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TraceStats_BufferStats_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_buffer_size() const { return at<12>().valid(); }
  uint64_t buffer_size() const { return at<12>().as_uint64(); }
  bool has_bytes_written() const { return at<1>().valid(); }
  uint64_t bytes_written() const { return at<1>().as_uint64(); }
  bool has_bytes_overwritten() const { return at<13>().valid(); }
  uint64_t bytes_overwritten() const { return at<13>().as_uint64(); }
  bool has_bytes_read() const { return at<14>().valid(); }
  uint64_t bytes_read() const { return at<14>().as_uint64(); }
  bool has_padding_bytes_written() const { return at<15>().valid(); }
  uint64_t padding_bytes_written() const { return at<15>().as_uint64(); }
  bool has_padding_bytes_cleared() const { return at<16>().valid(); }
  uint64_t padding_bytes_cleared() const { return at<16>().as_uint64(); }
  bool has_chunks_written() const { return at<2>().valid(); }
  uint64_t chunks_written() const { return at<2>().as_uint64(); }
  bool has_chunks_rewritten() const { return at<10>().valid(); }
  uint64_t chunks_rewritten() const { return at<10>().as_uint64(); }
  bool has_chunks_overwritten() const { return at<3>().valid(); }
  uint64_t chunks_overwritten() const { return at<3>().as_uint64(); }
  bool has_chunks_discarded() const { return at<18>().valid(); }
  uint64_t chunks_discarded() const { return at<18>().as_uint64(); }
  bool has_chunks_read() const { return at<17>().valid(); }
  uint64_t chunks_read() const { return at<17>().as_uint64(); }
  bool has_chunks_committed_out_of_order() const { return at<11>().valid(); }
  uint64_t chunks_committed_out_of_order() const { return at<11>().as_uint64(); }
  bool has_write_wrap_count() const { return at<4>().valid(); }
  uint64_t write_wrap_count() const { return at<4>().as_uint64(); }
  bool has_patches_succeeded() const { return at<5>().valid(); }
  uint64_t patches_succeeded() const { return at<5>().as_uint64(); }
  bool has_patches_failed() const { return at<6>().valid(); }
  uint64_t patches_failed() const { return at<6>().as_uint64(); }
  bool has_readaheads_succeeded() const { return at<7>().valid(); }
  uint64_t readaheads_succeeded() const { return at<7>().as_uint64(); }
  bool has_readaheads_failed() const { return at<8>().valid(); }
  uint64_t readaheads_failed() const { return at<8>().as_uint64(); }
  bool has_abi_violations() const { return at<9>().valid(); }
  uint64_t abi_violations() const { return at<9>().as_uint64(); }
  bool has_trace_writer_packet_loss() const { return at<19>().valid(); }
  uint64_t trace_writer_packet_loss() const { return at<19>().as_uint64(); }
};

class TraceStats_BufferStats : public ::protozero::Message {
 public:
  using Decoder = TraceStats_BufferStats_Decoder;
  enum : int32_t {
    kBufferSizeFieldNumber = 12,
    kBytesWrittenFieldNumber = 1,
    kBytesOverwrittenFieldNumber = 13,
    kBytesReadFieldNumber = 14,
    kPaddingBytesWrittenFieldNumber = 15,
    kPaddingBytesClearedFieldNumber = 16,
    kChunksWrittenFieldNumber = 2,
    kChunksRewrittenFieldNumber = 10,
    kChunksOverwrittenFieldNumber = 3,
    kChunksDiscardedFieldNumber = 18,
    kChunksReadFieldNumber = 17,
    kChunksCommittedOutOfOrderFieldNumber = 11,
    kWriteWrapCountFieldNumber = 4,
    kPatchesSucceededFieldNumber = 5,
    kPatchesFailedFieldNumber = 6,
    kReadaheadsSucceededFieldNumber = 7,
    kReadaheadsFailedFieldNumber = 8,
    kAbiViolationsFieldNumber = 9,
    kTraceWriterPacketLossFieldNumber = 19,
  };
  void set_buffer_size(uint64_t value) {
    AppendVarInt(12, value);
  }
  void set_bytes_written(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_bytes_overwritten(uint64_t value) {
    AppendVarInt(13, value);
  }
  void set_bytes_read(uint64_t value) {
    AppendVarInt(14, value);
  }
  void set_padding_bytes_written(uint64_t value) {
    AppendVarInt(15, value);
  }
  void set_padding_bytes_cleared(uint64_t value) {
    AppendVarInt(16, value);
  }
  void set_chunks_written(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_chunks_rewritten(uint64_t value) {
    AppendVarInt(10, value);
  }
  void set_chunks_overwritten(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_chunks_discarded(uint64_t value) {
    AppendVarInt(18, value);
  }
  void set_chunks_read(uint64_t value) {
    AppendVarInt(17, value);
  }
  void set_chunks_committed_out_of_order(uint64_t value) {
    AppendVarInt(11, value);
  }
  void set_write_wrap_count(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_patches_succeeded(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_patches_failed(uint64_t value) {
    AppendVarInt(6, value);
  }
  void set_readaheads_succeeded(uint64_t value) {
    AppendVarInt(7, value);
  }
  void set_readaheads_failed(uint64_t value) {
    AppendVarInt(8, value);
  }
  void set_abi_violations(uint64_t value) {
    AppendVarInt(9, value);
  }
  void set_trace_writer_packet_loss(uint64_t value) {
    AppendVarInt(19, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/common/tracing_service_state.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_COMMON_TRACING_SERVICE_STATE_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_COMMON_TRACING_SERVICE_STATE_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class DataSourceDescriptor;
class TracingServiceState_DataSource;
class TracingServiceState_Producer;

class TracingServiceState_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  TracingServiceState_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TracingServiceState_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TracingServiceState_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_producers() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator producers() const { return GetRepeated(1); }
  bool has_data_sources() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator data_sources() const { return GetRepeated(2); }
  bool has_num_sessions() const { return at<3>().valid(); }
  int32_t num_sessions() const { return at<3>().as_int32(); }
  bool has_num_sessions_started() const { return at<4>().valid(); }
  int32_t num_sessions_started() const { return at<4>().as_int32(); }
};

class TracingServiceState : public ::protozero::Message {
 public:
  using Decoder = TracingServiceState_Decoder;
  enum : int32_t {
    kProducersFieldNumber = 1,
    kDataSourcesFieldNumber = 2,
    kNumSessionsFieldNumber = 3,
    kNumSessionsStartedFieldNumber = 4,
  };
  using Producer = ::perfetto::protos::pbzero::TracingServiceState_Producer;
  using DataSource = ::perfetto::protos::pbzero::TracingServiceState_DataSource;
  template <typename T = TracingServiceState_Producer> T* add_producers() {
    return BeginNestedMessage<T>(1);
  }

  template <typename T = TracingServiceState_DataSource> T* add_data_sources() {
    return BeginNestedMessage<T>(2);
  }

  void set_num_sessions(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_num_sessions_started(int32_t value) {
    AppendVarInt(4, value);
  }
};

class TracingServiceState_DataSource_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TracingServiceState_DataSource_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TracingServiceState_DataSource_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TracingServiceState_DataSource_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_ds_descriptor() const { return at<1>().valid(); }
  ::protozero::ConstBytes ds_descriptor() const { return at<1>().as_bytes(); }
  bool has_producer_id() const { return at<2>().valid(); }
  int32_t producer_id() const { return at<2>().as_int32(); }
};

class TracingServiceState_DataSource : public ::protozero::Message {
 public:
  using Decoder = TracingServiceState_DataSource_Decoder;
  enum : int32_t {
    kDsDescriptorFieldNumber = 1,
    kProducerIdFieldNumber = 2,
  };
  template <typename T = DataSourceDescriptor> T* set_ds_descriptor() {
    return BeginNestedMessage<T>(1);
  }

  void set_producer_id(int32_t value) {
    AppendVarInt(2, value);
  }
};

class TracingServiceState_Producer_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TracingServiceState_Producer_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TracingServiceState_Producer_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TracingServiceState_Producer_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_id() const { return at<1>().valid(); }
  int32_t id() const { return at<1>().as_int32(); }
  bool has_name() const { return at<2>().valid(); }
  ::protozero::ConstChars name() const { return at<2>().as_string(); }
  bool has_uid() const { return at<3>().valid(); }
  int32_t uid() const { return at<3>().as_int32(); }
};

class TracingServiceState_Producer : public ::protozero::Message {
 public:
  using Decoder = TracingServiceState_Producer_Decoder;
  enum : int32_t {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kUidFieldNumber = 3,
  };
  void set_id(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_name(const char* value) {
    AppendString(2, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_name(const char* value, size_t size) {
    AppendBytes(2, value, size);
  }
  void set_uid(int32_t value) {
    AppendVarInt(3, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/common/track_event_descriptor.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_COMMON_TRACK_EVENT_DESCRIPTOR_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_COMMON_TRACK_EVENT_DESCRIPTOR_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class TrackEventDescriptor_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  TrackEventDescriptor_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TrackEventDescriptor_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TrackEventDescriptor_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_available_categories() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator available_categories() const { return GetRepeated(1); }
};

class TrackEventDescriptor : public ::protozero::Message {
 public:
  using Decoder = TrackEventDescriptor_Decoder;
  enum : int32_t {
    kAvailableCategoriesFieldNumber = 1,
  };
  void add_available_categories(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void add_available_categories(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/config/android/android_log_config.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_ANDROID_ANDROID_LOG_CONFIG_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_ANDROID_ANDROID_LOG_CONFIG_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

enum AndroidLogId : int32_t;
enum AndroidLogPriority : int32_t;

class AndroidLogConfig_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  AndroidLogConfig_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit AndroidLogConfig_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit AndroidLogConfig_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_log_ids() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator log_ids() const { return GetRepeated(1); }
  bool has_min_prio() const { return at<3>().valid(); }
  int32_t min_prio() const { return at<3>().as_int32(); }
  bool has_filter_tags() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator filter_tags() const { return GetRepeated(4); }
};

class AndroidLogConfig : public ::protozero::Message {
 public:
  using Decoder = AndroidLogConfig_Decoder;
  enum : int32_t {
    kLogIdsFieldNumber = 1,
    kMinPrioFieldNumber = 3,
    kFilterTagsFieldNumber = 4,
  };
  void add_log_ids(::perfetto::protos::pbzero::AndroidLogId value) {
    AppendTinyVarInt(1, value);
  }
  void set_min_prio(::perfetto::protos::pbzero::AndroidLogPriority value) {
    AppendTinyVarInt(3, value);
  }
  void add_filter_tags(const char* value) {
    AppendString(4, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void add_filter_tags(const char* value, size_t size) {
    AppendBytes(4, value, size);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/config/android/packages_list_config.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_ANDROID_PACKAGES_LIST_CONFIG_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_ANDROID_PACKAGES_LIST_CONFIG_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class PackagesListConfig_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  PackagesListConfig_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit PackagesListConfig_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit PackagesListConfig_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_package_name_filter() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator package_name_filter() const { return GetRepeated(1); }
};

class PackagesListConfig : public ::protozero::Message {
 public:
  using Decoder = PackagesListConfig_Decoder;
  enum : int32_t {
    kPackageNameFilterFieldNumber = 1,
  };
  void add_package_name_filter(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void add_package_name_filter(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/config/ftrace/ftrace_config.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_FTRACE_FTRACE_CONFIG_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_FTRACE_FTRACE_CONFIG_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class FtraceConfig_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/11, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  FtraceConfig_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit FtraceConfig_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit FtraceConfig_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_ftrace_events() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator ftrace_events() const { return GetRepeated(1); }
  bool has_atrace_categories() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator atrace_categories() const { return GetRepeated(2); }
  bool has_atrace_apps() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator atrace_apps() const { return GetRepeated(3); }
  bool has_buffer_size_kb() const { return at<10>().valid(); }
  uint32_t buffer_size_kb() const { return at<10>().as_uint32(); }
  bool has_drain_period_ms() const { return at<11>().valid(); }
  uint32_t drain_period_ms() const { return at<11>().as_uint32(); }
};

class FtraceConfig : public ::protozero::Message {
 public:
  using Decoder = FtraceConfig_Decoder;
  enum : int32_t {
    kFtraceEventsFieldNumber = 1,
    kAtraceCategoriesFieldNumber = 2,
    kAtraceAppsFieldNumber = 3,
    kBufferSizeKbFieldNumber = 10,
    kDrainPeriodMsFieldNumber = 11,
  };
  void add_ftrace_events(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void add_ftrace_events(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void add_atrace_categories(const char* value) {
    AppendString(2, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void add_atrace_categories(const char* value, size_t size) {
    AppendBytes(2, value, size);
  }
  void add_atrace_apps(const char* value) {
    AppendString(3, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void add_atrace_apps(const char* value, size_t size) {
    AppendBytes(3, value, size);
  }
  void set_buffer_size_kb(uint32_t value) {
    AppendVarInt(10, value);
  }
  void set_drain_period_ms(uint32_t value) {
    AppendVarInt(11, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/config/gpu/gpu_counter_config.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_GPU_GPU_COUNTER_CONFIG_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_GPU_GPU_COUNTER_CONFIG_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class GpuCounterConfig_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  GpuCounterConfig_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit GpuCounterConfig_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit GpuCounterConfig_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_counter_period_ns() const { return at<1>().valid(); }
  uint64_t counter_period_ns() const { return at<1>().as_uint64(); }
  bool has_counter_ids() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator counter_ids() const { return GetRepeated(2); }
  bool has_instrumented_sampling() const { return at<3>().valid(); }
  bool instrumented_sampling() const { return at<3>().as_bool(); }
  bool has_fix_gpu_clock() const { return at<4>().valid(); }
  bool fix_gpu_clock() const { return at<4>().as_bool(); }
};

class GpuCounterConfig : public ::protozero::Message {
 public:
  using Decoder = GpuCounterConfig_Decoder;
  enum : int32_t {
    kCounterPeriodNsFieldNumber = 1,
    kCounterIdsFieldNumber = 2,
    kInstrumentedSamplingFieldNumber = 3,
    kFixGpuClockFieldNumber = 4,
  };
  void set_counter_period_ns(uint64_t value) {
    AppendVarInt(1, value);
  }
  void add_counter_ids(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_instrumented_sampling(bool value) {
    AppendTinyVarInt(3, value);
  }
  void set_fix_gpu_clock(bool value) {
    AppendTinyVarInt(4, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/config/inode_file/inode_file_config.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_INODE_FILE_INODE_FILE_CONFIG_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_INODE_FILE_INODE_FILE_CONFIG_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class InodeFileConfig_MountPointMappingEntry;

class InodeFileConfig_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  InodeFileConfig_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit InodeFileConfig_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit InodeFileConfig_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_scan_interval_ms() const { return at<1>().valid(); }
  uint32_t scan_interval_ms() const { return at<1>().as_uint32(); }
  bool has_scan_delay_ms() const { return at<2>().valid(); }
  uint32_t scan_delay_ms() const { return at<2>().as_uint32(); }
  bool has_scan_batch_size() const { return at<3>().valid(); }
  uint32_t scan_batch_size() const { return at<3>().as_uint32(); }
  bool has_do_not_scan() const { return at<4>().valid(); }
  bool do_not_scan() const { return at<4>().as_bool(); }
  bool has_scan_mount_points() const { return at<5>().valid(); }
  ::protozero::RepeatedFieldIterator scan_mount_points() const { return GetRepeated(5); }
  bool has_mount_point_mapping() const { return at<6>().valid(); }
  ::protozero::RepeatedFieldIterator mount_point_mapping() const { return GetRepeated(6); }
};

class InodeFileConfig : public ::protozero::Message {
 public:
  using Decoder = InodeFileConfig_Decoder;
  enum : int32_t {
    kScanIntervalMsFieldNumber = 1,
    kScanDelayMsFieldNumber = 2,
    kScanBatchSizeFieldNumber = 3,
    kDoNotScanFieldNumber = 4,
    kScanMountPointsFieldNumber = 5,
    kMountPointMappingFieldNumber = 6,
  };
  using MountPointMappingEntry = ::perfetto::protos::pbzero::InodeFileConfig_MountPointMappingEntry;
  void set_scan_interval_ms(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_scan_delay_ms(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_scan_batch_size(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_do_not_scan(bool value) {
    AppendTinyVarInt(4, value);
  }
  void add_scan_mount_points(const char* value) {
    AppendString(5, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void add_scan_mount_points(const char* value, size_t size) {
    AppendBytes(5, value, size);
  }
  template <typename T = InodeFileConfig_MountPointMappingEntry> T* add_mount_point_mapping() {
    return BeginNestedMessage<T>(6);
  }

};

class InodeFileConfig_MountPointMappingEntry_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  InodeFileConfig_MountPointMappingEntry_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit InodeFileConfig_MountPointMappingEntry_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit InodeFileConfig_MountPointMappingEntry_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_mountpoint() const { return at<1>().valid(); }
  ::protozero::ConstChars mountpoint() const { return at<1>().as_string(); }
  bool has_scan_roots() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator scan_roots() const { return GetRepeated(2); }
};

class InodeFileConfig_MountPointMappingEntry : public ::protozero::Message {
 public:
  using Decoder = InodeFileConfig_MountPointMappingEntry_Decoder;
  enum : int32_t {
    kMountpointFieldNumber = 1,
    kScanRootsFieldNumber = 2,
  };
  void set_mountpoint(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_mountpoint(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void add_scan_roots(const char* value) {
    AppendString(2, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void add_scan_roots(const char* value, size_t size) {
    AppendBytes(2, value, size);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/config/power/android_power_config.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_POWER_ANDROID_POWER_CONFIG_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_POWER_ANDROID_POWER_CONFIG_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

enum AndroidPowerConfig_BatteryCounters : int32_t;

enum AndroidPowerConfig_BatteryCounters : int32_t {
  AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_UNSPECIFIED = 0,
  AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_CHARGE = 1,
  AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_CAPACITY_PERCENT = 2,
  AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_CURRENT = 3,
  AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_CURRENT_AVG = 4,
};

const AndroidPowerConfig_BatteryCounters AndroidPowerConfig_BatteryCounters_MIN = AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_UNSPECIFIED;
const AndroidPowerConfig_BatteryCounters AndroidPowerConfig_BatteryCounters_MAX = AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_CURRENT_AVG;

class AndroidPowerConfig_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  AndroidPowerConfig_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit AndroidPowerConfig_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit AndroidPowerConfig_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_battery_poll_ms() const { return at<1>().valid(); }
  uint32_t battery_poll_ms() const { return at<1>().as_uint32(); }
  bool has_battery_counters() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator battery_counters() const { return GetRepeated(2); }
  bool has_collect_power_rails() const { return at<3>().valid(); }
  bool collect_power_rails() const { return at<3>().as_bool(); }
};

class AndroidPowerConfig : public ::protozero::Message {
 public:
  using Decoder = AndroidPowerConfig_Decoder;
  enum : int32_t {
    kBatteryPollMsFieldNumber = 1,
    kBatteryCountersFieldNumber = 2,
    kCollectPowerRailsFieldNumber = 3,
  };
  using BatteryCounters = ::perfetto::protos::pbzero::AndroidPowerConfig_BatteryCounters;
  static const BatteryCounters BATTERY_COUNTER_UNSPECIFIED = AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_UNSPECIFIED;
  static const BatteryCounters BATTERY_COUNTER_CHARGE = AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_CHARGE;
  static const BatteryCounters BATTERY_COUNTER_CAPACITY_PERCENT = AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_CAPACITY_PERCENT;
  static const BatteryCounters BATTERY_COUNTER_CURRENT = AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_CURRENT;
  static const BatteryCounters BATTERY_COUNTER_CURRENT_AVG = AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_CURRENT_AVG;
  void set_battery_poll_ms(uint32_t value) {
    AppendVarInt(1, value);
  }
  void add_battery_counters(::perfetto::protos::pbzero::AndroidPowerConfig_BatteryCounters value) {
    AppendTinyVarInt(2, value);
  }
  void set_collect_power_rails(bool value) {
    AppendTinyVarInt(3, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/config/process_stats/process_stats_config.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_PROCESS_STATS_PROCESS_STATS_CONFIG_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_PROCESS_STATS_PROCESS_STATS_CONFIG_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

enum ProcessStatsConfig_Quirks : int32_t;

enum ProcessStatsConfig_Quirks : int32_t {
  ProcessStatsConfig_Quirks_QUIRKS_UNSPECIFIED = 0,
  ProcessStatsConfig_Quirks_DISABLE_INITIAL_DUMP = 1,
  ProcessStatsConfig_Quirks_DISABLE_ON_DEMAND = 2,
};

const ProcessStatsConfig_Quirks ProcessStatsConfig_Quirks_MIN = ProcessStatsConfig_Quirks_QUIRKS_UNSPECIFIED;
const ProcessStatsConfig_Quirks ProcessStatsConfig_Quirks_MAX = ProcessStatsConfig_Quirks_DISABLE_ON_DEMAND;

class ProcessStatsConfig_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  ProcessStatsConfig_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ProcessStatsConfig_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ProcessStatsConfig_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_quirks() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator quirks() const { return GetRepeated(1); }
  bool has_scan_all_processes_on_start() const { return at<2>().valid(); }
  bool scan_all_processes_on_start() const { return at<2>().as_bool(); }
  bool has_record_thread_names() const { return at<3>().valid(); }
  bool record_thread_names() const { return at<3>().as_bool(); }
  bool has_proc_stats_poll_ms() const { return at<4>().valid(); }
  uint32_t proc_stats_poll_ms() const { return at<4>().as_uint32(); }
  bool has_proc_stats_cache_ttl_ms() const { return at<6>().valid(); }
  uint32_t proc_stats_cache_ttl_ms() const { return at<6>().as_uint32(); }
};

class ProcessStatsConfig : public ::protozero::Message {
 public:
  using Decoder = ProcessStatsConfig_Decoder;
  enum : int32_t {
    kQuirksFieldNumber = 1,
    kScanAllProcessesOnStartFieldNumber = 2,
    kRecordThreadNamesFieldNumber = 3,
    kProcStatsPollMsFieldNumber = 4,
    kProcStatsCacheTtlMsFieldNumber = 6,
  };
  using Quirks = ::perfetto::protos::pbzero::ProcessStatsConfig_Quirks;
  static const Quirks QUIRKS_UNSPECIFIED = ProcessStatsConfig_Quirks_QUIRKS_UNSPECIFIED;
  static const Quirks DISABLE_INITIAL_DUMP = ProcessStatsConfig_Quirks_DISABLE_INITIAL_DUMP;
  static const Quirks DISABLE_ON_DEMAND = ProcessStatsConfig_Quirks_DISABLE_ON_DEMAND;
  void add_quirks(::perfetto::protos::pbzero::ProcessStatsConfig_Quirks value) {
    AppendTinyVarInt(1, value);
  }
  void set_scan_all_processes_on_start(bool value) {
    AppendTinyVarInt(2, value);
  }
  void set_record_thread_names(bool value) {
    AppendTinyVarInt(3, value);
  }
  void set_proc_stats_poll_ms(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_proc_stats_cache_ttl_ms(uint32_t value) {
    AppendVarInt(6, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/config/profiling/heapprofd_config.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_PROFILING_HEAPPROFD_CONFIG_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_PROFILING_HEAPPROFD_CONFIG_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class HeapprofdConfig_ContinuousDumpConfig;

class HeapprofdConfig_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/13, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  HeapprofdConfig_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit HeapprofdConfig_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit HeapprofdConfig_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_sampling_interval_bytes() const { return at<1>().valid(); }
  uint64_t sampling_interval_bytes() const { return at<1>().as_uint64(); }
  bool has_process_cmdline() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator process_cmdline() const { return GetRepeated(2); }
  bool has_pid() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator pid() const { return GetRepeated(4); }
  bool has_all() const { return at<5>().valid(); }
  bool all() const { return at<5>().as_bool(); }
  bool has_skip_symbol_prefix() const { return at<7>().valid(); }
  ::protozero::RepeatedFieldIterator skip_symbol_prefix() const { return GetRepeated(7); }
  bool has_continuous_dump_config() const { return at<6>().valid(); }
  ::protozero::ConstBytes continuous_dump_config() const { return at<6>().as_bytes(); }
  bool has_shmem_size_bytes() const { return at<8>().valid(); }
  uint64_t shmem_size_bytes() const { return at<8>().as_uint64(); }
  bool has_block_client() const { return at<9>().valid(); }
  bool block_client() const { return at<9>().as_bool(); }
  bool has_no_startup() const { return at<10>().valid(); }
  bool no_startup() const { return at<10>().as_bool(); }
  bool has_no_running() const { return at<11>().valid(); }
  bool no_running() const { return at<11>().as_bool(); }
  bool has_idle_allocations() const { return at<12>().valid(); }
  bool idle_allocations() const { return at<12>().as_bool(); }
  bool has_dump_at_max() const { return at<13>().valid(); }
  bool dump_at_max() const { return at<13>().as_bool(); }
};

class HeapprofdConfig : public ::protozero::Message {
 public:
  using Decoder = HeapprofdConfig_Decoder;
  enum : int32_t {
    kSamplingIntervalBytesFieldNumber = 1,
    kProcessCmdlineFieldNumber = 2,
    kPidFieldNumber = 4,
    kAllFieldNumber = 5,
    kSkipSymbolPrefixFieldNumber = 7,
    kContinuousDumpConfigFieldNumber = 6,
    kShmemSizeBytesFieldNumber = 8,
    kBlockClientFieldNumber = 9,
    kNoStartupFieldNumber = 10,
    kNoRunningFieldNumber = 11,
    kIdleAllocationsFieldNumber = 12,
    kDumpAtMaxFieldNumber = 13,
  };
  using ContinuousDumpConfig = ::perfetto::protos::pbzero::HeapprofdConfig_ContinuousDumpConfig;
  void set_sampling_interval_bytes(uint64_t value) {
    AppendVarInt(1, value);
  }
  void add_process_cmdline(const char* value) {
    AppendString(2, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void add_process_cmdline(const char* value, size_t size) {
    AppendBytes(2, value, size);
  }
  void add_pid(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_all(bool value) {
    AppendTinyVarInt(5, value);
  }
  void add_skip_symbol_prefix(const char* value) {
    AppendString(7, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void add_skip_symbol_prefix(const char* value, size_t size) {
    AppendBytes(7, value, size);
  }
  template <typename T = HeapprofdConfig_ContinuousDumpConfig> T* set_continuous_dump_config() {
    return BeginNestedMessage<T>(6);
  }

  void set_shmem_size_bytes(uint64_t value) {
    AppendVarInt(8, value);
  }
  void set_block_client(bool value) {
    AppendTinyVarInt(9, value);
  }
  void set_no_startup(bool value) {
    AppendTinyVarInt(10, value);
  }
  void set_no_running(bool value) {
    AppendTinyVarInt(11, value);
  }
  void set_idle_allocations(bool value) {
    AppendTinyVarInt(12, value);
  }
  void set_dump_at_max(bool value) {
    AppendTinyVarInt(13, value);
  }
};

class HeapprofdConfig_ContinuousDumpConfig_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  HeapprofdConfig_ContinuousDumpConfig_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit HeapprofdConfig_ContinuousDumpConfig_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit HeapprofdConfig_ContinuousDumpConfig_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dump_phase_ms() const { return at<5>().valid(); }
  uint32_t dump_phase_ms() const { return at<5>().as_uint32(); }
  bool has_dump_interval_ms() const { return at<6>().valid(); }
  uint32_t dump_interval_ms() const { return at<6>().as_uint32(); }
};

class HeapprofdConfig_ContinuousDumpConfig : public ::protozero::Message {
 public:
  using Decoder = HeapprofdConfig_ContinuousDumpConfig_Decoder;
  enum : int32_t {
    kDumpPhaseMsFieldNumber = 5,
    kDumpIntervalMsFieldNumber = 6,
  };
  void set_dump_phase_ms(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_dump_interval_ms(uint32_t value) {
    AppendVarInt(6, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/config/sys_stats/sys_stats_config.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_SYS_STATS_SYS_STATS_CONFIG_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_SYS_STATS_SYS_STATS_CONFIG_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

enum MeminfoCounters : int32_t;
enum SysStatsConfig_StatCounters : int32_t;
enum VmstatCounters : int32_t;

enum SysStatsConfig_StatCounters : int32_t {
  SysStatsConfig_StatCounters_STAT_UNSPECIFIED = 0,
  SysStatsConfig_StatCounters_STAT_CPU_TIMES = 1,
  SysStatsConfig_StatCounters_STAT_IRQ_COUNTS = 2,
  SysStatsConfig_StatCounters_STAT_SOFTIRQ_COUNTS = 3,
  SysStatsConfig_StatCounters_STAT_FORK_COUNT = 4,
};

const SysStatsConfig_StatCounters SysStatsConfig_StatCounters_MIN = SysStatsConfig_StatCounters_STAT_UNSPECIFIED;
const SysStatsConfig_StatCounters SysStatsConfig_StatCounters_MAX = SysStatsConfig_StatCounters_STAT_FORK_COUNT;

class SysStatsConfig_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  SysStatsConfig_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SysStatsConfig_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SysStatsConfig_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_meminfo_period_ms() const { return at<1>().valid(); }
  uint32_t meminfo_period_ms() const { return at<1>().as_uint32(); }
  bool has_meminfo_counters() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator meminfo_counters() const { return GetRepeated(2); }
  bool has_vmstat_period_ms() const { return at<3>().valid(); }
  uint32_t vmstat_period_ms() const { return at<3>().as_uint32(); }
  bool has_vmstat_counters() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator vmstat_counters() const { return GetRepeated(4); }
  bool has_stat_period_ms() const { return at<5>().valid(); }
  uint32_t stat_period_ms() const { return at<5>().as_uint32(); }
  bool has_stat_counters() const { return at<6>().valid(); }
  ::protozero::RepeatedFieldIterator stat_counters() const { return GetRepeated(6); }
};

class SysStatsConfig : public ::protozero::Message {
 public:
  using Decoder = SysStatsConfig_Decoder;
  enum : int32_t {
    kMeminfoPeriodMsFieldNumber = 1,
    kMeminfoCountersFieldNumber = 2,
    kVmstatPeriodMsFieldNumber = 3,
    kVmstatCountersFieldNumber = 4,
    kStatPeriodMsFieldNumber = 5,
    kStatCountersFieldNumber = 6,
  };
  using StatCounters = ::perfetto::protos::pbzero::SysStatsConfig_StatCounters;
  static const StatCounters STAT_UNSPECIFIED = SysStatsConfig_StatCounters_STAT_UNSPECIFIED;
  static const StatCounters STAT_CPU_TIMES = SysStatsConfig_StatCounters_STAT_CPU_TIMES;
  static const StatCounters STAT_IRQ_COUNTS = SysStatsConfig_StatCounters_STAT_IRQ_COUNTS;
  static const StatCounters STAT_SOFTIRQ_COUNTS = SysStatsConfig_StatCounters_STAT_SOFTIRQ_COUNTS;
  static const StatCounters STAT_FORK_COUNT = SysStatsConfig_StatCounters_STAT_FORK_COUNT;
  void set_meminfo_period_ms(uint32_t value) {
    AppendVarInt(1, value);
  }
  void add_meminfo_counters(::perfetto::protos::pbzero::MeminfoCounters value) {
    AppendTinyVarInt(2, value);
  }
  void set_vmstat_period_ms(uint32_t value) {
    AppendVarInt(3, value);
  }
  void add_vmstat_counters(::perfetto::protos::pbzero::VmstatCounters value) {
    AppendTinyVarInt(4, value);
  }
  void set_stat_period_ms(uint32_t value) {
    AppendVarInt(5, value);
  }
  void add_stat_counters(::perfetto::protos::pbzero::SysStatsConfig_StatCounters value) {
    AppendTinyVarInt(6, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/config/chrome/chrome_config.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_CHROME_CHROME_CONFIG_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_CHROME_CHROME_CONFIG_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class ChromeConfig_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ChromeConfig_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ChromeConfig_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ChromeConfig_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_trace_config() const { return at<1>().valid(); }
  ::protozero::ConstChars trace_config() const { return at<1>().as_string(); }
  bool has_privacy_filtering_enabled() const { return at<2>().valid(); }
  bool privacy_filtering_enabled() const { return at<2>().as_bool(); }
};

class ChromeConfig : public ::protozero::Message {
 public:
  using Decoder = ChromeConfig_Decoder;
  enum : int32_t {
    kTraceConfigFieldNumber = 1,
    kPrivacyFilteringEnabledFieldNumber = 2,
  };
  void set_trace_config(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_trace_config(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_privacy_filtering_enabled(bool value) {
    AppendTinyVarInt(2, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/config/data_source_config.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_DATA_SOURCE_CONFIG_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_DATA_SOURCE_CONFIG_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class AndroidLogConfig;
class AndroidPowerConfig;
class ChromeConfig;
class FtraceConfig;
class GpuCounterConfig;
class HeapprofdConfig;
class InodeFileConfig;
class PackagesListConfig;
class ProcessStatsConfig;
class SysStatsConfig;
class TestConfig;

class DataSourceConfig_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/109, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  DataSourceConfig_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit DataSourceConfig_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit DataSourceConfig_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_target_buffer() const { return at<2>().valid(); }
  uint32_t target_buffer() const { return at<2>().as_uint32(); }
  bool has_trace_duration_ms() const { return at<3>().valid(); }
  uint32_t trace_duration_ms() const { return at<3>().as_uint32(); }
  bool has_stop_timeout_ms() const { return at<7>().valid(); }
  uint32_t stop_timeout_ms() const { return at<7>().as_uint32(); }
  bool has_enable_extra_guardrails() const { return at<6>().valid(); }
  bool enable_extra_guardrails() const { return at<6>().as_bool(); }
  bool has_tracing_session_id() const { return at<4>().valid(); }
  uint64_t tracing_session_id() const { return at<4>().as_uint64(); }
  bool has_ftrace_config() const { return at<100>().valid(); }
  ::protozero::ConstBytes ftrace_config() const { return at<100>().as_bytes(); }
  bool has_inode_file_config() const { return at<102>().valid(); }
  ::protozero::ConstBytes inode_file_config() const { return at<102>().as_bytes(); }
  bool has_process_stats_config() const { return at<103>().valid(); }
  ::protozero::ConstBytes process_stats_config() const { return at<103>().as_bytes(); }
  bool has_sys_stats_config() const { return at<104>().valid(); }
  ::protozero::ConstBytes sys_stats_config() const { return at<104>().as_bytes(); }
  bool has_heapprofd_config() const { return at<105>().valid(); }
  ::protozero::ConstBytes heapprofd_config() const { return at<105>().as_bytes(); }
  bool has_android_power_config() const { return at<106>().valid(); }
  ::protozero::ConstBytes android_power_config() const { return at<106>().as_bytes(); }
  bool has_android_log_config() const { return at<107>().valid(); }
  ::protozero::ConstBytes android_log_config() const { return at<107>().as_bytes(); }
  bool has_gpu_counter_config() const { return at<108>().valid(); }
  ::protozero::ConstBytes gpu_counter_config() const { return at<108>().as_bytes(); }
  bool has_packages_list_config() const { return at<109>().valid(); }
  ::protozero::ConstBytes packages_list_config() const { return at<109>().as_bytes(); }
  bool has_chrome_config() const { return at<101>().valid(); }
  ::protozero::ConstBytes chrome_config() const { return at<101>().as_bytes(); }
  // field legacy_config omitted because its id is too high
  // field for_testing omitted because its id is too high
};

class DataSourceConfig : public ::protozero::Message {
 public:
  using Decoder = DataSourceConfig_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kTargetBufferFieldNumber = 2,
    kTraceDurationMsFieldNumber = 3,
    kStopTimeoutMsFieldNumber = 7,
    kEnableExtraGuardrailsFieldNumber = 6,
    kTracingSessionIdFieldNumber = 4,
    kFtraceConfigFieldNumber = 100,
    kInodeFileConfigFieldNumber = 102,
    kProcessStatsConfigFieldNumber = 103,
    kSysStatsConfigFieldNumber = 104,
    kHeapprofdConfigFieldNumber = 105,
    kAndroidPowerConfigFieldNumber = 106,
    kAndroidLogConfigFieldNumber = 107,
    kGpuCounterConfigFieldNumber = 108,
    kPackagesListConfigFieldNumber = 109,
    kChromeConfigFieldNumber = 101,
    kLegacyConfigFieldNumber = 1000,
    kForTestingFieldNumber = 1001,
  };
  void set_name(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_name(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_target_buffer(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_trace_duration_ms(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_stop_timeout_ms(uint32_t value) {
    AppendVarInt(7, value);
  }
  void set_enable_extra_guardrails(bool value) {
    AppendTinyVarInt(6, value);
  }
  void set_tracing_session_id(uint64_t value) {
    AppendVarInt(4, value);
  }
  template <typename T = FtraceConfig> T* set_ftrace_config() {
    return BeginNestedMessage<T>(100);
  }

  template <typename T = InodeFileConfig> T* set_inode_file_config() {
    return BeginNestedMessage<T>(102);
  }

  template <typename T = ProcessStatsConfig> T* set_process_stats_config() {
    return BeginNestedMessage<T>(103);
  }

  template <typename T = SysStatsConfig> T* set_sys_stats_config() {
    return BeginNestedMessage<T>(104);
  }

  template <typename T = HeapprofdConfig> T* set_heapprofd_config() {
    return BeginNestedMessage<T>(105);
  }

  template <typename T = AndroidPowerConfig> T* set_android_power_config() {
    return BeginNestedMessage<T>(106);
  }

  template <typename T = AndroidLogConfig> T* set_android_log_config() {
    return BeginNestedMessage<T>(107);
  }

  template <typename T = GpuCounterConfig> T* set_gpu_counter_config() {
    return BeginNestedMessage<T>(108);
  }

  template <typename T = PackagesListConfig> T* set_packages_list_config() {
    return BeginNestedMessage<T>(109);
  }

  template <typename T = ChromeConfig> T* set_chrome_config() {
    return BeginNestedMessage<T>(101);
  }

  void set_legacy_config(const char* value) {
    AppendString(1000, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_legacy_config(const char* value, size_t size) {
    AppendBytes(1000, value, size);
  }
  template <typename T = TestConfig> T* set_for_testing() {
    return BeginNestedMessage<T>(1001);
  }

};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/config/test_config.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_TEST_CONFIG_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_TEST_CONFIG_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class TestConfig_DummyFields;

class TestConfig_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TestConfig_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TestConfig_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TestConfig_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_message_count() const { return at<1>().valid(); }
  uint32_t message_count() const { return at<1>().as_uint32(); }
  bool has_max_messages_per_second() const { return at<2>().valid(); }
  uint32_t max_messages_per_second() const { return at<2>().as_uint32(); }
  bool has_seed() const { return at<3>().valid(); }
  uint32_t seed() const { return at<3>().as_uint32(); }
  bool has_message_size() const { return at<4>().valid(); }
  uint32_t message_size() const { return at<4>().as_uint32(); }
  bool has_send_batch_on_register() const { return at<5>().valid(); }
  bool send_batch_on_register() const { return at<5>().as_bool(); }
  bool has_dummy_fields() const { return at<6>().valid(); }
  ::protozero::ConstBytes dummy_fields() const { return at<6>().as_bytes(); }
};

class TestConfig : public ::protozero::Message {
 public:
  using Decoder = TestConfig_Decoder;
  enum : int32_t {
    kMessageCountFieldNumber = 1,
    kMaxMessagesPerSecondFieldNumber = 2,
    kSeedFieldNumber = 3,
    kMessageSizeFieldNumber = 4,
    kSendBatchOnRegisterFieldNumber = 5,
    kDummyFieldsFieldNumber = 6,
  };
  using DummyFields = ::perfetto::protos::pbzero::TestConfig_DummyFields;
  void set_message_count(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_max_messages_per_second(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_seed(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_message_size(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_send_batch_on_register(bool value) {
    AppendTinyVarInt(5, value);
  }
  template <typename T = TestConfig_DummyFields> T* set_dummy_fields() {
    return BeginNestedMessage<T>(6);
  }

};

class TestConfig_DummyFields_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/14, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TestConfig_DummyFields_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TestConfig_DummyFields_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TestConfig_DummyFields_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_field_uint32() const { return at<1>().valid(); }
  uint32_t field_uint32() const { return at<1>().as_uint32(); }
  bool has_field_int32() const { return at<2>().valid(); }
  int32_t field_int32() const { return at<2>().as_int32(); }
  bool has_field_uint64() const { return at<3>().valid(); }
  uint64_t field_uint64() const { return at<3>().as_uint64(); }
  bool has_field_int64() const { return at<4>().valid(); }
  int64_t field_int64() const { return at<4>().as_int64(); }
  bool has_field_fixed64() const { return at<5>().valid(); }
  uint64_t field_fixed64() const { return at<5>().as_uint64(); }
  bool has_field_sfixed64() const { return at<6>().valid(); }
  int64_t field_sfixed64() const { return at<6>().as_int64(); }
  bool has_field_fixed32() const { return at<7>().valid(); }
  uint32_t field_fixed32() const { return at<7>().as_uint32(); }
  bool has_field_sfixed32() const { return at<8>().valid(); }
  int32_t field_sfixed32() const { return at<8>().as_int32(); }
  bool has_field_double() const { return at<9>().valid(); }
  double field_double() const { return at<9>().as_double(); }
  bool has_field_float() const { return at<10>().valid(); }
  float field_float() const { return at<10>().as_float(); }
  bool has_field_sint64() const { return at<11>().valid(); }
  int64_t field_sint64() const { return at<11>().as_int64(); }
  bool has_field_sint32() const { return at<12>().valid(); }
  int32_t field_sint32() const { return at<12>().as_int32(); }
  bool has_field_string() const { return at<13>().valid(); }
  ::protozero::ConstChars field_string() const { return at<13>().as_string(); }
  bool has_field_bytes() const { return at<14>().valid(); }
  ::protozero::ConstBytes field_bytes() const { return at<14>().as_bytes(); }
};

class TestConfig_DummyFields : public ::protozero::Message {
 public:
  using Decoder = TestConfig_DummyFields_Decoder;
  enum : int32_t {
    kFieldUint32FieldNumber = 1,
    kFieldInt32FieldNumber = 2,
    kFieldUint64FieldNumber = 3,
    kFieldInt64FieldNumber = 4,
    kFieldFixed64FieldNumber = 5,
    kFieldSfixed64FieldNumber = 6,
    kFieldFixed32FieldNumber = 7,
    kFieldSfixed32FieldNumber = 8,
    kFieldDoubleFieldNumber = 9,
    kFieldFloatFieldNumber = 10,
    kFieldSint64FieldNumber = 11,
    kFieldSint32FieldNumber = 12,
    kFieldStringFieldNumber = 13,
    kFieldBytesFieldNumber = 14,
  };
  void set_field_uint32(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_field_int32(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_field_uint64(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_field_int64(int64_t value) {
    AppendVarInt(4, value);
  }
  void set_field_fixed64(uint64_t value) {
    AppendFixed(5, value);
  }
  void set_field_sfixed64(int64_t value) {
    AppendFixed(6, value);
  }
  void set_field_fixed32(uint32_t value) {
    AppendFixed(7, value);
  }
  void set_field_sfixed32(int32_t value) {
    AppendFixed(8, value);
  }
  void set_field_double(double value) {
    AppendFixed(9, value);
  }
  void set_field_float(float value) {
    AppendFixed(10, value);
  }
  void set_field_sint64(int64_t value) {
    AppendSignedVarInt(11, value);
  }
  void set_field_sint32(int32_t value) {
    AppendSignedVarInt(12, value);
  }
  void set_field_string(const char* value) {
    AppendString(13, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_field_string(const char* value, size_t size) {
    AppendBytes(13, value, size);
  }
  void set_field_bytes(const uint8_t* data, size_t size) {
    AppendBytes(14, data, size);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/config/trace_config.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_TRACE_CONFIG_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_CONFIG_TRACE_CONFIG_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class DataSourceConfig;
class TraceConfig_BufferConfig;
class TraceConfig_BuiltinDataSource;
class TraceConfig_DataSource;
class TraceConfig_GuardrailOverrides;
class TraceConfig_IncidentReportConfig;
class TraceConfig_IncrementalStateConfig;
class TraceConfig_ProducerConfig;
class TraceConfig_StatsdMetadata;
class TraceConfig_TriggerConfig;
class TraceConfig_TriggerConfig_Trigger;
enum TraceConfig_BufferConfig_FillPolicy : int32_t;
enum TraceConfig_CompressionType : int32_t;
enum TraceConfig_LockdownModeOperation : int32_t;
enum TraceConfig_TriggerConfig_TriggerMode : int32_t;

enum TraceConfig_LockdownModeOperation : int32_t {
  TraceConfig_LockdownModeOperation_LOCKDOWN_UNCHANGED = 0,
  TraceConfig_LockdownModeOperation_LOCKDOWN_CLEAR = 1,
  TraceConfig_LockdownModeOperation_LOCKDOWN_SET = 2,
};

const TraceConfig_LockdownModeOperation TraceConfig_LockdownModeOperation_MIN = TraceConfig_LockdownModeOperation_LOCKDOWN_UNCHANGED;
const TraceConfig_LockdownModeOperation TraceConfig_LockdownModeOperation_MAX = TraceConfig_LockdownModeOperation_LOCKDOWN_SET;

enum TraceConfig_CompressionType : int32_t {
  TraceConfig_CompressionType_COMPRESSION_TYPE_UNSPECIFIED = 0,
  TraceConfig_CompressionType_COMPRESSION_TYPE_DEFLATE = 1,
};

const TraceConfig_CompressionType TraceConfig_CompressionType_MIN = TraceConfig_CompressionType_COMPRESSION_TYPE_UNSPECIFIED;
const TraceConfig_CompressionType TraceConfig_CompressionType_MAX = TraceConfig_CompressionType_COMPRESSION_TYPE_DEFLATE;

enum TraceConfig_TriggerConfig_TriggerMode : int32_t {
  TraceConfig_TriggerConfig_TriggerMode_UNSPECIFIED = 0,
  TraceConfig_TriggerConfig_TriggerMode_START_TRACING = 1,
  TraceConfig_TriggerConfig_TriggerMode_STOP_TRACING = 2,
};

const TraceConfig_TriggerConfig_TriggerMode TraceConfig_TriggerConfig_TriggerMode_MIN = TraceConfig_TriggerConfig_TriggerMode_UNSPECIFIED;
const TraceConfig_TriggerConfig_TriggerMode TraceConfig_TriggerConfig_TriggerMode_MAX = TraceConfig_TriggerConfig_TriggerMode_STOP_TRACING;

enum TraceConfig_BufferConfig_FillPolicy : int32_t {
  TraceConfig_BufferConfig_FillPolicy_UNSPECIFIED = 0,
  TraceConfig_BufferConfig_FillPolicy_RING_BUFFER = 1,
  TraceConfig_BufferConfig_FillPolicy_DISCARD = 2,
};

const TraceConfig_BufferConfig_FillPolicy TraceConfig_BufferConfig_FillPolicy_MIN = TraceConfig_BufferConfig_FillPolicy_UNSPECIFIED;
const TraceConfig_BufferConfig_FillPolicy TraceConfig_BufferConfig_FillPolicy_MAX = TraceConfig_BufferConfig_FillPolicy_DISCARD;

class TraceConfig_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/26, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  TraceConfig_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TraceConfig_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TraceConfig_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_buffers() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator buffers() const { return GetRepeated(1); }
  bool has_data_sources() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator data_sources() const { return GetRepeated(2); }
  bool has_builtin_data_sources() const { return at<20>().valid(); }
  ::protozero::ConstBytes builtin_data_sources() const { return at<20>().as_bytes(); }
  bool has_duration_ms() const { return at<3>().valid(); }
  uint32_t duration_ms() const { return at<3>().as_uint32(); }
  bool has_enable_extra_guardrails() const { return at<4>().valid(); }
  bool enable_extra_guardrails() const { return at<4>().as_bool(); }
  bool has_lockdown_mode() const { return at<5>().valid(); }
  int32_t lockdown_mode() const { return at<5>().as_int32(); }
  bool has_producers() const { return at<6>().valid(); }
  ::protozero::RepeatedFieldIterator producers() const { return GetRepeated(6); }
  bool has_statsd_metadata() const { return at<7>().valid(); }
  ::protozero::ConstBytes statsd_metadata() const { return at<7>().as_bytes(); }
  bool has_write_into_file() const { return at<8>().valid(); }
  bool write_into_file() const { return at<8>().as_bool(); }
  bool has_file_write_period_ms() const { return at<9>().valid(); }
  uint32_t file_write_period_ms() const { return at<9>().as_uint32(); }
  bool has_max_file_size_bytes() const { return at<10>().valid(); }
  uint64_t max_file_size_bytes() const { return at<10>().as_uint64(); }
  bool has_guardrail_overrides() const { return at<11>().valid(); }
  ::protozero::ConstBytes guardrail_overrides() const { return at<11>().as_bytes(); }
  bool has_deferred_start() const { return at<12>().valid(); }
  bool deferred_start() const { return at<12>().as_bool(); }
  bool has_flush_period_ms() const { return at<13>().valid(); }
  uint32_t flush_period_ms() const { return at<13>().as_uint32(); }
  bool has_flush_timeout_ms() const { return at<14>().valid(); }
  uint32_t flush_timeout_ms() const { return at<14>().as_uint32(); }
  bool has_data_source_stop_timeout_ms() const { return at<23>().valid(); }
  uint32_t data_source_stop_timeout_ms() const { return at<23>().as_uint32(); }
  bool has_notify_traceur() const { return at<16>().valid(); }
  bool notify_traceur() const { return at<16>().as_bool(); }
  bool has_trigger_config() const { return at<17>().valid(); }
  ::protozero::ConstBytes trigger_config() const { return at<17>().as_bytes(); }
  bool has_activate_triggers() const { return at<18>().valid(); }
  ::protozero::RepeatedFieldIterator activate_triggers() const { return GetRepeated(18); }
  bool has_incremental_state_config() const { return at<21>().valid(); }
  ::protozero::ConstBytes incremental_state_config() const { return at<21>().as_bytes(); }
  bool has_allow_user_build_tracing() const { return at<19>().valid(); }
  bool allow_user_build_tracing() const { return at<19>().as_bool(); }
  bool has_unique_session_name() const { return at<22>().valid(); }
  ::protozero::ConstChars unique_session_name() const { return at<22>().as_string(); }
  bool has_compression_type() const { return at<24>().valid(); }
  int32_t compression_type() const { return at<24>().as_int32(); }
  bool has_incident_report_config() const { return at<25>().valid(); }
  ::protozero::ConstBytes incident_report_config() const { return at<25>().as_bytes(); }
  bool has_trace_uuid() const { return at<26>().valid(); }
  ::protozero::ConstBytes trace_uuid() const { return at<26>().as_bytes(); }
};

class TraceConfig : public ::protozero::Message {
 public:
  using Decoder = TraceConfig_Decoder;
  enum : int32_t {
    kBuffersFieldNumber = 1,
    kDataSourcesFieldNumber = 2,
    kBuiltinDataSourcesFieldNumber = 20,
    kDurationMsFieldNumber = 3,
    kEnableExtraGuardrailsFieldNumber = 4,
    kLockdownModeFieldNumber = 5,
    kProducersFieldNumber = 6,
    kStatsdMetadataFieldNumber = 7,
    kWriteIntoFileFieldNumber = 8,
    kFileWritePeriodMsFieldNumber = 9,
    kMaxFileSizeBytesFieldNumber = 10,
    kGuardrailOverridesFieldNumber = 11,
    kDeferredStartFieldNumber = 12,
    kFlushPeriodMsFieldNumber = 13,
    kFlushTimeoutMsFieldNumber = 14,
    kDataSourceStopTimeoutMsFieldNumber = 23,
    kNotifyTraceurFieldNumber = 16,
    kTriggerConfigFieldNumber = 17,
    kActivateTriggersFieldNumber = 18,
    kIncrementalStateConfigFieldNumber = 21,
    kAllowUserBuildTracingFieldNumber = 19,
    kUniqueSessionNameFieldNumber = 22,
    kCompressionTypeFieldNumber = 24,
    kIncidentReportConfigFieldNumber = 25,
    kTraceUuidFieldNumber = 26,
  };
  using BufferConfig = ::perfetto::protos::pbzero::TraceConfig_BufferConfig;
  using DataSource = ::perfetto::protos::pbzero::TraceConfig_DataSource;
  using BuiltinDataSource = ::perfetto::protos::pbzero::TraceConfig_BuiltinDataSource;
  using ProducerConfig = ::perfetto::protos::pbzero::TraceConfig_ProducerConfig;
  using StatsdMetadata = ::perfetto::protos::pbzero::TraceConfig_StatsdMetadata;
  using GuardrailOverrides = ::perfetto::protos::pbzero::TraceConfig_GuardrailOverrides;
  using TriggerConfig = ::perfetto::protos::pbzero::TraceConfig_TriggerConfig;
  using IncrementalStateConfig = ::perfetto::protos::pbzero::TraceConfig_IncrementalStateConfig;
  using IncidentReportConfig = ::perfetto::protos::pbzero::TraceConfig_IncidentReportConfig;
  using LockdownModeOperation = ::perfetto::protos::pbzero::TraceConfig_LockdownModeOperation;
  using CompressionType = ::perfetto::protos::pbzero::TraceConfig_CompressionType;
  static const LockdownModeOperation LOCKDOWN_UNCHANGED = TraceConfig_LockdownModeOperation_LOCKDOWN_UNCHANGED;
  static const LockdownModeOperation LOCKDOWN_CLEAR = TraceConfig_LockdownModeOperation_LOCKDOWN_CLEAR;
  static const LockdownModeOperation LOCKDOWN_SET = TraceConfig_LockdownModeOperation_LOCKDOWN_SET;
  static const CompressionType COMPRESSION_TYPE_UNSPECIFIED = TraceConfig_CompressionType_COMPRESSION_TYPE_UNSPECIFIED;
  static const CompressionType COMPRESSION_TYPE_DEFLATE = TraceConfig_CompressionType_COMPRESSION_TYPE_DEFLATE;
  template <typename T = TraceConfig_BufferConfig> T* add_buffers() {
    return BeginNestedMessage<T>(1);
  }

  template <typename T = TraceConfig_DataSource> T* add_data_sources() {
    return BeginNestedMessage<T>(2);
  }

  template <typename T = TraceConfig_BuiltinDataSource> T* set_builtin_data_sources() {
    return BeginNestedMessage<T>(20);
  }

  void set_duration_ms(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_enable_extra_guardrails(bool value) {
    AppendTinyVarInt(4, value);
  }
  void set_lockdown_mode(::perfetto::protos::pbzero::TraceConfig_LockdownModeOperation value) {
    AppendTinyVarInt(5, value);
  }
  template <typename T = TraceConfig_ProducerConfig> T* add_producers() {
    return BeginNestedMessage<T>(6);
  }

  template <typename T = TraceConfig_StatsdMetadata> T* set_statsd_metadata() {
    return BeginNestedMessage<T>(7);
  }

  void set_write_into_file(bool value) {
    AppendTinyVarInt(8, value);
  }
  void set_file_write_period_ms(uint32_t value) {
    AppendVarInt(9, value);
  }
  void set_max_file_size_bytes(uint64_t value) {
    AppendVarInt(10, value);
  }
  template <typename T = TraceConfig_GuardrailOverrides> T* set_guardrail_overrides() {
    return BeginNestedMessage<T>(11);
  }

  void set_deferred_start(bool value) {
    AppendTinyVarInt(12, value);
  }
  void set_flush_period_ms(uint32_t value) {
    AppendVarInt(13, value);
  }
  void set_flush_timeout_ms(uint32_t value) {
    AppendVarInt(14, value);
  }
  void set_data_source_stop_timeout_ms(uint32_t value) {
    AppendVarInt(23, value);
  }
  void set_notify_traceur(bool value) {
    AppendTinyVarInt(16, value);
  }
  template <typename T = TraceConfig_TriggerConfig> T* set_trigger_config() {
    return BeginNestedMessage<T>(17);
  }

  void add_activate_triggers(const char* value) {
    AppendString(18, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void add_activate_triggers(const char* value, size_t size) {
    AppendBytes(18, value, size);
  }
  template <typename T = TraceConfig_IncrementalStateConfig> T* set_incremental_state_config() {
    return BeginNestedMessage<T>(21);
  }

  void set_allow_user_build_tracing(bool value) {
    AppendTinyVarInt(19, value);
  }
  void set_unique_session_name(const char* value) {
    AppendString(22, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_unique_session_name(const char* value, size_t size) {
    AppendBytes(22, value, size);
  }
  void set_compression_type(::perfetto::protos::pbzero::TraceConfig_CompressionType value) {
    AppendTinyVarInt(24, value);
  }
  template <typename T = TraceConfig_IncidentReportConfig> T* set_incident_report_config() {
    return BeginNestedMessage<T>(25);
  }

  void set_trace_uuid(const uint8_t* data, size_t size) {
    AppendBytes(26, data, size);
  }
};

class TraceConfig_IncidentReportConfig_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TraceConfig_IncidentReportConfig_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TraceConfig_IncidentReportConfig_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TraceConfig_IncidentReportConfig_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_destination_package() const { return at<1>().valid(); }
  ::protozero::ConstChars destination_package() const { return at<1>().as_string(); }
  bool has_destination_class() const { return at<2>().valid(); }
  ::protozero::ConstChars destination_class() const { return at<2>().as_string(); }
  bool has_privacy_level() const { return at<3>().valid(); }
  int32_t privacy_level() const { return at<3>().as_int32(); }
  bool has_skip_dropbox() const { return at<4>().valid(); }
  bool skip_dropbox() const { return at<4>().as_bool(); }
};

class TraceConfig_IncidentReportConfig : public ::protozero::Message {
 public:
  using Decoder = TraceConfig_IncidentReportConfig_Decoder;
  enum : int32_t {
    kDestinationPackageFieldNumber = 1,
    kDestinationClassFieldNumber = 2,
    kPrivacyLevelFieldNumber = 3,
    kSkipDropboxFieldNumber = 4,
  };
  void set_destination_package(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_destination_package(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_destination_class(const char* value) {
    AppendString(2, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_destination_class(const char* value, size_t size) {
    AppendBytes(2, value, size);
  }
  void set_privacy_level(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_skip_dropbox(bool value) {
    AppendTinyVarInt(4, value);
  }
};

class TraceConfig_IncrementalStateConfig_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TraceConfig_IncrementalStateConfig_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TraceConfig_IncrementalStateConfig_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TraceConfig_IncrementalStateConfig_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_clear_period_ms() const { return at<1>().valid(); }
  uint32_t clear_period_ms() const { return at<1>().as_uint32(); }
};

class TraceConfig_IncrementalStateConfig : public ::protozero::Message {
 public:
  using Decoder = TraceConfig_IncrementalStateConfig_Decoder;
  enum : int32_t {
    kClearPeriodMsFieldNumber = 1,
  };
  void set_clear_period_ms(uint32_t value) {
    AppendVarInt(1, value);
  }
};

class TraceConfig_TriggerConfig_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  TraceConfig_TriggerConfig_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TraceConfig_TriggerConfig_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TraceConfig_TriggerConfig_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_trigger_mode() const { return at<1>().valid(); }
  int32_t trigger_mode() const { return at<1>().as_int32(); }
  bool has_triggers() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator triggers() const { return GetRepeated(2); }
  bool has_trigger_timeout_ms() const { return at<3>().valid(); }
  uint32_t trigger_timeout_ms() const { return at<3>().as_uint32(); }
};

class TraceConfig_TriggerConfig : public ::protozero::Message {
 public:
  using Decoder = TraceConfig_TriggerConfig_Decoder;
  enum : int32_t {
    kTriggerModeFieldNumber = 1,
    kTriggersFieldNumber = 2,
    kTriggerTimeoutMsFieldNumber = 3,
  };
  using Trigger = ::perfetto::protos::pbzero::TraceConfig_TriggerConfig_Trigger;
  using TriggerMode = ::perfetto::protos::pbzero::TraceConfig_TriggerConfig_TriggerMode;
  static const TriggerMode UNSPECIFIED = TraceConfig_TriggerConfig_TriggerMode_UNSPECIFIED;
  static const TriggerMode START_TRACING = TraceConfig_TriggerConfig_TriggerMode_START_TRACING;
  static const TriggerMode STOP_TRACING = TraceConfig_TriggerConfig_TriggerMode_STOP_TRACING;
  void set_trigger_mode(::perfetto::protos::pbzero::TraceConfig_TriggerConfig_TriggerMode value) {
    AppendTinyVarInt(1, value);
  }
  template <typename T = TraceConfig_TriggerConfig_Trigger> T* add_triggers() {
    return BeginNestedMessage<T>(2);
  }

  void set_trigger_timeout_ms(uint32_t value) {
    AppendVarInt(3, value);
  }
};

class TraceConfig_TriggerConfig_Trigger_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TraceConfig_TriggerConfig_Trigger_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TraceConfig_TriggerConfig_Trigger_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TraceConfig_TriggerConfig_Trigger_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_producer_name_regex() const { return at<2>().valid(); }
  ::protozero::ConstChars producer_name_regex() const { return at<2>().as_string(); }
  bool has_stop_delay_ms() const { return at<3>().valid(); }
  uint32_t stop_delay_ms() const { return at<3>().as_uint32(); }
};

class TraceConfig_TriggerConfig_Trigger : public ::protozero::Message {
 public:
  using Decoder = TraceConfig_TriggerConfig_Trigger_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kProducerNameRegexFieldNumber = 2,
    kStopDelayMsFieldNumber = 3,
  };
  void set_name(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_name(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_producer_name_regex(const char* value) {
    AppendString(2, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_producer_name_regex(const char* value, size_t size) {
    AppendBytes(2, value, size);
  }
  void set_stop_delay_ms(uint32_t value) {
    AppendVarInt(3, value);
  }
};

class TraceConfig_GuardrailOverrides_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TraceConfig_GuardrailOverrides_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TraceConfig_GuardrailOverrides_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TraceConfig_GuardrailOverrides_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_max_upload_per_day_bytes() const { return at<1>().valid(); }
  uint64_t max_upload_per_day_bytes() const { return at<1>().as_uint64(); }
};

class TraceConfig_GuardrailOverrides : public ::protozero::Message {
 public:
  using Decoder = TraceConfig_GuardrailOverrides_Decoder;
  enum : int32_t {
    kMaxUploadPerDayBytesFieldNumber = 1,
  };
  void set_max_upload_per_day_bytes(uint64_t value) {
    AppendVarInt(1, value);
  }
};

class TraceConfig_StatsdMetadata_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TraceConfig_StatsdMetadata_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TraceConfig_StatsdMetadata_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TraceConfig_StatsdMetadata_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_triggering_alert_id() const { return at<1>().valid(); }
  int64_t triggering_alert_id() const { return at<1>().as_int64(); }
  bool has_triggering_config_uid() const { return at<2>().valid(); }
  int32_t triggering_config_uid() const { return at<2>().as_int32(); }
  bool has_triggering_config_id() const { return at<3>().valid(); }
  int64_t triggering_config_id() const { return at<3>().as_int64(); }
  bool has_triggering_subscription_id() const { return at<4>().valid(); }
  int64_t triggering_subscription_id() const { return at<4>().as_int64(); }
};

class TraceConfig_StatsdMetadata : public ::protozero::Message {
 public:
  using Decoder = TraceConfig_StatsdMetadata_Decoder;
  enum : int32_t {
    kTriggeringAlertIdFieldNumber = 1,
    kTriggeringConfigUidFieldNumber = 2,
    kTriggeringConfigIdFieldNumber = 3,
    kTriggeringSubscriptionIdFieldNumber = 4,
  };
  void set_triggering_alert_id(int64_t value) {
    AppendVarInt(1, value);
  }
  void set_triggering_config_uid(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_triggering_config_id(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_triggering_subscription_id(int64_t value) {
    AppendVarInt(4, value);
  }
};

class TraceConfig_ProducerConfig_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TraceConfig_ProducerConfig_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TraceConfig_ProducerConfig_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TraceConfig_ProducerConfig_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_producer_name() const { return at<1>().valid(); }
  ::protozero::ConstChars producer_name() const { return at<1>().as_string(); }
  bool has_shm_size_kb() const { return at<2>().valid(); }
  uint32_t shm_size_kb() const { return at<2>().as_uint32(); }
  bool has_page_size_kb() const { return at<3>().valid(); }
  uint32_t page_size_kb() const { return at<3>().as_uint32(); }
};

class TraceConfig_ProducerConfig : public ::protozero::Message {
 public:
  using Decoder = TraceConfig_ProducerConfig_Decoder;
  enum : int32_t {
    kProducerNameFieldNumber = 1,
    kShmSizeKbFieldNumber = 2,
    kPageSizeKbFieldNumber = 3,
  };
  void set_producer_name(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_producer_name(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_shm_size_kb(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_page_size_kb(uint32_t value) {
    AppendVarInt(3, value);
  }
};

class TraceConfig_BuiltinDataSource_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TraceConfig_BuiltinDataSource_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TraceConfig_BuiltinDataSource_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TraceConfig_BuiltinDataSource_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_disable_clock_snapshotting() const { return at<1>().valid(); }
  bool disable_clock_snapshotting() const { return at<1>().as_bool(); }
  bool has_disable_trace_config() const { return at<2>().valid(); }
  bool disable_trace_config() const { return at<2>().as_bool(); }
  bool has_disable_system_info() const { return at<3>().valid(); }
  bool disable_system_info() const { return at<3>().as_bool(); }
};

class TraceConfig_BuiltinDataSource : public ::protozero::Message {
 public:
  using Decoder = TraceConfig_BuiltinDataSource_Decoder;
  enum : int32_t {
    kDisableClockSnapshottingFieldNumber = 1,
    kDisableTraceConfigFieldNumber = 2,
    kDisableSystemInfoFieldNumber = 3,
  };
  void set_disable_clock_snapshotting(bool value) {
    AppendTinyVarInt(1, value);
  }
  void set_disable_trace_config(bool value) {
    AppendTinyVarInt(2, value);
  }
  void set_disable_system_info(bool value) {
    AppendTinyVarInt(3, value);
  }
};

class TraceConfig_DataSource_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  TraceConfig_DataSource_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TraceConfig_DataSource_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TraceConfig_DataSource_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_config() const { return at<1>().valid(); }
  ::protozero::ConstBytes config() const { return at<1>().as_bytes(); }
  bool has_producer_name_filter() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator producer_name_filter() const { return GetRepeated(2); }
};

class TraceConfig_DataSource : public ::protozero::Message {
 public:
  using Decoder = TraceConfig_DataSource_Decoder;
  enum : int32_t {
    kConfigFieldNumber = 1,
    kProducerNameFilterFieldNumber = 2,
  };
  template <typename T = DataSourceConfig> T* set_config() {
    return BeginNestedMessage<T>(1);
  }

  void add_producer_name_filter(const char* value) {
    AppendString(2, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void add_producer_name_filter(const char* value, size_t size) {
    AppendBytes(2, value, size);
  }
};

class TraceConfig_BufferConfig_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TraceConfig_BufferConfig_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TraceConfig_BufferConfig_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TraceConfig_BufferConfig_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_size_kb() const { return at<1>().valid(); }
  uint32_t size_kb() const { return at<1>().as_uint32(); }
  bool has_fill_policy() const { return at<4>().valid(); }
  int32_t fill_policy() const { return at<4>().as_int32(); }
};

class TraceConfig_BufferConfig : public ::protozero::Message {
 public:
  using Decoder = TraceConfig_BufferConfig_Decoder;
  enum : int32_t {
    kSizeKbFieldNumber = 1,
    kFillPolicyFieldNumber = 4,
  };
  using FillPolicy = ::perfetto::protos::pbzero::TraceConfig_BufferConfig_FillPolicy;
  static const FillPolicy UNSPECIFIED = TraceConfig_BufferConfig_FillPolicy_UNSPECIFIED;
  static const FillPolicy RING_BUFFER = TraceConfig_BufferConfig_FillPolicy_RING_BUFFER;
  static const FillPolicy DISCARD = TraceConfig_BufferConfig_FillPolicy_DISCARD;
  void set_size_kb(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_fill_policy(::perfetto::protos::pbzero::TraceConfig_BufferConfig_FillPolicy value) {
    AppendTinyVarInt(4, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/clock_snapshot.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_CLOCK_SNAPSHOT_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_CLOCK_SNAPSHOT_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class ClockSnapshot_Clock;

enum ClockSnapshot_Clock_BuiltinClocks : int32_t {
  ClockSnapshot_Clock_BuiltinClocks_UNKNOWN = 0,
  ClockSnapshot_Clock_BuiltinClocks_REALTIME = 1,
  ClockSnapshot_Clock_BuiltinClocks_REALTIME_COARSE = 2,
  ClockSnapshot_Clock_BuiltinClocks_MONOTONIC = 3,
  ClockSnapshot_Clock_BuiltinClocks_MONOTONIC_COARSE = 4,
  ClockSnapshot_Clock_BuiltinClocks_MONOTONIC_RAW = 5,
  ClockSnapshot_Clock_BuiltinClocks_BOOTTIME = 6,
  ClockSnapshot_Clock_BuiltinClocks_PROCESS_CPUTIME = 7,
  ClockSnapshot_Clock_BuiltinClocks_THREAD_CPUTIME = 8,
  ClockSnapshot_Clock_BuiltinClocks_BUILTIN_CLOCK_MAX_ID = 63,
};

const ClockSnapshot_Clock_BuiltinClocks ClockSnapshot_Clock_BuiltinClocks_MIN = ClockSnapshot_Clock_BuiltinClocks_UNKNOWN;
const ClockSnapshot_Clock_BuiltinClocks ClockSnapshot_Clock_BuiltinClocks_MAX = ClockSnapshot_Clock_BuiltinClocks_BUILTIN_CLOCK_MAX_ID;

class ClockSnapshot_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  ClockSnapshot_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ClockSnapshot_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ClockSnapshot_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_clocks() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator clocks() const { return GetRepeated(1); }
};

class ClockSnapshot : public ::protozero::Message {
 public:
  using Decoder = ClockSnapshot_Decoder;
  enum : int32_t {
    kClocksFieldNumber = 1,
  };
  using Clock = ::perfetto::protos::pbzero::ClockSnapshot_Clock;
  template <typename T = ClockSnapshot_Clock> T* add_clocks() {
    return BeginNestedMessage<T>(1);
  }

};

class ClockSnapshot_Clock_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ClockSnapshot_Clock_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ClockSnapshot_Clock_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ClockSnapshot_Clock_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_clock_id() const { return at<1>().valid(); }
  uint32_t clock_id() const { return at<1>().as_uint32(); }
  bool has_timestamp() const { return at<2>().valid(); }
  uint64_t timestamp() const { return at<2>().as_uint64(); }
};

class ClockSnapshot_Clock : public ::protozero::Message {
 public:
  using Decoder = ClockSnapshot_Clock_Decoder;
  enum : int32_t {
    kClockIdFieldNumber = 1,
    kTimestampFieldNumber = 2,
  };
  using BuiltinClocks = ::perfetto::protos::pbzero::ClockSnapshot_Clock_BuiltinClocks;
  static const BuiltinClocks UNKNOWN = ClockSnapshot_Clock_BuiltinClocks_UNKNOWN;
  static const BuiltinClocks REALTIME = ClockSnapshot_Clock_BuiltinClocks_REALTIME;
  static const BuiltinClocks REALTIME_COARSE = ClockSnapshot_Clock_BuiltinClocks_REALTIME_COARSE;
  static const BuiltinClocks MONOTONIC = ClockSnapshot_Clock_BuiltinClocks_MONOTONIC;
  static const BuiltinClocks MONOTONIC_COARSE = ClockSnapshot_Clock_BuiltinClocks_MONOTONIC_COARSE;
  static const BuiltinClocks MONOTONIC_RAW = ClockSnapshot_Clock_BuiltinClocks_MONOTONIC_RAW;
  static const BuiltinClocks BOOTTIME = ClockSnapshot_Clock_BuiltinClocks_BOOTTIME;
  static const BuiltinClocks PROCESS_CPUTIME = ClockSnapshot_Clock_BuiltinClocks_PROCESS_CPUTIME;
  static const BuiltinClocks THREAD_CPUTIME = ClockSnapshot_Clock_BuiltinClocks_THREAD_CPUTIME;
  static const BuiltinClocks BUILTIN_CLOCK_MAX_ID = ClockSnapshot_Clock_BuiltinClocks_BUILTIN_CLOCK_MAX_ID;
  void set_clock_id(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_timestamp(uint64_t value) {
    AppendVarInt(2, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/trigger.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRIGGER_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRIGGER_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class Trigger_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Trigger_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Trigger_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Trigger_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_trigger_name() const { return at<1>().valid(); }
  ::protozero::ConstChars trigger_name() const { return at<1>().as_string(); }
  bool has_producer_name() const { return at<2>().valid(); }
  ::protozero::ConstChars producer_name() const { return at<2>().as_string(); }
  bool has_trusted_producer_uid() const { return at<3>().valid(); }
  int32_t trusted_producer_uid() const { return at<3>().as_int32(); }
};

class Trigger : public ::protozero::Message {
 public:
  using Decoder = Trigger_Decoder;
  enum : int32_t {
    kTriggerNameFieldNumber = 1,
    kProducerNameFieldNumber = 2,
    kTrustedProducerUidFieldNumber = 3,
  };
  void set_trigger_name(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_trigger_name(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_producer_name(const char* value) {
    AppendString(2, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_producer_name(const char* value, size_t size) {
    AppendBytes(2, value, size);
  }
  void set_trusted_producer_uid(int32_t value) {
    AppendVarInt(3, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/system_info.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_SYSTEM_INFO_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_SYSTEM_INFO_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class Utsname;

class SystemInfo_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SystemInfo_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SystemInfo_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SystemInfo_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_utsname() const { return at<1>().valid(); }
  ::protozero::ConstBytes utsname() const { return at<1>().as_bytes(); }
};

class SystemInfo : public ::protozero::Message {
 public:
  using Decoder = SystemInfo_Decoder;
  enum : int32_t {
    kUtsnameFieldNumber = 1,
  };
  template <typename T = Utsname> T* set_utsname() {
    return BeginNestedMessage<T>(1);
  }

};

class Utsname_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Utsname_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Utsname_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Utsname_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_sysname() const { return at<1>().valid(); }
  ::protozero::ConstChars sysname() const { return at<1>().as_string(); }
  bool has_version() const { return at<2>().valid(); }
  ::protozero::ConstChars version() const { return at<2>().as_string(); }
  bool has_release() const { return at<3>().valid(); }
  ::protozero::ConstChars release() const { return at<3>().as_string(); }
  bool has_machine() const { return at<4>().valid(); }
  ::protozero::ConstChars machine() const { return at<4>().as_string(); }
};

class Utsname : public ::protozero::Message {
 public:
  using Decoder = Utsname_Decoder;
  enum : int32_t {
    kSysnameFieldNumber = 1,
    kVersionFieldNumber = 2,
    kReleaseFieldNumber = 3,
    kMachineFieldNumber = 4,
  };
  void set_sysname(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_sysname(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_version(const char* value) {
    AppendString(2, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_version(const char* value, size_t size) {
    AppendBytes(2, value, size);
  }
  void set_release(const char* value) {
    AppendString(3, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_release(const char* value, size_t size) {
    AppendBytes(3, value, size);
  }
  void set_machine(const char* value) {
    AppendString(4, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_machine(const char* value, size_t size) {
    AppendBytes(4, value, size);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/android/android_log.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_ANDROID_ANDROID_LOG_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_ANDROID_ANDROID_LOG_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class AndroidLogPacket_LogEvent;
class AndroidLogPacket_LogEvent_Arg;
class AndroidLogPacket_Stats;
enum AndroidLogId : int32_t;
enum AndroidLogPriority : int32_t;

class AndroidLogPacket_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  AndroidLogPacket_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit AndroidLogPacket_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit AndroidLogPacket_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_events() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator events() const { return GetRepeated(1); }
  bool has_stats() const { return at<2>().valid(); }
  ::protozero::ConstBytes stats() const { return at<2>().as_bytes(); }
};

class AndroidLogPacket : public ::protozero::Message {
 public:
  using Decoder = AndroidLogPacket_Decoder;
  enum : int32_t {
    kEventsFieldNumber = 1,
    kStatsFieldNumber = 2,
  };
  using LogEvent = ::perfetto::protos::pbzero::AndroidLogPacket_LogEvent;
  using Stats = ::perfetto::protos::pbzero::AndroidLogPacket_Stats;
  template <typename T = AndroidLogPacket_LogEvent> T* add_events() {
    return BeginNestedMessage<T>(1);
  }

  template <typename T = AndroidLogPacket_Stats> T* set_stats() {
    return BeginNestedMessage<T>(2);
  }

};

class AndroidLogPacket_Stats_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  AndroidLogPacket_Stats_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit AndroidLogPacket_Stats_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit AndroidLogPacket_Stats_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_num_total() const { return at<1>().valid(); }
  uint64_t num_total() const { return at<1>().as_uint64(); }
  bool has_num_failed() const { return at<2>().valid(); }
  uint64_t num_failed() const { return at<2>().as_uint64(); }
  bool has_num_skipped() const { return at<3>().valid(); }
  uint64_t num_skipped() const { return at<3>().as_uint64(); }
};

class AndroidLogPacket_Stats : public ::protozero::Message {
 public:
  using Decoder = AndroidLogPacket_Stats_Decoder;
  enum : int32_t {
    kNumTotalFieldNumber = 1,
    kNumFailedFieldNumber = 2,
    kNumSkippedFieldNumber = 3,
  };
  void set_num_total(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_num_failed(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_num_skipped(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class AndroidLogPacket_LogEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/9, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  AndroidLogPacket_LogEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit AndroidLogPacket_LogEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit AndroidLogPacket_LogEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_log_id() const { return at<1>().valid(); }
  int32_t log_id() const { return at<1>().as_int32(); }
  bool has_pid() const { return at<2>().valid(); }
  int32_t pid() const { return at<2>().as_int32(); }
  bool has_tid() const { return at<3>().valid(); }
  int32_t tid() const { return at<3>().as_int32(); }
  bool has_uid() const { return at<4>().valid(); }
  int32_t uid() const { return at<4>().as_int32(); }
  bool has_timestamp() const { return at<5>().valid(); }
  uint64_t timestamp() const { return at<5>().as_uint64(); }
  bool has_tag() const { return at<6>().valid(); }
  ::protozero::ConstChars tag() const { return at<6>().as_string(); }
  bool has_prio() const { return at<7>().valid(); }
  int32_t prio() const { return at<7>().as_int32(); }
  bool has_message() const { return at<8>().valid(); }
  ::protozero::ConstChars message() const { return at<8>().as_string(); }
  bool has_args() const { return at<9>().valid(); }
  ::protozero::RepeatedFieldIterator args() const { return GetRepeated(9); }
};

class AndroidLogPacket_LogEvent : public ::protozero::Message {
 public:
  using Decoder = AndroidLogPacket_LogEvent_Decoder;
  enum : int32_t {
    kLogIdFieldNumber = 1,
    kPidFieldNumber = 2,
    kTidFieldNumber = 3,
    kUidFieldNumber = 4,
    kTimestampFieldNumber = 5,
    kTagFieldNumber = 6,
    kPrioFieldNumber = 7,
    kMessageFieldNumber = 8,
    kArgsFieldNumber = 9,
  };
  using Arg = ::perfetto::protos::pbzero::AndroidLogPacket_LogEvent_Arg;
  void set_log_id(::perfetto::protos::pbzero::AndroidLogId value) {
    AppendTinyVarInt(1, value);
  }
  void set_pid(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_tid(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_uid(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_timestamp(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_tag(const char* value) {
    AppendString(6, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_tag(const char* value, size_t size) {
    AppendBytes(6, value, size);
  }
  void set_prio(::perfetto::protos::pbzero::AndroidLogPriority value) {
    AppendTinyVarInt(7, value);
  }
  void set_message(const char* value) {
    AppendString(8, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_message(const char* value, size_t size) {
    AppendBytes(8, value, size);
  }
  template <typename T = AndroidLogPacket_LogEvent_Arg> T* add_args() {
    return BeginNestedMessage<T>(9);
  }

};

class AndroidLogPacket_LogEvent_Arg_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  AndroidLogPacket_LogEvent_Arg_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit AndroidLogPacket_LogEvent_Arg_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit AndroidLogPacket_LogEvent_Arg_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_int_value() const { return at<2>().valid(); }
  int64_t int_value() const { return at<2>().as_int64(); }
  bool has_float_value() const { return at<3>().valid(); }
  float float_value() const { return at<3>().as_float(); }
  bool has_string_value() const { return at<4>().valid(); }
  ::protozero::ConstChars string_value() const { return at<4>().as_string(); }
};

class AndroidLogPacket_LogEvent_Arg : public ::protozero::Message {
 public:
  using Decoder = AndroidLogPacket_LogEvent_Arg_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kIntValueFieldNumber = 2,
    kFloatValueFieldNumber = 3,
    kStringValueFieldNumber = 4,
  };
  void set_name(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_name(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_int_value(int64_t value) {
    AppendVarInt(2, value);
  }
  void set_float_value(float value) {
    AppendFixed(3, value);
  }
  void set_string_value(const char* value) {
    AppendString(4, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_string_value(const char* value, size_t size) {
    AppendBytes(4, value, size);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/android/graphics_frame_event.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_ANDROID_GRAPHICS_FRAME_EVENT_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_ANDROID_GRAPHICS_FRAME_EVENT_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class GraphicsFrameEvent_BufferEvent;
enum GraphicsFrameEvent_BufferEventType : int32_t;

enum GraphicsFrameEvent_BufferEventType : int32_t {
  GraphicsFrameEvent_BufferEventType_UNSPECIFIED = 0,
  GraphicsFrameEvent_BufferEventType_DEQUEUE = 1,
  GraphicsFrameEvent_BufferEventType_QUEUE = 2,
  GraphicsFrameEvent_BufferEventType_POST = 3,
  GraphicsFrameEvent_BufferEventType_ACQUIRE_FENCE = 4,
  GraphicsFrameEvent_BufferEventType_LATCH = 5,
  GraphicsFrameEvent_BufferEventType_HWC_COMPOSITION_QUEUED = 6,
  GraphicsFrameEvent_BufferEventType_FALLBACK_COMPOSITION = 7,
  GraphicsFrameEvent_BufferEventType_PRESENT_FENCE = 8,
  GraphicsFrameEvent_BufferEventType_RELEASE_FENCE = 9,
  GraphicsFrameEvent_BufferEventType_MODIFY = 10,
};

const GraphicsFrameEvent_BufferEventType GraphicsFrameEvent_BufferEventType_MIN = GraphicsFrameEvent_BufferEventType_UNSPECIFIED;
const GraphicsFrameEvent_BufferEventType GraphicsFrameEvent_BufferEventType_MAX = GraphicsFrameEvent_BufferEventType_MODIFY;

class GraphicsFrameEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  GraphicsFrameEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit GraphicsFrameEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit GraphicsFrameEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_buffer_event() const { return at<1>().valid(); }
  ::protozero::ConstBytes buffer_event() const { return at<1>().as_bytes(); }
};

class GraphicsFrameEvent : public ::protozero::Message {
 public:
  using Decoder = GraphicsFrameEvent_Decoder;
  enum : int32_t {
    kBufferEventFieldNumber = 1,
  };
  using BufferEvent = ::perfetto::protos::pbzero::GraphicsFrameEvent_BufferEvent;
  using BufferEventType = ::perfetto::protos::pbzero::GraphicsFrameEvent_BufferEventType;
  static const BufferEventType UNSPECIFIED = GraphicsFrameEvent_BufferEventType_UNSPECIFIED;
  static const BufferEventType DEQUEUE = GraphicsFrameEvent_BufferEventType_DEQUEUE;
  static const BufferEventType QUEUE = GraphicsFrameEvent_BufferEventType_QUEUE;
  static const BufferEventType POST = GraphicsFrameEvent_BufferEventType_POST;
  static const BufferEventType ACQUIRE_FENCE = GraphicsFrameEvent_BufferEventType_ACQUIRE_FENCE;
  static const BufferEventType LATCH = GraphicsFrameEvent_BufferEventType_LATCH;
  static const BufferEventType HWC_COMPOSITION_QUEUED = GraphicsFrameEvent_BufferEventType_HWC_COMPOSITION_QUEUED;
  static const BufferEventType FALLBACK_COMPOSITION = GraphicsFrameEvent_BufferEventType_FALLBACK_COMPOSITION;
  static const BufferEventType PRESENT_FENCE = GraphicsFrameEvent_BufferEventType_PRESENT_FENCE;
  static const BufferEventType RELEASE_FENCE = GraphicsFrameEvent_BufferEventType_RELEASE_FENCE;
  static const BufferEventType MODIFY = GraphicsFrameEvent_BufferEventType_MODIFY;
  template <typename T = GraphicsFrameEvent_BufferEvent> T* set_buffer_event() {
    return BeginNestedMessage<T>(1);
  }

};

class GraphicsFrameEvent_BufferEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  GraphicsFrameEvent_BufferEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit GraphicsFrameEvent_BufferEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit GraphicsFrameEvent_BufferEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_frame_number() const { return at<1>().valid(); }
  uint32_t frame_number() const { return at<1>().as_uint32(); }
  bool has_type() const { return at<2>().valid(); }
  int32_t type() const { return at<2>().as_int32(); }
  bool has_layer_name() const { return at<3>().valid(); }
  ::protozero::ConstChars layer_name() const { return at<3>().as_string(); }
  bool has_duration_ns() const { return at<4>().valid(); }
  uint64_t duration_ns() const { return at<4>().as_uint64(); }
  bool has_buffer_id() const { return at<5>().valid(); }
  uint32_t buffer_id() const { return at<5>().as_uint32(); }
};

class GraphicsFrameEvent_BufferEvent : public ::protozero::Message {
 public:
  using Decoder = GraphicsFrameEvent_BufferEvent_Decoder;
  enum : int32_t {
    kFrameNumberFieldNumber = 1,
    kTypeFieldNumber = 2,
    kLayerNameFieldNumber = 3,
    kDurationNsFieldNumber = 4,
    kBufferIdFieldNumber = 5,
  };
  void set_frame_number(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_type(::perfetto::protos::pbzero::GraphicsFrameEvent_BufferEventType value) {
    AppendTinyVarInt(2, value);
  }
  void set_layer_name(const char* value) {
    AppendString(3, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_layer_name(const char* value, size_t size) {
    AppendBytes(3, value, size);
  }
  void set_duration_ns(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_buffer_id(uint32_t value) {
    AppendVarInt(5, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/android/packages_list.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_ANDROID_PACKAGES_LIST_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_ANDROID_PACKAGES_LIST_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class PackagesList_PackageInfo;

class PackagesList_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  PackagesList_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit PackagesList_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit PackagesList_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_packages() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator packages() const { return GetRepeated(1); }
  bool has_parse_error() const { return at<2>().valid(); }
  bool parse_error() const { return at<2>().as_bool(); }
  bool has_read_error() const { return at<3>().valid(); }
  bool read_error() const { return at<3>().as_bool(); }
};

class PackagesList : public ::protozero::Message {
 public:
  using Decoder = PackagesList_Decoder;
  enum : int32_t {
    kPackagesFieldNumber = 1,
    kParseErrorFieldNumber = 2,
    kReadErrorFieldNumber = 3,
  };
  using PackageInfo = ::perfetto::protos::pbzero::PackagesList_PackageInfo;
  template <typename T = PackagesList_PackageInfo> T* add_packages() {
    return BeginNestedMessage<T>(1);
  }

  void set_parse_error(bool value) {
    AppendTinyVarInt(2, value);
  }
  void set_read_error(bool value) {
    AppendTinyVarInt(3, value);
  }
};

class PackagesList_PackageInfo_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  PackagesList_PackageInfo_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit PackagesList_PackageInfo_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit PackagesList_PackageInfo_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_uid() const { return at<2>().valid(); }
  uint64_t uid() const { return at<2>().as_uint64(); }
  bool has_debuggable() const { return at<3>().valid(); }
  bool debuggable() const { return at<3>().as_bool(); }
  bool has_profileable_from_shell() const { return at<4>().valid(); }
  bool profileable_from_shell() const { return at<4>().as_bool(); }
  bool has_version_code() const { return at<5>().valid(); }
  int64_t version_code() const { return at<5>().as_int64(); }
};

class PackagesList_PackageInfo : public ::protozero::Message {
 public:
  using Decoder = PackagesList_PackageInfo_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kUidFieldNumber = 2,
    kDebuggableFieldNumber = 3,
    kProfileableFromShellFieldNumber = 4,
    kVersionCodeFieldNumber = 5,
  };
  void set_name(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_name(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_uid(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_debuggable(bool value) {
    AppendTinyVarInt(3, value);
  }
  void set_profileable_from_shell(bool value) {
    AppendTinyVarInt(4, value);
  }
  void set_version_code(int64_t value) {
    AppendVarInt(5, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/profiling/heap_graph.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_PROFILING_HEAP_GRAPH_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_PROFILING_HEAP_GRAPH_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class HeapGraphObject;
class InternedString;

class HeapGraph_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  HeapGraph_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit HeapGraph_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit HeapGraph_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_pid() const { return at<1>().valid(); }
  int32_t pid() const { return at<1>().as_int32(); }
  bool has_objects() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator objects() const { return GetRepeated(2); }
  bool has_type_names() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator type_names() const { return GetRepeated(3); }
  bool has_field_names() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator field_names() const { return GetRepeated(4); }
  bool has_continued() const { return at<5>().valid(); }
  bool continued() const { return at<5>().as_bool(); }
  bool has_index() const { return at<6>().valid(); }
  uint64_t index() const { return at<6>().as_uint64(); }
};

class HeapGraph : public ::protozero::Message {
 public:
  using Decoder = HeapGraph_Decoder;
  enum : int32_t {
    kPidFieldNumber = 1,
    kObjectsFieldNumber = 2,
    kTypeNamesFieldNumber = 3,
    kFieldNamesFieldNumber = 4,
    kContinuedFieldNumber = 5,
    kIndexFieldNumber = 6,
  };
  void set_pid(int32_t value) {
    AppendVarInt(1, value);
  }
  template <typename T = HeapGraphObject> T* add_objects() {
    return BeginNestedMessage<T>(2);
  }

  template <typename T = InternedString> T* add_type_names() {
    return BeginNestedMessage<T>(3);
  }

  template <typename T = InternedString> T* add_field_names() {
    return BeginNestedMessage<T>(4);
  }

  void set_continued(bool value) {
    AppendTinyVarInt(5, value);
  }
  void set_index(uint64_t value) {
    AppendVarInt(6, value);
  }
};

class HeapGraphObject_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  HeapGraphObject_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit HeapGraphObject_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit HeapGraphObject_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_id() const { return at<1>().valid(); }
  uint64_t id() const { return at<1>().as_uint64(); }
  bool has_type_id() const { return at<2>().valid(); }
  uint64_t type_id() const { return at<2>().as_uint64(); }
  bool has_self_size() const { return at<3>().valid(); }
  uint64_t self_size() const { return at<3>().as_uint64(); }
  bool has_reference_field_id() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator reference_field_id() const { return GetRepeated(4); }
  bool has_reference_object_id() const { return at<5>().valid(); }
  ::protozero::RepeatedFieldIterator reference_object_id() const { return GetRepeated(5); }
};

class HeapGraphObject : public ::protozero::Message {
 public:
  using Decoder = HeapGraphObject_Decoder;
  enum : int32_t {
    kIdFieldNumber = 1,
    kTypeIdFieldNumber = 2,
    kSelfSizeFieldNumber = 3,
    kReferenceFieldIdFieldNumber = 4,
    kReferenceObjectIdFieldNumber = 5,
  };
  void set_id(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_type_id(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_self_size(uint64_t value) {
    AppendVarInt(3, value);
  }
  void add_reference_field_id(uint64_t value) {
    AppendVarInt(4, value);
  }
  void add_reference_object_id(uint64_t value) {
    AppendVarInt(5, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/profiling/profile_common.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_PROFILING_PROFILE_COMMON_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_PROFILING_PROFILE_COMMON_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class Callstack_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  Callstack_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Callstack_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Callstack_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_iid() const { return at<1>().valid(); }
  uint64_t iid() const { return at<1>().as_uint64(); }
  bool has_frame_ids() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator frame_ids() const { return GetRepeated(2); }
};

class Callstack : public ::protozero::Message {
 public:
  using Decoder = Callstack_Decoder;
  enum : int32_t {
    kIidFieldNumber = 1,
    kFrameIdsFieldNumber = 2,
  };
  void set_iid(uint64_t value) {
    AppendVarInt(1, value);
  }
  void add_frame_ids(uint64_t value) {
    AppendVarInt(2, value);
  }
};

class Frame_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Frame_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Frame_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Frame_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_iid() const { return at<1>().valid(); }
  uint64_t iid() const { return at<1>().as_uint64(); }
  bool has_function_name_id() const { return at<2>().valid(); }
  uint64_t function_name_id() const { return at<2>().as_uint64(); }
  bool has_mapping_id() const { return at<3>().valid(); }
  uint64_t mapping_id() const { return at<3>().as_uint64(); }
  bool has_rel_pc() const { return at<4>().valid(); }
  uint64_t rel_pc() const { return at<4>().as_uint64(); }
};

class Frame : public ::protozero::Message {
 public:
  using Decoder = Frame_Decoder;
  enum : int32_t {
    kIidFieldNumber = 1,
    kFunctionNameIdFieldNumber = 2,
    kMappingIdFieldNumber = 3,
    kRelPcFieldNumber = 4,
  };
  void set_iid(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_function_name_id(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_mapping_id(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_rel_pc(uint64_t value) {
    AppendVarInt(4, value);
  }
};

class Mapping_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  Mapping_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Mapping_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Mapping_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_iid() const { return at<1>().valid(); }
  uint64_t iid() const { return at<1>().as_uint64(); }
  bool has_build_id() const { return at<2>().valid(); }
  uint64_t build_id() const { return at<2>().as_uint64(); }
  bool has_exact_offset() const { return at<8>().valid(); }
  uint64_t exact_offset() const { return at<8>().as_uint64(); }
  bool has_start_offset() const { return at<3>().valid(); }
  uint64_t start_offset() const { return at<3>().as_uint64(); }
  bool has_start() const { return at<4>().valid(); }
  uint64_t start() const { return at<4>().as_uint64(); }
  bool has_end() const { return at<5>().valid(); }
  uint64_t end() const { return at<5>().as_uint64(); }
  bool has_load_bias() const { return at<6>().valid(); }
  uint64_t load_bias() const { return at<6>().as_uint64(); }
  bool has_path_string_ids() const { return at<7>().valid(); }
  ::protozero::RepeatedFieldIterator path_string_ids() const { return GetRepeated(7); }
};

class Mapping : public ::protozero::Message {
 public:
  using Decoder = Mapping_Decoder;
  enum : int32_t {
    kIidFieldNumber = 1,
    kBuildIdFieldNumber = 2,
    kExactOffsetFieldNumber = 8,
    kStartOffsetFieldNumber = 3,
    kStartFieldNumber = 4,
    kEndFieldNumber = 5,
    kLoadBiasFieldNumber = 6,
    kPathStringIdsFieldNumber = 7,
  };
  void set_iid(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_build_id(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_exact_offset(uint64_t value) {
    AppendVarInt(8, value);
  }
  void set_start_offset(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_start(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_end(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_load_bias(uint64_t value) {
    AppendVarInt(6, value);
  }
  void add_path_string_ids(uint64_t value) {
    AppendVarInt(7, value);
  }
};

class ProfiledFrameSymbols_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  ProfiledFrameSymbols_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ProfiledFrameSymbols_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ProfiledFrameSymbols_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_frame_iid() const { return at<1>().valid(); }
  uint64_t frame_iid() const { return at<1>().as_uint64(); }
  bool has_function_name_id() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator function_name_id() const { return GetRepeated(2); }
  bool has_file_name_id() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator file_name_id() const { return GetRepeated(3); }
  bool has_line_number() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator line_number() const { return GetRepeated(4); }
};

class ProfiledFrameSymbols : public ::protozero::Message {
 public:
  using Decoder = ProfiledFrameSymbols_Decoder;
  enum : int32_t {
    kFrameIidFieldNumber = 1,
    kFunctionNameIdFieldNumber = 2,
    kFileNameIdFieldNumber = 3,
    kLineNumberFieldNumber = 4,
  };
  void set_frame_iid(uint64_t value) {
    AppendVarInt(1, value);
  }
  void add_function_name_id(uint64_t value) {
    AppendVarInt(2, value);
  }
  void add_file_name_id(uint64_t value) {
    AppendVarInt(3, value);
  }
  void add_line_number(uint32_t value) {
    AppendVarInt(4, value);
  }
};

class InternedString_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  InternedString_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit InternedString_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit InternedString_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_iid() const { return at<1>().valid(); }
  uint64_t iid() const { return at<1>().as_uint64(); }
  bool has_str() const { return at<2>().valid(); }
  ::protozero::ConstBytes str() const { return at<2>().as_bytes(); }
};

class InternedString : public ::protozero::Message {
 public:
  using Decoder = InternedString_Decoder;
  enum : int32_t {
    kIidFieldNumber = 1,
    kStrFieldNumber = 2,
  };
  void set_iid(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_str(const uint8_t* data, size_t size) {
    AppendBytes(2, data, size);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/profiling/profile_packet.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_PROFILING_PROFILE_PACKET_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_PROFILING_PROFILE_PACKET_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class Callstack;
class Frame;
class InternedString;
class Mapping;
class ProfilePacket_HeapSample;
class ProfilePacket_Histogram;
class ProfilePacket_Histogram_Bucket;
class ProfilePacket_ProcessHeapSamples;
class ProfilePacket_ProcessStats;

class StreamingProfilePacket_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  StreamingProfilePacket_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit StreamingProfilePacket_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit StreamingProfilePacket_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_callstack_iid() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator callstack_iid() const { return GetRepeated(1); }
  bool has_timestamp_delta_us() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator timestamp_delta_us() const { return GetRepeated(2); }
};

class StreamingProfilePacket : public ::protozero::Message {
 public:
  using Decoder = StreamingProfilePacket_Decoder;
  enum : int32_t {
    kCallstackIidFieldNumber = 1,
    kTimestampDeltaUsFieldNumber = 2,
  };
  void add_callstack_iid(uint64_t value) {
    AppendVarInt(1, value);
  }
  void add_timestamp_delta_us(int64_t value) {
    AppendVarInt(2, value);
  }
};

class ProfilePacket_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/7, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  ProfilePacket_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ProfilePacket_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ProfilePacket_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_strings() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator strings() const { return GetRepeated(1); }
  bool has_mappings() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator mappings() const { return GetRepeated(4); }
  bool has_frames() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator frames() const { return GetRepeated(2); }
  bool has_callstacks() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator callstacks() const { return GetRepeated(3); }
  bool has_process_dumps() const { return at<5>().valid(); }
  ::protozero::RepeatedFieldIterator process_dumps() const { return GetRepeated(5); }
  bool has_continued() const { return at<6>().valid(); }
  bool continued() const { return at<6>().as_bool(); }
  bool has_index() const { return at<7>().valid(); }
  uint64_t index() const { return at<7>().as_uint64(); }
};

class ProfilePacket : public ::protozero::Message {
 public:
  using Decoder = ProfilePacket_Decoder;
  enum : int32_t {
    kStringsFieldNumber = 1,
    kMappingsFieldNumber = 4,
    kFramesFieldNumber = 2,
    kCallstacksFieldNumber = 3,
    kProcessDumpsFieldNumber = 5,
    kContinuedFieldNumber = 6,
    kIndexFieldNumber = 7,
  };
  using HeapSample = ::perfetto::protos::pbzero::ProfilePacket_HeapSample;
  using Histogram = ::perfetto::protos::pbzero::ProfilePacket_Histogram;
  using ProcessStats = ::perfetto::protos::pbzero::ProfilePacket_ProcessStats;
  using ProcessHeapSamples = ::perfetto::protos::pbzero::ProfilePacket_ProcessHeapSamples;
  template <typename T = InternedString> T* add_strings() {
    return BeginNestedMessage<T>(1);
  }

  template <typename T = Mapping> T* add_mappings() {
    return BeginNestedMessage<T>(4);
  }

  template <typename T = Frame> T* add_frames() {
    return BeginNestedMessage<T>(2);
  }

  template <typename T = Callstack> T* add_callstacks() {
    return BeginNestedMessage<T>(3);
  }

  template <typename T = ProfilePacket_ProcessHeapSamples> T* add_process_dumps() {
    return BeginNestedMessage<T>(5);
  }

  void set_continued(bool value) {
    AppendTinyVarInt(6, value);
  }
  void set_index(uint64_t value) {
    AppendVarInt(7, value);
  }
};

class ProfilePacket_ProcessHeapSamples_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/9, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  ProfilePacket_ProcessHeapSamples_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ProfilePacket_ProcessHeapSamples_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ProfilePacket_ProcessHeapSamples_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_pid() const { return at<1>().valid(); }
  uint64_t pid() const { return at<1>().as_uint64(); }
  bool has_from_startup() const { return at<3>().valid(); }
  bool from_startup() const { return at<3>().as_bool(); }
  bool has_rejected_concurrent() const { return at<4>().valid(); }
  bool rejected_concurrent() const { return at<4>().as_bool(); }
  bool has_disconnected() const { return at<6>().valid(); }
  bool disconnected() const { return at<6>().as_bool(); }
  bool has_buffer_overran() const { return at<7>().valid(); }
  bool buffer_overran() const { return at<7>().as_bool(); }
  bool has_buffer_corrupted() const { return at<8>().valid(); }
  bool buffer_corrupted() const { return at<8>().as_bool(); }
  bool has_timestamp() const { return at<9>().valid(); }
  uint64_t timestamp() const { return at<9>().as_uint64(); }
  bool has_stats() const { return at<5>().valid(); }
  ::protozero::ConstBytes stats() const { return at<5>().as_bytes(); }
  bool has_samples() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator samples() const { return GetRepeated(2); }
};

class ProfilePacket_ProcessHeapSamples : public ::protozero::Message {
 public:
  using Decoder = ProfilePacket_ProcessHeapSamples_Decoder;
  enum : int32_t {
    kPidFieldNumber = 1,
    kFromStartupFieldNumber = 3,
    kRejectedConcurrentFieldNumber = 4,
    kDisconnectedFieldNumber = 6,
    kBufferOverranFieldNumber = 7,
    kBufferCorruptedFieldNumber = 8,
    kTimestampFieldNumber = 9,
    kStatsFieldNumber = 5,
    kSamplesFieldNumber = 2,
  };
  void set_pid(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_from_startup(bool value) {
    AppendTinyVarInt(3, value);
  }
  void set_rejected_concurrent(bool value) {
    AppendTinyVarInt(4, value);
  }
  void set_disconnected(bool value) {
    AppendTinyVarInt(6, value);
  }
  void set_buffer_overran(bool value) {
    AppendTinyVarInt(7, value);
  }
  void set_buffer_corrupted(bool value) {
    AppendTinyVarInt(8, value);
  }
  void set_timestamp(uint64_t value) {
    AppendVarInt(9, value);
  }
  template <typename T = ProfilePacket_ProcessStats> T* set_stats() {
    return BeginNestedMessage<T>(5);
  }

  template <typename T = ProfilePacket_HeapSample> T* add_samples() {
    return BeginNestedMessage<T>(2);
  }

};

class ProfilePacket_ProcessStats_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ProfilePacket_ProcessStats_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ProfilePacket_ProcessStats_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ProfilePacket_ProcessStats_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_unwinding_errors() const { return at<1>().valid(); }
  uint64_t unwinding_errors() const { return at<1>().as_uint64(); }
  bool has_heap_samples() const { return at<2>().valid(); }
  uint64_t heap_samples() const { return at<2>().as_uint64(); }
  bool has_map_reparses() const { return at<3>().valid(); }
  uint64_t map_reparses() const { return at<3>().as_uint64(); }
  bool has_unwinding_time_us() const { return at<4>().valid(); }
  ::protozero::ConstBytes unwinding_time_us() const { return at<4>().as_bytes(); }
  bool has_total_unwinding_time_us() const { return at<5>().valid(); }
  uint64_t total_unwinding_time_us() const { return at<5>().as_uint64(); }
};

class ProfilePacket_ProcessStats : public ::protozero::Message {
 public:
  using Decoder = ProfilePacket_ProcessStats_Decoder;
  enum : int32_t {
    kUnwindingErrorsFieldNumber = 1,
    kHeapSamplesFieldNumber = 2,
    kMapReparsesFieldNumber = 3,
    kUnwindingTimeUsFieldNumber = 4,
    kTotalUnwindingTimeUsFieldNumber = 5,
  };
  void set_unwinding_errors(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_heap_samples(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_map_reparses(uint64_t value) {
    AppendVarInt(3, value);
  }
  template <typename T = ProfilePacket_Histogram> T* set_unwinding_time_us() {
    return BeginNestedMessage<T>(4);
  }

  void set_total_unwinding_time_us(uint64_t value) {
    AppendVarInt(5, value);
  }
};

class ProfilePacket_Histogram_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  ProfilePacket_Histogram_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ProfilePacket_Histogram_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ProfilePacket_Histogram_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_buckets() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator buckets() const { return GetRepeated(1); }
};

class ProfilePacket_Histogram : public ::protozero::Message {
 public:
  using Decoder = ProfilePacket_Histogram_Decoder;
  enum : int32_t {
    kBucketsFieldNumber = 1,
  };
  using Bucket = ::perfetto::protos::pbzero::ProfilePacket_Histogram_Bucket;
  template <typename T = ProfilePacket_Histogram_Bucket> T* add_buckets() {
    return BeginNestedMessage<T>(1);
  }

};

class ProfilePacket_Histogram_Bucket_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ProfilePacket_Histogram_Bucket_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ProfilePacket_Histogram_Bucket_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ProfilePacket_Histogram_Bucket_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_upper_limit() const { return at<1>().valid(); }
  uint64_t upper_limit() const { return at<1>().as_uint64(); }
  bool has_max_bucket() const { return at<2>().valid(); }
  bool max_bucket() const { return at<2>().as_bool(); }
  bool has_count() const { return at<3>().valid(); }
  uint64_t count() const { return at<3>().as_uint64(); }
};

class ProfilePacket_Histogram_Bucket : public ::protozero::Message {
 public:
  using Decoder = ProfilePacket_Histogram_Bucket_Decoder;
  enum : int32_t {
    kUpperLimitFieldNumber = 1,
    kMaxBucketFieldNumber = 2,
    kCountFieldNumber = 3,
  };
  void set_upper_limit(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_max_bucket(bool value) {
    AppendTinyVarInt(2, value);
  }
  void set_count(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class ProfilePacket_HeapSample_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ProfilePacket_HeapSample_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ProfilePacket_HeapSample_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ProfilePacket_HeapSample_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_callstack_id() const { return at<1>().valid(); }
  uint64_t callstack_id() const { return at<1>().as_uint64(); }
  bool has_self_allocated() const { return at<2>().valid(); }
  uint64_t self_allocated() const { return at<2>().as_uint64(); }
  bool has_self_freed() const { return at<3>().valid(); }
  uint64_t self_freed() const { return at<3>().as_uint64(); }
  bool has_self_idle() const { return at<7>().valid(); }
  uint64_t self_idle() const { return at<7>().as_uint64(); }
  bool has_self_max() const { return at<8>().valid(); }
  uint64_t self_max() const { return at<8>().as_uint64(); }
  bool has_timestamp() const { return at<4>().valid(); }
  uint64_t timestamp() const { return at<4>().as_uint64(); }
  bool has_alloc_count() const { return at<5>().valid(); }
  uint64_t alloc_count() const { return at<5>().as_uint64(); }
  bool has_free_count() const { return at<6>().valid(); }
  uint64_t free_count() const { return at<6>().as_uint64(); }
};

class ProfilePacket_HeapSample : public ::protozero::Message {
 public:
  using Decoder = ProfilePacket_HeapSample_Decoder;
  enum : int32_t {
    kCallstackIdFieldNumber = 1,
    kSelfAllocatedFieldNumber = 2,
    kSelfFreedFieldNumber = 3,
    kSelfIdleFieldNumber = 7,
    kSelfMaxFieldNumber = 8,
    kTimestampFieldNumber = 4,
    kAllocCountFieldNumber = 5,
    kFreeCountFieldNumber = 6,
  };
  void set_callstack_id(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_self_allocated(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_self_freed(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_self_idle(uint64_t value) {
    AppendVarInt(7, value);
  }
  void set_self_max(uint64_t value) {
    AppendVarInt(8, value);
  }
  void set_timestamp(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_alloc_count(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_free_count(uint64_t value) {
    AppendVarInt(6, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/appended_data/appended_data.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_APPENDED_DATA_APPENDED_DATA_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_APPENDED_DATA_APPENDED_DATA_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class ProfiledFrameSymbols;

class AppendedData_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  AppendedData_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit AppendedData_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit AppendedData_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_profiled_frame_symbols() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator profiled_frame_symbols() const { return GetRepeated(1); }
};

class AppendedData : public ::protozero::Message {
 public:
  using Decoder = AppendedData_Decoder;
  enum : int32_t {
    kProfiledFrameSymbolsFieldNumber = 1,
  };
  template <typename T = ProfiledFrameSymbols> T* add_profiled_frame_symbols() {
    return BeginNestedMessage<T>(1);
  }

};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/chrome/chrome_benchmark_metadata.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_CHROME_CHROME_BENCHMARK_METADATA_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_CHROME_CHROME_BENCHMARK_METADATA_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class ChromeBenchmarkMetadata_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/9, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  ChromeBenchmarkMetadata_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ChromeBenchmarkMetadata_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ChromeBenchmarkMetadata_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_benchmark_start_time_us() const { return at<1>().valid(); }
  int64_t benchmark_start_time_us() const { return at<1>().as_int64(); }
  bool has_story_run_time_us() const { return at<2>().valid(); }
  int64_t story_run_time_us() const { return at<2>().as_int64(); }
  bool has_benchmark_name() const { return at<3>().valid(); }
  ::protozero::ConstChars benchmark_name() const { return at<3>().as_string(); }
  bool has_benchmark_description() const { return at<4>().valid(); }
  ::protozero::ConstChars benchmark_description() const { return at<4>().as_string(); }
  bool has_label() const { return at<5>().valid(); }
  ::protozero::ConstChars label() const { return at<5>().as_string(); }
  bool has_story_name() const { return at<6>().valid(); }
  ::protozero::ConstChars story_name() const { return at<6>().as_string(); }
  bool has_story_tags() const { return at<7>().valid(); }
  ::protozero::RepeatedFieldIterator story_tags() const { return GetRepeated(7); }
  bool has_story_run_index() const { return at<8>().valid(); }
  int32_t story_run_index() const { return at<8>().as_int32(); }
  bool has_had_failures() const { return at<9>().valid(); }
  bool had_failures() const { return at<9>().as_bool(); }
};

class ChromeBenchmarkMetadata : public ::protozero::Message {
 public:
  using Decoder = ChromeBenchmarkMetadata_Decoder;
  enum : int32_t {
    kBenchmarkStartTimeUsFieldNumber = 1,
    kStoryRunTimeUsFieldNumber = 2,
    kBenchmarkNameFieldNumber = 3,
    kBenchmarkDescriptionFieldNumber = 4,
    kLabelFieldNumber = 5,
    kStoryNameFieldNumber = 6,
    kStoryTagsFieldNumber = 7,
    kStoryRunIndexFieldNumber = 8,
    kHadFailuresFieldNumber = 9,
  };
  void set_benchmark_start_time_us(int64_t value) {
    AppendVarInt(1, value);
  }
  void set_story_run_time_us(int64_t value) {
    AppendVarInt(2, value);
  }
  void set_benchmark_name(const char* value) {
    AppendString(3, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_benchmark_name(const char* value, size_t size) {
    AppendBytes(3, value, size);
  }
  void set_benchmark_description(const char* value) {
    AppendString(4, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_benchmark_description(const char* value, size_t size) {
    AppendBytes(4, value, size);
  }
  void set_label(const char* value) {
    AppendString(5, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_label(const char* value, size_t size) {
    AppendBytes(5, value, size);
  }
  void set_story_name(const char* value) {
    AppendString(6, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_story_name(const char* value, size_t size) {
    AppendBytes(6, value, size);
  }
  void add_story_tags(const char* value) {
    AppendString(7, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void add_story_tags(const char* value, size_t size) {
    AppendBytes(7, value, size);
  }
  void set_story_run_index(int32_t value) {
    AppendVarInt(8, value);
  }
  void set_had_failures(bool value) {
    AppendTinyVarInt(9, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/chrome/chrome_metadata.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_CHROME_CHROME_METADATA_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_CHROME_CHROME_METADATA_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class BackgroundTracingMetadata;
class BackgroundTracingMetadata_TriggerRule;
class BackgroundTracingMetadata_TriggerRule_HistogramRule;
class BackgroundTracingMetadata_TriggerRule_NamedRule;
enum BackgroundTracingMetadata_TriggerRule_NamedRule_EventType : int32_t;
enum BackgroundTracingMetadata_TriggerRule_TriggerType : int32_t;

enum BackgroundTracingMetadata_TriggerRule_TriggerType : int32_t {
  BackgroundTracingMetadata_TriggerRule_TriggerType_TRIGGER_UNSPECIFIED = 0,
  BackgroundTracingMetadata_TriggerRule_TriggerType_MONITOR_AND_DUMP_WHEN_SPECIFIC_HISTOGRAM_AND_VALUE = 1,
  BackgroundTracingMetadata_TriggerRule_TriggerType_MONITOR_AND_DUMP_WHEN_TRIGGER_NAMED = 2,
};

const BackgroundTracingMetadata_TriggerRule_TriggerType BackgroundTracingMetadata_TriggerRule_TriggerType_MIN = BackgroundTracingMetadata_TriggerRule_TriggerType_TRIGGER_UNSPECIFIED;
const BackgroundTracingMetadata_TriggerRule_TriggerType BackgroundTracingMetadata_TriggerRule_TriggerType_MAX = BackgroundTracingMetadata_TriggerRule_TriggerType_MONITOR_AND_DUMP_WHEN_TRIGGER_NAMED;

enum BackgroundTracingMetadata_TriggerRule_NamedRule_EventType : int32_t {
  BackgroundTracingMetadata_TriggerRule_NamedRule_EventType_UNSPECIFIED = 0,
  BackgroundTracingMetadata_TriggerRule_NamedRule_EventType_SESSION_RESTORE = 1,
  BackgroundTracingMetadata_TriggerRule_NamedRule_EventType_NAVIGATION = 2,
  BackgroundTracingMetadata_TriggerRule_NamedRule_EventType_STARTUP = 3,
  BackgroundTracingMetadata_TriggerRule_NamedRule_EventType_TEST_RULE = 1000,
};

const BackgroundTracingMetadata_TriggerRule_NamedRule_EventType BackgroundTracingMetadata_TriggerRule_NamedRule_EventType_MIN = BackgroundTracingMetadata_TriggerRule_NamedRule_EventType_UNSPECIFIED;
const BackgroundTracingMetadata_TriggerRule_NamedRule_EventType BackgroundTracingMetadata_TriggerRule_NamedRule_EventType_MAX = BackgroundTracingMetadata_TriggerRule_NamedRule_EventType_TEST_RULE;

class BackgroundTracingMetadata_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  BackgroundTracingMetadata_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BackgroundTracingMetadata_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BackgroundTracingMetadata_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_triggered_rule() const { return at<1>().valid(); }
  ::protozero::ConstBytes triggered_rule() const { return at<1>().as_bytes(); }
  bool has_active_rules() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator active_rules() const { return GetRepeated(2); }
};

class BackgroundTracingMetadata : public ::protozero::Message {
 public:
  using Decoder = BackgroundTracingMetadata_Decoder;
  enum : int32_t {
    kTriggeredRuleFieldNumber = 1,
    kActiveRulesFieldNumber = 2,
  };
  using TriggerRule = ::perfetto::protos::pbzero::BackgroundTracingMetadata_TriggerRule;
  template <typename T = BackgroundTracingMetadata_TriggerRule> T* set_triggered_rule() {
    return BeginNestedMessage<T>(1);
  }

  template <typename T = BackgroundTracingMetadata_TriggerRule> T* add_active_rules() {
    return BeginNestedMessage<T>(2);
  }

};

class BackgroundTracingMetadata_TriggerRule_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BackgroundTracingMetadata_TriggerRule_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BackgroundTracingMetadata_TriggerRule_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BackgroundTracingMetadata_TriggerRule_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_trigger_type() const { return at<1>().valid(); }
  int32_t trigger_type() const { return at<1>().as_int32(); }
  bool has_histogram_rule() const { return at<2>().valid(); }
  ::protozero::ConstBytes histogram_rule() const { return at<2>().as_bytes(); }
  bool has_named_rule() const { return at<3>().valid(); }
  ::protozero::ConstBytes named_rule() const { return at<3>().as_bytes(); }
};

class BackgroundTracingMetadata_TriggerRule : public ::protozero::Message {
 public:
  using Decoder = BackgroundTracingMetadata_TriggerRule_Decoder;
  enum : int32_t {
    kTriggerTypeFieldNumber = 1,
    kHistogramRuleFieldNumber = 2,
    kNamedRuleFieldNumber = 3,
  };
  using HistogramRule = ::perfetto::protos::pbzero::BackgroundTracingMetadata_TriggerRule_HistogramRule;
  using NamedRule = ::perfetto::protos::pbzero::BackgroundTracingMetadata_TriggerRule_NamedRule;
  using TriggerType = ::perfetto::protos::pbzero::BackgroundTracingMetadata_TriggerRule_TriggerType;
  static const TriggerType TRIGGER_UNSPECIFIED = BackgroundTracingMetadata_TriggerRule_TriggerType_TRIGGER_UNSPECIFIED;
  static const TriggerType MONITOR_AND_DUMP_WHEN_SPECIFIC_HISTOGRAM_AND_VALUE = BackgroundTracingMetadata_TriggerRule_TriggerType_MONITOR_AND_DUMP_WHEN_SPECIFIC_HISTOGRAM_AND_VALUE;
  static const TriggerType MONITOR_AND_DUMP_WHEN_TRIGGER_NAMED = BackgroundTracingMetadata_TriggerRule_TriggerType_MONITOR_AND_DUMP_WHEN_TRIGGER_NAMED;
  void set_trigger_type(::perfetto::protos::pbzero::BackgroundTracingMetadata_TriggerRule_TriggerType value) {
    AppendTinyVarInt(1, value);
  }
  template <typename T = BackgroundTracingMetadata_TriggerRule_HistogramRule> T* set_histogram_rule() {
    return BeginNestedMessage<T>(2);
  }

  template <typename T = BackgroundTracingMetadata_TriggerRule_NamedRule> T* set_named_rule() {
    return BeginNestedMessage<T>(3);
  }

};

class BackgroundTracingMetadata_TriggerRule_NamedRule_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BackgroundTracingMetadata_TriggerRule_NamedRule_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BackgroundTracingMetadata_TriggerRule_NamedRule_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BackgroundTracingMetadata_TriggerRule_NamedRule_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_event_type() const { return at<1>().valid(); }
  int32_t event_type() const { return at<1>().as_int32(); }
};

class BackgroundTracingMetadata_TriggerRule_NamedRule : public ::protozero::Message {
 public:
  using Decoder = BackgroundTracingMetadata_TriggerRule_NamedRule_Decoder;
  enum : int32_t {
    kEventTypeFieldNumber = 1,
  };
  using EventType = ::perfetto::protos::pbzero::BackgroundTracingMetadata_TriggerRule_NamedRule_EventType;
  static const EventType UNSPECIFIED = BackgroundTracingMetadata_TriggerRule_NamedRule_EventType_UNSPECIFIED;
  static const EventType SESSION_RESTORE = BackgroundTracingMetadata_TriggerRule_NamedRule_EventType_SESSION_RESTORE;
  static const EventType NAVIGATION = BackgroundTracingMetadata_TriggerRule_NamedRule_EventType_NAVIGATION;
  static const EventType STARTUP = BackgroundTracingMetadata_TriggerRule_NamedRule_EventType_STARTUP;
  static const EventType TEST_RULE = BackgroundTracingMetadata_TriggerRule_NamedRule_EventType_TEST_RULE;
  void set_event_type(::perfetto::protos::pbzero::BackgroundTracingMetadata_TriggerRule_NamedRule_EventType value) {
    AppendVarInt(1, value);
  }
};

class BackgroundTracingMetadata_TriggerRule_HistogramRule_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BackgroundTracingMetadata_TriggerRule_HistogramRule_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BackgroundTracingMetadata_TriggerRule_HistogramRule_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BackgroundTracingMetadata_TriggerRule_HistogramRule_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_histogram_name_hash() const { return at<1>().valid(); }
  uint64_t histogram_name_hash() const { return at<1>().as_uint64(); }
  bool has_histogram_min_trigger() const { return at<2>().valid(); }
  int64_t histogram_min_trigger() const { return at<2>().as_int64(); }
  bool has_histogram_max_trigger() const { return at<3>().valid(); }
  int64_t histogram_max_trigger() const { return at<3>().as_int64(); }
};

class BackgroundTracingMetadata_TriggerRule_HistogramRule : public ::protozero::Message {
 public:
  using Decoder = BackgroundTracingMetadata_TriggerRule_HistogramRule_Decoder;
  enum : int32_t {
    kHistogramNameHashFieldNumber = 1,
    kHistogramMinTriggerFieldNumber = 2,
    kHistogramMaxTriggerFieldNumber = 3,
  };
  void set_histogram_name_hash(uint64_t value) {
    AppendFixed(1, value);
  }
  void set_histogram_min_trigger(int64_t value) {
    AppendVarInt(2, value);
  }
  void set_histogram_max_trigger(int64_t value) {
    AppendVarInt(3, value);
  }
};

class ChromeMetadataPacket_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ChromeMetadataPacket_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ChromeMetadataPacket_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ChromeMetadataPacket_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_background_tracing_metadata() const { return at<1>().valid(); }
  ::protozero::ConstBytes background_tracing_metadata() const { return at<1>().as_bytes(); }
  bool has_chrome_version_code() const { return at<2>().valid(); }
  int32_t chrome_version_code() const { return at<2>().as_int32(); }
};

class ChromeMetadataPacket : public ::protozero::Message {
 public:
  using Decoder = ChromeMetadataPacket_Decoder;
  enum : int32_t {
    kBackgroundTracingMetadataFieldNumber = 1,
    kChromeVersionCodeFieldNumber = 2,
  };
  template <typename T = BackgroundTracingMetadata> T* set_background_tracing_metadata() {
    return BeginNestedMessage<T>(1);
  }

  void set_chrome_version_code(int32_t value) {
    AppendVarInt(2, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/chrome/chrome_trace_event.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_CHROME_CHROME_TRACE_EVENT_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_CHROME_CHROME_TRACE_EVENT_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class ChromeLegacyJsonTrace;
class ChromeMetadata;
class ChromeStringTableEntry;
class ChromeTraceEvent;
class ChromeTraceEvent_Arg;
class ChromeTracedValue;
enum ChromeLegacyJsonTrace_TraceType : int32_t;
enum ChromeTracedValue_NestedType : int32_t;

enum ChromeLegacyJsonTrace_TraceType : int32_t {
  ChromeLegacyJsonTrace_TraceType_USER_TRACE = 0,
  ChromeLegacyJsonTrace_TraceType_SYSTEM_TRACE = 1,
};

const ChromeLegacyJsonTrace_TraceType ChromeLegacyJsonTrace_TraceType_MIN = ChromeLegacyJsonTrace_TraceType_USER_TRACE;
const ChromeLegacyJsonTrace_TraceType ChromeLegacyJsonTrace_TraceType_MAX = ChromeLegacyJsonTrace_TraceType_SYSTEM_TRACE;

enum ChromeTracedValue_NestedType : int32_t {
  ChromeTracedValue_NestedType_DICT = 0,
  ChromeTracedValue_NestedType_ARRAY = 1,
};

const ChromeTracedValue_NestedType ChromeTracedValue_NestedType_MIN = ChromeTracedValue_NestedType_DICT;
const ChromeTracedValue_NestedType ChromeTracedValue_NestedType_MAX = ChromeTracedValue_NestedType_ARRAY;

class ChromeEventBundle_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  ChromeEventBundle_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ChromeEventBundle_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ChromeEventBundle_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_trace_events() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator trace_events() const { return GetRepeated(1); }
  bool has_metadata() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator metadata() const { return GetRepeated(2); }
  bool has_legacy_ftrace_output() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator legacy_ftrace_output() const { return GetRepeated(4); }
  bool has_legacy_json_trace() const { return at<5>().valid(); }
  ::protozero::RepeatedFieldIterator legacy_json_trace() const { return GetRepeated(5); }
  bool has_string_table() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator string_table() const { return GetRepeated(3); }
};

class ChromeEventBundle : public ::protozero::Message {
 public:
  using Decoder = ChromeEventBundle_Decoder;
  enum : int32_t {
    kTraceEventsFieldNumber = 1,
    kMetadataFieldNumber = 2,
    kLegacyFtraceOutputFieldNumber = 4,
    kLegacyJsonTraceFieldNumber = 5,
    kStringTableFieldNumber = 3,
  };
  template <typename T = ChromeTraceEvent> T* add_trace_events() {
    return BeginNestedMessage<T>(1);
  }

  template <typename T = ChromeMetadata> T* add_metadata() {
    return BeginNestedMessage<T>(2);
  }

  void add_legacy_ftrace_output(const char* value) {
    AppendString(4, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void add_legacy_ftrace_output(const char* value, size_t size) {
    AppendBytes(4, value, size);
  }
  template <typename T = ChromeLegacyJsonTrace> T* add_legacy_json_trace() {
    return BeginNestedMessage<T>(5);
  }

  template <typename T = ChromeStringTableEntry> T* add_string_table() {
    return BeginNestedMessage<T>(3);
  }

};

class ChromeLegacyJsonTrace_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ChromeLegacyJsonTrace_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ChromeLegacyJsonTrace_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ChromeLegacyJsonTrace_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_type() const { return at<1>().valid(); }
  int32_t type() const { return at<1>().as_int32(); }
  bool has_data() const { return at<2>().valid(); }
  ::protozero::ConstChars data() const { return at<2>().as_string(); }
};

class ChromeLegacyJsonTrace : public ::protozero::Message {
 public:
  using Decoder = ChromeLegacyJsonTrace_Decoder;
  enum : int32_t {
    kTypeFieldNumber = 1,
    kDataFieldNumber = 2,
  };
  using TraceType = ::perfetto::protos::pbzero::ChromeLegacyJsonTrace_TraceType;
  static const TraceType USER_TRACE = ChromeLegacyJsonTrace_TraceType_USER_TRACE;
  static const TraceType SYSTEM_TRACE = ChromeLegacyJsonTrace_TraceType_SYSTEM_TRACE;
  void set_type(::perfetto::protos::pbzero::ChromeLegacyJsonTrace_TraceType value) {
    AppendTinyVarInt(1, value);
  }
  void set_data(const char* value) {
    AppendString(2, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_data(const char* value, size_t size) {
    AppendBytes(2, value, size);
  }
};

class ChromeMetadata_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ChromeMetadata_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ChromeMetadata_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ChromeMetadata_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_string_value() const { return at<2>().valid(); }
  ::protozero::ConstChars string_value() const { return at<2>().as_string(); }
  bool has_bool_value() const { return at<3>().valid(); }
  bool bool_value() const { return at<3>().as_bool(); }
  bool has_int_value() const { return at<4>().valid(); }
  int64_t int_value() const { return at<4>().as_int64(); }
  bool has_json_value() const { return at<5>().valid(); }
  ::protozero::ConstChars json_value() const { return at<5>().as_string(); }
};

class ChromeMetadata : public ::protozero::Message {
 public:
  using Decoder = ChromeMetadata_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kStringValueFieldNumber = 2,
    kBoolValueFieldNumber = 3,
    kIntValueFieldNumber = 4,
    kJsonValueFieldNumber = 5,
  };
  void set_name(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_name(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_string_value(const char* value) {
    AppendString(2, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_string_value(const char* value, size_t size) {
    AppendBytes(2, value, size);
  }
  void set_bool_value(bool value) {
    AppendTinyVarInt(3, value);
  }
  void set_int_value(int64_t value) {
    AppendVarInt(4, value);
  }
  void set_json_value(const char* value) {
    AppendString(5, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_json_value(const char* value, size_t size) {
    AppendBytes(5, value, size);
  }
};

class ChromeTraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/16, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  ChromeTraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ChromeTraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ChromeTraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_timestamp() const { return at<2>().valid(); }
  int64_t timestamp() const { return at<2>().as_int64(); }
  bool has_phase() const { return at<3>().valid(); }
  int32_t phase() const { return at<3>().as_int32(); }
  bool has_thread_id() const { return at<4>().valid(); }
  int32_t thread_id() const { return at<4>().as_int32(); }
  bool has_duration() const { return at<5>().valid(); }
  int64_t duration() const { return at<5>().as_int64(); }
  bool has_thread_duration() const { return at<6>().valid(); }
  int64_t thread_duration() const { return at<6>().as_int64(); }
  bool has_scope() const { return at<7>().valid(); }
  ::protozero::ConstChars scope() const { return at<7>().as_string(); }
  bool has_id() const { return at<8>().valid(); }
  uint64_t id() const { return at<8>().as_uint64(); }
  bool has_flags() const { return at<9>().valid(); }
  uint32_t flags() const { return at<9>().as_uint32(); }
  bool has_category_group_name() const { return at<10>().valid(); }
  ::protozero::ConstChars category_group_name() const { return at<10>().as_string(); }
  bool has_process_id() const { return at<11>().valid(); }
  int32_t process_id() const { return at<11>().as_int32(); }
  bool has_thread_timestamp() const { return at<12>().valid(); }
  int64_t thread_timestamp() const { return at<12>().as_int64(); }
  bool has_bind_id() const { return at<13>().valid(); }
  uint64_t bind_id() const { return at<13>().as_uint64(); }
  bool has_args() const { return at<14>().valid(); }
  ::protozero::RepeatedFieldIterator args() const { return GetRepeated(14); }
  bool has_name_index() const { return at<15>().valid(); }
  uint32_t name_index() const { return at<15>().as_uint32(); }
  bool has_category_group_name_index() const { return at<16>().valid(); }
  uint32_t category_group_name_index() const { return at<16>().as_uint32(); }
};

class ChromeTraceEvent : public ::protozero::Message {
 public:
  using Decoder = ChromeTraceEvent_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kTimestampFieldNumber = 2,
    kPhaseFieldNumber = 3,
    kThreadIdFieldNumber = 4,
    kDurationFieldNumber = 5,
    kThreadDurationFieldNumber = 6,
    kScopeFieldNumber = 7,
    kIdFieldNumber = 8,
    kFlagsFieldNumber = 9,
    kCategoryGroupNameFieldNumber = 10,
    kProcessIdFieldNumber = 11,
    kThreadTimestampFieldNumber = 12,
    kBindIdFieldNumber = 13,
    kArgsFieldNumber = 14,
    kNameIndexFieldNumber = 15,
    kCategoryGroupNameIndexFieldNumber = 16,
  };
  using Arg = ::perfetto::protos::pbzero::ChromeTraceEvent_Arg;
  void set_name(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_name(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_timestamp(int64_t value) {
    AppendVarInt(2, value);
  }
  void set_phase(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_thread_id(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_duration(int64_t value) {
    AppendVarInt(5, value);
  }
  void set_thread_duration(int64_t value) {
    AppendVarInt(6, value);
  }
  void set_scope(const char* value) {
    AppendString(7, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_scope(const char* value, size_t size) {
    AppendBytes(7, value, size);
  }
  void set_id(uint64_t value) {
    AppendVarInt(8, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(9, value);
  }
  void set_category_group_name(const char* value) {
    AppendString(10, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_category_group_name(const char* value, size_t size) {
    AppendBytes(10, value, size);
  }
  void set_process_id(int32_t value) {
    AppendVarInt(11, value);
  }
  void set_thread_timestamp(int64_t value) {
    AppendVarInt(12, value);
  }
  void set_bind_id(uint64_t value) {
    AppendVarInt(13, value);
  }
  template <typename T = ChromeTraceEvent_Arg> T* add_args() {
    return BeginNestedMessage<T>(14);
  }

  void set_name_index(uint32_t value) {
    AppendVarInt(15, value);
  }
  void set_category_group_name_index(uint32_t value) {
    AppendVarInt(16, value);
  }
};

class ChromeTraceEvent_Arg_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/10, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ChromeTraceEvent_Arg_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ChromeTraceEvent_Arg_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ChromeTraceEvent_Arg_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_bool_value() const { return at<2>().valid(); }
  bool bool_value() const { return at<2>().as_bool(); }
  bool has_uint_value() const { return at<3>().valid(); }
  uint64_t uint_value() const { return at<3>().as_uint64(); }
  bool has_int_value() const { return at<4>().valid(); }
  int64_t int_value() const { return at<4>().as_int64(); }
  bool has_double_value() const { return at<5>().valid(); }
  double double_value() const { return at<5>().as_double(); }
  bool has_string_value() const { return at<6>().valid(); }
  ::protozero::ConstChars string_value() const { return at<6>().as_string(); }
  bool has_pointer_value() const { return at<7>().valid(); }
  uint64_t pointer_value() const { return at<7>().as_uint64(); }
  bool has_json_value() const { return at<8>().valid(); }
  ::protozero::ConstChars json_value() const { return at<8>().as_string(); }
  bool has_traced_value() const { return at<10>().valid(); }
  ::protozero::ConstBytes traced_value() const { return at<10>().as_bytes(); }
  bool has_name_index() const { return at<9>().valid(); }
  uint32_t name_index() const { return at<9>().as_uint32(); }
};

class ChromeTraceEvent_Arg : public ::protozero::Message {
 public:
  using Decoder = ChromeTraceEvent_Arg_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kBoolValueFieldNumber = 2,
    kUintValueFieldNumber = 3,
    kIntValueFieldNumber = 4,
    kDoubleValueFieldNumber = 5,
    kStringValueFieldNumber = 6,
    kPointerValueFieldNumber = 7,
    kJsonValueFieldNumber = 8,
    kTracedValueFieldNumber = 10,
    kNameIndexFieldNumber = 9,
  };
  void set_name(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_name(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_bool_value(bool value) {
    AppendTinyVarInt(2, value);
  }
  void set_uint_value(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_int_value(int64_t value) {
    AppendVarInt(4, value);
  }
  void set_double_value(double value) {
    AppendFixed(5, value);
  }
  void set_string_value(const char* value) {
    AppendString(6, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_string_value(const char* value, size_t size) {
    AppendBytes(6, value, size);
  }
  void set_pointer_value(uint64_t value) {
    AppendVarInt(7, value);
  }
  void set_json_value(const char* value) {
    AppendString(8, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_json_value(const char* value, size_t size) {
    AppendBytes(8, value, size);
  }
  template <typename T = ChromeTracedValue> T* set_traced_value() {
    return BeginNestedMessage<T>(10);
  }

  void set_name_index(uint32_t value) {
    AppendVarInt(9, value);
  }
};

class ChromeStringTableEntry_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ChromeStringTableEntry_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ChromeStringTableEntry_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ChromeStringTableEntry_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_value() const { return at<1>().valid(); }
  ::protozero::ConstChars value() const { return at<1>().as_string(); }
  bool has_index() const { return at<2>().valid(); }
  int32_t index() const { return at<2>().as_int32(); }
};

class ChromeStringTableEntry : public ::protozero::Message {
 public:
  using Decoder = ChromeStringTableEntry_Decoder;
  enum : int32_t {
    kValueFieldNumber = 1,
    kIndexFieldNumber = 2,
  };
  void set_value(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_value(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_index(int32_t value) {
    AppendVarInt(2, value);
  }
};

class ChromeTracedValue_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  ChromeTracedValue_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ChromeTracedValue_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ChromeTracedValue_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_nested_type() const { return at<1>().valid(); }
  int32_t nested_type() const { return at<1>().as_int32(); }
  bool has_dict_keys() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator dict_keys() const { return GetRepeated(2); }
  bool has_dict_values() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator dict_values() const { return GetRepeated(3); }
  bool has_array_values() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator array_values() const { return GetRepeated(4); }
  bool has_int_value() const { return at<5>().valid(); }
  int32_t int_value() const { return at<5>().as_int32(); }
  bool has_double_value() const { return at<6>().valid(); }
  double double_value() const { return at<6>().as_double(); }
  bool has_bool_value() const { return at<7>().valid(); }
  bool bool_value() const { return at<7>().as_bool(); }
  bool has_string_value() const { return at<8>().valid(); }
  ::protozero::ConstChars string_value() const { return at<8>().as_string(); }
};

class ChromeTracedValue : public ::protozero::Message {
 public:
  using Decoder = ChromeTracedValue_Decoder;
  enum : int32_t {
    kNestedTypeFieldNumber = 1,
    kDictKeysFieldNumber = 2,
    kDictValuesFieldNumber = 3,
    kArrayValuesFieldNumber = 4,
    kIntValueFieldNumber = 5,
    kDoubleValueFieldNumber = 6,
    kBoolValueFieldNumber = 7,
    kStringValueFieldNumber = 8,
  };
  using NestedType = ::perfetto::protos::pbzero::ChromeTracedValue_NestedType;
  static const NestedType DICT = ChromeTracedValue_NestedType_DICT;
  static const NestedType ARRAY = ChromeTracedValue_NestedType_ARRAY;
  void set_nested_type(::perfetto::protos::pbzero::ChromeTracedValue_NestedType value) {
    AppendTinyVarInt(1, value);
  }
  void add_dict_keys(const char* value) {
    AppendString(2, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void add_dict_keys(const char* value, size_t size) {
    AppendBytes(2, value, size);
  }
  template <typename T = ChromeTracedValue> T* add_dict_values() {
    return BeginNestedMessage<T>(3);
  }

  template <typename T = ChromeTracedValue> T* add_array_values() {
    return BeginNestedMessage<T>(4);
  }

  void set_int_value(int32_t value) {
    AppendVarInt(5, value);
  }
  void set_double_value(double value) {
    AppendFixed(6, value);
  }
  void set_bool_value(bool value) {
    AppendTinyVarInt(7, value);
  }
  void set_string_value(const char* value) {
    AppendString(8, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_string_value(const char* value, size_t size) {
    AppendBytes(8, value, size);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/filesystem/inode_file_map.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FILESYSTEM_INODE_FILE_MAP_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FILESYSTEM_INODE_FILE_MAP_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class InodeFileMap_Entry;
enum InodeFileMap_Entry_Type : int32_t;

enum InodeFileMap_Entry_Type : int32_t {
  InodeFileMap_Entry_Type_UNKNOWN = 0,
  InodeFileMap_Entry_Type_FILE = 1,
  InodeFileMap_Entry_Type_DIRECTORY = 2,
};

const InodeFileMap_Entry_Type InodeFileMap_Entry_Type_MIN = InodeFileMap_Entry_Type_UNKNOWN;
const InodeFileMap_Entry_Type InodeFileMap_Entry_Type_MAX = InodeFileMap_Entry_Type_DIRECTORY;

class InodeFileMap_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  InodeFileMap_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit InodeFileMap_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit InodeFileMap_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_block_device_id() const { return at<1>().valid(); }
  uint64_t block_device_id() const { return at<1>().as_uint64(); }
  bool has_mount_points() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator mount_points() const { return GetRepeated(2); }
  bool has_entries() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator entries() const { return GetRepeated(3); }
};

class InodeFileMap : public ::protozero::Message {
 public:
  using Decoder = InodeFileMap_Decoder;
  enum : int32_t {
    kBlockDeviceIdFieldNumber = 1,
    kMountPointsFieldNumber = 2,
    kEntriesFieldNumber = 3,
  };
  using Entry = ::perfetto::protos::pbzero::InodeFileMap_Entry;
  void set_block_device_id(uint64_t value) {
    AppendVarInt(1, value);
  }
  void add_mount_points(const char* value) {
    AppendString(2, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void add_mount_points(const char* value, size_t size) {
    AppendBytes(2, value, size);
  }
  template <typename T = InodeFileMap_Entry> T* add_entries() {
    return BeginNestedMessage<T>(3);
  }

};

class InodeFileMap_Entry_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  InodeFileMap_Entry_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit InodeFileMap_Entry_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit InodeFileMap_Entry_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_inode_number() const { return at<1>().valid(); }
  uint64_t inode_number() const { return at<1>().as_uint64(); }
  bool has_paths() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator paths() const { return GetRepeated(2); }
  bool has_type() const { return at<3>().valid(); }
  int32_t type() const { return at<3>().as_int32(); }
};

class InodeFileMap_Entry : public ::protozero::Message {
 public:
  using Decoder = InodeFileMap_Entry_Decoder;
  enum : int32_t {
    kInodeNumberFieldNumber = 1,
    kPathsFieldNumber = 2,
    kTypeFieldNumber = 3,
  };
  using Type = ::perfetto::protos::pbzero::InodeFileMap_Entry_Type;
  static const Type UNKNOWN = InodeFileMap_Entry_Type_UNKNOWN;
  static const Type FILE = InodeFileMap_Entry_Type_FILE;
  static const Type DIRECTORY = InodeFileMap_Entry_Type_DIRECTORY;
  void set_inode_number(uint64_t value) {
    AppendVarInt(1, value);
  }
  void add_paths(const char* value) {
    AppendString(2, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void add_paths(const char* value, size_t size) {
    AppendBytes(2, value, size);
  }
  void set_type(::perfetto::protos::pbzero::InodeFileMap_Entry_Type value) {
    AppendTinyVarInt(3, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/ftrace_event.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_FTRACE_EVENT_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_FTRACE_EVENT_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class AllocPagesIommuEndFtraceEvent;
class AllocPagesIommuFailFtraceEvent;
class AllocPagesIommuStartFtraceEvent;
class AllocPagesSysEndFtraceEvent;
class AllocPagesSysFailFtraceEvent;
class AllocPagesSysStartFtraceEvent;
class BinderLockFtraceEvent;
class BinderLockedFtraceEvent;
class BinderSetPriorityFtraceEvent;
class BinderTransactionAllocBufFtraceEvent;
class BinderTransactionFtraceEvent;
class BinderTransactionReceivedFtraceEvent;
class BinderUnlockFtraceEvent;
class BlockBioBackmergeFtraceEvent;
class BlockBioBounceFtraceEvent;
class BlockBioCompleteFtraceEvent;
class BlockBioFrontmergeFtraceEvent;
class BlockBioQueueFtraceEvent;
class BlockBioRemapFtraceEvent;
class BlockDirtyBufferFtraceEvent;
class BlockGetrqFtraceEvent;
class BlockPlugFtraceEvent;
class BlockRqAbortFtraceEvent;
class BlockRqCompleteFtraceEvent;
class BlockRqInsertFtraceEvent;
class BlockRqIssueFtraceEvent;
class BlockRqRemapFtraceEvent;
class BlockRqRequeueFtraceEvent;
class BlockSleeprqFtraceEvent;
class BlockSplitFtraceEvent;
class BlockTouchBufferFtraceEvent;
class BlockUnplugFtraceEvent;
class CgroupAttachTaskFtraceEvent;
class CgroupDestroyRootFtraceEvent;
class CgroupMkdirFtraceEvent;
class CgroupReleaseFtraceEvent;
class CgroupRemountFtraceEvent;
class CgroupRenameFtraceEvent;
class CgroupRmdirFtraceEvent;
class CgroupSetupRootFtraceEvent;
class CgroupTransferTasksFtraceEvent;
class ClkDisableFtraceEvent;
class ClkEnableFtraceEvent;
class ClkSetRateFtraceEvent;
class ClockDisableFtraceEvent;
class ClockEnableFtraceEvent;
class ClockSetRateFtraceEvent;
class CpuFrequencyFtraceEvent;
class CpuFrequencyLimitsFtraceEvent;
class CpuIdleFtraceEvent;
class DmaAllocContiguousRetryFtraceEvent;
class Ext4AllocDaBlocksFtraceEvent;
class Ext4AllocateBlocksFtraceEvent;
class Ext4AllocateInodeFtraceEvent;
class Ext4BeginOrderedTruncateFtraceEvent;
class Ext4CollapseRangeFtraceEvent;
class Ext4DaReleaseSpaceFtraceEvent;
class Ext4DaReserveSpaceFtraceEvent;
class Ext4DaUpdateReserveSpaceFtraceEvent;
class Ext4DaWriteBeginFtraceEvent;
class Ext4DaWriteEndFtraceEvent;
class Ext4DaWritePagesExtentFtraceEvent;
class Ext4DaWritePagesFtraceEvent;
class Ext4DirectIOEnterFtraceEvent;
class Ext4DirectIOExitFtraceEvent;
class Ext4DiscardBlocksFtraceEvent;
class Ext4DiscardPreallocationsFtraceEvent;
class Ext4DropInodeFtraceEvent;
class Ext4EsCacheExtentFtraceEvent;
class Ext4EsFindDelayedExtentRangeEnterFtraceEvent;
class Ext4EsFindDelayedExtentRangeExitFtraceEvent;
class Ext4EsInsertExtentFtraceEvent;
class Ext4EsLookupExtentEnterFtraceEvent;
class Ext4EsLookupExtentExitFtraceEvent;
class Ext4EsRemoveExtentFtraceEvent;
class Ext4EsShrinkCountFtraceEvent;
class Ext4EsShrinkFtraceEvent;
class Ext4EsShrinkScanEnterFtraceEvent;
class Ext4EsShrinkScanExitFtraceEvent;
class Ext4EvictInodeFtraceEvent;
class Ext4ExtConvertToInitializedEnterFtraceEvent;
class Ext4ExtConvertToInitializedFastpathFtraceEvent;
class Ext4ExtHandleUnwrittenExtentsFtraceEvent;
class Ext4ExtInCacheFtraceEvent;
class Ext4ExtLoadExtentFtraceEvent;
class Ext4ExtMapBlocksEnterFtraceEvent;
class Ext4ExtMapBlocksExitFtraceEvent;
class Ext4ExtPutInCacheFtraceEvent;
class Ext4ExtRemoveSpaceDoneFtraceEvent;
class Ext4ExtRemoveSpaceFtraceEvent;
class Ext4ExtRmIdxFtraceEvent;
class Ext4ExtRmLeafFtraceEvent;
class Ext4ExtShowExtentFtraceEvent;
class Ext4FallocateEnterFtraceEvent;
class Ext4FallocateExitFtraceEvent;
class Ext4FindDelallocRangeFtraceEvent;
class Ext4ForgetFtraceEvent;
class Ext4FreeBlocksFtraceEvent;
class Ext4FreeInodeFtraceEvent;
class Ext4GetImpliedClusterAllocExitFtraceEvent;
class Ext4GetReservedClusterAllocFtraceEvent;
class Ext4IndMapBlocksEnterFtraceEvent;
class Ext4IndMapBlocksExitFtraceEvent;
class Ext4InsertRangeFtraceEvent;
class Ext4InvalidatepageFtraceEvent;
class Ext4JournalStartFtraceEvent;
class Ext4JournalStartReservedFtraceEvent;
class Ext4JournalledInvalidatepageFtraceEvent;
class Ext4JournalledWriteEndFtraceEvent;
class Ext4LoadInodeBitmapFtraceEvent;
class Ext4LoadInodeFtraceEvent;
class Ext4MarkInodeDirtyFtraceEvent;
class Ext4MbBitmapLoadFtraceEvent;
class Ext4MbBuddyBitmapLoadFtraceEvent;
class Ext4MbDiscardPreallocationsFtraceEvent;
class Ext4MbNewGroupPaFtraceEvent;
class Ext4MbNewInodePaFtraceEvent;
class Ext4MbReleaseGroupPaFtraceEvent;
class Ext4MbReleaseInodePaFtraceEvent;
class Ext4MballocAllocFtraceEvent;
class Ext4MballocDiscardFtraceEvent;
class Ext4MballocFreeFtraceEvent;
class Ext4MballocPreallocFtraceEvent;
class Ext4OtherInodeUpdateTimeFtraceEvent;
class Ext4PunchHoleFtraceEvent;
class Ext4ReadBlockBitmapLoadFtraceEvent;
class Ext4ReadpageFtraceEvent;
class Ext4ReleasepageFtraceEvent;
class Ext4RemoveBlocksFtraceEvent;
class Ext4RequestBlocksFtraceEvent;
class Ext4RequestInodeFtraceEvent;
class Ext4SyncFileEnterFtraceEvent;
class Ext4SyncFileExitFtraceEvent;
class Ext4SyncFsFtraceEvent;
class Ext4TrimAllFreeFtraceEvent;
class Ext4TrimExtentFtraceEvent;
class Ext4TruncateEnterFtraceEvent;
class Ext4TruncateExitFtraceEvent;
class Ext4UnlinkEnterFtraceEvent;
class Ext4UnlinkExitFtraceEvent;
class Ext4WriteBeginFtraceEvent;
class Ext4WriteEndFtraceEvent;
class Ext4WritepageFtraceEvent;
class Ext4WritepagesFtraceEvent;
class Ext4WritepagesResultFtraceEvent;
class Ext4ZeroRangeFtraceEvent;
class F2fsDoSubmitBioFtraceEvent;
class F2fsEvictInodeFtraceEvent;
class F2fsFallocateFtraceEvent;
class F2fsGetDataBlockFtraceEvent;
class F2fsGetVictimFtraceEvent;
class F2fsIgetExitFtraceEvent;
class F2fsIgetFtraceEvent;
class F2fsNewInodeFtraceEvent;
class F2fsReadpageFtraceEvent;
class F2fsReserveNewBlockFtraceEvent;
class F2fsSetPageDirtyFtraceEvent;
class F2fsSubmitWritePageFtraceEvent;
class F2fsSyncFileEnterFtraceEvent;
class F2fsSyncFileExitFtraceEvent;
class F2fsSyncFsFtraceEvent;
class F2fsTruncateBlocksEnterFtraceEvent;
class F2fsTruncateBlocksExitFtraceEvent;
class F2fsTruncateDataBlocksRangeFtraceEvent;
class F2fsTruncateFtraceEvent;
class F2fsTruncateInodeBlocksEnterFtraceEvent;
class F2fsTruncateInodeBlocksExitFtraceEvent;
class F2fsTruncateNodeFtraceEvent;
class F2fsTruncateNodesEnterFtraceEvent;
class F2fsTruncateNodesExitFtraceEvent;
class F2fsTruncatePartialNodesFtraceEvent;
class F2fsUnlinkEnterFtraceEvent;
class F2fsUnlinkExitFtraceEvent;
class F2fsVmPageMkwriteFtraceEvent;
class F2fsWriteBeginFtraceEvent;
class F2fsWriteCheckpointFtraceEvent;
class F2fsWriteEndFtraceEvent;
class FenceDestroyFtraceEvent;
class FenceEnableSignalFtraceEvent;
class FenceInitFtraceEvent;
class FenceSignaledFtraceEvent;
class GenericFtraceEvent;
class GpuFrequencyFtraceEvent;
class GpuSchedCompleteFtraceEvent;
class GpuSchedEnqueueFtraceEvent;
class GpuSchedSubmitFtraceEvent;
class I2cReadFtraceEvent;
class I2cReplyFtraceEvent;
class I2cResultFtraceEvent;
class I2cWriteFtraceEvent;
class IommuMapRangeFtraceEvent;
class IommuSecPtblMapRangeEndFtraceEvent;
class IommuSecPtblMapRangeStartFtraceEvent;
class IonAllocBufferEndFtraceEvent;
class IonAllocBufferFailFtraceEvent;
class IonAllocBufferFallbackFtraceEvent;
class IonAllocBufferStartFtraceEvent;
class IonCpAllocRetryFtraceEvent;
class IonCpSecureBufferEndFtraceEvent;
class IonCpSecureBufferStartFtraceEvent;
class IonHeapGrowFtraceEvent;
class IonHeapShrinkFtraceEvent;
class IonPrefetchingFtraceEvent;
class IonSecureCmaAddToPoolEndFtraceEvent;
class IonSecureCmaAddToPoolStartFtraceEvent;
class IonSecureCmaAllocateEndFtraceEvent;
class IonSecureCmaAllocateStartFtraceEvent;
class IonSecureCmaShrinkPoolEndFtraceEvent;
class IonSecureCmaShrinkPoolStartFtraceEvent;
class IpiEntryFtraceEvent;
class IpiExitFtraceEvent;
class IpiRaiseFtraceEvent;
class IrqHandlerEntryFtraceEvent;
class IrqHandlerExitFtraceEvent;
class KfreeFtraceEvent;
class KmallocFtraceEvent;
class KmallocNodeFtraceEvent;
class KmemCacheAllocFtraceEvent;
class KmemCacheAllocNodeFtraceEvent;
class KmemCacheFreeFtraceEvent;
class LowmemoryKillFtraceEvent;
class MdpCmdKickoffFtraceEvent;
class MdpCmdPingpongDoneFtraceEvent;
class MdpCmdReadptrDoneFtraceEvent;
class MdpCmdReleaseBwFtraceEvent;
class MdpCmdWaitPingpongFtraceEvent;
class MdpCommitFtraceEvent;
class MdpCompareBwFtraceEvent;
class MdpMisrCrcFtraceEvent;
class MdpMixerUpdateFtraceEvent;
class MdpPerfPrefillCalcFtraceEvent;
class MdpPerfSetOtFtraceEvent;
class MdpPerfSetPanicLutsFtraceEvent;
class MdpPerfSetQosLutsFtraceEvent;
class MdpPerfSetWmLevelsFtraceEvent;
class MdpPerfUpdateBusFtraceEvent;
class MdpSsppChangeFtraceEvent;
class MdpSsppSetFtraceEvent;
class MdpTraceCounterFtraceEvent;
class MdpVideoUnderrunDoneFtraceEvent;
class MigratePagesEndFtraceEvent;
class MigratePagesStartFtraceEvent;
class MigrateRetryFtraceEvent;
class MmCompactionBeginFtraceEvent;
class MmCompactionDeferCompactionFtraceEvent;
class MmCompactionDeferResetFtraceEvent;
class MmCompactionDeferredFtraceEvent;
class MmCompactionEndFtraceEvent;
class MmCompactionFinishedFtraceEvent;
class MmCompactionIsolateFreepagesFtraceEvent;
class MmCompactionIsolateMigratepagesFtraceEvent;
class MmCompactionKcompactdSleepFtraceEvent;
class MmCompactionKcompactdWakeFtraceEvent;
class MmCompactionMigratepagesFtraceEvent;
class MmCompactionSuitableFtraceEvent;
class MmCompactionTryToCompactPagesFtraceEvent;
class MmCompactionWakeupKcompactdFtraceEvent;
class MmEventRecordFtraceEvent;
class MmFilemapAddToPageCacheFtraceEvent;
class MmFilemapDeleteFromPageCacheFtraceEvent;
class MmPageAllocExtfragFtraceEvent;
class MmPageAllocFtraceEvent;
class MmPageAllocZoneLockedFtraceEvent;
class MmPageFreeBatchedFtraceEvent;
class MmPageFreeFtraceEvent;
class MmPagePcpuDrainFtraceEvent;
class MmVmscanDirectReclaimBeginFtraceEvent;
class MmVmscanDirectReclaimEndFtraceEvent;
class MmVmscanKswapdSleepFtraceEvent;
class MmVmscanKswapdWakeFtraceEvent;
class OomScoreAdjUpdateFtraceEvent;
class PrintFtraceEvent;
class RegulatorDisableCompleteFtraceEvent;
class RegulatorDisableFtraceEvent;
class RegulatorEnableCompleteFtraceEvent;
class RegulatorEnableDelayFtraceEvent;
class RegulatorEnableFtraceEvent;
class RegulatorSetVoltageCompleteFtraceEvent;
class RegulatorSetVoltageFtraceEvent;
class RotatorBwAoAsContextFtraceEvent;
class RssStatFtraceEvent;
class SchedBlockedReasonFtraceEvent;
class SchedCpuHotplugFtraceEvent;
class SchedProcessExecFtraceEvent;
class SchedProcessExitFtraceEvent;
class SchedProcessForkFtraceEvent;
class SchedProcessFreeFtraceEvent;
class SchedProcessHangFtraceEvent;
class SchedProcessWaitFtraceEvent;
class SchedSwitchFtraceEvent;
class SchedWakeupFtraceEvent;
class SchedWakeupNewFtraceEvent;
class SchedWakingFtraceEvent;
class SignalDeliverFtraceEvent;
class SignalGenerateFtraceEvent;
class SmbusReadFtraceEvent;
class SmbusReplyFtraceEvent;
class SmbusResultFtraceEvent;
class SmbusWriteFtraceEvent;
class SoftirqEntryFtraceEvent;
class SoftirqExitFtraceEvent;
class SoftirqRaiseFtraceEvent;
class SuspendResumeFtraceEvent;
class SyncPtFtraceEvent;
class SyncTimelineFtraceEvent;
class SyncWaitFtraceEvent;
class SysEnterFtraceEvent;
class SysExitFtraceEvent;
class TaskNewtaskFtraceEvent;
class TaskRenameFtraceEvent;
class TracingMarkWriteFtraceEvent;
class WorkqueueActivateWorkFtraceEvent;
class WorkqueueExecuteEndFtraceEvent;
class WorkqueueExecuteStartFtraceEvent;
class WorkqueueQueueWorkFtraceEvent;
class ZeroFtraceEvent;

class FtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/335, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  FtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit FtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit FtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_timestamp() const { return at<1>().valid(); }
  uint64_t timestamp() const { return at<1>().as_uint64(); }
  bool has_pid() const { return at<2>().valid(); }
  uint32_t pid() const { return at<2>().as_uint32(); }
  bool has_print() const { return at<3>().valid(); }
  ::protozero::ConstBytes print() const { return at<3>().as_bytes(); }
  bool has_sched_switch() const { return at<4>().valid(); }
  ::protozero::ConstBytes sched_switch() const { return at<4>().as_bytes(); }
  bool has_cpu_frequency() const { return at<11>().valid(); }
  ::protozero::ConstBytes cpu_frequency() const { return at<11>().as_bytes(); }
  bool has_cpu_frequency_limits() const { return at<12>().valid(); }
  ::protozero::ConstBytes cpu_frequency_limits() const { return at<12>().as_bytes(); }
  bool has_cpu_idle() const { return at<13>().valid(); }
  ::protozero::ConstBytes cpu_idle() const { return at<13>().as_bytes(); }
  bool has_clock_enable() const { return at<14>().valid(); }
  ::protozero::ConstBytes clock_enable() const { return at<14>().as_bytes(); }
  bool has_clock_disable() const { return at<15>().valid(); }
  ::protozero::ConstBytes clock_disable() const { return at<15>().as_bytes(); }
  bool has_clock_set_rate() const { return at<16>().valid(); }
  ::protozero::ConstBytes clock_set_rate() const { return at<16>().as_bytes(); }
  bool has_sched_wakeup() const { return at<17>().valid(); }
  ::protozero::ConstBytes sched_wakeup() const { return at<17>().as_bytes(); }
  bool has_sched_blocked_reason() const { return at<18>().valid(); }
  ::protozero::ConstBytes sched_blocked_reason() const { return at<18>().as_bytes(); }
  bool has_sched_cpu_hotplug() const { return at<19>().valid(); }
  ::protozero::ConstBytes sched_cpu_hotplug() const { return at<19>().as_bytes(); }
  bool has_sched_waking() const { return at<20>().valid(); }
  ::protozero::ConstBytes sched_waking() const { return at<20>().as_bytes(); }
  bool has_ipi_entry() const { return at<21>().valid(); }
  ::protozero::ConstBytes ipi_entry() const { return at<21>().as_bytes(); }
  bool has_ipi_exit() const { return at<22>().valid(); }
  ::protozero::ConstBytes ipi_exit() const { return at<22>().as_bytes(); }
  bool has_ipi_raise() const { return at<23>().valid(); }
  ::protozero::ConstBytes ipi_raise() const { return at<23>().as_bytes(); }
  bool has_softirq_entry() const { return at<24>().valid(); }
  ::protozero::ConstBytes softirq_entry() const { return at<24>().as_bytes(); }
  bool has_softirq_exit() const { return at<25>().valid(); }
  ::protozero::ConstBytes softirq_exit() const { return at<25>().as_bytes(); }
  bool has_softirq_raise() const { return at<26>().valid(); }
  ::protozero::ConstBytes softirq_raise() const { return at<26>().as_bytes(); }
  bool has_i2c_read() const { return at<27>().valid(); }
  ::protozero::ConstBytes i2c_read() const { return at<27>().as_bytes(); }
  bool has_i2c_write() const { return at<28>().valid(); }
  ::protozero::ConstBytes i2c_write() const { return at<28>().as_bytes(); }
  bool has_i2c_result() const { return at<29>().valid(); }
  ::protozero::ConstBytes i2c_result() const { return at<29>().as_bytes(); }
  bool has_i2c_reply() const { return at<30>().valid(); }
  ::protozero::ConstBytes i2c_reply() const { return at<30>().as_bytes(); }
  bool has_smbus_read() const { return at<31>().valid(); }
  ::protozero::ConstBytes smbus_read() const { return at<31>().as_bytes(); }
  bool has_smbus_write() const { return at<32>().valid(); }
  ::protozero::ConstBytes smbus_write() const { return at<32>().as_bytes(); }
  bool has_smbus_result() const { return at<33>().valid(); }
  ::protozero::ConstBytes smbus_result() const { return at<33>().as_bytes(); }
  bool has_smbus_reply() const { return at<34>().valid(); }
  ::protozero::ConstBytes smbus_reply() const { return at<34>().as_bytes(); }
  bool has_lowmemory_kill() const { return at<35>().valid(); }
  ::protozero::ConstBytes lowmemory_kill() const { return at<35>().as_bytes(); }
  bool has_irq_handler_entry() const { return at<36>().valid(); }
  ::protozero::ConstBytes irq_handler_entry() const { return at<36>().as_bytes(); }
  bool has_irq_handler_exit() const { return at<37>().valid(); }
  ::protozero::ConstBytes irq_handler_exit() const { return at<37>().as_bytes(); }
  bool has_sync_pt() const { return at<38>().valid(); }
  ::protozero::ConstBytes sync_pt() const { return at<38>().as_bytes(); }
  bool has_sync_timeline() const { return at<39>().valid(); }
  ::protozero::ConstBytes sync_timeline() const { return at<39>().as_bytes(); }
  bool has_sync_wait() const { return at<40>().valid(); }
  ::protozero::ConstBytes sync_wait() const { return at<40>().as_bytes(); }
  bool has_ext4_da_write_begin() const { return at<41>().valid(); }
  ::protozero::ConstBytes ext4_da_write_begin() const { return at<41>().as_bytes(); }
  bool has_ext4_da_write_end() const { return at<42>().valid(); }
  ::protozero::ConstBytes ext4_da_write_end() const { return at<42>().as_bytes(); }
  bool has_ext4_sync_file_enter() const { return at<43>().valid(); }
  ::protozero::ConstBytes ext4_sync_file_enter() const { return at<43>().as_bytes(); }
  bool has_ext4_sync_file_exit() const { return at<44>().valid(); }
  ::protozero::ConstBytes ext4_sync_file_exit() const { return at<44>().as_bytes(); }
  bool has_block_rq_issue() const { return at<45>().valid(); }
  ::protozero::ConstBytes block_rq_issue() const { return at<45>().as_bytes(); }
  bool has_mm_vmscan_direct_reclaim_begin() const { return at<46>().valid(); }
  ::protozero::ConstBytes mm_vmscan_direct_reclaim_begin() const { return at<46>().as_bytes(); }
  bool has_mm_vmscan_direct_reclaim_end() const { return at<47>().valid(); }
  ::protozero::ConstBytes mm_vmscan_direct_reclaim_end() const { return at<47>().as_bytes(); }
  bool has_mm_vmscan_kswapd_wake() const { return at<48>().valid(); }
  ::protozero::ConstBytes mm_vmscan_kswapd_wake() const { return at<48>().as_bytes(); }
  bool has_mm_vmscan_kswapd_sleep() const { return at<49>().valid(); }
  ::protozero::ConstBytes mm_vmscan_kswapd_sleep() const { return at<49>().as_bytes(); }
  bool has_binder_transaction() const { return at<50>().valid(); }
  ::protozero::ConstBytes binder_transaction() const { return at<50>().as_bytes(); }
  bool has_binder_transaction_received() const { return at<51>().valid(); }
  ::protozero::ConstBytes binder_transaction_received() const { return at<51>().as_bytes(); }
  bool has_binder_set_priority() const { return at<52>().valid(); }
  ::protozero::ConstBytes binder_set_priority() const { return at<52>().as_bytes(); }
  bool has_binder_lock() const { return at<53>().valid(); }
  ::protozero::ConstBytes binder_lock() const { return at<53>().as_bytes(); }
  bool has_binder_locked() const { return at<54>().valid(); }
  ::protozero::ConstBytes binder_locked() const { return at<54>().as_bytes(); }
  bool has_binder_unlock() const { return at<55>().valid(); }
  ::protozero::ConstBytes binder_unlock() const { return at<55>().as_bytes(); }
  bool has_workqueue_activate_work() const { return at<56>().valid(); }
  ::protozero::ConstBytes workqueue_activate_work() const { return at<56>().as_bytes(); }
  bool has_workqueue_execute_end() const { return at<57>().valid(); }
  ::protozero::ConstBytes workqueue_execute_end() const { return at<57>().as_bytes(); }
  bool has_workqueue_execute_start() const { return at<58>().valid(); }
  ::protozero::ConstBytes workqueue_execute_start() const { return at<58>().as_bytes(); }
  bool has_workqueue_queue_work() const { return at<59>().valid(); }
  ::protozero::ConstBytes workqueue_queue_work() const { return at<59>().as_bytes(); }
  bool has_regulator_disable() const { return at<60>().valid(); }
  ::protozero::ConstBytes regulator_disable() const { return at<60>().as_bytes(); }
  bool has_regulator_disable_complete() const { return at<61>().valid(); }
  ::protozero::ConstBytes regulator_disable_complete() const { return at<61>().as_bytes(); }
  bool has_regulator_enable() const { return at<62>().valid(); }
  ::protozero::ConstBytes regulator_enable() const { return at<62>().as_bytes(); }
  bool has_regulator_enable_complete() const { return at<63>().valid(); }
  ::protozero::ConstBytes regulator_enable_complete() const { return at<63>().as_bytes(); }
  bool has_regulator_enable_delay() const { return at<64>().valid(); }
  ::protozero::ConstBytes regulator_enable_delay() const { return at<64>().as_bytes(); }
  bool has_regulator_set_voltage() const { return at<65>().valid(); }
  ::protozero::ConstBytes regulator_set_voltage() const { return at<65>().as_bytes(); }
  bool has_regulator_set_voltage_complete() const { return at<66>().valid(); }
  ::protozero::ConstBytes regulator_set_voltage_complete() const { return at<66>().as_bytes(); }
  bool has_cgroup_attach_task() const { return at<67>().valid(); }
  ::protozero::ConstBytes cgroup_attach_task() const { return at<67>().as_bytes(); }
  bool has_cgroup_mkdir() const { return at<68>().valid(); }
  ::protozero::ConstBytes cgroup_mkdir() const { return at<68>().as_bytes(); }
  bool has_cgroup_remount() const { return at<69>().valid(); }
  ::protozero::ConstBytes cgroup_remount() const { return at<69>().as_bytes(); }
  bool has_cgroup_rmdir() const { return at<70>().valid(); }
  ::protozero::ConstBytes cgroup_rmdir() const { return at<70>().as_bytes(); }
  bool has_cgroup_transfer_tasks() const { return at<71>().valid(); }
  ::protozero::ConstBytes cgroup_transfer_tasks() const { return at<71>().as_bytes(); }
  bool has_cgroup_destroy_root() const { return at<72>().valid(); }
  ::protozero::ConstBytes cgroup_destroy_root() const { return at<72>().as_bytes(); }
  bool has_cgroup_release() const { return at<73>().valid(); }
  ::protozero::ConstBytes cgroup_release() const { return at<73>().as_bytes(); }
  bool has_cgroup_rename() const { return at<74>().valid(); }
  ::protozero::ConstBytes cgroup_rename() const { return at<74>().as_bytes(); }
  bool has_cgroup_setup_root() const { return at<75>().valid(); }
  ::protozero::ConstBytes cgroup_setup_root() const { return at<75>().as_bytes(); }
  bool has_mdp_cmd_kickoff() const { return at<76>().valid(); }
  ::protozero::ConstBytes mdp_cmd_kickoff() const { return at<76>().as_bytes(); }
  bool has_mdp_commit() const { return at<77>().valid(); }
  ::protozero::ConstBytes mdp_commit() const { return at<77>().as_bytes(); }
  bool has_mdp_perf_set_ot() const { return at<78>().valid(); }
  ::protozero::ConstBytes mdp_perf_set_ot() const { return at<78>().as_bytes(); }
  bool has_mdp_sspp_change() const { return at<79>().valid(); }
  ::protozero::ConstBytes mdp_sspp_change() const { return at<79>().as_bytes(); }
  bool has_tracing_mark_write() const { return at<80>().valid(); }
  ::protozero::ConstBytes tracing_mark_write() const { return at<80>().as_bytes(); }
  bool has_mdp_cmd_pingpong_done() const { return at<81>().valid(); }
  ::protozero::ConstBytes mdp_cmd_pingpong_done() const { return at<81>().as_bytes(); }
  bool has_mdp_compare_bw() const { return at<82>().valid(); }
  ::protozero::ConstBytes mdp_compare_bw() const { return at<82>().as_bytes(); }
  bool has_mdp_perf_set_panic_luts() const { return at<83>().valid(); }
  ::protozero::ConstBytes mdp_perf_set_panic_luts() const { return at<83>().as_bytes(); }
  bool has_mdp_sspp_set() const { return at<84>().valid(); }
  ::protozero::ConstBytes mdp_sspp_set() const { return at<84>().as_bytes(); }
  bool has_mdp_cmd_readptr_done() const { return at<85>().valid(); }
  ::protozero::ConstBytes mdp_cmd_readptr_done() const { return at<85>().as_bytes(); }
  bool has_mdp_misr_crc() const { return at<86>().valid(); }
  ::protozero::ConstBytes mdp_misr_crc() const { return at<86>().as_bytes(); }
  bool has_mdp_perf_set_qos_luts() const { return at<87>().valid(); }
  ::protozero::ConstBytes mdp_perf_set_qos_luts() const { return at<87>().as_bytes(); }
  bool has_mdp_trace_counter() const { return at<88>().valid(); }
  ::protozero::ConstBytes mdp_trace_counter() const { return at<88>().as_bytes(); }
  bool has_mdp_cmd_release_bw() const { return at<89>().valid(); }
  ::protozero::ConstBytes mdp_cmd_release_bw() const { return at<89>().as_bytes(); }
  bool has_mdp_mixer_update() const { return at<90>().valid(); }
  ::protozero::ConstBytes mdp_mixer_update() const { return at<90>().as_bytes(); }
  bool has_mdp_perf_set_wm_levels() const { return at<91>().valid(); }
  ::protozero::ConstBytes mdp_perf_set_wm_levels() const { return at<91>().as_bytes(); }
  bool has_mdp_video_underrun_done() const { return at<92>().valid(); }
  ::protozero::ConstBytes mdp_video_underrun_done() const { return at<92>().as_bytes(); }
  bool has_mdp_cmd_wait_pingpong() const { return at<93>().valid(); }
  ::protozero::ConstBytes mdp_cmd_wait_pingpong() const { return at<93>().as_bytes(); }
  bool has_mdp_perf_prefill_calc() const { return at<94>().valid(); }
  ::protozero::ConstBytes mdp_perf_prefill_calc() const { return at<94>().as_bytes(); }
  bool has_mdp_perf_update_bus() const { return at<95>().valid(); }
  ::protozero::ConstBytes mdp_perf_update_bus() const { return at<95>().as_bytes(); }
  bool has_rotator_bw_ao_as_context() const { return at<96>().valid(); }
  ::protozero::ConstBytes rotator_bw_ao_as_context() const { return at<96>().as_bytes(); }
  bool has_mm_filemap_add_to_page_cache() const { return at<97>().valid(); }
  ::protozero::ConstBytes mm_filemap_add_to_page_cache() const { return at<97>().as_bytes(); }
  bool has_mm_filemap_delete_from_page_cache() const { return at<98>().valid(); }
  ::protozero::ConstBytes mm_filemap_delete_from_page_cache() const { return at<98>().as_bytes(); }
  bool has_mm_compaction_begin() const { return at<99>().valid(); }
  ::protozero::ConstBytes mm_compaction_begin() const { return at<99>().as_bytes(); }
  bool has_mm_compaction_defer_compaction() const { return at<100>().valid(); }
  ::protozero::ConstBytes mm_compaction_defer_compaction() const { return at<100>().as_bytes(); }
  bool has_mm_compaction_deferred() const { return at<101>().valid(); }
  ::protozero::ConstBytes mm_compaction_deferred() const { return at<101>().as_bytes(); }
  bool has_mm_compaction_defer_reset() const { return at<102>().valid(); }
  ::protozero::ConstBytes mm_compaction_defer_reset() const { return at<102>().as_bytes(); }
  bool has_mm_compaction_end() const { return at<103>().valid(); }
  ::protozero::ConstBytes mm_compaction_end() const { return at<103>().as_bytes(); }
  bool has_mm_compaction_finished() const { return at<104>().valid(); }
  ::protozero::ConstBytes mm_compaction_finished() const { return at<104>().as_bytes(); }
  bool has_mm_compaction_isolate_freepages() const { return at<105>().valid(); }
  ::protozero::ConstBytes mm_compaction_isolate_freepages() const { return at<105>().as_bytes(); }
  bool has_mm_compaction_isolate_migratepages() const { return at<106>().valid(); }
  ::protozero::ConstBytes mm_compaction_isolate_migratepages() const { return at<106>().as_bytes(); }
  bool has_mm_compaction_kcompactd_sleep() const { return at<107>().valid(); }
  ::protozero::ConstBytes mm_compaction_kcompactd_sleep() const { return at<107>().as_bytes(); }
  bool has_mm_compaction_kcompactd_wake() const { return at<108>().valid(); }
  ::protozero::ConstBytes mm_compaction_kcompactd_wake() const { return at<108>().as_bytes(); }
  bool has_mm_compaction_migratepages() const { return at<109>().valid(); }
  ::protozero::ConstBytes mm_compaction_migratepages() const { return at<109>().as_bytes(); }
  bool has_mm_compaction_suitable() const { return at<110>().valid(); }
  ::protozero::ConstBytes mm_compaction_suitable() const { return at<110>().as_bytes(); }
  bool has_mm_compaction_try_to_compact_pages() const { return at<111>().valid(); }
  ::protozero::ConstBytes mm_compaction_try_to_compact_pages() const { return at<111>().as_bytes(); }
  bool has_mm_compaction_wakeup_kcompactd() const { return at<112>().valid(); }
  ::protozero::ConstBytes mm_compaction_wakeup_kcompactd() const { return at<112>().as_bytes(); }
  bool has_suspend_resume() const { return at<113>().valid(); }
  ::protozero::ConstBytes suspend_resume() const { return at<113>().as_bytes(); }
  bool has_sched_wakeup_new() const { return at<114>().valid(); }
  ::protozero::ConstBytes sched_wakeup_new() const { return at<114>().as_bytes(); }
  bool has_block_bio_backmerge() const { return at<115>().valid(); }
  ::protozero::ConstBytes block_bio_backmerge() const { return at<115>().as_bytes(); }
  bool has_block_bio_bounce() const { return at<116>().valid(); }
  ::protozero::ConstBytes block_bio_bounce() const { return at<116>().as_bytes(); }
  bool has_block_bio_complete() const { return at<117>().valid(); }
  ::protozero::ConstBytes block_bio_complete() const { return at<117>().as_bytes(); }
  bool has_block_bio_frontmerge() const { return at<118>().valid(); }
  ::protozero::ConstBytes block_bio_frontmerge() const { return at<118>().as_bytes(); }
  bool has_block_bio_queue() const { return at<119>().valid(); }
  ::protozero::ConstBytes block_bio_queue() const { return at<119>().as_bytes(); }
  bool has_block_bio_remap() const { return at<120>().valid(); }
  ::protozero::ConstBytes block_bio_remap() const { return at<120>().as_bytes(); }
  bool has_block_dirty_buffer() const { return at<121>().valid(); }
  ::protozero::ConstBytes block_dirty_buffer() const { return at<121>().as_bytes(); }
  bool has_block_getrq() const { return at<122>().valid(); }
  ::protozero::ConstBytes block_getrq() const { return at<122>().as_bytes(); }
  bool has_block_plug() const { return at<123>().valid(); }
  ::protozero::ConstBytes block_plug() const { return at<123>().as_bytes(); }
  bool has_block_rq_abort() const { return at<124>().valid(); }
  ::protozero::ConstBytes block_rq_abort() const { return at<124>().as_bytes(); }
  bool has_block_rq_complete() const { return at<125>().valid(); }
  ::protozero::ConstBytes block_rq_complete() const { return at<125>().as_bytes(); }
  bool has_block_rq_insert() const { return at<126>().valid(); }
  ::protozero::ConstBytes block_rq_insert() const { return at<126>().as_bytes(); }
  bool has_block_rq_remap() const { return at<128>().valid(); }
  ::protozero::ConstBytes block_rq_remap() const { return at<128>().as_bytes(); }
  bool has_block_rq_requeue() const { return at<129>().valid(); }
  ::protozero::ConstBytes block_rq_requeue() const { return at<129>().as_bytes(); }
  bool has_block_sleeprq() const { return at<130>().valid(); }
  ::protozero::ConstBytes block_sleeprq() const { return at<130>().as_bytes(); }
  bool has_block_split() const { return at<131>().valid(); }
  ::protozero::ConstBytes block_split() const { return at<131>().as_bytes(); }
  bool has_block_touch_buffer() const { return at<132>().valid(); }
  ::protozero::ConstBytes block_touch_buffer() const { return at<132>().as_bytes(); }
  bool has_block_unplug() const { return at<133>().valid(); }
  ::protozero::ConstBytes block_unplug() const { return at<133>().as_bytes(); }
  bool has_ext4_alloc_da_blocks() const { return at<134>().valid(); }
  ::protozero::ConstBytes ext4_alloc_da_blocks() const { return at<134>().as_bytes(); }
  bool has_ext4_allocate_blocks() const { return at<135>().valid(); }
  ::protozero::ConstBytes ext4_allocate_blocks() const { return at<135>().as_bytes(); }
  bool has_ext4_allocate_inode() const { return at<136>().valid(); }
  ::protozero::ConstBytes ext4_allocate_inode() const { return at<136>().as_bytes(); }
  bool has_ext4_begin_ordered_truncate() const { return at<137>().valid(); }
  ::protozero::ConstBytes ext4_begin_ordered_truncate() const { return at<137>().as_bytes(); }
  bool has_ext4_collapse_range() const { return at<138>().valid(); }
  ::protozero::ConstBytes ext4_collapse_range() const { return at<138>().as_bytes(); }
  bool has_ext4_da_release_space() const { return at<139>().valid(); }
  ::protozero::ConstBytes ext4_da_release_space() const { return at<139>().as_bytes(); }
  bool has_ext4_da_reserve_space() const { return at<140>().valid(); }
  ::protozero::ConstBytes ext4_da_reserve_space() const { return at<140>().as_bytes(); }
  bool has_ext4_da_update_reserve_space() const { return at<141>().valid(); }
  ::protozero::ConstBytes ext4_da_update_reserve_space() const { return at<141>().as_bytes(); }
  bool has_ext4_da_write_pages() const { return at<142>().valid(); }
  ::protozero::ConstBytes ext4_da_write_pages() const { return at<142>().as_bytes(); }
  bool has_ext4_da_write_pages_extent() const { return at<143>().valid(); }
  ::protozero::ConstBytes ext4_da_write_pages_extent() const { return at<143>().as_bytes(); }
  bool has_ext4_direct_IO_enter() const { return at<144>().valid(); }
  ::protozero::ConstBytes ext4_direct_IO_enter() const { return at<144>().as_bytes(); }
  bool has_ext4_direct_IO_exit() const { return at<145>().valid(); }
  ::protozero::ConstBytes ext4_direct_IO_exit() const { return at<145>().as_bytes(); }
  bool has_ext4_discard_blocks() const { return at<146>().valid(); }
  ::protozero::ConstBytes ext4_discard_blocks() const { return at<146>().as_bytes(); }
  bool has_ext4_discard_preallocations() const { return at<147>().valid(); }
  ::protozero::ConstBytes ext4_discard_preallocations() const { return at<147>().as_bytes(); }
  bool has_ext4_drop_inode() const { return at<148>().valid(); }
  ::protozero::ConstBytes ext4_drop_inode() const { return at<148>().as_bytes(); }
  bool has_ext4_es_cache_extent() const { return at<149>().valid(); }
  ::protozero::ConstBytes ext4_es_cache_extent() const { return at<149>().as_bytes(); }
  bool has_ext4_es_find_delayed_extent_range_enter() const { return at<150>().valid(); }
  ::protozero::ConstBytes ext4_es_find_delayed_extent_range_enter() const { return at<150>().as_bytes(); }
  bool has_ext4_es_find_delayed_extent_range_exit() const { return at<151>().valid(); }
  ::protozero::ConstBytes ext4_es_find_delayed_extent_range_exit() const { return at<151>().as_bytes(); }
  bool has_ext4_es_insert_extent() const { return at<152>().valid(); }
  ::protozero::ConstBytes ext4_es_insert_extent() const { return at<152>().as_bytes(); }
  bool has_ext4_es_lookup_extent_enter() const { return at<153>().valid(); }
  ::protozero::ConstBytes ext4_es_lookup_extent_enter() const { return at<153>().as_bytes(); }
  bool has_ext4_es_lookup_extent_exit() const { return at<154>().valid(); }
  ::protozero::ConstBytes ext4_es_lookup_extent_exit() const { return at<154>().as_bytes(); }
  bool has_ext4_es_remove_extent() const { return at<155>().valid(); }
  ::protozero::ConstBytes ext4_es_remove_extent() const { return at<155>().as_bytes(); }
  bool has_ext4_es_shrink() const { return at<156>().valid(); }
  ::protozero::ConstBytes ext4_es_shrink() const { return at<156>().as_bytes(); }
  bool has_ext4_es_shrink_count() const { return at<157>().valid(); }
  ::protozero::ConstBytes ext4_es_shrink_count() const { return at<157>().as_bytes(); }
  bool has_ext4_es_shrink_scan_enter() const { return at<158>().valid(); }
  ::protozero::ConstBytes ext4_es_shrink_scan_enter() const { return at<158>().as_bytes(); }
  bool has_ext4_es_shrink_scan_exit() const { return at<159>().valid(); }
  ::protozero::ConstBytes ext4_es_shrink_scan_exit() const { return at<159>().as_bytes(); }
  bool has_ext4_evict_inode() const { return at<160>().valid(); }
  ::protozero::ConstBytes ext4_evict_inode() const { return at<160>().as_bytes(); }
  bool has_ext4_ext_convert_to_initialized_enter() const { return at<161>().valid(); }
  ::protozero::ConstBytes ext4_ext_convert_to_initialized_enter() const { return at<161>().as_bytes(); }
  bool has_ext4_ext_convert_to_initialized_fastpath() const { return at<162>().valid(); }
  ::protozero::ConstBytes ext4_ext_convert_to_initialized_fastpath() const { return at<162>().as_bytes(); }
  bool has_ext4_ext_handle_unwritten_extents() const { return at<163>().valid(); }
  ::protozero::ConstBytes ext4_ext_handle_unwritten_extents() const { return at<163>().as_bytes(); }
  bool has_ext4_ext_in_cache() const { return at<164>().valid(); }
  ::protozero::ConstBytes ext4_ext_in_cache() const { return at<164>().as_bytes(); }
  bool has_ext4_ext_load_extent() const { return at<165>().valid(); }
  ::protozero::ConstBytes ext4_ext_load_extent() const { return at<165>().as_bytes(); }
  bool has_ext4_ext_map_blocks_enter() const { return at<166>().valid(); }
  ::protozero::ConstBytes ext4_ext_map_blocks_enter() const { return at<166>().as_bytes(); }
  bool has_ext4_ext_map_blocks_exit() const { return at<167>().valid(); }
  ::protozero::ConstBytes ext4_ext_map_blocks_exit() const { return at<167>().as_bytes(); }
  bool has_ext4_ext_put_in_cache() const { return at<168>().valid(); }
  ::protozero::ConstBytes ext4_ext_put_in_cache() const { return at<168>().as_bytes(); }
  bool has_ext4_ext_remove_space() const { return at<169>().valid(); }
  ::protozero::ConstBytes ext4_ext_remove_space() const { return at<169>().as_bytes(); }
  bool has_ext4_ext_remove_space_done() const { return at<170>().valid(); }
  ::protozero::ConstBytes ext4_ext_remove_space_done() const { return at<170>().as_bytes(); }
  bool has_ext4_ext_rm_idx() const { return at<171>().valid(); }
  ::protozero::ConstBytes ext4_ext_rm_idx() const { return at<171>().as_bytes(); }
  bool has_ext4_ext_rm_leaf() const { return at<172>().valid(); }
  ::protozero::ConstBytes ext4_ext_rm_leaf() const { return at<172>().as_bytes(); }
  bool has_ext4_ext_show_extent() const { return at<173>().valid(); }
  ::protozero::ConstBytes ext4_ext_show_extent() const { return at<173>().as_bytes(); }
  bool has_ext4_fallocate_enter() const { return at<174>().valid(); }
  ::protozero::ConstBytes ext4_fallocate_enter() const { return at<174>().as_bytes(); }
  bool has_ext4_fallocate_exit() const { return at<175>().valid(); }
  ::protozero::ConstBytes ext4_fallocate_exit() const { return at<175>().as_bytes(); }
  bool has_ext4_find_delalloc_range() const { return at<176>().valid(); }
  ::protozero::ConstBytes ext4_find_delalloc_range() const { return at<176>().as_bytes(); }
  bool has_ext4_forget() const { return at<177>().valid(); }
  ::protozero::ConstBytes ext4_forget() const { return at<177>().as_bytes(); }
  bool has_ext4_free_blocks() const { return at<178>().valid(); }
  ::protozero::ConstBytes ext4_free_blocks() const { return at<178>().as_bytes(); }
  bool has_ext4_free_inode() const { return at<179>().valid(); }
  ::protozero::ConstBytes ext4_free_inode() const { return at<179>().as_bytes(); }
  bool has_ext4_get_implied_cluster_alloc_exit() const { return at<180>().valid(); }
  ::protozero::ConstBytes ext4_get_implied_cluster_alloc_exit() const { return at<180>().as_bytes(); }
  bool has_ext4_get_reserved_cluster_alloc() const { return at<181>().valid(); }
  ::protozero::ConstBytes ext4_get_reserved_cluster_alloc() const { return at<181>().as_bytes(); }
  bool has_ext4_ind_map_blocks_enter() const { return at<182>().valid(); }
  ::protozero::ConstBytes ext4_ind_map_blocks_enter() const { return at<182>().as_bytes(); }
  bool has_ext4_ind_map_blocks_exit() const { return at<183>().valid(); }
  ::protozero::ConstBytes ext4_ind_map_blocks_exit() const { return at<183>().as_bytes(); }
  bool has_ext4_insert_range() const { return at<184>().valid(); }
  ::protozero::ConstBytes ext4_insert_range() const { return at<184>().as_bytes(); }
  bool has_ext4_invalidatepage() const { return at<185>().valid(); }
  ::protozero::ConstBytes ext4_invalidatepage() const { return at<185>().as_bytes(); }
  bool has_ext4_journal_start() const { return at<186>().valid(); }
  ::protozero::ConstBytes ext4_journal_start() const { return at<186>().as_bytes(); }
  bool has_ext4_journal_start_reserved() const { return at<187>().valid(); }
  ::protozero::ConstBytes ext4_journal_start_reserved() const { return at<187>().as_bytes(); }
  bool has_ext4_journalled_invalidatepage() const { return at<188>().valid(); }
  ::protozero::ConstBytes ext4_journalled_invalidatepage() const { return at<188>().as_bytes(); }
  bool has_ext4_journalled_write_end() const { return at<189>().valid(); }
  ::protozero::ConstBytes ext4_journalled_write_end() const { return at<189>().as_bytes(); }
  bool has_ext4_load_inode() const { return at<190>().valid(); }
  ::protozero::ConstBytes ext4_load_inode() const { return at<190>().as_bytes(); }
  bool has_ext4_load_inode_bitmap() const { return at<191>().valid(); }
  ::protozero::ConstBytes ext4_load_inode_bitmap() const { return at<191>().as_bytes(); }
  bool has_ext4_mark_inode_dirty() const { return at<192>().valid(); }
  ::protozero::ConstBytes ext4_mark_inode_dirty() const { return at<192>().as_bytes(); }
  bool has_ext4_mb_bitmap_load() const { return at<193>().valid(); }
  ::protozero::ConstBytes ext4_mb_bitmap_load() const { return at<193>().as_bytes(); }
  bool has_ext4_mb_buddy_bitmap_load() const { return at<194>().valid(); }
  ::protozero::ConstBytes ext4_mb_buddy_bitmap_load() const { return at<194>().as_bytes(); }
  bool has_ext4_mb_discard_preallocations() const { return at<195>().valid(); }
  ::protozero::ConstBytes ext4_mb_discard_preallocations() const { return at<195>().as_bytes(); }
  bool has_ext4_mb_new_group_pa() const { return at<196>().valid(); }
  ::protozero::ConstBytes ext4_mb_new_group_pa() const { return at<196>().as_bytes(); }
  bool has_ext4_mb_new_inode_pa() const { return at<197>().valid(); }
  ::protozero::ConstBytes ext4_mb_new_inode_pa() const { return at<197>().as_bytes(); }
  bool has_ext4_mb_release_group_pa() const { return at<198>().valid(); }
  ::protozero::ConstBytes ext4_mb_release_group_pa() const { return at<198>().as_bytes(); }
  bool has_ext4_mb_release_inode_pa() const { return at<199>().valid(); }
  ::protozero::ConstBytes ext4_mb_release_inode_pa() const { return at<199>().as_bytes(); }
  bool has_ext4_mballoc_alloc() const { return at<200>().valid(); }
  ::protozero::ConstBytes ext4_mballoc_alloc() const { return at<200>().as_bytes(); }
  bool has_ext4_mballoc_discard() const { return at<201>().valid(); }
  ::protozero::ConstBytes ext4_mballoc_discard() const { return at<201>().as_bytes(); }
  bool has_ext4_mballoc_free() const { return at<202>().valid(); }
  ::protozero::ConstBytes ext4_mballoc_free() const { return at<202>().as_bytes(); }
  bool has_ext4_mballoc_prealloc() const { return at<203>().valid(); }
  ::protozero::ConstBytes ext4_mballoc_prealloc() const { return at<203>().as_bytes(); }
  bool has_ext4_other_inode_update_time() const { return at<204>().valid(); }
  ::protozero::ConstBytes ext4_other_inode_update_time() const { return at<204>().as_bytes(); }
  bool has_ext4_punch_hole() const { return at<205>().valid(); }
  ::protozero::ConstBytes ext4_punch_hole() const { return at<205>().as_bytes(); }
  bool has_ext4_read_block_bitmap_load() const { return at<206>().valid(); }
  ::protozero::ConstBytes ext4_read_block_bitmap_load() const { return at<206>().as_bytes(); }
  bool has_ext4_readpage() const { return at<207>().valid(); }
  ::protozero::ConstBytes ext4_readpage() const { return at<207>().as_bytes(); }
  bool has_ext4_releasepage() const { return at<208>().valid(); }
  ::protozero::ConstBytes ext4_releasepage() const { return at<208>().as_bytes(); }
  bool has_ext4_remove_blocks() const { return at<209>().valid(); }
  ::protozero::ConstBytes ext4_remove_blocks() const { return at<209>().as_bytes(); }
  bool has_ext4_request_blocks() const { return at<210>().valid(); }
  ::protozero::ConstBytes ext4_request_blocks() const { return at<210>().as_bytes(); }
  bool has_ext4_request_inode() const { return at<211>().valid(); }
  ::protozero::ConstBytes ext4_request_inode() const { return at<211>().as_bytes(); }
  bool has_ext4_sync_fs() const { return at<212>().valid(); }
  ::protozero::ConstBytes ext4_sync_fs() const { return at<212>().as_bytes(); }
  bool has_ext4_trim_all_free() const { return at<213>().valid(); }
  ::protozero::ConstBytes ext4_trim_all_free() const { return at<213>().as_bytes(); }
  bool has_ext4_trim_extent() const { return at<214>().valid(); }
  ::protozero::ConstBytes ext4_trim_extent() const { return at<214>().as_bytes(); }
  bool has_ext4_truncate_enter() const { return at<215>().valid(); }
  ::protozero::ConstBytes ext4_truncate_enter() const { return at<215>().as_bytes(); }
  bool has_ext4_truncate_exit() const { return at<216>().valid(); }
  ::protozero::ConstBytes ext4_truncate_exit() const { return at<216>().as_bytes(); }
  bool has_ext4_unlink_enter() const { return at<217>().valid(); }
  ::protozero::ConstBytes ext4_unlink_enter() const { return at<217>().as_bytes(); }
  bool has_ext4_unlink_exit() const { return at<218>().valid(); }
  ::protozero::ConstBytes ext4_unlink_exit() const { return at<218>().as_bytes(); }
  bool has_ext4_write_begin() const { return at<219>().valid(); }
  ::protozero::ConstBytes ext4_write_begin() const { return at<219>().as_bytes(); }
  bool has_ext4_write_end() const { return at<230>().valid(); }
  ::protozero::ConstBytes ext4_write_end() const { return at<230>().as_bytes(); }
  bool has_ext4_writepage() const { return at<231>().valid(); }
  ::protozero::ConstBytes ext4_writepage() const { return at<231>().as_bytes(); }
  bool has_ext4_writepages() const { return at<232>().valid(); }
  ::protozero::ConstBytes ext4_writepages() const { return at<232>().as_bytes(); }
  bool has_ext4_writepages_result() const { return at<233>().valid(); }
  ::protozero::ConstBytes ext4_writepages_result() const { return at<233>().as_bytes(); }
  bool has_ext4_zero_range() const { return at<234>().valid(); }
  ::protozero::ConstBytes ext4_zero_range() const { return at<234>().as_bytes(); }
  bool has_task_newtask() const { return at<235>().valid(); }
  ::protozero::ConstBytes task_newtask() const { return at<235>().as_bytes(); }
  bool has_task_rename() const { return at<236>().valid(); }
  ::protozero::ConstBytes task_rename() const { return at<236>().as_bytes(); }
  bool has_sched_process_exec() const { return at<237>().valid(); }
  ::protozero::ConstBytes sched_process_exec() const { return at<237>().as_bytes(); }
  bool has_sched_process_exit() const { return at<238>().valid(); }
  ::protozero::ConstBytes sched_process_exit() const { return at<238>().as_bytes(); }
  bool has_sched_process_fork() const { return at<239>().valid(); }
  ::protozero::ConstBytes sched_process_fork() const { return at<239>().as_bytes(); }
  bool has_sched_process_free() const { return at<240>().valid(); }
  ::protozero::ConstBytes sched_process_free() const { return at<240>().as_bytes(); }
  bool has_sched_process_hang() const { return at<241>().valid(); }
  ::protozero::ConstBytes sched_process_hang() const { return at<241>().as_bytes(); }
  bool has_sched_process_wait() const { return at<242>().valid(); }
  ::protozero::ConstBytes sched_process_wait() const { return at<242>().as_bytes(); }
  bool has_f2fs_do_submit_bio() const { return at<243>().valid(); }
  ::protozero::ConstBytes f2fs_do_submit_bio() const { return at<243>().as_bytes(); }
  bool has_f2fs_evict_inode() const { return at<244>().valid(); }
  ::protozero::ConstBytes f2fs_evict_inode() const { return at<244>().as_bytes(); }
  bool has_f2fs_fallocate() const { return at<245>().valid(); }
  ::protozero::ConstBytes f2fs_fallocate() const { return at<245>().as_bytes(); }
  bool has_f2fs_get_data_block() const { return at<246>().valid(); }
  ::protozero::ConstBytes f2fs_get_data_block() const { return at<246>().as_bytes(); }
  bool has_f2fs_get_victim() const { return at<247>().valid(); }
  ::protozero::ConstBytes f2fs_get_victim() const { return at<247>().as_bytes(); }
  bool has_f2fs_iget() const { return at<248>().valid(); }
  ::protozero::ConstBytes f2fs_iget() const { return at<248>().as_bytes(); }
  bool has_f2fs_iget_exit() const { return at<249>().valid(); }
  ::protozero::ConstBytes f2fs_iget_exit() const { return at<249>().as_bytes(); }
  bool has_f2fs_new_inode() const { return at<250>().valid(); }
  ::protozero::ConstBytes f2fs_new_inode() const { return at<250>().as_bytes(); }
  bool has_f2fs_readpage() const { return at<251>().valid(); }
  ::protozero::ConstBytes f2fs_readpage() const { return at<251>().as_bytes(); }
  bool has_f2fs_reserve_new_block() const { return at<252>().valid(); }
  ::protozero::ConstBytes f2fs_reserve_new_block() const { return at<252>().as_bytes(); }
  bool has_f2fs_set_page_dirty() const { return at<253>().valid(); }
  ::protozero::ConstBytes f2fs_set_page_dirty() const { return at<253>().as_bytes(); }
  bool has_f2fs_submit_write_page() const { return at<254>().valid(); }
  ::protozero::ConstBytes f2fs_submit_write_page() const { return at<254>().as_bytes(); }
  bool has_f2fs_sync_file_enter() const { return at<255>().valid(); }
  ::protozero::ConstBytes f2fs_sync_file_enter() const { return at<255>().as_bytes(); }
  bool has_f2fs_sync_file_exit() const { return at<256>().valid(); }
  ::protozero::ConstBytes f2fs_sync_file_exit() const { return at<256>().as_bytes(); }
  bool has_f2fs_sync_fs() const { return at<257>().valid(); }
  ::protozero::ConstBytes f2fs_sync_fs() const { return at<257>().as_bytes(); }
  bool has_f2fs_truncate() const { return at<258>().valid(); }
  ::protozero::ConstBytes f2fs_truncate() const { return at<258>().as_bytes(); }
  bool has_f2fs_truncate_blocks_enter() const { return at<259>().valid(); }
  ::protozero::ConstBytes f2fs_truncate_blocks_enter() const { return at<259>().as_bytes(); }
  bool has_f2fs_truncate_blocks_exit() const { return at<260>().valid(); }
  ::protozero::ConstBytes f2fs_truncate_blocks_exit() const { return at<260>().as_bytes(); }
  bool has_f2fs_truncate_data_blocks_range() const { return at<261>().valid(); }
  ::protozero::ConstBytes f2fs_truncate_data_blocks_range() const { return at<261>().as_bytes(); }
  bool has_f2fs_truncate_inode_blocks_enter() const { return at<262>().valid(); }
  ::protozero::ConstBytes f2fs_truncate_inode_blocks_enter() const { return at<262>().as_bytes(); }
  bool has_f2fs_truncate_inode_blocks_exit() const { return at<263>().valid(); }
  ::protozero::ConstBytes f2fs_truncate_inode_blocks_exit() const { return at<263>().as_bytes(); }
  bool has_f2fs_truncate_node() const { return at<264>().valid(); }
  ::protozero::ConstBytes f2fs_truncate_node() const { return at<264>().as_bytes(); }
  bool has_f2fs_truncate_nodes_enter() const { return at<265>().valid(); }
  ::protozero::ConstBytes f2fs_truncate_nodes_enter() const { return at<265>().as_bytes(); }
  bool has_f2fs_truncate_nodes_exit() const { return at<266>().valid(); }
  ::protozero::ConstBytes f2fs_truncate_nodes_exit() const { return at<266>().as_bytes(); }
  bool has_f2fs_truncate_partial_nodes() const { return at<267>().valid(); }
  ::protozero::ConstBytes f2fs_truncate_partial_nodes() const { return at<267>().as_bytes(); }
  bool has_f2fs_unlink_enter() const { return at<268>().valid(); }
  ::protozero::ConstBytes f2fs_unlink_enter() const { return at<268>().as_bytes(); }
  bool has_f2fs_unlink_exit() const { return at<269>().valid(); }
  ::protozero::ConstBytes f2fs_unlink_exit() const { return at<269>().as_bytes(); }
  bool has_f2fs_vm_page_mkwrite() const { return at<270>().valid(); }
  ::protozero::ConstBytes f2fs_vm_page_mkwrite() const { return at<270>().as_bytes(); }
  bool has_f2fs_write_begin() const { return at<271>().valid(); }
  ::protozero::ConstBytes f2fs_write_begin() const { return at<271>().as_bytes(); }
  bool has_f2fs_write_checkpoint() const { return at<272>().valid(); }
  ::protozero::ConstBytes f2fs_write_checkpoint() const { return at<272>().as_bytes(); }
  bool has_f2fs_write_end() const { return at<273>().valid(); }
  ::protozero::ConstBytes f2fs_write_end() const { return at<273>().as_bytes(); }
  bool has_alloc_pages_iommu_end() const { return at<274>().valid(); }
  ::protozero::ConstBytes alloc_pages_iommu_end() const { return at<274>().as_bytes(); }
  bool has_alloc_pages_iommu_fail() const { return at<275>().valid(); }
  ::protozero::ConstBytes alloc_pages_iommu_fail() const { return at<275>().as_bytes(); }
  bool has_alloc_pages_iommu_start() const { return at<276>().valid(); }
  ::protozero::ConstBytes alloc_pages_iommu_start() const { return at<276>().as_bytes(); }
  bool has_alloc_pages_sys_end() const { return at<277>().valid(); }
  ::protozero::ConstBytes alloc_pages_sys_end() const { return at<277>().as_bytes(); }
  bool has_alloc_pages_sys_fail() const { return at<278>().valid(); }
  ::protozero::ConstBytes alloc_pages_sys_fail() const { return at<278>().as_bytes(); }
  bool has_alloc_pages_sys_start() const { return at<279>().valid(); }
  ::protozero::ConstBytes alloc_pages_sys_start() const { return at<279>().as_bytes(); }
  bool has_dma_alloc_contiguous_retry() const { return at<280>().valid(); }
  ::protozero::ConstBytes dma_alloc_contiguous_retry() const { return at<280>().as_bytes(); }
  bool has_iommu_map_range() const { return at<281>().valid(); }
  ::protozero::ConstBytes iommu_map_range() const { return at<281>().as_bytes(); }
  bool has_iommu_sec_ptbl_map_range_end() const { return at<282>().valid(); }
  ::protozero::ConstBytes iommu_sec_ptbl_map_range_end() const { return at<282>().as_bytes(); }
  bool has_iommu_sec_ptbl_map_range_start() const { return at<283>().valid(); }
  ::protozero::ConstBytes iommu_sec_ptbl_map_range_start() const { return at<283>().as_bytes(); }
  bool has_ion_alloc_buffer_end() const { return at<284>().valid(); }
  ::protozero::ConstBytes ion_alloc_buffer_end() const { return at<284>().as_bytes(); }
  bool has_ion_alloc_buffer_fail() const { return at<285>().valid(); }
  ::protozero::ConstBytes ion_alloc_buffer_fail() const { return at<285>().as_bytes(); }
  bool has_ion_alloc_buffer_fallback() const { return at<286>().valid(); }
  ::protozero::ConstBytes ion_alloc_buffer_fallback() const { return at<286>().as_bytes(); }
  bool has_ion_alloc_buffer_start() const { return at<287>().valid(); }
  ::protozero::ConstBytes ion_alloc_buffer_start() const { return at<287>().as_bytes(); }
  bool has_ion_cp_alloc_retry() const { return at<288>().valid(); }
  ::protozero::ConstBytes ion_cp_alloc_retry() const { return at<288>().as_bytes(); }
  bool has_ion_cp_secure_buffer_end() const { return at<289>().valid(); }
  ::protozero::ConstBytes ion_cp_secure_buffer_end() const { return at<289>().as_bytes(); }
  bool has_ion_cp_secure_buffer_start() const { return at<290>().valid(); }
  ::protozero::ConstBytes ion_cp_secure_buffer_start() const { return at<290>().as_bytes(); }
  bool has_ion_prefetching() const { return at<291>().valid(); }
  ::protozero::ConstBytes ion_prefetching() const { return at<291>().as_bytes(); }
  bool has_ion_secure_cma_add_to_pool_end() const { return at<292>().valid(); }
  ::protozero::ConstBytes ion_secure_cma_add_to_pool_end() const { return at<292>().as_bytes(); }
  bool has_ion_secure_cma_add_to_pool_start() const { return at<293>().valid(); }
  ::protozero::ConstBytes ion_secure_cma_add_to_pool_start() const { return at<293>().as_bytes(); }
  bool has_ion_secure_cma_allocate_end() const { return at<294>().valid(); }
  ::protozero::ConstBytes ion_secure_cma_allocate_end() const { return at<294>().as_bytes(); }
  bool has_ion_secure_cma_allocate_start() const { return at<295>().valid(); }
  ::protozero::ConstBytes ion_secure_cma_allocate_start() const { return at<295>().as_bytes(); }
  bool has_ion_secure_cma_shrink_pool_end() const { return at<296>().valid(); }
  ::protozero::ConstBytes ion_secure_cma_shrink_pool_end() const { return at<296>().as_bytes(); }
  bool has_ion_secure_cma_shrink_pool_start() const { return at<297>().valid(); }
  ::protozero::ConstBytes ion_secure_cma_shrink_pool_start() const { return at<297>().as_bytes(); }
  bool has_kfree() const { return at<298>().valid(); }
  ::protozero::ConstBytes kfree() const { return at<298>().as_bytes(); }
  bool has_kmalloc() const { return at<299>().valid(); }
  ::protozero::ConstBytes kmalloc() const { return at<299>().as_bytes(); }
  bool has_kmalloc_node() const { return at<300>().valid(); }
  ::protozero::ConstBytes kmalloc_node() const { return at<300>().as_bytes(); }
  bool has_kmem_cache_alloc() const { return at<301>().valid(); }
  ::protozero::ConstBytes kmem_cache_alloc() const { return at<301>().as_bytes(); }
  bool has_kmem_cache_alloc_node() const { return at<302>().valid(); }
  ::protozero::ConstBytes kmem_cache_alloc_node() const { return at<302>().as_bytes(); }
  bool has_kmem_cache_free() const { return at<303>().valid(); }
  ::protozero::ConstBytes kmem_cache_free() const { return at<303>().as_bytes(); }
  bool has_migrate_pages_end() const { return at<304>().valid(); }
  ::protozero::ConstBytes migrate_pages_end() const { return at<304>().as_bytes(); }
  bool has_migrate_pages_start() const { return at<305>().valid(); }
  ::protozero::ConstBytes migrate_pages_start() const { return at<305>().as_bytes(); }
  bool has_migrate_retry() const { return at<306>().valid(); }
  ::protozero::ConstBytes migrate_retry() const { return at<306>().as_bytes(); }
  bool has_mm_page_alloc() const { return at<307>().valid(); }
  ::protozero::ConstBytes mm_page_alloc() const { return at<307>().as_bytes(); }
  bool has_mm_page_alloc_extfrag() const { return at<308>().valid(); }
  ::protozero::ConstBytes mm_page_alloc_extfrag() const { return at<308>().as_bytes(); }
  bool has_mm_page_alloc_zone_locked() const { return at<309>().valid(); }
  ::protozero::ConstBytes mm_page_alloc_zone_locked() const { return at<309>().as_bytes(); }
  bool has_mm_page_free() const { return at<310>().valid(); }
  ::protozero::ConstBytes mm_page_free() const { return at<310>().as_bytes(); }
  bool has_mm_page_free_batched() const { return at<311>().valid(); }
  ::protozero::ConstBytes mm_page_free_batched() const { return at<311>().as_bytes(); }
  bool has_mm_page_pcpu_drain() const { return at<312>().valid(); }
  ::protozero::ConstBytes mm_page_pcpu_drain() const { return at<312>().as_bytes(); }
  bool has_rss_stat() const { return at<313>().valid(); }
  ::protozero::ConstBytes rss_stat() const { return at<313>().as_bytes(); }
  bool has_ion_heap_shrink() const { return at<314>().valid(); }
  ::protozero::ConstBytes ion_heap_shrink() const { return at<314>().as_bytes(); }
  bool has_ion_heap_grow() const { return at<315>().valid(); }
  ::protozero::ConstBytes ion_heap_grow() const { return at<315>().as_bytes(); }
  bool has_fence_init() const { return at<316>().valid(); }
  ::protozero::ConstBytes fence_init() const { return at<316>().as_bytes(); }
  bool has_fence_destroy() const { return at<317>().valid(); }
  ::protozero::ConstBytes fence_destroy() const { return at<317>().as_bytes(); }
  bool has_fence_enable_signal() const { return at<318>().valid(); }
  ::protozero::ConstBytes fence_enable_signal() const { return at<318>().as_bytes(); }
  bool has_fence_signaled() const { return at<319>().valid(); }
  ::protozero::ConstBytes fence_signaled() const { return at<319>().as_bytes(); }
  bool has_clk_enable() const { return at<320>().valid(); }
  ::protozero::ConstBytes clk_enable() const { return at<320>().as_bytes(); }
  bool has_clk_disable() const { return at<321>().valid(); }
  ::protozero::ConstBytes clk_disable() const { return at<321>().as_bytes(); }
  bool has_clk_set_rate() const { return at<322>().valid(); }
  ::protozero::ConstBytes clk_set_rate() const { return at<322>().as_bytes(); }
  bool has_binder_transaction_alloc_buf() const { return at<323>().valid(); }
  ::protozero::ConstBytes binder_transaction_alloc_buf() const { return at<323>().as_bytes(); }
  bool has_signal_deliver() const { return at<324>().valid(); }
  ::protozero::ConstBytes signal_deliver() const { return at<324>().as_bytes(); }
  bool has_signal_generate() const { return at<325>().valid(); }
  ::protozero::ConstBytes signal_generate() const { return at<325>().as_bytes(); }
  bool has_oom_score_adj_update() const { return at<326>().valid(); }
  ::protozero::ConstBytes oom_score_adj_update() const { return at<326>().as_bytes(); }
  bool has_generic() const { return at<327>().valid(); }
  ::protozero::ConstBytes generic() const { return at<327>().as_bytes(); }
  bool has_mm_event_record() const { return at<328>().valid(); }
  ::protozero::ConstBytes mm_event_record() const { return at<328>().as_bytes(); }
  bool has_sys_enter() const { return at<329>().valid(); }
  ::protozero::ConstBytes sys_enter() const { return at<329>().as_bytes(); }
  bool has_sys_exit() const { return at<330>().valid(); }
  ::protozero::ConstBytes sys_exit() const { return at<330>().as_bytes(); }
  bool has_zero() const { return at<331>().valid(); }
  ::protozero::ConstBytes zero() const { return at<331>().as_bytes(); }
  bool has_gpu_frequency() const { return at<332>().valid(); }
  ::protozero::ConstBytes gpu_frequency() const { return at<332>().as_bytes(); }
  bool has_gpu_sched_enqueue() const { return at<333>().valid(); }
  ::protozero::ConstBytes gpu_sched_enqueue() const { return at<333>().as_bytes(); }
  bool has_gpu_sched_submit() const { return at<334>().valid(); }
  ::protozero::ConstBytes gpu_sched_submit() const { return at<334>().as_bytes(); }
  bool has_gpu_sched_complete() const { return at<335>().valid(); }
  ::protozero::ConstBytes gpu_sched_complete() const { return at<335>().as_bytes(); }
};

class FtraceEvent : public ::protozero::Message {
 public:
  using Decoder = FtraceEvent_Decoder;
  enum : int32_t {
    kTimestampFieldNumber = 1,
    kPidFieldNumber = 2,
    kPrintFieldNumber = 3,
    kSchedSwitchFieldNumber = 4,
    kCpuFrequencyFieldNumber = 11,
    kCpuFrequencyLimitsFieldNumber = 12,
    kCpuIdleFieldNumber = 13,
    kClockEnableFieldNumber = 14,
    kClockDisableFieldNumber = 15,
    kClockSetRateFieldNumber = 16,
    kSchedWakeupFieldNumber = 17,
    kSchedBlockedReasonFieldNumber = 18,
    kSchedCpuHotplugFieldNumber = 19,
    kSchedWakingFieldNumber = 20,
    kIpiEntryFieldNumber = 21,
    kIpiExitFieldNumber = 22,
    kIpiRaiseFieldNumber = 23,
    kSoftirqEntryFieldNumber = 24,
    kSoftirqExitFieldNumber = 25,
    kSoftirqRaiseFieldNumber = 26,
    kI2cReadFieldNumber = 27,
    kI2cWriteFieldNumber = 28,
    kI2cResultFieldNumber = 29,
    kI2cReplyFieldNumber = 30,
    kSmbusReadFieldNumber = 31,
    kSmbusWriteFieldNumber = 32,
    kSmbusResultFieldNumber = 33,
    kSmbusReplyFieldNumber = 34,
    kLowmemoryKillFieldNumber = 35,
    kIrqHandlerEntryFieldNumber = 36,
    kIrqHandlerExitFieldNumber = 37,
    kSyncPtFieldNumber = 38,
    kSyncTimelineFieldNumber = 39,
    kSyncWaitFieldNumber = 40,
    kExt4DaWriteBeginFieldNumber = 41,
    kExt4DaWriteEndFieldNumber = 42,
    kExt4SyncFileEnterFieldNumber = 43,
    kExt4SyncFileExitFieldNumber = 44,
    kBlockRqIssueFieldNumber = 45,
    kMmVmscanDirectReclaimBeginFieldNumber = 46,
    kMmVmscanDirectReclaimEndFieldNumber = 47,
    kMmVmscanKswapdWakeFieldNumber = 48,
    kMmVmscanKswapdSleepFieldNumber = 49,
    kBinderTransactionFieldNumber = 50,
    kBinderTransactionReceivedFieldNumber = 51,
    kBinderSetPriorityFieldNumber = 52,
    kBinderLockFieldNumber = 53,
    kBinderLockedFieldNumber = 54,
    kBinderUnlockFieldNumber = 55,
    kWorkqueueActivateWorkFieldNumber = 56,
    kWorkqueueExecuteEndFieldNumber = 57,
    kWorkqueueExecuteStartFieldNumber = 58,
    kWorkqueueQueueWorkFieldNumber = 59,
    kRegulatorDisableFieldNumber = 60,
    kRegulatorDisableCompleteFieldNumber = 61,
    kRegulatorEnableFieldNumber = 62,
    kRegulatorEnableCompleteFieldNumber = 63,
    kRegulatorEnableDelayFieldNumber = 64,
    kRegulatorSetVoltageFieldNumber = 65,
    kRegulatorSetVoltageCompleteFieldNumber = 66,
    kCgroupAttachTaskFieldNumber = 67,
    kCgroupMkdirFieldNumber = 68,
    kCgroupRemountFieldNumber = 69,
    kCgroupRmdirFieldNumber = 70,
    kCgroupTransferTasksFieldNumber = 71,
    kCgroupDestroyRootFieldNumber = 72,
    kCgroupReleaseFieldNumber = 73,
    kCgroupRenameFieldNumber = 74,
    kCgroupSetupRootFieldNumber = 75,
    kMdpCmdKickoffFieldNumber = 76,
    kMdpCommitFieldNumber = 77,
    kMdpPerfSetOtFieldNumber = 78,
    kMdpSsppChangeFieldNumber = 79,
    kTracingMarkWriteFieldNumber = 80,
    kMdpCmdPingpongDoneFieldNumber = 81,
    kMdpCompareBwFieldNumber = 82,
    kMdpPerfSetPanicLutsFieldNumber = 83,
    kMdpSsppSetFieldNumber = 84,
    kMdpCmdReadptrDoneFieldNumber = 85,
    kMdpMisrCrcFieldNumber = 86,
    kMdpPerfSetQosLutsFieldNumber = 87,
    kMdpTraceCounterFieldNumber = 88,
    kMdpCmdReleaseBwFieldNumber = 89,
    kMdpMixerUpdateFieldNumber = 90,
    kMdpPerfSetWmLevelsFieldNumber = 91,
    kMdpVideoUnderrunDoneFieldNumber = 92,
    kMdpCmdWaitPingpongFieldNumber = 93,
    kMdpPerfPrefillCalcFieldNumber = 94,
    kMdpPerfUpdateBusFieldNumber = 95,
    kRotatorBwAoAsContextFieldNumber = 96,
    kMmFilemapAddToPageCacheFieldNumber = 97,
    kMmFilemapDeleteFromPageCacheFieldNumber = 98,
    kMmCompactionBeginFieldNumber = 99,
    kMmCompactionDeferCompactionFieldNumber = 100,
    kMmCompactionDeferredFieldNumber = 101,
    kMmCompactionDeferResetFieldNumber = 102,
    kMmCompactionEndFieldNumber = 103,
    kMmCompactionFinishedFieldNumber = 104,
    kMmCompactionIsolateFreepagesFieldNumber = 105,
    kMmCompactionIsolateMigratepagesFieldNumber = 106,
    kMmCompactionKcompactdSleepFieldNumber = 107,
    kMmCompactionKcompactdWakeFieldNumber = 108,
    kMmCompactionMigratepagesFieldNumber = 109,
    kMmCompactionSuitableFieldNumber = 110,
    kMmCompactionTryToCompactPagesFieldNumber = 111,
    kMmCompactionWakeupKcompactdFieldNumber = 112,
    kSuspendResumeFieldNumber = 113,
    kSchedWakeupNewFieldNumber = 114,
    kBlockBioBackmergeFieldNumber = 115,
    kBlockBioBounceFieldNumber = 116,
    kBlockBioCompleteFieldNumber = 117,
    kBlockBioFrontmergeFieldNumber = 118,
    kBlockBioQueueFieldNumber = 119,
    kBlockBioRemapFieldNumber = 120,
    kBlockDirtyBufferFieldNumber = 121,
    kBlockGetrqFieldNumber = 122,
    kBlockPlugFieldNumber = 123,
    kBlockRqAbortFieldNumber = 124,
    kBlockRqCompleteFieldNumber = 125,
    kBlockRqInsertFieldNumber = 126,
    kBlockRqRemapFieldNumber = 128,
    kBlockRqRequeueFieldNumber = 129,
    kBlockSleeprqFieldNumber = 130,
    kBlockSplitFieldNumber = 131,
    kBlockTouchBufferFieldNumber = 132,
    kBlockUnplugFieldNumber = 133,
    kExt4AllocDaBlocksFieldNumber = 134,
    kExt4AllocateBlocksFieldNumber = 135,
    kExt4AllocateInodeFieldNumber = 136,
    kExt4BeginOrderedTruncateFieldNumber = 137,
    kExt4CollapseRangeFieldNumber = 138,
    kExt4DaReleaseSpaceFieldNumber = 139,
    kExt4DaReserveSpaceFieldNumber = 140,
    kExt4DaUpdateReserveSpaceFieldNumber = 141,
    kExt4DaWritePagesFieldNumber = 142,
    kExt4DaWritePagesExtentFieldNumber = 143,
    kExt4DirectIOEnterFieldNumber = 144,
    kExt4DirectIOExitFieldNumber = 145,
    kExt4DiscardBlocksFieldNumber = 146,
    kExt4DiscardPreallocationsFieldNumber = 147,
    kExt4DropInodeFieldNumber = 148,
    kExt4EsCacheExtentFieldNumber = 149,
    kExt4EsFindDelayedExtentRangeEnterFieldNumber = 150,
    kExt4EsFindDelayedExtentRangeExitFieldNumber = 151,
    kExt4EsInsertExtentFieldNumber = 152,
    kExt4EsLookupExtentEnterFieldNumber = 153,
    kExt4EsLookupExtentExitFieldNumber = 154,
    kExt4EsRemoveExtentFieldNumber = 155,
    kExt4EsShrinkFieldNumber = 156,
    kExt4EsShrinkCountFieldNumber = 157,
    kExt4EsShrinkScanEnterFieldNumber = 158,
    kExt4EsShrinkScanExitFieldNumber = 159,
    kExt4EvictInodeFieldNumber = 160,
    kExt4ExtConvertToInitializedEnterFieldNumber = 161,
    kExt4ExtConvertToInitializedFastpathFieldNumber = 162,
    kExt4ExtHandleUnwrittenExtentsFieldNumber = 163,
    kExt4ExtInCacheFieldNumber = 164,
    kExt4ExtLoadExtentFieldNumber = 165,
    kExt4ExtMapBlocksEnterFieldNumber = 166,
    kExt4ExtMapBlocksExitFieldNumber = 167,
    kExt4ExtPutInCacheFieldNumber = 168,
    kExt4ExtRemoveSpaceFieldNumber = 169,
    kExt4ExtRemoveSpaceDoneFieldNumber = 170,
    kExt4ExtRmIdxFieldNumber = 171,
    kExt4ExtRmLeafFieldNumber = 172,
    kExt4ExtShowExtentFieldNumber = 173,
    kExt4FallocateEnterFieldNumber = 174,
    kExt4FallocateExitFieldNumber = 175,
    kExt4FindDelallocRangeFieldNumber = 176,
    kExt4ForgetFieldNumber = 177,
    kExt4FreeBlocksFieldNumber = 178,
    kExt4FreeInodeFieldNumber = 179,
    kExt4GetImpliedClusterAllocExitFieldNumber = 180,
    kExt4GetReservedClusterAllocFieldNumber = 181,
    kExt4IndMapBlocksEnterFieldNumber = 182,
    kExt4IndMapBlocksExitFieldNumber = 183,
    kExt4InsertRangeFieldNumber = 184,
    kExt4InvalidatepageFieldNumber = 185,
    kExt4JournalStartFieldNumber = 186,
    kExt4JournalStartReservedFieldNumber = 187,
    kExt4JournalledInvalidatepageFieldNumber = 188,
    kExt4JournalledWriteEndFieldNumber = 189,
    kExt4LoadInodeFieldNumber = 190,
    kExt4LoadInodeBitmapFieldNumber = 191,
    kExt4MarkInodeDirtyFieldNumber = 192,
    kExt4MbBitmapLoadFieldNumber = 193,
    kExt4MbBuddyBitmapLoadFieldNumber = 194,
    kExt4MbDiscardPreallocationsFieldNumber = 195,
    kExt4MbNewGroupPaFieldNumber = 196,
    kExt4MbNewInodePaFieldNumber = 197,
    kExt4MbReleaseGroupPaFieldNumber = 198,
    kExt4MbReleaseInodePaFieldNumber = 199,
    kExt4MballocAllocFieldNumber = 200,
    kExt4MballocDiscardFieldNumber = 201,
    kExt4MballocFreeFieldNumber = 202,
    kExt4MballocPreallocFieldNumber = 203,
    kExt4OtherInodeUpdateTimeFieldNumber = 204,
    kExt4PunchHoleFieldNumber = 205,
    kExt4ReadBlockBitmapLoadFieldNumber = 206,
    kExt4ReadpageFieldNumber = 207,
    kExt4ReleasepageFieldNumber = 208,
    kExt4RemoveBlocksFieldNumber = 209,
    kExt4RequestBlocksFieldNumber = 210,
    kExt4RequestInodeFieldNumber = 211,
    kExt4SyncFsFieldNumber = 212,
    kExt4TrimAllFreeFieldNumber = 213,
    kExt4TrimExtentFieldNumber = 214,
    kExt4TruncateEnterFieldNumber = 215,
    kExt4TruncateExitFieldNumber = 216,
    kExt4UnlinkEnterFieldNumber = 217,
    kExt4UnlinkExitFieldNumber = 218,
    kExt4WriteBeginFieldNumber = 219,
    kExt4WriteEndFieldNumber = 230,
    kExt4WritepageFieldNumber = 231,
    kExt4WritepagesFieldNumber = 232,
    kExt4WritepagesResultFieldNumber = 233,
    kExt4ZeroRangeFieldNumber = 234,
    kTaskNewtaskFieldNumber = 235,
    kTaskRenameFieldNumber = 236,
    kSchedProcessExecFieldNumber = 237,
    kSchedProcessExitFieldNumber = 238,
    kSchedProcessForkFieldNumber = 239,
    kSchedProcessFreeFieldNumber = 240,
    kSchedProcessHangFieldNumber = 241,
    kSchedProcessWaitFieldNumber = 242,
    kF2fsDoSubmitBioFieldNumber = 243,
    kF2fsEvictInodeFieldNumber = 244,
    kF2fsFallocateFieldNumber = 245,
    kF2fsGetDataBlockFieldNumber = 246,
    kF2fsGetVictimFieldNumber = 247,
    kF2fsIgetFieldNumber = 248,
    kF2fsIgetExitFieldNumber = 249,
    kF2fsNewInodeFieldNumber = 250,
    kF2fsReadpageFieldNumber = 251,
    kF2fsReserveNewBlockFieldNumber = 252,
    kF2fsSetPageDirtyFieldNumber = 253,
    kF2fsSubmitWritePageFieldNumber = 254,
    kF2fsSyncFileEnterFieldNumber = 255,
    kF2fsSyncFileExitFieldNumber = 256,
    kF2fsSyncFsFieldNumber = 257,
    kF2fsTruncateFieldNumber = 258,
    kF2fsTruncateBlocksEnterFieldNumber = 259,
    kF2fsTruncateBlocksExitFieldNumber = 260,
    kF2fsTruncateDataBlocksRangeFieldNumber = 261,
    kF2fsTruncateInodeBlocksEnterFieldNumber = 262,
    kF2fsTruncateInodeBlocksExitFieldNumber = 263,
    kF2fsTruncateNodeFieldNumber = 264,
    kF2fsTruncateNodesEnterFieldNumber = 265,
    kF2fsTruncateNodesExitFieldNumber = 266,
    kF2fsTruncatePartialNodesFieldNumber = 267,
    kF2fsUnlinkEnterFieldNumber = 268,
    kF2fsUnlinkExitFieldNumber = 269,
    kF2fsVmPageMkwriteFieldNumber = 270,
    kF2fsWriteBeginFieldNumber = 271,
    kF2fsWriteCheckpointFieldNumber = 272,
    kF2fsWriteEndFieldNumber = 273,
    kAllocPagesIommuEndFieldNumber = 274,
    kAllocPagesIommuFailFieldNumber = 275,
    kAllocPagesIommuStartFieldNumber = 276,
    kAllocPagesSysEndFieldNumber = 277,
    kAllocPagesSysFailFieldNumber = 278,
    kAllocPagesSysStartFieldNumber = 279,
    kDmaAllocContiguousRetryFieldNumber = 280,
    kIommuMapRangeFieldNumber = 281,
    kIommuSecPtblMapRangeEndFieldNumber = 282,
    kIommuSecPtblMapRangeStartFieldNumber = 283,
    kIonAllocBufferEndFieldNumber = 284,
    kIonAllocBufferFailFieldNumber = 285,
    kIonAllocBufferFallbackFieldNumber = 286,
    kIonAllocBufferStartFieldNumber = 287,
    kIonCpAllocRetryFieldNumber = 288,
    kIonCpSecureBufferEndFieldNumber = 289,
    kIonCpSecureBufferStartFieldNumber = 290,
    kIonPrefetchingFieldNumber = 291,
    kIonSecureCmaAddToPoolEndFieldNumber = 292,
    kIonSecureCmaAddToPoolStartFieldNumber = 293,
    kIonSecureCmaAllocateEndFieldNumber = 294,
    kIonSecureCmaAllocateStartFieldNumber = 295,
    kIonSecureCmaShrinkPoolEndFieldNumber = 296,
    kIonSecureCmaShrinkPoolStartFieldNumber = 297,
    kKfreeFieldNumber = 298,
    kKmallocFieldNumber = 299,
    kKmallocNodeFieldNumber = 300,
    kKmemCacheAllocFieldNumber = 301,
    kKmemCacheAllocNodeFieldNumber = 302,
    kKmemCacheFreeFieldNumber = 303,
    kMigratePagesEndFieldNumber = 304,
    kMigratePagesStartFieldNumber = 305,
    kMigrateRetryFieldNumber = 306,
    kMmPageAllocFieldNumber = 307,
    kMmPageAllocExtfragFieldNumber = 308,
    kMmPageAllocZoneLockedFieldNumber = 309,
    kMmPageFreeFieldNumber = 310,
    kMmPageFreeBatchedFieldNumber = 311,
    kMmPagePcpuDrainFieldNumber = 312,
    kRssStatFieldNumber = 313,
    kIonHeapShrinkFieldNumber = 314,
    kIonHeapGrowFieldNumber = 315,
    kFenceInitFieldNumber = 316,
    kFenceDestroyFieldNumber = 317,
    kFenceEnableSignalFieldNumber = 318,
    kFenceSignaledFieldNumber = 319,
    kClkEnableFieldNumber = 320,
    kClkDisableFieldNumber = 321,
    kClkSetRateFieldNumber = 322,
    kBinderTransactionAllocBufFieldNumber = 323,
    kSignalDeliverFieldNumber = 324,
    kSignalGenerateFieldNumber = 325,
    kOomScoreAdjUpdateFieldNumber = 326,
    kGenericFieldNumber = 327,
    kMmEventRecordFieldNumber = 328,
    kSysEnterFieldNumber = 329,
    kSysExitFieldNumber = 330,
    kZeroFieldNumber = 331,
    kGpuFrequencyFieldNumber = 332,
    kGpuSchedEnqueueFieldNumber = 333,
    kGpuSchedSubmitFieldNumber = 334,
    kGpuSchedCompleteFieldNumber = 335,
  };
  void set_timestamp(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_pid(uint32_t value) {
    AppendVarInt(2, value);
  }
  template <typename T = PrintFtraceEvent> T* set_print() {
    return BeginNestedMessage<T>(3);
  }

  template <typename T = SchedSwitchFtraceEvent> T* set_sched_switch() {
    return BeginNestedMessage<T>(4);
  }

  template <typename T = CpuFrequencyFtraceEvent> T* set_cpu_frequency() {
    return BeginNestedMessage<T>(11);
  }

  template <typename T = CpuFrequencyLimitsFtraceEvent> T* set_cpu_frequency_limits() {
    return BeginNestedMessage<T>(12);
  }

  template <typename T = CpuIdleFtraceEvent> T* set_cpu_idle() {
    return BeginNestedMessage<T>(13);
  }

  template <typename T = ClockEnableFtraceEvent> T* set_clock_enable() {
    return BeginNestedMessage<T>(14);
  }

  template <typename T = ClockDisableFtraceEvent> T* set_clock_disable() {
    return BeginNestedMessage<T>(15);
  }

  template <typename T = ClockSetRateFtraceEvent> T* set_clock_set_rate() {
    return BeginNestedMessage<T>(16);
  }

  template <typename T = SchedWakeupFtraceEvent> T* set_sched_wakeup() {
    return BeginNestedMessage<T>(17);
  }

  template <typename T = SchedBlockedReasonFtraceEvent> T* set_sched_blocked_reason() {
    return BeginNestedMessage<T>(18);
  }

  template <typename T = SchedCpuHotplugFtraceEvent> T* set_sched_cpu_hotplug() {
    return BeginNestedMessage<T>(19);
  }

  template <typename T = SchedWakingFtraceEvent> T* set_sched_waking() {
    return BeginNestedMessage<T>(20);
  }

  template <typename T = IpiEntryFtraceEvent> T* set_ipi_entry() {
    return BeginNestedMessage<T>(21);
  }

  template <typename T = IpiExitFtraceEvent> T* set_ipi_exit() {
    return BeginNestedMessage<T>(22);
  }

  template <typename T = IpiRaiseFtraceEvent> T* set_ipi_raise() {
    return BeginNestedMessage<T>(23);
  }

  template <typename T = SoftirqEntryFtraceEvent> T* set_softirq_entry() {
    return BeginNestedMessage<T>(24);
  }

  template <typename T = SoftirqExitFtraceEvent> T* set_softirq_exit() {
    return BeginNestedMessage<T>(25);
  }

  template <typename T = SoftirqRaiseFtraceEvent> T* set_softirq_raise() {
    return BeginNestedMessage<T>(26);
  }

  template <typename T = I2cReadFtraceEvent> T* set_i2c_read() {
    return BeginNestedMessage<T>(27);
  }

  template <typename T = I2cWriteFtraceEvent> T* set_i2c_write() {
    return BeginNestedMessage<T>(28);
  }

  template <typename T = I2cResultFtraceEvent> T* set_i2c_result() {
    return BeginNestedMessage<T>(29);
  }

  template <typename T = I2cReplyFtraceEvent> T* set_i2c_reply() {
    return BeginNestedMessage<T>(30);
  }

  template <typename T = SmbusReadFtraceEvent> T* set_smbus_read() {
    return BeginNestedMessage<T>(31);
  }

  template <typename T = SmbusWriteFtraceEvent> T* set_smbus_write() {
    return BeginNestedMessage<T>(32);
  }

  template <typename T = SmbusResultFtraceEvent> T* set_smbus_result() {
    return BeginNestedMessage<T>(33);
  }

  template <typename T = SmbusReplyFtraceEvent> T* set_smbus_reply() {
    return BeginNestedMessage<T>(34);
  }

  template <typename T = LowmemoryKillFtraceEvent> T* set_lowmemory_kill() {
    return BeginNestedMessage<T>(35);
  }

  template <typename T = IrqHandlerEntryFtraceEvent> T* set_irq_handler_entry() {
    return BeginNestedMessage<T>(36);
  }

  template <typename T = IrqHandlerExitFtraceEvent> T* set_irq_handler_exit() {
    return BeginNestedMessage<T>(37);
  }

  template <typename T = SyncPtFtraceEvent> T* set_sync_pt() {
    return BeginNestedMessage<T>(38);
  }

  template <typename T = SyncTimelineFtraceEvent> T* set_sync_timeline() {
    return BeginNestedMessage<T>(39);
  }

  template <typename T = SyncWaitFtraceEvent> T* set_sync_wait() {
    return BeginNestedMessage<T>(40);
  }

  template <typename T = Ext4DaWriteBeginFtraceEvent> T* set_ext4_da_write_begin() {
    return BeginNestedMessage<T>(41);
  }

  template <typename T = Ext4DaWriteEndFtraceEvent> T* set_ext4_da_write_end() {
    return BeginNestedMessage<T>(42);
  }

  template <typename T = Ext4SyncFileEnterFtraceEvent> T* set_ext4_sync_file_enter() {
    return BeginNestedMessage<T>(43);
  }

  template <typename T = Ext4SyncFileExitFtraceEvent> T* set_ext4_sync_file_exit() {
    return BeginNestedMessage<T>(44);
  }

  template <typename T = BlockRqIssueFtraceEvent> T* set_block_rq_issue() {
    return BeginNestedMessage<T>(45);
  }

  template <typename T = MmVmscanDirectReclaimBeginFtraceEvent> T* set_mm_vmscan_direct_reclaim_begin() {
    return BeginNestedMessage<T>(46);
  }

  template <typename T = MmVmscanDirectReclaimEndFtraceEvent> T* set_mm_vmscan_direct_reclaim_end() {
    return BeginNestedMessage<T>(47);
  }

  template <typename T = MmVmscanKswapdWakeFtraceEvent> T* set_mm_vmscan_kswapd_wake() {
    return BeginNestedMessage<T>(48);
  }

  template <typename T = MmVmscanKswapdSleepFtraceEvent> T* set_mm_vmscan_kswapd_sleep() {
    return BeginNestedMessage<T>(49);
  }

  template <typename T = BinderTransactionFtraceEvent> T* set_binder_transaction() {
    return BeginNestedMessage<T>(50);
  }

  template <typename T = BinderTransactionReceivedFtraceEvent> T* set_binder_transaction_received() {
    return BeginNestedMessage<T>(51);
  }

  template <typename T = BinderSetPriorityFtraceEvent> T* set_binder_set_priority() {
    return BeginNestedMessage<T>(52);
  }

  template <typename T = BinderLockFtraceEvent> T* set_binder_lock() {
    return BeginNestedMessage<T>(53);
  }

  template <typename T = BinderLockedFtraceEvent> T* set_binder_locked() {
    return BeginNestedMessage<T>(54);
  }

  template <typename T = BinderUnlockFtraceEvent> T* set_binder_unlock() {
    return BeginNestedMessage<T>(55);
  }

  template <typename T = WorkqueueActivateWorkFtraceEvent> T* set_workqueue_activate_work() {
    return BeginNestedMessage<T>(56);
  }

  template <typename T = WorkqueueExecuteEndFtraceEvent> T* set_workqueue_execute_end() {
    return BeginNestedMessage<T>(57);
  }

  template <typename T = WorkqueueExecuteStartFtraceEvent> T* set_workqueue_execute_start() {
    return BeginNestedMessage<T>(58);
  }

  template <typename T = WorkqueueQueueWorkFtraceEvent> T* set_workqueue_queue_work() {
    return BeginNestedMessage<T>(59);
  }

  template <typename T = RegulatorDisableFtraceEvent> T* set_regulator_disable() {
    return BeginNestedMessage<T>(60);
  }

  template <typename T = RegulatorDisableCompleteFtraceEvent> T* set_regulator_disable_complete() {
    return BeginNestedMessage<T>(61);
  }

  template <typename T = RegulatorEnableFtraceEvent> T* set_regulator_enable() {
    return BeginNestedMessage<T>(62);
  }

  template <typename T = RegulatorEnableCompleteFtraceEvent> T* set_regulator_enable_complete() {
    return BeginNestedMessage<T>(63);
  }

  template <typename T = RegulatorEnableDelayFtraceEvent> T* set_regulator_enable_delay() {
    return BeginNestedMessage<T>(64);
  }

  template <typename T = RegulatorSetVoltageFtraceEvent> T* set_regulator_set_voltage() {
    return BeginNestedMessage<T>(65);
  }

  template <typename T = RegulatorSetVoltageCompleteFtraceEvent> T* set_regulator_set_voltage_complete() {
    return BeginNestedMessage<T>(66);
  }

  template <typename T = CgroupAttachTaskFtraceEvent> T* set_cgroup_attach_task() {
    return BeginNestedMessage<T>(67);
  }

  template <typename T = CgroupMkdirFtraceEvent> T* set_cgroup_mkdir() {
    return BeginNestedMessage<T>(68);
  }

  template <typename T = CgroupRemountFtraceEvent> T* set_cgroup_remount() {
    return BeginNestedMessage<T>(69);
  }

  template <typename T = CgroupRmdirFtraceEvent> T* set_cgroup_rmdir() {
    return BeginNestedMessage<T>(70);
  }

  template <typename T = CgroupTransferTasksFtraceEvent> T* set_cgroup_transfer_tasks() {
    return BeginNestedMessage<T>(71);
  }

  template <typename T = CgroupDestroyRootFtraceEvent> T* set_cgroup_destroy_root() {
    return BeginNestedMessage<T>(72);
  }

  template <typename T = CgroupReleaseFtraceEvent> T* set_cgroup_release() {
    return BeginNestedMessage<T>(73);
  }

  template <typename T = CgroupRenameFtraceEvent> T* set_cgroup_rename() {
    return BeginNestedMessage<T>(74);
  }

  template <typename T = CgroupSetupRootFtraceEvent> T* set_cgroup_setup_root() {
    return BeginNestedMessage<T>(75);
  }

  template <typename T = MdpCmdKickoffFtraceEvent> T* set_mdp_cmd_kickoff() {
    return BeginNestedMessage<T>(76);
  }

  template <typename T = MdpCommitFtraceEvent> T* set_mdp_commit() {
    return BeginNestedMessage<T>(77);
  }

  template <typename T = MdpPerfSetOtFtraceEvent> T* set_mdp_perf_set_ot() {
    return BeginNestedMessage<T>(78);
  }

  template <typename T = MdpSsppChangeFtraceEvent> T* set_mdp_sspp_change() {
    return BeginNestedMessage<T>(79);
  }

  template <typename T = TracingMarkWriteFtraceEvent> T* set_tracing_mark_write() {
    return BeginNestedMessage<T>(80);
  }

  template <typename T = MdpCmdPingpongDoneFtraceEvent> T* set_mdp_cmd_pingpong_done() {
    return BeginNestedMessage<T>(81);
  }

  template <typename T = MdpCompareBwFtraceEvent> T* set_mdp_compare_bw() {
    return BeginNestedMessage<T>(82);
  }

  template <typename T = MdpPerfSetPanicLutsFtraceEvent> T* set_mdp_perf_set_panic_luts() {
    return BeginNestedMessage<T>(83);
  }

  template <typename T = MdpSsppSetFtraceEvent> T* set_mdp_sspp_set() {
    return BeginNestedMessage<T>(84);
  }

  template <typename T = MdpCmdReadptrDoneFtraceEvent> T* set_mdp_cmd_readptr_done() {
    return BeginNestedMessage<T>(85);
  }

  template <typename T = MdpMisrCrcFtraceEvent> T* set_mdp_misr_crc() {
    return BeginNestedMessage<T>(86);
  }

  template <typename T = MdpPerfSetQosLutsFtraceEvent> T* set_mdp_perf_set_qos_luts() {
    return BeginNestedMessage<T>(87);
  }

  template <typename T = MdpTraceCounterFtraceEvent> T* set_mdp_trace_counter() {
    return BeginNestedMessage<T>(88);
  }

  template <typename T = MdpCmdReleaseBwFtraceEvent> T* set_mdp_cmd_release_bw() {
    return BeginNestedMessage<T>(89);
  }

  template <typename T = MdpMixerUpdateFtraceEvent> T* set_mdp_mixer_update() {
    return BeginNestedMessage<T>(90);
  }

  template <typename T = MdpPerfSetWmLevelsFtraceEvent> T* set_mdp_perf_set_wm_levels() {
    return BeginNestedMessage<T>(91);
  }

  template <typename T = MdpVideoUnderrunDoneFtraceEvent> T* set_mdp_video_underrun_done() {
    return BeginNestedMessage<T>(92);
  }

  template <typename T = MdpCmdWaitPingpongFtraceEvent> T* set_mdp_cmd_wait_pingpong() {
    return BeginNestedMessage<T>(93);
  }

  template <typename T = MdpPerfPrefillCalcFtraceEvent> T* set_mdp_perf_prefill_calc() {
    return BeginNestedMessage<T>(94);
  }

  template <typename T = MdpPerfUpdateBusFtraceEvent> T* set_mdp_perf_update_bus() {
    return BeginNestedMessage<T>(95);
  }

  template <typename T = RotatorBwAoAsContextFtraceEvent> T* set_rotator_bw_ao_as_context() {
    return BeginNestedMessage<T>(96);
  }

  template <typename T = MmFilemapAddToPageCacheFtraceEvent> T* set_mm_filemap_add_to_page_cache() {
    return BeginNestedMessage<T>(97);
  }

  template <typename T = MmFilemapDeleteFromPageCacheFtraceEvent> T* set_mm_filemap_delete_from_page_cache() {
    return BeginNestedMessage<T>(98);
  }

  template <typename T = MmCompactionBeginFtraceEvent> T* set_mm_compaction_begin() {
    return BeginNestedMessage<T>(99);
  }

  template <typename T = MmCompactionDeferCompactionFtraceEvent> T* set_mm_compaction_defer_compaction() {
    return BeginNestedMessage<T>(100);
  }

  template <typename T = MmCompactionDeferredFtraceEvent> T* set_mm_compaction_deferred() {
    return BeginNestedMessage<T>(101);
  }

  template <typename T = MmCompactionDeferResetFtraceEvent> T* set_mm_compaction_defer_reset() {
    return BeginNestedMessage<T>(102);
  }

  template <typename T = MmCompactionEndFtraceEvent> T* set_mm_compaction_end() {
    return BeginNestedMessage<T>(103);
  }

  template <typename T = MmCompactionFinishedFtraceEvent> T* set_mm_compaction_finished() {
    return BeginNestedMessage<T>(104);
  }

  template <typename T = MmCompactionIsolateFreepagesFtraceEvent> T* set_mm_compaction_isolate_freepages() {
    return BeginNestedMessage<T>(105);
  }

  template <typename T = MmCompactionIsolateMigratepagesFtraceEvent> T* set_mm_compaction_isolate_migratepages() {
    return BeginNestedMessage<T>(106);
  }

  template <typename T = MmCompactionKcompactdSleepFtraceEvent> T* set_mm_compaction_kcompactd_sleep() {
    return BeginNestedMessage<T>(107);
  }

  template <typename T = MmCompactionKcompactdWakeFtraceEvent> T* set_mm_compaction_kcompactd_wake() {
    return BeginNestedMessage<T>(108);
  }

  template <typename T = MmCompactionMigratepagesFtraceEvent> T* set_mm_compaction_migratepages() {
    return BeginNestedMessage<T>(109);
  }

  template <typename T = MmCompactionSuitableFtraceEvent> T* set_mm_compaction_suitable() {
    return BeginNestedMessage<T>(110);
  }

  template <typename T = MmCompactionTryToCompactPagesFtraceEvent> T* set_mm_compaction_try_to_compact_pages() {
    return BeginNestedMessage<T>(111);
  }

  template <typename T = MmCompactionWakeupKcompactdFtraceEvent> T* set_mm_compaction_wakeup_kcompactd() {
    return BeginNestedMessage<T>(112);
  }

  template <typename T = SuspendResumeFtraceEvent> T* set_suspend_resume() {
    return BeginNestedMessage<T>(113);
  }

  template <typename T = SchedWakeupNewFtraceEvent> T* set_sched_wakeup_new() {
    return BeginNestedMessage<T>(114);
  }

  template <typename T = BlockBioBackmergeFtraceEvent> T* set_block_bio_backmerge() {
    return BeginNestedMessage<T>(115);
  }

  template <typename T = BlockBioBounceFtraceEvent> T* set_block_bio_bounce() {
    return BeginNestedMessage<T>(116);
  }

  template <typename T = BlockBioCompleteFtraceEvent> T* set_block_bio_complete() {
    return BeginNestedMessage<T>(117);
  }

  template <typename T = BlockBioFrontmergeFtraceEvent> T* set_block_bio_frontmerge() {
    return BeginNestedMessage<T>(118);
  }

  template <typename T = BlockBioQueueFtraceEvent> T* set_block_bio_queue() {
    return BeginNestedMessage<T>(119);
  }

  template <typename T = BlockBioRemapFtraceEvent> T* set_block_bio_remap() {
    return BeginNestedMessage<T>(120);
  }

  template <typename T = BlockDirtyBufferFtraceEvent> T* set_block_dirty_buffer() {
    return BeginNestedMessage<T>(121);
  }

  template <typename T = BlockGetrqFtraceEvent> T* set_block_getrq() {
    return BeginNestedMessage<T>(122);
  }

  template <typename T = BlockPlugFtraceEvent> T* set_block_plug() {
    return BeginNestedMessage<T>(123);
  }

  template <typename T = BlockRqAbortFtraceEvent> T* set_block_rq_abort() {
    return BeginNestedMessage<T>(124);
  }

  template <typename T = BlockRqCompleteFtraceEvent> T* set_block_rq_complete() {
    return BeginNestedMessage<T>(125);
  }

  template <typename T = BlockRqInsertFtraceEvent> T* set_block_rq_insert() {
    return BeginNestedMessage<T>(126);
  }

  template <typename T = BlockRqRemapFtraceEvent> T* set_block_rq_remap() {
    return BeginNestedMessage<T>(128);
  }

  template <typename T = BlockRqRequeueFtraceEvent> T* set_block_rq_requeue() {
    return BeginNestedMessage<T>(129);
  }

  template <typename T = BlockSleeprqFtraceEvent> T* set_block_sleeprq() {
    return BeginNestedMessage<T>(130);
  }

  template <typename T = BlockSplitFtraceEvent> T* set_block_split() {
    return BeginNestedMessage<T>(131);
  }

  template <typename T = BlockTouchBufferFtraceEvent> T* set_block_touch_buffer() {
    return BeginNestedMessage<T>(132);
  }

  template <typename T = BlockUnplugFtraceEvent> T* set_block_unplug() {
    return BeginNestedMessage<T>(133);
  }

  template <typename T = Ext4AllocDaBlocksFtraceEvent> T* set_ext4_alloc_da_blocks() {
    return BeginNestedMessage<T>(134);
  }

  template <typename T = Ext4AllocateBlocksFtraceEvent> T* set_ext4_allocate_blocks() {
    return BeginNestedMessage<T>(135);
  }

  template <typename T = Ext4AllocateInodeFtraceEvent> T* set_ext4_allocate_inode() {
    return BeginNestedMessage<T>(136);
  }

  template <typename T = Ext4BeginOrderedTruncateFtraceEvent> T* set_ext4_begin_ordered_truncate() {
    return BeginNestedMessage<T>(137);
  }

  template <typename T = Ext4CollapseRangeFtraceEvent> T* set_ext4_collapse_range() {
    return BeginNestedMessage<T>(138);
  }

  template <typename T = Ext4DaReleaseSpaceFtraceEvent> T* set_ext4_da_release_space() {
    return BeginNestedMessage<T>(139);
  }

  template <typename T = Ext4DaReserveSpaceFtraceEvent> T* set_ext4_da_reserve_space() {
    return BeginNestedMessage<T>(140);
  }

  template <typename T = Ext4DaUpdateReserveSpaceFtraceEvent> T* set_ext4_da_update_reserve_space() {
    return BeginNestedMessage<T>(141);
  }

  template <typename T = Ext4DaWritePagesFtraceEvent> T* set_ext4_da_write_pages() {
    return BeginNestedMessage<T>(142);
  }

  template <typename T = Ext4DaWritePagesExtentFtraceEvent> T* set_ext4_da_write_pages_extent() {
    return BeginNestedMessage<T>(143);
  }

  template <typename T = Ext4DirectIOEnterFtraceEvent> T* set_ext4_direct_IO_enter() {
    return BeginNestedMessage<T>(144);
  }

  template <typename T = Ext4DirectIOExitFtraceEvent> T* set_ext4_direct_IO_exit() {
    return BeginNestedMessage<T>(145);
  }

  template <typename T = Ext4DiscardBlocksFtraceEvent> T* set_ext4_discard_blocks() {
    return BeginNestedMessage<T>(146);
  }

  template <typename T = Ext4DiscardPreallocationsFtraceEvent> T* set_ext4_discard_preallocations() {
    return BeginNestedMessage<T>(147);
  }

  template <typename T = Ext4DropInodeFtraceEvent> T* set_ext4_drop_inode() {
    return BeginNestedMessage<T>(148);
  }

  template <typename T = Ext4EsCacheExtentFtraceEvent> T* set_ext4_es_cache_extent() {
    return BeginNestedMessage<T>(149);
  }

  template <typename T = Ext4EsFindDelayedExtentRangeEnterFtraceEvent> T* set_ext4_es_find_delayed_extent_range_enter() {
    return BeginNestedMessage<T>(150);
  }

  template <typename T = Ext4EsFindDelayedExtentRangeExitFtraceEvent> T* set_ext4_es_find_delayed_extent_range_exit() {
    return BeginNestedMessage<T>(151);
  }

  template <typename T = Ext4EsInsertExtentFtraceEvent> T* set_ext4_es_insert_extent() {
    return BeginNestedMessage<T>(152);
  }

  template <typename T = Ext4EsLookupExtentEnterFtraceEvent> T* set_ext4_es_lookup_extent_enter() {
    return BeginNestedMessage<T>(153);
  }

  template <typename T = Ext4EsLookupExtentExitFtraceEvent> T* set_ext4_es_lookup_extent_exit() {
    return BeginNestedMessage<T>(154);
  }

  template <typename T = Ext4EsRemoveExtentFtraceEvent> T* set_ext4_es_remove_extent() {
    return BeginNestedMessage<T>(155);
  }

  template <typename T = Ext4EsShrinkFtraceEvent> T* set_ext4_es_shrink() {
    return BeginNestedMessage<T>(156);
  }

  template <typename T = Ext4EsShrinkCountFtraceEvent> T* set_ext4_es_shrink_count() {
    return BeginNestedMessage<T>(157);
  }

  template <typename T = Ext4EsShrinkScanEnterFtraceEvent> T* set_ext4_es_shrink_scan_enter() {
    return BeginNestedMessage<T>(158);
  }

  template <typename T = Ext4EsShrinkScanExitFtraceEvent> T* set_ext4_es_shrink_scan_exit() {
    return BeginNestedMessage<T>(159);
  }

  template <typename T = Ext4EvictInodeFtraceEvent> T* set_ext4_evict_inode() {
    return BeginNestedMessage<T>(160);
  }

  template <typename T = Ext4ExtConvertToInitializedEnterFtraceEvent> T* set_ext4_ext_convert_to_initialized_enter() {
    return BeginNestedMessage<T>(161);
  }

  template <typename T = Ext4ExtConvertToInitializedFastpathFtraceEvent> T* set_ext4_ext_convert_to_initialized_fastpath() {
    return BeginNestedMessage<T>(162);
  }

  template <typename T = Ext4ExtHandleUnwrittenExtentsFtraceEvent> T* set_ext4_ext_handle_unwritten_extents() {
    return BeginNestedMessage<T>(163);
  }

  template <typename T = Ext4ExtInCacheFtraceEvent> T* set_ext4_ext_in_cache() {
    return BeginNestedMessage<T>(164);
  }

  template <typename T = Ext4ExtLoadExtentFtraceEvent> T* set_ext4_ext_load_extent() {
    return BeginNestedMessage<T>(165);
  }

  template <typename T = Ext4ExtMapBlocksEnterFtraceEvent> T* set_ext4_ext_map_blocks_enter() {
    return BeginNestedMessage<T>(166);
  }

  template <typename T = Ext4ExtMapBlocksExitFtraceEvent> T* set_ext4_ext_map_blocks_exit() {
    return BeginNestedMessage<T>(167);
  }

  template <typename T = Ext4ExtPutInCacheFtraceEvent> T* set_ext4_ext_put_in_cache() {
    return BeginNestedMessage<T>(168);
  }

  template <typename T = Ext4ExtRemoveSpaceFtraceEvent> T* set_ext4_ext_remove_space() {
    return BeginNestedMessage<T>(169);
  }

  template <typename T = Ext4ExtRemoveSpaceDoneFtraceEvent> T* set_ext4_ext_remove_space_done() {
    return BeginNestedMessage<T>(170);
  }

  template <typename T = Ext4ExtRmIdxFtraceEvent> T* set_ext4_ext_rm_idx() {
    return BeginNestedMessage<T>(171);
  }

  template <typename T = Ext4ExtRmLeafFtraceEvent> T* set_ext4_ext_rm_leaf() {
    return BeginNestedMessage<T>(172);
  }

  template <typename T = Ext4ExtShowExtentFtraceEvent> T* set_ext4_ext_show_extent() {
    return BeginNestedMessage<T>(173);
  }

  template <typename T = Ext4FallocateEnterFtraceEvent> T* set_ext4_fallocate_enter() {
    return BeginNestedMessage<T>(174);
  }

  template <typename T = Ext4FallocateExitFtraceEvent> T* set_ext4_fallocate_exit() {
    return BeginNestedMessage<T>(175);
  }

  template <typename T = Ext4FindDelallocRangeFtraceEvent> T* set_ext4_find_delalloc_range() {
    return BeginNestedMessage<T>(176);
  }

  template <typename T = Ext4ForgetFtraceEvent> T* set_ext4_forget() {
    return BeginNestedMessage<T>(177);
  }

  template <typename T = Ext4FreeBlocksFtraceEvent> T* set_ext4_free_blocks() {
    return BeginNestedMessage<T>(178);
  }

  template <typename T = Ext4FreeInodeFtraceEvent> T* set_ext4_free_inode() {
    return BeginNestedMessage<T>(179);
  }

  template <typename T = Ext4GetImpliedClusterAllocExitFtraceEvent> T* set_ext4_get_implied_cluster_alloc_exit() {
    return BeginNestedMessage<T>(180);
  }

  template <typename T = Ext4GetReservedClusterAllocFtraceEvent> T* set_ext4_get_reserved_cluster_alloc() {
    return BeginNestedMessage<T>(181);
  }

  template <typename T = Ext4IndMapBlocksEnterFtraceEvent> T* set_ext4_ind_map_blocks_enter() {
    return BeginNestedMessage<T>(182);
  }

  template <typename T = Ext4IndMapBlocksExitFtraceEvent> T* set_ext4_ind_map_blocks_exit() {
    return BeginNestedMessage<T>(183);
  }

  template <typename T = Ext4InsertRangeFtraceEvent> T* set_ext4_insert_range() {
    return BeginNestedMessage<T>(184);
  }

  template <typename T = Ext4InvalidatepageFtraceEvent> T* set_ext4_invalidatepage() {
    return BeginNestedMessage<T>(185);
  }

  template <typename T = Ext4JournalStartFtraceEvent> T* set_ext4_journal_start() {
    return BeginNestedMessage<T>(186);
  }

  template <typename T = Ext4JournalStartReservedFtraceEvent> T* set_ext4_journal_start_reserved() {
    return BeginNestedMessage<T>(187);
  }

  template <typename T = Ext4JournalledInvalidatepageFtraceEvent> T* set_ext4_journalled_invalidatepage() {
    return BeginNestedMessage<T>(188);
  }

  template <typename T = Ext4JournalledWriteEndFtraceEvent> T* set_ext4_journalled_write_end() {
    return BeginNestedMessage<T>(189);
  }

  template <typename T = Ext4LoadInodeFtraceEvent> T* set_ext4_load_inode() {
    return BeginNestedMessage<T>(190);
  }

  template <typename T = Ext4LoadInodeBitmapFtraceEvent> T* set_ext4_load_inode_bitmap() {
    return BeginNestedMessage<T>(191);
  }

  template <typename T = Ext4MarkInodeDirtyFtraceEvent> T* set_ext4_mark_inode_dirty() {
    return BeginNestedMessage<T>(192);
  }

  template <typename T = Ext4MbBitmapLoadFtraceEvent> T* set_ext4_mb_bitmap_load() {
    return BeginNestedMessage<T>(193);
  }

  template <typename T = Ext4MbBuddyBitmapLoadFtraceEvent> T* set_ext4_mb_buddy_bitmap_load() {
    return BeginNestedMessage<T>(194);
  }

  template <typename T = Ext4MbDiscardPreallocationsFtraceEvent> T* set_ext4_mb_discard_preallocations() {
    return BeginNestedMessage<T>(195);
  }

  template <typename T = Ext4MbNewGroupPaFtraceEvent> T* set_ext4_mb_new_group_pa() {
    return BeginNestedMessage<T>(196);
  }

  template <typename T = Ext4MbNewInodePaFtraceEvent> T* set_ext4_mb_new_inode_pa() {
    return BeginNestedMessage<T>(197);
  }

  template <typename T = Ext4MbReleaseGroupPaFtraceEvent> T* set_ext4_mb_release_group_pa() {
    return BeginNestedMessage<T>(198);
  }

  template <typename T = Ext4MbReleaseInodePaFtraceEvent> T* set_ext4_mb_release_inode_pa() {
    return BeginNestedMessage<T>(199);
  }

  template <typename T = Ext4MballocAllocFtraceEvent> T* set_ext4_mballoc_alloc() {
    return BeginNestedMessage<T>(200);
  }

  template <typename T = Ext4MballocDiscardFtraceEvent> T* set_ext4_mballoc_discard() {
    return BeginNestedMessage<T>(201);
  }

  template <typename T = Ext4MballocFreeFtraceEvent> T* set_ext4_mballoc_free() {
    return BeginNestedMessage<T>(202);
  }

  template <typename T = Ext4MballocPreallocFtraceEvent> T* set_ext4_mballoc_prealloc() {
    return BeginNestedMessage<T>(203);
  }

  template <typename T = Ext4OtherInodeUpdateTimeFtraceEvent> T* set_ext4_other_inode_update_time() {
    return BeginNestedMessage<T>(204);
  }

  template <typename T = Ext4PunchHoleFtraceEvent> T* set_ext4_punch_hole() {
    return BeginNestedMessage<T>(205);
  }

  template <typename T = Ext4ReadBlockBitmapLoadFtraceEvent> T* set_ext4_read_block_bitmap_load() {
    return BeginNestedMessage<T>(206);
  }

  template <typename T = Ext4ReadpageFtraceEvent> T* set_ext4_readpage() {
    return BeginNestedMessage<T>(207);
  }

  template <typename T = Ext4ReleasepageFtraceEvent> T* set_ext4_releasepage() {
    return BeginNestedMessage<T>(208);
  }

  template <typename T = Ext4RemoveBlocksFtraceEvent> T* set_ext4_remove_blocks() {
    return BeginNestedMessage<T>(209);
  }

  template <typename T = Ext4RequestBlocksFtraceEvent> T* set_ext4_request_blocks() {
    return BeginNestedMessage<T>(210);
  }

  template <typename T = Ext4RequestInodeFtraceEvent> T* set_ext4_request_inode() {
    return BeginNestedMessage<T>(211);
  }

  template <typename T = Ext4SyncFsFtraceEvent> T* set_ext4_sync_fs() {
    return BeginNestedMessage<T>(212);
  }

  template <typename T = Ext4TrimAllFreeFtraceEvent> T* set_ext4_trim_all_free() {
    return BeginNestedMessage<T>(213);
  }

  template <typename T = Ext4TrimExtentFtraceEvent> T* set_ext4_trim_extent() {
    return BeginNestedMessage<T>(214);
  }

  template <typename T = Ext4TruncateEnterFtraceEvent> T* set_ext4_truncate_enter() {
    return BeginNestedMessage<T>(215);
  }

  template <typename T = Ext4TruncateExitFtraceEvent> T* set_ext4_truncate_exit() {
    return BeginNestedMessage<T>(216);
  }

  template <typename T = Ext4UnlinkEnterFtraceEvent> T* set_ext4_unlink_enter() {
    return BeginNestedMessage<T>(217);
  }

  template <typename T = Ext4UnlinkExitFtraceEvent> T* set_ext4_unlink_exit() {
    return BeginNestedMessage<T>(218);
  }

  template <typename T = Ext4WriteBeginFtraceEvent> T* set_ext4_write_begin() {
    return BeginNestedMessage<T>(219);
  }

  template <typename T = Ext4WriteEndFtraceEvent> T* set_ext4_write_end() {
    return BeginNestedMessage<T>(230);
  }

  template <typename T = Ext4WritepageFtraceEvent> T* set_ext4_writepage() {
    return BeginNestedMessage<T>(231);
  }

  template <typename T = Ext4WritepagesFtraceEvent> T* set_ext4_writepages() {
    return BeginNestedMessage<T>(232);
  }

  template <typename T = Ext4WritepagesResultFtraceEvent> T* set_ext4_writepages_result() {
    return BeginNestedMessage<T>(233);
  }

  template <typename T = Ext4ZeroRangeFtraceEvent> T* set_ext4_zero_range() {
    return BeginNestedMessage<T>(234);
  }

  template <typename T = TaskNewtaskFtraceEvent> T* set_task_newtask() {
    return BeginNestedMessage<T>(235);
  }

  template <typename T = TaskRenameFtraceEvent> T* set_task_rename() {
    return BeginNestedMessage<T>(236);
  }

  template <typename T = SchedProcessExecFtraceEvent> T* set_sched_process_exec() {
    return BeginNestedMessage<T>(237);
  }

  template <typename T = SchedProcessExitFtraceEvent> T* set_sched_process_exit() {
    return BeginNestedMessage<T>(238);
  }

  template <typename T = SchedProcessForkFtraceEvent> T* set_sched_process_fork() {
    return BeginNestedMessage<T>(239);
  }

  template <typename T = SchedProcessFreeFtraceEvent> T* set_sched_process_free() {
    return BeginNestedMessage<T>(240);
  }

  template <typename T = SchedProcessHangFtraceEvent> T* set_sched_process_hang() {
    return BeginNestedMessage<T>(241);
  }

  template <typename T = SchedProcessWaitFtraceEvent> T* set_sched_process_wait() {
    return BeginNestedMessage<T>(242);
  }

  template <typename T = F2fsDoSubmitBioFtraceEvent> T* set_f2fs_do_submit_bio() {
    return BeginNestedMessage<T>(243);
  }

  template <typename T = F2fsEvictInodeFtraceEvent> T* set_f2fs_evict_inode() {
    return BeginNestedMessage<T>(244);
  }

  template <typename T = F2fsFallocateFtraceEvent> T* set_f2fs_fallocate() {
    return BeginNestedMessage<T>(245);
  }

  template <typename T = F2fsGetDataBlockFtraceEvent> T* set_f2fs_get_data_block() {
    return BeginNestedMessage<T>(246);
  }

  template <typename T = F2fsGetVictimFtraceEvent> T* set_f2fs_get_victim() {
    return BeginNestedMessage<T>(247);
  }

  template <typename T = F2fsIgetFtraceEvent> T* set_f2fs_iget() {
    return BeginNestedMessage<T>(248);
  }

  template <typename T = F2fsIgetExitFtraceEvent> T* set_f2fs_iget_exit() {
    return BeginNestedMessage<T>(249);
  }

  template <typename T = F2fsNewInodeFtraceEvent> T* set_f2fs_new_inode() {
    return BeginNestedMessage<T>(250);
  }

  template <typename T = F2fsReadpageFtraceEvent> T* set_f2fs_readpage() {
    return BeginNestedMessage<T>(251);
  }

  template <typename T = F2fsReserveNewBlockFtraceEvent> T* set_f2fs_reserve_new_block() {
    return BeginNestedMessage<T>(252);
  }

  template <typename T = F2fsSetPageDirtyFtraceEvent> T* set_f2fs_set_page_dirty() {
    return BeginNestedMessage<T>(253);
  }

  template <typename T = F2fsSubmitWritePageFtraceEvent> T* set_f2fs_submit_write_page() {
    return BeginNestedMessage<T>(254);
  }

  template <typename T = F2fsSyncFileEnterFtraceEvent> T* set_f2fs_sync_file_enter() {
    return BeginNestedMessage<T>(255);
  }

  template <typename T = F2fsSyncFileExitFtraceEvent> T* set_f2fs_sync_file_exit() {
    return BeginNestedMessage<T>(256);
  }

  template <typename T = F2fsSyncFsFtraceEvent> T* set_f2fs_sync_fs() {
    return BeginNestedMessage<T>(257);
  }

  template <typename T = F2fsTruncateFtraceEvent> T* set_f2fs_truncate() {
    return BeginNestedMessage<T>(258);
  }

  template <typename T = F2fsTruncateBlocksEnterFtraceEvent> T* set_f2fs_truncate_blocks_enter() {
    return BeginNestedMessage<T>(259);
  }

  template <typename T = F2fsTruncateBlocksExitFtraceEvent> T* set_f2fs_truncate_blocks_exit() {
    return BeginNestedMessage<T>(260);
  }

  template <typename T = F2fsTruncateDataBlocksRangeFtraceEvent> T* set_f2fs_truncate_data_blocks_range() {
    return BeginNestedMessage<T>(261);
  }

  template <typename T = F2fsTruncateInodeBlocksEnterFtraceEvent> T* set_f2fs_truncate_inode_blocks_enter() {
    return BeginNestedMessage<T>(262);
  }

  template <typename T = F2fsTruncateInodeBlocksExitFtraceEvent> T* set_f2fs_truncate_inode_blocks_exit() {
    return BeginNestedMessage<T>(263);
  }

  template <typename T = F2fsTruncateNodeFtraceEvent> T* set_f2fs_truncate_node() {
    return BeginNestedMessage<T>(264);
  }

  template <typename T = F2fsTruncateNodesEnterFtraceEvent> T* set_f2fs_truncate_nodes_enter() {
    return BeginNestedMessage<T>(265);
  }

  template <typename T = F2fsTruncateNodesExitFtraceEvent> T* set_f2fs_truncate_nodes_exit() {
    return BeginNestedMessage<T>(266);
  }

  template <typename T = F2fsTruncatePartialNodesFtraceEvent> T* set_f2fs_truncate_partial_nodes() {
    return BeginNestedMessage<T>(267);
  }

  template <typename T = F2fsUnlinkEnterFtraceEvent> T* set_f2fs_unlink_enter() {
    return BeginNestedMessage<T>(268);
  }

  template <typename T = F2fsUnlinkExitFtraceEvent> T* set_f2fs_unlink_exit() {
    return BeginNestedMessage<T>(269);
  }

  template <typename T = F2fsVmPageMkwriteFtraceEvent> T* set_f2fs_vm_page_mkwrite() {
    return BeginNestedMessage<T>(270);
  }

  template <typename T = F2fsWriteBeginFtraceEvent> T* set_f2fs_write_begin() {
    return BeginNestedMessage<T>(271);
  }

  template <typename T = F2fsWriteCheckpointFtraceEvent> T* set_f2fs_write_checkpoint() {
    return BeginNestedMessage<T>(272);
  }

  template <typename T = F2fsWriteEndFtraceEvent> T* set_f2fs_write_end() {
    return BeginNestedMessage<T>(273);
  }

  template <typename T = AllocPagesIommuEndFtraceEvent> T* set_alloc_pages_iommu_end() {
    return BeginNestedMessage<T>(274);
  }

  template <typename T = AllocPagesIommuFailFtraceEvent> T* set_alloc_pages_iommu_fail() {
    return BeginNestedMessage<T>(275);
  }

  template <typename T = AllocPagesIommuStartFtraceEvent> T* set_alloc_pages_iommu_start() {
    return BeginNestedMessage<T>(276);
  }

  template <typename T = AllocPagesSysEndFtraceEvent> T* set_alloc_pages_sys_end() {
    return BeginNestedMessage<T>(277);
  }

  template <typename T = AllocPagesSysFailFtraceEvent> T* set_alloc_pages_sys_fail() {
    return BeginNestedMessage<T>(278);
  }

  template <typename T = AllocPagesSysStartFtraceEvent> T* set_alloc_pages_sys_start() {
    return BeginNestedMessage<T>(279);
  }

  template <typename T = DmaAllocContiguousRetryFtraceEvent> T* set_dma_alloc_contiguous_retry() {
    return BeginNestedMessage<T>(280);
  }

  template <typename T = IommuMapRangeFtraceEvent> T* set_iommu_map_range() {
    return BeginNestedMessage<T>(281);
  }

  template <typename T = IommuSecPtblMapRangeEndFtraceEvent> T* set_iommu_sec_ptbl_map_range_end() {
    return BeginNestedMessage<T>(282);
  }

  template <typename T = IommuSecPtblMapRangeStartFtraceEvent> T* set_iommu_sec_ptbl_map_range_start() {
    return BeginNestedMessage<T>(283);
  }

  template <typename T = IonAllocBufferEndFtraceEvent> T* set_ion_alloc_buffer_end() {
    return BeginNestedMessage<T>(284);
  }

  template <typename T = IonAllocBufferFailFtraceEvent> T* set_ion_alloc_buffer_fail() {
    return BeginNestedMessage<T>(285);
  }

  template <typename T = IonAllocBufferFallbackFtraceEvent> T* set_ion_alloc_buffer_fallback() {
    return BeginNestedMessage<T>(286);
  }

  template <typename T = IonAllocBufferStartFtraceEvent> T* set_ion_alloc_buffer_start() {
    return BeginNestedMessage<T>(287);
  }

  template <typename T = IonCpAllocRetryFtraceEvent> T* set_ion_cp_alloc_retry() {
    return BeginNestedMessage<T>(288);
  }

  template <typename T = IonCpSecureBufferEndFtraceEvent> T* set_ion_cp_secure_buffer_end() {
    return BeginNestedMessage<T>(289);
  }

  template <typename T = IonCpSecureBufferStartFtraceEvent> T* set_ion_cp_secure_buffer_start() {
    return BeginNestedMessage<T>(290);
  }

  template <typename T = IonPrefetchingFtraceEvent> T* set_ion_prefetching() {
    return BeginNestedMessage<T>(291);
  }

  template <typename T = IonSecureCmaAddToPoolEndFtraceEvent> T* set_ion_secure_cma_add_to_pool_end() {
    return BeginNestedMessage<T>(292);
  }

  template <typename T = IonSecureCmaAddToPoolStartFtraceEvent> T* set_ion_secure_cma_add_to_pool_start() {
    return BeginNestedMessage<T>(293);
  }

  template <typename T = IonSecureCmaAllocateEndFtraceEvent> T* set_ion_secure_cma_allocate_end() {
    return BeginNestedMessage<T>(294);
  }

  template <typename T = IonSecureCmaAllocateStartFtraceEvent> T* set_ion_secure_cma_allocate_start() {
    return BeginNestedMessage<T>(295);
  }

  template <typename T = IonSecureCmaShrinkPoolEndFtraceEvent> T* set_ion_secure_cma_shrink_pool_end() {
    return BeginNestedMessage<T>(296);
  }

  template <typename T = IonSecureCmaShrinkPoolStartFtraceEvent> T* set_ion_secure_cma_shrink_pool_start() {
    return BeginNestedMessage<T>(297);
  }

  template <typename T = KfreeFtraceEvent> T* set_kfree() {
    return BeginNestedMessage<T>(298);
  }

  template <typename T = KmallocFtraceEvent> T* set_kmalloc() {
    return BeginNestedMessage<T>(299);
  }

  template <typename T = KmallocNodeFtraceEvent> T* set_kmalloc_node() {
    return BeginNestedMessage<T>(300);
  }

  template <typename T = KmemCacheAllocFtraceEvent> T* set_kmem_cache_alloc() {
    return BeginNestedMessage<T>(301);
  }

  template <typename T = KmemCacheAllocNodeFtraceEvent> T* set_kmem_cache_alloc_node() {
    return BeginNestedMessage<T>(302);
  }

  template <typename T = KmemCacheFreeFtraceEvent> T* set_kmem_cache_free() {
    return BeginNestedMessage<T>(303);
  }

  template <typename T = MigratePagesEndFtraceEvent> T* set_migrate_pages_end() {
    return BeginNestedMessage<T>(304);
  }

  template <typename T = MigratePagesStartFtraceEvent> T* set_migrate_pages_start() {
    return BeginNestedMessage<T>(305);
  }

  template <typename T = MigrateRetryFtraceEvent> T* set_migrate_retry() {
    return BeginNestedMessage<T>(306);
  }

  template <typename T = MmPageAllocFtraceEvent> T* set_mm_page_alloc() {
    return BeginNestedMessage<T>(307);
  }

  template <typename T = MmPageAllocExtfragFtraceEvent> T* set_mm_page_alloc_extfrag() {
    return BeginNestedMessage<T>(308);
  }

  template <typename T = MmPageAllocZoneLockedFtraceEvent> T* set_mm_page_alloc_zone_locked() {
    return BeginNestedMessage<T>(309);
  }

  template <typename T = MmPageFreeFtraceEvent> T* set_mm_page_free() {
    return BeginNestedMessage<T>(310);
  }

  template <typename T = MmPageFreeBatchedFtraceEvent> T* set_mm_page_free_batched() {
    return BeginNestedMessage<T>(311);
  }

  template <typename T = MmPagePcpuDrainFtraceEvent> T* set_mm_page_pcpu_drain() {
    return BeginNestedMessage<T>(312);
  }

  template <typename T = RssStatFtraceEvent> T* set_rss_stat() {
    return BeginNestedMessage<T>(313);
  }

  template <typename T = IonHeapShrinkFtraceEvent> T* set_ion_heap_shrink() {
    return BeginNestedMessage<T>(314);
  }

  template <typename T = IonHeapGrowFtraceEvent> T* set_ion_heap_grow() {
    return BeginNestedMessage<T>(315);
  }

  template <typename T = FenceInitFtraceEvent> T* set_fence_init() {
    return BeginNestedMessage<T>(316);
  }

  template <typename T = FenceDestroyFtraceEvent> T* set_fence_destroy() {
    return BeginNestedMessage<T>(317);
  }

  template <typename T = FenceEnableSignalFtraceEvent> T* set_fence_enable_signal() {
    return BeginNestedMessage<T>(318);
  }

  template <typename T = FenceSignaledFtraceEvent> T* set_fence_signaled() {
    return BeginNestedMessage<T>(319);
  }

  template <typename T = ClkEnableFtraceEvent> T* set_clk_enable() {
    return BeginNestedMessage<T>(320);
  }

  template <typename T = ClkDisableFtraceEvent> T* set_clk_disable() {
    return BeginNestedMessage<T>(321);
  }

  template <typename T = ClkSetRateFtraceEvent> T* set_clk_set_rate() {
    return BeginNestedMessage<T>(322);
  }

  template <typename T = BinderTransactionAllocBufFtraceEvent> T* set_binder_transaction_alloc_buf() {
    return BeginNestedMessage<T>(323);
  }

  template <typename T = SignalDeliverFtraceEvent> T* set_signal_deliver() {
    return BeginNestedMessage<T>(324);
  }

  template <typename T = SignalGenerateFtraceEvent> T* set_signal_generate() {
    return BeginNestedMessage<T>(325);
  }

  template <typename T = OomScoreAdjUpdateFtraceEvent> T* set_oom_score_adj_update() {
    return BeginNestedMessage<T>(326);
  }

  template <typename T = GenericFtraceEvent> T* set_generic() {
    return BeginNestedMessage<T>(327);
  }

  template <typename T = MmEventRecordFtraceEvent> T* set_mm_event_record() {
    return BeginNestedMessage<T>(328);
  }

  template <typename T = SysEnterFtraceEvent> T* set_sys_enter() {
    return BeginNestedMessage<T>(329);
  }

  template <typename T = SysExitFtraceEvent> T* set_sys_exit() {
    return BeginNestedMessage<T>(330);
  }

  template <typename T = ZeroFtraceEvent> T* set_zero() {
    return BeginNestedMessage<T>(331);
  }

  template <typename T = GpuFrequencyFtraceEvent> T* set_gpu_frequency() {
    return BeginNestedMessage<T>(332);
  }

  template <typename T = GpuSchedEnqueueFtraceEvent> T* set_gpu_sched_enqueue() {
    return BeginNestedMessage<T>(333);
  }

  template <typename T = GpuSchedSubmitFtraceEvent> T* set_gpu_sched_submit() {
    return BeginNestedMessage<T>(334);
  }

  template <typename T = GpuSchedCompleteFtraceEvent> T* set_gpu_sched_complete() {
    return BeginNestedMessage<T>(335);
  }

};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/ftrace_event_bundle.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_FTRACE_EVENT_BUNDLE_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_FTRACE_EVENT_BUNDLE_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class FtraceEvent;

class FtraceEventBundle_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  FtraceEventBundle_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit FtraceEventBundle_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit FtraceEventBundle_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_cpu() const { return at<1>().valid(); }
  uint32_t cpu() const { return at<1>().as_uint32(); }
  bool has_event() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator event() const { return GetRepeated(2); }
  bool has_lost_events() const { return at<3>().valid(); }
  bool lost_events() const { return at<3>().as_bool(); }
};

class FtraceEventBundle : public ::protozero::Message {
 public:
  using Decoder = FtraceEventBundle_Decoder;
  enum : int32_t {
    kCpuFieldNumber = 1,
    kEventFieldNumber = 2,
    kLostEventsFieldNumber = 3,
  };
  void set_cpu(uint32_t value) {
    AppendVarInt(1, value);
  }
  template <typename T = FtraceEvent> T* add_event() {
    return BeginNestedMessage<T>(2);
  }

  void set_lost_events(bool value) {
    AppendTinyVarInt(3, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/ftrace_stats.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_FTRACE_STATS_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_FTRACE_STATS_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class FtraceCpuStats;
enum FtraceStats_Phase : int32_t;

enum FtraceStats_Phase : int32_t {
  FtraceStats_Phase_UNSPECIFIED = 0,
  FtraceStats_Phase_START_OF_TRACE = 1,
  FtraceStats_Phase_END_OF_TRACE = 2,
};

const FtraceStats_Phase FtraceStats_Phase_MIN = FtraceStats_Phase_UNSPECIFIED;
const FtraceStats_Phase FtraceStats_Phase_MAX = FtraceStats_Phase_END_OF_TRACE;

class FtraceStats_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  FtraceStats_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit FtraceStats_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit FtraceStats_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_phase() const { return at<1>().valid(); }
  int32_t phase() const { return at<1>().as_int32(); }
  bool has_cpu_stats() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator cpu_stats() const { return GetRepeated(2); }
};

class FtraceStats : public ::protozero::Message {
 public:
  using Decoder = FtraceStats_Decoder;
  enum : int32_t {
    kPhaseFieldNumber = 1,
    kCpuStatsFieldNumber = 2,
  };
  using Phase = ::perfetto::protos::pbzero::FtraceStats_Phase;
  static const Phase UNSPECIFIED = FtraceStats_Phase_UNSPECIFIED;
  static const Phase START_OF_TRACE = FtraceStats_Phase_START_OF_TRACE;
  static const Phase END_OF_TRACE = FtraceStats_Phase_END_OF_TRACE;
  void set_phase(::perfetto::protos::pbzero::FtraceStats_Phase value) {
    AppendTinyVarInt(1, value);
  }
  template <typename T = FtraceCpuStats> T* add_cpu_stats() {
    return BeginNestedMessage<T>(2);
  }

};

class FtraceCpuStats_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/9, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  FtraceCpuStats_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit FtraceCpuStats_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit FtraceCpuStats_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_cpu() const { return at<1>().valid(); }
  uint64_t cpu() const { return at<1>().as_uint64(); }
  bool has_entries() const { return at<2>().valid(); }
  uint64_t entries() const { return at<2>().as_uint64(); }
  bool has_overrun() const { return at<3>().valid(); }
  uint64_t overrun() const { return at<3>().as_uint64(); }
  bool has_commit_overrun() const { return at<4>().valid(); }
  uint64_t commit_overrun() const { return at<4>().as_uint64(); }
  bool has_bytes_read() const { return at<5>().valid(); }
  uint64_t bytes_read() const { return at<5>().as_uint64(); }
  bool has_oldest_event_ts() const { return at<6>().valid(); }
  double oldest_event_ts() const { return at<6>().as_double(); }
  bool has_now_ts() const { return at<7>().valid(); }
  double now_ts() const { return at<7>().as_double(); }
  bool has_dropped_events() const { return at<8>().valid(); }
  uint64_t dropped_events() const { return at<8>().as_uint64(); }
  bool has_read_events() const { return at<9>().valid(); }
  uint64_t read_events() const { return at<9>().as_uint64(); }
};

class FtraceCpuStats : public ::protozero::Message {
 public:
  using Decoder = FtraceCpuStats_Decoder;
  enum : int32_t {
    kCpuFieldNumber = 1,
    kEntriesFieldNumber = 2,
    kOverrunFieldNumber = 3,
    kCommitOverrunFieldNumber = 4,
    kBytesReadFieldNumber = 5,
    kOldestEventTsFieldNumber = 6,
    kNowTsFieldNumber = 7,
    kDroppedEventsFieldNumber = 8,
    kReadEventsFieldNumber = 9,
  };
  void set_cpu(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_entries(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_overrun(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_commit_overrun(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_bytes_read(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_oldest_event_ts(double value) {
    AppendFixed(6, value);
  }
  void set_now_ts(double value) {
    AppendFixed(7, value);
  }
  void set_dropped_events(uint64_t value) {
    AppendVarInt(8, value);
  }
  void set_read_events(uint64_t value) {
    AppendVarInt(9, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/test_bundle_wrapper.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_TEST_BUNDLE_WRAPPER_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_TEST_BUNDLE_WRAPPER_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class FtraceEventBundle;

class TestBundleWrapper_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  TestBundleWrapper_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TestBundleWrapper_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TestBundleWrapper_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_before() const { return at<1>().valid(); }
  ::protozero::ConstChars before() const { return at<1>().as_string(); }
  bool has_bundle() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator bundle() const { return GetRepeated(2); }
  bool has_after() const { return at<3>().valid(); }
  ::protozero::ConstChars after() const { return at<3>().as_string(); }
};

class TestBundleWrapper : public ::protozero::Message {
 public:
  using Decoder = TestBundleWrapper_Decoder;
  enum : int32_t {
    kBeforeFieldNumber = 1,
    kBundleFieldNumber = 2,
    kAfterFieldNumber = 3,
  };
  void set_before(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_before(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  template <typename T = FtraceEventBundle> T* add_bundle() {
    return BeginNestedMessage<T>(2);
  }

  void set_after(const char* value) {
    AppendString(3, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_after(const char* value, size_t size) {
    AppendBytes(3, value, size);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/generic.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_GENERIC_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_GENERIC_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class GenericFtraceEvent_Field;

class GenericFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  GenericFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit GenericFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit GenericFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_event_name() const { return at<1>().valid(); }
  ::protozero::ConstChars event_name() const { return at<1>().as_string(); }
  bool has_field() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator field() const { return GetRepeated(2); }
};

class GenericFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = GenericFtraceEvent_Decoder;
  enum : int32_t {
    kEventNameFieldNumber = 1,
    kFieldFieldNumber = 2,
  };
  using Field = ::perfetto::protos::pbzero::GenericFtraceEvent_Field;
  void set_event_name(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_event_name(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  template <typename T = GenericFtraceEvent_Field> T* add_field() {
    return BeginNestedMessage<T>(2);
  }

};

class GenericFtraceEvent_Field_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  GenericFtraceEvent_Field_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit GenericFtraceEvent_Field_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit GenericFtraceEvent_Field_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_str_value() const { return at<3>().valid(); }
  ::protozero::ConstChars str_value() const { return at<3>().as_string(); }
  bool has_int_value() const { return at<4>().valid(); }
  int64_t int_value() const { return at<4>().as_int64(); }
  bool has_uint_value() const { return at<5>().valid(); }
  uint64_t uint_value() const { return at<5>().as_uint64(); }
};

class GenericFtraceEvent_Field : public ::protozero::Message {
 public:
  using Decoder = GenericFtraceEvent_Field_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kStrValueFieldNumber = 3,
    kIntValueFieldNumber = 4,
    kUintValueFieldNumber = 5,
  };
  void set_name(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_name(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_str_value(const char* value) {
    AppendString(3, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_str_value(const char* value, size_t size) {
    AppendBytes(3, value, size);
  }
  void set_int_value(int64_t value) {
    AppendVarInt(4, value);
  }
  void set_uint_value(uint64_t value) {
    AppendVarInt(5, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/binder.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_BINDER_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_BINDER_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class BinderTransactionAllocBufFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BinderTransactionAllocBufFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BinderTransactionAllocBufFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BinderTransactionAllocBufFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_data_size() const { return at<1>().valid(); }
  uint64_t data_size() const { return at<1>().as_uint64(); }
  bool has_debug_id() const { return at<2>().valid(); }
  int32_t debug_id() const { return at<2>().as_int32(); }
  bool has_offsets_size() const { return at<3>().valid(); }
  uint64_t offsets_size() const { return at<3>().as_uint64(); }
};

class BinderTransactionAllocBufFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = BinderTransactionAllocBufFtraceEvent_Decoder;
  enum : int32_t {
    kDataSizeFieldNumber = 1,
    kDebugIdFieldNumber = 2,
    kOffsetsSizeFieldNumber = 3,
  };
  void set_data_size(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_debug_id(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_offsets_size(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class BinderUnlockFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BinderUnlockFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BinderUnlockFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BinderUnlockFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_tag() const { return at<1>().valid(); }
  ::protozero::ConstChars tag() const { return at<1>().as_string(); }
};

class BinderUnlockFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = BinderUnlockFtraceEvent_Decoder;
  enum : int32_t {
    kTagFieldNumber = 1,
  };
  void set_tag(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_tag(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
};

class BinderLockedFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BinderLockedFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BinderLockedFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BinderLockedFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_tag() const { return at<1>().valid(); }
  ::protozero::ConstChars tag() const { return at<1>().as_string(); }
};

class BinderLockedFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = BinderLockedFtraceEvent_Decoder;
  enum : int32_t {
    kTagFieldNumber = 1,
  };
  void set_tag(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_tag(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
};

class BinderLockFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BinderLockFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BinderLockFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BinderLockFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_tag() const { return at<1>().valid(); }
  ::protozero::ConstChars tag() const { return at<1>().as_string(); }
};

class BinderLockFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = BinderLockFtraceEvent_Decoder;
  enum : int32_t {
    kTagFieldNumber = 1,
  };
  void set_tag(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_tag(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
};

class BinderSetPriorityFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BinderSetPriorityFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BinderSetPriorityFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BinderSetPriorityFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_proc() const { return at<1>().valid(); }
  int32_t proc() const { return at<1>().as_int32(); }
  bool has_thread() const { return at<2>().valid(); }
  int32_t thread() const { return at<2>().as_int32(); }
  bool has_old_prio() const { return at<3>().valid(); }
  uint32_t old_prio() const { return at<3>().as_uint32(); }
  bool has_new_prio() const { return at<4>().valid(); }
  uint32_t new_prio() const { return at<4>().as_uint32(); }
  bool has_desired_prio() const { return at<5>().valid(); }
  uint32_t desired_prio() const { return at<5>().as_uint32(); }
};

class BinderSetPriorityFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = BinderSetPriorityFtraceEvent_Decoder;
  enum : int32_t {
    kProcFieldNumber = 1,
    kThreadFieldNumber = 2,
    kOldPrioFieldNumber = 3,
    kNewPrioFieldNumber = 4,
    kDesiredPrioFieldNumber = 5,
  };
  void set_proc(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_thread(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_old_prio(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_new_prio(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_desired_prio(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class BinderTransactionReceivedFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BinderTransactionReceivedFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BinderTransactionReceivedFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BinderTransactionReceivedFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_debug_id() const { return at<1>().valid(); }
  int32_t debug_id() const { return at<1>().as_int32(); }
};

class BinderTransactionReceivedFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = BinderTransactionReceivedFtraceEvent_Decoder;
  enum : int32_t {
    kDebugIdFieldNumber = 1,
  };
  void set_debug_id(int32_t value) {
    AppendVarInt(1, value);
  }
};

class BinderTransactionFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/7, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BinderTransactionFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BinderTransactionFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BinderTransactionFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_debug_id() const { return at<1>().valid(); }
  int32_t debug_id() const { return at<1>().as_int32(); }
  bool has_target_node() const { return at<2>().valid(); }
  int32_t target_node() const { return at<2>().as_int32(); }
  bool has_to_proc() const { return at<3>().valid(); }
  int32_t to_proc() const { return at<3>().as_int32(); }
  bool has_to_thread() const { return at<4>().valid(); }
  int32_t to_thread() const { return at<4>().as_int32(); }
  bool has_reply() const { return at<5>().valid(); }
  int32_t reply() const { return at<5>().as_int32(); }
  bool has_code() const { return at<6>().valid(); }
  uint32_t code() const { return at<6>().as_uint32(); }
  bool has_flags() const { return at<7>().valid(); }
  uint32_t flags() const { return at<7>().as_uint32(); }
};

class BinderTransactionFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = BinderTransactionFtraceEvent_Decoder;
  enum : int32_t {
    kDebugIdFieldNumber = 1,
    kTargetNodeFieldNumber = 2,
    kToProcFieldNumber = 3,
    kToThreadFieldNumber = 4,
    kReplyFieldNumber = 5,
    kCodeFieldNumber = 6,
    kFlagsFieldNumber = 7,
  };
  void set_debug_id(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_target_node(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_to_proc(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_to_thread(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_reply(int32_t value) {
    AppendVarInt(5, value);
  }
  void set_code(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(7, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/block.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_BLOCK_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_BLOCK_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class BlockUnplugFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BlockUnplugFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BlockUnplugFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BlockUnplugFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_nr_rq() const { return at<1>().valid(); }
  int32_t nr_rq() const { return at<1>().as_int32(); }
  bool has_comm() const { return at<2>().valid(); }
  ::protozero::ConstChars comm() const { return at<2>().as_string(); }
};

class BlockUnplugFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = BlockUnplugFtraceEvent_Decoder;
  enum : int32_t {
    kNrRqFieldNumber = 1,
    kCommFieldNumber = 2,
  };
  void set_nr_rq(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_comm(const char* value) {
    AppendString(2, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_comm(const char* value, size_t size) {
    AppendBytes(2, value, size);
  }
};

class BlockTouchBufferFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BlockTouchBufferFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BlockTouchBufferFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BlockTouchBufferFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_sector() const { return at<2>().valid(); }
  uint64_t sector() const { return at<2>().as_uint64(); }
  bool has_size() const { return at<3>().valid(); }
  uint64_t size() const { return at<3>().as_uint64(); }
};

class BlockTouchBufferFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = BlockTouchBufferFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kSizeFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_sector(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_size(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class BlockSplitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BlockSplitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BlockSplitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BlockSplitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_sector() const { return at<2>().valid(); }
  uint64_t sector() const { return at<2>().as_uint64(); }
  bool has_new_sector() const { return at<3>().valid(); }
  uint64_t new_sector() const { return at<3>().as_uint64(); }
  bool has_rwbs() const { return at<4>().valid(); }
  ::protozero::ConstChars rwbs() const { return at<4>().as_string(); }
  bool has_comm() const { return at<5>().valid(); }
  ::protozero::ConstChars comm() const { return at<5>().as_string(); }
};

class BlockSplitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = BlockSplitFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNewSectorFieldNumber = 3,
    kRwbsFieldNumber = 4,
    kCommFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_sector(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_new_sector(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_rwbs(const char* value) {
    AppendString(4, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_rwbs(const char* value, size_t size) {
    AppendBytes(4, value, size);
  }
  void set_comm(const char* value) {
    AppendString(5, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_comm(const char* value, size_t size) {
    AppendBytes(5, value, size);
  }
};

class BlockSleeprqFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BlockSleeprqFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BlockSleeprqFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BlockSleeprqFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_sector() const { return at<2>().valid(); }
  uint64_t sector() const { return at<2>().as_uint64(); }
  bool has_nr_sector() const { return at<3>().valid(); }
  uint32_t nr_sector() const { return at<3>().as_uint32(); }
  bool has_rwbs() const { return at<4>().valid(); }
  ::protozero::ConstChars rwbs() const { return at<4>().as_string(); }
  bool has_comm() const { return at<5>().valid(); }
  ::protozero::ConstChars comm() const { return at<5>().as_string(); }
};

class BlockSleeprqFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = BlockSleeprqFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
    kRwbsFieldNumber = 4,
    kCommFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_sector(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_nr_sector(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_rwbs(const char* value) {
    AppendString(4, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_rwbs(const char* value, size_t size) {
    AppendBytes(4, value, size);
  }
  void set_comm(const char* value) {
    AppendString(5, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_comm(const char* value, size_t size) {
    AppendBytes(5, value, size);
  }
};

class BlockRqRequeueFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BlockRqRequeueFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BlockRqRequeueFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BlockRqRequeueFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_sector() const { return at<2>().valid(); }
  uint64_t sector() const { return at<2>().as_uint64(); }
  bool has_nr_sector() const { return at<3>().valid(); }
  uint32_t nr_sector() const { return at<3>().as_uint32(); }
  bool has_errors() const { return at<4>().valid(); }
  int32_t errors() const { return at<4>().as_int32(); }
  bool has_rwbs() const { return at<5>().valid(); }
  ::protozero::ConstChars rwbs() const { return at<5>().as_string(); }
  bool has_cmd() const { return at<6>().valid(); }
  ::protozero::ConstChars cmd() const { return at<6>().as_string(); }
};

class BlockRqRequeueFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = BlockRqRequeueFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
    kErrorsFieldNumber = 4,
    kRwbsFieldNumber = 5,
    kCmdFieldNumber = 6,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_sector(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_nr_sector(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_errors(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_rwbs(const char* value) {
    AppendString(5, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_rwbs(const char* value, size_t size) {
    AppendBytes(5, value, size);
  }
  void set_cmd(const char* value) {
    AppendString(6, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_cmd(const char* value, size_t size) {
    AppendBytes(6, value, size);
  }
};

class BlockRqRemapFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/7, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BlockRqRemapFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BlockRqRemapFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BlockRqRemapFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_sector() const { return at<2>().valid(); }
  uint64_t sector() const { return at<2>().as_uint64(); }
  bool has_nr_sector() const { return at<3>().valid(); }
  uint32_t nr_sector() const { return at<3>().as_uint32(); }
  bool has_old_dev() const { return at<4>().valid(); }
  uint64_t old_dev() const { return at<4>().as_uint64(); }
  bool has_old_sector() const { return at<5>().valid(); }
  uint64_t old_sector() const { return at<5>().as_uint64(); }
  bool has_nr_bios() const { return at<6>().valid(); }
  uint32_t nr_bios() const { return at<6>().as_uint32(); }
  bool has_rwbs() const { return at<7>().valid(); }
  ::protozero::ConstChars rwbs() const { return at<7>().as_string(); }
};

class BlockRqRemapFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = BlockRqRemapFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
    kOldDevFieldNumber = 4,
    kOldSectorFieldNumber = 5,
    kNrBiosFieldNumber = 6,
    kRwbsFieldNumber = 7,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_sector(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_nr_sector(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_old_dev(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_old_sector(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_nr_bios(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_rwbs(const char* value) {
    AppendString(7, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_rwbs(const char* value, size_t size) {
    AppendBytes(7, value, size);
  }
};

class BlockRqInsertFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/7, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BlockRqInsertFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BlockRqInsertFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BlockRqInsertFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_sector() const { return at<2>().valid(); }
  uint64_t sector() const { return at<2>().as_uint64(); }
  bool has_nr_sector() const { return at<3>().valid(); }
  uint32_t nr_sector() const { return at<3>().as_uint32(); }
  bool has_bytes() const { return at<4>().valid(); }
  uint32_t bytes() const { return at<4>().as_uint32(); }
  bool has_rwbs() const { return at<5>().valid(); }
  ::protozero::ConstChars rwbs() const { return at<5>().as_string(); }
  bool has_comm() const { return at<6>().valid(); }
  ::protozero::ConstChars comm() const { return at<6>().as_string(); }
  bool has_cmd() const { return at<7>().valid(); }
  ::protozero::ConstChars cmd() const { return at<7>().as_string(); }
};

class BlockRqInsertFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = BlockRqInsertFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
    kBytesFieldNumber = 4,
    kRwbsFieldNumber = 5,
    kCommFieldNumber = 6,
    kCmdFieldNumber = 7,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_sector(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_nr_sector(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_bytes(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_rwbs(const char* value) {
    AppendString(5, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_rwbs(const char* value, size_t size) {
    AppendBytes(5, value, size);
  }
  void set_comm(const char* value) {
    AppendString(6, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_comm(const char* value, size_t size) {
    AppendBytes(6, value, size);
  }
  void set_cmd(const char* value) {
    AppendString(7, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_cmd(const char* value, size_t size) {
    AppendBytes(7, value, size);
  }
};

class BlockRqCompleteFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BlockRqCompleteFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BlockRqCompleteFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BlockRqCompleteFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_sector() const { return at<2>().valid(); }
  uint64_t sector() const { return at<2>().as_uint64(); }
  bool has_nr_sector() const { return at<3>().valid(); }
  uint32_t nr_sector() const { return at<3>().as_uint32(); }
  bool has_errors() const { return at<4>().valid(); }
  int32_t errors() const { return at<4>().as_int32(); }
  bool has_rwbs() const { return at<5>().valid(); }
  ::protozero::ConstChars rwbs() const { return at<5>().as_string(); }
  bool has_cmd() const { return at<6>().valid(); }
  ::protozero::ConstChars cmd() const { return at<6>().as_string(); }
};

class BlockRqCompleteFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = BlockRqCompleteFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
    kErrorsFieldNumber = 4,
    kRwbsFieldNumber = 5,
    kCmdFieldNumber = 6,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_sector(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_nr_sector(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_errors(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_rwbs(const char* value) {
    AppendString(5, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_rwbs(const char* value, size_t size) {
    AppendBytes(5, value, size);
  }
  void set_cmd(const char* value) {
    AppendString(6, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_cmd(const char* value, size_t size) {
    AppendBytes(6, value, size);
  }
};

class BlockRqAbortFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BlockRqAbortFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BlockRqAbortFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BlockRqAbortFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_sector() const { return at<2>().valid(); }
  uint64_t sector() const { return at<2>().as_uint64(); }
  bool has_nr_sector() const { return at<3>().valid(); }
  uint32_t nr_sector() const { return at<3>().as_uint32(); }
  bool has_errors() const { return at<4>().valid(); }
  int32_t errors() const { return at<4>().as_int32(); }
  bool has_rwbs() const { return at<5>().valid(); }
  ::protozero::ConstChars rwbs() const { return at<5>().as_string(); }
  bool has_cmd() const { return at<6>().valid(); }
  ::protozero::ConstChars cmd() const { return at<6>().as_string(); }
};

class BlockRqAbortFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = BlockRqAbortFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
    kErrorsFieldNumber = 4,
    kRwbsFieldNumber = 5,
    kCmdFieldNumber = 6,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_sector(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_nr_sector(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_errors(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_rwbs(const char* value) {
    AppendString(5, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_rwbs(const char* value, size_t size) {
    AppendBytes(5, value, size);
  }
  void set_cmd(const char* value) {
    AppendString(6, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_cmd(const char* value, size_t size) {
    AppendBytes(6, value, size);
  }
};

class BlockPlugFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BlockPlugFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BlockPlugFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BlockPlugFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_comm() const { return at<1>().valid(); }
  ::protozero::ConstChars comm() const { return at<1>().as_string(); }
};

class BlockPlugFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = BlockPlugFtraceEvent_Decoder;
  enum : int32_t {
    kCommFieldNumber = 1,
  };
  void set_comm(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_comm(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
};

class BlockGetrqFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BlockGetrqFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BlockGetrqFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BlockGetrqFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_sector() const { return at<2>().valid(); }
  uint64_t sector() const { return at<2>().as_uint64(); }
  bool has_nr_sector() const { return at<3>().valid(); }
  uint32_t nr_sector() const { return at<3>().as_uint32(); }
  bool has_rwbs() const { return at<4>().valid(); }
  ::protozero::ConstChars rwbs() const { return at<4>().as_string(); }
  bool has_comm() const { return at<5>().valid(); }
  ::protozero::ConstChars comm() const { return at<5>().as_string(); }
};

class BlockGetrqFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = BlockGetrqFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
    kRwbsFieldNumber = 4,
    kCommFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_sector(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_nr_sector(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_rwbs(const char* value) {
    AppendString(4, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_rwbs(const char* value, size_t size) {
    AppendBytes(4, value, size);
  }
  void set_comm(const char* value) {
    AppendString(5, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_comm(const char* value, size_t size) {
    AppendBytes(5, value, size);
  }
};

class BlockDirtyBufferFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BlockDirtyBufferFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BlockDirtyBufferFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BlockDirtyBufferFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_sector() const { return at<2>().valid(); }
  uint64_t sector() const { return at<2>().as_uint64(); }
  bool has_size() const { return at<3>().valid(); }
  uint64_t size() const { return at<3>().as_uint64(); }
};

class BlockDirtyBufferFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = BlockDirtyBufferFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kSizeFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_sector(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_size(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class BlockBioRemapFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BlockBioRemapFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BlockBioRemapFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BlockBioRemapFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_sector() const { return at<2>().valid(); }
  uint64_t sector() const { return at<2>().as_uint64(); }
  bool has_nr_sector() const { return at<3>().valid(); }
  uint32_t nr_sector() const { return at<3>().as_uint32(); }
  bool has_old_dev() const { return at<4>().valid(); }
  uint64_t old_dev() const { return at<4>().as_uint64(); }
  bool has_old_sector() const { return at<5>().valid(); }
  uint64_t old_sector() const { return at<5>().as_uint64(); }
  bool has_rwbs() const { return at<6>().valid(); }
  ::protozero::ConstChars rwbs() const { return at<6>().as_string(); }
};

class BlockBioRemapFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = BlockBioRemapFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
    kOldDevFieldNumber = 4,
    kOldSectorFieldNumber = 5,
    kRwbsFieldNumber = 6,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_sector(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_nr_sector(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_old_dev(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_old_sector(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_rwbs(const char* value) {
    AppendString(6, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_rwbs(const char* value, size_t size) {
    AppendBytes(6, value, size);
  }
};

class BlockBioQueueFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BlockBioQueueFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BlockBioQueueFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BlockBioQueueFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_sector() const { return at<2>().valid(); }
  uint64_t sector() const { return at<2>().as_uint64(); }
  bool has_nr_sector() const { return at<3>().valid(); }
  uint32_t nr_sector() const { return at<3>().as_uint32(); }
  bool has_rwbs() const { return at<4>().valid(); }
  ::protozero::ConstChars rwbs() const { return at<4>().as_string(); }
  bool has_comm() const { return at<5>().valid(); }
  ::protozero::ConstChars comm() const { return at<5>().as_string(); }
};

class BlockBioQueueFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = BlockBioQueueFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
    kRwbsFieldNumber = 4,
    kCommFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_sector(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_nr_sector(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_rwbs(const char* value) {
    AppendString(4, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_rwbs(const char* value, size_t size) {
    AppendBytes(4, value, size);
  }
  void set_comm(const char* value) {
    AppendString(5, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_comm(const char* value, size_t size) {
    AppendBytes(5, value, size);
  }
};

class BlockBioFrontmergeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BlockBioFrontmergeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BlockBioFrontmergeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BlockBioFrontmergeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_sector() const { return at<2>().valid(); }
  uint64_t sector() const { return at<2>().as_uint64(); }
  bool has_nr_sector() const { return at<3>().valid(); }
  uint32_t nr_sector() const { return at<3>().as_uint32(); }
  bool has_rwbs() const { return at<4>().valid(); }
  ::protozero::ConstChars rwbs() const { return at<4>().as_string(); }
  bool has_comm() const { return at<5>().valid(); }
  ::protozero::ConstChars comm() const { return at<5>().as_string(); }
};

class BlockBioFrontmergeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = BlockBioFrontmergeFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
    kRwbsFieldNumber = 4,
    kCommFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_sector(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_nr_sector(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_rwbs(const char* value) {
    AppendString(4, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_rwbs(const char* value, size_t size) {
    AppendBytes(4, value, size);
  }
  void set_comm(const char* value) {
    AppendString(5, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_comm(const char* value, size_t size) {
    AppendBytes(5, value, size);
  }
};

class BlockBioCompleteFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BlockBioCompleteFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BlockBioCompleteFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BlockBioCompleteFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_sector() const { return at<2>().valid(); }
  uint64_t sector() const { return at<2>().as_uint64(); }
  bool has_nr_sector() const { return at<3>().valid(); }
  uint32_t nr_sector() const { return at<3>().as_uint32(); }
  bool has_error() const { return at<4>().valid(); }
  int32_t error() const { return at<4>().as_int32(); }
  bool has_rwbs() const { return at<5>().valid(); }
  ::protozero::ConstChars rwbs() const { return at<5>().as_string(); }
};

class BlockBioCompleteFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = BlockBioCompleteFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
    kErrorFieldNumber = 4,
    kRwbsFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_sector(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_nr_sector(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_error(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_rwbs(const char* value) {
    AppendString(5, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_rwbs(const char* value, size_t size) {
    AppendBytes(5, value, size);
  }
};

class BlockBioBounceFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BlockBioBounceFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BlockBioBounceFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BlockBioBounceFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_sector() const { return at<2>().valid(); }
  uint64_t sector() const { return at<2>().as_uint64(); }
  bool has_nr_sector() const { return at<3>().valid(); }
  uint32_t nr_sector() const { return at<3>().as_uint32(); }
  bool has_rwbs() const { return at<4>().valid(); }
  ::protozero::ConstChars rwbs() const { return at<4>().as_string(); }
  bool has_comm() const { return at<5>().valid(); }
  ::protozero::ConstChars comm() const { return at<5>().as_string(); }
};

class BlockBioBounceFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = BlockBioBounceFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
    kRwbsFieldNumber = 4,
    kCommFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_sector(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_nr_sector(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_rwbs(const char* value) {
    AppendString(4, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_rwbs(const char* value, size_t size) {
    AppendBytes(4, value, size);
  }
  void set_comm(const char* value) {
    AppendString(5, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_comm(const char* value, size_t size) {
    AppendBytes(5, value, size);
  }
};

class BlockBioBackmergeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BlockBioBackmergeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BlockBioBackmergeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BlockBioBackmergeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_sector() const { return at<2>().valid(); }
  uint64_t sector() const { return at<2>().as_uint64(); }
  bool has_nr_sector() const { return at<3>().valid(); }
  uint32_t nr_sector() const { return at<3>().as_uint32(); }
  bool has_rwbs() const { return at<4>().valid(); }
  ::protozero::ConstChars rwbs() const { return at<4>().as_string(); }
  bool has_comm() const { return at<5>().valid(); }
  ::protozero::ConstChars comm() const { return at<5>().as_string(); }
};

class BlockBioBackmergeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = BlockBioBackmergeFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
    kRwbsFieldNumber = 4,
    kCommFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_sector(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_nr_sector(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_rwbs(const char* value) {
    AppendString(4, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_rwbs(const char* value, size_t size) {
    AppendBytes(4, value, size);
  }
  void set_comm(const char* value) {
    AppendString(5, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_comm(const char* value, size_t size) {
    AppendBytes(5, value, size);
  }
};

class BlockRqIssueFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/7, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BlockRqIssueFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BlockRqIssueFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BlockRqIssueFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_sector() const { return at<2>().valid(); }
  uint64_t sector() const { return at<2>().as_uint64(); }
  bool has_nr_sector() const { return at<3>().valid(); }
  uint32_t nr_sector() const { return at<3>().as_uint32(); }
  bool has_bytes() const { return at<4>().valid(); }
  uint32_t bytes() const { return at<4>().as_uint32(); }
  bool has_rwbs() const { return at<5>().valid(); }
  ::protozero::ConstChars rwbs() const { return at<5>().as_string(); }
  bool has_comm() const { return at<6>().valid(); }
  ::protozero::ConstChars comm() const { return at<6>().as_string(); }
  bool has_cmd() const { return at<7>().valid(); }
  ::protozero::ConstChars cmd() const { return at<7>().as_string(); }
};

class BlockRqIssueFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = BlockRqIssueFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kSectorFieldNumber = 2,
    kNrSectorFieldNumber = 3,
    kBytesFieldNumber = 4,
    kRwbsFieldNumber = 5,
    kCommFieldNumber = 6,
    kCmdFieldNumber = 7,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_sector(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_nr_sector(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_bytes(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_rwbs(const char* value) {
    AppendString(5, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_rwbs(const char* value, size_t size) {
    AppendBytes(5, value, size);
  }
  void set_comm(const char* value) {
    AppendString(6, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_comm(const char* value, size_t size) {
    AppendBytes(6, value, size);
  }
  void set_cmd(const char* value) {
    AppendString(7, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_cmd(const char* value, size_t size) {
    AppendBytes(7, value, size);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/cgroup.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_CGROUP_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_CGROUP_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class CgroupSetupRootFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  CgroupSetupRootFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit CgroupSetupRootFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit CgroupSetupRootFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_root() const { return at<1>().valid(); }
  int32_t root() const { return at<1>().as_int32(); }
  bool has_ss_mask() const { return at<2>().valid(); }
  uint32_t ss_mask() const { return at<2>().as_uint32(); }
  bool has_name() const { return at<3>().valid(); }
  ::protozero::ConstChars name() const { return at<3>().as_string(); }
};

class CgroupSetupRootFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = CgroupSetupRootFtraceEvent_Decoder;
  enum : int32_t {
    kRootFieldNumber = 1,
    kSsMaskFieldNumber = 2,
    kNameFieldNumber = 3,
  };
  void set_root(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_ss_mask(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_name(const char* value) {
    AppendString(3, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_name(const char* value, size_t size) {
    AppendBytes(3, value, size);
  }
};

class CgroupRenameFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  CgroupRenameFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit CgroupRenameFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit CgroupRenameFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_root() const { return at<1>().valid(); }
  int32_t root() const { return at<1>().as_int32(); }
  bool has_id() const { return at<2>().valid(); }
  int32_t id() const { return at<2>().as_int32(); }
  bool has_cname() const { return at<3>().valid(); }
  ::protozero::ConstChars cname() const { return at<3>().as_string(); }
};

class CgroupRenameFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = CgroupRenameFtraceEvent_Decoder;
  enum : int32_t {
    kRootFieldNumber = 1,
    kIdFieldNumber = 2,
    kCnameFieldNumber = 3,
  };
  void set_root(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_id(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_cname(const char* value) {
    AppendString(3, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_cname(const char* value, size_t size) {
    AppendBytes(3, value, size);
  }
};

class CgroupReleaseFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  CgroupReleaseFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit CgroupReleaseFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit CgroupReleaseFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_root() const { return at<1>().valid(); }
  int32_t root() const { return at<1>().as_int32(); }
  bool has_id() const { return at<2>().valid(); }
  int32_t id() const { return at<2>().as_int32(); }
  bool has_cname() const { return at<3>().valid(); }
  ::protozero::ConstChars cname() const { return at<3>().as_string(); }
};

class CgroupReleaseFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = CgroupReleaseFtraceEvent_Decoder;
  enum : int32_t {
    kRootFieldNumber = 1,
    kIdFieldNumber = 2,
    kCnameFieldNumber = 3,
  };
  void set_root(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_id(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_cname(const char* value) {
    AppendString(3, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_cname(const char* value, size_t size) {
    AppendBytes(3, value, size);
  }
};

class CgroupDestroyRootFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  CgroupDestroyRootFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit CgroupDestroyRootFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit CgroupDestroyRootFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_root() const { return at<1>().valid(); }
  int32_t root() const { return at<1>().as_int32(); }
  bool has_ss_mask() const { return at<2>().valid(); }
  uint32_t ss_mask() const { return at<2>().as_uint32(); }
  bool has_name() const { return at<3>().valid(); }
  ::protozero::ConstChars name() const { return at<3>().as_string(); }
};

class CgroupDestroyRootFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = CgroupDestroyRootFtraceEvent_Decoder;
  enum : int32_t {
    kRootFieldNumber = 1,
    kSsMaskFieldNumber = 2,
    kNameFieldNumber = 3,
  };
  void set_root(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_ss_mask(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_name(const char* value) {
    AppendString(3, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_name(const char* value, size_t size) {
    AppendBytes(3, value, size);
  }
};

class CgroupTransferTasksFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  CgroupTransferTasksFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit CgroupTransferTasksFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit CgroupTransferTasksFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dst_root() const { return at<1>().valid(); }
  int32_t dst_root() const { return at<1>().as_int32(); }
  bool has_dst_id() const { return at<2>().valid(); }
  int32_t dst_id() const { return at<2>().as_int32(); }
  bool has_pid() const { return at<3>().valid(); }
  int32_t pid() const { return at<3>().as_int32(); }
  bool has_comm() const { return at<4>().valid(); }
  ::protozero::ConstChars comm() const { return at<4>().as_string(); }
  bool has_cname() const { return at<5>().valid(); }
  ::protozero::ConstChars cname() const { return at<5>().as_string(); }
};

class CgroupTransferTasksFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = CgroupTransferTasksFtraceEvent_Decoder;
  enum : int32_t {
    kDstRootFieldNumber = 1,
    kDstIdFieldNumber = 2,
    kPidFieldNumber = 3,
    kCommFieldNumber = 4,
    kCnameFieldNumber = 5,
  };
  void set_dst_root(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_dst_id(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_pid(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_comm(const char* value) {
    AppendString(4, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_comm(const char* value, size_t size) {
    AppendBytes(4, value, size);
  }
  void set_cname(const char* value) {
    AppendString(5, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_cname(const char* value, size_t size) {
    AppendBytes(5, value, size);
  }
};

class CgroupRmdirFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  CgroupRmdirFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit CgroupRmdirFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit CgroupRmdirFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_root() const { return at<1>().valid(); }
  int32_t root() const { return at<1>().as_int32(); }
  bool has_id() const { return at<2>().valid(); }
  int32_t id() const { return at<2>().as_int32(); }
  bool has_cname() const { return at<3>().valid(); }
  ::protozero::ConstChars cname() const { return at<3>().as_string(); }
};

class CgroupRmdirFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = CgroupRmdirFtraceEvent_Decoder;
  enum : int32_t {
    kRootFieldNumber = 1,
    kIdFieldNumber = 2,
    kCnameFieldNumber = 3,
  };
  void set_root(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_id(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_cname(const char* value) {
    AppendString(3, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_cname(const char* value, size_t size) {
    AppendBytes(3, value, size);
  }
};

class CgroupRemountFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  CgroupRemountFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit CgroupRemountFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit CgroupRemountFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_root() const { return at<1>().valid(); }
  int32_t root() const { return at<1>().as_int32(); }
  bool has_ss_mask() const { return at<2>().valid(); }
  uint32_t ss_mask() const { return at<2>().as_uint32(); }
  bool has_name() const { return at<3>().valid(); }
  ::protozero::ConstChars name() const { return at<3>().as_string(); }
};

class CgroupRemountFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = CgroupRemountFtraceEvent_Decoder;
  enum : int32_t {
    kRootFieldNumber = 1,
    kSsMaskFieldNumber = 2,
    kNameFieldNumber = 3,
  };
  void set_root(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_ss_mask(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_name(const char* value) {
    AppendString(3, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_name(const char* value, size_t size) {
    AppendBytes(3, value, size);
  }
};

class CgroupMkdirFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  CgroupMkdirFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit CgroupMkdirFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit CgroupMkdirFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_root() const { return at<1>().valid(); }
  int32_t root() const { return at<1>().as_int32(); }
  bool has_id() const { return at<2>().valid(); }
  int32_t id() const { return at<2>().as_int32(); }
  bool has_cname() const { return at<3>().valid(); }
  ::protozero::ConstChars cname() const { return at<3>().as_string(); }
};

class CgroupMkdirFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = CgroupMkdirFtraceEvent_Decoder;
  enum : int32_t {
    kRootFieldNumber = 1,
    kIdFieldNumber = 2,
    kCnameFieldNumber = 3,
  };
  void set_root(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_id(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_cname(const char* value) {
    AppendString(3, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_cname(const char* value, size_t size) {
    AppendBytes(3, value, size);
  }
};

class CgroupAttachTaskFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  CgroupAttachTaskFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit CgroupAttachTaskFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit CgroupAttachTaskFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dst_root() const { return at<1>().valid(); }
  int32_t dst_root() const { return at<1>().as_int32(); }
  bool has_dst_id() const { return at<2>().valid(); }
  int32_t dst_id() const { return at<2>().as_int32(); }
  bool has_pid() const { return at<3>().valid(); }
  int32_t pid() const { return at<3>().as_int32(); }
  bool has_comm() const { return at<4>().valid(); }
  ::protozero::ConstChars comm() const { return at<4>().as_string(); }
  bool has_cname() const { return at<5>().valid(); }
  ::protozero::ConstChars cname() const { return at<5>().as_string(); }
};

class CgroupAttachTaskFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = CgroupAttachTaskFtraceEvent_Decoder;
  enum : int32_t {
    kDstRootFieldNumber = 1,
    kDstIdFieldNumber = 2,
    kPidFieldNumber = 3,
    kCommFieldNumber = 4,
    kCnameFieldNumber = 5,
  };
  void set_dst_root(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_dst_id(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_pid(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_comm(const char* value) {
    AppendString(4, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_comm(const char* value, size_t size) {
    AppendBytes(4, value, size);
  }
  void set_cname(const char* value) {
    AppendString(5, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_cname(const char* value, size_t size) {
    AppendBytes(5, value, size);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/clk.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_CLK_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_CLK_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class ClkSetRateFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ClkSetRateFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ClkSetRateFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ClkSetRateFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_rate() const { return at<2>().valid(); }
  uint64_t rate() const { return at<2>().as_uint64(); }
};

class ClkSetRateFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = ClkSetRateFtraceEvent_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kRateFieldNumber = 2,
  };
  void set_name(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_name(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_rate(uint64_t value) {
    AppendVarInt(2, value);
  }
};

class ClkDisableFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ClkDisableFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ClkDisableFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ClkDisableFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
};

class ClkDisableFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = ClkDisableFtraceEvent_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
  };
  void set_name(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_name(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
};

class ClkEnableFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ClkEnableFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ClkEnableFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ClkEnableFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
};

class ClkEnableFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = ClkEnableFtraceEvent_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
  };
  void set_name(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_name(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/compaction.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_COMPACTION_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_COMPACTION_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class MmCompactionWakeupKcompactdFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmCompactionWakeupKcompactdFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmCompactionWakeupKcompactdFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmCompactionWakeupKcompactdFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_nid() const { return at<1>().valid(); }
  int32_t nid() const { return at<1>().as_int32(); }
  bool has_order() const { return at<2>().valid(); }
  int32_t order() const { return at<2>().as_int32(); }
  bool has_classzone_idx() const { return at<3>().valid(); }
  uint32_t classzone_idx() const { return at<3>().as_uint32(); }
};

class MmCompactionWakeupKcompactdFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmCompactionWakeupKcompactdFtraceEvent_Decoder;
  enum : int32_t {
    kNidFieldNumber = 1,
    kOrderFieldNumber = 2,
    kClasszoneIdxFieldNumber = 3,
  };
  void set_nid(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_order(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_classzone_idx(uint32_t value) {
    AppendVarInt(3, value);
  }
};

class MmCompactionTryToCompactPagesFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmCompactionTryToCompactPagesFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmCompactionTryToCompactPagesFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmCompactionTryToCompactPagesFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_order() const { return at<1>().valid(); }
  int32_t order() const { return at<1>().as_int32(); }
  bool has_gfp_mask() const { return at<2>().valid(); }
  uint32_t gfp_mask() const { return at<2>().as_uint32(); }
  bool has_mode() const { return at<3>().valid(); }
  uint32_t mode() const { return at<3>().as_uint32(); }
};

class MmCompactionTryToCompactPagesFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmCompactionTryToCompactPagesFtraceEvent_Decoder;
  enum : int32_t {
    kOrderFieldNumber = 1,
    kGfpMaskFieldNumber = 2,
    kModeFieldNumber = 3,
  };
  void set_order(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_gfp_mask(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_mode(uint32_t value) {
    AppendVarInt(3, value);
  }
};

class MmCompactionSuitableFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmCompactionSuitableFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmCompactionSuitableFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmCompactionSuitableFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_nid() const { return at<1>().valid(); }
  int32_t nid() const { return at<1>().as_int32(); }
  bool has_idx() const { return at<2>().valid(); }
  uint32_t idx() const { return at<2>().as_uint32(); }
  bool has_order() const { return at<3>().valid(); }
  int32_t order() const { return at<3>().as_int32(); }
  bool has_ret() const { return at<4>().valid(); }
  int32_t ret() const { return at<4>().as_int32(); }
};

class MmCompactionSuitableFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmCompactionSuitableFtraceEvent_Decoder;
  enum : int32_t {
    kNidFieldNumber = 1,
    kIdxFieldNumber = 2,
    kOrderFieldNumber = 3,
    kRetFieldNumber = 4,
  };
  void set_nid(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_idx(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_order(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(4, value);
  }
};

class MmCompactionMigratepagesFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmCompactionMigratepagesFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmCompactionMigratepagesFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmCompactionMigratepagesFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_nr_migrated() const { return at<1>().valid(); }
  uint64_t nr_migrated() const { return at<1>().as_uint64(); }
  bool has_nr_failed() const { return at<2>().valid(); }
  uint64_t nr_failed() const { return at<2>().as_uint64(); }
};

class MmCompactionMigratepagesFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmCompactionMigratepagesFtraceEvent_Decoder;
  enum : int32_t {
    kNrMigratedFieldNumber = 1,
    kNrFailedFieldNumber = 2,
  };
  void set_nr_migrated(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_nr_failed(uint64_t value) {
    AppendVarInt(2, value);
  }
};

class MmCompactionKcompactdWakeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmCompactionKcompactdWakeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmCompactionKcompactdWakeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmCompactionKcompactdWakeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_nid() const { return at<1>().valid(); }
  int32_t nid() const { return at<1>().as_int32(); }
  bool has_order() const { return at<2>().valid(); }
  int32_t order() const { return at<2>().as_int32(); }
  bool has_classzone_idx() const { return at<3>().valid(); }
  uint32_t classzone_idx() const { return at<3>().as_uint32(); }
};

class MmCompactionKcompactdWakeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmCompactionKcompactdWakeFtraceEvent_Decoder;
  enum : int32_t {
    kNidFieldNumber = 1,
    kOrderFieldNumber = 2,
    kClasszoneIdxFieldNumber = 3,
  };
  void set_nid(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_order(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_classzone_idx(uint32_t value) {
    AppendVarInt(3, value);
  }
};

class MmCompactionKcompactdSleepFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmCompactionKcompactdSleepFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmCompactionKcompactdSleepFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmCompactionKcompactdSleepFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_nid() const { return at<1>().valid(); }
  int32_t nid() const { return at<1>().as_int32(); }
};

class MmCompactionKcompactdSleepFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmCompactionKcompactdSleepFtraceEvent_Decoder;
  enum : int32_t {
    kNidFieldNumber = 1,
  };
  void set_nid(int32_t value) {
    AppendVarInt(1, value);
  }
};

class MmCompactionIsolateMigratepagesFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmCompactionIsolateMigratepagesFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmCompactionIsolateMigratepagesFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmCompactionIsolateMigratepagesFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_start_pfn() const { return at<1>().valid(); }
  uint64_t start_pfn() const { return at<1>().as_uint64(); }
  bool has_end_pfn() const { return at<2>().valid(); }
  uint64_t end_pfn() const { return at<2>().as_uint64(); }
  bool has_nr_scanned() const { return at<3>().valid(); }
  uint64_t nr_scanned() const { return at<3>().as_uint64(); }
  bool has_nr_taken() const { return at<4>().valid(); }
  uint64_t nr_taken() const { return at<4>().as_uint64(); }
};

class MmCompactionIsolateMigratepagesFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmCompactionIsolateMigratepagesFtraceEvent_Decoder;
  enum : int32_t {
    kStartPfnFieldNumber = 1,
    kEndPfnFieldNumber = 2,
    kNrScannedFieldNumber = 3,
    kNrTakenFieldNumber = 4,
  };
  void set_start_pfn(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_end_pfn(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_nr_scanned(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_nr_taken(uint64_t value) {
    AppendVarInt(4, value);
  }
};

class MmCompactionIsolateFreepagesFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmCompactionIsolateFreepagesFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmCompactionIsolateFreepagesFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmCompactionIsolateFreepagesFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_start_pfn() const { return at<1>().valid(); }
  uint64_t start_pfn() const { return at<1>().as_uint64(); }
  bool has_end_pfn() const { return at<2>().valid(); }
  uint64_t end_pfn() const { return at<2>().as_uint64(); }
  bool has_nr_scanned() const { return at<3>().valid(); }
  uint64_t nr_scanned() const { return at<3>().as_uint64(); }
  bool has_nr_taken() const { return at<4>().valid(); }
  uint64_t nr_taken() const { return at<4>().as_uint64(); }
};

class MmCompactionIsolateFreepagesFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmCompactionIsolateFreepagesFtraceEvent_Decoder;
  enum : int32_t {
    kStartPfnFieldNumber = 1,
    kEndPfnFieldNumber = 2,
    kNrScannedFieldNumber = 3,
    kNrTakenFieldNumber = 4,
  };
  void set_start_pfn(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_end_pfn(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_nr_scanned(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_nr_taken(uint64_t value) {
    AppendVarInt(4, value);
  }
};

class MmCompactionFinishedFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmCompactionFinishedFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmCompactionFinishedFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmCompactionFinishedFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_nid() const { return at<1>().valid(); }
  int32_t nid() const { return at<1>().as_int32(); }
  bool has_idx() const { return at<2>().valid(); }
  uint32_t idx() const { return at<2>().as_uint32(); }
  bool has_order() const { return at<3>().valid(); }
  int32_t order() const { return at<3>().as_int32(); }
  bool has_ret() const { return at<4>().valid(); }
  int32_t ret() const { return at<4>().as_int32(); }
};

class MmCompactionFinishedFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmCompactionFinishedFtraceEvent_Decoder;
  enum : int32_t {
    kNidFieldNumber = 1,
    kIdxFieldNumber = 2,
    kOrderFieldNumber = 3,
    kRetFieldNumber = 4,
  };
  void set_nid(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_idx(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_order(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(4, value);
  }
};

class MmCompactionEndFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmCompactionEndFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmCompactionEndFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmCompactionEndFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_zone_start() const { return at<1>().valid(); }
  uint64_t zone_start() const { return at<1>().as_uint64(); }
  bool has_migrate_pfn() const { return at<2>().valid(); }
  uint64_t migrate_pfn() const { return at<2>().as_uint64(); }
  bool has_free_pfn() const { return at<3>().valid(); }
  uint64_t free_pfn() const { return at<3>().as_uint64(); }
  bool has_zone_end() const { return at<4>().valid(); }
  uint64_t zone_end() const { return at<4>().as_uint64(); }
  bool has_sync() const { return at<5>().valid(); }
  uint32_t sync() const { return at<5>().as_uint32(); }
  bool has_status() const { return at<6>().valid(); }
  int32_t status() const { return at<6>().as_int32(); }
};

class MmCompactionEndFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmCompactionEndFtraceEvent_Decoder;
  enum : int32_t {
    kZoneStartFieldNumber = 1,
    kMigratePfnFieldNumber = 2,
    kFreePfnFieldNumber = 3,
    kZoneEndFieldNumber = 4,
    kSyncFieldNumber = 5,
    kStatusFieldNumber = 6,
  };
  void set_zone_start(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_migrate_pfn(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_free_pfn(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_zone_end(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_sync(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_status(int32_t value) {
    AppendVarInt(6, value);
  }
};

class MmCompactionDeferResetFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmCompactionDeferResetFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmCompactionDeferResetFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmCompactionDeferResetFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_nid() const { return at<1>().valid(); }
  int32_t nid() const { return at<1>().as_int32(); }
  bool has_idx() const { return at<2>().valid(); }
  uint32_t idx() const { return at<2>().as_uint32(); }
  bool has_order() const { return at<3>().valid(); }
  int32_t order() const { return at<3>().as_int32(); }
  bool has_considered() const { return at<4>().valid(); }
  uint32_t considered() const { return at<4>().as_uint32(); }
  bool has_defer_shift() const { return at<5>().valid(); }
  uint32_t defer_shift() const { return at<5>().as_uint32(); }
  bool has_order_failed() const { return at<6>().valid(); }
  int32_t order_failed() const { return at<6>().as_int32(); }
};

class MmCompactionDeferResetFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmCompactionDeferResetFtraceEvent_Decoder;
  enum : int32_t {
    kNidFieldNumber = 1,
    kIdxFieldNumber = 2,
    kOrderFieldNumber = 3,
    kConsideredFieldNumber = 4,
    kDeferShiftFieldNumber = 5,
    kOrderFailedFieldNumber = 6,
  };
  void set_nid(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_idx(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_order(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_considered(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_defer_shift(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_order_failed(int32_t value) {
    AppendVarInt(6, value);
  }
};

class MmCompactionDeferredFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmCompactionDeferredFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmCompactionDeferredFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmCompactionDeferredFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_nid() const { return at<1>().valid(); }
  int32_t nid() const { return at<1>().as_int32(); }
  bool has_idx() const { return at<2>().valid(); }
  uint32_t idx() const { return at<2>().as_uint32(); }
  bool has_order() const { return at<3>().valid(); }
  int32_t order() const { return at<3>().as_int32(); }
  bool has_considered() const { return at<4>().valid(); }
  uint32_t considered() const { return at<4>().as_uint32(); }
  bool has_defer_shift() const { return at<5>().valid(); }
  uint32_t defer_shift() const { return at<5>().as_uint32(); }
  bool has_order_failed() const { return at<6>().valid(); }
  int32_t order_failed() const { return at<6>().as_int32(); }
};

class MmCompactionDeferredFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmCompactionDeferredFtraceEvent_Decoder;
  enum : int32_t {
    kNidFieldNumber = 1,
    kIdxFieldNumber = 2,
    kOrderFieldNumber = 3,
    kConsideredFieldNumber = 4,
    kDeferShiftFieldNumber = 5,
    kOrderFailedFieldNumber = 6,
  };
  void set_nid(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_idx(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_order(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_considered(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_defer_shift(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_order_failed(int32_t value) {
    AppendVarInt(6, value);
  }
};

class MmCompactionDeferCompactionFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmCompactionDeferCompactionFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmCompactionDeferCompactionFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmCompactionDeferCompactionFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_nid() const { return at<1>().valid(); }
  int32_t nid() const { return at<1>().as_int32(); }
  bool has_idx() const { return at<2>().valid(); }
  uint32_t idx() const { return at<2>().as_uint32(); }
  bool has_order() const { return at<3>().valid(); }
  int32_t order() const { return at<3>().as_int32(); }
  bool has_considered() const { return at<4>().valid(); }
  uint32_t considered() const { return at<4>().as_uint32(); }
  bool has_defer_shift() const { return at<5>().valid(); }
  uint32_t defer_shift() const { return at<5>().as_uint32(); }
  bool has_order_failed() const { return at<6>().valid(); }
  int32_t order_failed() const { return at<6>().as_int32(); }
};

class MmCompactionDeferCompactionFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmCompactionDeferCompactionFtraceEvent_Decoder;
  enum : int32_t {
    kNidFieldNumber = 1,
    kIdxFieldNumber = 2,
    kOrderFieldNumber = 3,
    kConsideredFieldNumber = 4,
    kDeferShiftFieldNumber = 5,
    kOrderFailedFieldNumber = 6,
  };
  void set_nid(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_idx(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_order(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_considered(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_defer_shift(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_order_failed(int32_t value) {
    AppendVarInt(6, value);
  }
};

class MmCompactionBeginFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmCompactionBeginFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmCompactionBeginFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmCompactionBeginFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_zone_start() const { return at<1>().valid(); }
  uint64_t zone_start() const { return at<1>().as_uint64(); }
  bool has_migrate_pfn() const { return at<2>().valid(); }
  uint64_t migrate_pfn() const { return at<2>().as_uint64(); }
  bool has_free_pfn() const { return at<3>().valid(); }
  uint64_t free_pfn() const { return at<3>().as_uint64(); }
  bool has_zone_end() const { return at<4>().valid(); }
  uint64_t zone_end() const { return at<4>().as_uint64(); }
  bool has_sync() const { return at<5>().valid(); }
  uint32_t sync() const { return at<5>().as_uint32(); }
};

class MmCompactionBeginFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmCompactionBeginFtraceEvent_Decoder;
  enum : int32_t {
    kZoneStartFieldNumber = 1,
    kMigratePfnFieldNumber = 2,
    kFreePfnFieldNumber = 3,
    kZoneEndFieldNumber = 4,
    kSyncFieldNumber = 5,
  };
  void set_zone_start(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_migrate_pfn(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_free_pfn(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_zone_end(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_sync(uint32_t value) {
    AppendVarInt(5, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/ext4.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_EXT4_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_EXT4_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class Ext4ZeroRangeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ZeroRangeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ZeroRangeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ZeroRangeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_offset() const { return at<3>().valid(); }
  int64_t offset() const { return at<3>().as_int64(); }
  bool has_len() const { return at<4>().valid(); }
  int64_t len() const { return at<4>().as_int64(); }
  bool has_mode() const { return at<5>().valid(); }
  int32_t mode() const { return at<5>().as_int32(); }
};

class Ext4ZeroRangeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ZeroRangeFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kOffsetFieldNumber = 3,
    kLenFieldNumber = 4,
    kModeFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_offset(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_len(int64_t value) {
    AppendVarInt(4, value);
  }
  void set_mode(int32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4WritepagesResultFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/7, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4WritepagesResultFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4WritepagesResultFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4WritepagesResultFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_ret() const { return at<3>().valid(); }
  int32_t ret() const { return at<3>().as_int32(); }
  bool has_pages_written() const { return at<4>().valid(); }
  int32_t pages_written() const { return at<4>().as_int32(); }
  bool has_pages_skipped() const { return at<5>().valid(); }
  int64_t pages_skipped() const { return at<5>().as_int64(); }
  bool has_writeback_index() const { return at<6>().valid(); }
  uint64_t writeback_index() const { return at<6>().as_uint64(); }
  bool has_sync_mode() const { return at<7>().valid(); }
  int32_t sync_mode() const { return at<7>().as_int32(); }
};

class Ext4WritepagesResultFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4WritepagesResultFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kRetFieldNumber = 3,
    kPagesWrittenFieldNumber = 4,
    kPagesSkippedFieldNumber = 5,
    kWritebackIndexFieldNumber = 6,
    kSyncModeFieldNumber = 7,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_pages_written(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_pages_skipped(int64_t value) {
    AppendVarInt(5, value);
  }
  void set_writeback_index(uint64_t value) {
    AppendVarInt(6, value);
  }
  void set_sync_mode(int32_t value) {
    AppendVarInt(7, value);
  }
};

class Ext4WritepagesFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/10, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4WritepagesFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4WritepagesFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4WritepagesFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_nr_to_write() const { return at<3>().valid(); }
  int64_t nr_to_write() const { return at<3>().as_int64(); }
  bool has_pages_skipped() const { return at<4>().valid(); }
  int64_t pages_skipped() const { return at<4>().as_int64(); }
  bool has_range_start() const { return at<5>().valid(); }
  int64_t range_start() const { return at<5>().as_int64(); }
  bool has_range_end() const { return at<6>().valid(); }
  int64_t range_end() const { return at<6>().as_int64(); }
  bool has_writeback_index() const { return at<7>().valid(); }
  uint64_t writeback_index() const { return at<7>().as_uint64(); }
  bool has_sync_mode() const { return at<8>().valid(); }
  int32_t sync_mode() const { return at<8>().as_int32(); }
  bool has_for_kupdate() const { return at<9>().valid(); }
  uint32_t for_kupdate() const { return at<9>().as_uint32(); }
  bool has_range_cyclic() const { return at<10>().valid(); }
  uint32_t range_cyclic() const { return at<10>().as_uint32(); }
};

class Ext4WritepagesFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4WritepagesFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kNrToWriteFieldNumber = 3,
    kPagesSkippedFieldNumber = 4,
    kRangeStartFieldNumber = 5,
    kRangeEndFieldNumber = 6,
    kWritebackIndexFieldNumber = 7,
    kSyncModeFieldNumber = 8,
    kForKupdateFieldNumber = 9,
    kRangeCyclicFieldNumber = 10,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_nr_to_write(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_pages_skipped(int64_t value) {
    AppendVarInt(4, value);
  }
  void set_range_start(int64_t value) {
    AppendVarInt(5, value);
  }
  void set_range_end(int64_t value) {
    AppendVarInt(6, value);
  }
  void set_writeback_index(uint64_t value) {
    AppendVarInt(7, value);
  }
  void set_sync_mode(int32_t value) {
    AppendVarInt(8, value);
  }
  void set_for_kupdate(uint32_t value) {
    AppendVarInt(9, value);
  }
  void set_range_cyclic(uint32_t value) {
    AppendVarInt(10, value);
  }
};

class Ext4WritepageFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4WritepageFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4WritepageFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4WritepageFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_index() const { return at<3>().valid(); }
  uint64_t index() const { return at<3>().as_uint64(); }
};

class Ext4WritepageFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4WritepageFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kIndexFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_index(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4WriteEndFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4WriteEndFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4WriteEndFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4WriteEndFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_pos() const { return at<3>().valid(); }
  int64_t pos() const { return at<3>().as_int64(); }
  bool has_len() const { return at<4>().valid(); }
  uint32_t len() const { return at<4>().as_uint32(); }
  bool has_copied() const { return at<5>().valid(); }
  uint32_t copied() const { return at<5>().as_uint32(); }
};

class Ext4WriteEndFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4WriteEndFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPosFieldNumber = 3,
    kLenFieldNumber = 4,
    kCopiedFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pos(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_copied(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4WriteBeginFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4WriteBeginFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4WriteBeginFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4WriteBeginFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_pos() const { return at<3>().valid(); }
  int64_t pos() const { return at<3>().as_int64(); }
  bool has_len() const { return at<4>().valid(); }
  uint32_t len() const { return at<4>().as_uint32(); }
  bool has_flags() const { return at<5>().valid(); }
  uint32_t flags() const { return at<5>().as_uint32(); }
};

class Ext4WriteBeginFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4WriteBeginFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPosFieldNumber = 3,
    kLenFieldNumber = 4,
    kFlagsFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pos(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4UnlinkExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4UnlinkExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4UnlinkExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4UnlinkExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_ret() const { return at<3>().valid(); }
  int32_t ret() const { return at<3>().as_int32(); }
};

class Ext4UnlinkExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4UnlinkExitFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kRetFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4UnlinkEnterFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4UnlinkEnterFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4UnlinkEnterFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4UnlinkEnterFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_parent() const { return at<3>().valid(); }
  uint64_t parent() const { return at<3>().as_uint64(); }
  bool has_size() const { return at<4>().valid(); }
  int64_t size() const { return at<4>().as_int64(); }
};

class Ext4UnlinkEnterFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4UnlinkEnterFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kParentFieldNumber = 3,
    kSizeFieldNumber = 4,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_parent(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_size(int64_t value) {
    AppendVarInt(4, value);
  }
};

class Ext4TruncateExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4TruncateExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4TruncateExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4TruncateExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_blocks() const { return at<3>().valid(); }
  uint64_t blocks() const { return at<3>().as_uint64(); }
};

class Ext4TruncateExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4TruncateExitFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kBlocksFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_blocks(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4TruncateEnterFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4TruncateEnterFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4TruncateEnterFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4TruncateEnterFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_blocks() const { return at<3>().valid(); }
  uint64_t blocks() const { return at<3>().as_uint64(); }
};

class Ext4TruncateEnterFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4TruncateEnterFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kBlocksFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_blocks(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4TrimExtentFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4TrimExtentFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4TrimExtentFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4TrimExtentFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev_major() const { return at<1>().valid(); }
  int32_t dev_major() const { return at<1>().as_int32(); }
  bool has_dev_minor() const { return at<2>().valid(); }
  int32_t dev_minor() const { return at<2>().as_int32(); }
  bool has_group() const { return at<3>().valid(); }
  uint32_t group() const { return at<3>().as_uint32(); }
  bool has_start() const { return at<4>().valid(); }
  int32_t start() const { return at<4>().as_int32(); }
  bool has_len() const { return at<5>().valid(); }
  int32_t len() const { return at<5>().as_int32(); }
};

class Ext4TrimExtentFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4TrimExtentFtraceEvent_Decoder;
  enum : int32_t {
    kDevMajorFieldNumber = 1,
    kDevMinorFieldNumber = 2,
    kGroupFieldNumber = 3,
    kStartFieldNumber = 4,
    kLenFieldNumber = 5,
  };
  void set_dev_major(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_dev_minor(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_group(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_start(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_len(int32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4TrimAllFreeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4TrimAllFreeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4TrimAllFreeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4TrimAllFreeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev_major() const { return at<1>().valid(); }
  int32_t dev_major() const { return at<1>().as_int32(); }
  bool has_dev_minor() const { return at<2>().valid(); }
  int32_t dev_minor() const { return at<2>().as_int32(); }
  bool has_group() const { return at<3>().valid(); }
  uint32_t group() const { return at<3>().as_uint32(); }
  bool has_start() const { return at<4>().valid(); }
  int32_t start() const { return at<4>().as_int32(); }
  bool has_len() const { return at<5>().valid(); }
  int32_t len() const { return at<5>().as_int32(); }
};

class Ext4TrimAllFreeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4TrimAllFreeFtraceEvent_Decoder;
  enum : int32_t {
    kDevMajorFieldNumber = 1,
    kDevMinorFieldNumber = 2,
    kGroupFieldNumber = 3,
    kStartFieldNumber = 4,
    kLenFieldNumber = 5,
  };
  void set_dev_major(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_dev_minor(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_group(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_start(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_len(int32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4SyncFsFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4SyncFsFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4SyncFsFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4SyncFsFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_wait() const { return at<2>().valid(); }
  int32_t wait() const { return at<2>().as_int32(); }
};

class Ext4SyncFsFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4SyncFsFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kWaitFieldNumber = 2,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_wait(int32_t value) {
    AppendVarInt(2, value);
  }
};

class Ext4RequestInodeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4RequestInodeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4RequestInodeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4RequestInodeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_dir() const { return at<2>().valid(); }
  uint64_t dir() const { return at<2>().as_uint64(); }
  bool has_mode() const { return at<3>().valid(); }
  uint32_t mode() const { return at<3>().as_uint32(); }
};

class Ext4RequestInodeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4RequestInodeFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kDirFieldNumber = 2,
    kModeFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_dir(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_mode(uint32_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4RequestBlocksFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/10, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4RequestBlocksFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4RequestBlocksFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4RequestBlocksFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_len() const { return at<3>().valid(); }
  uint32_t len() const { return at<3>().as_uint32(); }
  bool has_logical() const { return at<4>().valid(); }
  uint32_t logical() const { return at<4>().as_uint32(); }
  bool has_lleft() const { return at<5>().valid(); }
  uint32_t lleft() const { return at<5>().as_uint32(); }
  bool has_lright() const { return at<6>().valid(); }
  uint32_t lright() const { return at<6>().as_uint32(); }
  bool has_goal() const { return at<7>().valid(); }
  uint64_t goal() const { return at<7>().as_uint64(); }
  bool has_pleft() const { return at<8>().valid(); }
  uint64_t pleft() const { return at<8>().as_uint64(); }
  bool has_pright() const { return at<9>().valid(); }
  uint64_t pright() const { return at<9>().as_uint64(); }
  bool has_flags() const { return at<10>().valid(); }
  uint32_t flags() const { return at<10>().as_uint32(); }
};

class Ext4RequestBlocksFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4RequestBlocksFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLenFieldNumber = 3,
    kLogicalFieldNumber = 4,
    kLleftFieldNumber = 5,
    kLrightFieldNumber = 6,
    kGoalFieldNumber = 7,
    kPleftFieldNumber = 8,
    kPrightFieldNumber = 9,
    kFlagsFieldNumber = 10,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_logical(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_lleft(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_lright(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_goal(uint64_t value) {
    AppendVarInt(7, value);
  }
  void set_pleft(uint64_t value) {
    AppendVarInt(8, value);
  }
  void set_pright(uint64_t value) {
    AppendVarInt(9, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(10, value);
  }
};

class Ext4RemoveBlocksFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4RemoveBlocksFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4RemoveBlocksFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4RemoveBlocksFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_from() const { return at<3>().valid(); }
  uint32_t from() const { return at<3>().as_uint32(); }
  bool has_to() const { return at<4>().valid(); }
  uint32_t to() const { return at<4>().as_uint32(); }
  bool has_partial() const { return at<5>().valid(); }
  int64_t partial() const { return at<5>().as_int64(); }
  bool has_ee_pblk() const { return at<6>().valid(); }
  uint64_t ee_pblk() const { return at<6>().as_uint64(); }
  bool has_ee_lblk() const { return at<7>().valid(); }
  uint32_t ee_lblk() const { return at<7>().as_uint32(); }
  bool has_ee_len() const { return at<8>().valid(); }
  uint32_t ee_len() const { return at<8>().as_uint32(); }
};

class Ext4RemoveBlocksFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4RemoveBlocksFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kFromFieldNumber = 3,
    kToFieldNumber = 4,
    kPartialFieldNumber = 5,
    kEePblkFieldNumber = 6,
    kEeLblkFieldNumber = 7,
    kEeLenFieldNumber = 8,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_from(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_to(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_partial(int64_t value) {
    AppendVarInt(5, value);
  }
  void set_ee_pblk(uint64_t value) {
    AppendVarInt(6, value);
  }
  void set_ee_lblk(uint32_t value) {
    AppendVarInt(7, value);
  }
  void set_ee_len(uint32_t value) {
    AppendVarInt(8, value);
  }
};

class Ext4ReleasepageFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ReleasepageFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ReleasepageFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ReleasepageFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_index() const { return at<3>().valid(); }
  uint64_t index() const { return at<3>().as_uint64(); }
};

class Ext4ReleasepageFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ReleasepageFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kIndexFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_index(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4ReadpageFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ReadpageFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ReadpageFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ReadpageFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_index() const { return at<3>().valid(); }
  uint64_t index() const { return at<3>().as_uint64(); }
};

class Ext4ReadpageFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ReadpageFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kIndexFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_index(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4ReadBlockBitmapLoadFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ReadBlockBitmapLoadFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ReadBlockBitmapLoadFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ReadBlockBitmapLoadFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_group() const { return at<2>().valid(); }
  uint32_t group() const { return at<2>().as_uint32(); }
};

class Ext4ReadBlockBitmapLoadFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ReadBlockBitmapLoadFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kGroupFieldNumber = 2,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_group(uint32_t value) {
    AppendVarInt(2, value);
  }
};

class Ext4PunchHoleFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4PunchHoleFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4PunchHoleFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4PunchHoleFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_offset() const { return at<3>().valid(); }
  int64_t offset() const { return at<3>().as_int64(); }
  bool has_len() const { return at<4>().valid(); }
  int64_t len() const { return at<4>().as_int64(); }
  bool has_mode() const { return at<5>().valid(); }
  int32_t mode() const { return at<5>().as_int32(); }
};

class Ext4PunchHoleFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4PunchHoleFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kOffsetFieldNumber = 3,
    kLenFieldNumber = 4,
    kModeFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_offset(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_len(int64_t value) {
    AppendVarInt(4, value);
  }
  void set_mode(int32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4OtherInodeUpdateTimeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4OtherInodeUpdateTimeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4OtherInodeUpdateTimeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4OtherInodeUpdateTimeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_orig_ino() const { return at<3>().valid(); }
  uint64_t orig_ino() const { return at<3>().as_uint64(); }
  bool has_uid() const { return at<4>().valid(); }
  uint32_t uid() const { return at<4>().as_uint32(); }
  bool has_gid() const { return at<5>().valid(); }
  uint32_t gid() const { return at<5>().as_uint32(); }
  bool has_mode() const { return at<6>().valid(); }
  uint32_t mode() const { return at<6>().as_uint32(); }
};

class Ext4OtherInodeUpdateTimeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4OtherInodeUpdateTimeFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kOrigInoFieldNumber = 3,
    kUidFieldNumber = 4,
    kGidFieldNumber = 5,
    kModeFieldNumber = 6,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_orig_ino(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_uid(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_gid(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_mode(uint32_t value) {
    AppendVarInt(6, value);
  }
};

class Ext4MballocPreallocFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/10, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4MballocPreallocFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4MballocPreallocFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4MballocPreallocFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_orig_logical() const { return at<3>().valid(); }
  uint32_t orig_logical() const { return at<3>().as_uint32(); }
  bool has_orig_start() const { return at<4>().valid(); }
  int32_t orig_start() const { return at<4>().as_int32(); }
  bool has_orig_group() const { return at<5>().valid(); }
  uint32_t orig_group() const { return at<5>().as_uint32(); }
  bool has_orig_len() const { return at<6>().valid(); }
  int32_t orig_len() const { return at<6>().as_int32(); }
  bool has_result_logical() const { return at<7>().valid(); }
  uint32_t result_logical() const { return at<7>().as_uint32(); }
  bool has_result_start() const { return at<8>().valid(); }
  int32_t result_start() const { return at<8>().as_int32(); }
  bool has_result_group() const { return at<9>().valid(); }
  uint32_t result_group() const { return at<9>().as_uint32(); }
  bool has_result_len() const { return at<10>().valid(); }
  int32_t result_len() const { return at<10>().as_int32(); }
};

class Ext4MballocPreallocFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4MballocPreallocFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kOrigLogicalFieldNumber = 3,
    kOrigStartFieldNumber = 4,
    kOrigGroupFieldNumber = 5,
    kOrigLenFieldNumber = 6,
    kResultLogicalFieldNumber = 7,
    kResultStartFieldNumber = 8,
    kResultGroupFieldNumber = 9,
    kResultLenFieldNumber = 10,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_orig_logical(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_orig_start(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_orig_group(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_orig_len(int32_t value) {
    AppendVarInt(6, value);
  }
  void set_result_logical(uint32_t value) {
    AppendVarInt(7, value);
  }
  void set_result_start(int32_t value) {
    AppendVarInt(8, value);
  }
  void set_result_group(uint32_t value) {
    AppendVarInt(9, value);
  }
  void set_result_len(int32_t value) {
    AppendVarInt(10, value);
  }
};

class Ext4MballocFreeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4MballocFreeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4MballocFreeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4MballocFreeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_result_start() const { return at<3>().valid(); }
  int32_t result_start() const { return at<3>().as_int32(); }
  bool has_result_group() const { return at<4>().valid(); }
  uint32_t result_group() const { return at<4>().as_uint32(); }
  bool has_result_len() const { return at<5>().valid(); }
  int32_t result_len() const { return at<5>().as_int32(); }
};

class Ext4MballocFreeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4MballocFreeFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kResultStartFieldNumber = 3,
    kResultGroupFieldNumber = 4,
    kResultLenFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_result_start(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_result_group(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_result_len(int32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4MballocDiscardFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4MballocDiscardFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4MballocDiscardFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4MballocDiscardFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_result_start() const { return at<3>().valid(); }
  int32_t result_start() const { return at<3>().as_int32(); }
  bool has_result_group() const { return at<4>().valid(); }
  uint32_t result_group() const { return at<4>().as_uint32(); }
  bool has_result_len() const { return at<5>().valid(); }
  int32_t result_len() const { return at<5>().as_int32(); }
};

class Ext4MballocDiscardFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4MballocDiscardFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kResultStartFieldNumber = 3,
    kResultGroupFieldNumber = 4,
    kResultLenFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_result_start(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_result_group(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_result_len(int32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4MballocAllocFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/20, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4MballocAllocFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4MballocAllocFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4MballocAllocFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_orig_logical() const { return at<3>().valid(); }
  uint32_t orig_logical() const { return at<3>().as_uint32(); }
  bool has_orig_start() const { return at<4>().valid(); }
  int32_t orig_start() const { return at<4>().as_int32(); }
  bool has_orig_group() const { return at<5>().valid(); }
  uint32_t orig_group() const { return at<5>().as_uint32(); }
  bool has_orig_len() const { return at<6>().valid(); }
  int32_t orig_len() const { return at<6>().as_int32(); }
  bool has_goal_logical() const { return at<7>().valid(); }
  uint32_t goal_logical() const { return at<7>().as_uint32(); }
  bool has_goal_start() const { return at<8>().valid(); }
  int32_t goal_start() const { return at<8>().as_int32(); }
  bool has_goal_group() const { return at<9>().valid(); }
  uint32_t goal_group() const { return at<9>().as_uint32(); }
  bool has_goal_len() const { return at<10>().valid(); }
  int32_t goal_len() const { return at<10>().as_int32(); }
  bool has_result_logical() const { return at<11>().valid(); }
  uint32_t result_logical() const { return at<11>().as_uint32(); }
  bool has_result_start() const { return at<12>().valid(); }
  int32_t result_start() const { return at<12>().as_int32(); }
  bool has_result_group() const { return at<13>().valid(); }
  uint32_t result_group() const { return at<13>().as_uint32(); }
  bool has_result_len() const { return at<14>().valid(); }
  int32_t result_len() const { return at<14>().as_int32(); }
  bool has_found() const { return at<15>().valid(); }
  uint32_t found() const { return at<15>().as_uint32(); }
  bool has_groups() const { return at<16>().valid(); }
  uint32_t groups() const { return at<16>().as_uint32(); }
  bool has_buddy() const { return at<17>().valid(); }
  uint32_t buddy() const { return at<17>().as_uint32(); }
  bool has_flags() const { return at<18>().valid(); }
  uint32_t flags() const { return at<18>().as_uint32(); }
  bool has_tail() const { return at<19>().valid(); }
  uint32_t tail() const { return at<19>().as_uint32(); }
  bool has_cr() const { return at<20>().valid(); }
  uint32_t cr() const { return at<20>().as_uint32(); }
};

class Ext4MballocAllocFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4MballocAllocFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kOrigLogicalFieldNumber = 3,
    kOrigStartFieldNumber = 4,
    kOrigGroupFieldNumber = 5,
    kOrigLenFieldNumber = 6,
    kGoalLogicalFieldNumber = 7,
    kGoalStartFieldNumber = 8,
    kGoalGroupFieldNumber = 9,
    kGoalLenFieldNumber = 10,
    kResultLogicalFieldNumber = 11,
    kResultStartFieldNumber = 12,
    kResultGroupFieldNumber = 13,
    kResultLenFieldNumber = 14,
    kFoundFieldNumber = 15,
    kGroupsFieldNumber = 16,
    kBuddyFieldNumber = 17,
    kFlagsFieldNumber = 18,
    kTailFieldNumber = 19,
    kCrFieldNumber = 20,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_orig_logical(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_orig_start(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_orig_group(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_orig_len(int32_t value) {
    AppendVarInt(6, value);
  }
  void set_goal_logical(uint32_t value) {
    AppendVarInt(7, value);
  }
  void set_goal_start(int32_t value) {
    AppendVarInt(8, value);
  }
  void set_goal_group(uint32_t value) {
    AppendVarInt(9, value);
  }
  void set_goal_len(int32_t value) {
    AppendVarInt(10, value);
  }
  void set_result_logical(uint32_t value) {
    AppendVarInt(11, value);
  }
  void set_result_start(int32_t value) {
    AppendVarInt(12, value);
  }
  void set_result_group(uint32_t value) {
    AppendVarInt(13, value);
  }
  void set_result_len(int32_t value) {
    AppendVarInt(14, value);
  }
  void set_found(uint32_t value) {
    AppendVarInt(15, value);
  }
  void set_groups(uint32_t value) {
    AppendVarInt(16, value);
  }
  void set_buddy(uint32_t value) {
    AppendVarInt(17, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(18, value);
  }
  void set_tail(uint32_t value) {
    AppendVarInt(19, value);
  }
  void set_cr(uint32_t value) {
    AppendVarInt(20, value);
  }
};

class Ext4MbReleaseInodePaFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4MbReleaseInodePaFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4MbReleaseInodePaFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4MbReleaseInodePaFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_block() const { return at<3>().valid(); }
  uint64_t block() const { return at<3>().as_uint64(); }
  bool has_count() const { return at<4>().valid(); }
  uint32_t count() const { return at<4>().as_uint32(); }
};

class Ext4MbReleaseInodePaFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4MbReleaseInodePaFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kBlockFieldNumber = 3,
    kCountFieldNumber = 4,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_block(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_count(uint32_t value) {
    AppendVarInt(4, value);
  }
};

class Ext4MbReleaseGroupPaFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4MbReleaseGroupPaFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4MbReleaseGroupPaFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4MbReleaseGroupPaFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_pa_pstart() const { return at<2>().valid(); }
  uint64_t pa_pstart() const { return at<2>().as_uint64(); }
  bool has_pa_len() const { return at<3>().valid(); }
  uint32_t pa_len() const { return at<3>().as_uint32(); }
};

class Ext4MbReleaseGroupPaFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4MbReleaseGroupPaFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kPaPstartFieldNumber = 2,
    kPaLenFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_pa_pstart(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pa_len(uint32_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4MbNewInodePaFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4MbNewInodePaFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4MbNewInodePaFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4MbNewInodePaFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_pa_pstart() const { return at<3>().valid(); }
  uint64_t pa_pstart() const { return at<3>().as_uint64(); }
  bool has_pa_lstart() const { return at<4>().valid(); }
  uint64_t pa_lstart() const { return at<4>().as_uint64(); }
  bool has_pa_len() const { return at<5>().valid(); }
  uint32_t pa_len() const { return at<5>().as_uint32(); }
};

class Ext4MbNewInodePaFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4MbNewInodePaFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPaPstartFieldNumber = 3,
    kPaLstartFieldNumber = 4,
    kPaLenFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pa_pstart(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_pa_lstart(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_pa_len(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4MbNewGroupPaFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4MbNewGroupPaFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4MbNewGroupPaFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4MbNewGroupPaFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_pa_pstart() const { return at<3>().valid(); }
  uint64_t pa_pstart() const { return at<3>().as_uint64(); }
  bool has_pa_lstart() const { return at<4>().valid(); }
  uint64_t pa_lstart() const { return at<4>().as_uint64(); }
  bool has_pa_len() const { return at<5>().valid(); }
  uint32_t pa_len() const { return at<5>().as_uint32(); }
};

class Ext4MbNewGroupPaFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4MbNewGroupPaFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPaPstartFieldNumber = 3,
    kPaLstartFieldNumber = 4,
    kPaLenFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pa_pstart(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_pa_lstart(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_pa_len(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4MbDiscardPreallocationsFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4MbDiscardPreallocationsFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4MbDiscardPreallocationsFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4MbDiscardPreallocationsFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_needed() const { return at<2>().valid(); }
  int32_t needed() const { return at<2>().as_int32(); }
};

class Ext4MbDiscardPreallocationsFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4MbDiscardPreallocationsFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kNeededFieldNumber = 2,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_needed(int32_t value) {
    AppendVarInt(2, value);
  }
};

class Ext4MbBuddyBitmapLoadFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4MbBuddyBitmapLoadFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4MbBuddyBitmapLoadFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4MbBuddyBitmapLoadFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_group() const { return at<2>().valid(); }
  uint32_t group() const { return at<2>().as_uint32(); }
};

class Ext4MbBuddyBitmapLoadFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4MbBuddyBitmapLoadFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kGroupFieldNumber = 2,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_group(uint32_t value) {
    AppendVarInt(2, value);
  }
};

class Ext4MbBitmapLoadFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4MbBitmapLoadFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4MbBitmapLoadFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4MbBitmapLoadFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_group() const { return at<2>().valid(); }
  uint32_t group() const { return at<2>().as_uint32(); }
};

class Ext4MbBitmapLoadFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4MbBitmapLoadFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kGroupFieldNumber = 2,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_group(uint32_t value) {
    AppendVarInt(2, value);
  }
};

class Ext4MarkInodeDirtyFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4MarkInodeDirtyFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4MarkInodeDirtyFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4MarkInodeDirtyFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_ip() const { return at<3>().valid(); }
  uint64_t ip() const { return at<3>().as_uint64(); }
};

class Ext4MarkInodeDirtyFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4MarkInodeDirtyFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kIpFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_ip(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4LoadInodeBitmapFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4LoadInodeBitmapFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4LoadInodeBitmapFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4LoadInodeBitmapFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_group() const { return at<2>().valid(); }
  uint32_t group() const { return at<2>().as_uint32(); }
};

class Ext4LoadInodeBitmapFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4LoadInodeBitmapFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kGroupFieldNumber = 2,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_group(uint32_t value) {
    AppendVarInt(2, value);
  }
};

class Ext4LoadInodeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4LoadInodeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4LoadInodeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4LoadInodeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
};

class Ext4LoadInodeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4LoadInodeFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
};

class Ext4JournalledWriteEndFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4JournalledWriteEndFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4JournalledWriteEndFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4JournalledWriteEndFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_pos() const { return at<3>().valid(); }
  int64_t pos() const { return at<3>().as_int64(); }
  bool has_len() const { return at<4>().valid(); }
  uint32_t len() const { return at<4>().as_uint32(); }
  bool has_copied() const { return at<5>().valid(); }
  uint32_t copied() const { return at<5>().as_uint32(); }
};

class Ext4JournalledWriteEndFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4JournalledWriteEndFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPosFieldNumber = 3,
    kLenFieldNumber = 4,
    kCopiedFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pos(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_copied(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4JournalledInvalidatepageFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4JournalledInvalidatepageFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4JournalledInvalidatepageFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4JournalledInvalidatepageFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_index() const { return at<3>().valid(); }
  uint64_t index() const { return at<3>().as_uint64(); }
  bool has_offset() const { return at<4>().valid(); }
  uint64_t offset() const { return at<4>().as_uint64(); }
  bool has_length() const { return at<5>().valid(); }
  uint32_t length() const { return at<5>().as_uint32(); }
};

class Ext4JournalledInvalidatepageFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4JournalledInvalidatepageFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kIndexFieldNumber = 3,
    kOffsetFieldNumber = 4,
    kLengthFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_index(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_offset(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_length(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4JournalStartReservedFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4JournalStartReservedFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4JournalStartReservedFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4JournalStartReservedFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ip() const { return at<2>().valid(); }
  uint64_t ip() const { return at<2>().as_uint64(); }
  bool has_blocks() const { return at<3>().valid(); }
  int32_t blocks() const { return at<3>().as_int32(); }
};

class Ext4JournalStartReservedFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4JournalStartReservedFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kIpFieldNumber = 2,
    kBlocksFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ip(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_blocks(int32_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4JournalStartFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4JournalStartFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4JournalStartFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4JournalStartFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ip() const { return at<2>().valid(); }
  uint64_t ip() const { return at<2>().as_uint64(); }
  bool has_blocks() const { return at<3>().valid(); }
  int32_t blocks() const { return at<3>().as_int32(); }
  bool has_rsv_blocks() const { return at<4>().valid(); }
  int32_t rsv_blocks() const { return at<4>().as_int32(); }
  bool has_nblocks() const { return at<5>().valid(); }
  int32_t nblocks() const { return at<5>().as_int32(); }
};

class Ext4JournalStartFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4JournalStartFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kIpFieldNumber = 2,
    kBlocksFieldNumber = 3,
    kRsvBlocksFieldNumber = 4,
    kNblocksFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ip(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_blocks(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_rsv_blocks(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_nblocks(int32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4InvalidatepageFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4InvalidatepageFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4InvalidatepageFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4InvalidatepageFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_index() const { return at<3>().valid(); }
  uint64_t index() const { return at<3>().as_uint64(); }
  bool has_offset() const { return at<4>().valid(); }
  uint64_t offset() const { return at<4>().as_uint64(); }
  bool has_length() const { return at<5>().valid(); }
  uint32_t length() const { return at<5>().as_uint32(); }
};

class Ext4InvalidatepageFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4InvalidatepageFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kIndexFieldNumber = 3,
    kOffsetFieldNumber = 4,
    kLengthFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_index(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_offset(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_length(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4InsertRangeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4InsertRangeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4InsertRangeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4InsertRangeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_offset() const { return at<3>().valid(); }
  int64_t offset() const { return at<3>().as_int64(); }
  bool has_len() const { return at<4>().valid(); }
  int64_t len() const { return at<4>().as_int64(); }
};

class Ext4InsertRangeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4InsertRangeFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kOffsetFieldNumber = 3,
    kLenFieldNumber = 4,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_offset(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_len(int64_t value) {
    AppendVarInt(4, value);
  }
};

class Ext4IndMapBlocksExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4IndMapBlocksExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4IndMapBlocksExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4IndMapBlocksExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_flags() const { return at<3>().valid(); }
  uint32_t flags() const { return at<3>().as_uint32(); }
  bool has_pblk() const { return at<4>().valid(); }
  uint64_t pblk() const { return at<4>().as_uint64(); }
  bool has_lblk() const { return at<5>().valid(); }
  uint32_t lblk() const { return at<5>().as_uint32(); }
  bool has_len() const { return at<6>().valid(); }
  uint32_t len() const { return at<6>().as_uint32(); }
  bool has_mflags() const { return at<7>().valid(); }
  uint32_t mflags() const { return at<7>().as_uint32(); }
  bool has_ret() const { return at<8>().valid(); }
  int32_t ret() const { return at<8>().as_int32(); }
};

class Ext4IndMapBlocksExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4IndMapBlocksExitFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kFlagsFieldNumber = 3,
    kPblkFieldNumber = 4,
    kLblkFieldNumber = 5,
    kLenFieldNumber = 6,
    kMflagsFieldNumber = 7,
    kRetFieldNumber = 8,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_pblk(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_lblk(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_mflags(uint32_t value) {
    AppendVarInt(7, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(8, value);
  }
};

class Ext4IndMapBlocksEnterFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4IndMapBlocksEnterFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4IndMapBlocksEnterFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4IndMapBlocksEnterFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_lblk() const { return at<3>().valid(); }
  uint32_t lblk() const { return at<3>().as_uint32(); }
  bool has_len() const { return at<4>().valid(); }
  uint32_t len() const { return at<4>().as_uint32(); }
  bool has_flags() const { return at<5>().valid(); }
  uint32_t flags() const { return at<5>().as_uint32(); }
};

class Ext4IndMapBlocksEnterFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4IndMapBlocksEnterFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLblkFieldNumber = 3,
    kLenFieldNumber = 4,
    kFlagsFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_lblk(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4GetReservedClusterAllocFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4GetReservedClusterAllocFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4GetReservedClusterAllocFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4GetReservedClusterAllocFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_lblk() const { return at<3>().valid(); }
  uint32_t lblk() const { return at<3>().as_uint32(); }
  bool has_len() const { return at<4>().valid(); }
  uint32_t len() const { return at<4>().as_uint32(); }
};

class Ext4GetReservedClusterAllocFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4GetReservedClusterAllocFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLblkFieldNumber = 3,
    kLenFieldNumber = 4,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_lblk(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(4, value);
  }
};

class Ext4GetImpliedClusterAllocExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4GetImpliedClusterAllocExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4GetImpliedClusterAllocExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4GetImpliedClusterAllocExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_flags() const { return at<2>().valid(); }
  uint32_t flags() const { return at<2>().as_uint32(); }
  bool has_lblk() const { return at<3>().valid(); }
  uint32_t lblk() const { return at<3>().as_uint32(); }
  bool has_pblk() const { return at<4>().valid(); }
  uint64_t pblk() const { return at<4>().as_uint64(); }
  bool has_len() const { return at<5>().valid(); }
  uint32_t len() const { return at<5>().as_uint32(); }
  bool has_ret() const { return at<6>().valid(); }
  int32_t ret() const { return at<6>().as_int32(); }
};

class Ext4GetImpliedClusterAllocExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4GetImpliedClusterAllocExitFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kLblkFieldNumber = 3,
    kPblkFieldNumber = 4,
    kLenFieldNumber = 5,
    kRetFieldNumber = 6,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_lblk(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_pblk(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(6, value);
  }
};

class Ext4FreeInodeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4FreeInodeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4FreeInodeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4FreeInodeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_uid() const { return at<3>().valid(); }
  uint32_t uid() const { return at<3>().as_uint32(); }
  bool has_gid() const { return at<4>().valid(); }
  uint32_t gid() const { return at<4>().as_uint32(); }
  bool has_blocks() const { return at<5>().valid(); }
  uint64_t blocks() const { return at<5>().as_uint64(); }
  bool has_mode() const { return at<6>().valid(); }
  uint32_t mode() const { return at<6>().as_uint32(); }
};

class Ext4FreeInodeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4FreeInodeFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kUidFieldNumber = 3,
    kGidFieldNumber = 4,
    kBlocksFieldNumber = 5,
    kModeFieldNumber = 6,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_uid(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_gid(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_blocks(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_mode(uint32_t value) {
    AppendVarInt(6, value);
  }
};

class Ext4FreeBlocksFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4FreeBlocksFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4FreeBlocksFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4FreeBlocksFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_block() const { return at<3>().valid(); }
  uint64_t block() const { return at<3>().as_uint64(); }
  bool has_count() const { return at<4>().valid(); }
  uint64_t count() const { return at<4>().as_uint64(); }
  bool has_flags() const { return at<5>().valid(); }
  int32_t flags() const { return at<5>().as_int32(); }
  bool has_mode() const { return at<6>().valid(); }
  uint32_t mode() const { return at<6>().as_uint32(); }
};

class Ext4FreeBlocksFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4FreeBlocksFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kBlockFieldNumber = 3,
    kCountFieldNumber = 4,
    kFlagsFieldNumber = 5,
    kModeFieldNumber = 6,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_block(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_count(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_flags(int32_t value) {
    AppendVarInt(5, value);
  }
  void set_mode(uint32_t value) {
    AppendVarInt(6, value);
  }
};

class Ext4ForgetFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ForgetFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ForgetFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ForgetFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_block() const { return at<3>().valid(); }
  uint64_t block() const { return at<3>().as_uint64(); }
  bool has_is_metadata() const { return at<4>().valid(); }
  int32_t is_metadata() const { return at<4>().as_int32(); }
  bool has_mode() const { return at<5>().valid(); }
  uint32_t mode() const { return at<5>().as_uint32(); }
};

class Ext4ForgetFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ForgetFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kBlockFieldNumber = 3,
    kIsMetadataFieldNumber = 4,
    kModeFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_block(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_is_metadata(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_mode(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4FindDelallocRangeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/7, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4FindDelallocRangeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4FindDelallocRangeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4FindDelallocRangeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_from() const { return at<3>().valid(); }
  uint32_t from() const { return at<3>().as_uint32(); }
  bool has_to() const { return at<4>().valid(); }
  uint32_t to() const { return at<4>().as_uint32(); }
  bool has_reverse() const { return at<5>().valid(); }
  int32_t reverse() const { return at<5>().as_int32(); }
  bool has_found() const { return at<6>().valid(); }
  int32_t found() const { return at<6>().as_int32(); }
  bool has_found_blk() const { return at<7>().valid(); }
  uint32_t found_blk() const { return at<7>().as_uint32(); }
};

class Ext4FindDelallocRangeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4FindDelallocRangeFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kFromFieldNumber = 3,
    kToFieldNumber = 4,
    kReverseFieldNumber = 5,
    kFoundFieldNumber = 6,
    kFoundBlkFieldNumber = 7,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_from(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_to(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_reverse(int32_t value) {
    AppendVarInt(5, value);
  }
  void set_found(int32_t value) {
    AppendVarInt(6, value);
  }
  void set_found_blk(uint32_t value) {
    AppendVarInt(7, value);
  }
};

class Ext4FallocateExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4FallocateExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4FallocateExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4FallocateExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_pos() const { return at<3>().valid(); }
  int64_t pos() const { return at<3>().as_int64(); }
  bool has_blocks() const { return at<4>().valid(); }
  uint32_t blocks() const { return at<4>().as_uint32(); }
  bool has_ret() const { return at<5>().valid(); }
  int32_t ret() const { return at<5>().as_int32(); }
};

class Ext4FallocateExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4FallocateExitFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPosFieldNumber = 3,
    kBlocksFieldNumber = 4,
    kRetFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pos(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_blocks(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4FallocateEnterFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4FallocateEnterFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4FallocateEnterFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4FallocateEnterFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_offset() const { return at<3>().valid(); }
  int64_t offset() const { return at<3>().as_int64(); }
  bool has_len() const { return at<4>().valid(); }
  int64_t len() const { return at<4>().as_int64(); }
  bool has_mode() const { return at<5>().valid(); }
  int32_t mode() const { return at<5>().as_int32(); }
  bool has_pos() const { return at<6>().valid(); }
  int64_t pos() const { return at<6>().as_int64(); }
};

class Ext4FallocateEnterFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4FallocateEnterFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kOffsetFieldNumber = 3,
    kLenFieldNumber = 4,
    kModeFieldNumber = 5,
    kPosFieldNumber = 6,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_offset(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_len(int64_t value) {
    AppendVarInt(4, value);
  }
  void set_mode(int32_t value) {
    AppendVarInt(5, value);
  }
  void set_pos(int64_t value) {
    AppendVarInt(6, value);
  }
};

class Ext4ExtShowExtentFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ExtShowExtentFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ExtShowExtentFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ExtShowExtentFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_pblk() const { return at<3>().valid(); }
  uint64_t pblk() const { return at<3>().as_uint64(); }
  bool has_lblk() const { return at<4>().valid(); }
  uint32_t lblk() const { return at<4>().as_uint32(); }
  bool has_len() const { return at<5>().valid(); }
  uint32_t len() const { return at<5>().as_uint32(); }
};

class Ext4ExtShowExtentFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ExtShowExtentFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPblkFieldNumber = 3,
    kLblkFieldNumber = 4,
    kLenFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pblk(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_lblk(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4ExtRmLeafFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/7, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ExtRmLeafFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ExtRmLeafFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ExtRmLeafFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_partial() const { return at<3>().valid(); }
  int64_t partial() const { return at<3>().as_int64(); }
  bool has_start() const { return at<4>().valid(); }
  uint32_t start() const { return at<4>().as_uint32(); }
  bool has_ee_lblk() const { return at<5>().valid(); }
  uint32_t ee_lblk() const { return at<5>().as_uint32(); }
  bool has_ee_pblk() const { return at<6>().valid(); }
  uint64_t ee_pblk() const { return at<6>().as_uint64(); }
  bool has_ee_len() const { return at<7>().valid(); }
  int32_t ee_len() const { return at<7>().as_int32(); }
};

class Ext4ExtRmLeafFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ExtRmLeafFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPartialFieldNumber = 3,
    kStartFieldNumber = 4,
    kEeLblkFieldNumber = 5,
    kEePblkFieldNumber = 6,
    kEeLenFieldNumber = 7,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_partial(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_start(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_ee_lblk(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_ee_pblk(uint64_t value) {
    AppendVarInt(6, value);
  }
  void set_ee_len(int32_t value) {
    AppendVarInt(7, value);
  }
};

class Ext4ExtRmIdxFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ExtRmIdxFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ExtRmIdxFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ExtRmIdxFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_pblk() const { return at<3>().valid(); }
  uint64_t pblk() const { return at<3>().as_uint64(); }
};

class Ext4ExtRmIdxFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ExtRmIdxFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPblkFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pblk(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4ExtRemoveSpaceDoneFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/7, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ExtRemoveSpaceDoneFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ExtRemoveSpaceDoneFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ExtRemoveSpaceDoneFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_start() const { return at<3>().valid(); }
  uint32_t start() const { return at<3>().as_uint32(); }
  bool has_end() const { return at<4>().valid(); }
  uint32_t end() const { return at<4>().as_uint32(); }
  bool has_depth() const { return at<5>().valid(); }
  int32_t depth() const { return at<5>().as_int32(); }
  bool has_partial() const { return at<6>().valid(); }
  int64_t partial() const { return at<6>().as_int64(); }
  bool has_eh_entries() const { return at<7>().valid(); }
  uint32_t eh_entries() const { return at<7>().as_uint32(); }
};

class Ext4ExtRemoveSpaceDoneFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ExtRemoveSpaceDoneFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kStartFieldNumber = 3,
    kEndFieldNumber = 4,
    kDepthFieldNumber = 5,
    kPartialFieldNumber = 6,
    kEhEntriesFieldNumber = 7,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_start(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_end(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_depth(int32_t value) {
    AppendVarInt(5, value);
  }
  void set_partial(int64_t value) {
    AppendVarInt(6, value);
  }
  void set_eh_entries(uint32_t value) {
    AppendVarInt(7, value);
  }
};

class Ext4ExtRemoveSpaceFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ExtRemoveSpaceFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ExtRemoveSpaceFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ExtRemoveSpaceFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_start() const { return at<3>().valid(); }
  uint32_t start() const { return at<3>().as_uint32(); }
  bool has_end() const { return at<4>().valid(); }
  uint32_t end() const { return at<4>().as_uint32(); }
  bool has_depth() const { return at<5>().valid(); }
  int32_t depth() const { return at<5>().as_int32(); }
};

class Ext4ExtRemoveSpaceFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ExtRemoveSpaceFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kStartFieldNumber = 3,
    kEndFieldNumber = 4,
    kDepthFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_start(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_end(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_depth(int32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4ExtPutInCacheFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ExtPutInCacheFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ExtPutInCacheFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ExtPutInCacheFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_lblk() const { return at<3>().valid(); }
  uint32_t lblk() const { return at<3>().as_uint32(); }
  bool has_len() const { return at<4>().valid(); }
  uint32_t len() const { return at<4>().as_uint32(); }
  bool has_start() const { return at<5>().valid(); }
  uint64_t start() const { return at<5>().as_uint64(); }
};

class Ext4ExtPutInCacheFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ExtPutInCacheFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLblkFieldNumber = 3,
    kLenFieldNumber = 4,
    kStartFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_lblk(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_start(uint64_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4ExtMapBlocksExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ExtMapBlocksExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ExtMapBlocksExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ExtMapBlocksExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_flags() const { return at<3>().valid(); }
  uint32_t flags() const { return at<3>().as_uint32(); }
  bool has_pblk() const { return at<4>().valid(); }
  uint64_t pblk() const { return at<4>().as_uint64(); }
  bool has_lblk() const { return at<5>().valid(); }
  uint32_t lblk() const { return at<5>().as_uint32(); }
  bool has_len() const { return at<6>().valid(); }
  uint32_t len() const { return at<6>().as_uint32(); }
  bool has_mflags() const { return at<7>().valid(); }
  uint32_t mflags() const { return at<7>().as_uint32(); }
  bool has_ret() const { return at<8>().valid(); }
  int32_t ret() const { return at<8>().as_int32(); }
};

class Ext4ExtMapBlocksExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ExtMapBlocksExitFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kFlagsFieldNumber = 3,
    kPblkFieldNumber = 4,
    kLblkFieldNumber = 5,
    kLenFieldNumber = 6,
    kMflagsFieldNumber = 7,
    kRetFieldNumber = 8,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_pblk(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_lblk(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_mflags(uint32_t value) {
    AppendVarInt(7, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(8, value);
  }
};

class Ext4ExtMapBlocksEnterFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ExtMapBlocksEnterFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ExtMapBlocksEnterFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ExtMapBlocksEnterFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_lblk() const { return at<3>().valid(); }
  uint32_t lblk() const { return at<3>().as_uint32(); }
  bool has_len() const { return at<4>().valid(); }
  uint32_t len() const { return at<4>().as_uint32(); }
  bool has_flags() const { return at<5>().valid(); }
  uint32_t flags() const { return at<5>().as_uint32(); }
};

class Ext4ExtMapBlocksEnterFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ExtMapBlocksEnterFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLblkFieldNumber = 3,
    kLenFieldNumber = 4,
    kFlagsFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_lblk(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4ExtLoadExtentFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ExtLoadExtentFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ExtLoadExtentFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ExtLoadExtentFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_pblk() const { return at<3>().valid(); }
  uint64_t pblk() const { return at<3>().as_uint64(); }
  bool has_lblk() const { return at<4>().valid(); }
  uint32_t lblk() const { return at<4>().as_uint32(); }
};

class Ext4ExtLoadExtentFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ExtLoadExtentFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPblkFieldNumber = 3,
    kLblkFieldNumber = 4,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pblk(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_lblk(uint32_t value) {
    AppendVarInt(4, value);
  }
};

class Ext4ExtInCacheFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ExtInCacheFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ExtInCacheFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ExtInCacheFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_lblk() const { return at<3>().valid(); }
  uint32_t lblk() const { return at<3>().as_uint32(); }
  bool has_ret() const { return at<4>().valid(); }
  int32_t ret() const { return at<4>().as_int32(); }
};

class Ext4ExtInCacheFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ExtInCacheFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLblkFieldNumber = 3,
    kRetFieldNumber = 4,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_lblk(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(4, value);
  }
};

class Ext4ExtHandleUnwrittenExtentsFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ExtHandleUnwrittenExtentsFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ExtHandleUnwrittenExtentsFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ExtHandleUnwrittenExtentsFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_flags() const { return at<3>().valid(); }
  int32_t flags() const { return at<3>().as_int32(); }
  bool has_lblk() const { return at<4>().valid(); }
  uint32_t lblk() const { return at<4>().as_uint32(); }
  bool has_pblk() const { return at<5>().valid(); }
  uint64_t pblk() const { return at<5>().as_uint64(); }
  bool has_len() const { return at<6>().valid(); }
  uint32_t len() const { return at<6>().as_uint32(); }
  bool has_allocated() const { return at<7>().valid(); }
  uint32_t allocated() const { return at<7>().as_uint32(); }
  bool has_newblk() const { return at<8>().valid(); }
  uint64_t newblk() const { return at<8>().as_uint64(); }
};

class Ext4ExtHandleUnwrittenExtentsFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ExtHandleUnwrittenExtentsFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kFlagsFieldNumber = 3,
    kLblkFieldNumber = 4,
    kPblkFieldNumber = 5,
    kLenFieldNumber = 6,
    kAllocatedFieldNumber = 7,
    kNewblkFieldNumber = 8,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_flags(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_lblk(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_pblk(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_allocated(uint32_t value) {
    AppendVarInt(7, value);
  }
  void set_newblk(uint64_t value) {
    AppendVarInt(8, value);
  }
};

class Ext4ExtConvertToInitializedFastpathFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/10, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ExtConvertToInitializedFastpathFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ExtConvertToInitializedFastpathFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ExtConvertToInitializedFastpathFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_m_lblk() const { return at<3>().valid(); }
  uint32_t m_lblk() const { return at<3>().as_uint32(); }
  bool has_m_len() const { return at<4>().valid(); }
  uint32_t m_len() const { return at<4>().as_uint32(); }
  bool has_u_lblk() const { return at<5>().valid(); }
  uint32_t u_lblk() const { return at<5>().as_uint32(); }
  bool has_u_len() const { return at<6>().valid(); }
  uint32_t u_len() const { return at<6>().as_uint32(); }
  bool has_u_pblk() const { return at<7>().valid(); }
  uint64_t u_pblk() const { return at<7>().as_uint64(); }
  bool has_i_lblk() const { return at<8>().valid(); }
  uint32_t i_lblk() const { return at<8>().as_uint32(); }
  bool has_i_len() const { return at<9>().valid(); }
  uint32_t i_len() const { return at<9>().as_uint32(); }
  bool has_i_pblk() const { return at<10>().valid(); }
  uint64_t i_pblk() const { return at<10>().as_uint64(); }
};

class Ext4ExtConvertToInitializedFastpathFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ExtConvertToInitializedFastpathFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kMLblkFieldNumber = 3,
    kMLenFieldNumber = 4,
    kULblkFieldNumber = 5,
    kULenFieldNumber = 6,
    kUPblkFieldNumber = 7,
    kILblkFieldNumber = 8,
    kILenFieldNumber = 9,
    kIPblkFieldNumber = 10,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_m_lblk(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_m_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_u_lblk(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_u_len(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_u_pblk(uint64_t value) {
    AppendVarInt(7, value);
  }
  void set_i_lblk(uint32_t value) {
    AppendVarInt(8, value);
  }
  void set_i_len(uint32_t value) {
    AppendVarInt(9, value);
  }
  void set_i_pblk(uint64_t value) {
    AppendVarInt(10, value);
  }
};

class Ext4ExtConvertToInitializedEnterFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/7, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4ExtConvertToInitializedEnterFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4ExtConvertToInitializedEnterFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4ExtConvertToInitializedEnterFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_m_lblk() const { return at<3>().valid(); }
  uint32_t m_lblk() const { return at<3>().as_uint32(); }
  bool has_m_len() const { return at<4>().valid(); }
  uint32_t m_len() const { return at<4>().as_uint32(); }
  bool has_u_lblk() const { return at<5>().valid(); }
  uint32_t u_lblk() const { return at<5>().as_uint32(); }
  bool has_u_len() const { return at<6>().valid(); }
  uint32_t u_len() const { return at<6>().as_uint32(); }
  bool has_u_pblk() const { return at<7>().valid(); }
  uint64_t u_pblk() const { return at<7>().as_uint64(); }
};

class Ext4ExtConvertToInitializedEnterFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4ExtConvertToInitializedEnterFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kMLblkFieldNumber = 3,
    kMLenFieldNumber = 4,
    kULblkFieldNumber = 5,
    kULenFieldNumber = 6,
    kUPblkFieldNumber = 7,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_m_lblk(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_m_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_u_lblk(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_u_len(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_u_pblk(uint64_t value) {
    AppendVarInt(7, value);
  }
};

class Ext4EvictInodeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4EvictInodeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4EvictInodeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4EvictInodeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_nlink() const { return at<3>().valid(); }
  int32_t nlink() const { return at<3>().as_int32(); }
};

class Ext4EvictInodeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4EvictInodeFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kNlinkFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_nlink(int32_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4EsShrinkScanExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4EsShrinkScanExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4EsShrinkScanExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4EsShrinkScanExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_nr_shrunk() const { return at<2>().valid(); }
  int32_t nr_shrunk() const { return at<2>().as_int32(); }
  bool has_cache_cnt() const { return at<3>().valid(); }
  int32_t cache_cnt() const { return at<3>().as_int32(); }
};

class Ext4EsShrinkScanExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4EsShrinkScanExitFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kNrShrunkFieldNumber = 2,
    kCacheCntFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_nr_shrunk(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_cache_cnt(int32_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4EsShrinkScanEnterFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4EsShrinkScanEnterFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4EsShrinkScanEnterFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4EsShrinkScanEnterFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_nr_to_scan() const { return at<2>().valid(); }
  int32_t nr_to_scan() const { return at<2>().as_int32(); }
  bool has_cache_cnt() const { return at<3>().valid(); }
  int32_t cache_cnt() const { return at<3>().as_int32(); }
};

class Ext4EsShrinkScanEnterFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4EsShrinkScanEnterFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kNrToScanFieldNumber = 2,
    kCacheCntFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_nr_to_scan(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_cache_cnt(int32_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4EsShrinkCountFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4EsShrinkCountFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4EsShrinkCountFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4EsShrinkCountFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_nr_to_scan() const { return at<2>().valid(); }
  int32_t nr_to_scan() const { return at<2>().as_int32(); }
  bool has_cache_cnt() const { return at<3>().valid(); }
  int32_t cache_cnt() const { return at<3>().as_int32(); }
};

class Ext4EsShrinkCountFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4EsShrinkCountFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kNrToScanFieldNumber = 2,
    kCacheCntFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_nr_to_scan(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_cache_cnt(int32_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4EsShrinkFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4EsShrinkFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4EsShrinkFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4EsShrinkFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_nr_shrunk() const { return at<2>().valid(); }
  int32_t nr_shrunk() const { return at<2>().as_int32(); }
  bool has_scan_time() const { return at<3>().valid(); }
  uint64_t scan_time() const { return at<3>().as_uint64(); }
  bool has_nr_skipped() const { return at<4>().valid(); }
  int32_t nr_skipped() const { return at<4>().as_int32(); }
  bool has_retried() const { return at<5>().valid(); }
  int32_t retried() const { return at<5>().as_int32(); }
};

class Ext4EsShrinkFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4EsShrinkFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kNrShrunkFieldNumber = 2,
    kScanTimeFieldNumber = 3,
    kNrSkippedFieldNumber = 4,
    kRetriedFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_nr_shrunk(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_scan_time(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_nr_skipped(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_retried(int32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4EsRemoveExtentFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4EsRemoveExtentFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4EsRemoveExtentFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4EsRemoveExtentFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_lblk() const { return at<3>().valid(); }
  int64_t lblk() const { return at<3>().as_int64(); }
  bool has_len() const { return at<4>().valid(); }
  int64_t len() const { return at<4>().as_int64(); }
};

class Ext4EsRemoveExtentFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4EsRemoveExtentFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLblkFieldNumber = 3,
    kLenFieldNumber = 4,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_lblk(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_len(int64_t value) {
    AppendVarInt(4, value);
  }
};

class Ext4EsLookupExtentExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/7, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4EsLookupExtentExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4EsLookupExtentExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4EsLookupExtentExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_lblk() const { return at<3>().valid(); }
  uint32_t lblk() const { return at<3>().as_uint32(); }
  bool has_len() const { return at<4>().valid(); }
  uint32_t len() const { return at<4>().as_uint32(); }
  bool has_pblk() const { return at<5>().valid(); }
  uint64_t pblk() const { return at<5>().as_uint64(); }
  bool has_status() const { return at<6>().valid(); }
  uint64_t status() const { return at<6>().as_uint64(); }
  bool has_found() const { return at<7>().valid(); }
  int32_t found() const { return at<7>().as_int32(); }
};

class Ext4EsLookupExtentExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4EsLookupExtentExitFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLblkFieldNumber = 3,
    kLenFieldNumber = 4,
    kPblkFieldNumber = 5,
    kStatusFieldNumber = 6,
    kFoundFieldNumber = 7,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_lblk(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_pblk(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_status(uint64_t value) {
    AppendVarInt(6, value);
  }
  void set_found(int32_t value) {
    AppendVarInt(7, value);
  }
};

class Ext4EsLookupExtentEnterFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4EsLookupExtentEnterFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4EsLookupExtentEnterFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4EsLookupExtentEnterFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_lblk() const { return at<3>().valid(); }
  uint32_t lblk() const { return at<3>().as_uint32(); }
};

class Ext4EsLookupExtentEnterFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4EsLookupExtentEnterFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLblkFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_lblk(uint32_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4EsInsertExtentFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4EsInsertExtentFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4EsInsertExtentFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4EsInsertExtentFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_lblk() const { return at<3>().valid(); }
  uint32_t lblk() const { return at<3>().as_uint32(); }
  bool has_len() const { return at<4>().valid(); }
  uint32_t len() const { return at<4>().as_uint32(); }
  bool has_pblk() const { return at<5>().valid(); }
  uint64_t pblk() const { return at<5>().as_uint64(); }
  bool has_status() const { return at<6>().valid(); }
  uint64_t status() const { return at<6>().as_uint64(); }
};

class Ext4EsInsertExtentFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4EsInsertExtentFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLblkFieldNumber = 3,
    kLenFieldNumber = 4,
    kPblkFieldNumber = 5,
    kStatusFieldNumber = 6,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_lblk(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_pblk(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_status(uint64_t value) {
    AppendVarInt(6, value);
  }
};

class Ext4EsFindDelayedExtentRangeExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4EsFindDelayedExtentRangeExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4EsFindDelayedExtentRangeExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4EsFindDelayedExtentRangeExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_lblk() const { return at<3>().valid(); }
  uint32_t lblk() const { return at<3>().as_uint32(); }
  bool has_len() const { return at<4>().valid(); }
  uint32_t len() const { return at<4>().as_uint32(); }
  bool has_pblk() const { return at<5>().valid(); }
  uint64_t pblk() const { return at<5>().as_uint64(); }
  bool has_status() const { return at<6>().valid(); }
  uint64_t status() const { return at<6>().as_uint64(); }
};

class Ext4EsFindDelayedExtentRangeExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4EsFindDelayedExtentRangeExitFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLblkFieldNumber = 3,
    kLenFieldNumber = 4,
    kPblkFieldNumber = 5,
    kStatusFieldNumber = 6,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_lblk(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_pblk(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_status(uint64_t value) {
    AppendVarInt(6, value);
  }
};

class Ext4EsFindDelayedExtentRangeEnterFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4EsFindDelayedExtentRangeEnterFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4EsFindDelayedExtentRangeEnterFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4EsFindDelayedExtentRangeEnterFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_lblk() const { return at<3>().valid(); }
  uint32_t lblk() const { return at<3>().as_uint32(); }
};

class Ext4EsFindDelayedExtentRangeEnterFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4EsFindDelayedExtentRangeEnterFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLblkFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_lblk(uint32_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4EsCacheExtentFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4EsCacheExtentFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4EsCacheExtentFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4EsCacheExtentFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_lblk() const { return at<3>().valid(); }
  uint32_t lblk() const { return at<3>().as_uint32(); }
  bool has_len() const { return at<4>().valid(); }
  uint32_t len() const { return at<4>().as_uint32(); }
  bool has_pblk() const { return at<5>().valid(); }
  uint64_t pblk() const { return at<5>().as_uint64(); }
  bool has_status() const { return at<6>().valid(); }
  uint32_t status() const { return at<6>().as_uint32(); }
};

class Ext4EsCacheExtentFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4EsCacheExtentFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLblkFieldNumber = 3,
    kLenFieldNumber = 4,
    kPblkFieldNumber = 5,
    kStatusFieldNumber = 6,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_lblk(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_pblk(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_status(uint32_t value) {
    AppendVarInt(6, value);
  }
};

class Ext4DropInodeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4DropInodeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4DropInodeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4DropInodeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_drop() const { return at<3>().valid(); }
  int32_t drop() const { return at<3>().as_int32(); }
};

class Ext4DropInodeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4DropInodeFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kDropFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_drop(int32_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4DiscardPreallocationsFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4DiscardPreallocationsFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4DiscardPreallocationsFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4DiscardPreallocationsFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
};

class Ext4DiscardPreallocationsFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4DiscardPreallocationsFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
};

class Ext4DiscardBlocksFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4DiscardBlocksFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4DiscardBlocksFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4DiscardBlocksFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_blk() const { return at<2>().valid(); }
  uint64_t blk() const { return at<2>().as_uint64(); }
  bool has_count() const { return at<3>().valid(); }
  uint64_t count() const { return at<3>().as_uint64(); }
};

class Ext4DiscardBlocksFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4DiscardBlocksFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kBlkFieldNumber = 2,
    kCountFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_blk(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_count(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4DirectIOExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4DirectIOExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4DirectIOExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4DirectIOExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_pos() const { return at<3>().valid(); }
  int64_t pos() const { return at<3>().as_int64(); }
  bool has_len() const { return at<4>().valid(); }
  uint64_t len() const { return at<4>().as_uint64(); }
  bool has_rw() const { return at<5>().valid(); }
  int32_t rw() const { return at<5>().as_int32(); }
  bool has_ret() const { return at<6>().valid(); }
  int32_t ret() const { return at<6>().as_int32(); }
};

class Ext4DirectIOExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4DirectIOExitFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPosFieldNumber = 3,
    kLenFieldNumber = 4,
    kRwFieldNumber = 5,
    kRetFieldNumber = 6,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pos(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_rw(int32_t value) {
    AppendVarInt(5, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(6, value);
  }
};

class Ext4DirectIOEnterFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4DirectIOEnterFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4DirectIOEnterFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4DirectIOEnterFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_pos() const { return at<3>().valid(); }
  int64_t pos() const { return at<3>().as_int64(); }
  bool has_len() const { return at<4>().valid(); }
  uint64_t len() const { return at<4>().as_uint64(); }
  bool has_rw() const { return at<5>().valid(); }
  int32_t rw() const { return at<5>().as_int32(); }
};

class Ext4DirectIOEnterFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4DirectIOEnterFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPosFieldNumber = 3,
    kLenFieldNumber = 4,
    kRwFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pos(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_rw(int32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4DaWritePagesExtentFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4DaWritePagesExtentFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4DaWritePagesExtentFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4DaWritePagesExtentFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_lblk() const { return at<3>().valid(); }
  uint64_t lblk() const { return at<3>().as_uint64(); }
  bool has_len() const { return at<4>().valid(); }
  uint32_t len() const { return at<4>().as_uint32(); }
  bool has_flags() const { return at<5>().valid(); }
  uint32_t flags() const { return at<5>().as_uint32(); }
};

class Ext4DaWritePagesExtentFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4DaWritePagesExtentFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kLblkFieldNumber = 3,
    kLenFieldNumber = 4,
    kFlagsFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_lblk(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4DaWritePagesFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/10, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4DaWritePagesFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4DaWritePagesFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4DaWritePagesFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_first_page() const { return at<3>().valid(); }
  uint64_t first_page() const { return at<3>().as_uint64(); }
  bool has_nr_to_write() const { return at<4>().valid(); }
  int64_t nr_to_write() const { return at<4>().as_int64(); }
  bool has_sync_mode() const { return at<5>().valid(); }
  int32_t sync_mode() const { return at<5>().as_int32(); }
  bool has_b_blocknr() const { return at<6>().valid(); }
  uint64_t b_blocknr() const { return at<6>().as_uint64(); }
  bool has_b_size() const { return at<7>().valid(); }
  uint32_t b_size() const { return at<7>().as_uint32(); }
  bool has_b_state() const { return at<8>().valid(); }
  uint32_t b_state() const { return at<8>().as_uint32(); }
  bool has_io_done() const { return at<9>().valid(); }
  int32_t io_done() const { return at<9>().as_int32(); }
  bool has_pages_written() const { return at<10>().valid(); }
  int32_t pages_written() const { return at<10>().as_int32(); }
};

class Ext4DaWritePagesFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4DaWritePagesFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kFirstPageFieldNumber = 3,
    kNrToWriteFieldNumber = 4,
    kSyncModeFieldNumber = 5,
    kBBlocknrFieldNumber = 6,
    kBSizeFieldNumber = 7,
    kBStateFieldNumber = 8,
    kIoDoneFieldNumber = 9,
    kPagesWrittenFieldNumber = 10,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_first_page(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_nr_to_write(int64_t value) {
    AppendVarInt(4, value);
  }
  void set_sync_mode(int32_t value) {
    AppendVarInt(5, value);
  }
  void set_b_blocknr(uint64_t value) {
    AppendVarInt(6, value);
  }
  void set_b_size(uint32_t value) {
    AppendVarInt(7, value);
  }
  void set_b_state(uint32_t value) {
    AppendVarInt(8, value);
  }
  void set_io_done(int32_t value) {
    AppendVarInt(9, value);
  }
  void set_pages_written(int32_t value) {
    AppendVarInt(10, value);
  }
};

class Ext4DaUpdateReserveSpaceFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/9, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4DaUpdateReserveSpaceFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4DaUpdateReserveSpaceFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4DaUpdateReserveSpaceFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_i_blocks() const { return at<3>().valid(); }
  uint64_t i_blocks() const { return at<3>().as_uint64(); }
  bool has_used_blocks() const { return at<4>().valid(); }
  int32_t used_blocks() const { return at<4>().as_int32(); }
  bool has_reserved_data_blocks() const { return at<5>().valid(); }
  int32_t reserved_data_blocks() const { return at<5>().as_int32(); }
  bool has_reserved_meta_blocks() const { return at<6>().valid(); }
  int32_t reserved_meta_blocks() const { return at<6>().as_int32(); }
  bool has_allocated_meta_blocks() const { return at<7>().valid(); }
  int32_t allocated_meta_blocks() const { return at<7>().as_int32(); }
  bool has_quota_claim() const { return at<8>().valid(); }
  int32_t quota_claim() const { return at<8>().as_int32(); }
  bool has_mode() const { return at<9>().valid(); }
  uint32_t mode() const { return at<9>().as_uint32(); }
};

class Ext4DaUpdateReserveSpaceFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4DaUpdateReserveSpaceFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kIBlocksFieldNumber = 3,
    kUsedBlocksFieldNumber = 4,
    kReservedDataBlocksFieldNumber = 5,
    kReservedMetaBlocksFieldNumber = 6,
    kAllocatedMetaBlocksFieldNumber = 7,
    kQuotaClaimFieldNumber = 8,
    kModeFieldNumber = 9,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_i_blocks(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_used_blocks(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_reserved_data_blocks(int32_t value) {
    AppendVarInt(5, value);
  }
  void set_reserved_meta_blocks(int32_t value) {
    AppendVarInt(6, value);
  }
  void set_allocated_meta_blocks(int32_t value) {
    AppendVarInt(7, value);
  }
  void set_quota_claim(int32_t value) {
    AppendVarInt(8, value);
  }
  void set_mode(uint32_t value) {
    AppendVarInt(9, value);
  }
};

class Ext4DaReserveSpaceFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/7, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4DaReserveSpaceFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4DaReserveSpaceFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4DaReserveSpaceFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_i_blocks() const { return at<3>().valid(); }
  uint64_t i_blocks() const { return at<3>().as_uint64(); }
  bool has_reserved_data_blocks() const { return at<4>().valid(); }
  int32_t reserved_data_blocks() const { return at<4>().as_int32(); }
  bool has_reserved_meta_blocks() const { return at<5>().valid(); }
  int32_t reserved_meta_blocks() const { return at<5>().as_int32(); }
  bool has_mode() const { return at<6>().valid(); }
  uint32_t mode() const { return at<6>().as_uint32(); }
  bool has_md_needed() const { return at<7>().valid(); }
  int32_t md_needed() const { return at<7>().as_int32(); }
};

class Ext4DaReserveSpaceFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4DaReserveSpaceFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kIBlocksFieldNumber = 3,
    kReservedDataBlocksFieldNumber = 4,
    kReservedMetaBlocksFieldNumber = 5,
    kModeFieldNumber = 6,
    kMdNeededFieldNumber = 7,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_i_blocks(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_reserved_data_blocks(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_reserved_meta_blocks(int32_t value) {
    AppendVarInt(5, value);
  }
  void set_mode(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_md_needed(int32_t value) {
    AppendVarInt(7, value);
  }
};

class Ext4DaReleaseSpaceFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4DaReleaseSpaceFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4DaReleaseSpaceFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4DaReleaseSpaceFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_i_blocks() const { return at<3>().valid(); }
  uint64_t i_blocks() const { return at<3>().as_uint64(); }
  bool has_freed_blocks() const { return at<4>().valid(); }
  int32_t freed_blocks() const { return at<4>().as_int32(); }
  bool has_reserved_data_blocks() const { return at<5>().valid(); }
  int32_t reserved_data_blocks() const { return at<5>().as_int32(); }
  bool has_reserved_meta_blocks() const { return at<6>().valid(); }
  int32_t reserved_meta_blocks() const { return at<6>().as_int32(); }
  bool has_allocated_meta_blocks() const { return at<7>().valid(); }
  int32_t allocated_meta_blocks() const { return at<7>().as_int32(); }
  bool has_mode() const { return at<8>().valid(); }
  uint32_t mode() const { return at<8>().as_uint32(); }
};

class Ext4DaReleaseSpaceFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4DaReleaseSpaceFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kIBlocksFieldNumber = 3,
    kFreedBlocksFieldNumber = 4,
    kReservedDataBlocksFieldNumber = 5,
    kReservedMetaBlocksFieldNumber = 6,
    kAllocatedMetaBlocksFieldNumber = 7,
    kModeFieldNumber = 8,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_i_blocks(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_freed_blocks(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_reserved_data_blocks(int32_t value) {
    AppendVarInt(5, value);
  }
  void set_reserved_meta_blocks(int32_t value) {
    AppendVarInt(6, value);
  }
  void set_allocated_meta_blocks(int32_t value) {
    AppendVarInt(7, value);
  }
  void set_mode(uint32_t value) {
    AppendVarInt(8, value);
  }
};

class Ext4CollapseRangeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4CollapseRangeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4CollapseRangeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4CollapseRangeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_offset() const { return at<3>().valid(); }
  int64_t offset() const { return at<3>().as_int64(); }
  bool has_len() const { return at<4>().valid(); }
  int64_t len() const { return at<4>().as_int64(); }
};

class Ext4CollapseRangeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4CollapseRangeFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kOffsetFieldNumber = 3,
    kLenFieldNumber = 4,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_offset(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_len(int64_t value) {
    AppendVarInt(4, value);
  }
};

class Ext4BeginOrderedTruncateFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4BeginOrderedTruncateFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4BeginOrderedTruncateFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4BeginOrderedTruncateFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_new_size() const { return at<3>().valid(); }
  int64_t new_size() const { return at<3>().as_int64(); }
};

class Ext4BeginOrderedTruncateFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4BeginOrderedTruncateFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kNewSizeFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_new_size(int64_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4AllocateInodeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4AllocateInodeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4AllocateInodeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4AllocateInodeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_dir() const { return at<3>().valid(); }
  uint64_t dir() const { return at<3>().as_uint64(); }
  bool has_mode() const { return at<4>().valid(); }
  uint32_t mode() const { return at<4>().as_uint32(); }
};

class Ext4AllocateInodeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4AllocateInodeFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kDirFieldNumber = 3,
    kModeFieldNumber = 4,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_dir(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_mode(uint32_t value) {
    AppendVarInt(4, value);
  }
};

class Ext4AllocateBlocksFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/11, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4AllocateBlocksFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4AllocateBlocksFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4AllocateBlocksFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_block() const { return at<3>().valid(); }
  uint64_t block() const { return at<3>().as_uint64(); }
  bool has_len() const { return at<4>().valid(); }
  uint32_t len() const { return at<4>().as_uint32(); }
  bool has_logical() const { return at<5>().valid(); }
  uint32_t logical() const { return at<5>().as_uint32(); }
  bool has_lleft() const { return at<6>().valid(); }
  uint32_t lleft() const { return at<6>().as_uint32(); }
  bool has_lright() const { return at<7>().valid(); }
  uint32_t lright() const { return at<7>().as_uint32(); }
  bool has_goal() const { return at<8>().valid(); }
  uint64_t goal() const { return at<8>().as_uint64(); }
  bool has_pleft() const { return at<9>().valid(); }
  uint64_t pleft() const { return at<9>().as_uint64(); }
  bool has_pright() const { return at<10>().valid(); }
  uint64_t pright() const { return at<10>().as_uint64(); }
  bool has_flags() const { return at<11>().valid(); }
  uint32_t flags() const { return at<11>().as_uint32(); }
};

class Ext4AllocateBlocksFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4AllocateBlocksFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kBlockFieldNumber = 3,
    kLenFieldNumber = 4,
    kLogicalFieldNumber = 5,
    kLleftFieldNumber = 6,
    kLrightFieldNumber = 7,
    kGoalFieldNumber = 8,
    kPleftFieldNumber = 9,
    kPrightFieldNumber = 10,
    kFlagsFieldNumber = 11,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_block(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_logical(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_lleft(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_lright(uint32_t value) {
    AppendVarInt(7, value);
  }
  void set_goal(uint64_t value) {
    AppendVarInt(8, value);
  }
  void set_pleft(uint64_t value) {
    AppendVarInt(9, value);
  }
  void set_pright(uint64_t value) {
    AppendVarInt(10, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(11, value);
  }
};

class Ext4AllocDaBlocksFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4AllocDaBlocksFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4AllocDaBlocksFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4AllocDaBlocksFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_data_blocks() const { return at<3>().valid(); }
  uint32_t data_blocks() const { return at<3>().as_uint32(); }
  bool has_meta_blocks() const { return at<4>().valid(); }
  uint32_t meta_blocks() const { return at<4>().as_uint32(); }
};

class Ext4AllocDaBlocksFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4AllocDaBlocksFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kDataBlocksFieldNumber = 3,
    kMetaBlocksFieldNumber = 4,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_data_blocks(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_meta_blocks(uint32_t value) {
    AppendVarInt(4, value);
  }
};

class Ext4SyncFileExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4SyncFileExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4SyncFileExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4SyncFileExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_ret() const { return at<3>().valid(); }
  int32_t ret() const { return at<3>().as_int32(); }
};

class Ext4SyncFileExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4SyncFileExitFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kRetFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(3, value);
  }
};

class Ext4SyncFileEnterFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4SyncFileEnterFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4SyncFileEnterFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4SyncFileEnterFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_parent() const { return at<3>().valid(); }
  uint64_t parent() const { return at<3>().as_uint64(); }
  bool has_datasync() const { return at<4>().valid(); }
  int32_t datasync() const { return at<4>().as_int32(); }
};

class Ext4SyncFileEnterFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4SyncFileEnterFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kParentFieldNumber = 3,
    kDatasyncFieldNumber = 4,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_parent(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_datasync(int32_t value) {
    AppendVarInt(4, value);
  }
};

class Ext4DaWriteEndFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4DaWriteEndFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4DaWriteEndFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4DaWriteEndFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_pos() const { return at<3>().valid(); }
  int64_t pos() const { return at<3>().as_int64(); }
  bool has_len() const { return at<4>().valid(); }
  uint32_t len() const { return at<4>().as_uint32(); }
  bool has_copied() const { return at<5>().valid(); }
  uint32_t copied() const { return at<5>().as_uint32(); }
};

class Ext4DaWriteEndFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4DaWriteEndFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPosFieldNumber = 3,
    kLenFieldNumber = 4,
    kCopiedFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pos(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_copied(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class Ext4DaWriteBeginFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  Ext4DaWriteBeginFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Ext4DaWriteBeginFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Ext4DaWriteBeginFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_pos() const { return at<3>().valid(); }
  int64_t pos() const { return at<3>().as_int64(); }
  bool has_len() const { return at<4>().valid(); }
  uint32_t len() const { return at<4>().as_uint32(); }
  bool has_flags() const { return at<5>().valid(); }
  uint32_t flags() const { return at<5>().as_uint32(); }
};

class Ext4DaWriteBeginFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = Ext4DaWriteBeginFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPosFieldNumber = 3,
    kLenFieldNumber = 4,
    kFlagsFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pos(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(5, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/f2fs.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_F2FS_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_F2FS_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class F2fsWriteEndFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsWriteEndFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsWriteEndFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsWriteEndFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_pos() const { return at<3>().valid(); }
  int64_t pos() const { return at<3>().as_int64(); }
  bool has_len() const { return at<4>().valid(); }
  uint32_t len() const { return at<4>().as_uint32(); }
  bool has_copied() const { return at<5>().valid(); }
  uint32_t copied() const { return at<5>().as_uint32(); }
};

class F2fsWriteEndFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsWriteEndFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPosFieldNumber = 3,
    kLenFieldNumber = 4,
    kCopiedFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pos(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_copied(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class F2fsWriteCheckpointFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsWriteCheckpointFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsWriteCheckpointFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsWriteCheckpointFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_is_umount() const { return at<2>().valid(); }
  uint32_t is_umount() const { return at<2>().as_uint32(); }
  bool has_msg() const { return at<3>().valid(); }
  ::protozero::ConstChars msg() const { return at<3>().as_string(); }
};

class F2fsWriteCheckpointFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsWriteCheckpointFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kIsUmountFieldNumber = 2,
    kMsgFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_is_umount(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_msg(const char* value) {
    AppendString(3, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_msg(const char* value, size_t size) {
    AppendBytes(3, value, size);
  }
};

class F2fsWriteBeginFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsWriteBeginFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsWriteBeginFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsWriteBeginFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_pos() const { return at<3>().valid(); }
  int64_t pos() const { return at<3>().as_int64(); }
  bool has_len() const { return at<4>().valid(); }
  uint32_t len() const { return at<4>().as_uint32(); }
  bool has_flags() const { return at<5>().valid(); }
  uint32_t flags() const { return at<5>().as_uint32(); }
};

class F2fsWriteBeginFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsWriteBeginFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPosFieldNumber = 3,
    kLenFieldNumber = 4,
    kFlagsFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pos(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class F2fsVmPageMkwriteFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsVmPageMkwriteFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsVmPageMkwriteFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsVmPageMkwriteFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_type() const { return at<3>().valid(); }
  int32_t type() const { return at<3>().as_int32(); }
  bool has_dir() const { return at<4>().valid(); }
  int32_t dir() const { return at<4>().as_int32(); }
  bool has_index() const { return at<5>().valid(); }
  uint64_t index() const { return at<5>().as_uint64(); }
  bool has_dirty() const { return at<6>().valid(); }
  int32_t dirty() const { return at<6>().as_int32(); }
};

class F2fsVmPageMkwriteFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsVmPageMkwriteFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kTypeFieldNumber = 3,
    kDirFieldNumber = 4,
    kIndexFieldNumber = 5,
    kDirtyFieldNumber = 6,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_type(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_dir(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_index(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_dirty(int32_t value) {
    AppendVarInt(6, value);
  }
};

class F2fsUnlinkExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsUnlinkExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsUnlinkExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsUnlinkExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_ret() const { return at<3>().valid(); }
  int32_t ret() const { return at<3>().as_int32(); }
};

class F2fsUnlinkExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsUnlinkExitFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kRetFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(3, value);
  }
};

class F2fsUnlinkEnterFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsUnlinkEnterFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsUnlinkEnterFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsUnlinkEnterFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_size() const { return at<3>().valid(); }
  int64_t size() const { return at<3>().as_int64(); }
  bool has_blocks() const { return at<4>().valid(); }
  uint64_t blocks() const { return at<4>().as_uint64(); }
  bool has_name() const { return at<5>().valid(); }
  ::protozero::ConstChars name() const { return at<5>().as_string(); }
};

class F2fsUnlinkEnterFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsUnlinkEnterFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kSizeFieldNumber = 3,
    kBlocksFieldNumber = 4,
    kNameFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_size(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_blocks(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_name(const char* value) {
    AppendString(5, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_name(const char* value, size_t size) {
    AppendBytes(5, value, size);
  }
};

class F2fsTruncatePartialNodesFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsTruncatePartialNodesFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsTruncatePartialNodesFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsTruncatePartialNodesFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_nid() const { return at<3>().valid(); }
  uint32_t nid() const { return at<3>().as_uint32(); }
  bool has_depth() const { return at<4>().valid(); }
  int32_t depth() const { return at<4>().as_int32(); }
  bool has_err() const { return at<5>().valid(); }
  int32_t err() const { return at<5>().as_int32(); }
};

class F2fsTruncatePartialNodesFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsTruncatePartialNodesFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kNidFieldNumber = 3,
    kDepthFieldNumber = 4,
    kErrFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_nid(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_depth(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_err(int32_t value) {
    AppendVarInt(5, value);
  }
};

class F2fsTruncateNodesExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsTruncateNodesExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsTruncateNodesExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsTruncateNodesExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_ret() const { return at<3>().valid(); }
  int32_t ret() const { return at<3>().as_int32(); }
};

class F2fsTruncateNodesExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsTruncateNodesExitFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kRetFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(3, value);
  }
};

class F2fsTruncateNodesEnterFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsTruncateNodesEnterFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsTruncateNodesEnterFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsTruncateNodesEnterFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_nid() const { return at<3>().valid(); }
  uint32_t nid() const { return at<3>().as_uint32(); }
  bool has_blk_addr() const { return at<4>().valid(); }
  uint32_t blk_addr() const { return at<4>().as_uint32(); }
};

class F2fsTruncateNodesEnterFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsTruncateNodesEnterFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kNidFieldNumber = 3,
    kBlkAddrFieldNumber = 4,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_nid(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_blk_addr(uint32_t value) {
    AppendVarInt(4, value);
  }
};

class F2fsTruncateNodeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsTruncateNodeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsTruncateNodeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsTruncateNodeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_nid() const { return at<3>().valid(); }
  uint32_t nid() const { return at<3>().as_uint32(); }
  bool has_blk_addr() const { return at<4>().valid(); }
  uint32_t blk_addr() const { return at<4>().as_uint32(); }
};

class F2fsTruncateNodeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsTruncateNodeFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kNidFieldNumber = 3,
    kBlkAddrFieldNumber = 4,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_nid(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_blk_addr(uint32_t value) {
    AppendVarInt(4, value);
  }
};

class F2fsTruncateInodeBlocksExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsTruncateInodeBlocksExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsTruncateInodeBlocksExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsTruncateInodeBlocksExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_ret() const { return at<3>().valid(); }
  int32_t ret() const { return at<3>().as_int32(); }
};

class F2fsTruncateInodeBlocksExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsTruncateInodeBlocksExitFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kRetFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(3, value);
  }
};

class F2fsTruncateInodeBlocksEnterFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsTruncateInodeBlocksEnterFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsTruncateInodeBlocksEnterFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsTruncateInodeBlocksEnterFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_size() const { return at<3>().valid(); }
  int64_t size() const { return at<3>().as_int64(); }
  bool has_blocks() const { return at<4>().valid(); }
  uint64_t blocks() const { return at<4>().as_uint64(); }
  bool has_from() const { return at<5>().valid(); }
  uint64_t from() const { return at<5>().as_uint64(); }
};

class F2fsTruncateInodeBlocksEnterFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsTruncateInodeBlocksEnterFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kSizeFieldNumber = 3,
    kBlocksFieldNumber = 4,
    kFromFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_size(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_blocks(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_from(uint64_t value) {
    AppendVarInt(5, value);
  }
};

class F2fsTruncateDataBlocksRangeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsTruncateDataBlocksRangeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsTruncateDataBlocksRangeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsTruncateDataBlocksRangeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_nid() const { return at<3>().valid(); }
  uint32_t nid() const { return at<3>().as_uint32(); }
  bool has_ofs() const { return at<4>().valid(); }
  uint32_t ofs() const { return at<4>().as_uint32(); }
  bool has_free() const { return at<5>().valid(); }
  int32_t free() const { return at<5>().as_int32(); }
};

class F2fsTruncateDataBlocksRangeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsTruncateDataBlocksRangeFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kNidFieldNumber = 3,
    kOfsFieldNumber = 4,
    kFreeFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_nid(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_ofs(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_free(int32_t value) {
    AppendVarInt(5, value);
  }
};

class F2fsTruncateBlocksExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsTruncateBlocksExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsTruncateBlocksExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsTruncateBlocksExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_ret() const { return at<3>().valid(); }
  int32_t ret() const { return at<3>().as_int32(); }
};

class F2fsTruncateBlocksExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsTruncateBlocksExitFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kRetFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(3, value);
  }
};

class F2fsTruncateBlocksEnterFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsTruncateBlocksEnterFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsTruncateBlocksEnterFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsTruncateBlocksEnterFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_size() const { return at<3>().valid(); }
  int64_t size() const { return at<3>().as_int64(); }
  bool has_blocks() const { return at<4>().valid(); }
  uint64_t blocks() const { return at<4>().as_uint64(); }
  bool has_from() const { return at<5>().valid(); }
  uint64_t from() const { return at<5>().as_uint64(); }
};

class F2fsTruncateBlocksEnterFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsTruncateBlocksEnterFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kSizeFieldNumber = 3,
    kBlocksFieldNumber = 4,
    kFromFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_size(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_blocks(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_from(uint64_t value) {
    AppendVarInt(5, value);
  }
};

class F2fsTruncateFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsTruncateFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsTruncateFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsTruncateFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_pino() const { return at<3>().valid(); }
  uint64_t pino() const { return at<3>().as_uint64(); }
  bool has_mode() const { return at<4>().valid(); }
  uint32_t mode() const { return at<4>().as_uint32(); }
  bool has_size() const { return at<5>().valid(); }
  int64_t size() const { return at<5>().as_int64(); }
  bool has_nlink() const { return at<6>().valid(); }
  uint32_t nlink() const { return at<6>().as_uint32(); }
  bool has_blocks() const { return at<7>().valid(); }
  uint64_t blocks() const { return at<7>().as_uint64(); }
  bool has_advise() const { return at<8>().valid(); }
  uint32_t advise() const { return at<8>().as_uint32(); }
};

class F2fsTruncateFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsTruncateFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPinoFieldNumber = 3,
    kModeFieldNumber = 4,
    kSizeFieldNumber = 5,
    kNlinkFieldNumber = 6,
    kBlocksFieldNumber = 7,
    kAdviseFieldNumber = 8,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pino(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_mode(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_size(int64_t value) {
    AppendVarInt(5, value);
  }
  void set_nlink(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_blocks(uint64_t value) {
    AppendVarInt(7, value);
  }
  void set_advise(uint32_t value) {
    AppendVarInt(8, value);
  }
};

class F2fsSyncFsFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsSyncFsFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsSyncFsFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsSyncFsFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_dirty() const { return at<2>().valid(); }
  int32_t dirty() const { return at<2>().as_int32(); }
  bool has_wait() const { return at<3>().valid(); }
  int32_t wait() const { return at<3>().as_int32(); }
};

class F2fsSyncFsFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsSyncFsFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kDirtyFieldNumber = 2,
    kWaitFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_dirty(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_wait(int32_t value) {
    AppendVarInt(3, value);
  }
};

class F2fsSyncFileExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsSyncFileExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsSyncFileExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsSyncFileExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_need_cp() const { return at<3>().valid(); }
  uint32_t need_cp() const { return at<3>().as_uint32(); }
  bool has_datasync() const { return at<4>().valid(); }
  int32_t datasync() const { return at<4>().as_int32(); }
  bool has_ret() const { return at<5>().valid(); }
  int32_t ret() const { return at<5>().as_int32(); }
};

class F2fsSyncFileExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsSyncFileExitFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kNeedCpFieldNumber = 3,
    kDatasyncFieldNumber = 4,
    kRetFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_need_cp(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_datasync(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(5, value);
  }
};

class F2fsSyncFileEnterFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsSyncFileEnterFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsSyncFileEnterFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsSyncFileEnterFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_pino() const { return at<3>().valid(); }
  uint64_t pino() const { return at<3>().as_uint64(); }
  bool has_mode() const { return at<4>().valid(); }
  uint32_t mode() const { return at<4>().as_uint32(); }
  bool has_size() const { return at<5>().valid(); }
  int64_t size() const { return at<5>().as_int64(); }
  bool has_nlink() const { return at<6>().valid(); }
  uint32_t nlink() const { return at<6>().as_uint32(); }
  bool has_blocks() const { return at<7>().valid(); }
  uint64_t blocks() const { return at<7>().as_uint64(); }
  bool has_advise() const { return at<8>().valid(); }
  uint32_t advise() const { return at<8>().as_uint32(); }
};

class F2fsSyncFileEnterFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsSyncFileEnterFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPinoFieldNumber = 3,
    kModeFieldNumber = 4,
    kSizeFieldNumber = 5,
    kNlinkFieldNumber = 6,
    kBlocksFieldNumber = 7,
    kAdviseFieldNumber = 8,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pino(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_mode(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_size(int64_t value) {
    AppendVarInt(5, value);
  }
  void set_nlink(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_blocks(uint64_t value) {
    AppendVarInt(7, value);
  }
  void set_advise(uint32_t value) {
    AppendVarInt(8, value);
  }
};

class F2fsSubmitWritePageFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsSubmitWritePageFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsSubmitWritePageFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsSubmitWritePageFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_type() const { return at<3>().valid(); }
  int32_t type() const { return at<3>().as_int32(); }
  bool has_index() const { return at<4>().valid(); }
  uint64_t index() const { return at<4>().as_uint64(); }
  bool has_block() const { return at<5>().valid(); }
  uint32_t block() const { return at<5>().as_uint32(); }
};

class F2fsSubmitWritePageFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsSubmitWritePageFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kTypeFieldNumber = 3,
    kIndexFieldNumber = 4,
    kBlockFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_type(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_index(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_block(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class F2fsSetPageDirtyFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsSetPageDirtyFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsSetPageDirtyFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsSetPageDirtyFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_type() const { return at<3>().valid(); }
  int32_t type() const { return at<3>().as_int32(); }
  bool has_dir() const { return at<4>().valid(); }
  int32_t dir() const { return at<4>().as_int32(); }
  bool has_index() const { return at<5>().valid(); }
  uint64_t index() const { return at<5>().as_uint64(); }
  bool has_dirty() const { return at<6>().valid(); }
  int32_t dirty() const { return at<6>().as_int32(); }
};

class F2fsSetPageDirtyFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsSetPageDirtyFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kTypeFieldNumber = 3,
    kDirFieldNumber = 4,
    kIndexFieldNumber = 5,
    kDirtyFieldNumber = 6,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_type(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_dir(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_index(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_dirty(int32_t value) {
    AppendVarInt(6, value);
  }
};

class F2fsReserveNewBlockFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsReserveNewBlockFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsReserveNewBlockFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsReserveNewBlockFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_nid() const { return at<2>().valid(); }
  uint32_t nid() const { return at<2>().as_uint32(); }
  bool has_ofs_in_node() const { return at<3>().valid(); }
  uint32_t ofs_in_node() const { return at<3>().as_uint32(); }
};

class F2fsReserveNewBlockFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsReserveNewBlockFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kNidFieldNumber = 2,
    kOfsInNodeFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_nid(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_ofs_in_node(uint32_t value) {
    AppendVarInt(3, value);
  }
};

class F2fsReadpageFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsReadpageFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsReadpageFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsReadpageFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_index() const { return at<3>().valid(); }
  uint64_t index() const { return at<3>().as_uint64(); }
  bool has_blkaddr() const { return at<4>().valid(); }
  uint64_t blkaddr() const { return at<4>().as_uint64(); }
  bool has_type() const { return at<5>().valid(); }
  int32_t type() const { return at<5>().as_int32(); }
};

class F2fsReadpageFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsReadpageFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kIndexFieldNumber = 3,
    kBlkaddrFieldNumber = 4,
    kTypeFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_index(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_blkaddr(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_type(int32_t value) {
    AppendVarInt(5, value);
  }
};

class F2fsNewInodeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsNewInodeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsNewInodeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsNewInodeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_ret() const { return at<3>().valid(); }
  int32_t ret() const { return at<3>().as_int32(); }
};

class F2fsNewInodeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsNewInodeFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kRetFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(3, value);
  }
};

class F2fsIgetExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsIgetExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsIgetExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsIgetExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_ret() const { return at<3>().valid(); }
  int32_t ret() const { return at<3>().as_int32(); }
};

class F2fsIgetExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsIgetExitFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kRetFieldNumber = 3,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(3, value);
  }
};

class F2fsIgetFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsIgetFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsIgetFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsIgetFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_pino() const { return at<3>().valid(); }
  uint64_t pino() const { return at<3>().as_uint64(); }
  bool has_mode() const { return at<4>().valid(); }
  uint32_t mode() const { return at<4>().as_uint32(); }
  bool has_size() const { return at<5>().valid(); }
  int64_t size() const { return at<5>().as_int64(); }
  bool has_nlink() const { return at<6>().valid(); }
  uint32_t nlink() const { return at<6>().as_uint32(); }
  bool has_blocks() const { return at<7>().valid(); }
  uint64_t blocks() const { return at<7>().as_uint64(); }
  bool has_advise() const { return at<8>().valid(); }
  uint32_t advise() const { return at<8>().as_uint32(); }
};

class F2fsIgetFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsIgetFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPinoFieldNumber = 3,
    kModeFieldNumber = 4,
    kSizeFieldNumber = 5,
    kNlinkFieldNumber = 6,
    kBlocksFieldNumber = 7,
    kAdviseFieldNumber = 8,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pino(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_mode(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_size(int64_t value) {
    AppendVarInt(5, value);
  }
  void set_nlink(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_blocks(uint64_t value) {
    AppendVarInt(7, value);
  }
  void set_advise(uint32_t value) {
    AppendVarInt(8, value);
  }
};

class F2fsGetVictimFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/10, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsGetVictimFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsGetVictimFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsGetVictimFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_type() const { return at<2>().valid(); }
  int32_t type() const { return at<2>().as_int32(); }
  bool has_gc_type() const { return at<3>().valid(); }
  int32_t gc_type() const { return at<3>().as_int32(); }
  bool has_alloc_mode() const { return at<4>().valid(); }
  int32_t alloc_mode() const { return at<4>().as_int32(); }
  bool has_gc_mode() const { return at<5>().valid(); }
  int32_t gc_mode() const { return at<5>().as_int32(); }
  bool has_victim() const { return at<6>().valid(); }
  uint32_t victim() const { return at<6>().as_uint32(); }
  bool has_ofs_unit() const { return at<7>().valid(); }
  uint32_t ofs_unit() const { return at<7>().as_uint32(); }
  bool has_pre_victim() const { return at<8>().valid(); }
  uint32_t pre_victim() const { return at<8>().as_uint32(); }
  bool has_prefree() const { return at<9>().valid(); }
  uint32_t prefree() const { return at<9>().as_uint32(); }
  bool has_free() const { return at<10>().valid(); }
  uint32_t free() const { return at<10>().as_uint32(); }
};

class F2fsGetVictimFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsGetVictimFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kTypeFieldNumber = 2,
    kGcTypeFieldNumber = 3,
    kAllocModeFieldNumber = 4,
    kGcModeFieldNumber = 5,
    kVictimFieldNumber = 6,
    kOfsUnitFieldNumber = 7,
    kPreVictimFieldNumber = 8,
    kPrefreeFieldNumber = 9,
    kFreeFieldNumber = 10,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_type(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_gc_type(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_alloc_mode(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_gc_mode(int32_t value) {
    AppendVarInt(5, value);
  }
  void set_victim(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_ofs_unit(uint32_t value) {
    AppendVarInt(7, value);
  }
  void set_pre_victim(uint32_t value) {
    AppendVarInt(8, value);
  }
  void set_prefree(uint32_t value) {
    AppendVarInt(9, value);
  }
  void set_free(uint32_t value) {
    AppendVarInt(10, value);
  }
};

class F2fsGetDataBlockFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsGetDataBlockFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsGetDataBlockFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsGetDataBlockFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_iblock() const { return at<3>().valid(); }
  uint64_t iblock() const { return at<3>().as_uint64(); }
  bool has_bh_start() const { return at<4>().valid(); }
  uint64_t bh_start() const { return at<4>().as_uint64(); }
  bool has_bh_size() const { return at<5>().valid(); }
  uint64_t bh_size() const { return at<5>().as_uint64(); }
  bool has_ret() const { return at<6>().valid(); }
  int32_t ret() const { return at<6>().as_int32(); }
};

class F2fsGetDataBlockFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsGetDataBlockFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kIblockFieldNumber = 3,
    kBhStartFieldNumber = 4,
    kBhSizeFieldNumber = 5,
    kRetFieldNumber = 6,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_iblock(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_bh_start(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_bh_size(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(6, value);
  }
};

class F2fsFallocateFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsFallocateFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsFallocateFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsFallocateFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_mode() const { return at<3>().valid(); }
  int32_t mode() const { return at<3>().as_int32(); }
  bool has_offset() const { return at<4>().valid(); }
  int64_t offset() const { return at<4>().as_int64(); }
  bool has_len() const { return at<5>().valid(); }
  int64_t len() const { return at<5>().as_int64(); }
  bool has_size() const { return at<6>().valid(); }
  int64_t size() const { return at<6>().as_int64(); }
  bool has_blocks() const { return at<7>().valid(); }
  uint64_t blocks() const { return at<7>().as_uint64(); }
  bool has_ret() const { return at<8>().valid(); }
  int32_t ret() const { return at<8>().as_int32(); }
};

class F2fsFallocateFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsFallocateFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kModeFieldNumber = 3,
    kOffsetFieldNumber = 4,
    kLenFieldNumber = 5,
    kSizeFieldNumber = 6,
    kBlocksFieldNumber = 7,
    kRetFieldNumber = 8,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_mode(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_offset(int64_t value) {
    AppendVarInt(4, value);
  }
  void set_len(int64_t value) {
    AppendVarInt(5, value);
  }
  void set_size(int64_t value) {
    AppendVarInt(6, value);
  }
  void set_blocks(uint64_t value) {
    AppendVarInt(7, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(8, value);
  }
};

class F2fsEvictInodeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsEvictInodeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsEvictInodeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsEvictInodeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_ino() const { return at<2>().valid(); }
  uint64_t ino() const { return at<2>().as_uint64(); }
  bool has_pino() const { return at<3>().valid(); }
  uint64_t pino() const { return at<3>().as_uint64(); }
  bool has_mode() const { return at<4>().valid(); }
  uint32_t mode() const { return at<4>().as_uint32(); }
  bool has_size() const { return at<5>().valid(); }
  int64_t size() const { return at<5>().as_int64(); }
  bool has_nlink() const { return at<6>().valid(); }
  uint32_t nlink() const { return at<6>().as_uint32(); }
  bool has_blocks() const { return at<7>().valid(); }
  uint64_t blocks() const { return at<7>().as_uint64(); }
  bool has_advise() const { return at<8>().valid(); }
  uint32_t advise() const { return at<8>().as_uint32(); }
};

class F2fsEvictInodeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsEvictInodeFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kInoFieldNumber = 2,
    kPinoFieldNumber = 3,
    kModeFieldNumber = 4,
    kSizeFieldNumber = 5,
    kNlinkFieldNumber = 6,
    kBlocksFieldNumber = 7,
    kAdviseFieldNumber = 8,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pino(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_mode(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_size(int64_t value) {
    AppendVarInt(5, value);
  }
  void set_nlink(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_blocks(uint64_t value) {
    AppendVarInt(7, value);
  }
  void set_advise(uint32_t value) {
    AppendVarInt(8, value);
  }
};

class F2fsDoSubmitBioFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  F2fsDoSubmitBioFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit F2fsDoSubmitBioFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit F2fsDoSubmitBioFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_dev() const { return at<1>().valid(); }
  uint64_t dev() const { return at<1>().as_uint64(); }
  bool has_btype() const { return at<2>().valid(); }
  int32_t btype() const { return at<2>().as_int32(); }
  bool has_sync() const { return at<3>().valid(); }
  uint32_t sync() const { return at<3>().as_uint32(); }
  bool has_sector() const { return at<4>().valid(); }
  uint64_t sector() const { return at<4>().as_uint64(); }
  bool has_size() const { return at<5>().valid(); }
  uint32_t size() const { return at<5>().as_uint32(); }
};

class F2fsDoSubmitBioFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = F2fsDoSubmitBioFtraceEvent_Decoder;
  enum : int32_t {
    kDevFieldNumber = 1,
    kBtypeFieldNumber = 2,
    kSyncFieldNumber = 3,
    kSectorFieldNumber = 4,
    kSizeFieldNumber = 5,
  };
  void set_dev(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_btype(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_sync(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_sector(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_size(uint32_t value) {
    AppendVarInt(5, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/fence.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_FENCE_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_FENCE_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class FenceSignaledFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  FenceSignaledFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit FenceSignaledFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit FenceSignaledFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_context() const { return at<1>().valid(); }
  uint32_t context() const { return at<1>().as_uint32(); }
  bool has_driver() const { return at<2>().valid(); }
  ::protozero::ConstChars driver() const { return at<2>().as_string(); }
  bool has_seqno() const { return at<3>().valid(); }
  uint32_t seqno() const { return at<3>().as_uint32(); }
  bool has_timeline() const { return at<4>().valid(); }
  ::protozero::ConstChars timeline() const { return at<4>().as_string(); }
};

class FenceSignaledFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = FenceSignaledFtraceEvent_Decoder;
  enum : int32_t {
    kContextFieldNumber = 1,
    kDriverFieldNumber = 2,
    kSeqnoFieldNumber = 3,
    kTimelineFieldNumber = 4,
  };
  void set_context(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_driver(const char* value) {
    AppendString(2, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_driver(const char* value, size_t size) {
    AppendBytes(2, value, size);
  }
  void set_seqno(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_timeline(const char* value) {
    AppendString(4, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_timeline(const char* value, size_t size) {
    AppendBytes(4, value, size);
  }
};

class FenceEnableSignalFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  FenceEnableSignalFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit FenceEnableSignalFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit FenceEnableSignalFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_context() const { return at<1>().valid(); }
  uint32_t context() const { return at<1>().as_uint32(); }
  bool has_driver() const { return at<2>().valid(); }
  ::protozero::ConstChars driver() const { return at<2>().as_string(); }
  bool has_seqno() const { return at<3>().valid(); }
  uint32_t seqno() const { return at<3>().as_uint32(); }
  bool has_timeline() const { return at<4>().valid(); }
  ::protozero::ConstChars timeline() const { return at<4>().as_string(); }
};

class FenceEnableSignalFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = FenceEnableSignalFtraceEvent_Decoder;
  enum : int32_t {
    kContextFieldNumber = 1,
    kDriverFieldNumber = 2,
    kSeqnoFieldNumber = 3,
    kTimelineFieldNumber = 4,
  };
  void set_context(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_driver(const char* value) {
    AppendString(2, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_driver(const char* value, size_t size) {
    AppendBytes(2, value, size);
  }
  void set_seqno(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_timeline(const char* value) {
    AppendString(4, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_timeline(const char* value, size_t size) {
    AppendBytes(4, value, size);
  }
};

class FenceDestroyFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  FenceDestroyFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit FenceDestroyFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit FenceDestroyFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_context() const { return at<1>().valid(); }
  uint32_t context() const { return at<1>().as_uint32(); }
  bool has_driver() const { return at<2>().valid(); }
  ::protozero::ConstChars driver() const { return at<2>().as_string(); }
  bool has_seqno() const { return at<3>().valid(); }
  uint32_t seqno() const { return at<3>().as_uint32(); }
  bool has_timeline() const { return at<4>().valid(); }
  ::protozero::ConstChars timeline() const { return at<4>().as_string(); }
};

class FenceDestroyFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = FenceDestroyFtraceEvent_Decoder;
  enum : int32_t {
    kContextFieldNumber = 1,
    kDriverFieldNumber = 2,
    kSeqnoFieldNumber = 3,
    kTimelineFieldNumber = 4,
  };
  void set_context(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_driver(const char* value) {
    AppendString(2, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_driver(const char* value, size_t size) {
    AppendBytes(2, value, size);
  }
  void set_seqno(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_timeline(const char* value) {
    AppendString(4, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_timeline(const char* value, size_t size) {
    AppendBytes(4, value, size);
  }
};

class FenceInitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  FenceInitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit FenceInitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit FenceInitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_context() const { return at<1>().valid(); }
  uint32_t context() const { return at<1>().as_uint32(); }
  bool has_driver() const { return at<2>().valid(); }
  ::protozero::ConstChars driver() const { return at<2>().as_string(); }
  bool has_seqno() const { return at<3>().valid(); }
  uint32_t seqno() const { return at<3>().as_uint32(); }
  bool has_timeline() const { return at<4>().valid(); }
  ::protozero::ConstChars timeline() const { return at<4>().as_string(); }
};

class FenceInitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = FenceInitFtraceEvent_Decoder;
  enum : int32_t {
    kContextFieldNumber = 1,
    kDriverFieldNumber = 2,
    kSeqnoFieldNumber = 3,
    kTimelineFieldNumber = 4,
  };
  void set_context(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_driver(const char* value) {
    AppendString(2, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_driver(const char* value, size_t size) {
    AppendBytes(2, value, size);
  }
  void set_seqno(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_timeline(const char* value) {
    AppendString(4, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_timeline(const char* value, size_t size) {
    AppendBytes(4, value, size);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/filemap.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_FILEMAP_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_FILEMAP_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class MmFilemapDeleteFromPageCacheFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmFilemapDeleteFromPageCacheFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmFilemapDeleteFromPageCacheFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmFilemapDeleteFromPageCacheFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_pfn() const { return at<1>().valid(); }
  uint64_t pfn() const { return at<1>().as_uint64(); }
  bool has_i_ino() const { return at<2>().valid(); }
  uint64_t i_ino() const { return at<2>().as_uint64(); }
  bool has_index() const { return at<3>().valid(); }
  uint64_t index() const { return at<3>().as_uint64(); }
  bool has_s_dev() const { return at<4>().valid(); }
  uint64_t s_dev() const { return at<4>().as_uint64(); }
  bool has_page() const { return at<5>().valid(); }
  uint64_t page() const { return at<5>().as_uint64(); }
};

class MmFilemapDeleteFromPageCacheFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmFilemapDeleteFromPageCacheFtraceEvent_Decoder;
  enum : int32_t {
    kPfnFieldNumber = 1,
    kIInoFieldNumber = 2,
    kIndexFieldNumber = 3,
    kSDevFieldNumber = 4,
    kPageFieldNumber = 5,
  };
  void set_pfn(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_i_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_index(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_s_dev(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_page(uint64_t value) {
    AppendVarInt(5, value);
  }
};

class MmFilemapAddToPageCacheFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmFilemapAddToPageCacheFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmFilemapAddToPageCacheFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmFilemapAddToPageCacheFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_pfn() const { return at<1>().valid(); }
  uint64_t pfn() const { return at<1>().as_uint64(); }
  bool has_i_ino() const { return at<2>().valid(); }
  uint64_t i_ino() const { return at<2>().as_uint64(); }
  bool has_index() const { return at<3>().valid(); }
  uint64_t index() const { return at<3>().as_uint64(); }
  bool has_s_dev() const { return at<4>().valid(); }
  uint64_t s_dev() const { return at<4>().as_uint64(); }
  bool has_page() const { return at<5>().valid(); }
  uint64_t page() const { return at<5>().as_uint64(); }
};

class MmFilemapAddToPageCacheFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmFilemapAddToPageCacheFtraceEvent_Decoder;
  enum : int32_t {
    kPfnFieldNumber = 1,
    kIInoFieldNumber = 2,
    kIndexFieldNumber = 3,
    kSDevFieldNumber = 4,
    kPageFieldNumber = 5,
  };
  void set_pfn(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_i_ino(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_index(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_s_dev(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_page(uint64_t value) {
    AppendVarInt(5, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/ftrace.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_FTRACE_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_FTRACE_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class PrintFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  PrintFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit PrintFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit PrintFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_ip() const { return at<1>().valid(); }
  uint64_t ip() const { return at<1>().as_uint64(); }
  bool has_buf() const { return at<2>().valid(); }
  ::protozero::ConstChars buf() const { return at<2>().as_string(); }
};

class PrintFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = PrintFtraceEvent_Decoder;
  enum : int32_t {
    kIpFieldNumber = 1,
    kBufFieldNumber = 2,
  };
  void set_ip(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_buf(const char* value) {
    AppendString(2, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_buf(const char* value, size_t size) {
    AppendBytes(2, value, size);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/gpu.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_GPU_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_GPU_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class GpuSchedCompleteFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  GpuSchedCompleteFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit GpuSchedCompleteFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit GpuSchedCompleteFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_ctx_id() const { return at<1>().valid(); }
  uint32_t ctx_id() const { return at<1>().as_uint32(); }
  bool has_job_id() const { return at<2>().valid(); }
  uint32_t job_id() const { return at<2>().as_uint32(); }
  bool has_msg() const { return at<3>().valid(); }
  ::protozero::ConstChars msg() const { return at<3>().as_string(); }
  bool has_priority() const { return at<4>().valid(); }
  uint32_t priority() const { return at<4>().as_uint32(); }
  bool has_submission_id() const { return at<5>().valid(); }
  uint32_t submission_id() const { return at<5>().as_uint32(); }
};

class GpuSchedCompleteFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = GpuSchedCompleteFtraceEvent_Decoder;
  enum : int32_t {
    kCtxIdFieldNumber = 1,
    kJobIdFieldNumber = 2,
    kMsgFieldNumber = 3,
    kPriorityFieldNumber = 4,
    kSubmissionIdFieldNumber = 5,
  };
  void set_ctx_id(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_job_id(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_msg(const char* value) {
    AppendString(3, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_msg(const char* value, size_t size) {
    AppendBytes(3, value, size);
  }
  void set_priority(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_submission_id(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class GpuSchedSubmitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  GpuSchedSubmitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit GpuSchedSubmitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit GpuSchedSubmitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_ctx_id() const { return at<1>().valid(); }
  uint32_t ctx_id() const { return at<1>().as_uint32(); }
  bool has_hwqueue_id() const { return at<2>().valid(); }
  uint32_t hwqueue_id() const { return at<2>().as_uint32(); }
  bool has_job_id() const { return at<3>().valid(); }
  uint32_t job_id() const { return at<3>().as_uint32(); }
  bool has_priority() const { return at<4>().valid(); }
  uint32_t priority() const { return at<4>().as_uint32(); }
  bool has_submission_id() const { return at<5>().valid(); }
  uint32_t submission_id() const { return at<5>().as_uint32(); }
};

class GpuSchedSubmitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = GpuSchedSubmitFtraceEvent_Decoder;
  enum : int32_t {
    kCtxIdFieldNumber = 1,
    kHwqueueIdFieldNumber = 2,
    kJobIdFieldNumber = 3,
    kPriorityFieldNumber = 4,
    kSubmissionIdFieldNumber = 5,
  };
  void set_ctx_id(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_hwqueue_id(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_job_id(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_priority(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_submission_id(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class GpuSchedEnqueueFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  GpuSchedEnqueueFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit GpuSchedEnqueueFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit GpuSchedEnqueueFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_ctx_id() const { return at<1>().valid(); }
  uint32_t ctx_id() const { return at<1>().as_uint32(); }
  bool has_job_id() const { return at<2>().valid(); }
  uint32_t job_id() const { return at<2>().as_uint32(); }
  bool has_priority() const { return at<3>().valid(); }
  uint32_t priority() const { return at<3>().as_uint32(); }
  bool has_submission_id() const { return at<4>().valid(); }
  uint32_t submission_id() const { return at<4>().as_uint32(); }
};

class GpuSchedEnqueueFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = GpuSchedEnqueueFtraceEvent_Decoder;
  enum : int32_t {
    kCtxIdFieldNumber = 1,
    kJobIdFieldNumber = 2,
    kPriorityFieldNumber = 3,
    kSubmissionIdFieldNumber = 4,
  };
  void set_ctx_id(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_job_id(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_priority(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_submission_id(uint32_t value) {
    AppendVarInt(4, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/i2c.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_I2C_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_I2C_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class SmbusReplyFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SmbusReplyFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SmbusReplyFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SmbusReplyFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_adapter_nr() const { return at<1>().valid(); }
  int32_t adapter_nr() const { return at<1>().as_int32(); }
  bool has_addr() const { return at<2>().valid(); }
  uint32_t addr() const { return at<2>().as_uint32(); }
  bool has_flags() const { return at<3>().valid(); }
  uint32_t flags() const { return at<3>().as_uint32(); }
  bool has_command() const { return at<4>().valid(); }
  uint32_t command() const { return at<4>().as_uint32(); }
  bool has_len() const { return at<5>().valid(); }
  uint32_t len() const { return at<5>().as_uint32(); }
  bool has_protocol() const { return at<6>().valid(); }
  uint32_t protocol() const { return at<6>().as_uint32(); }
};

class SmbusReplyFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SmbusReplyFtraceEvent_Decoder;
  enum : int32_t {
    kAdapterNrFieldNumber = 1,
    kAddrFieldNumber = 2,
    kFlagsFieldNumber = 3,
    kCommandFieldNumber = 4,
    kLenFieldNumber = 5,
    kProtocolFieldNumber = 6,
  };
  void set_adapter_nr(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_addr(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_command(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_protocol(uint32_t value) {
    AppendVarInt(6, value);
  }
};

class SmbusResultFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/7, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SmbusResultFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SmbusResultFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SmbusResultFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_adapter_nr() const { return at<1>().valid(); }
  int32_t adapter_nr() const { return at<1>().as_int32(); }
  bool has_addr() const { return at<2>().valid(); }
  uint32_t addr() const { return at<2>().as_uint32(); }
  bool has_flags() const { return at<3>().valid(); }
  uint32_t flags() const { return at<3>().as_uint32(); }
  bool has_read_write() const { return at<4>().valid(); }
  uint32_t read_write() const { return at<4>().as_uint32(); }
  bool has_command() const { return at<5>().valid(); }
  uint32_t command() const { return at<5>().as_uint32(); }
  bool has_res() const { return at<6>().valid(); }
  int32_t res() const { return at<6>().as_int32(); }
  bool has_protocol() const { return at<7>().valid(); }
  uint32_t protocol() const { return at<7>().as_uint32(); }
};

class SmbusResultFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SmbusResultFtraceEvent_Decoder;
  enum : int32_t {
    kAdapterNrFieldNumber = 1,
    kAddrFieldNumber = 2,
    kFlagsFieldNumber = 3,
    kReadWriteFieldNumber = 4,
    kCommandFieldNumber = 5,
    kResFieldNumber = 6,
    kProtocolFieldNumber = 7,
  };
  void set_adapter_nr(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_addr(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_read_write(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_command(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_res(int32_t value) {
    AppendVarInt(6, value);
  }
  void set_protocol(uint32_t value) {
    AppendVarInt(7, value);
  }
};

class SmbusWriteFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SmbusWriteFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SmbusWriteFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SmbusWriteFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_adapter_nr() const { return at<1>().valid(); }
  int32_t adapter_nr() const { return at<1>().as_int32(); }
  bool has_addr() const { return at<2>().valid(); }
  uint32_t addr() const { return at<2>().as_uint32(); }
  bool has_flags() const { return at<3>().valid(); }
  uint32_t flags() const { return at<3>().as_uint32(); }
  bool has_command() const { return at<4>().valid(); }
  uint32_t command() const { return at<4>().as_uint32(); }
  bool has_len() const { return at<5>().valid(); }
  uint32_t len() const { return at<5>().as_uint32(); }
  bool has_protocol() const { return at<6>().valid(); }
  uint32_t protocol() const { return at<6>().as_uint32(); }
};

class SmbusWriteFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SmbusWriteFtraceEvent_Decoder;
  enum : int32_t {
    kAdapterNrFieldNumber = 1,
    kAddrFieldNumber = 2,
    kFlagsFieldNumber = 3,
    kCommandFieldNumber = 4,
    kLenFieldNumber = 5,
    kProtocolFieldNumber = 6,
  };
  void set_adapter_nr(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_addr(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_command(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_protocol(uint32_t value) {
    AppendVarInt(6, value);
  }
};

class SmbusReadFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SmbusReadFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SmbusReadFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SmbusReadFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_adapter_nr() const { return at<1>().valid(); }
  int32_t adapter_nr() const { return at<1>().as_int32(); }
  bool has_flags() const { return at<2>().valid(); }
  uint32_t flags() const { return at<2>().as_uint32(); }
  bool has_addr() const { return at<3>().valid(); }
  uint32_t addr() const { return at<3>().as_uint32(); }
  bool has_command() const { return at<4>().valid(); }
  uint32_t command() const { return at<4>().as_uint32(); }
  bool has_protocol() const { return at<5>().valid(); }
  uint32_t protocol() const { return at<5>().as_uint32(); }
};

class SmbusReadFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SmbusReadFtraceEvent_Decoder;
  enum : int32_t {
    kAdapterNrFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kAddrFieldNumber = 3,
    kCommandFieldNumber = 4,
    kProtocolFieldNumber = 5,
  };
  void set_adapter_nr(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_addr(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_command(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_protocol(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class I2cReplyFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  I2cReplyFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit I2cReplyFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit I2cReplyFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_adapter_nr() const { return at<1>().valid(); }
  int32_t adapter_nr() const { return at<1>().as_int32(); }
  bool has_msg_nr() const { return at<2>().valid(); }
  uint32_t msg_nr() const { return at<2>().as_uint32(); }
  bool has_addr() const { return at<3>().valid(); }
  uint32_t addr() const { return at<3>().as_uint32(); }
  bool has_flags() const { return at<4>().valid(); }
  uint32_t flags() const { return at<4>().as_uint32(); }
  bool has_len() const { return at<5>().valid(); }
  uint32_t len() const { return at<5>().as_uint32(); }
  bool has_buf() const { return at<6>().valid(); }
  uint32_t buf() const { return at<6>().as_uint32(); }
};

class I2cReplyFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = I2cReplyFtraceEvent_Decoder;
  enum : int32_t {
    kAdapterNrFieldNumber = 1,
    kMsgNrFieldNumber = 2,
    kAddrFieldNumber = 3,
    kFlagsFieldNumber = 4,
    kLenFieldNumber = 5,
    kBufFieldNumber = 6,
  };
  void set_adapter_nr(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_msg_nr(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_addr(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_buf(uint32_t value) {
    AppendVarInt(6, value);
  }
};

class I2cResultFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  I2cResultFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit I2cResultFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit I2cResultFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_adapter_nr() const { return at<1>().valid(); }
  int32_t adapter_nr() const { return at<1>().as_int32(); }
  bool has_nr_msgs() const { return at<2>().valid(); }
  uint32_t nr_msgs() const { return at<2>().as_uint32(); }
  bool has_ret() const { return at<3>().valid(); }
  int32_t ret() const { return at<3>().as_int32(); }
};

class I2cResultFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = I2cResultFtraceEvent_Decoder;
  enum : int32_t {
    kAdapterNrFieldNumber = 1,
    kNrMsgsFieldNumber = 2,
    kRetFieldNumber = 3,
  };
  void set_adapter_nr(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_nr_msgs(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(3, value);
  }
};

class I2cWriteFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  I2cWriteFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit I2cWriteFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit I2cWriteFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_adapter_nr() const { return at<1>().valid(); }
  int32_t adapter_nr() const { return at<1>().as_int32(); }
  bool has_msg_nr() const { return at<2>().valid(); }
  uint32_t msg_nr() const { return at<2>().as_uint32(); }
  bool has_addr() const { return at<3>().valid(); }
  uint32_t addr() const { return at<3>().as_uint32(); }
  bool has_flags() const { return at<4>().valid(); }
  uint32_t flags() const { return at<4>().as_uint32(); }
  bool has_len() const { return at<5>().valid(); }
  uint32_t len() const { return at<5>().as_uint32(); }
  bool has_buf() const { return at<6>().valid(); }
  uint32_t buf() const { return at<6>().as_uint32(); }
};

class I2cWriteFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = I2cWriteFtraceEvent_Decoder;
  enum : int32_t {
    kAdapterNrFieldNumber = 1,
    kMsgNrFieldNumber = 2,
    kAddrFieldNumber = 3,
    kFlagsFieldNumber = 4,
    kLenFieldNumber = 5,
    kBufFieldNumber = 6,
  };
  void set_adapter_nr(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_msg_nr(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_addr(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_buf(uint32_t value) {
    AppendVarInt(6, value);
  }
};

class I2cReadFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  I2cReadFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit I2cReadFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit I2cReadFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_adapter_nr() const { return at<1>().valid(); }
  int32_t adapter_nr() const { return at<1>().as_int32(); }
  bool has_msg_nr() const { return at<2>().valid(); }
  uint32_t msg_nr() const { return at<2>().as_uint32(); }
  bool has_addr() const { return at<3>().valid(); }
  uint32_t addr() const { return at<3>().as_uint32(); }
  bool has_flags() const { return at<4>().valid(); }
  uint32_t flags() const { return at<4>().as_uint32(); }
  bool has_len() const { return at<5>().valid(); }
  uint32_t len() const { return at<5>().as_uint32(); }
};

class I2cReadFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = I2cReadFtraceEvent_Decoder;
  enum : int32_t {
    kAdapterNrFieldNumber = 1,
    kMsgNrFieldNumber = 2,
    kAddrFieldNumber = 3,
    kFlagsFieldNumber = 4,
    kLenFieldNumber = 5,
  };
  void set_adapter_nr(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_msg_nr(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_addr(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_len(uint32_t value) {
    AppendVarInt(5, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/ipi.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_IPI_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_IPI_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class IpiRaiseFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IpiRaiseFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IpiRaiseFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IpiRaiseFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_target_cpus() const { return at<1>().valid(); }
  uint32_t target_cpus() const { return at<1>().as_uint32(); }
  bool has_reason() const { return at<2>().valid(); }
  ::protozero::ConstChars reason() const { return at<2>().as_string(); }
};

class IpiRaiseFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IpiRaiseFtraceEvent_Decoder;
  enum : int32_t {
    kTargetCpusFieldNumber = 1,
    kReasonFieldNumber = 2,
  };
  void set_target_cpus(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_reason(const char* value) {
    AppendString(2, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_reason(const char* value, size_t size) {
    AppendBytes(2, value, size);
  }
};

class IpiExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IpiExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IpiExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IpiExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_reason() const { return at<1>().valid(); }
  ::protozero::ConstChars reason() const { return at<1>().as_string(); }
};

class IpiExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IpiExitFtraceEvent_Decoder;
  enum : int32_t {
    kReasonFieldNumber = 1,
  };
  void set_reason(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_reason(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
};

class IpiEntryFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IpiEntryFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IpiEntryFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IpiEntryFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_reason() const { return at<1>().valid(); }
  ::protozero::ConstChars reason() const { return at<1>().as_string(); }
};

class IpiEntryFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IpiEntryFtraceEvent_Decoder;
  enum : int32_t {
    kReasonFieldNumber = 1,
  };
  void set_reason(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_reason(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/irq.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_IRQ_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_IRQ_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class IrqHandlerExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IrqHandlerExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IrqHandlerExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IrqHandlerExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_irq() const { return at<1>().valid(); }
  int32_t irq() const { return at<1>().as_int32(); }
  bool has_ret() const { return at<2>().valid(); }
  int32_t ret() const { return at<2>().as_int32(); }
};

class IrqHandlerExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IrqHandlerExitFtraceEvent_Decoder;
  enum : int32_t {
    kIrqFieldNumber = 1,
    kRetFieldNumber = 2,
  };
  void set_irq(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_ret(int32_t value) {
    AppendVarInt(2, value);
  }
};

class IrqHandlerEntryFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IrqHandlerEntryFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IrqHandlerEntryFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IrqHandlerEntryFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_irq() const { return at<1>().valid(); }
  int32_t irq() const { return at<1>().as_int32(); }
  bool has_name() const { return at<2>().valid(); }
  ::protozero::ConstChars name() const { return at<2>().as_string(); }
  bool has_handler() const { return at<3>().valid(); }
  uint32_t handler() const { return at<3>().as_uint32(); }
};

class IrqHandlerEntryFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IrqHandlerEntryFtraceEvent_Decoder;
  enum : int32_t {
    kIrqFieldNumber = 1,
    kNameFieldNumber = 2,
    kHandlerFieldNumber = 3,
  };
  void set_irq(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_name(const char* value) {
    AppendString(2, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_name(const char* value, size_t size) {
    AppendBytes(2, value, size);
  }
  void set_handler(uint32_t value) {
    AppendVarInt(3, value);
  }
};

class SoftirqRaiseFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SoftirqRaiseFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SoftirqRaiseFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SoftirqRaiseFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_vec() const { return at<1>().valid(); }
  uint32_t vec() const { return at<1>().as_uint32(); }
};

class SoftirqRaiseFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SoftirqRaiseFtraceEvent_Decoder;
  enum : int32_t {
    kVecFieldNumber = 1,
  };
  void set_vec(uint32_t value) {
    AppendVarInt(1, value);
  }
};

class SoftirqExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SoftirqExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SoftirqExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SoftirqExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_vec() const { return at<1>().valid(); }
  uint32_t vec() const { return at<1>().as_uint32(); }
};

class SoftirqExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SoftirqExitFtraceEvent_Decoder;
  enum : int32_t {
    kVecFieldNumber = 1,
  };
  void set_vec(uint32_t value) {
    AppendVarInt(1, value);
  }
};

class SoftirqEntryFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SoftirqEntryFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SoftirqEntryFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SoftirqEntryFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_vec() const { return at<1>().valid(); }
  uint32_t vec() const { return at<1>().as_uint32(); }
};

class SoftirqEntryFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SoftirqEntryFtraceEvent_Decoder;
  enum : int32_t {
    kVecFieldNumber = 1,
  };
  void set_vec(uint32_t value) {
    AppendVarInt(1, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/kmem.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_KMEM_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_KMEM_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class IonHeapGrowFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IonHeapGrowFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IonHeapGrowFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IonHeapGrowFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_heap_name() const { return at<1>().valid(); }
  ::protozero::ConstChars heap_name() const { return at<1>().as_string(); }
  bool has_len() const { return at<2>().valid(); }
  uint64_t len() const { return at<2>().as_uint64(); }
  bool has_total_allocated() const { return at<3>().valid(); }
  int64_t total_allocated() const { return at<3>().as_int64(); }
};

class IonHeapGrowFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IonHeapGrowFtraceEvent_Decoder;
  enum : int32_t {
    kHeapNameFieldNumber = 1,
    kLenFieldNumber = 2,
    kTotalAllocatedFieldNumber = 3,
  };
  void set_heap_name(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_heap_name(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_len(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_total_allocated(int64_t value) {
    AppendVarInt(3, value);
  }
};

class IonHeapShrinkFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IonHeapShrinkFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IonHeapShrinkFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IonHeapShrinkFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_heap_name() const { return at<1>().valid(); }
  ::protozero::ConstChars heap_name() const { return at<1>().as_string(); }
  bool has_len() const { return at<2>().valid(); }
  uint64_t len() const { return at<2>().as_uint64(); }
  bool has_total_allocated() const { return at<3>().valid(); }
  int64_t total_allocated() const { return at<3>().as_int64(); }
};

class IonHeapShrinkFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IonHeapShrinkFtraceEvent_Decoder;
  enum : int32_t {
    kHeapNameFieldNumber = 1,
    kLenFieldNumber = 2,
    kTotalAllocatedFieldNumber = 3,
  };
  void set_heap_name(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_heap_name(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_len(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_total_allocated(int64_t value) {
    AppendVarInt(3, value);
  }
};

class RssStatFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  RssStatFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit RssStatFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit RssStatFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_member() const { return at<1>().valid(); }
  int32_t member() const { return at<1>().as_int32(); }
  bool has_size() const { return at<2>().valid(); }
  int64_t size() const { return at<2>().as_int64(); }
};

class RssStatFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = RssStatFtraceEvent_Decoder;
  enum : int32_t {
    kMemberFieldNumber = 1,
    kSizeFieldNumber = 2,
  };
  void set_member(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_size(int64_t value) {
    AppendVarInt(2, value);
  }
};

class MmPagePcpuDrainFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmPagePcpuDrainFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmPagePcpuDrainFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmPagePcpuDrainFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_migratetype() const { return at<1>().valid(); }
  int32_t migratetype() const { return at<1>().as_int32(); }
  bool has_order() const { return at<2>().valid(); }
  uint32_t order() const { return at<2>().as_uint32(); }
  bool has_page() const { return at<3>().valid(); }
  uint64_t page() const { return at<3>().as_uint64(); }
  bool has_pfn() const { return at<4>().valid(); }
  uint64_t pfn() const { return at<4>().as_uint64(); }
};

class MmPagePcpuDrainFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmPagePcpuDrainFtraceEvent_Decoder;
  enum : int32_t {
    kMigratetypeFieldNumber = 1,
    kOrderFieldNumber = 2,
    kPageFieldNumber = 3,
    kPfnFieldNumber = 4,
  };
  void set_migratetype(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_order(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_page(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_pfn(uint64_t value) {
    AppendVarInt(4, value);
  }
};

class MmPageFreeBatchedFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmPageFreeBatchedFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmPageFreeBatchedFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmPageFreeBatchedFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_cold() const { return at<1>().valid(); }
  int32_t cold() const { return at<1>().as_int32(); }
  bool has_page() const { return at<2>().valid(); }
  uint64_t page() const { return at<2>().as_uint64(); }
  bool has_pfn() const { return at<3>().valid(); }
  uint64_t pfn() const { return at<3>().as_uint64(); }
};

class MmPageFreeBatchedFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmPageFreeBatchedFtraceEvent_Decoder;
  enum : int32_t {
    kColdFieldNumber = 1,
    kPageFieldNumber = 2,
    kPfnFieldNumber = 3,
  };
  void set_cold(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_page(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pfn(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class MmPageFreeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmPageFreeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmPageFreeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmPageFreeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_order() const { return at<1>().valid(); }
  uint32_t order() const { return at<1>().as_uint32(); }
  bool has_page() const { return at<2>().valid(); }
  uint64_t page() const { return at<2>().as_uint64(); }
  bool has_pfn() const { return at<3>().valid(); }
  uint64_t pfn() const { return at<3>().as_uint64(); }
};

class MmPageFreeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmPageFreeFtraceEvent_Decoder;
  enum : int32_t {
    kOrderFieldNumber = 1,
    kPageFieldNumber = 2,
    kPfnFieldNumber = 3,
  };
  void set_order(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_page(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pfn(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class MmPageAllocZoneLockedFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmPageAllocZoneLockedFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmPageAllocZoneLockedFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmPageAllocZoneLockedFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_migratetype() const { return at<1>().valid(); }
  int32_t migratetype() const { return at<1>().as_int32(); }
  bool has_order() const { return at<2>().valid(); }
  uint32_t order() const { return at<2>().as_uint32(); }
  bool has_page() const { return at<3>().valid(); }
  uint64_t page() const { return at<3>().as_uint64(); }
  bool has_pfn() const { return at<4>().valid(); }
  uint64_t pfn() const { return at<4>().as_uint64(); }
};

class MmPageAllocZoneLockedFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmPageAllocZoneLockedFtraceEvent_Decoder;
  enum : int32_t {
    kMigratetypeFieldNumber = 1,
    kOrderFieldNumber = 2,
    kPageFieldNumber = 3,
    kPfnFieldNumber = 4,
  };
  void set_migratetype(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_order(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_page(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_pfn(uint64_t value) {
    AppendVarInt(4, value);
  }
};

class MmPageAllocExtfragFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/7, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmPageAllocExtfragFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmPageAllocExtfragFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmPageAllocExtfragFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_alloc_migratetype() const { return at<1>().valid(); }
  int32_t alloc_migratetype() const { return at<1>().as_int32(); }
  bool has_alloc_order() const { return at<2>().valid(); }
  int32_t alloc_order() const { return at<2>().as_int32(); }
  bool has_fallback_migratetype() const { return at<3>().valid(); }
  int32_t fallback_migratetype() const { return at<3>().as_int32(); }
  bool has_fallback_order() const { return at<4>().valid(); }
  int32_t fallback_order() const { return at<4>().as_int32(); }
  bool has_page() const { return at<5>().valid(); }
  uint64_t page() const { return at<5>().as_uint64(); }
  bool has_change_ownership() const { return at<6>().valid(); }
  int32_t change_ownership() const { return at<6>().as_int32(); }
  bool has_pfn() const { return at<7>().valid(); }
  uint64_t pfn() const { return at<7>().as_uint64(); }
};

class MmPageAllocExtfragFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmPageAllocExtfragFtraceEvent_Decoder;
  enum : int32_t {
    kAllocMigratetypeFieldNumber = 1,
    kAllocOrderFieldNumber = 2,
    kFallbackMigratetypeFieldNumber = 3,
    kFallbackOrderFieldNumber = 4,
    kPageFieldNumber = 5,
    kChangeOwnershipFieldNumber = 6,
    kPfnFieldNumber = 7,
  };
  void set_alloc_migratetype(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_alloc_order(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_fallback_migratetype(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_fallback_order(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_page(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_change_ownership(int32_t value) {
    AppendVarInt(6, value);
  }
  void set_pfn(uint64_t value) {
    AppendVarInt(7, value);
  }
};

class MmPageAllocFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmPageAllocFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmPageAllocFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmPageAllocFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_gfp_flags() const { return at<1>().valid(); }
  uint32_t gfp_flags() const { return at<1>().as_uint32(); }
  bool has_migratetype() const { return at<2>().valid(); }
  int32_t migratetype() const { return at<2>().as_int32(); }
  bool has_order() const { return at<3>().valid(); }
  uint32_t order() const { return at<3>().as_uint32(); }
  bool has_page() const { return at<4>().valid(); }
  uint64_t page() const { return at<4>().as_uint64(); }
  bool has_pfn() const { return at<5>().valid(); }
  uint64_t pfn() const { return at<5>().as_uint64(); }
};

class MmPageAllocFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmPageAllocFtraceEvent_Decoder;
  enum : int32_t {
    kGfpFlagsFieldNumber = 1,
    kMigratetypeFieldNumber = 2,
    kOrderFieldNumber = 3,
    kPageFieldNumber = 4,
    kPfnFieldNumber = 5,
  };
  void set_gfp_flags(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_migratetype(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_order(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_page(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_pfn(uint64_t value) {
    AppendVarInt(5, value);
  }
};

class MigrateRetryFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MigrateRetryFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MigrateRetryFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MigrateRetryFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_tries() const { return at<1>().valid(); }
  int32_t tries() const { return at<1>().as_int32(); }
};

class MigrateRetryFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MigrateRetryFtraceEvent_Decoder;
  enum : int32_t {
    kTriesFieldNumber = 1,
  };
  void set_tries(int32_t value) {
    AppendVarInt(1, value);
  }
};

class MigratePagesStartFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MigratePagesStartFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MigratePagesStartFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MigratePagesStartFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_mode() const { return at<1>().valid(); }
  int32_t mode() const { return at<1>().as_int32(); }
};

class MigratePagesStartFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MigratePagesStartFtraceEvent_Decoder;
  enum : int32_t {
    kModeFieldNumber = 1,
  };
  void set_mode(int32_t value) {
    AppendVarInt(1, value);
  }
};

class MigratePagesEndFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MigratePagesEndFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MigratePagesEndFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MigratePagesEndFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_mode() const { return at<1>().valid(); }
  int32_t mode() const { return at<1>().as_int32(); }
};

class MigratePagesEndFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MigratePagesEndFtraceEvent_Decoder;
  enum : int32_t {
    kModeFieldNumber = 1,
  };
  void set_mode(int32_t value) {
    AppendVarInt(1, value);
  }
};

class KmemCacheFreeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  KmemCacheFreeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit KmemCacheFreeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit KmemCacheFreeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_call_site() const { return at<1>().valid(); }
  uint64_t call_site() const { return at<1>().as_uint64(); }
  bool has_ptr() const { return at<2>().valid(); }
  uint64_t ptr() const { return at<2>().as_uint64(); }
};

class KmemCacheFreeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = KmemCacheFreeFtraceEvent_Decoder;
  enum : int32_t {
    kCallSiteFieldNumber = 1,
    kPtrFieldNumber = 2,
  };
  void set_call_site(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ptr(uint64_t value) {
    AppendVarInt(2, value);
  }
};

class KmemCacheAllocNodeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  KmemCacheAllocNodeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit KmemCacheAllocNodeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit KmemCacheAllocNodeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_bytes_alloc() const { return at<1>().valid(); }
  uint64_t bytes_alloc() const { return at<1>().as_uint64(); }
  bool has_bytes_req() const { return at<2>().valid(); }
  uint64_t bytes_req() const { return at<2>().as_uint64(); }
  bool has_call_site() const { return at<3>().valid(); }
  uint64_t call_site() const { return at<3>().as_uint64(); }
  bool has_gfp_flags() const { return at<4>().valid(); }
  uint32_t gfp_flags() const { return at<4>().as_uint32(); }
  bool has_node() const { return at<5>().valid(); }
  int32_t node() const { return at<5>().as_int32(); }
  bool has_ptr() const { return at<6>().valid(); }
  uint64_t ptr() const { return at<6>().as_uint64(); }
};

class KmemCacheAllocNodeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = KmemCacheAllocNodeFtraceEvent_Decoder;
  enum : int32_t {
    kBytesAllocFieldNumber = 1,
    kBytesReqFieldNumber = 2,
    kCallSiteFieldNumber = 3,
    kGfpFlagsFieldNumber = 4,
    kNodeFieldNumber = 5,
    kPtrFieldNumber = 6,
  };
  void set_bytes_alloc(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_bytes_req(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_call_site(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_gfp_flags(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_node(int32_t value) {
    AppendVarInt(5, value);
  }
  void set_ptr(uint64_t value) {
    AppendVarInt(6, value);
  }
};

class KmemCacheAllocFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  KmemCacheAllocFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit KmemCacheAllocFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit KmemCacheAllocFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_bytes_alloc() const { return at<1>().valid(); }
  uint64_t bytes_alloc() const { return at<1>().as_uint64(); }
  bool has_bytes_req() const { return at<2>().valid(); }
  uint64_t bytes_req() const { return at<2>().as_uint64(); }
  bool has_call_site() const { return at<3>().valid(); }
  uint64_t call_site() const { return at<3>().as_uint64(); }
  bool has_gfp_flags() const { return at<4>().valid(); }
  uint32_t gfp_flags() const { return at<4>().as_uint32(); }
  bool has_ptr() const { return at<5>().valid(); }
  uint64_t ptr() const { return at<5>().as_uint64(); }
};

class KmemCacheAllocFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = KmemCacheAllocFtraceEvent_Decoder;
  enum : int32_t {
    kBytesAllocFieldNumber = 1,
    kBytesReqFieldNumber = 2,
    kCallSiteFieldNumber = 3,
    kGfpFlagsFieldNumber = 4,
    kPtrFieldNumber = 5,
  };
  void set_bytes_alloc(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_bytes_req(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_call_site(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_gfp_flags(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_ptr(uint64_t value) {
    AppendVarInt(5, value);
  }
};

class KmallocNodeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  KmallocNodeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit KmallocNodeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit KmallocNodeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_bytes_alloc() const { return at<1>().valid(); }
  uint64_t bytes_alloc() const { return at<1>().as_uint64(); }
  bool has_bytes_req() const { return at<2>().valid(); }
  uint64_t bytes_req() const { return at<2>().as_uint64(); }
  bool has_call_site() const { return at<3>().valid(); }
  uint64_t call_site() const { return at<3>().as_uint64(); }
  bool has_gfp_flags() const { return at<4>().valid(); }
  uint32_t gfp_flags() const { return at<4>().as_uint32(); }
  bool has_node() const { return at<5>().valid(); }
  int32_t node() const { return at<5>().as_int32(); }
  bool has_ptr() const { return at<6>().valid(); }
  uint64_t ptr() const { return at<6>().as_uint64(); }
};

class KmallocNodeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = KmallocNodeFtraceEvent_Decoder;
  enum : int32_t {
    kBytesAllocFieldNumber = 1,
    kBytesReqFieldNumber = 2,
    kCallSiteFieldNumber = 3,
    kGfpFlagsFieldNumber = 4,
    kNodeFieldNumber = 5,
    kPtrFieldNumber = 6,
  };
  void set_bytes_alloc(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_bytes_req(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_call_site(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_gfp_flags(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_node(int32_t value) {
    AppendVarInt(5, value);
  }
  void set_ptr(uint64_t value) {
    AppendVarInt(6, value);
  }
};

class KmallocFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  KmallocFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit KmallocFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit KmallocFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_bytes_alloc() const { return at<1>().valid(); }
  uint64_t bytes_alloc() const { return at<1>().as_uint64(); }
  bool has_bytes_req() const { return at<2>().valid(); }
  uint64_t bytes_req() const { return at<2>().as_uint64(); }
  bool has_call_site() const { return at<3>().valid(); }
  uint64_t call_site() const { return at<3>().as_uint64(); }
  bool has_gfp_flags() const { return at<4>().valid(); }
  uint32_t gfp_flags() const { return at<4>().as_uint32(); }
  bool has_ptr() const { return at<5>().valid(); }
  uint64_t ptr() const { return at<5>().as_uint64(); }
};

class KmallocFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = KmallocFtraceEvent_Decoder;
  enum : int32_t {
    kBytesAllocFieldNumber = 1,
    kBytesReqFieldNumber = 2,
    kCallSiteFieldNumber = 3,
    kGfpFlagsFieldNumber = 4,
    kPtrFieldNumber = 5,
  };
  void set_bytes_alloc(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_bytes_req(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_call_site(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_gfp_flags(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_ptr(uint64_t value) {
    AppendVarInt(5, value);
  }
};

class KfreeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  KfreeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit KfreeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit KfreeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_call_site() const { return at<1>().valid(); }
  uint64_t call_site() const { return at<1>().as_uint64(); }
  bool has_ptr() const { return at<2>().valid(); }
  uint64_t ptr() const { return at<2>().as_uint64(); }
};

class KfreeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = KfreeFtraceEvent_Decoder;
  enum : int32_t {
    kCallSiteFieldNumber = 1,
    kPtrFieldNumber = 2,
  };
  void set_call_site(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_ptr(uint64_t value) {
    AppendVarInt(2, value);
  }
};

class IonSecureCmaShrinkPoolStartFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IonSecureCmaShrinkPoolStartFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IonSecureCmaShrinkPoolStartFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IonSecureCmaShrinkPoolStartFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_drained_size() const { return at<1>().valid(); }
  uint64_t drained_size() const { return at<1>().as_uint64(); }
  bool has_skipped_size() const { return at<2>().valid(); }
  uint64_t skipped_size() const { return at<2>().as_uint64(); }
};

class IonSecureCmaShrinkPoolStartFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IonSecureCmaShrinkPoolStartFtraceEvent_Decoder;
  enum : int32_t {
    kDrainedSizeFieldNumber = 1,
    kSkippedSizeFieldNumber = 2,
  };
  void set_drained_size(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_skipped_size(uint64_t value) {
    AppendVarInt(2, value);
  }
};

class IonSecureCmaShrinkPoolEndFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IonSecureCmaShrinkPoolEndFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IonSecureCmaShrinkPoolEndFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IonSecureCmaShrinkPoolEndFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_drained_size() const { return at<1>().valid(); }
  uint64_t drained_size() const { return at<1>().as_uint64(); }
  bool has_skipped_size() const { return at<2>().valid(); }
  uint64_t skipped_size() const { return at<2>().as_uint64(); }
};

class IonSecureCmaShrinkPoolEndFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IonSecureCmaShrinkPoolEndFtraceEvent_Decoder;
  enum : int32_t {
    kDrainedSizeFieldNumber = 1,
    kSkippedSizeFieldNumber = 2,
  };
  void set_drained_size(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_skipped_size(uint64_t value) {
    AppendVarInt(2, value);
  }
};

class IonSecureCmaAllocateStartFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IonSecureCmaAllocateStartFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IonSecureCmaAllocateStartFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IonSecureCmaAllocateStartFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_align() const { return at<1>().valid(); }
  uint64_t align() const { return at<1>().as_uint64(); }
  bool has_flags() const { return at<2>().valid(); }
  uint64_t flags() const { return at<2>().as_uint64(); }
  bool has_heap_name() const { return at<3>().valid(); }
  ::protozero::ConstChars heap_name() const { return at<3>().as_string(); }
  bool has_len() const { return at<4>().valid(); }
  uint64_t len() const { return at<4>().as_uint64(); }
};

class IonSecureCmaAllocateStartFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IonSecureCmaAllocateStartFtraceEvent_Decoder;
  enum : int32_t {
    kAlignFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kHeapNameFieldNumber = 3,
    kLenFieldNumber = 4,
  };
  void set_align(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_flags(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_heap_name(const char* value) {
    AppendString(3, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_heap_name(const char* value, size_t size) {
    AppendBytes(3, value, size);
  }
  void set_len(uint64_t value) {
    AppendVarInt(4, value);
  }
};

class IonSecureCmaAllocateEndFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IonSecureCmaAllocateEndFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IonSecureCmaAllocateEndFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IonSecureCmaAllocateEndFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_align() const { return at<1>().valid(); }
  uint64_t align() const { return at<1>().as_uint64(); }
  bool has_flags() const { return at<2>().valid(); }
  uint64_t flags() const { return at<2>().as_uint64(); }
  bool has_heap_name() const { return at<3>().valid(); }
  ::protozero::ConstChars heap_name() const { return at<3>().as_string(); }
  bool has_len() const { return at<4>().valid(); }
  uint64_t len() const { return at<4>().as_uint64(); }
};

class IonSecureCmaAllocateEndFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IonSecureCmaAllocateEndFtraceEvent_Decoder;
  enum : int32_t {
    kAlignFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kHeapNameFieldNumber = 3,
    kLenFieldNumber = 4,
  };
  void set_align(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_flags(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_heap_name(const char* value) {
    AppendString(3, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_heap_name(const char* value, size_t size) {
    AppendBytes(3, value, size);
  }
  void set_len(uint64_t value) {
    AppendVarInt(4, value);
  }
};

class IonSecureCmaAddToPoolStartFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IonSecureCmaAddToPoolStartFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IonSecureCmaAddToPoolStartFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IonSecureCmaAddToPoolStartFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_is_prefetch() const { return at<1>().valid(); }
  uint32_t is_prefetch() const { return at<1>().as_uint32(); }
  bool has_len() const { return at<2>().valid(); }
  uint64_t len() const { return at<2>().as_uint64(); }
  bool has_pool_total() const { return at<3>().valid(); }
  int32_t pool_total() const { return at<3>().as_int32(); }
};

class IonSecureCmaAddToPoolStartFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IonSecureCmaAddToPoolStartFtraceEvent_Decoder;
  enum : int32_t {
    kIsPrefetchFieldNumber = 1,
    kLenFieldNumber = 2,
    kPoolTotalFieldNumber = 3,
  };
  void set_is_prefetch(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_len(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pool_total(int32_t value) {
    AppendVarInt(3, value);
  }
};

class IonSecureCmaAddToPoolEndFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IonSecureCmaAddToPoolEndFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IonSecureCmaAddToPoolEndFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IonSecureCmaAddToPoolEndFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_is_prefetch() const { return at<1>().valid(); }
  uint32_t is_prefetch() const { return at<1>().as_uint32(); }
  bool has_len() const { return at<2>().valid(); }
  uint64_t len() const { return at<2>().as_uint64(); }
  bool has_pool_total() const { return at<3>().valid(); }
  int32_t pool_total() const { return at<3>().as_int32(); }
};

class IonSecureCmaAddToPoolEndFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IonSecureCmaAddToPoolEndFtraceEvent_Decoder;
  enum : int32_t {
    kIsPrefetchFieldNumber = 1,
    kLenFieldNumber = 2,
    kPoolTotalFieldNumber = 3,
  };
  void set_is_prefetch(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_len(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pool_total(int32_t value) {
    AppendVarInt(3, value);
  }
};

class IonPrefetchingFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IonPrefetchingFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IonPrefetchingFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IonPrefetchingFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_len() const { return at<1>().valid(); }
  uint64_t len() const { return at<1>().as_uint64(); }
};

class IonPrefetchingFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IonPrefetchingFtraceEvent_Decoder;
  enum : int32_t {
    kLenFieldNumber = 1,
  };
  void set_len(uint64_t value) {
    AppendVarInt(1, value);
  }
};

class IonCpSecureBufferStartFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IonCpSecureBufferStartFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IonCpSecureBufferStartFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IonCpSecureBufferStartFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_align() const { return at<1>().valid(); }
  uint64_t align() const { return at<1>().as_uint64(); }
  bool has_flags() const { return at<2>().valid(); }
  uint64_t flags() const { return at<2>().as_uint64(); }
  bool has_heap_name() const { return at<3>().valid(); }
  ::protozero::ConstChars heap_name() const { return at<3>().as_string(); }
  bool has_len() const { return at<4>().valid(); }
  uint64_t len() const { return at<4>().as_uint64(); }
};

class IonCpSecureBufferStartFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IonCpSecureBufferStartFtraceEvent_Decoder;
  enum : int32_t {
    kAlignFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kHeapNameFieldNumber = 3,
    kLenFieldNumber = 4,
  };
  void set_align(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_flags(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_heap_name(const char* value) {
    AppendString(3, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_heap_name(const char* value, size_t size) {
    AppendBytes(3, value, size);
  }
  void set_len(uint64_t value) {
    AppendVarInt(4, value);
  }
};

class IonCpSecureBufferEndFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IonCpSecureBufferEndFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IonCpSecureBufferEndFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IonCpSecureBufferEndFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_align() const { return at<1>().valid(); }
  uint64_t align() const { return at<1>().as_uint64(); }
  bool has_flags() const { return at<2>().valid(); }
  uint64_t flags() const { return at<2>().as_uint64(); }
  bool has_heap_name() const { return at<3>().valid(); }
  ::protozero::ConstChars heap_name() const { return at<3>().as_string(); }
  bool has_len() const { return at<4>().valid(); }
  uint64_t len() const { return at<4>().as_uint64(); }
};

class IonCpSecureBufferEndFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IonCpSecureBufferEndFtraceEvent_Decoder;
  enum : int32_t {
    kAlignFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kHeapNameFieldNumber = 3,
    kLenFieldNumber = 4,
  };
  void set_align(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_flags(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_heap_name(const char* value) {
    AppendString(3, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_heap_name(const char* value, size_t size) {
    AppendBytes(3, value, size);
  }
  void set_len(uint64_t value) {
    AppendVarInt(4, value);
  }
};

class IonCpAllocRetryFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IonCpAllocRetryFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IonCpAllocRetryFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IonCpAllocRetryFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_tries() const { return at<1>().valid(); }
  int32_t tries() const { return at<1>().as_int32(); }
};

class IonCpAllocRetryFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IonCpAllocRetryFtraceEvent_Decoder;
  enum : int32_t {
    kTriesFieldNumber = 1,
  };
  void set_tries(int32_t value) {
    AppendVarInt(1, value);
  }
};

class IonAllocBufferStartFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IonAllocBufferStartFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IonAllocBufferStartFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IonAllocBufferStartFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_client_name() const { return at<1>().valid(); }
  ::protozero::ConstChars client_name() const { return at<1>().as_string(); }
  bool has_flags() const { return at<2>().valid(); }
  uint32_t flags() const { return at<2>().as_uint32(); }
  bool has_heap_name() const { return at<3>().valid(); }
  ::protozero::ConstChars heap_name() const { return at<3>().as_string(); }
  bool has_len() const { return at<4>().valid(); }
  uint64_t len() const { return at<4>().as_uint64(); }
  bool has_mask() const { return at<5>().valid(); }
  uint32_t mask() const { return at<5>().as_uint32(); }
};

class IonAllocBufferStartFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IonAllocBufferStartFtraceEvent_Decoder;
  enum : int32_t {
    kClientNameFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kHeapNameFieldNumber = 3,
    kLenFieldNumber = 4,
    kMaskFieldNumber = 5,
  };
  void set_client_name(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_client_name(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_heap_name(const char* value) {
    AppendString(3, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_heap_name(const char* value, size_t size) {
    AppendBytes(3, value, size);
  }
  void set_len(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_mask(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class IonAllocBufferFallbackFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IonAllocBufferFallbackFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IonAllocBufferFallbackFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IonAllocBufferFallbackFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_client_name() const { return at<1>().valid(); }
  ::protozero::ConstChars client_name() const { return at<1>().as_string(); }
  bool has_error() const { return at<2>().valid(); }
  int64_t error() const { return at<2>().as_int64(); }
  bool has_flags() const { return at<3>().valid(); }
  uint32_t flags() const { return at<3>().as_uint32(); }
  bool has_heap_name() const { return at<4>().valid(); }
  ::protozero::ConstChars heap_name() const { return at<4>().as_string(); }
  bool has_len() const { return at<5>().valid(); }
  uint64_t len() const { return at<5>().as_uint64(); }
  bool has_mask() const { return at<6>().valid(); }
  uint32_t mask() const { return at<6>().as_uint32(); }
};

class IonAllocBufferFallbackFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IonAllocBufferFallbackFtraceEvent_Decoder;
  enum : int32_t {
    kClientNameFieldNumber = 1,
    kErrorFieldNumber = 2,
    kFlagsFieldNumber = 3,
    kHeapNameFieldNumber = 4,
    kLenFieldNumber = 5,
    kMaskFieldNumber = 6,
  };
  void set_client_name(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_client_name(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_error(int64_t value) {
    AppendVarInt(2, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_heap_name(const char* value) {
    AppendString(4, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_heap_name(const char* value, size_t size) {
    AppendBytes(4, value, size);
  }
  void set_len(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_mask(uint32_t value) {
    AppendVarInt(6, value);
  }
};

class IonAllocBufferFailFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IonAllocBufferFailFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IonAllocBufferFailFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IonAllocBufferFailFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_client_name() const { return at<1>().valid(); }
  ::protozero::ConstChars client_name() const { return at<1>().as_string(); }
  bool has_error() const { return at<2>().valid(); }
  int64_t error() const { return at<2>().as_int64(); }
  bool has_flags() const { return at<3>().valid(); }
  uint32_t flags() const { return at<3>().as_uint32(); }
  bool has_heap_name() const { return at<4>().valid(); }
  ::protozero::ConstChars heap_name() const { return at<4>().as_string(); }
  bool has_len() const { return at<5>().valid(); }
  uint64_t len() const { return at<5>().as_uint64(); }
  bool has_mask() const { return at<6>().valid(); }
  uint32_t mask() const { return at<6>().as_uint32(); }
};

class IonAllocBufferFailFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IonAllocBufferFailFtraceEvent_Decoder;
  enum : int32_t {
    kClientNameFieldNumber = 1,
    kErrorFieldNumber = 2,
    kFlagsFieldNumber = 3,
    kHeapNameFieldNumber = 4,
    kLenFieldNumber = 5,
    kMaskFieldNumber = 6,
  };
  void set_client_name(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_client_name(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_error(int64_t value) {
    AppendVarInt(2, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_heap_name(const char* value) {
    AppendString(4, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_heap_name(const char* value, size_t size) {
    AppendBytes(4, value, size);
  }
  void set_len(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_mask(uint32_t value) {
    AppendVarInt(6, value);
  }
};

class IonAllocBufferEndFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IonAllocBufferEndFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IonAllocBufferEndFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IonAllocBufferEndFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_client_name() const { return at<1>().valid(); }
  ::protozero::ConstChars client_name() const { return at<1>().as_string(); }
  bool has_flags() const { return at<2>().valid(); }
  uint32_t flags() const { return at<2>().as_uint32(); }
  bool has_heap_name() const { return at<3>().valid(); }
  ::protozero::ConstChars heap_name() const { return at<3>().as_string(); }
  bool has_len() const { return at<4>().valid(); }
  uint64_t len() const { return at<4>().as_uint64(); }
  bool has_mask() const { return at<5>().valid(); }
  uint32_t mask() const { return at<5>().as_uint32(); }
};

class IonAllocBufferEndFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IonAllocBufferEndFtraceEvent_Decoder;
  enum : int32_t {
    kClientNameFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kHeapNameFieldNumber = 3,
    kLenFieldNumber = 4,
    kMaskFieldNumber = 5,
  };
  void set_client_name(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_client_name(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_heap_name(const char* value) {
    AppendString(3, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_heap_name(const char* value, size_t size) {
    AppendBytes(3, value, size);
  }
  void set_len(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_mask(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class IommuSecPtblMapRangeStartFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IommuSecPtblMapRangeStartFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IommuSecPtblMapRangeStartFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IommuSecPtblMapRangeStartFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_len() const { return at<1>().valid(); }
  uint64_t len() const { return at<1>().as_uint64(); }
  bool has_num() const { return at<2>().valid(); }
  int32_t num() const { return at<2>().as_int32(); }
  bool has_pa() const { return at<3>().valid(); }
  uint32_t pa() const { return at<3>().as_uint32(); }
  bool has_sec_id() const { return at<4>().valid(); }
  int32_t sec_id() const { return at<4>().as_int32(); }
  bool has_va() const { return at<5>().valid(); }
  uint64_t va() const { return at<5>().as_uint64(); }
};

class IommuSecPtblMapRangeStartFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IommuSecPtblMapRangeStartFtraceEvent_Decoder;
  enum : int32_t {
    kLenFieldNumber = 1,
    kNumFieldNumber = 2,
    kPaFieldNumber = 3,
    kSecIdFieldNumber = 4,
    kVaFieldNumber = 5,
  };
  void set_len(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_num(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_pa(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_sec_id(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_va(uint64_t value) {
    AppendVarInt(5, value);
  }
};

class IommuSecPtblMapRangeEndFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IommuSecPtblMapRangeEndFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IommuSecPtblMapRangeEndFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IommuSecPtblMapRangeEndFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_len() const { return at<1>().valid(); }
  uint64_t len() const { return at<1>().as_uint64(); }
  bool has_num() const { return at<2>().valid(); }
  int32_t num() const { return at<2>().as_int32(); }
  bool has_pa() const { return at<3>().valid(); }
  uint32_t pa() const { return at<3>().as_uint32(); }
  bool has_sec_id() const { return at<4>().valid(); }
  int32_t sec_id() const { return at<4>().as_int32(); }
  bool has_va() const { return at<5>().valid(); }
  uint64_t va() const { return at<5>().as_uint64(); }
};

class IommuSecPtblMapRangeEndFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IommuSecPtblMapRangeEndFtraceEvent_Decoder;
  enum : int32_t {
    kLenFieldNumber = 1,
    kNumFieldNumber = 2,
    kPaFieldNumber = 3,
    kSecIdFieldNumber = 4,
    kVaFieldNumber = 5,
  };
  void set_len(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_num(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_pa(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_sec_id(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_va(uint64_t value) {
    AppendVarInt(5, value);
  }
};

class IommuMapRangeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  IommuMapRangeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit IommuMapRangeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit IommuMapRangeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_chunk_size() const { return at<1>().valid(); }
  uint64_t chunk_size() const { return at<1>().as_uint64(); }
  bool has_len() const { return at<2>().valid(); }
  uint64_t len() const { return at<2>().as_uint64(); }
  bool has_pa() const { return at<3>().valid(); }
  uint64_t pa() const { return at<3>().as_uint64(); }
  bool has_va() const { return at<4>().valid(); }
  uint64_t va() const { return at<4>().as_uint64(); }
};

class IommuMapRangeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = IommuMapRangeFtraceEvent_Decoder;
  enum : int32_t {
    kChunkSizeFieldNumber = 1,
    kLenFieldNumber = 2,
    kPaFieldNumber = 3,
    kVaFieldNumber = 4,
  };
  void set_chunk_size(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_len(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_pa(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_va(uint64_t value) {
    AppendVarInt(4, value);
  }
};

class DmaAllocContiguousRetryFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  DmaAllocContiguousRetryFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit DmaAllocContiguousRetryFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit DmaAllocContiguousRetryFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_tries() const { return at<1>().valid(); }
  int32_t tries() const { return at<1>().as_int32(); }
};

class DmaAllocContiguousRetryFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = DmaAllocContiguousRetryFtraceEvent_Decoder;
  enum : int32_t {
    kTriesFieldNumber = 1,
  };
  void set_tries(int32_t value) {
    AppendVarInt(1, value);
  }
};

class AllocPagesSysStartFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  AllocPagesSysStartFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit AllocPagesSysStartFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit AllocPagesSysStartFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_gfp_flags() const { return at<1>().valid(); }
  uint32_t gfp_flags() const { return at<1>().as_uint32(); }
  bool has_order() const { return at<2>().valid(); }
  uint32_t order() const { return at<2>().as_uint32(); }
};

class AllocPagesSysStartFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = AllocPagesSysStartFtraceEvent_Decoder;
  enum : int32_t {
    kGfpFlagsFieldNumber = 1,
    kOrderFieldNumber = 2,
  };
  void set_gfp_flags(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_order(uint32_t value) {
    AppendVarInt(2, value);
  }
};

class AllocPagesSysFailFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  AllocPagesSysFailFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit AllocPagesSysFailFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit AllocPagesSysFailFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_gfp_flags() const { return at<1>().valid(); }
  uint32_t gfp_flags() const { return at<1>().as_uint32(); }
  bool has_order() const { return at<2>().valid(); }
  uint32_t order() const { return at<2>().as_uint32(); }
};

class AllocPagesSysFailFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = AllocPagesSysFailFtraceEvent_Decoder;
  enum : int32_t {
    kGfpFlagsFieldNumber = 1,
    kOrderFieldNumber = 2,
  };
  void set_gfp_flags(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_order(uint32_t value) {
    AppendVarInt(2, value);
  }
};

class AllocPagesSysEndFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  AllocPagesSysEndFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit AllocPagesSysEndFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit AllocPagesSysEndFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_gfp_flags() const { return at<1>().valid(); }
  uint32_t gfp_flags() const { return at<1>().as_uint32(); }
  bool has_order() const { return at<2>().valid(); }
  uint32_t order() const { return at<2>().as_uint32(); }
};

class AllocPagesSysEndFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = AllocPagesSysEndFtraceEvent_Decoder;
  enum : int32_t {
    kGfpFlagsFieldNumber = 1,
    kOrderFieldNumber = 2,
  };
  void set_gfp_flags(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_order(uint32_t value) {
    AppendVarInt(2, value);
  }
};

class AllocPagesIommuStartFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  AllocPagesIommuStartFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit AllocPagesIommuStartFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit AllocPagesIommuStartFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_gfp_flags() const { return at<1>().valid(); }
  uint32_t gfp_flags() const { return at<1>().as_uint32(); }
  bool has_order() const { return at<2>().valid(); }
  uint32_t order() const { return at<2>().as_uint32(); }
};

class AllocPagesIommuStartFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = AllocPagesIommuStartFtraceEvent_Decoder;
  enum : int32_t {
    kGfpFlagsFieldNumber = 1,
    kOrderFieldNumber = 2,
  };
  void set_gfp_flags(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_order(uint32_t value) {
    AppendVarInt(2, value);
  }
};

class AllocPagesIommuFailFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  AllocPagesIommuFailFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit AllocPagesIommuFailFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit AllocPagesIommuFailFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_gfp_flags() const { return at<1>().valid(); }
  uint32_t gfp_flags() const { return at<1>().as_uint32(); }
  bool has_order() const { return at<2>().valid(); }
  uint32_t order() const { return at<2>().as_uint32(); }
};

class AllocPagesIommuFailFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = AllocPagesIommuFailFtraceEvent_Decoder;
  enum : int32_t {
    kGfpFlagsFieldNumber = 1,
    kOrderFieldNumber = 2,
  };
  void set_gfp_flags(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_order(uint32_t value) {
    AppendVarInt(2, value);
  }
};

class AllocPagesIommuEndFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  AllocPagesIommuEndFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit AllocPagesIommuEndFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit AllocPagesIommuEndFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_gfp_flags() const { return at<1>().valid(); }
  uint32_t gfp_flags() const { return at<1>().as_uint32(); }
  bool has_order() const { return at<2>().valid(); }
  uint32_t order() const { return at<2>().as_uint32(); }
};

class AllocPagesIommuEndFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = AllocPagesIommuEndFtraceEvent_Decoder;
  enum : int32_t {
    kGfpFlagsFieldNumber = 1,
    kOrderFieldNumber = 2,
  };
  void set_gfp_flags(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_order(uint32_t value) {
    AppendVarInt(2, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/lowmemorykiller.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_LOWMEMORYKILLER_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_LOWMEMORYKILLER_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class LowmemoryKillFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  LowmemoryKillFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit LowmemoryKillFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit LowmemoryKillFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_comm() const { return at<1>().valid(); }
  ::protozero::ConstChars comm() const { return at<1>().as_string(); }
  bool has_pid() const { return at<2>().valid(); }
  int32_t pid() const { return at<2>().as_int32(); }
  bool has_pagecache_size() const { return at<3>().valid(); }
  int64_t pagecache_size() const { return at<3>().as_int64(); }
  bool has_pagecache_limit() const { return at<4>().valid(); }
  int64_t pagecache_limit() const { return at<4>().as_int64(); }
  bool has_free() const { return at<5>().valid(); }
  int64_t free() const { return at<5>().as_int64(); }
};

class LowmemoryKillFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = LowmemoryKillFtraceEvent_Decoder;
  enum : int32_t {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
    kPagecacheSizeFieldNumber = 3,
    kPagecacheLimitFieldNumber = 4,
    kFreeFieldNumber = 5,
  };
  void set_comm(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_comm(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_pid(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_pagecache_size(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_pagecache_limit(int64_t value) {
    AppendVarInt(4, value);
  }
  void set_free(int64_t value) {
    AppendVarInt(5, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/mdss.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_MDSS_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_MDSS_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class RotatorBwAoAsContextFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  RotatorBwAoAsContextFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit RotatorBwAoAsContextFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit RotatorBwAoAsContextFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_state() const { return at<1>().valid(); }
  uint32_t state() const { return at<1>().as_uint32(); }
};

class RotatorBwAoAsContextFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = RotatorBwAoAsContextFtraceEvent_Decoder;
  enum : int32_t {
    kStateFieldNumber = 1,
  };
  void set_state(uint32_t value) {
    AppendVarInt(1, value);
  }
};

class MdpPerfUpdateBusFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpPerfUpdateBusFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpPerfUpdateBusFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpPerfUpdateBusFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_client() const { return at<1>().valid(); }
  int32_t client() const { return at<1>().as_int32(); }
  bool has_ab_quota() const { return at<2>().valid(); }
  uint64_t ab_quota() const { return at<2>().as_uint64(); }
  bool has_ib_quota() const { return at<3>().valid(); }
  uint64_t ib_quota() const { return at<3>().as_uint64(); }
};

class MdpPerfUpdateBusFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpPerfUpdateBusFtraceEvent_Decoder;
  enum : int32_t {
    kClientFieldNumber = 1,
    kAbQuotaFieldNumber = 2,
    kIbQuotaFieldNumber = 3,
  };
  void set_client(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_ab_quota(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_ib_quota(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class MdpPerfPrefillCalcFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/10, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpPerfPrefillCalcFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpPerfPrefillCalcFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpPerfPrefillCalcFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_pnum() const { return at<1>().valid(); }
  uint32_t pnum() const { return at<1>().as_uint32(); }
  bool has_latency_buf() const { return at<2>().valid(); }
  uint32_t latency_buf() const { return at<2>().as_uint32(); }
  bool has_ot() const { return at<3>().valid(); }
  uint32_t ot() const { return at<3>().as_uint32(); }
  bool has_y_buf() const { return at<4>().valid(); }
  uint32_t y_buf() const { return at<4>().as_uint32(); }
  bool has_y_scaler() const { return at<5>().valid(); }
  uint32_t y_scaler() const { return at<5>().as_uint32(); }
  bool has_pp_lines() const { return at<6>().valid(); }
  uint32_t pp_lines() const { return at<6>().as_uint32(); }
  bool has_pp_bytes() const { return at<7>().valid(); }
  uint32_t pp_bytes() const { return at<7>().as_uint32(); }
  bool has_post_sc() const { return at<8>().valid(); }
  uint32_t post_sc() const { return at<8>().as_uint32(); }
  bool has_fbc_bytes() const { return at<9>().valid(); }
  uint32_t fbc_bytes() const { return at<9>().as_uint32(); }
  bool has_prefill_bytes() const { return at<10>().valid(); }
  uint32_t prefill_bytes() const { return at<10>().as_uint32(); }
};

class MdpPerfPrefillCalcFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpPerfPrefillCalcFtraceEvent_Decoder;
  enum : int32_t {
    kPnumFieldNumber = 1,
    kLatencyBufFieldNumber = 2,
    kOtFieldNumber = 3,
    kYBufFieldNumber = 4,
    kYScalerFieldNumber = 5,
    kPpLinesFieldNumber = 6,
    kPpBytesFieldNumber = 7,
    kPostScFieldNumber = 8,
    kFbcBytesFieldNumber = 9,
    kPrefillBytesFieldNumber = 10,
  };
  void set_pnum(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_latency_buf(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_ot(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_y_buf(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_y_scaler(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_pp_lines(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_pp_bytes(uint32_t value) {
    AppendVarInt(7, value);
  }
  void set_post_sc(uint32_t value) {
    AppendVarInt(8, value);
  }
  void set_fbc_bytes(uint32_t value) {
    AppendVarInt(9, value);
  }
  void set_prefill_bytes(uint32_t value) {
    AppendVarInt(10, value);
  }
};

class MdpCmdWaitPingpongFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpCmdWaitPingpongFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpCmdWaitPingpongFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpCmdWaitPingpongFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_ctl_num() const { return at<1>().valid(); }
  uint32_t ctl_num() const { return at<1>().as_uint32(); }
  bool has_kickoff_cnt() const { return at<2>().valid(); }
  int32_t kickoff_cnt() const { return at<2>().as_int32(); }
};

class MdpCmdWaitPingpongFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpCmdWaitPingpongFtraceEvent_Decoder;
  enum : int32_t {
    kCtlNumFieldNumber = 1,
    kKickoffCntFieldNumber = 2,
  };
  void set_ctl_num(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_kickoff_cnt(int32_t value) {
    AppendVarInt(2, value);
  }
};

class MdpVideoUnderrunDoneFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpVideoUnderrunDoneFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpVideoUnderrunDoneFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpVideoUnderrunDoneFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_ctl_num() const { return at<1>().valid(); }
  uint32_t ctl_num() const { return at<1>().as_uint32(); }
  bool has_underrun_cnt() const { return at<2>().valid(); }
  uint32_t underrun_cnt() const { return at<2>().as_uint32(); }
};

class MdpVideoUnderrunDoneFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpVideoUnderrunDoneFtraceEvent_Decoder;
  enum : int32_t {
    kCtlNumFieldNumber = 1,
    kUnderrunCntFieldNumber = 2,
  };
  void set_ctl_num(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_underrun_cnt(uint32_t value) {
    AppendVarInt(2, value);
  }
};

class MdpPerfSetWmLevelsFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpPerfSetWmLevelsFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpPerfSetWmLevelsFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpPerfSetWmLevelsFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_pnum() const { return at<1>().valid(); }
  uint32_t pnum() const { return at<1>().as_uint32(); }
  bool has_use_space() const { return at<2>().valid(); }
  uint32_t use_space() const { return at<2>().as_uint32(); }
  bool has_priority_bytes() const { return at<3>().valid(); }
  uint32_t priority_bytes() const { return at<3>().as_uint32(); }
  bool has_wm0() const { return at<4>().valid(); }
  uint32_t wm0() const { return at<4>().as_uint32(); }
  bool has_wm1() const { return at<5>().valid(); }
  uint32_t wm1() const { return at<5>().as_uint32(); }
  bool has_wm2() const { return at<6>().valid(); }
  uint32_t wm2() const { return at<6>().as_uint32(); }
  bool has_mb_cnt() const { return at<7>().valid(); }
  uint32_t mb_cnt() const { return at<7>().as_uint32(); }
  bool has_mb_size() const { return at<8>().valid(); }
  uint32_t mb_size() const { return at<8>().as_uint32(); }
};

class MdpPerfSetWmLevelsFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpPerfSetWmLevelsFtraceEvent_Decoder;
  enum : int32_t {
    kPnumFieldNumber = 1,
    kUseSpaceFieldNumber = 2,
    kPriorityBytesFieldNumber = 3,
    kWm0FieldNumber = 4,
    kWm1FieldNumber = 5,
    kWm2FieldNumber = 6,
    kMbCntFieldNumber = 7,
    kMbSizeFieldNumber = 8,
  };
  void set_pnum(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_use_space(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_priority_bytes(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_wm0(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_wm1(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_wm2(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_mb_cnt(uint32_t value) {
    AppendVarInt(7, value);
  }
  void set_mb_size(uint32_t value) {
    AppendVarInt(8, value);
  }
};

class MdpMixerUpdateFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpMixerUpdateFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpMixerUpdateFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpMixerUpdateFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_mixer_num() const { return at<1>().valid(); }
  uint32_t mixer_num() const { return at<1>().as_uint32(); }
};

class MdpMixerUpdateFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpMixerUpdateFtraceEvent_Decoder;
  enum : int32_t {
    kMixerNumFieldNumber = 1,
  };
  void set_mixer_num(uint32_t value) {
    AppendVarInt(1, value);
  }
};

class MdpCmdReleaseBwFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpCmdReleaseBwFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpCmdReleaseBwFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpCmdReleaseBwFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_ctl_num() const { return at<1>().valid(); }
  uint32_t ctl_num() const { return at<1>().as_uint32(); }
};

class MdpCmdReleaseBwFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpCmdReleaseBwFtraceEvent_Decoder;
  enum : int32_t {
    kCtlNumFieldNumber = 1,
  };
  void set_ctl_num(uint32_t value) {
    AppendVarInt(1, value);
  }
};

class MdpTraceCounterFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpTraceCounterFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpTraceCounterFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpTraceCounterFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_pid() const { return at<1>().valid(); }
  int32_t pid() const { return at<1>().as_int32(); }
  bool has_counter_name() const { return at<2>().valid(); }
  ::protozero::ConstChars counter_name() const { return at<2>().as_string(); }
  bool has_value() const { return at<3>().valid(); }
  int32_t value() const { return at<3>().as_int32(); }
};

class MdpTraceCounterFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpTraceCounterFtraceEvent_Decoder;
  enum : int32_t {
    kPidFieldNumber = 1,
    kCounterNameFieldNumber = 2,
    kValueFieldNumber = 3,
  };
  void set_pid(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_counter_name(const char* value) {
    AppendString(2, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_counter_name(const char* value, size_t size) {
    AppendBytes(2, value, size);
  }
  void set_value(int32_t value) {
    AppendVarInt(3, value);
  }
};

class MdpPerfSetQosLutsFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/7, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpPerfSetQosLutsFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpPerfSetQosLutsFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpPerfSetQosLutsFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_pnum() const { return at<1>().valid(); }
  uint32_t pnum() const { return at<1>().as_uint32(); }
  bool has_fmt() const { return at<2>().valid(); }
  uint32_t fmt() const { return at<2>().as_uint32(); }
  bool has_intf() const { return at<3>().valid(); }
  uint32_t intf() const { return at<3>().as_uint32(); }
  bool has_rot() const { return at<4>().valid(); }
  uint32_t rot() const { return at<4>().as_uint32(); }
  bool has_fl() const { return at<5>().valid(); }
  uint32_t fl() const { return at<5>().as_uint32(); }
  bool has_lut() const { return at<6>().valid(); }
  uint32_t lut() const { return at<6>().as_uint32(); }
  bool has_linear() const { return at<7>().valid(); }
  uint32_t linear() const { return at<7>().as_uint32(); }
};

class MdpPerfSetQosLutsFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpPerfSetQosLutsFtraceEvent_Decoder;
  enum : int32_t {
    kPnumFieldNumber = 1,
    kFmtFieldNumber = 2,
    kIntfFieldNumber = 3,
    kRotFieldNumber = 4,
    kFlFieldNumber = 5,
    kLutFieldNumber = 6,
    kLinearFieldNumber = 7,
  };
  void set_pnum(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_fmt(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_intf(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_rot(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_fl(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_lut(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_linear(uint32_t value) {
    AppendVarInt(7, value);
  }
};

class MdpMisrCrcFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpMisrCrcFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpMisrCrcFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpMisrCrcFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_block_id() const { return at<1>().valid(); }
  uint32_t block_id() const { return at<1>().as_uint32(); }
  bool has_vsync_cnt() const { return at<2>().valid(); }
  uint32_t vsync_cnt() const { return at<2>().as_uint32(); }
  bool has_crc() const { return at<3>().valid(); }
  uint32_t crc() const { return at<3>().as_uint32(); }
};

class MdpMisrCrcFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpMisrCrcFtraceEvent_Decoder;
  enum : int32_t {
    kBlockIdFieldNumber = 1,
    kVsyncCntFieldNumber = 2,
    kCrcFieldNumber = 3,
  };
  void set_block_id(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_vsync_cnt(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_crc(uint32_t value) {
    AppendVarInt(3, value);
  }
};

class MdpCmdReadptrDoneFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpCmdReadptrDoneFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpCmdReadptrDoneFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpCmdReadptrDoneFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_ctl_num() const { return at<1>().valid(); }
  uint32_t ctl_num() const { return at<1>().as_uint32(); }
  bool has_koff_cnt() const { return at<2>().valid(); }
  int32_t koff_cnt() const { return at<2>().as_int32(); }
};

class MdpCmdReadptrDoneFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpCmdReadptrDoneFtraceEvent_Decoder;
  enum : int32_t {
    kCtlNumFieldNumber = 1,
    kKoffCntFieldNumber = 2,
  };
  void set_ctl_num(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_koff_cnt(int32_t value) {
    AppendVarInt(2, value);
  }
};

class MdpSsppSetFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/16, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpSsppSetFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpSsppSetFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpSsppSetFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_num() const { return at<1>().valid(); }
  uint32_t num() const { return at<1>().as_uint32(); }
  bool has_play_cnt() const { return at<2>().valid(); }
  uint32_t play_cnt() const { return at<2>().as_uint32(); }
  bool has_mixer() const { return at<3>().valid(); }
  uint32_t mixer() const { return at<3>().as_uint32(); }
  bool has_stage() const { return at<4>().valid(); }
  uint32_t stage() const { return at<4>().as_uint32(); }
  bool has_flags() const { return at<5>().valid(); }
  uint32_t flags() const { return at<5>().as_uint32(); }
  bool has_format() const { return at<6>().valid(); }
  uint32_t format() const { return at<6>().as_uint32(); }
  bool has_img_w() const { return at<7>().valid(); }
  uint32_t img_w() const { return at<7>().as_uint32(); }
  bool has_img_h() const { return at<8>().valid(); }
  uint32_t img_h() const { return at<8>().as_uint32(); }
  bool has_src_x() const { return at<9>().valid(); }
  uint32_t src_x() const { return at<9>().as_uint32(); }
  bool has_src_y() const { return at<10>().valid(); }
  uint32_t src_y() const { return at<10>().as_uint32(); }
  bool has_src_w() const { return at<11>().valid(); }
  uint32_t src_w() const { return at<11>().as_uint32(); }
  bool has_src_h() const { return at<12>().valid(); }
  uint32_t src_h() const { return at<12>().as_uint32(); }
  bool has_dst_x() const { return at<13>().valid(); }
  uint32_t dst_x() const { return at<13>().as_uint32(); }
  bool has_dst_y() const { return at<14>().valid(); }
  uint32_t dst_y() const { return at<14>().as_uint32(); }
  bool has_dst_w() const { return at<15>().valid(); }
  uint32_t dst_w() const { return at<15>().as_uint32(); }
  bool has_dst_h() const { return at<16>().valid(); }
  uint32_t dst_h() const { return at<16>().as_uint32(); }
};

class MdpSsppSetFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpSsppSetFtraceEvent_Decoder;
  enum : int32_t {
    kNumFieldNumber = 1,
    kPlayCntFieldNumber = 2,
    kMixerFieldNumber = 3,
    kStageFieldNumber = 4,
    kFlagsFieldNumber = 5,
    kFormatFieldNumber = 6,
    kImgWFieldNumber = 7,
    kImgHFieldNumber = 8,
    kSrcXFieldNumber = 9,
    kSrcYFieldNumber = 10,
    kSrcWFieldNumber = 11,
    kSrcHFieldNumber = 12,
    kDstXFieldNumber = 13,
    kDstYFieldNumber = 14,
    kDstWFieldNumber = 15,
    kDstHFieldNumber = 16,
  };
  void set_num(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_play_cnt(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_mixer(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_stage(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_format(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_img_w(uint32_t value) {
    AppendVarInt(7, value);
  }
  void set_img_h(uint32_t value) {
    AppendVarInt(8, value);
  }
  void set_src_x(uint32_t value) {
    AppendVarInt(9, value);
  }
  void set_src_y(uint32_t value) {
    AppendVarInt(10, value);
  }
  void set_src_w(uint32_t value) {
    AppendVarInt(11, value);
  }
  void set_src_h(uint32_t value) {
    AppendVarInt(12, value);
  }
  void set_dst_x(uint32_t value) {
    AppendVarInt(13, value);
  }
  void set_dst_y(uint32_t value) {
    AppendVarInt(14, value);
  }
  void set_dst_w(uint32_t value) {
    AppendVarInt(15, value);
  }
  void set_dst_h(uint32_t value) {
    AppendVarInt(16, value);
  }
};

class MdpPerfSetPanicLutsFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpPerfSetPanicLutsFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpPerfSetPanicLutsFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpPerfSetPanicLutsFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_pnum() const { return at<1>().valid(); }
  uint32_t pnum() const { return at<1>().as_uint32(); }
  bool has_fmt() const { return at<2>().valid(); }
  uint32_t fmt() const { return at<2>().as_uint32(); }
  bool has_mode() const { return at<3>().valid(); }
  uint32_t mode() const { return at<3>().as_uint32(); }
  bool has_panic_lut() const { return at<4>().valid(); }
  uint32_t panic_lut() const { return at<4>().as_uint32(); }
  bool has_robust_lut() const { return at<5>().valid(); }
  uint32_t robust_lut() const { return at<5>().as_uint32(); }
};

class MdpPerfSetPanicLutsFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpPerfSetPanicLutsFtraceEvent_Decoder;
  enum : int32_t {
    kPnumFieldNumber = 1,
    kFmtFieldNumber = 2,
    kModeFieldNumber = 3,
    kPanicLutFieldNumber = 4,
    kRobustLutFieldNumber = 5,
  };
  void set_pnum(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_fmt(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_mode(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_panic_lut(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_robust_lut(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class MdpCompareBwFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpCompareBwFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpCompareBwFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpCompareBwFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_new_ab() const { return at<1>().valid(); }
  uint64_t new_ab() const { return at<1>().as_uint64(); }
  bool has_new_ib() const { return at<2>().valid(); }
  uint64_t new_ib() const { return at<2>().as_uint64(); }
  bool has_new_wb() const { return at<3>().valid(); }
  uint64_t new_wb() const { return at<3>().as_uint64(); }
  bool has_old_ab() const { return at<4>().valid(); }
  uint64_t old_ab() const { return at<4>().as_uint64(); }
  bool has_old_ib() const { return at<5>().valid(); }
  uint64_t old_ib() const { return at<5>().as_uint64(); }
  bool has_old_wb() const { return at<6>().valid(); }
  uint64_t old_wb() const { return at<6>().as_uint64(); }
  bool has_params_changed() const { return at<7>().valid(); }
  uint32_t params_changed() const { return at<7>().as_uint32(); }
  bool has_update_bw() const { return at<8>().valid(); }
  uint32_t update_bw() const { return at<8>().as_uint32(); }
};

class MdpCompareBwFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpCompareBwFtraceEvent_Decoder;
  enum : int32_t {
    kNewAbFieldNumber = 1,
    kNewIbFieldNumber = 2,
    kNewWbFieldNumber = 3,
    kOldAbFieldNumber = 4,
    kOldIbFieldNumber = 5,
    kOldWbFieldNumber = 6,
    kParamsChangedFieldNumber = 7,
    kUpdateBwFieldNumber = 8,
  };
  void set_new_ab(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_new_ib(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_new_wb(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_old_ab(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_old_ib(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_old_wb(uint64_t value) {
    AppendVarInt(6, value);
  }
  void set_params_changed(uint32_t value) {
    AppendVarInt(7, value);
  }
  void set_update_bw(uint32_t value) {
    AppendVarInt(8, value);
  }
};

class MdpCmdPingpongDoneFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpCmdPingpongDoneFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpCmdPingpongDoneFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpCmdPingpongDoneFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_ctl_num() const { return at<1>().valid(); }
  uint32_t ctl_num() const { return at<1>().as_uint32(); }
  bool has_intf_num() const { return at<2>().valid(); }
  uint32_t intf_num() const { return at<2>().as_uint32(); }
  bool has_pp_num() const { return at<3>().valid(); }
  uint32_t pp_num() const { return at<3>().as_uint32(); }
  bool has_koff_cnt() const { return at<4>().valid(); }
  int32_t koff_cnt() const { return at<4>().as_int32(); }
};

class MdpCmdPingpongDoneFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpCmdPingpongDoneFtraceEvent_Decoder;
  enum : int32_t {
    kCtlNumFieldNumber = 1,
    kIntfNumFieldNumber = 2,
    kPpNumFieldNumber = 3,
    kKoffCntFieldNumber = 4,
  };
  void set_ctl_num(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_intf_num(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_pp_num(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_koff_cnt(int32_t value) {
    AppendVarInt(4, value);
  }
};

class TracingMarkWriteFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TracingMarkWriteFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TracingMarkWriteFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TracingMarkWriteFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_pid() const { return at<1>().valid(); }
  int32_t pid() const { return at<1>().as_int32(); }
  bool has_trace_name() const { return at<2>().valid(); }
  ::protozero::ConstChars trace_name() const { return at<2>().as_string(); }
  bool has_trace_begin() const { return at<3>().valid(); }
  uint32_t trace_begin() const { return at<3>().as_uint32(); }
};

class TracingMarkWriteFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = TracingMarkWriteFtraceEvent_Decoder;
  enum : int32_t {
    kPidFieldNumber = 1,
    kTraceNameFieldNumber = 2,
    kTraceBeginFieldNumber = 3,
  };
  void set_pid(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_trace_name(const char* value) {
    AppendString(2, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_trace_name(const char* value, size_t size) {
    AppendBytes(2, value, size);
  }
  void set_trace_begin(uint32_t value) {
    AppendVarInt(3, value);
  }
};

class MdpSsppChangeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/16, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpSsppChangeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpSsppChangeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpSsppChangeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_num() const { return at<1>().valid(); }
  uint32_t num() const { return at<1>().as_uint32(); }
  bool has_play_cnt() const { return at<2>().valid(); }
  uint32_t play_cnt() const { return at<2>().as_uint32(); }
  bool has_mixer() const { return at<3>().valid(); }
  uint32_t mixer() const { return at<3>().as_uint32(); }
  bool has_stage() const { return at<4>().valid(); }
  uint32_t stage() const { return at<4>().as_uint32(); }
  bool has_flags() const { return at<5>().valid(); }
  uint32_t flags() const { return at<5>().as_uint32(); }
  bool has_format() const { return at<6>().valid(); }
  uint32_t format() const { return at<6>().as_uint32(); }
  bool has_img_w() const { return at<7>().valid(); }
  uint32_t img_w() const { return at<7>().as_uint32(); }
  bool has_img_h() const { return at<8>().valid(); }
  uint32_t img_h() const { return at<8>().as_uint32(); }
  bool has_src_x() const { return at<9>().valid(); }
  uint32_t src_x() const { return at<9>().as_uint32(); }
  bool has_src_y() const { return at<10>().valid(); }
  uint32_t src_y() const { return at<10>().as_uint32(); }
  bool has_src_w() const { return at<11>().valid(); }
  uint32_t src_w() const { return at<11>().as_uint32(); }
  bool has_src_h() const { return at<12>().valid(); }
  uint32_t src_h() const { return at<12>().as_uint32(); }
  bool has_dst_x() const { return at<13>().valid(); }
  uint32_t dst_x() const { return at<13>().as_uint32(); }
  bool has_dst_y() const { return at<14>().valid(); }
  uint32_t dst_y() const { return at<14>().as_uint32(); }
  bool has_dst_w() const { return at<15>().valid(); }
  uint32_t dst_w() const { return at<15>().as_uint32(); }
  bool has_dst_h() const { return at<16>().valid(); }
  uint32_t dst_h() const { return at<16>().as_uint32(); }
};

class MdpSsppChangeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpSsppChangeFtraceEvent_Decoder;
  enum : int32_t {
    kNumFieldNumber = 1,
    kPlayCntFieldNumber = 2,
    kMixerFieldNumber = 3,
    kStageFieldNumber = 4,
    kFlagsFieldNumber = 5,
    kFormatFieldNumber = 6,
    kImgWFieldNumber = 7,
    kImgHFieldNumber = 8,
    kSrcXFieldNumber = 9,
    kSrcYFieldNumber = 10,
    kSrcWFieldNumber = 11,
    kSrcHFieldNumber = 12,
    kDstXFieldNumber = 13,
    kDstYFieldNumber = 14,
    kDstWFieldNumber = 15,
    kDstHFieldNumber = 16,
  };
  void set_num(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_play_cnt(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_mixer(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_stage(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_flags(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_format(uint32_t value) {
    AppendVarInt(6, value);
  }
  void set_img_w(uint32_t value) {
    AppendVarInt(7, value);
  }
  void set_img_h(uint32_t value) {
    AppendVarInt(8, value);
  }
  void set_src_x(uint32_t value) {
    AppendVarInt(9, value);
  }
  void set_src_y(uint32_t value) {
    AppendVarInt(10, value);
  }
  void set_src_w(uint32_t value) {
    AppendVarInt(11, value);
  }
  void set_src_h(uint32_t value) {
    AppendVarInt(12, value);
  }
  void set_dst_x(uint32_t value) {
    AppendVarInt(13, value);
  }
  void set_dst_y(uint32_t value) {
    AppendVarInt(14, value);
  }
  void set_dst_w(uint32_t value) {
    AppendVarInt(15, value);
  }
  void set_dst_h(uint32_t value) {
    AppendVarInt(16, value);
  }
};

class MdpPerfSetOtFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpPerfSetOtFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpPerfSetOtFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpPerfSetOtFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_pnum() const { return at<1>().valid(); }
  uint32_t pnum() const { return at<1>().as_uint32(); }
  bool has_xin_id() const { return at<2>().valid(); }
  uint32_t xin_id() const { return at<2>().as_uint32(); }
  bool has_rd_lim() const { return at<3>().valid(); }
  uint32_t rd_lim() const { return at<3>().as_uint32(); }
  bool has_is_vbif_rt() const { return at<4>().valid(); }
  uint32_t is_vbif_rt() const { return at<4>().as_uint32(); }
};

class MdpPerfSetOtFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpPerfSetOtFtraceEvent_Decoder;
  enum : int32_t {
    kPnumFieldNumber = 1,
    kXinIdFieldNumber = 2,
    kRdLimFieldNumber = 3,
    kIsVbifRtFieldNumber = 4,
  };
  void set_pnum(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_xin_id(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_rd_lim(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_is_vbif_rt(uint32_t value) {
    AppendVarInt(4, value);
  }
};

class MdpCommitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpCommitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpCommitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpCommitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_num() const { return at<1>().valid(); }
  uint32_t num() const { return at<1>().as_uint32(); }
  bool has_play_cnt() const { return at<2>().valid(); }
  uint32_t play_cnt() const { return at<2>().as_uint32(); }
  bool has_clk_rate() const { return at<3>().valid(); }
  uint32_t clk_rate() const { return at<3>().as_uint32(); }
  bool has_bandwidth() const { return at<4>().valid(); }
  uint64_t bandwidth() const { return at<4>().as_uint64(); }
};

class MdpCommitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpCommitFtraceEvent_Decoder;
  enum : int32_t {
    kNumFieldNumber = 1,
    kPlayCntFieldNumber = 2,
    kClkRateFieldNumber = 3,
    kBandwidthFieldNumber = 4,
  };
  void set_num(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_play_cnt(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_clk_rate(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_bandwidth(uint64_t value) {
    AppendVarInt(4, value);
  }
};

class MdpCmdKickoffFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MdpCmdKickoffFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MdpCmdKickoffFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MdpCmdKickoffFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_ctl_num() const { return at<1>().valid(); }
  uint32_t ctl_num() const { return at<1>().as_uint32(); }
  bool has_kickoff_cnt() const { return at<2>().valid(); }
  int32_t kickoff_cnt() const { return at<2>().as_int32(); }
};

class MdpCmdKickoffFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MdpCmdKickoffFtraceEvent_Decoder;
  enum : int32_t {
    kCtlNumFieldNumber = 1,
    kKickoffCntFieldNumber = 2,
  };
  void set_ctl_num(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_kickoff_cnt(int32_t value) {
    AppendVarInt(2, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/mm_event.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_MM_EVENT_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_MM_EVENT_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class MmEventRecordFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmEventRecordFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmEventRecordFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmEventRecordFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_avg_lat() const { return at<1>().valid(); }
  uint32_t avg_lat() const { return at<1>().as_uint32(); }
  bool has_count() const { return at<2>().valid(); }
  uint32_t count() const { return at<2>().as_uint32(); }
  bool has_max_lat() const { return at<3>().valid(); }
  uint32_t max_lat() const { return at<3>().as_uint32(); }
  bool has_type() const { return at<4>().valid(); }
  uint32_t type() const { return at<4>().as_uint32(); }
};

class MmEventRecordFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmEventRecordFtraceEvent_Decoder;
  enum : int32_t {
    kAvgLatFieldNumber = 1,
    kCountFieldNumber = 2,
    kMaxLatFieldNumber = 3,
    kTypeFieldNumber = 4,
  };
  void set_avg_lat(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_count(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_max_lat(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_type(uint32_t value) {
    AppendVarInt(4, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/oom.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_OOM_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_OOM_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class OomScoreAdjUpdateFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  OomScoreAdjUpdateFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit OomScoreAdjUpdateFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit OomScoreAdjUpdateFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_comm() const { return at<1>().valid(); }
  ::protozero::ConstChars comm() const { return at<1>().as_string(); }
  bool has_oom_score_adj() const { return at<2>().valid(); }
  int32_t oom_score_adj() const { return at<2>().as_int32(); }
  bool has_pid() const { return at<3>().valid(); }
  int32_t pid() const { return at<3>().as_int32(); }
};

class OomScoreAdjUpdateFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = OomScoreAdjUpdateFtraceEvent_Decoder;
  enum : int32_t {
    kCommFieldNumber = 1,
    kOomScoreAdjFieldNumber = 2,
    kPidFieldNumber = 3,
  };
  void set_comm(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_comm(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_oom_score_adj(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_pid(int32_t value) {
    AppendVarInt(3, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/power.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_POWER_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_POWER_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class GpuFrequencyFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  GpuFrequencyFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit GpuFrequencyFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit GpuFrequencyFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_gpu_id() const { return at<1>().valid(); }
  uint32_t gpu_id() const { return at<1>().as_uint32(); }
  bool has_state() const { return at<2>().valid(); }
  uint32_t state() const { return at<2>().as_uint32(); }
};

class GpuFrequencyFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = GpuFrequencyFtraceEvent_Decoder;
  enum : int32_t {
    kGpuIdFieldNumber = 1,
    kStateFieldNumber = 2,
  };
  void set_gpu_id(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_state(uint32_t value) {
    AppendVarInt(2, value);
  }
};

class SuspendResumeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SuspendResumeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SuspendResumeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SuspendResumeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_action() const { return at<1>().valid(); }
  ::protozero::ConstChars action() const { return at<1>().as_string(); }
  bool has_val() const { return at<2>().valid(); }
  int32_t val() const { return at<2>().as_int32(); }
  bool has_start() const { return at<3>().valid(); }
  uint32_t start() const { return at<3>().as_uint32(); }
};

class SuspendResumeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SuspendResumeFtraceEvent_Decoder;
  enum : int32_t {
    kActionFieldNumber = 1,
    kValFieldNumber = 2,
    kStartFieldNumber = 3,
  };
  void set_action(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_action(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_val(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_start(uint32_t value) {
    AppendVarInt(3, value);
  }
};

class ClockSetRateFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ClockSetRateFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ClockSetRateFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ClockSetRateFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_state() const { return at<2>().valid(); }
  uint64_t state() const { return at<2>().as_uint64(); }
  bool has_cpu_id() const { return at<3>().valid(); }
  uint64_t cpu_id() const { return at<3>().as_uint64(); }
};

class ClockSetRateFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = ClockSetRateFtraceEvent_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kStateFieldNumber = 2,
    kCpuIdFieldNumber = 3,
  };
  void set_name(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_name(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_state(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_cpu_id(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class ClockDisableFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ClockDisableFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ClockDisableFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ClockDisableFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_state() const { return at<2>().valid(); }
  uint64_t state() const { return at<2>().as_uint64(); }
  bool has_cpu_id() const { return at<3>().valid(); }
  uint64_t cpu_id() const { return at<3>().as_uint64(); }
};

class ClockDisableFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = ClockDisableFtraceEvent_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kStateFieldNumber = 2,
    kCpuIdFieldNumber = 3,
  };
  void set_name(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_name(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_state(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_cpu_id(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class ClockEnableFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ClockEnableFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ClockEnableFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ClockEnableFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_state() const { return at<2>().valid(); }
  uint64_t state() const { return at<2>().as_uint64(); }
  bool has_cpu_id() const { return at<3>().valid(); }
  uint64_t cpu_id() const { return at<3>().as_uint64(); }
};

class ClockEnableFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = ClockEnableFtraceEvent_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kStateFieldNumber = 2,
    kCpuIdFieldNumber = 3,
  };
  void set_name(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_name(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_state(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_cpu_id(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class CpuIdleFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  CpuIdleFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit CpuIdleFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit CpuIdleFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_state() const { return at<1>().valid(); }
  uint32_t state() const { return at<1>().as_uint32(); }
  bool has_cpu_id() const { return at<2>().valid(); }
  uint32_t cpu_id() const { return at<2>().as_uint32(); }
};

class CpuIdleFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = CpuIdleFtraceEvent_Decoder;
  enum : int32_t {
    kStateFieldNumber = 1,
    kCpuIdFieldNumber = 2,
  };
  void set_state(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_cpu_id(uint32_t value) {
    AppendVarInt(2, value);
  }
};

class CpuFrequencyLimitsFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  CpuFrequencyLimitsFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit CpuFrequencyLimitsFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit CpuFrequencyLimitsFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_min_freq() const { return at<1>().valid(); }
  uint32_t min_freq() const { return at<1>().as_uint32(); }
  bool has_max_freq() const { return at<2>().valid(); }
  uint32_t max_freq() const { return at<2>().as_uint32(); }
  bool has_cpu_id() const { return at<3>().valid(); }
  uint32_t cpu_id() const { return at<3>().as_uint32(); }
};

class CpuFrequencyLimitsFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = CpuFrequencyLimitsFtraceEvent_Decoder;
  enum : int32_t {
    kMinFreqFieldNumber = 1,
    kMaxFreqFieldNumber = 2,
    kCpuIdFieldNumber = 3,
  };
  void set_min_freq(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_max_freq(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_cpu_id(uint32_t value) {
    AppendVarInt(3, value);
  }
};

class CpuFrequencyFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  CpuFrequencyFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit CpuFrequencyFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit CpuFrequencyFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_state() const { return at<1>().valid(); }
  uint32_t state() const { return at<1>().as_uint32(); }
  bool has_cpu_id() const { return at<2>().valid(); }
  uint32_t cpu_id() const { return at<2>().as_uint32(); }
};

class CpuFrequencyFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = CpuFrequencyFtraceEvent_Decoder;
  enum : int32_t {
    kStateFieldNumber = 1,
    kCpuIdFieldNumber = 2,
  };
  void set_state(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_cpu_id(uint32_t value) {
    AppendVarInt(2, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/raw_syscalls.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_RAW_SYSCALLS_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_RAW_SYSCALLS_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class SysExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SysExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SysExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SysExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_id() const { return at<1>().valid(); }
  int64_t id() const { return at<1>().as_int64(); }
  bool has_ret() const { return at<2>().valid(); }
  int64_t ret() const { return at<2>().as_int64(); }
};

class SysExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SysExitFtraceEvent_Decoder;
  enum : int32_t {
    kIdFieldNumber = 1,
    kRetFieldNumber = 2,
  };
  void set_id(int64_t value) {
    AppendVarInt(1, value);
  }
  void set_ret(int64_t value) {
    AppendVarInt(2, value);
  }
};

class SysEnterFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SysEnterFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SysEnterFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SysEnterFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_id() const { return at<1>().valid(); }
  int64_t id() const { return at<1>().as_int64(); }
};

class SysEnterFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SysEnterFtraceEvent_Decoder;
  enum : int32_t {
    kIdFieldNumber = 1,
  };
  void set_id(int64_t value) {
    AppendVarInt(1, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/regulator.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_REGULATOR_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_REGULATOR_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class RegulatorSetVoltageCompleteFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  RegulatorSetVoltageCompleteFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit RegulatorSetVoltageCompleteFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit RegulatorSetVoltageCompleteFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_val() const { return at<2>().valid(); }
  uint32_t val() const { return at<2>().as_uint32(); }
};

class RegulatorSetVoltageCompleteFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = RegulatorSetVoltageCompleteFtraceEvent_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kValFieldNumber = 2,
  };
  void set_name(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_name(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_val(uint32_t value) {
    AppendVarInt(2, value);
  }
};

class RegulatorSetVoltageFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  RegulatorSetVoltageFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit RegulatorSetVoltageFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit RegulatorSetVoltageFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_min() const { return at<2>().valid(); }
  int32_t min() const { return at<2>().as_int32(); }
  bool has_max() const { return at<3>().valid(); }
  int32_t max() const { return at<3>().as_int32(); }
};

class RegulatorSetVoltageFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = RegulatorSetVoltageFtraceEvent_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kMinFieldNumber = 2,
    kMaxFieldNumber = 3,
  };
  void set_name(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_name(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_min(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_max(int32_t value) {
    AppendVarInt(3, value);
  }
};

class RegulatorEnableDelayFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  RegulatorEnableDelayFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit RegulatorEnableDelayFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit RegulatorEnableDelayFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
};

class RegulatorEnableDelayFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = RegulatorEnableDelayFtraceEvent_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
  };
  void set_name(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_name(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
};

class RegulatorEnableCompleteFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  RegulatorEnableCompleteFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit RegulatorEnableCompleteFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit RegulatorEnableCompleteFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
};

class RegulatorEnableCompleteFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = RegulatorEnableCompleteFtraceEvent_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
  };
  void set_name(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_name(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
};

class RegulatorEnableFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  RegulatorEnableFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit RegulatorEnableFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit RegulatorEnableFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
};

class RegulatorEnableFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = RegulatorEnableFtraceEvent_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
  };
  void set_name(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_name(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
};

class RegulatorDisableCompleteFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  RegulatorDisableCompleteFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit RegulatorDisableCompleteFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit RegulatorDisableCompleteFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
};

class RegulatorDisableCompleteFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = RegulatorDisableCompleteFtraceEvent_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
  };
  void set_name(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_name(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
};

class RegulatorDisableFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  RegulatorDisableFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit RegulatorDisableFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit RegulatorDisableFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
};

class RegulatorDisableFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = RegulatorDisableFtraceEvent_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
  };
  void set_name(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_name(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/sched.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_SCHED_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_SCHED_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class SchedProcessWaitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SchedProcessWaitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SchedProcessWaitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SchedProcessWaitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_comm() const { return at<1>().valid(); }
  ::protozero::ConstChars comm() const { return at<1>().as_string(); }
  bool has_pid() const { return at<2>().valid(); }
  int32_t pid() const { return at<2>().as_int32(); }
  bool has_prio() const { return at<3>().valid(); }
  int32_t prio() const { return at<3>().as_int32(); }
};

class SchedProcessWaitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SchedProcessWaitFtraceEvent_Decoder;
  enum : int32_t {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
    kPrioFieldNumber = 3,
  };
  void set_comm(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_comm(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_pid(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_prio(int32_t value) {
    AppendVarInt(3, value);
  }
};

class SchedProcessHangFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SchedProcessHangFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SchedProcessHangFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SchedProcessHangFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_comm() const { return at<1>().valid(); }
  ::protozero::ConstChars comm() const { return at<1>().as_string(); }
  bool has_pid() const { return at<2>().valid(); }
  int32_t pid() const { return at<2>().as_int32(); }
};

class SchedProcessHangFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SchedProcessHangFtraceEvent_Decoder;
  enum : int32_t {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
  };
  void set_comm(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_comm(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_pid(int32_t value) {
    AppendVarInt(2, value);
  }
};

class SchedProcessFreeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SchedProcessFreeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SchedProcessFreeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SchedProcessFreeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_comm() const { return at<1>().valid(); }
  ::protozero::ConstChars comm() const { return at<1>().as_string(); }
  bool has_pid() const { return at<2>().valid(); }
  int32_t pid() const { return at<2>().as_int32(); }
  bool has_prio() const { return at<3>().valid(); }
  int32_t prio() const { return at<3>().as_int32(); }
};

class SchedProcessFreeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SchedProcessFreeFtraceEvent_Decoder;
  enum : int32_t {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
    kPrioFieldNumber = 3,
  };
  void set_comm(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_comm(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_pid(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_prio(int32_t value) {
    AppendVarInt(3, value);
  }
};

class SchedProcessForkFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SchedProcessForkFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SchedProcessForkFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SchedProcessForkFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_parent_comm() const { return at<1>().valid(); }
  ::protozero::ConstChars parent_comm() const { return at<1>().as_string(); }
  bool has_parent_pid() const { return at<2>().valid(); }
  int32_t parent_pid() const { return at<2>().as_int32(); }
  bool has_child_comm() const { return at<3>().valid(); }
  ::protozero::ConstChars child_comm() const { return at<3>().as_string(); }
  bool has_child_pid() const { return at<4>().valid(); }
  int32_t child_pid() const { return at<4>().as_int32(); }
};

class SchedProcessForkFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SchedProcessForkFtraceEvent_Decoder;
  enum : int32_t {
    kParentCommFieldNumber = 1,
    kParentPidFieldNumber = 2,
    kChildCommFieldNumber = 3,
    kChildPidFieldNumber = 4,
  };
  void set_parent_comm(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_parent_comm(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_parent_pid(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_child_comm(const char* value) {
    AppendString(3, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_child_comm(const char* value, size_t size) {
    AppendBytes(3, value, size);
  }
  void set_child_pid(int32_t value) {
    AppendVarInt(4, value);
  }
};

class SchedProcessExitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SchedProcessExitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SchedProcessExitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SchedProcessExitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_comm() const { return at<1>().valid(); }
  ::protozero::ConstChars comm() const { return at<1>().as_string(); }
  bool has_pid() const { return at<2>().valid(); }
  int32_t pid() const { return at<2>().as_int32(); }
  bool has_tgid() const { return at<3>().valid(); }
  int32_t tgid() const { return at<3>().as_int32(); }
  bool has_prio() const { return at<4>().valid(); }
  int32_t prio() const { return at<4>().as_int32(); }
};

class SchedProcessExitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SchedProcessExitFtraceEvent_Decoder;
  enum : int32_t {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
    kTgidFieldNumber = 3,
    kPrioFieldNumber = 4,
  };
  void set_comm(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_comm(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_pid(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_tgid(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_prio(int32_t value) {
    AppendVarInt(4, value);
  }
};

class SchedProcessExecFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SchedProcessExecFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SchedProcessExecFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SchedProcessExecFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_filename() const { return at<1>().valid(); }
  ::protozero::ConstChars filename() const { return at<1>().as_string(); }
  bool has_pid() const { return at<2>().valid(); }
  int32_t pid() const { return at<2>().as_int32(); }
  bool has_old_pid() const { return at<3>().valid(); }
  int32_t old_pid() const { return at<3>().as_int32(); }
};

class SchedProcessExecFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SchedProcessExecFtraceEvent_Decoder;
  enum : int32_t {
    kFilenameFieldNumber = 1,
    kPidFieldNumber = 2,
    kOldPidFieldNumber = 3,
  };
  void set_filename(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_filename(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_pid(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_old_pid(int32_t value) {
    AppendVarInt(3, value);
  }
};

class SchedWakeupNewFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SchedWakeupNewFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SchedWakeupNewFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SchedWakeupNewFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_comm() const { return at<1>().valid(); }
  ::protozero::ConstChars comm() const { return at<1>().as_string(); }
  bool has_pid() const { return at<2>().valid(); }
  int32_t pid() const { return at<2>().as_int32(); }
  bool has_prio() const { return at<3>().valid(); }
  int32_t prio() const { return at<3>().as_int32(); }
  bool has_success() const { return at<4>().valid(); }
  int32_t success() const { return at<4>().as_int32(); }
  bool has_target_cpu() const { return at<5>().valid(); }
  int32_t target_cpu() const { return at<5>().as_int32(); }
};

class SchedWakeupNewFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SchedWakeupNewFtraceEvent_Decoder;
  enum : int32_t {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
    kPrioFieldNumber = 3,
    kSuccessFieldNumber = 4,
    kTargetCpuFieldNumber = 5,
  };
  void set_comm(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_comm(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_pid(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_prio(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_success(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_target_cpu(int32_t value) {
    AppendVarInt(5, value);
  }
};

class SchedWakingFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SchedWakingFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SchedWakingFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SchedWakingFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_comm() const { return at<1>().valid(); }
  ::protozero::ConstChars comm() const { return at<1>().as_string(); }
  bool has_pid() const { return at<2>().valid(); }
  int32_t pid() const { return at<2>().as_int32(); }
  bool has_prio() const { return at<3>().valid(); }
  int32_t prio() const { return at<3>().as_int32(); }
  bool has_success() const { return at<4>().valid(); }
  int32_t success() const { return at<4>().as_int32(); }
  bool has_target_cpu() const { return at<5>().valid(); }
  int32_t target_cpu() const { return at<5>().as_int32(); }
};

class SchedWakingFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SchedWakingFtraceEvent_Decoder;
  enum : int32_t {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
    kPrioFieldNumber = 3,
    kSuccessFieldNumber = 4,
    kTargetCpuFieldNumber = 5,
  };
  void set_comm(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_comm(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_pid(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_prio(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_success(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_target_cpu(int32_t value) {
    AppendVarInt(5, value);
  }
};

class SchedCpuHotplugFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SchedCpuHotplugFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SchedCpuHotplugFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SchedCpuHotplugFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_affected_cpu() const { return at<1>().valid(); }
  int32_t affected_cpu() const { return at<1>().as_int32(); }
  bool has_error() const { return at<2>().valid(); }
  int32_t error() const { return at<2>().as_int32(); }
  bool has_status() const { return at<3>().valid(); }
  int32_t status() const { return at<3>().as_int32(); }
};

class SchedCpuHotplugFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SchedCpuHotplugFtraceEvent_Decoder;
  enum : int32_t {
    kAffectedCpuFieldNumber = 1,
    kErrorFieldNumber = 2,
    kStatusFieldNumber = 3,
  };
  void set_affected_cpu(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_error(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_status(int32_t value) {
    AppendVarInt(3, value);
  }
};

class SchedBlockedReasonFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SchedBlockedReasonFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SchedBlockedReasonFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SchedBlockedReasonFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_pid() const { return at<1>().valid(); }
  int32_t pid() const { return at<1>().as_int32(); }
  bool has_caller() const { return at<2>().valid(); }
  uint64_t caller() const { return at<2>().as_uint64(); }
  bool has_io_wait() const { return at<3>().valid(); }
  uint32_t io_wait() const { return at<3>().as_uint32(); }
};

class SchedBlockedReasonFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SchedBlockedReasonFtraceEvent_Decoder;
  enum : int32_t {
    kPidFieldNumber = 1,
    kCallerFieldNumber = 2,
    kIoWaitFieldNumber = 3,
  };
  void set_pid(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_caller(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_io_wait(uint32_t value) {
    AppendVarInt(3, value);
  }
};

class SchedWakeupFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SchedWakeupFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SchedWakeupFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SchedWakeupFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_comm() const { return at<1>().valid(); }
  ::protozero::ConstChars comm() const { return at<1>().as_string(); }
  bool has_pid() const { return at<2>().valid(); }
  int32_t pid() const { return at<2>().as_int32(); }
  bool has_prio() const { return at<3>().valid(); }
  int32_t prio() const { return at<3>().as_int32(); }
  bool has_success() const { return at<4>().valid(); }
  int32_t success() const { return at<4>().as_int32(); }
  bool has_target_cpu() const { return at<5>().valid(); }
  int32_t target_cpu() const { return at<5>().as_int32(); }
};

class SchedWakeupFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SchedWakeupFtraceEvent_Decoder;
  enum : int32_t {
    kCommFieldNumber = 1,
    kPidFieldNumber = 2,
    kPrioFieldNumber = 3,
    kSuccessFieldNumber = 4,
    kTargetCpuFieldNumber = 5,
  };
  void set_comm(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_comm(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_pid(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_prio(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_success(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_target_cpu(int32_t value) {
    AppendVarInt(5, value);
  }
};

class SchedSwitchFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/7, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SchedSwitchFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SchedSwitchFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SchedSwitchFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_prev_comm() const { return at<1>().valid(); }
  ::protozero::ConstChars prev_comm() const { return at<1>().as_string(); }
  bool has_prev_pid() const { return at<2>().valid(); }
  int32_t prev_pid() const { return at<2>().as_int32(); }
  bool has_prev_prio() const { return at<3>().valid(); }
  int32_t prev_prio() const { return at<3>().as_int32(); }
  bool has_prev_state() const { return at<4>().valid(); }
  int64_t prev_state() const { return at<4>().as_int64(); }
  bool has_next_comm() const { return at<5>().valid(); }
  ::protozero::ConstChars next_comm() const { return at<5>().as_string(); }
  bool has_next_pid() const { return at<6>().valid(); }
  int32_t next_pid() const { return at<6>().as_int32(); }
  bool has_next_prio() const { return at<7>().valid(); }
  int32_t next_prio() const { return at<7>().as_int32(); }
};

class SchedSwitchFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SchedSwitchFtraceEvent_Decoder;
  enum : int32_t {
    kPrevCommFieldNumber = 1,
    kPrevPidFieldNumber = 2,
    kPrevPrioFieldNumber = 3,
    kPrevStateFieldNumber = 4,
    kNextCommFieldNumber = 5,
    kNextPidFieldNumber = 6,
    kNextPrioFieldNumber = 7,
  };
  void set_prev_comm(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_prev_comm(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_prev_pid(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_prev_prio(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_prev_state(int64_t value) {
    AppendVarInt(4, value);
  }
  void set_next_comm(const char* value) {
    AppendString(5, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_next_comm(const char* value, size_t size) {
    AppendBytes(5, value, size);
  }
  void set_next_pid(int32_t value) {
    AppendVarInt(6, value);
  }
  void set_next_prio(int32_t value) {
    AppendVarInt(7, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/signal.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_SIGNAL_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_SIGNAL_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class SignalGenerateFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SignalGenerateFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SignalGenerateFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SignalGenerateFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_code() const { return at<1>().valid(); }
  int32_t code() const { return at<1>().as_int32(); }
  bool has_comm() const { return at<2>().valid(); }
  ::protozero::ConstChars comm() const { return at<2>().as_string(); }
  bool has_group() const { return at<3>().valid(); }
  int32_t group() const { return at<3>().as_int32(); }
  bool has_pid() const { return at<4>().valid(); }
  int32_t pid() const { return at<4>().as_int32(); }
  bool has_result() const { return at<5>().valid(); }
  int32_t result() const { return at<5>().as_int32(); }
  bool has_sig() const { return at<6>().valid(); }
  int32_t sig() const { return at<6>().as_int32(); }
};

class SignalGenerateFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SignalGenerateFtraceEvent_Decoder;
  enum : int32_t {
    kCodeFieldNumber = 1,
    kCommFieldNumber = 2,
    kGroupFieldNumber = 3,
    kPidFieldNumber = 4,
    kResultFieldNumber = 5,
    kSigFieldNumber = 6,
  };
  void set_code(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_comm(const char* value) {
    AppendString(2, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_comm(const char* value, size_t size) {
    AppendBytes(2, value, size);
  }
  void set_group(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_pid(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_result(int32_t value) {
    AppendVarInt(5, value);
  }
  void set_sig(int32_t value) {
    AppendVarInt(6, value);
  }
};

class SignalDeliverFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SignalDeliverFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SignalDeliverFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SignalDeliverFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_code() const { return at<1>().valid(); }
  int32_t code() const { return at<1>().as_int32(); }
  bool has_sa_flags() const { return at<2>().valid(); }
  uint64_t sa_flags() const { return at<2>().as_uint64(); }
  bool has_sig() const { return at<3>().valid(); }
  int32_t sig() const { return at<3>().as_int32(); }
};

class SignalDeliverFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SignalDeliverFtraceEvent_Decoder;
  enum : int32_t {
    kCodeFieldNumber = 1,
    kSaFlagsFieldNumber = 2,
    kSigFieldNumber = 3,
  };
  void set_code(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_sa_flags(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_sig(int32_t value) {
    AppendVarInt(3, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/sync.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_SYNC_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_SYNC_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class SyncWaitFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SyncWaitFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SyncWaitFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SyncWaitFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_status() const { return at<2>().valid(); }
  int32_t status() const { return at<2>().as_int32(); }
  bool has_begin() const { return at<3>().valid(); }
  uint32_t begin() const { return at<3>().as_uint32(); }
};

class SyncWaitFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SyncWaitFtraceEvent_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kStatusFieldNumber = 2,
    kBeginFieldNumber = 3,
  };
  void set_name(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_name(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_status(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_begin(uint32_t value) {
    AppendVarInt(3, value);
  }
};

class SyncTimelineFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SyncTimelineFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SyncTimelineFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SyncTimelineFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_value() const { return at<2>().valid(); }
  ::protozero::ConstChars value() const { return at<2>().as_string(); }
};

class SyncTimelineFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SyncTimelineFtraceEvent_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  void set_name(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_name(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_value(const char* value) {
    AppendString(2, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_value(const char* value, size_t size) {
    AppendBytes(2, value, size);
  }
};

class SyncPtFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SyncPtFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SyncPtFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SyncPtFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_timeline() const { return at<1>().valid(); }
  ::protozero::ConstChars timeline() const { return at<1>().as_string(); }
  bool has_value() const { return at<2>().valid(); }
  ::protozero::ConstChars value() const { return at<2>().as_string(); }
};

class SyncPtFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = SyncPtFtraceEvent_Decoder;
  enum : int32_t {
    kTimelineFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  void set_timeline(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_timeline(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_value(const char* value) {
    AppendString(2, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_value(const char* value, size_t size) {
    AppendBytes(2, value, size);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/systrace.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_SYSTRACE_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_SYSTRACE_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class ZeroFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ZeroFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ZeroFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ZeroFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_flag() const { return at<1>().valid(); }
  int32_t flag() const { return at<1>().as_int32(); }
  bool has_name() const { return at<2>().valid(); }
  ::protozero::ConstChars name() const { return at<2>().as_string(); }
  bool has_pid() const { return at<3>().valid(); }
  int32_t pid() const { return at<3>().as_int32(); }
  bool has_value() const { return at<4>().valid(); }
  int64_t value() const { return at<4>().as_int64(); }
};

class ZeroFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = ZeroFtraceEvent_Decoder;
  enum : int32_t {
    kFlagFieldNumber = 1,
    kNameFieldNumber = 2,
    kPidFieldNumber = 3,
    kValueFieldNumber = 4,
  };
  void set_flag(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_name(const char* value) {
    AppendString(2, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_name(const char* value, size_t size) {
    AppendBytes(2, value, size);
  }
  void set_pid(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_value(int64_t value) {
    AppendVarInt(4, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/task.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_TASK_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_TASK_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class TaskRenameFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TaskRenameFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TaskRenameFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TaskRenameFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_pid() const { return at<1>().valid(); }
  int32_t pid() const { return at<1>().as_int32(); }
  bool has_oldcomm() const { return at<2>().valid(); }
  ::protozero::ConstChars oldcomm() const { return at<2>().as_string(); }
  bool has_newcomm() const { return at<3>().valid(); }
  ::protozero::ConstChars newcomm() const { return at<3>().as_string(); }
  bool has_oom_score_adj() const { return at<4>().valid(); }
  int32_t oom_score_adj() const { return at<4>().as_int32(); }
};

class TaskRenameFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = TaskRenameFtraceEvent_Decoder;
  enum : int32_t {
    kPidFieldNumber = 1,
    kOldcommFieldNumber = 2,
    kNewcommFieldNumber = 3,
    kOomScoreAdjFieldNumber = 4,
  };
  void set_pid(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_oldcomm(const char* value) {
    AppendString(2, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_oldcomm(const char* value, size_t size) {
    AppendBytes(2, value, size);
  }
  void set_newcomm(const char* value) {
    AppendString(3, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_newcomm(const char* value, size_t size) {
    AppendBytes(3, value, size);
  }
  void set_oom_score_adj(int32_t value) {
    AppendVarInt(4, value);
  }
};

class TaskNewtaskFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TaskNewtaskFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TaskNewtaskFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TaskNewtaskFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_pid() const { return at<1>().valid(); }
  int32_t pid() const { return at<1>().as_int32(); }
  bool has_comm() const { return at<2>().valid(); }
  ::protozero::ConstChars comm() const { return at<2>().as_string(); }
  bool has_clone_flags() const { return at<3>().valid(); }
  uint64_t clone_flags() const { return at<3>().as_uint64(); }
  bool has_oom_score_adj() const { return at<4>().valid(); }
  int32_t oom_score_adj() const { return at<4>().as_int32(); }
};

class TaskNewtaskFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = TaskNewtaskFtraceEvent_Decoder;
  enum : int32_t {
    kPidFieldNumber = 1,
    kCommFieldNumber = 2,
    kCloneFlagsFieldNumber = 3,
    kOomScoreAdjFieldNumber = 4,
  };
  void set_pid(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_comm(const char* value) {
    AppendString(2, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_comm(const char* value, size_t size) {
    AppendBytes(2, value, size);
  }
  void set_clone_flags(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_oom_score_adj(int32_t value) {
    AppendVarInt(4, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/vmscan.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_VMSCAN_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_VMSCAN_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class MmVmscanKswapdSleepFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmVmscanKswapdSleepFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmVmscanKswapdSleepFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmVmscanKswapdSleepFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_nid() const { return at<1>().valid(); }
  int32_t nid() const { return at<1>().as_int32(); }
};

class MmVmscanKswapdSleepFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmVmscanKswapdSleepFtraceEvent_Decoder;
  enum : int32_t {
    kNidFieldNumber = 1,
  };
  void set_nid(int32_t value) {
    AppendVarInt(1, value);
  }
};

class MmVmscanKswapdWakeFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmVmscanKswapdWakeFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmVmscanKswapdWakeFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmVmscanKswapdWakeFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_nid() const { return at<1>().valid(); }
  int32_t nid() const { return at<1>().as_int32(); }
  bool has_order() const { return at<2>().valid(); }
  int32_t order() const { return at<2>().as_int32(); }
};

class MmVmscanKswapdWakeFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmVmscanKswapdWakeFtraceEvent_Decoder;
  enum : int32_t {
    kNidFieldNumber = 1,
    kOrderFieldNumber = 2,
  };
  void set_nid(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_order(int32_t value) {
    AppendVarInt(2, value);
  }
};

class MmVmscanDirectReclaimEndFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmVmscanDirectReclaimEndFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmVmscanDirectReclaimEndFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmVmscanDirectReclaimEndFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_nr_reclaimed() const { return at<1>().valid(); }
  uint64_t nr_reclaimed() const { return at<1>().as_uint64(); }
};

class MmVmscanDirectReclaimEndFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmVmscanDirectReclaimEndFtraceEvent_Decoder;
  enum : int32_t {
    kNrReclaimedFieldNumber = 1,
  };
  void set_nr_reclaimed(uint64_t value) {
    AppendVarInt(1, value);
  }
};

class MmVmscanDirectReclaimBeginFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  MmVmscanDirectReclaimBeginFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit MmVmscanDirectReclaimBeginFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit MmVmscanDirectReclaimBeginFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_order() const { return at<1>().valid(); }
  int32_t order() const { return at<1>().as_int32(); }
  bool has_may_writepage() const { return at<2>().valid(); }
  int32_t may_writepage() const { return at<2>().as_int32(); }
  bool has_gfp_flags() const { return at<3>().valid(); }
  uint32_t gfp_flags() const { return at<3>().as_uint32(); }
};

class MmVmscanDirectReclaimBeginFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = MmVmscanDirectReclaimBeginFtraceEvent_Decoder;
  enum : int32_t {
    kOrderFieldNumber = 1,
    kMayWritepageFieldNumber = 2,
    kGfpFlagsFieldNumber = 3,
  };
  void set_order(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_may_writepage(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_gfp_flags(uint32_t value) {
    AppendVarInt(3, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/workqueue.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_WORKQUEUE_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_FTRACE_WORKQUEUE_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class WorkqueueQueueWorkFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  WorkqueueQueueWorkFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit WorkqueueQueueWorkFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit WorkqueueQueueWorkFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_work() const { return at<1>().valid(); }
  uint64_t work() const { return at<1>().as_uint64(); }
  bool has_function() const { return at<2>().valid(); }
  uint64_t function() const { return at<2>().as_uint64(); }
  bool has_workqueue() const { return at<3>().valid(); }
  uint64_t workqueue() const { return at<3>().as_uint64(); }
  bool has_req_cpu() const { return at<4>().valid(); }
  uint32_t req_cpu() const { return at<4>().as_uint32(); }
  bool has_cpu() const { return at<5>().valid(); }
  uint32_t cpu() const { return at<5>().as_uint32(); }
};

class WorkqueueQueueWorkFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = WorkqueueQueueWorkFtraceEvent_Decoder;
  enum : int32_t {
    kWorkFieldNumber = 1,
    kFunctionFieldNumber = 2,
    kWorkqueueFieldNumber = 3,
    kReqCpuFieldNumber = 4,
    kCpuFieldNumber = 5,
  };
  void set_work(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_function(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_workqueue(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_req_cpu(uint32_t value) {
    AppendVarInt(4, value);
  }
  void set_cpu(uint32_t value) {
    AppendVarInt(5, value);
  }
};

class WorkqueueExecuteStartFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  WorkqueueExecuteStartFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit WorkqueueExecuteStartFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit WorkqueueExecuteStartFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_work() const { return at<1>().valid(); }
  uint64_t work() const { return at<1>().as_uint64(); }
  bool has_function() const { return at<2>().valid(); }
  uint64_t function() const { return at<2>().as_uint64(); }
};

class WorkqueueExecuteStartFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = WorkqueueExecuteStartFtraceEvent_Decoder;
  enum : int32_t {
    kWorkFieldNumber = 1,
    kFunctionFieldNumber = 2,
  };
  void set_work(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_function(uint64_t value) {
    AppendVarInt(2, value);
  }
};

class WorkqueueExecuteEndFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  WorkqueueExecuteEndFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit WorkqueueExecuteEndFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit WorkqueueExecuteEndFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_work() const { return at<1>().valid(); }
  uint64_t work() const { return at<1>().as_uint64(); }
};

class WorkqueueExecuteEndFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = WorkqueueExecuteEndFtraceEvent_Decoder;
  enum : int32_t {
    kWorkFieldNumber = 1,
  };
  void set_work(uint64_t value) {
    AppendVarInt(1, value);
  }
};

class WorkqueueActivateWorkFtraceEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  WorkqueueActivateWorkFtraceEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit WorkqueueActivateWorkFtraceEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit WorkqueueActivateWorkFtraceEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_work() const { return at<1>().valid(); }
  uint64_t work() const { return at<1>().as_uint64(); }
};

class WorkqueueActivateWorkFtraceEvent : public ::protozero::Message {
 public:
  using Decoder = WorkqueueActivateWorkFtraceEvent_Decoder;
  enum : int32_t {
    kWorkFieldNumber = 1,
  };
  void set_work(uint64_t value) {
    AppendVarInt(1, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/gpu/gpu_counter_event.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_GPU_GPU_COUNTER_EVENT_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_GPU_GPU_COUNTER_EVENT_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class GpuCounterDescriptor;
class GpuCounterEvent_GpuCounter;

class GpuCounterEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  GpuCounterEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit GpuCounterEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit GpuCounterEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_counter_descriptor() const { return at<1>().valid(); }
  ::protozero::ConstBytes counter_descriptor() const { return at<1>().as_bytes(); }
  bool has_counters() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator counters() const { return GetRepeated(2); }
  bool has_gpu_id() const { return at<3>().valid(); }
  int32_t gpu_id() const { return at<3>().as_int32(); }
};

class GpuCounterEvent : public ::protozero::Message {
 public:
  using Decoder = GpuCounterEvent_Decoder;
  enum : int32_t {
    kCounterDescriptorFieldNumber = 1,
    kCountersFieldNumber = 2,
    kGpuIdFieldNumber = 3,
  };
  using GpuCounter = ::perfetto::protos::pbzero::GpuCounterEvent_GpuCounter;
  template <typename T = GpuCounterDescriptor> T* set_counter_descriptor() {
    return BeginNestedMessage<T>(1);
  }

  template <typename T = GpuCounterEvent_GpuCounter> T* add_counters() {
    return BeginNestedMessage<T>(2);
  }

  void set_gpu_id(int32_t value) {
    AppendVarInt(3, value);
  }
};

class GpuCounterEvent_GpuCounter_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  GpuCounterEvent_GpuCounter_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit GpuCounterEvent_GpuCounter_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit GpuCounterEvent_GpuCounter_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_counter_id() const { return at<1>().valid(); }
  uint32_t counter_id() const { return at<1>().as_uint32(); }
  bool has_int_value() const { return at<2>().valid(); }
  int64_t int_value() const { return at<2>().as_int64(); }
  bool has_double_value() const { return at<3>().valid(); }
  double double_value() const { return at<3>().as_double(); }
};

class GpuCounterEvent_GpuCounter : public ::protozero::Message {
 public:
  using Decoder = GpuCounterEvent_GpuCounter_Decoder;
  enum : int32_t {
    kCounterIdFieldNumber = 1,
    kIntValueFieldNumber = 2,
    kDoubleValueFieldNumber = 3,
  };
  void set_counter_id(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_int_value(int64_t value) {
    AppendVarInt(2, value);
  }
  void set_double_value(double value) {
    AppendFixed(3, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/gpu/gpu_render_stage_event.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_GPU_GPU_RENDER_STAGE_EVENT_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_GPU_GPU_RENDER_STAGE_EVENT_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class GpuRenderStageEvent_ExtraData;
class GpuRenderStageEvent_Specifications;
class GpuRenderStageEvent_Specifications_ContextSpec;
class GpuRenderStageEvent_Specifications_Description;

class GpuRenderStageEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/11, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  GpuRenderStageEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit GpuRenderStageEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit GpuRenderStageEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_event_id() const { return at<1>().valid(); }
  uint64_t event_id() const { return at<1>().as_uint64(); }
  bool has_duration() const { return at<2>().valid(); }
  uint64_t duration() const { return at<2>().as_uint64(); }
  bool has_hw_queue_id() const { return at<3>().valid(); }
  int32_t hw_queue_id() const { return at<3>().as_int32(); }
  bool has_stage_id() const { return at<4>().valid(); }
  int32_t stage_id() const { return at<4>().as_int32(); }
  bool has_context() const { return at<5>().valid(); }
  uint64_t context() const { return at<5>().as_uint64(); }
  bool has_render_target_handle() const { return at<8>().valid(); }
  uint64_t render_target_handle() const { return at<8>().as_uint64(); }
  bool has_render_pass_handle() const { return at<9>().valid(); }
  uint64_t render_pass_handle() const { return at<9>().as_uint64(); }
  bool has_submission_id() const { return at<10>().valid(); }
  uint32_t submission_id() const { return at<10>().as_uint32(); }
  bool has_extra_data() const { return at<6>().valid(); }
  ::protozero::RepeatedFieldIterator extra_data() const { return GetRepeated(6); }
  bool has_specifications() const { return at<7>().valid(); }
  ::protozero::ConstBytes specifications() const { return at<7>().as_bytes(); }
  bool has_gpu_id() const { return at<11>().valid(); }
  int32_t gpu_id() const { return at<11>().as_int32(); }
};

class GpuRenderStageEvent : public ::protozero::Message {
 public:
  using Decoder = GpuRenderStageEvent_Decoder;
  enum : int32_t {
    kEventIdFieldNumber = 1,
    kDurationFieldNumber = 2,
    kHwQueueIdFieldNumber = 3,
    kStageIdFieldNumber = 4,
    kContextFieldNumber = 5,
    kRenderTargetHandleFieldNumber = 8,
    kRenderPassHandleFieldNumber = 9,
    kSubmissionIdFieldNumber = 10,
    kExtraDataFieldNumber = 6,
    kSpecificationsFieldNumber = 7,
    kGpuIdFieldNumber = 11,
  };
  using ExtraData = ::perfetto::protos::pbzero::GpuRenderStageEvent_ExtraData;
  using Specifications = ::perfetto::protos::pbzero::GpuRenderStageEvent_Specifications;
  void set_event_id(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_duration(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_hw_queue_id(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_stage_id(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_context(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_render_target_handle(uint64_t value) {
    AppendVarInt(8, value);
  }
  void set_render_pass_handle(uint64_t value) {
    AppendVarInt(9, value);
  }
  void set_submission_id(uint32_t value) {
    AppendVarInt(10, value);
  }
  template <typename T = GpuRenderStageEvent_ExtraData> T* add_extra_data() {
    return BeginNestedMessage<T>(6);
  }

  template <typename T = GpuRenderStageEvent_Specifications> T* set_specifications() {
    return BeginNestedMessage<T>(7);
  }

  void set_gpu_id(int32_t value) {
    AppendVarInt(11, value);
  }
};

class GpuRenderStageEvent_Specifications_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  GpuRenderStageEvent_Specifications_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit GpuRenderStageEvent_Specifications_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit GpuRenderStageEvent_Specifications_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_context_spec() const { return at<1>().valid(); }
  ::protozero::ConstBytes context_spec() const { return at<1>().as_bytes(); }
  bool has_hw_queue() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator hw_queue() const { return GetRepeated(2); }
  bool has_stage() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator stage() const { return GetRepeated(3); }
};

class GpuRenderStageEvent_Specifications : public ::protozero::Message {
 public:
  using Decoder = GpuRenderStageEvent_Specifications_Decoder;
  enum : int32_t {
    kContextSpecFieldNumber = 1,
    kHwQueueFieldNumber = 2,
    kStageFieldNumber = 3,
  };
  using ContextSpec = ::perfetto::protos::pbzero::GpuRenderStageEvent_Specifications_ContextSpec;
  using Description = ::perfetto::protos::pbzero::GpuRenderStageEvent_Specifications_Description;
  template <typename T = GpuRenderStageEvent_Specifications_ContextSpec> T* set_context_spec() {
    return BeginNestedMessage<T>(1);
  }

  template <typename T = GpuRenderStageEvent_Specifications_Description> T* add_hw_queue() {
    return BeginNestedMessage<T>(2);
  }

  template <typename T = GpuRenderStageEvent_Specifications_Description> T* add_stage() {
    return BeginNestedMessage<T>(3);
  }

};

class GpuRenderStageEvent_Specifications_Description_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  GpuRenderStageEvent_Specifications_Description_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit GpuRenderStageEvent_Specifications_Description_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit GpuRenderStageEvent_Specifications_Description_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_description() const { return at<2>().valid(); }
  ::protozero::ConstChars description() const { return at<2>().as_string(); }
};

class GpuRenderStageEvent_Specifications_Description : public ::protozero::Message {
 public:
  using Decoder = GpuRenderStageEvent_Specifications_Description_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kDescriptionFieldNumber = 2,
  };
  void set_name(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_name(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_description(const char* value) {
    AppendString(2, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_description(const char* value, size_t size) {
    AppendBytes(2, value, size);
  }
};

class GpuRenderStageEvent_Specifications_ContextSpec_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  GpuRenderStageEvent_Specifications_ContextSpec_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit GpuRenderStageEvent_Specifications_ContextSpec_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit GpuRenderStageEvent_Specifications_ContextSpec_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_context() const { return at<1>().valid(); }
  uint64_t context() const { return at<1>().as_uint64(); }
  bool has_pid() const { return at<2>().valid(); }
  int32_t pid() const { return at<2>().as_int32(); }
};

class GpuRenderStageEvent_Specifications_ContextSpec : public ::protozero::Message {
 public:
  using Decoder = GpuRenderStageEvent_Specifications_ContextSpec_Decoder;
  enum : int32_t {
    kContextFieldNumber = 1,
    kPidFieldNumber = 2,
  };
  void set_context(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_pid(int32_t value) {
    AppendVarInt(2, value);
  }
};

class GpuRenderStageEvent_ExtraData_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  GpuRenderStageEvent_ExtraData_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit GpuRenderStageEvent_ExtraData_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit GpuRenderStageEvent_ExtraData_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name() const { return at<1>().valid(); }
  ::protozero::ConstChars name() const { return at<1>().as_string(); }
  bool has_value() const { return at<2>().valid(); }
  ::protozero::ConstChars value() const { return at<2>().as_string(); }
};

class GpuRenderStageEvent_ExtraData : public ::protozero::Message {
 public:
  using Decoder = GpuRenderStageEvent_ExtraData_Decoder;
  enum : int32_t {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  void set_name(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_name(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_value(const char* value) {
    AppendString(2, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_value(const char* value, size_t size) {
    AppendBytes(2, value, size);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/track_event/debug_annotation.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACK_EVENT_DEBUG_ANNOTATION_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACK_EVENT_DEBUG_ANNOTATION_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class DebugAnnotation_NestedValue;
enum DebugAnnotation_NestedValue_NestedType : int32_t;

enum DebugAnnotation_NestedValue_NestedType : int32_t {
  DebugAnnotation_NestedValue_NestedType_UNSPECIFIED = 0,
  DebugAnnotation_NestedValue_NestedType_DICT = 1,
  DebugAnnotation_NestedValue_NestedType_ARRAY = 2,
};

const DebugAnnotation_NestedValue_NestedType DebugAnnotation_NestedValue_NestedType_MIN = DebugAnnotation_NestedValue_NestedType_UNSPECIFIED;
const DebugAnnotation_NestedValue_NestedType DebugAnnotation_NestedValue_NestedType_MAX = DebugAnnotation_NestedValue_NestedType_ARRAY;

class DebugAnnotationName_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  DebugAnnotationName_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit DebugAnnotationName_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit DebugAnnotationName_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_iid() const { return at<1>().valid(); }
  uint64_t iid() const { return at<1>().as_uint64(); }
  bool has_name() const { return at<2>().valid(); }
  ::protozero::ConstChars name() const { return at<2>().as_string(); }
};

class DebugAnnotationName : public ::protozero::Message {
 public:
  using Decoder = DebugAnnotationName_Decoder;
  enum : int32_t {
    kIidFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  void set_iid(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_name(const char* value) {
    AppendString(2, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_name(const char* value, size_t size) {
    AppendBytes(2, value, size);
  }
};

class DebugAnnotation_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/10, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  DebugAnnotation_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit DebugAnnotation_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit DebugAnnotation_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name_iid() const { return at<1>().valid(); }
  uint64_t name_iid() const { return at<1>().as_uint64(); }
  bool has_name() const { return at<10>().valid(); }
  ::protozero::ConstChars name() const { return at<10>().as_string(); }
  bool has_bool_value() const { return at<2>().valid(); }
  bool bool_value() const { return at<2>().as_bool(); }
  bool has_uint_value() const { return at<3>().valid(); }
  uint64_t uint_value() const { return at<3>().as_uint64(); }
  bool has_int_value() const { return at<4>().valid(); }
  int64_t int_value() const { return at<4>().as_int64(); }
  bool has_double_value() const { return at<5>().valid(); }
  double double_value() const { return at<5>().as_double(); }
  bool has_string_value() const { return at<6>().valid(); }
  ::protozero::ConstChars string_value() const { return at<6>().as_string(); }
  bool has_pointer_value() const { return at<7>().valid(); }
  uint64_t pointer_value() const { return at<7>().as_uint64(); }
  bool has_nested_value() const { return at<8>().valid(); }
  ::protozero::ConstBytes nested_value() const { return at<8>().as_bytes(); }
  bool has_legacy_json_value() const { return at<9>().valid(); }
  ::protozero::ConstChars legacy_json_value() const { return at<9>().as_string(); }
};

class DebugAnnotation : public ::protozero::Message {
 public:
  using Decoder = DebugAnnotation_Decoder;
  enum : int32_t {
    kNameIidFieldNumber = 1,
    kNameFieldNumber = 10,
    kBoolValueFieldNumber = 2,
    kUintValueFieldNumber = 3,
    kIntValueFieldNumber = 4,
    kDoubleValueFieldNumber = 5,
    kStringValueFieldNumber = 6,
    kPointerValueFieldNumber = 7,
    kNestedValueFieldNumber = 8,
    kLegacyJsonValueFieldNumber = 9,
  };
  using NestedValue = ::perfetto::protos::pbzero::DebugAnnotation_NestedValue;
  void set_name_iid(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_name(const char* value) {
    AppendString(10, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_name(const char* value, size_t size) {
    AppendBytes(10, value, size);
  }
  void set_bool_value(bool value) {
    AppendTinyVarInt(2, value);
  }
  void set_uint_value(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_int_value(int64_t value) {
    AppendVarInt(4, value);
  }
  void set_double_value(double value) {
    AppendFixed(5, value);
  }
  void set_string_value(const char* value) {
    AppendString(6, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_string_value(const char* value, size_t size) {
    AppendBytes(6, value, size);
  }
  void set_pointer_value(uint64_t value) {
    AppendVarInt(7, value);
  }
  template <typename T = DebugAnnotation_NestedValue> T* set_nested_value() {
    return BeginNestedMessage<T>(8);
  }

  void set_legacy_json_value(const char* value) {
    AppendString(9, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_legacy_json_value(const char* value, size_t size) {
    AppendBytes(9, value, size);
  }
};

class DebugAnnotation_NestedValue_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  DebugAnnotation_NestedValue_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit DebugAnnotation_NestedValue_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit DebugAnnotation_NestedValue_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_nested_type() const { return at<1>().valid(); }
  int32_t nested_type() const { return at<1>().as_int32(); }
  bool has_dict_keys() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator dict_keys() const { return GetRepeated(2); }
  bool has_dict_values() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator dict_values() const { return GetRepeated(3); }
  bool has_array_values() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator array_values() const { return GetRepeated(4); }
  bool has_int_value() const { return at<5>().valid(); }
  int64_t int_value() const { return at<5>().as_int64(); }
  bool has_double_value() const { return at<6>().valid(); }
  double double_value() const { return at<6>().as_double(); }
  bool has_bool_value() const { return at<7>().valid(); }
  bool bool_value() const { return at<7>().as_bool(); }
  bool has_string_value() const { return at<8>().valid(); }
  ::protozero::ConstChars string_value() const { return at<8>().as_string(); }
};

class DebugAnnotation_NestedValue : public ::protozero::Message {
 public:
  using Decoder = DebugAnnotation_NestedValue_Decoder;
  enum : int32_t {
    kNestedTypeFieldNumber = 1,
    kDictKeysFieldNumber = 2,
    kDictValuesFieldNumber = 3,
    kArrayValuesFieldNumber = 4,
    kIntValueFieldNumber = 5,
    kDoubleValueFieldNumber = 6,
    kBoolValueFieldNumber = 7,
    kStringValueFieldNumber = 8,
  };
  using NestedType = ::perfetto::protos::pbzero::DebugAnnotation_NestedValue_NestedType;
  static const NestedType UNSPECIFIED = DebugAnnotation_NestedValue_NestedType_UNSPECIFIED;
  static const NestedType DICT = DebugAnnotation_NestedValue_NestedType_DICT;
  static const NestedType ARRAY = DebugAnnotation_NestedValue_NestedType_ARRAY;
  void set_nested_type(::perfetto::protos::pbzero::DebugAnnotation_NestedValue_NestedType value) {
    AppendTinyVarInt(1, value);
  }
  void add_dict_keys(const char* value) {
    AppendString(2, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void add_dict_keys(const char* value, size_t size) {
    AppendBytes(2, value, size);
  }
  template <typename T = DebugAnnotation_NestedValue> T* add_dict_values() {
    return BeginNestedMessage<T>(3);
  }

  template <typename T = DebugAnnotation_NestedValue> T* add_array_values() {
    return BeginNestedMessage<T>(4);
  }

  void set_int_value(int64_t value) {
    AppendVarInt(5, value);
  }
  void set_double_value(double value) {
    AppendFixed(6, value);
  }
  void set_bool_value(bool value) {
    AppendTinyVarInt(7, value);
  }
  void set_string_value(const char* value) {
    AppendString(8, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_string_value(const char* value, size_t size) {
    AppendBytes(8, value, size);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/track_event/log_message.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACK_EVENT_LOG_MESSAGE_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACK_EVENT_LOG_MESSAGE_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class LogMessageBody_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  LogMessageBody_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit LogMessageBody_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit LogMessageBody_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_iid() const { return at<1>().valid(); }
  uint64_t iid() const { return at<1>().as_uint64(); }
  bool has_body() const { return at<2>().valid(); }
  ::protozero::ConstChars body() const { return at<2>().as_string(); }
};

class LogMessageBody : public ::protozero::Message {
 public:
  using Decoder = LogMessageBody_Decoder;
  enum : int32_t {
    kIidFieldNumber = 1,
    kBodyFieldNumber = 2,
  };
  void set_iid(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_body(const char* value) {
    AppendString(2, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_body(const char* value, size_t size) {
    AppendBytes(2, value, size);
  }
};

class LogMessage_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  LogMessage_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit LogMessage_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit LogMessage_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_source_location_iid() const { return at<1>().valid(); }
  uint64_t source_location_iid() const { return at<1>().as_uint64(); }
  bool has_body_iid() const { return at<2>().valid(); }
  uint64_t body_iid() const { return at<2>().as_uint64(); }
};

class LogMessage : public ::protozero::Message {
 public:
  using Decoder = LogMessage_Decoder;
  enum : int32_t {
    kSourceLocationIidFieldNumber = 1,
    kBodyIidFieldNumber = 2,
  };
  void set_source_location_iid(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_body_iid(uint64_t value) {
    AppendVarInt(2, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/track_event/process_descriptor.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACK_EVENT_PROCESS_DESCRIPTOR_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACK_EVENT_PROCESS_DESCRIPTOR_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

enum ProcessDescriptor_ChromeProcessType : int32_t;

enum ProcessDescriptor_ChromeProcessType : int32_t {
  ProcessDescriptor_ChromeProcessType_PROCESS_UNSPECIFIED = 0,
  ProcessDescriptor_ChromeProcessType_PROCESS_BROWSER = 1,
  ProcessDescriptor_ChromeProcessType_PROCESS_RENDERER = 2,
  ProcessDescriptor_ChromeProcessType_PROCESS_UTILITY = 3,
  ProcessDescriptor_ChromeProcessType_PROCESS_ZYGOTE = 4,
  ProcessDescriptor_ChromeProcessType_PROCESS_SANDBOX_HELPER = 5,
  ProcessDescriptor_ChromeProcessType_PROCESS_GPU = 6,
  ProcessDescriptor_ChromeProcessType_PROCESS_PPAPI_PLUGIN = 7,
  ProcessDescriptor_ChromeProcessType_PROCESS_PPAPI_BROKER = 8,
};

const ProcessDescriptor_ChromeProcessType ProcessDescriptor_ChromeProcessType_MIN = ProcessDescriptor_ChromeProcessType_PROCESS_UNSPECIFIED;
const ProcessDescriptor_ChromeProcessType ProcessDescriptor_ChromeProcessType_MAX = ProcessDescriptor_ChromeProcessType_PROCESS_PPAPI_BROKER;

class ProcessDescriptor_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/5, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  ProcessDescriptor_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ProcessDescriptor_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ProcessDescriptor_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_pid() const { return at<1>().valid(); }
  int32_t pid() const { return at<1>().as_int32(); }
  bool has_cmdline() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator cmdline() const { return GetRepeated(2); }
  bool has_legacy_sort_index() const { return at<3>().valid(); }
  int32_t legacy_sort_index() const { return at<3>().as_int32(); }
  bool has_chrome_process_type() const { return at<4>().valid(); }
  int32_t chrome_process_type() const { return at<4>().as_int32(); }
  bool has_process_priority() const { return at<5>().valid(); }
  int32_t process_priority() const { return at<5>().as_int32(); }
};

class ProcessDescriptor : public ::protozero::Message {
 public:
  using Decoder = ProcessDescriptor_Decoder;
  enum : int32_t {
    kPidFieldNumber = 1,
    kCmdlineFieldNumber = 2,
    kLegacySortIndexFieldNumber = 3,
    kChromeProcessTypeFieldNumber = 4,
    kProcessPriorityFieldNumber = 5,
  };
  using ChromeProcessType = ::perfetto::protos::pbzero::ProcessDescriptor_ChromeProcessType;
  static const ChromeProcessType PROCESS_UNSPECIFIED = ProcessDescriptor_ChromeProcessType_PROCESS_UNSPECIFIED;
  static const ChromeProcessType PROCESS_BROWSER = ProcessDescriptor_ChromeProcessType_PROCESS_BROWSER;
  static const ChromeProcessType PROCESS_RENDERER = ProcessDescriptor_ChromeProcessType_PROCESS_RENDERER;
  static const ChromeProcessType PROCESS_UTILITY = ProcessDescriptor_ChromeProcessType_PROCESS_UTILITY;
  static const ChromeProcessType PROCESS_ZYGOTE = ProcessDescriptor_ChromeProcessType_PROCESS_ZYGOTE;
  static const ChromeProcessType PROCESS_SANDBOX_HELPER = ProcessDescriptor_ChromeProcessType_PROCESS_SANDBOX_HELPER;
  static const ChromeProcessType PROCESS_GPU = ProcessDescriptor_ChromeProcessType_PROCESS_GPU;
  static const ChromeProcessType PROCESS_PPAPI_PLUGIN = ProcessDescriptor_ChromeProcessType_PROCESS_PPAPI_PLUGIN;
  static const ChromeProcessType PROCESS_PPAPI_BROKER = ProcessDescriptor_ChromeProcessType_PROCESS_PPAPI_BROKER;
  void set_pid(int32_t value) {
    AppendVarInt(1, value);
  }
  void add_cmdline(const char* value) {
    AppendString(2, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void add_cmdline(const char* value, size_t size) {
    AppendBytes(2, value, size);
  }
  void set_legacy_sort_index(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_chrome_process_type(::perfetto::protos::pbzero::ProcessDescriptor_ChromeProcessType value) {
    AppendTinyVarInt(4, value);
  }
  void set_process_priority(int32_t value) {
    AppendVarInt(5, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/track_event/source_location.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACK_EVENT_SOURCE_LOCATION_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACK_EVENT_SOURCE_LOCATION_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class SourceLocation_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SourceLocation_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SourceLocation_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SourceLocation_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_iid() const { return at<1>().valid(); }
  uint64_t iid() const { return at<1>().as_uint64(); }
  bool has_file_name() const { return at<2>().valid(); }
  ::protozero::ConstChars file_name() const { return at<2>().as_string(); }
  bool has_function_name() const { return at<3>().valid(); }
  ::protozero::ConstChars function_name() const { return at<3>().as_string(); }
  bool has_line_number() const { return at<4>().valid(); }
  uint32_t line_number() const { return at<4>().as_uint32(); }
};

class SourceLocation : public ::protozero::Message {
 public:
  using Decoder = SourceLocation_Decoder;
  enum : int32_t {
    kIidFieldNumber = 1,
    kFileNameFieldNumber = 2,
    kFunctionNameFieldNumber = 3,
    kLineNumberFieldNumber = 4,
  };
  void set_iid(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_file_name(const char* value) {
    AppendString(2, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_file_name(const char* value, size_t size) {
    AppendBytes(2, value, size);
  }
  void set_function_name(const char* value) {
    AppendString(3, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_function_name(const char* value, size_t size) {
    AppendBytes(3, value, size);
  }
  void set_line_number(uint32_t value) {
    AppendVarInt(4, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/track_event/task_execution.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACK_EVENT_TASK_EXECUTION_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACK_EVENT_TASK_EXECUTION_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class TaskExecution_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TaskExecution_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TaskExecution_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TaskExecution_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_posted_from_iid() const { return at<1>().valid(); }
  uint64_t posted_from_iid() const { return at<1>().as_uint64(); }
};

class TaskExecution : public ::protozero::Message {
 public:
  using Decoder = TaskExecution_Decoder;
  enum : int32_t {
    kPostedFromIidFieldNumber = 1,
  };
  void set_posted_from_iid(uint64_t value) {
    AppendVarInt(1, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/track_event/thread_descriptor.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACK_EVENT_THREAD_DESCRIPTOR_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACK_EVENT_THREAD_DESCRIPTOR_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

enum ThreadDescriptor_ChromeThreadType : int32_t;

enum ThreadDescriptor_ChromeThreadType : int32_t {
  ThreadDescriptor_ChromeThreadType_CHROME_THREAD_UNSPECIFIED = 0,
  ThreadDescriptor_ChromeThreadType_CHROME_THREAD_MAIN = 1,
  ThreadDescriptor_ChromeThreadType_CHROME_THREAD_IO = 2,
  ThreadDescriptor_ChromeThreadType_CHROME_THREAD_POOL_BG_WORKER = 3,
  ThreadDescriptor_ChromeThreadType_CHROME_THREAD_POOL_FG_WORKER = 4,
  ThreadDescriptor_ChromeThreadType_CHROME_THREAD_POOL_FB_BLOCKING = 5,
  ThreadDescriptor_ChromeThreadType_CHROME_THREAD_POOL_BG_BLOCKING = 6,
  ThreadDescriptor_ChromeThreadType_CHROME_THREAD_POOL_SERVICE = 7,
  ThreadDescriptor_ChromeThreadType_CHROME_THREAD_COMPOSITOR = 8,
  ThreadDescriptor_ChromeThreadType_CHROME_THREAD_VIZ_COMPOSITOR = 9,
  ThreadDescriptor_ChromeThreadType_CHROME_THREAD_COMPOSITOR_WORKER = 10,
  ThreadDescriptor_ChromeThreadType_CHROME_THREAD_SERVICE_WORKER = 11,
  ThreadDescriptor_ChromeThreadType_CHROME_THREAD_MEMORY_INFRA = 50,
  ThreadDescriptor_ChromeThreadType_CHROME_THREAD_SAMPLING_PROFILER = 51,
};

const ThreadDescriptor_ChromeThreadType ThreadDescriptor_ChromeThreadType_MIN = ThreadDescriptor_ChromeThreadType_CHROME_THREAD_UNSPECIFIED;
const ThreadDescriptor_ChromeThreadType ThreadDescriptor_ChromeThreadType_MAX = ThreadDescriptor_ChromeThreadType_CHROME_THREAD_SAMPLING_PROFILER;

class ThreadDescriptor_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ThreadDescriptor_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ThreadDescriptor_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ThreadDescriptor_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_pid() const { return at<1>().valid(); }
  int32_t pid() const { return at<1>().as_int32(); }
  bool has_tid() const { return at<2>().valid(); }
  int32_t tid() const { return at<2>().as_int32(); }
  bool has_legacy_sort_index() const { return at<3>().valid(); }
  int32_t legacy_sort_index() const { return at<3>().as_int32(); }
  bool has_chrome_thread_type() const { return at<4>().valid(); }
  int32_t chrome_thread_type() const { return at<4>().as_int32(); }
  bool has_thread_name() const { return at<5>().valid(); }
  ::protozero::ConstChars thread_name() const { return at<5>().as_string(); }
  bool has_reference_timestamp_us() const { return at<6>().valid(); }
  int64_t reference_timestamp_us() const { return at<6>().as_int64(); }
  bool has_reference_thread_time_us() const { return at<7>().valid(); }
  int64_t reference_thread_time_us() const { return at<7>().as_int64(); }
  bool has_reference_thread_instruction_count() const { return at<8>().valid(); }
  int64_t reference_thread_instruction_count() const { return at<8>().as_int64(); }
};

class ThreadDescriptor : public ::protozero::Message {
 public:
  using Decoder = ThreadDescriptor_Decoder;
  enum : int32_t {
    kPidFieldNumber = 1,
    kTidFieldNumber = 2,
    kLegacySortIndexFieldNumber = 3,
    kChromeThreadTypeFieldNumber = 4,
    kThreadNameFieldNumber = 5,
    kReferenceTimestampUsFieldNumber = 6,
    kReferenceThreadTimeUsFieldNumber = 7,
    kReferenceThreadInstructionCountFieldNumber = 8,
  };
  using ChromeThreadType = ::perfetto::protos::pbzero::ThreadDescriptor_ChromeThreadType;
  static const ChromeThreadType CHROME_THREAD_UNSPECIFIED = ThreadDescriptor_ChromeThreadType_CHROME_THREAD_UNSPECIFIED;
  static const ChromeThreadType CHROME_THREAD_MAIN = ThreadDescriptor_ChromeThreadType_CHROME_THREAD_MAIN;
  static const ChromeThreadType CHROME_THREAD_IO = ThreadDescriptor_ChromeThreadType_CHROME_THREAD_IO;
  static const ChromeThreadType CHROME_THREAD_POOL_BG_WORKER = ThreadDescriptor_ChromeThreadType_CHROME_THREAD_POOL_BG_WORKER;
  static const ChromeThreadType CHROME_THREAD_POOL_FG_WORKER = ThreadDescriptor_ChromeThreadType_CHROME_THREAD_POOL_FG_WORKER;
  static const ChromeThreadType CHROME_THREAD_POOL_FB_BLOCKING = ThreadDescriptor_ChromeThreadType_CHROME_THREAD_POOL_FB_BLOCKING;
  static const ChromeThreadType CHROME_THREAD_POOL_BG_BLOCKING = ThreadDescriptor_ChromeThreadType_CHROME_THREAD_POOL_BG_BLOCKING;
  static const ChromeThreadType CHROME_THREAD_POOL_SERVICE = ThreadDescriptor_ChromeThreadType_CHROME_THREAD_POOL_SERVICE;
  static const ChromeThreadType CHROME_THREAD_COMPOSITOR = ThreadDescriptor_ChromeThreadType_CHROME_THREAD_COMPOSITOR;
  static const ChromeThreadType CHROME_THREAD_VIZ_COMPOSITOR = ThreadDescriptor_ChromeThreadType_CHROME_THREAD_VIZ_COMPOSITOR;
  static const ChromeThreadType CHROME_THREAD_COMPOSITOR_WORKER = ThreadDescriptor_ChromeThreadType_CHROME_THREAD_COMPOSITOR_WORKER;
  static const ChromeThreadType CHROME_THREAD_SERVICE_WORKER = ThreadDescriptor_ChromeThreadType_CHROME_THREAD_SERVICE_WORKER;
  static const ChromeThreadType CHROME_THREAD_MEMORY_INFRA = ThreadDescriptor_ChromeThreadType_CHROME_THREAD_MEMORY_INFRA;
  static const ChromeThreadType CHROME_THREAD_SAMPLING_PROFILER = ThreadDescriptor_ChromeThreadType_CHROME_THREAD_SAMPLING_PROFILER;
  void set_pid(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_tid(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_legacy_sort_index(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_chrome_thread_type(::perfetto::protos::pbzero::ThreadDescriptor_ChromeThreadType value) {
    AppendTinyVarInt(4, value);
  }
  void set_thread_name(const char* value) {
    AppendString(5, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_thread_name(const char* value, size_t size) {
    AppendBytes(5, value, size);
  }
  void set_reference_timestamp_us(int64_t value) {
    AppendVarInt(6, value);
  }
  void set_reference_thread_time_us(int64_t value) {
    AppendVarInt(7, value);
  }
  void set_reference_thread_instruction_count(int64_t value) {
    AppendVarInt(8, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/track_event/track_descriptor.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACK_EVENT_TRACK_DESCRIPTOR_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACK_EVENT_TRACK_DESCRIPTOR_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class ProcessDescriptor;
class ThreadDescriptor;

class TrackDescriptor_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TrackDescriptor_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TrackDescriptor_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TrackDescriptor_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_uuid() const { return at<1>().valid(); }
  uint64_t uuid() const { return at<1>().as_uint64(); }
  bool has_name() const { return at<2>().valid(); }
  ::protozero::ConstChars name() const { return at<2>().as_string(); }
  bool has_process() const { return at<3>().valid(); }
  ::protozero::ConstBytes process() const { return at<3>().as_bytes(); }
  bool has_thread() const { return at<4>().valid(); }
  ::protozero::ConstBytes thread() const { return at<4>().as_bytes(); }
};

class TrackDescriptor : public ::protozero::Message {
 public:
  using Decoder = TrackDescriptor_Decoder;
  enum : int32_t {
    kUuidFieldNumber = 1,
    kNameFieldNumber = 2,
    kProcessFieldNumber = 3,
    kThreadFieldNumber = 4,
  };
  void set_uuid(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_name(const char* value) {
    AppendString(2, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_name(const char* value, size_t size) {
    AppendBytes(2, value, size);
  }
  template <typename T = ProcessDescriptor> T* set_process() {
    return BeginNestedMessage<T>(3);
  }

  template <typename T = ThreadDescriptor> T* set_thread() {
    return BeginNestedMessage<T>(4);
  }

};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/track_event/track_event.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACK_EVENT_TRACK_EVENT_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACK_EVENT_TRACK_EVENT_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class DebugAnnotation;
class LogMessage;
class TaskExecution;
class TrackEvent_LegacyEvent;
enum TrackEvent_LegacyEvent_FlowDirection : int32_t;
enum TrackEvent_LegacyEvent_InstantEventScope : int32_t;
enum TrackEvent_Type : int32_t;

enum TrackEvent_Type : int32_t {
  TrackEvent_Type_TYPE_UNSPECIFIED = 0,
  TrackEvent_Type_TYPE_SLICE_BEGIN = 1,
  TrackEvent_Type_TYPE_SLICE_END = 2,
  TrackEvent_Type_TYPE_INSTANT = 3,
};

const TrackEvent_Type TrackEvent_Type_MIN = TrackEvent_Type_TYPE_UNSPECIFIED;
const TrackEvent_Type TrackEvent_Type_MAX = TrackEvent_Type_TYPE_INSTANT;

enum TrackEvent_LegacyEvent_FlowDirection : int32_t {
  TrackEvent_LegacyEvent_FlowDirection_FLOW_UNSPECIFIED = 0,
  TrackEvent_LegacyEvent_FlowDirection_FLOW_IN = 1,
  TrackEvent_LegacyEvent_FlowDirection_FLOW_OUT = 2,
  TrackEvent_LegacyEvent_FlowDirection_FLOW_INOUT = 3,
};

const TrackEvent_LegacyEvent_FlowDirection TrackEvent_LegacyEvent_FlowDirection_MIN = TrackEvent_LegacyEvent_FlowDirection_FLOW_UNSPECIFIED;
const TrackEvent_LegacyEvent_FlowDirection TrackEvent_LegacyEvent_FlowDirection_MAX = TrackEvent_LegacyEvent_FlowDirection_FLOW_INOUT;

enum TrackEvent_LegacyEvent_InstantEventScope : int32_t {
  TrackEvent_LegacyEvent_InstantEventScope_SCOPE_UNSPECIFIED = 0,
  TrackEvent_LegacyEvent_InstantEventScope_SCOPE_GLOBAL = 1,
  TrackEvent_LegacyEvent_InstantEventScope_SCOPE_PROCESS = 2,
  TrackEvent_LegacyEvent_InstantEventScope_SCOPE_THREAD = 3,
};

const TrackEvent_LegacyEvent_InstantEventScope TrackEvent_LegacyEvent_InstantEventScope_MIN = TrackEvent_LegacyEvent_InstantEventScope_SCOPE_UNSPECIFIED;
const TrackEvent_LegacyEvent_InstantEventScope TrackEvent_LegacyEvent_InstantEventScope_MAX = TrackEvent_LegacyEvent_InstantEventScope_SCOPE_THREAD;

class EventName_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  EventName_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit EventName_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit EventName_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_iid() const { return at<1>().valid(); }
  uint64_t iid() const { return at<1>().as_uint64(); }
  bool has_name() const { return at<2>().valid(); }
  ::protozero::ConstChars name() const { return at<2>().as_string(); }
};

class EventName : public ::protozero::Message {
 public:
  using Decoder = EventName_Decoder;
  enum : int32_t {
    kIidFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  void set_iid(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_name(const char* value) {
    AppendString(2, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_name(const char* value, size_t size) {
    AppendBytes(2, value, size);
  }
};

class EventCategory_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  EventCategory_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit EventCategory_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit EventCategory_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_iid() const { return at<1>().valid(); }
  uint64_t iid() const { return at<1>().as_uint64(); }
  bool has_name() const { return at<2>().valid(); }
  ::protozero::ConstChars name() const { return at<2>().as_string(); }
};

class EventCategory : public ::protozero::Message {
 public:
  using Decoder = EventCategory_Decoder;
  enum : int32_t {
    kIidFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  void set_iid(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_name(const char* value) {
    AppendString(2, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_name(const char* value, size_t size) {
    AppendBytes(2, value, size);
  }
};

class TrackEventDefaults_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/10, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TrackEventDefaults_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TrackEventDefaults_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TrackEventDefaults_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_track_uuid() const { return at<10>().valid(); }
  uint64_t track_uuid() const { return at<10>().as_uint64(); }
};

class TrackEventDefaults : public ::protozero::Message {
 public:
  using Decoder = TrackEventDefaults_Decoder;
  enum : int32_t {
    kTrackUuidFieldNumber = 10,
  };
  void set_track_uuid(uint64_t value) {
    AppendVarInt(10, value);
  }
};

class TrackEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/23, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  TrackEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TrackEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TrackEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_timestamp_delta_us() const { return at<1>().valid(); }
  int64_t timestamp_delta_us() const { return at<1>().as_int64(); }
  bool has_timestamp_absolute_us() const { return at<16>().valid(); }
  int64_t timestamp_absolute_us() const { return at<16>().as_int64(); }
  bool has_thread_time_delta_us() const { return at<2>().valid(); }
  int64_t thread_time_delta_us() const { return at<2>().as_int64(); }
  bool has_thread_time_absolute_us() const { return at<17>().valid(); }
  int64_t thread_time_absolute_us() const { return at<17>().as_int64(); }
  bool has_thread_instruction_count_delta() const { return at<8>().valid(); }
  int64_t thread_instruction_count_delta() const { return at<8>().as_int64(); }
  bool has_thread_instruction_count_absolute() const { return at<20>().valid(); }
  int64_t thread_instruction_count_absolute() const { return at<20>().as_int64(); }
  bool has_category_iids() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator category_iids() const { return GetRepeated(3); }
  bool has_categories() const { return at<22>().valid(); }
  ::protozero::RepeatedFieldIterator categories() const { return GetRepeated(22); }
  bool has_name_iid() const { return at<10>().valid(); }
  uint64_t name_iid() const { return at<10>().as_uint64(); }
  bool has_name() const { return at<23>().valid(); }
  ::protozero::ConstChars name() const { return at<23>().as_string(); }
  bool has_type() const { return at<9>().valid(); }
  int32_t type() const { return at<9>().as_int32(); }
  bool has_track_uuid() const { return at<11>().valid(); }
  uint64_t track_uuid() const { return at<11>().as_uint64(); }
  bool has_debug_annotations() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator debug_annotations() const { return GetRepeated(4); }
  bool has_task_execution() const { return at<5>().valid(); }
  ::protozero::ConstBytes task_execution() const { return at<5>().as_bytes(); }
  bool has_log_message() const { return at<21>().valid(); }
  ::protozero::ConstBytes log_message() const { return at<21>().as_bytes(); }
  bool has_legacy_event() const { return at<6>().valid(); }
  ::protozero::ConstBytes legacy_event() const { return at<6>().as_bytes(); }
};

class TrackEvent : public ::protozero::Message {
 public:
  using Decoder = TrackEvent_Decoder;
  enum : int32_t {
    kTimestampDeltaUsFieldNumber = 1,
    kTimestampAbsoluteUsFieldNumber = 16,
    kThreadTimeDeltaUsFieldNumber = 2,
    kThreadTimeAbsoluteUsFieldNumber = 17,
    kThreadInstructionCountDeltaFieldNumber = 8,
    kThreadInstructionCountAbsoluteFieldNumber = 20,
    kCategoryIidsFieldNumber = 3,
    kCategoriesFieldNumber = 22,
    kNameIidFieldNumber = 10,
    kNameFieldNumber = 23,
    kTypeFieldNumber = 9,
    kTrackUuidFieldNumber = 11,
    kDebugAnnotationsFieldNumber = 4,
    kTaskExecutionFieldNumber = 5,
    kLogMessageFieldNumber = 21,
    kLegacyEventFieldNumber = 6,
  };
  using LegacyEvent = ::perfetto::protos::pbzero::TrackEvent_LegacyEvent;
  using Type = ::perfetto::protos::pbzero::TrackEvent_Type;
  static const Type TYPE_UNSPECIFIED = TrackEvent_Type_TYPE_UNSPECIFIED;
  static const Type TYPE_SLICE_BEGIN = TrackEvent_Type_TYPE_SLICE_BEGIN;
  static const Type TYPE_SLICE_END = TrackEvent_Type_TYPE_SLICE_END;
  static const Type TYPE_INSTANT = TrackEvent_Type_TYPE_INSTANT;
  void set_timestamp_delta_us(int64_t value) {
    AppendVarInt(1, value);
  }
  void set_timestamp_absolute_us(int64_t value) {
    AppendVarInt(16, value);
  }
  void set_thread_time_delta_us(int64_t value) {
    AppendVarInt(2, value);
  }
  void set_thread_time_absolute_us(int64_t value) {
    AppendVarInt(17, value);
  }
  void set_thread_instruction_count_delta(int64_t value) {
    AppendVarInt(8, value);
  }
  void set_thread_instruction_count_absolute(int64_t value) {
    AppendVarInt(20, value);
  }
  void add_category_iids(uint64_t value) {
    AppendVarInt(3, value);
  }
  void add_categories(const char* value) {
    AppendString(22, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void add_categories(const char* value, size_t size) {
    AppendBytes(22, value, size);
  }
  void set_name_iid(uint64_t value) {
    AppendVarInt(10, value);
  }
  void set_name(const char* value) {
    AppendString(23, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_name(const char* value, size_t size) {
    AppendBytes(23, value, size);
  }
  void set_type(::perfetto::protos::pbzero::TrackEvent_Type value) {
    AppendTinyVarInt(9, value);
  }
  void set_track_uuid(uint64_t value) {
    AppendVarInt(11, value);
  }
  template <typename T = DebugAnnotation> T* add_debug_annotations() {
    return BeginNestedMessage<T>(4);
  }

  template <typename T = TaskExecution> T* set_task_execution() {
    return BeginNestedMessage<T>(5);
  }

  template <typename T = LogMessage> T* set_log_message() {
    return BeginNestedMessage<T>(21);
  }

  template <typename T = TrackEvent_LegacyEvent> T* set_legacy_event() {
    return BeginNestedMessage<T>(6);
  }

};

class TrackEvent_LegacyEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/19, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TrackEvent_LegacyEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TrackEvent_LegacyEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TrackEvent_LegacyEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_name_iid() const { return at<1>().valid(); }
  uint64_t name_iid() const { return at<1>().as_uint64(); }
  bool has_phase() const { return at<2>().valid(); }
  int32_t phase() const { return at<2>().as_int32(); }
  bool has_duration_us() const { return at<3>().valid(); }
  int64_t duration_us() const { return at<3>().as_int64(); }
  bool has_thread_duration_us() const { return at<4>().valid(); }
  int64_t thread_duration_us() const { return at<4>().as_int64(); }
  bool has_thread_instruction_delta() const { return at<15>().valid(); }
  int64_t thread_instruction_delta() const { return at<15>().as_int64(); }
  bool has_unscoped_id() const { return at<6>().valid(); }
  uint64_t unscoped_id() const { return at<6>().as_uint64(); }
  bool has_local_id() const { return at<10>().valid(); }
  uint64_t local_id() const { return at<10>().as_uint64(); }
  bool has_global_id() const { return at<11>().valid(); }
  uint64_t global_id() const { return at<11>().as_uint64(); }
  bool has_id_scope() const { return at<7>().valid(); }
  ::protozero::ConstChars id_scope() const { return at<7>().as_string(); }
  bool has_use_async_tts() const { return at<9>().valid(); }
  bool use_async_tts() const { return at<9>().as_bool(); }
  bool has_bind_id() const { return at<8>().valid(); }
  uint64_t bind_id() const { return at<8>().as_uint64(); }
  bool has_bind_to_enclosing() const { return at<12>().valid(); }
  bool bind_to_enclosing() const { return at<12>().as_bool(); }
  bool has_flow_direction() const { return at<13>().valid(); }
  int32_t flow_direction() const { return at<13>().as_int32(); }
  bool has_instant_event_scope() const { return at<14>().valid(); }
  int32_t instant_event_scope() const { return at<14>().as_int32(); }
  bool has_pid_override() const { return at<18>().valid(); }
  int32_t pid_override() const { return at<18>().as_int32(); }
  bool has_tid_override() const { return at<19>().valid(); }
  int32_t tid_override() const { return at<19>().as_int32(); }
};

class TrackEvent_LegacyEvent : public ::protozero::Message {
 public:
  using Decoder = TrackEvent_LegacyEvent_Decoder;
  enum : int32_t {
    kNameIidFieldNumber = 1,
    kPhaseFieldNumber = 2,
    kDurationUsFieldNumber = 3,
    kThreadDurationUsFieldNumber = 4,
    kThreadInstructionDeltaFieldNumber = 15,
    kUnscopedIdFieldNumber = 6,
    kLocalIdFieldNumber = 10,
    kGlobalIdFieldNumber = 11,
    kIdScopeFieldNumber = 7,
    kUseAsyncTtsFieldNumber = 9,
    kBindIdFieldNumber = 8,
    kBindToEnclosingFieldNumber = 12,
    kFlowDirectionFieldNumber = 13,
    kInstantEventScopeFieldNumber = 14,
    kPidOverrideFieldNumber = 18,
    kTidOverrideFieldNumber = 19,
  };
  using FlowDirection = ::perfetto::protos::pbzero::TrackEvent_LegacyEvent_FlowDirection;
  using InstantEventScope = ::perfetto::protos::pbzero::TrackEvent_LegacyEvent_InstantEventScope;
  static const FlowDirection FLOW_UNSPECIFIED = TrackEvent_LegacyEvent_FlowDirection_FLOW_UNSPECIFIED;
  static const FlowDirection FLOW_IN = TrackEvent_LegacyEvent_FlowDirection_FLOW_IN;
  static const FlowDirection FLOW_OUT = TrackEvent_LegacyEvent_FlowDirection_FLOW_OUT;
  static const FlowDirection FLOW_INOUT = TrackEvent_LegacyEvent_FlowDirection_FLOW_INOUT;
  static const InstantEventScope SCOPE_UNSPECIFIED = TrackEvent_LegacyEvent_InstantEventScope_SCOPE_UNSPECIFIED;
  static const InstantEventScope SCOPE_GLOBAL = TrackEvent_LegacyEvent_InstantEventScope_SCOPE_GLOBAL;
  static const InstantEventScope SCOPE_PROCESS = TrackEvent_LegacyEvent_InstantEventScope_SCOPE_PROCESS;
  static const InstantEventScope SCOPE_THREAD = TrackEvent_LegacyEvent_InstantEventScope_SCOPE_THREAD;
  void set_name_iid(uint64_t value) {
    AppendVarInt(1, value);
  }
  void set_phase(int32_t value) {
    AppendVarInt(2, value);
  }
  void set_duration_us(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_thread_duration_us(int64_t value) {
    AppendVarInt(4, value);
  }
  void set_thread_instruction_delta(int64_t value) {
    AppendVarInt(15, value);
  }
  void set_unscoped_id(uint64_t value) {
    AppendVarInt(6, value);
  }
  void set_local_id(uint64_t value) {
    AppendVarInt(10, value);
  }
  void set_global_id(uint64_t value) {
    AppendVarInt(11, value);
  }
  void set_id_scope(const char* value) {
    AppendString(7, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_id_scope(const char* value, size_t size) {
    AppendBytes(7, value, size);
  }
  void set_use_async_tts(bool value) {
    AppendTinyVarInt(9, value);
  }
  void set_bind_id(uint64_t value) {
    AppendVarInt(8, value);
  }
  void set_bind_to_enclosing(bool value) {
    AppendTinyVarInt(12, value);
  }
  void set_flow_direction(::perfetto::protos::pbzero::TrackEvent_LegacyEvent_FlowDirection value) {
    AppendTinyVarInt(13, value);
  }
  void set_instant_event_scope(::perfetto::protos::pbzero::TrackEvent_LegacyEvent_InstantEventScope value) {
    AppendTinyVarInt(14, value);
  }
  void set_pid_override(int32_t value) {
    AppendVarInt(18, value);
  }
  void set_tid_override(int32_t value) {
    AppendVarInt(19, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/interned_data/interned_data.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_INTERNED_DATA_INTERNED_DATA_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_INTERNED_DATA_INTERNED_DATA_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class Callstack;
class DebugAnnotationName;
class EventCategory;
class EventName;
class Frame;
class InternedString;
class LogMessageBody;
class Mapping;
class ProfiledFrameSymbols;
class SourceLocation;

class InternedData_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/21, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  InternedData_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit InternedData_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit InternedData_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_event_categories() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator event_categories() const { return GetRepeated(1); }
  bool has_event_names() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator event_names() const { return GetRepeated(2); }
  bool has_debug_annotation_names() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator debug_annotation_names() const { return GetRepeated(3); }
  bool has_source_locations() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator source_locations() const { return GetRepeated(4); }
  bool has_log_message_body() const { return at<20>().valid(); }
  ::protozero::RepeatedFieldIterator log_message_body() const { return GetRepeated(20); }
  bool has_build_ids() const { return at<16>().valid(); }
  ::protozero::RepeatedFieldIterator build_ids() const { return GetRepeated(16); }
  bool has_mapping_paths() const { return at<17>().valid(); }
  ::protozero::RepeatedFieldIterator mapping_paths() const { return GetRepeated(17); }
  bool has_source_paths() const { return at<18>().valid(); }
  ::protozero::RepeatedFieldIterator source_paths() const { return GetRepeated(18); }
  bool has_function_names() const { return at<5>().valid(); }
  ::protozero::RepeatedFieldIterator function_names() const { return GetRepeated(5); }
  bool has_profiled_frame_symbols() const { return at<21>().valid(); }
  ::protozero::RepeatedFieldIterator profiled_frame_symbols() const { return GetRepeated(21); }
  bool has_mappings() const { return at<19>().valid(); }
  ::protozero::RepeatedFieldIterator mappings() const { return GetRepeated(19); }
  bool has_frames() const { return at<6>().valid(); }
  ::protozero::RepeatedFieldIterator frames() const { return GetRepeated(6); }
  bool has_callstacks() const { return at<7>().valid(); }
  ::protozero::RepeatedFieldIterator callstacks() const { return GetRepeated(7); }
};

class InternedData : public ::protozero::Message {
 public:
  using Decoder = InternedData_Decoder;
  enum : int32_t {
    kEventCategoriesFieldNumber = 1,
    kEventNamesFieldNumber = 2,
    kDebugAnnotationNamesFieldNumber = 3,
    kSourceLocationsFieldNumber = 4,
    kLogMessageBodyFieldNumber = 20,
    kBuildIdsFieldNumber = 16,
    kMappingPathsFieldNumber = 17,
    kSourcePathsFieldNumber = 18,
    kFunctionNamesFieldNumber = 5,
    kProfiledFrameSymbolsFieldNumber = 21,
    kMappingsFieldNumber = 19,
    kFramesFieldNumber = 6,
    kCallstacksFieldNumber = 7,
  };
  template <typename T = EventCategory> T* add_event_categories() {
    return BeginNestedMessage<T>(1);
  }

  template <typename T = EventName> T* add_event_names() {
    return BeginNestedMessage<T>(2);
  }

  template <typename T = DebugAnnotationName> T* add_debug_annotation_names() {
    return BeginNestedMessage<T>(3);
  }

  template <typename T = SourceLocation> T* add_source_locations() {
    return BeginNestedMessage<T>(4);
  }

  template <typename T = LogMessageBody> T* add_log_message_body() {
    return BeginNestedMessage<T>(20);
  }

  template <typename T = InternedString> T* add_build_ids() {
    return BeginNestedMessage<T>(16);
  }

  template <typename T = InternedString> T* add_mapping_paths() {
    return BeginNestedMessage<T>(17);
  }

  template <typename T = InternedString> T* add_source_paths() {
    return BeginNestedMessage<T>(18);
  }

  template <typename T = InternedString> T* add_function_names() {
    return BeginNestedMessage<T>(5);
  }

  template <typename T = ProfiledFrameSymbols> T* add_profiled_frame_symbols() {
    return BeginNestedMessage<T>(21);
  }

  template <typename T = Mapping> T* add_mappings() {
    return BeginNestedMessage<T>(19);
  }

  template <typename T = Frame> T* add_frames() {
    return BeginNestedMessage<T>(6);
  }

  template <typename T = Callstack> T* add_callstacks() {
    return BeginNestedMessage<T>(7);
  }

};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/perfetto/perfetto_metatrace.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_PERFETTO_PERFETTO_METATRACE_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_PERFETTO_PERFETTO_METATRACE_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class PerfettoMetatrace_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  PerfettoMetatrace_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit PerfettoMetatrace_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit PerfettoMetatrace_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_event_id() const { return at<1>().valid(); }
  uint32_t event_id() const { return at<1>().as_uint32(); }
  bool has_counter_id() const { return at<2>().valid(); }
  uint32_t counter_id() const { return at<2>().as_uint32(); }
  bool has_event_duration_ns() const { return at<3>().valid(); }
  uint32_t event_duration_ns() const { return at<3>().as_uint32(); }
  bool has_counter_value() const { return at<4>().valid(); }
  int32_t counter_value() const { return at<4>().as_int32(); }
  bool has_thread_id() const { return at<5>().valid(); }
  uint32_t thread_id() const { return at<5>().as_uint32(); }
  bool has_has_overruns() const { return at<6>().valid(); }
  bool has_overruns() const { return at<6>().as_bool(); }
};

class PerfettoMetatrace : public ::protozero::Message {
 public:
  using Decoder = PerfettoMetatrace_Decoder;
  enum : int32_t {
    kEventIdFieldNumber = 1,
    kCounterIdFieldNumber = 2,
    kEventDurationNsFieldNumber = 3,
    kCounterValueFieldNumber = 4,
    kThreadIdFieldNumber = 5,
    kHasOverrunsFieldNumber = 6,
  };
  void set_event_id(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_counter_id(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_event_duration_ns(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_counter_value(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_thread_id(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_has_overruns(bool value) {
    AppendTinyVarInt(6, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/power/battery_counters.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_POWER_BATTERY_COUNTERS_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_POWER_BATTERY_COUNTERS_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class BatteryCounters_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  BatteryCounters_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit BatteryCounters_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit BatteryCounters_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_charge_counter_uah() const { return at<1>().valid(); }
  int64_t charge_counter_uah() const { return at<1>().as_int64(); }
  bool has_capacity_percent() const { return at<2>().valid(); }
  float capacity_percent() const { return at<2>().as_float(); }
  bool has_current_ua() const { return at<3>().valid(); }
  int64_t current_ua() const { return at<3>().as_int64(); }
  bool has_current_avg_ua() const { return at<4>().valid(); }
  int64_t current_avg_ua() const { return at<4>().as_int64(); }
};

class BatteryCounters : public ::protozero::Message {
 public:
  using Decoder = BatteryCounters_Decoder;
  enum : int32_t {
    kChargeCounterUahFieldNumber = 1,
    kCapacityPercentFieldNumber = 2,
    kCurrentUaFieldNumber = 3,
    kCurrentAvgUaFieldNumber = 4,
  };
  void set_charge_counter_uah(int64_t value) {
    AppendVarInt(1, value);
  }
  void set_capacity_percent(float value) {
    AppendFixed(2, value);
  }
  void set_current_ua(int64_t value) {
    AppendVarInt(3, value);
  }
  void set_current_avg_ua(int64_t value) {
    AppendVarInt(4, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/power/power_rails.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_POWER_POWER_RAILS_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_POWER_POWER_RAILS_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class PowerRails_EnergyData;
class PowerRails_RailDescriptor;

class PowerRails_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  PowerRails_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit PowerRails_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit PowerRails_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_rail_descriptor() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator rail_descriptor() const { return GetRepeated(1); }
  bool has_energy_data() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator energy_data() const { return GetRepeated(2); }
};

class PowerRails : public ::protozero::Message {
 public:
  using Decoder = PowerRails_Decoder;
  enum : int32_t {
    kRailDescriptorFieldNumber = 1,
    kEnergyDataFieldNumber = 2,
  };
  using RailDescriptor = ::perfetto::protos::pbzero::PowerRails_RailDescriptor;
  using EnergyData = ::perfetto::protos::pbzero::PowerRails_EnergyData;
  template <typename T = PowerRails_RailDescriptor> T* add_rail_descriptor() {
    return BeginNestedMessage<T>(1);
  }

  template <typename T = PowerRails_EnergyData> T* add_energy_data() {
    return BeginNestedMessage<T>(2);
  }

};

class PowerRails_EnergyData_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  PowerRails_EnergyData_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit PowerRails_EnergyData_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit PowerRails_EnergyData_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_index() const { return at<1>().valid(); }
  uint32_t index() const { return at<1>().as_uint32(); }
  bool has_timestamp_ms() const { return at<2>().valid(); }
  uint64_t timestamp_ms() const { return at<2>().as_uint64(); }
  bool has_energy() const { return at<3>().valid(); }
  uint64_t energy() const { return at<3>().as_uint64(); }
};

class PowerRails_EnergyData : public ::protozero::Message {
 public:
  using Decoder = PowerRails_EnergyData_Decoder;
  enum : int32_t {
    kIndexFieldNumber = 1,
    kTimestampMsFieldNumber = 2,
    kEnergyFieldNumber = 3,
  };
  void set_index(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_timestamp_ms(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_energy(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class PowerRails_RailDescriptor_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  PowerRails_RailDescriptor_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit PowerRails_RailDescriptor_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit PowerRails_RailDescriptor_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_index() const { return at<1>().valid(); }
  uint32_t index() const { return at<1>().as_uint32(); }
  bool has_rail_name() const { return at<2>().valid(); }
  ::protozero::ConstChars rail_name() const { return at<2>().as_string(); }
  bool has_subsys_name() const { return at<3>().valid(); }
  ::protozero::ConstChars subsys_name() const { return at<3>().as_string(); }
  bool has_sampling_rate() const { return at<4>().valid(); }
  uint32_t sampling_rate() const { return at<4>().as_uint32(); }
};

class PowerRails_RailDescriptor : public ::protozero::Message {
 public:
  using Decoder = PowerRails_RailDescriptor_Decoder;
  enum : int32_t {
    kIndexFieldNumber = 1,
    kRailNameFieldNumber = 2,
    kSubsysNameFieldNumber = 3,
    kSamplingRateFieldNumber = 4,
  };
  void set_index(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_rail_name(const char* value) {
    AppendString(2, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_rail_name(const char* value, size_t size) {
    AppendBytes(2, value, size);
  }
  void set_subsys_name(const char* value) {
    AppendString(3, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_subsys_name(const char* value, size_t size) {
    AppendBytes(3, value, size);
  }
  void set_sampling_rate(uint32_t value) {
    AppendVarInt(4, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ps/process_stats.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_PS_PROCESS_STATS_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_PS_PROCESS_STATS_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class ProcessStats_Process;

class ProcessStats_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  ProcessStats_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ProcessStats_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ProcessStats_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_processes() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator processes() const { return GetRepeated(1); }
  bool has_collection_end_timestamp() const { return at<2>().valid(); }
  uint64_t collection_end_timestamp() const { return at<2>().as_uint64(); }
};

class ProcessStats : public ::protozero::Message {
 public:
  using Decoder = ProcessStats_Decoder;
  enum : int32_t {
    kProcessesFieldNumber = 1,
    kCollectionEndTimestampFieldNumber = 2,
  };
  using Process = ::perfetto::protos::pbzero::ProcessStats_Process;
  template <typename T = ProcessStats_Process> T* add_processes() {
    return BeginNestedMessage<T>(1);
  }

  void set_collection_end_timestamp(uint64_t value) {
    AppendVarInt(2, value);
  }
};

class ProcessStats_Process_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/10, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ProcessStats_Process_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ProcessStats_Process_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ProcessStats_Process_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_pid() const { return at<1>().valid(); }
  int32_t pid() const { return at<1>().as_int32(); }
  bool has_vm_size_kb() const { return at<2>().valid(); }
  uint64_t vm_size_kb() const { return at<2>().as_uint64(); }
  bool has_vm_rss_kb() const { return at<3>().valid(); }
  uint64_t vm_rss_kb() const { return at<3>().as_uint64(); }
  bool has_rss_anon_kb() const { return at<4>().valid(); }
  uint64_t rss_anon_kb() const { return at<4>().as_uint64(); }
  bool has_rss_file_kb() const { return at<5>().valid(); }
  uint64_t rss_file_kb() const { return at<5>().as_uint64(); }
  bool has_rss_shmem_kb() const { return at<6>().valid(); }
  uint64_t rss_shmem_kb() const { return at<6>().as_uint64(); }
  bool has_vm_swap_kb() const { return at<7>().valid(); }
  uint64_t vm_swap_kb() const { return at<7>().as_uint64(); }
  bool has_vm_locked_kb() const { return at<8>().valid(); }
  uint64_t vm_locked_kb() const { return at<8>().as_uint64(); }
  bool has_vm_hwm_kb() const { return at<9>().valid(); }
  uint64_t vm_hwm_kb() const { return at<9>().as_uint64(); }
  bool has_oom_score_adj() const { return at<10>().valid(); }
  int64_t oom_score_adj() const { return at<10>().as_int64(); }
};

class ProcessStats_Process : public ::protozero::Message {
 public:
  using Decoder = ProcessStats_Process_Decoder;
  enum : int32_t {
    kPidFieldNumber = 1,
    kVmSizeKbFieldNumber = 2,
    kVmRssKbFieldNumber = 3,
    kRssAnonKbFieldNumber = 4,
    kRssFileKbFieldNumber = 5,
    kRssShmemKbFieldNumber = 6,
    kVmSwapKbFieldNumber = 7,
    kVmLockedKbFieldNumber = 8,
    kVmHwmKbFieldNumber = 9,
    kOomScoreAdjFieldNumber = 10,
  };
  void set_pid(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_vm_size_kb(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_vm_rss_kb(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_rss_anon_kb(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_rss_file_kb(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_rss_shmem_kb(uint64_t value) {
    AppendVarInt(6, value);
  }
  void set_vm_swap_kb(uint64_t value) {
    AppendVarInt(7, value);
  }
  void set_vm_locked_kb(uint64_t value) {
    AppendVarInt(8, value);
  }
  void set_vm_hwm_kb(uint64_t value) {
    AppendVarInt(9, value);
  }
  void set_oom_score_adj(int64_t value) {
    AppendVarInt(10, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ps/process_tree.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_PS_PROCESS_TREE_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_PS_PROCESS_TREE_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class ProcessTree_Process;
class ProcessTree_Thread;

class ProcessTree_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  ProcessTree_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ProcessTree_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ProcessTree_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_processes() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator processes() const { return GetRepeated(1); }
  bool has_threads() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator threads() const { return GetRepeated(2); }
  bool has_collection_end_timestamp() const { return at<3>().valid(); }
  uint64_t collection_end_timestamp() const { return at<3>().as_uint64(); }
};

class ProcessTree : public ::protozero::Message {
 public:
  using Decoder = ProcessTree_Decoder;
  enum : int32_t {
    kProcessesFieldNumber = 1,
    kThreadsFieldNumber = 2,
    kCollectionEndTimestampFieldNumber = 3,
  };
  using Thread = ::perfetto::protos::pbzero::ProcessTree_Thread;
  using Process = ::perfetto::protos::pbzero::ProcessTree_Process;
  template <typename T = ProcessTree_Process> T* add_processes() {
    return BeginNestedMessage<T>(1);
  }

  template <typename T = ProcessTree_Thread> T* add_threads() {
    return BeginNestedMessage<T>(2);
  }

  void set_collection_end_timestamp(uint64_t value) {
    AppendVarInt(3, value);
  }
};

class ProcessTree_Process_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/4, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  ProcessTree_Process_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ProcessTree_Process_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ProcessTree_Process_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_pid() const { return at<1>().valid(); }
  int32_t pid() const { return at<1>().as_int32(); }
  bool has_ppid() const { return at<2>().valid(); }
  int32_t ppid() const { return at<2>().as_int32(); }
  bool has_cmdline() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator cmdline() const { return GetRepeated(3); }
  bool has_threads_deprecated() const { return at<4>().valid(); }
  ::protozero::RepeatedFieldIterator threads_deprecated() const { return GetRepeated(4); }
};

class ProcessTree_Process : public ::protozero::Message {
 public:
  using Decoder = ProcessTree_Process_Decoder;
  enum : int32_t {
    kPidFieldNumber = 1,
    kPpidFieldNumber = 2,
    kCmdlineFieldNumber = 3,
    kThreadsDeprecatedFieldNumber = 4,
  };
  void set_pid(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_ppid(int32_t value) {
    AppendVarInt(2, value);
  }
  void add_cmdline(const char* value) {
    AppendString(3, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void add_cmdline(const char* value, size_t size) {
    AppendBytes(3, value, size);
  }
  template <typename T = ProcessTree_Thread> T* add_threads_deprecated() {
    return BeginNestedMessage<T>(4);
  }

};

class ProcessTree_Thread_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/3, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  ProcessTree_Thread_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit ProcessTree_Thread_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit ProcessTree_Thread_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_tid() const { return at<1>().valid(); }
  int32_t tid() const { return at<1>().as_int32(); }
  bool has_tgid() const { return at<3>().valid(); }
  int32_t tgid() const { return at<3>().as_int32(); }
  bool has_name() const { return at<2>().valid(); }
  ::protozero::ConstChars name() const { return at<2>().as_string(); }
};

class ProcessTree_Thread : public ::protozero::Message {
 public:
  using Decoder = ProcessTree_Thread_Decoder;
  enum : int32_t {
    kTidFieldNumber = 1,
    kTgidFieldNumber = 3,
    kNameFieldNumber = 2,
  };
  void set_tid(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_tgid(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_name(const char* value) {
    AppendString(2, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_name(const char* value, size_t size) {
    AppendBytes(2, value, size);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/sys_stats/sys_stats.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_SYS_STATS_SYS_STATS_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_SYS_STATS_SYS_STATS_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class SysStats_CpuTimes;
class SysStats_InterruptCount;
class SysStats_MeminfoValue;
class SysStats_VmstatValue;
enum MeminfoCounters : int32_t;
enum VmstatCounters : int32_t;

class SysStats_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/9, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  SysStats_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SysStats_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SysStats_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_meminfo() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator meminfo() const { return GetRepeated(1); }
  bool has_vmstat() const { return at<2>().valid(); }
  ::protozero::RepeatedFieldIterator vmstat() const { return GetRepeated(2); }
  bool has_cpu_stat() const { return at<3>().valid(); }
  ::protozero::RepeatedFieldIterator cpu_stat() const { return GetRepeated(3); }
  bool has_num_forks() const { return at<4>().valid(); }
  uint64_t num_forks() const { return at<4>().as_uint64(); }
  bool has_num_irq_total() const { return at<5>().valid(); }
  uint64_t num_irq_total() const { return at<5>().as_uint64(); }
  bool has_num_irq() const { return at<6>().valid(); }
  ::protozero::RepeatedFieldIterator num_irq() const { return GetRepeated(6); }
  bool has_num_softirq_total() const { return at<7>().valid(); }
  uint64_t num_softirq_total() const { return at<7>().as_uint64(); }
  bool has_num_softirq() const { return at<8>().valid(); }
  ::protozero::RepeatedFieldIterator num_softirq() const { return GetRepeated(8); }
  bool has_collection_end_timestamp() const { return at<9>().valid(); }
  uint64_t collection_end_timestamp() const { return at<9>().as_uint64(); }
};

class SysStats : public ::protozero::Message {
 public:
  using Decoder = SysStats_Decoder;
  enum : int32_t {
    kMeminfoFieldNumber = 1,
    kVmstatFieldNumber = 2,
    kCpuStatFieldNumber = 3,
    kNumForksFieldNumber = 4,
    kNumIrqTotalFieldNumber = 5,
    kNumIrqFieldNumber = 6,
    kNumSoftirqTotalFieldNumber = 7,
    kNumSoftirqFieldNumber = 8,
    kCollectionEndTimestampFieldNumber = 9,
  };
  using MeminfoValue = ::perfetto::protos::pbzero::SysStats_MeminfoValue;
  using VmstatValue = ::perfetto::protos::pbzero::SysStats_VmstatValue;
  using CpuTimes = ::perfetto::protos::pbzero::SysStats_CpuTimes;
  using InterruptCount = ::perfetto::protos::pbzero::SysStats_InterruptCount;
  template <typename T = SysStats_MeminfoValue> T* add_meminfo() {
    return BeginNestedMessage<T>(1);
  }

  template <typename T = SysStats_VmstatValue> T* add_vmstat() {
    return BeginNestedMessage<T>(2);
  }

  template <typename T = SysStats_CpuTimes> T* add_cpu_stat() {
    return BeginNestedMessage<T>(3);
  }

  void set_num_forks(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_num_irq_total(uint64_t value) {
    AppendVarInt(5, value);
  }
  template <typename T = SysStats_InterruptCount> T* add_num_irq() {
    return BeginNestedMessage<T>(6);
  }

  void set_num_softirq_total(uint64_t value) {
    AppendVarInt(7, value);
  }
  template <typename T = SysStats_InterruptCount> T* add_num_softirq() {
    return BeginNestedMessage<T>(8);
  }

  void set_collection_end_timestamp(uint64_t value) {
    AppendVarInt(9, value);
  }
};

class SysStats_InterruptCount_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SysStats_InterruptCount_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SysStats_InterruptCount_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SysStats_InterruptCount_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_irq() const { return at<1>().valid(); }
  int32_t irq() const { return at<1>().as_int32(); }
  bool has_count() const { return at<2>().valid(); }
  uint64_t count() const { return at<2>().as_uint64(); }
};

class SysStats_InterruptCount : public ::protozero::Message {
 public:
  using Decoder = SysStats_InterruptCount_Decoder;
  enum : int32_t {
    kIrqFieldNumber = 1,
    kCountFieldNumber = 2,
  };
  void set_irq(int32_t value) {
    AppendVarInt(1, value);
  }
  void set_count(uint64_t value) {
    AppendVarInt(2, value);
  }
};

class SysStats_CpuTimes_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/8, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SysStats_CpuTimes_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SysStats_CpuTimes_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SysStats_CpuTimes_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_cpu_id() const { return at<1>().valid(); }
  uint32_t cpu_id() const { return at<1>().as_uint32(); }
  bool has_user_ns() const { return at<2>().valid(); }
  uint64_t user_ns() const { return at<2>().as_uint64(); }
  bool has_user_ice_ns() const { return at<3>().valid(); }
  uint64_t user_ice_ns() const { return at<3>().as_uint64(); }
  bool has_system_mode_ns() const { return at<4>().valid(); }
  uint64_t system_mode_ns() const { return at<4>().as_uint64(); }
  bool has_idle_ns() const { return at<5>().valid(); }
  uint64_t idle_ns() const { return at<5>().as_uint64(); }
  bool has_io_wait_ns() const { return at<6>().valid(); }
  uint64_t io_wait_ns() const { return at<6>().as_uint64(); }
  bool has_irq_ns() const { return at<7>().valid(); }
  uint64_t irq_ns() const { return at<7>().as_uint64(); }
  bool has_softirq_ns() const { return at<8>().valid(); }
  uint64_t softirq_ns() const { return at<8>().as_uint64(); }
};

class SysStats_CpuTimes : public ::protozero::Message {
 public:
  using Decoder = SysStats_CpuTimes_Decoder;
  enum : int32_t {
    kCpuIdFieldNumber = 1,
    kUserNsFieldNumber = 2,
    kUserIceNsFieldNumber = 3,
    kSystemModeNsFieldNumber = 4,
    kIdleNsFieldNumber = 5,
    kIoWaitNsFieldNumber = 6,
    kIrqNsFieldNumber = 7,
    kSoftirqNsFieldNumber = 8,
  };
  void set_cpu_id(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_user_ns(uint64_t value) {
    AppendVarInt(2, value);
  }
  void set_user_ice_ns(uint64_t value) {
    AppendVarInt(3, value);
  }
  void set_system_mode_ns(uint64_t value) {
    AppendVarInt(4, value);
  }
  void set_idle_ns(uint64_t value) {
    AppendVarInt(5, value);
  }
  void set_io_wait_ns(uint64_t value) {
    AppendVarInt(6, value);
  }
  void set_irq_ns(uint64_t value) {
    AppendVarInt(7, value);
  }
  void set_softirq_ns(uint64_t value) {
    AppendVarInt(8, value);
  }
};

class SysStats_VmstatValue_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SysStats_VmstatValue_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SysStats_VmstatValue_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SysStats_VmstatValue_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_key() const { return at<1>().valid(); }
  int32_t key() const { return at<1>().as_int32(); }
  bool has_value() const { return at<2>().valid(); }
  uint64_t value() const { return at<2>().as_uint64(); }
};

class SysStats_VmstatValue : public ::protozero::Message {
 public:
  using Decoder = SysStats_VmstatValue_Decoder;
  enum : int32_t {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  void set_key(::perfetto::protos::pbzero::VmstatCounters value) {
    AppendTinyVarInt(1, value);
  }
  void set_value(uint64_t value) {
    AppendVarInt(2, value);
  }
};

class SysStats_MeminfoValue_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  SysStats_MeminfoValue_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit SysStats_MeminfoValue_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit SysStats_MeminfoValue_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_key() const { return at<1>().valid(); }
  int32_t key() const { return at<1>().as_int32(); }
  bool has_value() const { return at<2>().valid(); }
  uint64_t value() const { return at<2>().as_uint64(); }
};

class SysStats_MeminfoValue : public ::protozero::Message {
 public:
  using Decoder = SysStats_MeminfoValue_Decoder;
  enum : int32_t {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  void set_key(::perfetto::protos::pbzero::MeminfoCounters value) {
    AppendTinyVarInt(1, value);
  }
  void set_value(uint64_t value) {
    AppendVarInt(2, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/trace_packet_defaults.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACE_PACKET_DEFAULTS_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACE_PACKET_DEFAULTS_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class TrackEventDefaults;

class TracePacketDefaults_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/58, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TracePacketDefaults_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TracePacketDefaults_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TracePacketDefaults_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_timestamp_clock_id() const { return at<58>().valid(); }
  uint32_t timestamp_clock_id() const { return at<58>().as_uint32(); }
  bool has_track_event_defaults() const { return at<11>().valid(); }
  ::protozero::ConstBytes track_event_defaults() const { return at<11>().as_bytes(); }
};

class TracePacketDefaults : public ::protozero::Message {
 public:
  using Decoder = TracePacketDefaults_Decoder;
  enum : int32_t {
    kTimestampClockIdFieldNumber = 58,
    kTrackEventDefaultsFieldNumber = 11,
  };
  void set_timestamp_clock_id(uint32_t value) {
    AppendVarInt(58, value);
  }
  template <typename T = TrackEventDefaults> T* set_track_event_defaults() {
    return BeginNestedMessage<T>(11);
  }

};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/test_event.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TEST_EVENT_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TEST_EVENT_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class TestEvent_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/2, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TestEvent_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TestEvent_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TestEvent_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_str() const { return at<1>().valid(); }
  ::protozero::ConstChars str() const { return at<1>().as_string(); }
  bool has_seq_value() const { return at<2>().valid(); }
  uint32_t seq_value() const { return at<2>().as_uint32(); }
};

class TestEvent : public ::protozero::Message {
 public:
  using Decoder = TestEvent_Decoder;
  enum : int32_t {
    kStrFieldNumber = 1,
    kSeqValueFieldNumber = 2,
  };
  void set_str(const char* value) {
    AppendString(1, value);
  }
  // Doesn't check for null terminator.
  // Expects |value| to be at least |size| long.
  void set_str(const char* value, size_t size) {
    AppendBytes(1, value, size);
  }
  void set_seq_value(uint32_t value) {
    AppendVarInt(2, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/trace_packet.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACE_PACKET_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACE_PACKET_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class AndroidLogPacket;
class AppendedData;
class BatteryCounters;
class ChromeBenchmarkMetadata;
class ChromeEventBundle;
class ChromeMetadataPacket;
class ClockSnapshot;
class FtraceEventBundle;
class FtraceStats;
class GpuCounterEvent;
class GpuRenderStageEvent;
class GraphicsFrameEvent;
class HeapGraph;
class InodeFileMap;
class InternedData;
class PackagesList;
class PerfettoMetatrace;
class PowerRails;
class ProcessDescriptor;
class ProcessStats;
class ProcessTree;
class ProfilePacket;
class ProfiledFrameSymbols;
class StreamingProfilePacket;
class SysStats;
class SystemInfo;
class TestEvent;
class ThreadDescriptor;
class TraceConfig;
class TracePacketDefaults;
class TraceStats;
class TrackDescriptor;
class TrackEvent;
class Trigger;

enum TracePacket_SequenceFlags : int32_t {
  TracePacket_SequenceFlags_SEQ_UNSPECIFIED = 0,
  TracePacket_SequenceFlags_SEQ_INCREMENTAL_STATE_CLEARED = 1,
  TracePacket_SequenceFlags_SEQ_NEEDS_INCREMENTAL_STATE = 2,
};

const TracePacket_SequenceFlags TracePacket_SequenceFlags_MIN = TracePacket_SequenceFlags_SEQ_UNSPECIFIED;
const TracePacket_SequenceFlags TracePacket_SequenceFlags_MAX = TracePacket_SequenceFlags_SEQ_NEEDS_INCREMENTAL_STATE;

class TracePacket_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/900, /*HAS_NONPACKED_REPEATED_FIELDS=*/false> {
 public:
  TracePacket_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TracePacket_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TracePacket_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_timestamp() const { return at<8>().valid(); }
  uint64_t timestamp() const { return at<8>().as_uint64(); }
  bool has_timestamp_clock_id() const { return at<58>().valid(); }
  uint32_t timestamp_clock_id() const { return at<58>().as_uint32(); }
  bool has_ftrace_events() const { return at<1>().valid(); }
  ::protozero::ConstBytes ftrace_events() const { return at<1>().as_bytes(); }
  bool has_process_tree() const { return at<2>().valid(); }
  ::protozero::ConstBytes process_tree() const { return at<2>().as_bytes(); }
  bool has_process_stats() const { return at<9>().valid(); }
  ::protozero::ConstBytes process_stats() const { return at<9>().as_bytes(); }
  bool has_inode_file_map() const { return at<4>().valid(); }
  ::protozero::ConstBytes inode_file_map() const { return at<4>().as_bytes(); }
  bool has_chrome_events() const { return at<5>().valid(); }
  ::protozero::ConstBytes chrome_events() const { return at<5>().as_bytes(); }
  bool has_clock_snapshot() const { return at<6>().valid(); }
  ::protozero::ConstBytes clock_snapshot() const { return at<6>().as_bytes(); }
  bool has_sys_stats() const { return at<7>().valid(); }
  ::protozero::ConstBytes sys_stats() const { return at<7>().as_bytes(); }
  bool has_track_event() const { return at<11>().valid(); }
  ::protozero::ConstBytes track_event() const { return at<11>().as_bytes(); }
  bool has_trace_config() const { return at<33>().valid(); }
  ::protozero::ConstBytes trace_config() const { return at<33>().as_bytes(); }
  bool has_ftrace_stats() const { return at<34>().valid(); }
  ::protozero::ConstBytes ftrace_stats() const { return at<34>().as_bytes(); }
  bool has_trace_stats() const { return at<35>().valid(); }
  ::protozero::ConstBytes trace_stats() const { return at<35>().as_bytes(); }
  bool has_profile_packet() const { return at<37>().valid(); }
  ::protozero::ConstBytes profile_packet() const { return at<37>().as_bytes(); }
  bool has_battery() const { return at<38>().valid(); }
  ::protozero::ConstBytes battery() const { return at<38>().as_bytes(); }
  bool has_power_rails() const { return at<40>().valid(); }
  ::protozero::ConstBytes power_rails() const { return at<40>().as_bytes(); }
  bool has_android_log() const { return at<39>().valid(); }
  ::protozero::ConstBytes android_log() const { return at<39>().as_bytes(); }
  bool has_system_info() const { return at<45>().valid(); }
  ::protozero::ConstBytes system_info() const { return at<45>().as_bytes(); }
  bool has_trigger() const { return at<46>().valid(); }
  ::protozero::ConstBytes trigger() const { return at<46>().as_bytes(); }
  bool has_packages_list() const { return at<47>().valid(); }
  ::protozero::ConstBytes packages_list() const { return at<47>().as_bytes(); }
  bool has_chrome_benchmark_metadata() const { return at<48>().valid(); }
  ::protozero::ConstBytes chrome_benchmark_metadata() const { return at<48>().as_bytes(); }
  bool has_perfetto_metatrace() const { return at<49>().valid(); }
  ::protozero::ConstBytes perfetto_metatrace() const { return at<49>().as_bytes(); }
  bool has_chrome_metadata() const { return at<51>().valid(); }
  ::protozero::ConstBytes chrome_metadata() const { return at<51>().as_bytes(); }
  bool has_gpu_counter_event() const { return at<52>().valid(); }
  ::protozero::ConstBytes gpu_counter_event() const { return at<52>().as_bytes(); }
  bool has_gpu_render_stage_event() const { return at<53>().valid(); }
  ::protozero::ConstBytes gpu_render_stage_event() const { return at<53>().as_bytes(); }
  bool has_streaming_profile_packet() const { return at<54>().valid(); }
  ::protozero::ConstBytes streaming_profile_packet() const { return at<54>().as_bytes(); }
  bool has_heap_graph() const { return at<56>().valid(); }
  ::protozero::ConstBytes heap_graph() const { return at<56>().as_bytes(); }
  bool has_graphics_frame_event() const { return at<57>().valid(); }
  ::protozero::ConstBytes graphics_frame_event() const { return at<57>().as_bytes(); }
  bool has_profiled_frame_symbols() const { return at<55>().valid(); }
  ::protozero::ConstBytes profiled_frame_symbols() const { return at<55>().as_bytes(); }
  bool has_track_descriptor() const { return at<60>().valid(); }
  ::protozero::ConstBytes track_descriptor() const { return at<60>().as_bytes(); }
  bool has_process_descriptor() const { return at<43>().valid(); }
  ::protozero::ConstBytes process_descriptor() const { return at<43>().as_bytes(); }
  bool has_thread_descriptor() const { return at<44>().valid(); }
  ::protozero::ConstBytes thread_descriptor() const { return at<44>().as_bytes(); }
  bool has_synchronization_marker() const { return at<36>().valid(); }
  ::protozero::ConstBytes synchronization_marker() const { return at<36>().as_bytes(); }
  bool has_compressed_packets() const { return at<50>().valid(); }
  ::protozero::ConstBytes compressed_packets() const { return at<50>().as_bytes(); }
  bool has_for_testing() const { return at<900>().valid(); }
  ::protozero::ConstBytes for_testing() const { return at<900>().as_bytes(); }
  bool has_trusted_uid() const { return at<3>().valid(); }
  int32_t trusted_uid() const { return at<3>().as_int32(); }
  bool has_trusted_packet_sequence_id() const { return at<10>().valid(); }
  uint32_t trusted_packet_sequence_id() const { return at<10>().as_uint32(); }
  bool has_interned_data() const { return at<12>().valid(); }
  ::protozero::ConstBytes interned_data() const { return at<12>().as_bytes(); }
  bool has_appended_data() const { return at<61>().valid(); }
  ::protozero::ConstBytes appended_data() const { return at<61>().as_bytes(); }
  bool has_sequence_flags() const { return at<13>().valid(); }
  uint32_t sequence_flags() const { return at<13>().as_uint32(); }
  bool has_incremental_state_cleared() const { return at<41>().valid(); }
  bool incremental_state_cleared() const { return at<41>().as_bool(); }
  bool has_trace_packet_defaults() const { return at<59>().valid(); }
  ::protozero::ConstBytes trace_packet_defaults() const { return at<59>().as_bytes(); }
  bool has_previous_packet_dropped() const { return at<42>().valid(); }
  bool previous_packet_dropped() const { return at<42>().as_bool(); }
};

class TracePacket : public ::protozero::Message {
 public:
  using Decoder = TracePacket_Decoder;
  enum : int32_t {
    kTimestampFieldNumber = 8,
    kTimestampClockIdFieldNumber = 58,
    kFtraceEventsFieldNumber = 1,
    kProcessTreeFieldNumber = 2,
    kProcessStatsFieldNumber = 9,
    kInodeFileMapFieldNumber = 4,
    kChromeEventsFieldNumber = 5,
    kClockSnapshotFieldNumber = 6,
    kSysStatsFieldNumber = 7,
    kTrackEventFieldNumber = 11,
    kTraceConfigFieldNumber = 33,
    kFtraceStatsFieldNumber = 34,
    kTraceStatsFieldNumber = 35,
    kProfilePacketFieldNumber = 37,
    kBatteryFieldNumber = 38,
    kPowerRailsFieldNumber = 40,
    kAndroidLogFieldNumber = 39,
    kSystemInfoFieldNumber = 45,
    kTriggerFieldNumber = 46,
    kPackagesListFieldNumber = 47,
    kChromeBenchmarkMetadataFieldNumber = 48,
    kPerfettoMetatraceFieldNumber = 49,
    kChromeMetadataFieldNumber = 51,
    kGpuCounterEventFieldNumber = 52,
    kGpuRenderStageEventFieldNumber = 53,
    kStreamingProfilePacketFieldNumber = 54,
    kHeapGraphFieldNumber = 56,
    kGraphicsFrameEventFieldNumber = 57,
    kProfiledFrameSymbolsFieldNumber = 55,
    kTrackDescriptorFieldNumber = 60,
    kProcessDescriptorFieldNumber = 43,
    kThreadDescriptorFieldNumber = 44,
    kSynchronizationMarkerFieldNumber = 36,
    kCompressedPacketsFieldNumber = 50,
    kForTestingFieldNumber = 900,
    kTrustedUidFieldNumber = 3,
    kTrustedPacketSequenceIdFieldNumber = 10,
    kInternedDataFieldNumber = 12,
    kAppendedDataFieldNumber = 61,
    kSequenceFlagsFieldNumber = 13,
    kIncrementalStateClearedFieldNumber = 41,
    kTracePacketDefaultsFieldNumber = 59,
    kPreviousPacketDroppedFieldNumber = 42,
  };
  using SequenceFlags = ::perfetto::protos::pbzero::TracePacket_SequenceFlags;
  static const SequenceFlags SEQ_UNSPECIFIED = TracePacket_SequenceFlags_SEQ_UNSPECIFIED;
  static const SequenceFlags SEQ_INCREMENTAL_STATE_CLEARED = TracePacket_SequenceFlags_SEQ_INCREMENTAL_STATE_CLEARED;
  static const SequenceFlags SEQ_NEEDS_INCREMENTAL_STATE = TracePacket_SequenceFlags_SEQ_NEEDS_INCREMENTAL_STATE;
  void set_timestamp(uint64_t value) {
    AppendVarInt(8, value);
  }
  void set_timestamp_clock_id(uint32_t value) {
    AppendVarInt(58, value);
  }
  template <typename T = FtraceEventBundle> T* set_ftrace_events() {
    return BeginNestedMessage<T>(1);
  }

  template <typename T = ProcessTree> T* set_process_tree() {
    return BeginNestedMessage<T>(2);
  }

  template <typename T = ProcessStats> T* set_process_stats() {
    return BeginNestedMessage<T>(9);
  }

  template <typename T = InodeFileMap> T* set_inode_file_map() {
    return BeginNestedMessage<T>(4);
  }

  template <typename T = ChromeEventBundle> T* set_chrome_events() {
    return BeginNestedMessage<T>(5);
  }

  template <typename T = ClockSnapshot> T* set_clock_snapshot() {
    return BeginNestedMessage<T>(6);
  }

  template <typename T = SysStats> T* set_sys_stats() {
    return BeginNestedMessage<T>(7);
  }

  template <typename T = TrackEvent> T* set_track_event() {
    return BeginNestedMessage<T>(11);
  }

  template <typename T = TraceConfig> T* set_trace_config() {
    return BeginNestedMessage<T>(33);
  }

  template <typename T = FtraceStats> T* set_ftrace_stats() {
    return BeginNestedMessage<T>(34);
  }

  template <typename T = TraceStats> T* set_trace_stats() {
    return BeginNestedMessage<T>(35);
  }

  template <typename T = ProfilePacket> T* set_profile_packet() {
    return BeginNestedMessage<T>(37);
  }

  template <typename T = BatteryCounters> T* set_battery() {
    return BeginNestedMessage<T>(38);
  }

  template <typename T = PowerRails> T* set_power_rails() {
    return BeginNestedMessage<T>(40);
  }

  template <typename T = AndroidLogPacket> T* set_android_log() {
    return BeginNestedMessage<T>(39);
  }

  template <typename T = SystemInfo> T* set_system_info() {
    return BeginNestedMessage<T>(45);
  }

  template <typename T = Trigger> T* set_trigger() {
    return BeginNestedMessage<T>(46);
  }

  template <typename T = PackagesList> T* set_packages_list() {
    return BeginNestedMessage<T>(47);
  }

  template <typename T = ChromeBenchmarkMetadata> T* set_chrome_benchmark_metadata() {
    return BeginNestedMessage<T>(48);
  }

  template <typename T = PerfettoMetatrace> T* set_perfetto_metatrace() {
    return BeginNestedMessage<T>(49);
  }

  template <typename T = ChromeMetadataPacket> T* set_chrome_metadata() {
    return BeginNestedMessage<T>(51);
  }

  template <typename T = GpuCounterEvent> T* set_gpu_counter_event() {
    return BeginNestedMessage<T>(52);
  }

  template <typename T = GpuRenderStageEvent> T* set_gpu_render_stage_event() {
    return BeginNestedMessage<T>(53);
  }

  template <typename T = StreamingProfilePacket> T* set_streaming_profile_packet() {
    return BeginNestedMessage<T>(54);
  }

  template <typename T = HeapGraph> T* set_heap_graph() {
    return BeginNestedMessage<T>(56);
  }

  template <typename T = GraphicsFrameEvent> T* set_graphics_frame_event() {
    return BeginNestedMessage<T>(57);
  }

  template <typename T = ProfiledFrameSymbols> T* set_profiled_frame_symbols() {
    return BeginNestedMessage<T>(55);
  }

  template <typename T = TrackDescriptor> T* set_track_descriptor() {
    return BeginNestedMessage<T>(60);
  }

  template <typename T = ProcessDescriptor> T* set_process_descriptor() {
    return BeginNestedMessage<T>(43);
  }

  template <typename T = ThreadDescriptor> T* set_thread_descriptor() {
    return BeginNestedMessage<T>(44);
  }

  void set_synchronization_marker(const uint8_t* data, size_t size) {
    AppendBytes(36, data, size);
  }
  void set_compressed_packets(const uint8_t* data, size_t size) {
    AppendBytes(50, data, size);
  }
  template <typename T = TestEvent> T* set_for_testing() {
    return BeginNestedMessage<T>(900);
  }

  void set_trusted_uid(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_trusted_packet_sequence_id(uint32_t value) {
    AppendVarInt(10, value);
  }
  template <typename T = InternedData> T* set_interned_data() {
    return BeginNestedMessage<T>(12);
  }

  template <typename T = AppendedData> T* set_appended_data() {
    return BeginNestedMessage<T>(61);
  }

  void set_sequence_flags(uint32_t value) {
    AppendVarInt(13, value);
  }
  void set_incremental_state_cleared(bool value) {
    AppendTinyVarInt(41, value);
  }
  template <typename T = TracePacketDefaults> T* set_trace_packet_defaults() {
    return BeginNestedMessage<T>(59);
  }

  void set_previous_packet_dropped(bool value) {
    AppendTinyVarInt(42, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/trace.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACE_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_TRACE_TRACE_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/packed_repeated_fields.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class TracePacket;

class Trace_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/1, /*HAS_NONPACKED_REPEATED_FIELDS=*/true> {
 public:
  Trace_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit Trace_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit Trace_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_packet() const { return at<1>().valid(); }
  ::protozero::RepeatedFieldIterator packet() const { return GetRepeated(1); }
};

class Trace : public ::protozero::Message {
 public:
  using Decoder = Trace_Decoder;
  enum : int32_t {
    kPacketFieldNumber = 1,
  };
  template <typename T = TracePacket> T* add_packet() {
    return BeginNestedMessage<T>(1);
  }

};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/common/android_log_constants.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/common/android_log_constants.proto

#ifndef PROTOBUF_protos_2fperfetto_2fcommon_2fandroid_5flog_5fconstants_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2fcommon_2fandroid_5flog_5fconstants_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2fcommon_2fandroid_5flog_5fconstants_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2fandroid_5flog_5fconstants_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2fandroid_5flog_5fconstants_2eproto();


enum AndroidLogId {
  LID_DEFAULT = 0,
  LID_RADIO = 1,
  LID_EVENTS = 2,
  LID_SYSTEM = 3,
  LID_CRASH = 4,
  LID_STATS = 5,
  LID_SECURITY = 6,
  LID_KERNEL = 7
};
bool AndroidLogId_IsValid(int value);
const AndroidLogId AndroidLogId_MIN = LID_DEFAULT;
const AndroidLogId AndroidLogId_MAX = LID_KERNEL;
const int AndroidLogId_ARRAYSIZE = AndroidLogId_MAX + 1;

enum AndroidLogPriority {
  PRIO_UNSPECIFIED = 0,
  PRIO_UNUSED = 1,
  PRIO_VERBOSE = 2,
  PRIO_DEBUG = 3,
  PRIO_INFO = 4,
  PRIO_WARN = 5,
  PRIO_ERROR = 6,
  PRIO_FATAL = 7
};
bool AndroidLogPriority_IsValid(int value);
const AndroidLogPriority AndroidLogPriority_MIN = PRIO_UNSPECIFIED;
const AndroidLogPriority AndroidLogPriority_MAX = PRIO_FATAL;
const int AndroidLogPriority_ARRAYSIZE = AndroidLogPriority_MAX + 1;

// ===================================================================


// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::perfetto::protos::AndroidLogId> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::perfetto::protos::AndroidLogPriority> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2fcommon_2fandroid_5flog_5fconstants_2eproto__INCLUDED
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/common/commit_data_request.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/common/commit_data_request.proto

#ifndef PROTOBUF_protos_2fperfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();

class CommitDataRequest;
class CommitDataRequest_ChunkToPatch;
class CommitDataRequest_ChunkToPatch_Patch;
class CommitDataRequest_ChunksToMove;

// ===================================================================

class CommitDataRequest_ChunksToMove : public ::google::protobuf::MessageLite {
 public:
  CommitDataRequest_ChunksToMove();
  virtual ~CommitDataRequest_ChunksToMove();

  CommitDataRequest_ChunksToMove(const CommitDataRequest_ChunksToMove& from);

  inline CommitDataRequest_ChunksToMove& operator=(const CommitDataRequest_ChunksToMove& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const CommitDataRequest_ChunksToMove& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommitDataRequest_ChunksToMove* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommitDataRequest_ChunksToMove* other);

  // implements Message ----------------------------------------------

  inline CommitDataRequest_ChunksToMove* New() const { return New(NULL); }

  CommitDataRequest_ChunksToMove* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommitDataRequest_ChunksToMove& from);
  void MergeFrom(const CommitDataRequest_ChunksToMove& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommitDataRequest_ChunksToMove* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 page = 1;
  bool has_page() const;
  void clear_page();
  static const int kPageFieldNumber = 1;
  ::google::protobuf::uint32 page() const;
  void set_page(::google::protobuf::uint32 value);

  // optional uint32 chunk = 2;
  bool has_chunk() const;
  void clear_chunk();
  static const int kChunkFieldNumber = 2;
  ::google::protobuf::uint32 chunk() const;
  void set_chunk(::google::protobuf::uint32 value);

  // optional uint32 target_buffer = 3;
  bool has_target_buffer() const;
  void clear_target_buffer();
  static const int kTargetBufferFieldNumber = 3;
  ::google::protobuf::uint32 target_buffer() const;
  void set_target_buffer(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.CommitDataRequest.ChunksToMove)
 private:
  inline void set_has_page();
  inline void clear_has_page();
  inline void set_has_chunk();
  inline void clear_has_chunk();
  inline void set_has_target_buffer();
  inline void clear_has_target_buffer();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 page_;
  ::google::protobuf::uint32 chunk_;
  ::google::protobuf::uint32 target_buffer_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();

  void InitAsDefaultInstance();
  static CommitDataRequest_ChunksToMove* default_instance_;
};
// -------------------------------------------------------------------

class CommitDataRequest_ChunkToPatch_Patch : public ::google::protobuf::MessageLite {
 public:
  CommitDataRequest_ChunkToPatch_Patch();
  virtual ~CommitDataRequest_ChunkToPatch_Patch();

  CommitDataRequest_ChunkToPatch_Patch(const CommitDataRequest_ChunkToPatch_Patch& from);

  inline CommitDataRequest_ChunkToPatch_Patch& operator=(const CommitDataRequest_ChunkToPatch_Patch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const CommitDataRequest_ChunkToPatch_Patch& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommitDataRequest_ChunkToPatch_Patch* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommitDataRequest_ChunkToPatch_Patch* other);

  // implements Message ----------------------------------------------

  inline CommitDataRequest_ChunkToPatch_Patch* New() const { return New(NULL); }

  CommitDataRequest_ChunkToPatch_Patch* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommitDataRequest_ChunkToPatch_Patch& from);
  void MergeFrom(const CommitDataRequest_ChunkToPatch_Patch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommitDataRequest_ChunkToPatch_Patch* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 offset = 1;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 1;
  ::google::protobuf::uint32 offset() const;
  void set_offset(::google::protobuf::uint32 value);

  // optional bytes data = 2;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:perfetto.protos.CommitDataRequest.ChunkToPatch.Patch)
 private:
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::uint32 offset_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();

  void InitAsDefaultInstance();
  static CommitDataRequest_ChunkToPatch_Patch* default_instance_;
};
// -------------------------------------------------------------------

class CommitDataRequest_ChunkToPatch : public ::google::protobuf::MessageLite {
 public:
  CommitDataRequest_ChunkToPatch();
  virtual ~CommitDataRequest_ChunkToPatch();

  CommitDataRequest_ChunkToPatch(const CommitDataRequest_ChunkToPatch& from);

  inline CommitDataRequest_ChunkToPatch& operator=(const CommitDataRequest_ChunkToPatch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const CommitDataRequest_ChunkToPatch& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommitDataRequest_ChunkToPatch* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommitDataRequest_ChunkToPatch* other);

  // implements Message ----------------------------------------------

  inline CommitDataRequest_ChunkToPatch* New() const { return New(NULL); }

  CommitDataRequest_ChunkToPatch* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommitDataRequest_ChunkToPatch& from);
  void MergeFrom(const CommitDataRequest_ChunkToPatch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommitDataRequest_ChunkToPatch* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CommitDataRequest_ChunkToPatch_Patch Patch;

  // accessors -------------------------------------------------------

  // optional uint32 target_buffer = 1;
  bool has_target_buffer() const;
  void clear_target_buffer();
  static const int kTargetBufferFieldNumber = 1;
  ::google::protobuf::uint32 target_buffer() const;
  void set_target_buffer(::google::protobuf::uint32 value);

  // optional uint32 writer_id = 2;
  bool has_writer_id() const;
  void clear_writer_id();
  static const int kWriterIdFieldNumber = 2;
  ::google::protobuf::uint32 writer_id() const;
  void set_writer_id(::google::protobuf::uint32 value);

  // optional uint32 chunk_id = 3;
  bool has_chunk_id() const;
  void clear_chunk_id();
  static const int kChunkIdFieldNumber = 3;
  ::google::protobuf::uint32 chunk_id() const;
  void set_chunk_id(::google::protobuf::uint32 value);

  // repeated .perfetto.protos.CommitDataRequest.ChunkToPatch.Patch patches = 4;
  int patches_size() const;
  void clear_patches();
  static const int kPatchesFieldNumber = 4;
  const ::perfetto::protos::CommitDataRequest_ChunkToPatch_Patch& patches(int index) const;
  ::perfetto::protos::CommitDataRequest_ChunkToPatch_Patch* mutable_patches(int index);
  ::perfetto::protos::CommitDataRequest_ChunkToPatch_Patch* add_patches();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::CommitDataRequest_ChunkToPatch_Patch >*
      mutable_patches();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::CommitDataRequest_ChunkToPatch_Patch >&
      patches() const;

  // optional bool has_more_patches = 5;
  bool has_has_more_patches() const;
  void clear_has_more_patches();
  static const int kHasMorePatchesFieldNumber = 5;
  bool has_more_patches() const;
  void set_has_more_patches(bool value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.CommitDataRequest.ChunkToPatch)
 private:
  inline void set_has_target_buffer();
  inline void clear_has_target_buffer();
  inline void set_has_writer_id();
  inline void clear_has_writer_id();
  inline void set_has_chunk_id();
  inline void clear_has_chunk_id();
  inline void set_has_has_more_patches();
  inline void clear_has_has_more_patches();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 target_buffer_;
  ::google::protobuf::uint32 writer_id_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::CommitDataRequest_ChunkToPatch_Patch > patches_;
  ::google::protobuf::uint32 chunk_id_;
  bool has_more_patches_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();

  void InitAsDefaultInstance();
  static CommitDataRequest_ChunkToPatch* default_instance_;
};
// -------------------------------------------------------------------

class CommitDataRequest : public ::google::protobuf::MessageLite {
 public:
  CommitDataRequest();
  virtual ~CommitDataRequest();

  CommitDataRequest(const CommitDataRequest& from);

  inline CommitDataRequest& operator=(const CommitDataRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const CommitDataRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommitDataRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommitDataRequest* other);

  // implements Message ----------------------------------------------

  inline CommitDataRequest* New() const { return New(NULL); }

  CommitDataRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommitDataRequest& from);
  void MergeFrom(const CommitDataRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommitDataRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CommitDataRequest_ChunksToMove ChunksToMove;
  typedef CommitDataRequest_ChunkToPatch ChunkToPatch;

  // accessors -------------------------------------------------------

  // repeated .perfetto.protos.CommitDataRequest.ChunksToMove chunks_to_move = 1;
  int chunks_to_move_size() const;
  void clear_chunks_to_move();
  static const int kChunksToMoveFieldNumber = 1;
  const ::perfetto::protos::CommitDataRequest_ChunksToMove& chunks_to_move(int index) const;
  ::perfetto::protos::CommitDataRequest_ChunksToMove* mutable_chunks_to_move(int index);
  ::perfetto::protos::CommitDataRequest_ChunksToMove* add_chunks_to_move();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::CommitDataRequest_ChunksToMove >*
      mutable_chunks_to_move();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::CommitDataRequest_ChunksToMove >&
      chunks_to_move() const;

  // repeated .perfetto.protos.CommitDataRequest.ChunkToPatch chunks_to_patch = 2;
  int chunks_to_patch_size() const;
  void clear_chunks_to_patch();
  static const int kChunksToPatchFieldNumber = 2;
  const ::perfetto::protos::CommitDataRequest_ChunkToPatch& chunks_to_patch(int index) const;
  ::perfetto::protos::CommitDataRequest_ChunkToPatch* mutable_chunks_to_patch(int index);
  ::perfetto::protos::CommitDataRequest_ChunkToPatch* add_chunks_to_patch();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::CommitDataRequest_ChunkToPatch >*
      mutable_chunks_to_patch();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::CommitDataRequest_ChunkToPatch >&
      chunks_to_patch() const;

  // optional uint64 flush_request_id = 3;
  bool has_flush_request_id() const;
  void clear_flush_request_id();
  static const int kFlushRequestIdFieldNumber = 3;
  ::google::protobuf::uint64 flush_request_id() const;
  void set_flush_request_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.CommitDataRequest)
 private:
  inline void set_has_flush_request_id();
  inline void clear_has_flush_request_id();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::CommitDataRequest_ChunksToMove > chunks_to_move_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::CommitDataRequest_ChunkToPatch > chunks_to_patch_;
  ::google::protobuf::uint64 flush_request_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();

  void InitAsDefaultInstance();
  static CommitDataRequest* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// CommitDataRequest_ChunksToMove

// optional uint32 page = 1;
inline bool CommitDataRequest_ChunksToMove::has_page() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommitDataRequest_ChunksToMove::set_has_page() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommitDataRequest_ChunksToMove::clear_has_page() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommitDataRequest_ChunksToMove::clear_page() {
  page_ = 0u;
  clear_has_page();
}
inline ::google::protobuf::uint32 CommitDataRequest_ChunksToMove::page() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.CommitDataRequest.ChunksToMove.page)
  return page_;
}
inline void CommitDataRequest_ChunksToMove::set_page(::google::protobuf::uint32 value) {
  set_has_page();
  page_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.CommitDataRequest.ChunksToMove.page)
}

// optional uint32 chunk = 2;
inline bool CommitDataRequest_ChunksToMove::has_chunk() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommitDataRequest_ChunksToMove::set_has_chunk() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommitDataRequest_ChunksToMove::clear_has_chunk() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommitDataRequest_ChunksToMove::clear_chunk() {
  chunk_ = 0u;
  clear_has_chunk();
}
inline ::google::protobuf::uint32 CommitDataRequest_ChunksToMove::chunk() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.CommitDataRequest.ChunksToMove.chunk)
  return chunk_;
}
inline void CommitDataRequest_ChunksToMove::set_chunk(::google::protobuf::uint32 value) {
  set_has_chunk();
  chunk_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.CommitDataRequest.ChunksToMove.chunk)
}

// optional uint32 target_buffer = 3;
inline bool CommitDataRequest_ChunksToMove::has_target_buffer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommitDataRequest_ChunksToMove::set_has_target_buffer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommitDataRequest_ChunksToMove::clear_has_target_buffer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommitDataRequest_ChunksToMove::clear_target_buffer() {
  target_buffer_ = 0u;
  clear_has_target_buffer();
}
inline ::google::protobuf::uint32 CommitDataRequest_ChunksToMove::target_buffer() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.CommitDataRequest.ChunksToMove.target_buffer)
  return target_buffer_;
}
inline void CommitDataRequest_ChunksToMove::set_target_buffer(::google::protobuf::uint32 value) {
  set_has_target_buffer();
  target_buffer_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.CommitDataRequest.ChunksToMove.target_buffer)
}

// -------------------------------------------------------------------

// CommitDataRequest_ChunkToPatch_Patch

// optional uint32 offset = 1;
inline bool CommitDataRequest_ChunkToPatch_Patch::has_offset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommitDataRequest_ChunkToPatch_Patch::set_has_offset() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommitDataRequest_ChunkToPatch_Patch::clear_has_offset() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommitDataRequest_ChunkToPatch_Patch::clear_offset() {
  offset_ = 0u;
  clear_has_offset();
}
inline ::google::protobuf::uint32 CommitDataRequest_ChunkToPatch_Patch::offset() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.CommitDataRequest.ChunkToPatch.Patch.offset)
  return offset_;
}
inline void CommitDataRequest_ChunkToPatch_Patch::set_offset(::google::protobuf::uint32 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.CommitDataRequest.ChunkToPatch.Patch.offset)
}

// optional bytes data = 2;
inline bool CommitDataRequest_ChunkToPatch_Patch::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommitDataRequest_ChunkToPatch_Patch::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommitDataRequest_ChunkToPatch_Patch::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommitDataRequest_ChunkToPatch_Patch::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
inline const ::std::string& CommitDataRequest_ChunkToPatch_Patch::data() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.CommitDataRequest.ChunkToPatch.Patch.data)
  return data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CommitDataRequest_ChunkToPatch_Patch::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.CommitDataRequest.ChunkToPatch.Patch.data)
}
inline void CommitDataRequest_ChunkToPatch_Patch::set_data(const char* value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.CommitDataRequest.ChunkToPatch.Patch.data)
}
inline void CommitDataRequest_ChunkToPatch_Patch::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.CommitDataRequest.ChunkToPatch.Patch.data)
}
inline ::std::string* CommitDataRequest_ChunkToPatch_Patch::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.CommitDataRequest.ChunkToPatch.Patch.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CommitDataRequest_ChunkToPatch_Patch::release_data() {
  // @@protoc_insertion_point(field_release:perfetto.protos.CommitDataRequest.ChunkToPatch.Patch.data)
  clear_has_data();
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CommitDataRequest_ChunkToPatch_Patch::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.CommitDataRequest.ChunkToPatch.Patch.data)
}

// -------------------------------------------------------------------

// CommitDataRequest_ChunkToPatch

// optional uint32 target_buffer = 1;
inline bool CommitDataRequest_ChunkToPatch::has_target_buffer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommitDataRequest_ChunkToPatch::set_has_target_buffer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommitDataRequest_ChunkToPatch::clear_has_target_buffer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommitDataRequest_ChunkToPatch::clear_target_buffer() {
  target_buffer_ = 0u;
  clear_has_target_buffer();
}
inline ::google::protobuf::uint32 CommitDataRequest_ChunkToPatch::target_buffer() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.CommitDataRequest.ChunkToPatch.target_buffer)
  return target_buffer_;
}
inline void CommitDataRequest_ChunkToPatch::set_target_buffer(::google::protobuf::uint32 value) {
  set_has_target_buffer();
  target_buffer_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.CommitDataRequest.ChunkToPatch.target_buffer)
}

// optional uint32 writer_id = 2;
inline bool CommitDataRequest_ChunkToPatch::has_writer_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommitDataRequest_ChunkToPatch::set_has_writer_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommitDataRequest_ChunkToPatch::clear_has_writer_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommitDataRequest_ChunkToPatch::clear_writer_id() {
  writer_id_ = 0u;
  clear_has_writer_id();
}
inline ::google::protobuf::uint32 CommitDataRequest_ChunkToPatch::writer_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.CommitDataRequest.ChunkToPatch.writer_id)
  return writer_id_;
}
inline void CommitDataRequest_ChunkToPatch::set_writer_id(::google::protobuf::uint32 value) {
  set_has_writer_id();
  writer_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.CommitDataRequest.ChunkToPatch.writer_id)
}

// optional uint32 chunk_id = 3;
inline bool CommitDataRequest_ChunkToPatch::has_chunk_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommitDataRequest_ChunkToPatch::set_has_chunk_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommitDataRequest_ChunkToPatch::clear_has_chunk_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommitDataRequest_ChunkToPatch::clear_chunk_id() {
  chunk_id_ = 0u;
  clear_has_chunk_id();
}
inline ::google::protobuf::uint32 CommitDataRequest_ChunkToPatch::chunk_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.CommitDataRequest.ChunkToPatch.chunk_id)
  return chunk_id_;
}
inline void CommitDataRequest_ChunkToPatch::set_chunk_id(::google::protobuf::uint32 value) {
  set_has_chunk_id();
  chunk_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.CommitDataRequest.ChunkToPatch.chunk_id)
}

// repeated .perfetto.protos.CommitDataRequest.ChunkToPatch.Patch patches = 4;
inline int CommitDataRequest_ChunkToPatch::patches_size() const {
  return patches_.size();
}
inline void CommitDataRequest_ChunkToPatch::clear_patches() {
  patches_.Clear();
}
inline const ::perfetto::protos::CommitDataRequest_ChunkToPatch_Patch& CommitDataRequest_ChunkToPatch::patches(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.CommitDataRequest.ChunkToPatch.patches)
  return patches_.Get(index);
}
inline ::perfetto::protos::CommitDataRequest_ChunkToPatch_Patch* CommitDataRequest_ChunkToPatch::mutable_patches(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.CommitDataRequest.ChunkToPatch.patches)
  return patches_.Mutable(index);
}
inline ::perfetto::protos::CommitDataRequest_ChunkToPatch_Patch* CommitDataRequest_ChunkToPatch::add_patches() {
  // @@protoc_insertion_point(field_add:perfetto.protos.CommitDataRequest.ChunkToPatch.patches)
  return patches_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::CommitDataRequest_ChunkToPatch_Patch >*
CommitDataRequest_ChunkToPatch::mutable_patches() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.CommitDataRequest.ChunkToPatch.patches)
  return &patches_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::CommitDataRequest_ChunkToPatch_Patch >&
CommitDataRequest_ChunkToPatch::patches() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.CommitDataRequest.ChunkToPatch.patches)
  return patches_;
}

// optional bool has_more_patches = 5;
inline bool CommitDataRequest_ChunkToPatch::has_has_more_patches() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommitDataRequest_ChunkToPatch::set_has_has_more_patches() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommitDataRequest_ChunkToPatch::clear_has_has_more_patches() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommitDataRequest_ChunkToPatch::clear_has_more_patches() {
  has_more_patches_ = false;
  clear_has_has_more_patches();
}
inline bool CommitDataRequest_ChunkToPatch::has_more_patches() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.CommitDataRequest.ChunkToPatch.has_more_patches)
  return has_more_patches_;
}
inline void CommitDataRequest_ChunkToPatch::set_has_more_patches(bool value) {
  set_has_has_more_patches();
  has_more_patches_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.CommitDataRequest.ChunkToPatch.has_more_patches)
}

// -------------------------------------------------------------------

// CommitDataRequest

// repeated .perfetto.protos.CommitDataRequest.ChunksToMove chunks_to_move = 1;
inline int CommitDataRequest::chunks_to_move_size() const {
  return chunks_to_move_.size();
}
inline void CommitDataRequest::clear_chunks_to_move() {
  chunks_to_move_.Clear();
}
inline const ::perfetto::protos::CommitDataRequest_ChunksToMove& CommitDataRequest::chunks_to_move(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.CommitDataRequest.chunks_to_move)
  return chunks_to_move_.Get(index);
}
inline ::perfetto::protos::CommitDataRequest_ChunksToMove* CommitDataRequest::mutable_chunks_to_move(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.CommitDataRequest.chunks_to_move)
  return chunks_to_move_.Mutable(index);
}
inline ::perfetto::protos::CommitDataRequest_ChunksToMove* CommitDataRequest::add_chunks_to_move() {
  // @@protoc_insertion_point(field_add:perfetto.protos.CommitDataRequest.chunks_to_move)
  return chunks_to_move_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::CommitDataRequest_ChunksToMove >*
CommitDataRequest::mutable_chunks_to_move() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.CommitDataRequest.chunks_to_move)
  return &chunks_to_move_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::CommitDataRequest_ChunksToMove >&
CommitDataRequest::chunks_to_move() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.CommitDataRequest.chunks_to_move)
  return chunks_to_move_;
}

// repeated .perfetto.protos.CommitDataRequest.ChunkToPatch chunks_to_patch = 2;
inline int CommitDataRequest::chunks_to_patch_size() const {
  return chunks_to_patch_.size();
}
inline void CommitDataRequest::clear_chunks_to_patch() {
  chunks_to_patch_.Clear();
}
inline const ::perfetto::protos::CommitDataRequest_ChunkToPatch& CommitDataRequest::chunks_to_patch(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.CommitDataRequest.chunks_to_patch)
  return chunks_to_patch_.Get(index);
}
inline ::perfetto::protos::CommitDataRequest_ChunkToPatch* CommitDataRequest::mutable_chunks_to_patch(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.CommitDataRequest.chunks_to_patch)
  return chunks_to_patch_.Mutable(index);
}
inline ::perfetto::protos::CommitDataRequest_ChunkToPatch* CommitDataRequest::add_chunks_to_patch() {
  // @@protoc_insertion_point(field_add:perfetto.protos.CommitDataRequest.chunks_to_patch)
  return chunks_to_patch_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::CommitDataRequest_ChunkToPatch >*
CommitDataRequest::mutable_chunks_to_patch() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.CommitDataRequest.chunks_to_patch)
  return &chunks_to_patch_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::CommitDataRequest_ChunkToPatch >&
CommitDataRequest::chunks_to_patch() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.CommitDataRequest.chunks_to_patch)
  return chunks_to_patch_;
}

// optional uint64 flush_request_id = 3;
inline bool CommitDataRequest::has_flush_request_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommitDataRequest::set_has_flush_request_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommitDataRequest::clear_has_flush_request_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommitDataRequest::clear_flush_request_id() {
  flush_request_id_ = GOOGLE_ULONGLONG(0);
  clear_has_flush_request_id();
}
inline ::google::protobuf::uint64 CommitDataRequest::flush_request_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.CommitDataRequest.flush_request_id)
  return flush_request_id_;
}
inline void CommitDataRequest::set_flush_request_id(::google::protobuf::uint64 value) {
  set_has_flush_request_id();
  flush_request_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.CommitDataRequest.flush_request_id)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto__INCLUDED
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/common/data_source_descriptor.pb.h
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/common/gpu_counter_descriptor.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/common/gpu_counter_descriptor.proto

#ifndef PROTOBUF_protos_2fperfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto();

class GpuCounterDescriptor;
class GpuCounterDescriptor_GpuCounterBlock;
class GpuCounterDescriptor_GpuCounterSpec;

enum GpuCounterDescriptor_MeasureUnit {
  GpuCounterDescriptor_MeasureUnit_NONE = 0,
  GpuCounterDescriptor_MeasureUnit_BIT = 1,
  GpuCounterDescriptor_MeasureUnit_KILOBIT = 2,
  GpuCounterDescriptor_MeasureUnit_MEGABIT = 3,
  GpuCounterDescriptor_MeasureUnit_GIGABIT = 4,
  GpuCounterDescriptor_MeasureUnit_TERABIT = 5,
  GpuCounterDescriptor_MeasureUnit_PETABIT = 6,
  GpuCounterDescriptor_MeasureUnit_BYTE = 7,
  GpuCounterDescriptor_MeasureUnit_KILOBYTE = 8,
  GpuCounterDescriptor_MeasureUnit_MEGABYTE = 9,
  GpuCounterDescriptor_MeasureUnit_GIGABYTE = 10,
  GpuCounterDescriptor_MeasureUnit_TERABYTE = 11,
  GpuCounterDescriptor_MeasureUnit_PETABYTE = 12,
  GpuCounterDescriptor_MeasureUnit_HERTZ = 13,
  GpuCounterDescriptor_MeasureUnit_KILOHERTZ = 14,
  GpuCounterDescriptor_MeasureUnit_MEGAHERTZ = 15,
  GpuCounterDescriptor_MeasureUnit_GIGAHERTZ = 16,
  GpuCounterDescriptor_MeasureUnit_TERAHERTZ = 17,
  GpuCounterDescriptor_MeasureUnit_PETAHERTZ = 18,
  GpuCounterDescriptor_MeasureUnit_NANOSECOND = 19,
  GpuCounterDescriptor_MeasureUnit_MICROSECOND = 20,
  GpuCounterDescriptor_MeasureUnit_MILLISECOND = 21,
  GpuCounterDescriptor_MeasureUnit_SECOND = 22,
  GpuCounterDescriptor_MeasureUnit_MINUTE = 23,
  GpuCounterDescriptor_MeasureUnit_HOUR = 24,
  GpuCounterDescriptor_MeasureUnit_VERTEX = 25,
  GpuCounterDescriptor_MeasureUnit_PIXEL = 26,
  GpuCounterDescriptor_MeasureUnit_TRIANGLE = 27,
  GpuCounterDescriptor_MeasureUnit_MILLIWATT = 28,
  GpuCounterDescriptor_MeasureUnit_WATT = 29,
  GpuCounterDescriptor_MeasureUnit_KILOWATT = 30,
  GpuCounterDescriptor_MeasureUnit_JOULE = 31,
  GpuCounterDescriptor_MeasureUnit_VOLT = 32,
  GpuCounterDescriptor_MeasureUnit_AMPERE = 33,
  GpuCounterDescriptor_MeasureUnit_CELSIUS = 34,
  GpuCounterDescriptor_MeasureUnit_FAHRENHEIT = 35,
  GpuCounterDescriptor_MeasureUnit_KELVIN = 36,
  GpuCounterDescriptor_MeasureUnit_PERCENT = 37
};
bool GpuCounterDescriptor_MeasureUnit_IsValid(int value);
const GpuCounterDescriptor_MeasureUnit GpuCounterDescriptor_MeasureUnit_MeasureUnit_MIN = GpuCounterDescriptor_MeasureUnit_NONE;
const GpuCounterDescriptor_MeasureUnit GpuCounterDescriptor_MeasureUnit_MeasureUnit_MAX = GpuCounterDescriptor_MeasureUnit_PERCENT;
const int GpuCounterDescriptor_MeasureUnit_MeasureUnit_ARRAYSIZE = GpuCounterDescriptor_MeasureUnit_MeasureUnit_MAX + 1;

// ===================================================================

class GpuCounterDescriptor_GpuCounterSpec : public ::google::protobuf::MessageLite {
 public:
  GpuCounterDescriptor_GpuCounterSpec();
  virtual ~GpuCounterDescriptor_GpuCounterSpec();

  GpuCounterDescriptor_GpuCounterSpec(const GpuCounterDescriptor_GpuCounterSpec& from);

  inline GpuCounterDescriptor_GpuCounterSpec& operator=(const GpuCounterDescriptor_GpuCounterSpec& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const GpuCounterDescriptor_GpuCounterSpec& default_instance();

  enum PeakValueCase {
    kIntPeakValue = 5,
    kDoublePeakValue = 6,
    PEAK_VALUE_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GpuCounterDescriptor_GpuCounterSpec* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GpuCounterDescriptor_GpuCounterSpec* other);

  // implements Message ----------------------------------------------

  inline GpuCounterDescriptor_GpuCounterSpec* New() const { return New(NULL); }

  GpuCounterDescriptor_GpuCounterSpec* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GpuCounterDescriptor_GpuCounterSpec& from);
  void MergeFrom(const GpuCounterDescriptor_GpuCounterSpec& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GpuCounterDescriptor_GpuCounterSpec* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 counter_id = 1;
  bool has_counter_id() const;
  void clear_counter_id();
  static const int kCounterIdFieldNumber = 1;
  ::google::protobuf::uint32 counter_id() const;
  void set_counter_id(::google::protobuf::uint32 value);

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string description = 3;
  bool has_description() const;
  void clear_description();
  static const int kDescriptionFieldNumber = 3;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // optional int64 int_peak_value = 5;
  bool has_int_peak_value() const;
  void clear_int_peak_value();
  static const int kIntPeakValueFieldNumber = 5;
  ::google::protobuf::int64 int_peak_value() const;
  void set_int_peak_value(::google::protobuf::int64 value);

  // optional double double_peak_value = 6;
  bool has_double_peak_value() const;
  void clear_double_peak_value();
  static const int kDoublePeakValueFieldNumber = 6;
  double double_peak_value() const;
  void set_double_peak_value(double value);

  // repeated .perfetto.protos.GpuCounterDescriptor.MeasureUnit numerator_units = 7;
  int numerator_units_size() const;
  void clear_numerator_units();
  static const int kNumeratorUnitsFieldNumber = 7;
  ::perfetto::protos::GpuCounterDescriptor_MeasureUnit numerator_units(int index) const;
  void set_numerator_units(int index, ::perfetto::protos::GpuCounterDescriptor_MeasureUnit value);
  void add_numerator_units(::perfetto::protos::GpuCounterDescriptor_MeasureUnit value);
  const ::google::protobuf::RepeatedField<int>& numerator_units() const;
  ::google::protobuf::RepeatedField<int>* mutable_numerator_units();

  // repeated .perfetto.protos.GpuCounterDescriptor.MeasureUnit denominator_units = 8;
  int denominator_units_size() const;
  void clear_denominator_units();
  static const int kDenominatorUnitsFieldNumber = 8;
  ::perfetto::protos::GpuCounterDescriptor_MeasureUnit denominator_units(int index) const;
  void set_denominator_units(int index, ::perfetto::protos::GpuCounterDescriptor_MeasureUnit value);
  void add_denominator_units(::perfetto::protos::GpuCounterDescriptor_MeasureUnit value);
  const ::google::protobuf::RepeatedField<int>& denominator_units() const;
  ::google::protobuf::RepeatedField<int>* mutable_denominator_units();

  // optional bool select_by_default = 9;
  bool has_select_by_default() const;
  void clear_select_by_default();
  static const int kSelectByDefaultFieldNumber = 9;
  bool select_by_default() const;
  void set_select_by_default(bool value);

  PeakValueCase peak_value_case() const;
  // @@protoc_insertion_point(class_scope:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec)
 private:
  inline void set_has_counter_id();
  inline void clear_has_counter_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_int_peak_value();
  inline void set_has_double_peak_value();
  inline void set_has_select_by_default();
  inline void clear_has_select_by_default();

  inline bool has_peak_value() const;
  void clear_peak_value();
  inline void clear_has_peak_value();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::uint32 counter_id_;
  bool select_by_default_;
  ::google::protobuf::RepeatedField<int> numerator_units_;
  ::google::protobuf::RepeatedField<int> denominator_units_;
  union PeakValueUnion {
    PeakValueUnion() {}
    ::google::protobuf::int64 int_peak_value_;
    double double_peak_value_;
  } peak_value_;
  ::google::protobuf::uint32 _oneof_case_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto();

  void InitAsDefaultInstance();
  static GpuCounterDescriptor_GpuCounterSpec* default_instance_;
};
// -------------------------------------------------------------------

class GpuCounterDescriptor_GpuCounterBlock : public ::google::protobuf::MessageLite {
 public:
  GpuCounterDescriptor_GpuCounterBlock();
  virtual ~GpuCounterDescriptor_GpuCounterBlock();

  GpuCounterDescriptor_GpuCounterBlock(const GpuCounterDescriptor_GpuCounterBlock& from);

  inline GpuCounterDescriptor_GpuCounterBlock& operator=(const GpuCounterDescriptor_GpuCounterBlock& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const GpuCounterDescriptor_GpuCounterBlock& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GpuCounterDescriptor_GpuCounterBlock* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GpuCounterDescriptor_GpuCounterBlock* other);

  // implements Message ----------------------------------------------

  inline GpuCounterDescriptor_GpuCounterBlock* New() const { return New(NULL); }

  GpuCounterDescriptor_GpuCounterBlock* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GpuCounterDescriptor_GpuCounterBlock& from);
  void MergeFrom(const GpuCounterDescriptor_GpuCounterBlock& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GpuCounterDescriptor_GpuCounterBlock* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 block_id = 1;
  bool has_block_id() const;
  void clear_block_id();
  static const int kBlockIdFieldNumber = 1;
  ::google::protobuf::uint32 block_id() const;
  void set_block_id(::google::protobuf::uint32 value);

  // optional uint32 block_capacity = 2;
  bool has_block_capacity() const;
  void clear_block_capacity();
  static const int kBlockCapacityFieldNumber = 2;
  ::google::protobuf::uint32 block_capacity() const;
  void set_block_capacity(::google::protobuf::uint32 value);

  // optional string name = 3;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string description = 4;
  bool has_description() const;
  void clear_description();
  static const int kDescriptionFieldNumber = 4;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // repeated uint32 counter_ids = 5;
  int counter_ids_size() const;
  void clear_counter_ids();
  static const int kCounterIdsFieldNumber = 5;
  ::google::protobuf::uint32 counter_ids(int index) const;
  void set_counter_ids(int index, ::google::protobuf::uint32 value);
  void add_counter_ids(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      counter_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_counter_ids();

  // @@protoc_insertion_point(class_scope:perfetto.protos.GpuCounterDescriptor.GpuCounterBlock)
 private:
  inline void set_has_block_id();
  inline void clear_has_block_id();
  inline void set_has_block_capacity();
  inline void clear_has_block_capacity();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_description();
  inline void clear_has_description();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 block_id_;
  ::google::protobuf::uint32 block_capacity_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > counter_ids_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto();

  void InitAsDefaultInstance();
  static GpuCounterDescriptor_GpuCounterBlock* default_instance_;
};
// -------------------------------------------------------------------

class GpuCounterDescriptor : public ::google::protobuf::MessageLite {
 public:
  GpuCounterDescriptor();
  virtual ~GpuCounterDescriptor();

  GpuCounterDescriptor(const GpuCounterDescriptor& from);

  inline GpuCounterDescriptor& operator=(const GpuCounterDescriptor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const GpuCounterDescriptor& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GpuCounterDescriptor* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GpuCounterDescriptor* other);

  // implements Message ----------------------------------------------

  inline GpuCounterDescriptor* New() const { return New(NULL); }

  GpuCounterDescriptor* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GpuCounterDescriptor& from);
  void MergeFrom(const GpuCounterDescriptor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GpuCounterDescriptor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef GpuCounterDescriptor_GpuCounterSpec GpuCounterSpec;
  typedef GpuCounterDescriptor_GpuCounterBlock GpuCounterBlock;

  typedef GpuCounterDescriptor_MeasureUnit MeasureUnit;
  static const MeasureUnit NONE =
    GpuCounterDescriptor_MeasureUnit_NONE;
  static const MeasureUnit BIT =
    GpuCounterDescriptor_MeasureUnit_BIT;
  static const MeasureUnit KILOBIT =
    GpuCounterDescriptor_MeasureUnit_KILOBIT;
  static const MeasureUnit MEGABIT =
    GpuCounterDescriptor_MeasureUnit_MEGABIT;
  static const MeasureUnit GIGABIT =
    GpuCounterDescriptor_MeasureUnit_GIGABIT;
  static const MeasureUnit TERABIT =
    GpuCounterDescriptor_MeasureUnit_TERABIT;
  static const MeasureUnit PETABIT =
    GpuCounterDescriptor_MeasureUnit_PETABIT;
  static const MeasureUnit BYTE =
    GpuCounterDescriptor_MeasureUnit_BYTE;
  static const MeasureUnit KILOBYTE =
    GpuCounterDescriptor_MeasureUnit_KILOBYTE;
  static const MeasureUnit MEGABYTE =
    GpuCounterDescriptor_MeasureUnit_MEGABYTE;
  static const MeasureUnit GIGABYTE =
    GpuCounterDescriptor_MeasureUnit_GIGABYTE;
  static const MeasureUnit TERABYTE =
    GpuCounterDescriptor_MeasureUnit_TERABYTE;
  static const MeasureUnit PETABYTE =
    GpuCounterDescriptor_MeasureUnit_PETABYTE;
  static const MeasureUnit HERTZ =
    GpuCounterDescriptor_MeasureUnit_HERTZ;
  static const MeasureUnit KILOHERTZ =
    GpuCounterDescriptor_MeasureUnit_KILOHERTZ;
  static const MeasureUnit MEGAHERTZ =
    GpuCounterDescriptor_MeasureUnit_MEGAHERTZ;
  static const MeasureUnit GIGAHERTZ =
    GpuCounterDescriptor_MeasureUnit_GIGAHERTZ;
  static const MeasureUnit TERAHERTZ =
    GpuCounterDescriptor_MeasureUnit_TERAHERTZ;
  static const MeasureUnit PETAHERTZ =
    GpuCounterDescriptor_MeasureUnit_PETAHERTZ;
  static const MeasureUnit NANOSECOND =
    GpuCounterDescriptor_MeasureUnit_NANOSECOND;
  static const MeasureUnit MICROSECOND =
    GpuCounterDescriptor_MeasureUnit_MICROSECOND;
  static const MeasureUnit MILLISECOND =
    GpuCounterDescriptor_MeasureUnit_MILLISECOND;
  static const MeasureUnit SECOND =
    GpuCounterDescriptor_MeasureUnit_SECOND;
  static const MeasureUnit MINUTE =
    GpuCounterDescriptor_MeasureUnit_MINUTE;
  static const MeasureUnit HOUR =
    GpuCounterDescriptor_MeasureUnit_HOUR;
  static const MeasureUnit VERTEX =
    GpuCounterDescriptor_MeasureUnit_VERTEX;
  static const MeasureUnit PIXEL =
    GpuCounterDescriptor_MeasureUnit_PIXEL;
  static const MeasureUnit TRIANGLE =
    GpuCounterDescriptor_MeasureUnit_TRIANGLE;
  static const MeasureUnit MILLIWATT =
    GpuCounterDescriptor_MeasureUnit_MILLIWATT;
  static const MeasureUnit WATT =
    GpuCounterDescriptor_MeasureUnit_WATT;
  static const MeasureUnit KILOWATT =
    GpuCounterDescriptor_MeasureUnit_KILOWATT;
  static const MeasureUnit JOULE =
    GpuCounterDescriptor_MeasureUnit_JOULE;
  static const MeasureUnit VOLT =
    GpuCounterDescriptor_MeasureUnit_VOLT;
  static const MeasureUnit AMPERE =
    GpuCounterDescriptor_MeasureUnit_AMPERE;
  static const MeasureUnit CELSIUS =
    GpuCounterDescriptor_MeasureUnit_CELSIUS;
  static const MeasureUnit FAHRENHEIT =
    GpuCounterDescriptor_MeasureUnit_FAHRENHEIT;
  static const MeasureUnit KELVIN =
    GpuCounterDescriptor_MeasureUnit_KELVIN;
  static const MeasureUnit PERCENT =
    GpuCounterDescriptor_MeasureUnit_PERCENT;
  static inline bool MeasureUnit_IsValid(int value) {
    return GpuCounterDescriptor_MeasureUnit_IsValid(value);
  }
  static const MeasureUnit MeasureUnit_MIN =
    GpuCounterDescriptor_MeasureUnit_MeasureUnit_MIN;
  static const MeasureUnit MeasureUnit_MAX =
    GpuCounterDescriptor_MeasureUnit_MeasureUnit_MAX;
  static const int MeasureUnit_ARRAYSIZE =
    GpuCounterDescriptor_MeasureUnit_MeasureUnit_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .perfetto.protos.GpuCounterDescriptor.GpuCounterSpec specs = 1;
  int specs_size() const;
  void clear_specs();
  static const int kSpecsFieldNumber = 1;
  const ::perfetto::protos::GpuCounterDescriptor_GpuCounterSpec& specs(int index) const;
  ::perfetto::protos::GpuCounterDescriptor_GpuCounterSpec* mutable_specs(int index);
  ::perfetto::protos::GpuCounterDescriptor_GpuCounterSpec* add_specs();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::GpuCounterDescriptor_GpuCounterSpec >*
      mutable_specs();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::GpuCounterDescriptor_GpuCounterSpec >&
      specs() const;

  // repeated .perfetto.protos.GpuCounterDescriptor.GpuCounterBlock blocks = 2;
  int blocks_size() const;
  void clear_blocks();
  static const int kBlocksFieldNumber = 2;
  const ::perfetto::protos::GpuCounterDescriptor_GpuCounterBlock& blocks(int index) const;
  ::perfetto::protos::GpuCounterDescriptor_GpuCounterBlock* mutable_blocks(int index);
  ::perfetto::protos::GpuCounterDescriptor_GpuCounterBlock* add_blocks();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::GpuCounterDescriptor_GpuCounterBlock >*
      mutable_blocks();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::GpuCounterDescriptor_GpuCounterBlock >&
      blocks() const;

  // optional uint64 min_sampling_period_ns = 3;
  bool has_min_sampling_period_ns() const;
  void clear_min_sampling_period_ns();
  static const int kMinSamplingPeriodNsFieldNumber = 3;
  ::google::protobuf::uint64 min_sampling_period_ns() const;
  void set_min_sampling_period_ns(::google::protobuf::uint64 value);

  // optional uint64 max_sampling_period_ns = 4;
  bool has_max_sampling_period_ns() const;
  void clear_max_sampling_period_ns();
  static const int kMaxSamplingPeriodNsFieldNumber = 4;
  ::google::protobuf::uint64 max_sampling_period_ns() const;
  void set_max_sampling_period_ns(::google::protobuf::uint64 value);

  // optional bool supports_instrumented_sampling = 5;
  bool has_supports_instrumented_sampling() const;
  void clear_supports_instrumented_sampling();
  static const int kSupportsInstrumentedSamplingFieldNumber = 5;
  bool supports_instrumented_sampling() const;
  void set_supports_instrumented_sampling(bool value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.GpuCounterDescriptor)
 private:
  inline void set_has_min_sampling_period_ns();
  inline void clear_has_min_sampling_period_ns();
  inline void set_has_max_sampling_period_ns();
  inline void clear_has_max_sampling_period_ns();
  inline void set_has_supports_instrumented_sampling();
  inline void clear_has_supports_instrumented_sampling();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::GpuCounterDescriptor_GpuCounterSpec > specs_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::GpuCounterDescriptor_GpuCounterBlock > blocks_;
  ::google::protobuf::uint64 min_sampling_period_ns_;
  ::google::protobuf::uint64 max_sampling_period_ns_;
  bool supports_instrumented_sampling_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto();

  void InitAsDefaultInstance();
  static GpuCounterDescriptor* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// GpuCounterDescriptor_GpuCounterSpec

// optional uint32 counter_id = 1;
inline bool GpuCounterDescriptor_GpuCounterSpec::has_counter_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GpuCounterDescriptor_GpuCounterSpec::set_has_counter_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GpuCounterDescriptor_GpuCounterSpec::clear_has_counter_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GpuCounterDescriptor_GpuCounterSpec::clear_counter_id() {
  counter_id_ = 0u;
  clear_has_counter_id();
}
inline ::google::protobuf::uint32 GpuCounterDescriptor_GpuCounterSpec::counter_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.counter_id)
  return counter_id_;
}
inline void GpuCounterDescriptor_GpuCounterSpec::set_counter_id(::google::protobuf::uint32 value) {
  set_has_counter_id();
  counter_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.counter_id)
}

// optional string name = 2;
inline bool GpuCounterDescriptor_GpuCounterSpec::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GpuCounterDescriptor_GpuCounterSpec::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GpuCounterDescriptor_GpuCounterSpec::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GpuCounterDescriptor_GpuCounterSpec::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& GpuCounterDescriptor_GpuCounterSpec::name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GpuCounterDescriptor_GpuCounterSpec::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.name)
}
inline void GpuCounterDescriptor_GpuCounterSpec::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.name)
}
inline void GpuCounterDescriptor_GpuCounterSpec::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.name)
}
inline ::std::string* GpuCounterDescriptor_GpuCounterSpec::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GpuCounterDescriptor_GpuCounterSpec::release_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GpuCounterDescriptor_GpuCounterSpec::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.name)
}

// optional string description = 3;
inline bool GpuCounterDescriptor_GpuCounterSpec::has_description() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GpuCounterDescriptor_GpuCounterSpec::set_has_description() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GpuCounterDescriptor_GpuCounterSpec::clear_has_description() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GpuCounterDescriptor_GpuCounterSpec::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_description();
}
inline const ::std::string& GpuCounterDescriptor_GpuCounterSpec::description() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.description)
  return description_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GpuCounterDescriptor_GpuCounterSpec::set_description(const ::std::string& value) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.description)
}
inline void GpuCounterDescriptor_GpuCounterSpec::set_description(const char* value) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.description)
}
inline void GpuCounterDescriptor_GpuCounterSpec::set_description(const char* value, size_t size) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.description)
}
inline ::std::string* GpuCounterDescriptor_GpuCounterSpec::mutable_description() {
  set_has_description();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GpuCounterDescriptor_GpuCounterSpec::release_description() {
  // @@protoc_insertion_point(field_release:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.description)
  clear_has_description();
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GpuCounterDescriptor_GpuCounterSpec::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    set_has_description();
  } else {
    clear_has_description();
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.description)
}

// optional int64 int_peak_value = 5;
inline bool GpuCounterDescriptor_GpuCounterSpec::has_int_peak_value() const {
  return peak_value_case() == kIntPeakValue;
}
inline void GpuCounterDescriptor_GpuCounterSpec::set_has_int_peak_value() {
  _oneof_case_[0] = kIntPeakValue;
}
inline void GpuCounterDescriptor_GpuCounterSpec::clear_int_peak_value() {
  if (has_int_peak_value()) {
    peak_value_.int_peak_value_ = GOOGLE_LONGLONG(0);
    clear_has_peak_value();
  }
}
inline ::google::protobuf::int64 GpuCounterDescriptor_GpuCounterSpec::int_peak_value() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.int_peak_value)
  if (has_int_peak_value()) {
    return peak_value_.int_peak_value_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void GpuCounterDescriptor_GpuCounterSpec::set_int_peak_value(::google::protobuf::int64 value) {
  if (!has_int_peak_value()) {
    clear_peak_value();
    set_has_int_peak_value();
  }
  peak_value_.int_peak_value_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.int_peak_value)
}

// optional double double_peak_value = 6;
inline bool GpuCounterDescriptor_GpuCounterSpec::has_double_peak_value() const {
  return peak_value_case() == kDoublePeakValue;
}
inline void GpuCounterDescriptor_GpuCounterSpec::set_has_double_peak_value() {
  _oneof_case_[0] = kDoublePeakValue;
}
inline void GpuCounterDescriptor_GpuCounterSpec::clear_double_peak_value() {
  if (has_double_peak_value()) {
    peak_value_.double_peak_value_ = 0;
    clear_has_peak_value();
  }
}
inline double GpuCounterDescriptor_GpuCounterSpec::double_peak_value() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.double_peak_value)
  if (has_double_peak_value()) {
    return peak_value_.double_peak_value_;
  }
  return 0;
}
inline void GpuCounterDescriptor_GpuCounterSpec::set_double_peak_value(double value) {
  if (!has_double_peak_value()) {
    clear_peak_value();
    set_has_double_peak_value();
  }
  peak_value_.double_peak_value_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.double_peak_value)
}

// repeated .perfetto.protos.GpuCounterDescriptor.MeasureUnit numerator_units = 7;
inline int GpuCounterDescriptor_GpuCounterSpec::numerator_units_size() const {
  return numerator_units_.size();
}
inline void GpuCounterDescriptor_GpuCounterSpec::clear_numerator_units() {
  numerator_units_.Clear();
}
inline ::perfetto::protos::GpuCounterDescriptor_MeasureUnit GpuCounterDescriptor_GpuCounterSpec::numerator_units(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.numerator_units)
  return static_cast< ::perfetto::protos::GpuCounterDescriptor_MeasureUnit >(numerator_units_.Get(index));
}
inline void GpuCounterDescriptor_GpuCounterSpec::set_numerator_units(int index, ::perfetto::protos::GpuCounterDescriptor_MeasureUnit value) {
  assert(::perfetto::protos::GpuCounterDescriptor_MeasureUnit_IsValid(value));
  numerator_units_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.numerator_units)
}
inline void GpuCounterDescriptor_GpuCounterSpec::add_numerator_units(::perfetto::protos::GpuCounterDescriptor_MeasureUnit value) {
  assert(::perfetto::protos::GpuCounterDescriptor_MeasureUnit_IsValid(value));
  numerator_units_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.numerator_units)
}
inline const ::google::protobuf::RepeatedField<int>&
GpuCounterDescriptor_GpuCounterSpec::numerator_units() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.numerator_units)
  return numerator_units_;
}
inline ::google::protobuf::RepeatedField<int>*
GpuCounterDescriptor_GpuCounterSpec::mutable_numerator_units() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.numerator_units)
  return &numerator_units_;
}

// repeated .perfetto.protos.GpuCounterDescriptor.MeasureUnit denominator_units = 8;
inline int GpuCounterDescriptor_GpuCounterSpec::denominator_units_size() const {
  return denominator_units_.size();
}
inline void GpuCounterDescriptor_GpuCounterSpec::clear_denominator_units() {
  denominator_units_.Clear();
}
inline ::perfetto::protos::GpuCounterDescriptor_MeasureUnit GpuCounterDescriptor_GpuCounterSpec::denominator_units(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.denominator_units)
  return static_cast< ::perfetto::protos::GpuCounterDescriptor_MeasureUnit >(denominator_units_.Get(index));
}
inline void GpuCounterDescriptor_GpuCounterSpec::set_denominator_units(int index, ::perfetto::protos::GpuCounterDescriptor_MeasureUnit value) {
  assert(::perfetto::protos::GpuCounterDescriptor_MeasureUnit_IsValid(value));
  denominator_units_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.denominator_units)
}
inline void GpuCounterDescriptor_GpuCounterSpec::add_denominator_units(::perfetto::protos::GpuCounterDescriptor_MeasureUnit value) {
  assert(::perfetto::protos::GpuCounterDescriptor_MeasureUnit_IsValid(value));
  denominator_units_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.denominator_units)
}
inline const ::google::protobuf::RepeatedField<int>&
GpuCounterDescriptor_GpuCounterSpec::denominator_units() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.denominator_units)
  return denominator_units_;
}
inline ::google::protobuf::RepeatedField<int>*
GpuCounterDescriptor_GpuCounterSpec::mutable_denominator_units() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.denominator_units)
  return &denominator_units_;
}

// optional bool select_by_default = 9;
inline bool GpuCounterDescriptor_GpuCounterSpec::has_select_by_default() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GpuCounterDescriptor_GpuCounterSpec::set_has_select_by_default() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GpuCounterDescriptor_GpuCounterSpec::clear_has_select_by_default() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GpuCounterDescriptor_GpuCounterSpec::clear_select_by_default() {
  select_by_default_ = false;
  clear_has_select_by_default();
}
inline bool GpuCounterDescriptor_GpuCounterSpec::select_by_default() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.select_by_default)
  return select_by_default_;
}
inline void GpuCounterDescriptor_GpuCounterSpec::set_select_by_default(bool value) {
  set_has_select_by_default();
  select_by_default_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.select_by_default)
}

inline bool GpuCounterDescriptor_GpuCounterSpec::has_peak_value() const {
  return peak_value_case() != PEAK_VALUE_NOT_SET;
}
inline void GpuCounterDescriptor_GpuCounterSpec::clear_has_peak_value() {
  _oneof_case_[0] = PEAK_VALUE_NOT_SET;
}
inline GpuCounterDescriptor_GpuCounterSpec::PeakValueCase GpuCounterDescriptor_GpuCounterSpec::peak_value_case() const {
  return GpuCounterDescriptor_GpuCounterSpec::PeakValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// GpuCounterDescriptor_GpuCounterBlock

// optional uint32 block_id = 1;
inline bool GpuCounterDescriptor_GpuCounterBlock::has_block_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GpuCounterDescriptor_GpuCounterBlock::set_has_block_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GpuCounterDescriptor_GpuCounterBlock::clear_has_block_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GpuCounterDescriptor_GpuCounterBlock::clear_block_id() {
  block_id_ = 0u;
  clear_has_block_id();
}
inline ::google::protobuf::uint32 GpuCounterDescriptor_GpuCounterBlock::block_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterDescriptor.GpuCounterBlock.block_id)
  return block_id_;
}
inline void GpuCounterDescriptor_GpuCounterBlock::set_block_id(::google::protobuf::uint32 value) {
  set_has_block_id();
  block_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.GpuCounterDescriptor.GpuCounterBlock.block_id)
}

// optional uint32 block_capacity = 2;
inline bool GpuCounterDescriptor_GpuCounterBlock::has_block_capacity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GpuCounterDescriptor_GpuCounterBlock::set_has_block_capacity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GpuCounterDescriptor_GpuCounterBlock::clear_has_block_capacity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GpuCounterDescriptor_GpuCounterBlock::clear_block_capacity() {
  block_capacity_ = 0u;
  clear_has_block_capacity();
}
inline ::google::protobuf::uint32 GpuCounterDescriptor_GpuCounterBlock::block_capacity() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterDescriptor.GpuCounterBlock.block_capacity)
  return block_capacity_;
}
inline void GpuCounterDescriptor_GpuCounterBlock::set_block_capacity(::google::protobuf::uint32 value) {
  set_has_block_capacity();
  block_capacity_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.GpuCounterDescriptor.GpuCounterBlock.block_capacity)
}

// optional string name = 3;
inline bool GpuCounterDescriptor_GpuCounterBlock::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GpuCounterDescriptor_GpuCounterBlock::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GpuCounterDescriptor_GpuCounterBlock::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GpuCounterDescriptor_GpuCounterBlock::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& GpuCounterDescriptor_GpuCounterBlock::name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterDescriptor.GpuCounterBlock.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GpuCounterDescriptor_GpuCounterBlock::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.GpuCounterDescriptor.GpuCounterBlock.name)
}
inline void GpuCounterDescriptor_GpuCounterBlock::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.GpuCounterDescriptor.GpuCounterBlock.name)
}
inline void GpuCounterDescriptor_GpuCounterBlock::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.GpuCounterDescriptor.GpuCounterBlock.name)
}
inline ::std::string* GpuCounterDescriptor_GpuCounterBlock::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GpuCounterDescriptor.GpuCounterBlock.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GpuCounterDescriptor_GpuCounterBlock::release_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.GpuCounterDescriptor.GpuCounterBlock.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GpuCounterDescriptor_GpuCounterBlock::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.GpuCounterDescriptor.GpuCounterBlock.name)
}

// optional string description = 4;
inline bool GpuCounterDescriptor_GpuCounterBlock::has_description() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GpuCounterDescriptor_GpuCounterBlock::set_has_description() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GpuCounterDescriptor_GpuCounterBlock::clear_has_description() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GpuCounterDescriptor_GpuCounterBlock::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_description();
}
inline const ::std::string& GpuCounterDescriptor_GpuCounterBlock::description() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterDescriptor.GpuCounterBlock.description)
  return description_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GpuCounterDescriptor_GpuCounterBlock::set_description(const ::std::string& value) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.GpuCounterDescriptor.GpuCounterBlock.description)
}
inline void GpuCounterDescriptor_GpuCounterBlock::set_description(const char* value) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.GpuCounterDescriptor.GpuCounterBlock.description)
}
inline void GpuCounterDescriptor_GpuCounterBlock::set_description(const char* value, size_t size) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.GpuCounterDescriptor.GpuCounterBlock.description)
}
inline ::std::string* GpuCounterDescriptor_GpuCounterBlock::mutable_description() {
  set_has_description();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GpuCounterDescriptor.GpuCounterBlock.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GpuCounterDescriptor_GpuCounterBlock::release_description() {
  // @@protoc_insertion_point(field_release:perfetto.protos.GpuCounterDescriptor.GpuCounterBlock.description)
  clear_has_description();
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GpuCounterDescriptor_GpuCounterBlock::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    set_has_description();
  } else {
    clear_has_description();
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.GpuCounterDescriptor.GpuCounterBlock.description)
}

// repeated uint32 counter_ids = 5;
inline int GpuCounterDescriptor_GpuCounterBlock::counter_ids_size() const {
  return counter_ids_.size();
}
inline void GpuCounterDescriptor_GpuCounterBlock::clear_counter_ids() {
  counter_ids_.Clear();
}
inline ::google::protobuf::uint32 GpuCounterDescriptor_GpuCounterBlock::counter_ids(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterDescriptor.GpuCounterBlock.counter_ids)
  return counter_ids_.Get(index);
}
inline void GpuCounterDescriptor_GpuCounterBlock::set_counter_ids(int index, ::google::protobuf::uint32 value) {
  counter_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.GpuCounterDescriptor.GpuCounterBlock.counter_ids)
}
inline void GpuCounterDescriptor_GpuCounterBlock::add_counter_ids(::google::protobuf::uint32 value) {
  counter_ids_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.GpuCounterDescriptor.GpuCounterBlock.counter_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
GpuCounterDescriptor_GpuCounterBlock::counter_ids() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.GpuCounterDescriptor.GpuCounterBlock.counter_ids)
  return counter_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
GpuCounterDescriptor_GpuCounterBlock::mutable_counter_ids() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.GpuCounterDescriptor.GpuCounterBlock.counter_ids)
  return &counter_ids_;
}

// -------------------------------------------------------------------

// GpuCounterDescriptor

// repeated .perfetto.protos.GpuCounterDescriptor.GpuCounterSpec specs = 1;
inline int GpuCounterDescriptor::specs_size() const {
  return specs_.size();
}
inline void GpuCounterDescriptor::clear_specs() {
  specs_.Clear();
}
inline const ::perfetto::protos::GpuCounterDescriptor_GpuCounterSpec& GpuCounterDescriptor::specs(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterDescriptor.specs)
  return specs_.Get(index);
}
inline ::perfetto::protos::GpuCounterDescriptor_GpuCounterSpec* GpuCounterDescriptor::mutable_specs(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GpuCounterDescriptor.specs)
  return specs_.Mutable(index);
}
inline ::perfetto::protos::GpuCounterDescriptor_GpuCounterSpec* GpuCounterDescriptor::add_specs() {
  // @@protoc_insertion_point(field_add:perfetto.protos.GpuCounterDescriptor.specs)
  return specs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::GpuCounterDescriptor_GpuCounterSpec >*
GpuCounterDescriptor::mutable_specs() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.GpuCounterDescriptor.specs)
  return &specs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::GpuCounterDescriptor_GpuCounterSpec >&
GpuCounterDescriptor::specs() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.GpuCounterDescriptor.specs)
  return specs_;
}

// repeated .perfetto.protos.GpuCounterDescriptor.GpuCounterBlock blocks = 2;
inline int GpuCounterDescriptor::blocks_size() const {
  return blocks_.size();
}
inline void GpuCounterDescriptor::clear_blocks() {
  blocks_.Clear();
}
inline const ::perfetto::protos::GpuCounterDescriptor_GpuCounterBlock& GpuCounterDescriptor::blocks(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterDescriptor.blocks)
  return blocks_.Get(index);
}
inline ::perfetto::protos::GpuCounterDescriptor_GpuCounterBlock* GpuCounterDescriptor::mutable_blocks(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GpuCounterDescriptor.blocks)
  return blocks_.Mutable(index);
}
inline ::perfetto::protos::GpuCounterDescriptor_GpuCounterBlock* GpuCounterDescriptor::add_blocks() {
  // @@protoc_insertion_point(field_add:perfetto.protos.GpuCounterDescriptor.blocks)
  return blocks_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::GpuCounterDescriptor_GpuCounterBlock >*
GpuCounterDescriptor::mutable_blocks() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.GpuCounterDescriptor.blocks)
  return &blocks_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::GpuCounterDescriptor_GpuCounterBlock >&
GpuCounterDescriptor::blocks() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.GpuCounterDescriptor.blocks)
  return blocks_;
}

// optional uint64 min_sampling_period_ns = 3;
inline bool GpuCounterDescriptor::has_min_sampling_period_ns() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GpuCounterDescriptor::set_has_min_sampling_period_ns() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GpuCounterDescriptor::clear_has_min_sampling_period_ns() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GpuCounterDescriptor::clear_min_sampling_period_ns() {
  min_sampling_period_ns_ = GOOGLE_ULONGLONG(0);
  clear_has_min_sampling_period_ns();
}
inline ::google::protobuf::uint64 GpuCounterDescriptor::min_sampling_period_ns() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterDescriptor.min_sampling_period_ns)
  return min_sampling_period_ns_;
}
inline void GpuCounterDescriptor::set_min_sampling_period_ns(::google::protobuf::uint64 value) {
  set_has_min_sampling_period_ns();
  min_sampling_period_ns_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.GpuCounterDescriptor.min_sampling_period_ns)
}

// optional uint64 max_sampling_period_ns = 4;
inline bool GpuCounterDescriptor::has_max_sampling_period_ns() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GpuCounterDescriptor::set_has_max_sampling_period_ns() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GpuCounterDescriptor::clear_has_max_sampling_period_ns() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GpuCounterDescriptor::clear_max_sampling_period_ns() {
  max_sampling_period_ns_ = GOOGLE_ULONGLONG(0);
  clear_has_max_sampling_period_ns();
}
inline ::google::protobuf::uint64 GpuCounterDescriptor::max_sampling_period_ns() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterDescriptor.max_sampling_period_ns)
  return max_sampling_period_ns_;
}
inline void GpuCounterDescriptor::set_max_sampling_period_ns(::google::protobuf::uint64 value) {
  set_has_max_sampling_period_ns();
  max_sampling_period_ns_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.GpuCounterDescriptor.max_sampling_period_ns)
}

// optional bool supports_instrumented_sampling = 5;
inline bool GpuCounterDescriptor::has_supports_instrumented_sampling() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GpuCounterDescriptor::set_has_supports_instrumented_sampling() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GpuCounterDescriptor::clear_has_supports_instrumented_sampling() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GpuCounterDescriptor::clear_supports_instrumented_sampling() {
  supports_instrumented_sampling_ = false;
  clear_has_supports_instrumented_sampling();
}
inline bool GpuCounterDescriptor::supports_instrumented_sampling() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterDescriptor.supports_instrumented_sampling)
  return supports_instrumented_sampling_;
}
inline void GpuCounterDescriptor::set_supports_instrumented_sampling(bool value) {
  set_has_supports_instrumented_sampling();
  supports_instrumented_sampling_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.GpuCounterDescriptor.supports_instrumented_sampling)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::perfetto::protos::GpuCounterDescriptor_MeasureUnit> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto__INCLUDED
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/common/track_event_descriptor.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/common/track_event_descriptor.proto

#ifndef PROTOBUF_protos_2fperfetto_2fcommon_2ftrack_5fevent_5fdescriptor_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2fcommon_2ftrack_5fevent_5fdescriptor_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2fcommon_2ftrack_5fevent_5fdescriptor_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2ftrack_5fevent_5fdescriptor_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2ftrack_5fevent_5fdescriptor_2eproto();

class TrackEventDescriptor;

// ===================================================================

class TrackEventDescriptor : public ::google::protobuf::MessageLite {
 public:
  TrackEventDescriptor();
  virtual ~TrackEventDescriptor();

  TrackEventDescriptor(const TrackEventDescriptor& from);

  inline TrackEventDescriptor& operator=(const TrackEventDescriptor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TrackEventDescriptor& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TrackEventDescriptor* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TrackEventDescriptor* other);

  // implements Message ----------------------------------------------

  inline TrackEventDescriptor* New() const { return New(NULL); }

  TrackEventDescriptor* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TrackEventDescriptor& from);
  void MergeFrom(const TrackEventDescriptor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TrackEventDescriptor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string available_categories = 1;
  int available_categories_size() const;
  void clear_available_categories();
  static const int kAvailableCategoriesFieldNumber = 1;
  const ::std::string& available_categories(int index) const;
  ::std::string* mutable_available_categories(int index);
  void set_available_categories(int index, const ::std::string& value);
  void set_available_categories(int index, const char* value);
  void set_available_categories(int index, const char* value, size_t size);
  ::std::string* add_available_categories();
  void add_available_categories(const ::std::string& value);
  void add_available_categories(const char* value);
  void add_available_categories(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& available_categories() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_available_categories();

  // @@protoc_insertion_point(class_scope:perfetto.protos.TrackEventDescriptor)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> available_categories_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2ftrack_5fevent_5fdescriptor_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2ftrack_5fevent_5fdescriptor_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2ftrack_5fevent_5fdescriptor_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2ftrack_5fevent_5fdescriptor_2eproto();

  void InitAsDefaultInstance();
  static TrackEventDescriptor* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// TrackEventDescriptor

// repeated string available_categories = 1;
inline int TrackEventDescriptor::available_categories_size() const {
  return available_categories_.size();
}
inline void TrackEventDescriptor::clear_available_categories() {
  available_categories_.Clear();
}
inline const ::std::string& TrackEventDescriptor::available_categories(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TrackEventDescriptor.available_categories)
  return available_categories_.Get(index);
}
inline ::std::string* TrackEventDescriptor::mutable_available_categories(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TrackEventDescriptor.available_categories)
  return available_categories_.Mutable(index);
}
inline void TrackEventDescriptor::set_available_categories(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.TrackEventDescriptor.available_categories)
  available_categories_.Mutable(index)->assign(value);
}
inline void TrackEventDescriptor::set_available_categories(int index, const char* value) {
  available_categories_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.TrackEventDescriptor.available_categories)
}
inline void TrackEventDescriptor::set_available_categories(int index, const char* value, size_t size) {
  available_categories_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.TrackEventDescriptor.available_categories)
}
inline ::std::string* TrackEventDescriptor::add_available_categories() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.TrackEventDescriptor.available_categories)
  return available_categories_.Add();
}
inline void TrackEventDescriptor::add_available_categories(const ::std::string& value) {
  available_categories_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.TrackEventDescriptor.available_categories)
}
inline void TrackEventDescriptor::add_available_categories(const char* value) {
  available_categories_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.TrackEventDescriptor.available_categories)
}
inline void TrackEventDescriptor::add_available_categories(const char* value, size_t size) {
  available_categories_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.TrackEventDescriptor.available_categories)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TrackEventDescriptor::available_categories() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.TrackEventDescriptor.available_categories)
  return available_categories_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TrackEventDescriptor::mutable_available_categories() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.TrackEventDescriptor.available_categories)
  return &available_categories_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2fcommon_2ftrack_5fevent_5fdescriptor_2eproto__INCLUDED
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/common/data_source_descriptor.proto

#ifndef PROTOBUF_protos_2fperfetto_2fcommon_2fdata_5fsource_5fdescriptor_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2fcommon_2fdata_5fsource_5fdescriptor_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// gen_amalgamated expanded: #include "protos/perfetto/common/gpu_counter_descriptor.pb.h"
// gen_amalgamated expanded: #include "protos/perfetto/common/track_event_descriptor.pb.h"
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2fcommon_2fdata_5fsource_5fdescriptor_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2fdata_5fsource_5fdescriptor_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2fdata_5fsource_5fdescriptor_2eproto();

class DataSourceDescriptor;

// ===================================================================

class DataSourceDescriptor : public ::google::protobuf::MessageLite {
 public:
  DataSourceDescriptor();
  virtual ~DataSourceDescriptor();

  DataSourceDescriptor(const DataSourceDescriptor& from);

  inline DataSourceDescriptor& operator=(const DataSourceDescriptor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const DataSourceDescriptor& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DataSourceDescriptor* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DataSourceDescriptor* other);

  // implements Message ----------------------------------------------

  inline DataSourceDescriptor* New() const { return New(NULL); }

  DataSourceDescriptor* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DataSourceDescriptor& from);
  void MergeFrom(const DataSourceDescriptor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DataSourceDescriptor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional bool will_notify_on_stop = 2;
  bool has_will_notify_on_stop() const;
  void clear_will_notify_on_stop();
  static const int kWillNotifyOnStopFieldNumber = 2;
  bool will_notify_on_stop() const;
  void set_will_notify_on_stop(bool value);

  // optional bool will_notify_on_start = 3;
  bool has_will_notify_on_start() const;
  void clear_will_notify_on_start();
  static const int kWillNotifyOnStartFieldNumber = 3;
  bool will_notify_on_start() const;
  void set_will_notify_on_start(bool value);

  // optional bool handles_incremental_state_clear = 4;
  bool has_handles_incremental_state_clear() const;
  void clear_handles_incremental_state_clear();
  static const int kHandlesIncrementalStateClearFieldNumber = 4;
  bool handles_incremental_state_clear() const;
  void set_handles_incremental_state_clear(bool value);

  // optional .perfetto.protos.GpuCounterDescriptor gpu_counter_descriptor = 5 [lazy = true];
  bool has_gpu_counter_descriptor() const;
  void clear_gpu_counter_descriptor();
  static const int kGpuCounterDescriptorFieldNumber = 5;
  const ::perfetto::protos::GpuCounterDescriptor& gpu_counter_descriptor() const;
  ::perfetto::protos::GpuCounterDescriptor* mutable_gpu_counter_descriptor();
  ::perfetto::protos::GpuCounterDescriptor* release_gpu_counter_descriptor();
  void set_allocated_gpu_counter_descriptor(::perfetto::protos::GpuCounterDescriptor* gpu_counter_descriptor);

  // optional .perfetto.protos.TrackEventDescriptor track_event_descriptor = 6 [lazy = true];
  bool has_track_event_descriptor() const;
  void clear_track_event_descriptor();
  static const int kTrackEventDescriptorFieldNumber = 6;
  const ::perfetto::protos::TrackEventDescriptor& track_event_descriptor() const;
  ::perfetto::protos::TrackEventDescriptor* mutable_track_event_descriptor();
  ::perfetto::protos::TrackEventDescriptor* release_track_event_descriptor();
  void set_allocated_track_event_descriptor(::perfetto::protos::TrackEventDescriptor* track_event_descriptor);

  // @@protoc_insertion_point(class_scope:perfetto.protos.DataSourceDescriptor)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_will_notify_on_stop();
  inline void clear_has_will_notify_on_stop();
  inline void set_has_will_notify_on_start();
  inline void clear_has_will_notify_on_start();
  inline void set_has_handles_incremental_state_clear();
  inline void clear_has_handles_incremental_state_clear();
  inline void set_has_gpu_counter_descriptor();
  inline void clear_has_gpu_counter_descriptor();
  inline void set_has_track_event_descriptor();
  inline void clear_has_track_event_descriptor();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::perfetto::protos::GpuCounterDescriptor* gpu_counter_descriptor_;
  ::perfetto::protos::TrackEventDescriptor* track_event_descriptor_;
  bool will_notify_on_stop_;
  bool will_notify_on_start_;
  bool handles_incremental_state_clear_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fdata_5fsource_5fdescriptor_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fdata_5fsource_5fdescriptor_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2fdata_5fsource_5fdescriptor_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2fdata_5fsource_5fdescriptor_2eproto();

  void InitAsDefaultInstance();
  static DataSourceDescriptor* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// DataSourceDescriptor

// optional string name = 1;
inline bool DataSourceDescriptor::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataSourceDescriptor::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataSourceDescriptor::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataSourceDescriptor::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& DataSourceDescriptor::name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceDescriptor.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DataSourceDescriptor::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.DataSourceDescriptor.name)
}
inline void DataSourceDescriptor::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.DataSourceDescriptor.name)
}
inline void DataSourceDescriptor::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.DataSourceDescriptor.name)
}
inline ::std::string* DataSourceDescriptor::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceDescriptor.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DataSourceDescriptor::release_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceDescriptor.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DataSourceDescriptor::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceDescriptor.name)
}

// optional bool will_notify_on_stop = 2;
inline bool DataSourceDescriptor::has_will_notify_on_stop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataSourceDescriptor::set_has_will_notify_on_stop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataSourceDescriptor::clear_has_will_notify_on_stop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataSourceDescriptor::clear_will_notify_on_stop() {
  will_notify_on_stop_ = false;
  clear_has_will_notify_on_stop();
}
inline bool DataSourceDescriptor::will_notify_on_stop() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceDescriptor.will_notify_on_stop)
  return will_notify_on_stop_;
}
inline void DataSourceDescriptor::set_will_notify_on_stop(bool value) {
  set_has_will_notify_on_stop();
  will_notify_on_stop_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.DataSourceDescriptor.will_notify_on_stop)
}

// optional bool will_notify_on_start = 3;
inline bool DataSourceDescriptor::has_will_notify_on_start() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DataSourceDescriptor::set_has_will_notify_on_start() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DataSourceDescriptor::clear_has_will_notify_on_start() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DataSourceDescriptor::clear_will_notify_on_start() {
  will_notify_on_start_ = false;
  clear_has_will_notify_on_start();
}
inline bool DataSourceDescriptor::will_notify_on_start() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceDescriptor.will_notify_on_start)
  return will_notify_on_start_;
}
inline void DataSourceDescriptor::set_will_notify_on_start(bool value) {
  set_has_will_notify_on_start();
  will_notify_on_start_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.DataSourceDescriptor.will_notify_on_start)
}

// optional bool handles_incremental_state_clear = 4;
inline bool DataSourceDescriptor::has_handles_incremental_state_clear() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DataSourceDescriptor::set_has_handles_incremental_state_clear() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DataSourceDescriptor::clear_has_handles_incremental_state_clear() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DataSourceDescriptor::clear_handles_incremental_state_clear() {
  handles_incremental_state_clear_ = false;
  clear_has_handles_incremental_state_clear();
}
inline bool DataSourceDescriptor::handles_incremental_state_clear() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceDescriptor.handles_incremental_state_clear)
  return handles_incremental_state_clear_;
}
inline void DataSourceDescriptor::set_handles_incremental_state_clear(bool value) {
  set_has_handles_incremental_state_clear();
  handles_incremental_state_clear_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.DataSourceDescriptor.handles_incremental_state_clear)
}

// optional .perfetto.protos.GpuCounterDescriptor gpu_counter_descriptor = 5 [lazy = true];
inline bool DataSourceDescriptor::has_gpu_counter_descriptor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DataSourceDescriptor::set_has_gpu_counter_descriptor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DataSourceDescriptor::clear_has_gpu_counter_descriptor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DataSourceDescriptor::clear_gpu_counter_descriptor() {
  if (gpu_counter_descriptor_ != NULL) gpu_counter_descriptor_->::perfetto::protos::GpuCounterDescriptor::Clear();
  clear_has_gpu_counter_descriptor();
}
inline const ::perfetto::protos::GpuCounterDescriptor& DataSourceDescriptor::gpu_counter_descriptor() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceDescriptor.gpu_counter_descriptor)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return gpu_counter_descriptor_ != NULL ? *gpu_counter_descriptor_ : *default_instance().gpu_counter_descriptor_;
#else
  return gpu_counter_descriptor_ != NULL ? *gpu_counter_descriptor_ : *default_instance_->gpu_counter_descriptor_;
#endif
}
inline ::perfetto::protos::GpuCounterDescriptor* DataSourceDescriptor::mutable_gpu_counter_descriptor() {
  set_has_gpu_counter_descriptor();
  if (gpu_counter_descriptor_ == NULL) {
    gpu_counter_descriptor_ = new ::perfetto::protos::GpuCounterDescriptor;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceDescriptor.gpu_counter_descriptor)
  return gpu_counter_descriptor_;
}
inline ::perfetto::protos::GpuCounterDescriptor* DataSourceDescriptor::release_gpu_counter_descriptor() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceDescriptor.gpu_counter_descriptor)
  clear_has_gpu_counter_descriptor();
  ::perfetto::protos::GpuCounterDescriptor* temp = gpu_counter_descriptor_;
  gpu_counter_descriptor_ = NULL;
  return temp;
}
inline void DataSourceDescriptor::set_allocated_gpu_counter_descriptor(::perfetto::protos::GpuCounterDescriptor* gpu_counter_descriptor) {
  delete gpu_counter_descriptor_;
  gpu_counter_descriptor_ = gpu_counter_descriptor;
  if (gpu_counter_descriptor) {
    set_has_gpu_counter_descriptor();
  } else {
    clear_has_gpu_counter_descriptor();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceDescriptor.gpu_counter_descriptor)
}

// optional .perfetto.protos.TrackEventDescriptor track_event_descriptor = 6 [lazy = true];
inline bool DataSourceDescriptor::has_track_event_descriptor() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DataSourceDescriptor::set_has_track_event_descriptor() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DataSourceDescriptor::clear_has_track_event_descriptor() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DataSourceDescriptor::clear_track_event_descriptor() {
  if (track_event_descriptor_ != NULL) track_event_descriptor_->::perfetto::protos::TrackEventDescriptor::Clear();
  clear_has_track_event_descriptor();
}
inline const ::perfetto::protos::TrackEventDescriptor& DataSourceDescriptor::track_event_descriptor() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceDescriptor.track_event_descriptor)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return track_event_descriptor_ != NULL ? *track_event_descriptor_ : *default_instance().track_event_descriptor_;
#else
  return track_event_descriptor_ != NULL ? *track_event_descriptor_ : *default_instance_->track_event_descriptor_;
#endif
}
inline ::perfetto::protos::TrackEventDescriptor* DataSourceDescriptor::mutable_track_event_descriptor() {
  set_has_track_event_descriptor();
  if (track_event_descriptor_ == NULL) {
    track_event_descriptor_ = new ::perfetto::protos::TrackEventDescriptor;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceDescriptor.track_event_descriptor)
  return track_event_descriptor_;
}
inline ::perfetto::protos::TrackEventDescriptor* DataSourceDescriptor::release_track_event_descriptor() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceDescriptor.track_event_descriptor)
  clear_has_track_event_descriptor();
  ::perfetto::protos::TrackEventDescriptor* temp = track_event_descriptor_;
  track_event_descriptor_ = NULL;
  return temp;
}
inline void DataSourceDescriptor::set_allocated_track_event_descriptor(::perfetto::protos::TrackEventDescriptor* track_event_descriptor) {
  delete track_event_descriptor_;
  track_event_descriptor_ = track_event_descriptor;
  if (track_event_descriptor) {
    set_has_track_event_descriptor();
  } else {
    clear_has_track_event_descriptor();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceDescriptor.track_event_descriptor)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2fcommon_2fdata_5fsource_5fdescriptor_2eproto__INCLUDED
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/common/descriptor.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/common/descriptor.proto

#ifndef PROTOBUF_protos_2fperfetto_2fcommon_2fdescriptor_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2fcommon_2fdescriptor_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2fcommon_2fdescriptor_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2fdescriptor_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2fdescriptor_2eproto();

class DescriptorProto;
class DescriptorProto_ReservedRange;
class EnumDescriptorProto;
class EnumValueDescriptorProto;
class FieldDescriptorProto;
class FileDescriptorProto;
class FileDescriptorSet;
class OneofDescriptorProto;
class OneofOptions;

enum FieldDescriptorProto_Type {
  FieldDescriptorProto_Type_TYPE_DOUBLE = 1,
  FieldDescriptorProto_Type_TYPE_FLOAT = 2,
  FieldDescriptorProto_Type_TYPE_INT64 = 3,
  FieldDescriptorProto_Type_TYPE_UINT64 = 4,
  FieldDescriptorProto_Type_TYPE_INT32 = 5,
  FieldDescriptorProto_Type_TYPE_FIXED64 = 6,
  FieldDescriptorProto_Type_TYPE_FIXED32 = 7,
  FieldDescriptorProto_Type_TYPE_BOOL = 8,
  FieldDescriptorProto_Type_TYPE_STRING = 9,
  FieldDescriptorProto_Type_TYPE_GROUP = 10,
  FieldDescriptorProto_Type_TYPE_MESSAGE = 11,
  FieldDescriptorProto_Type_TYPE_BYTES = 12,
  FieldDescriptorProto_Type_TYPE_UINT32 = 13,
  FieldDescriptorProto_Type_TYPE_ENUM = 14,
  FieldDescriptorProto_Type_TYPE_SFIXED32 = 15,
  FieldDescriptorProto_Type_TYPE_SFIXED64 = 16,
  FieldDescriptorProto_Type_TYPE_SINT32 = 17,
  FieldDescriptorProto_Type_TYPE_SINT64 = 18
};
bool FieldDescriptorProto_Type_IsValid(int value);
const FieldDescriptorProto_Type FieldDescriptorProto_Type_Type_MIN = FieldDescriptorProto_Type_TYPE_DOUBLE;
const FieldDescriptorProto_Type FieldDescriptorProto_Type_Type_MAX = FieldDescriptorProto_Type_TYPE_SINT64;
const int FieldDescriptorProto_Type_Type_ARRAYSIZE = FieldDescriptorProto_Type_Type_MAX + 1;

enum FieldDescriptorProto_Label {
  FieldDescriptorProto_Label_LABEL_OPTIONAL = 1,
  FieldDescriptorProto_Label_LABEL_REQUIRED = 2,
  FieldDescriptorProto_Label_LABEL_REPEATED = 3
};
bool FieldDescriptorProto_Label_IsValid(int value);
const FieldDescriptorProto_Label FieldDescriptorProto_Label_Label_MIN = FieldDescriptorProto_Label_LABEL_OPTIONAL;
const FieldDescriptorProto_Label FieldDescriptorProto_Label_Label_MAX = FieldDescriptorProto_Label_LABEL_REPEATED;
const int FieldDescriptorProto_Label_Label_ARRAYSIZE = FieldDescriptorProto_Label_Label_MAX + 1;

// ===================================================================

class FileDescriptorSet : public ::google::protobuf::MessageLite {
 public:
  FileDescriptorSet();
  virtual ~FileDescriptorSet();

  FileDescriptorSet(const FileDescriptorSet& from);

  inline FileDescriptorSet& operator=(const FileDescriptorSet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const FileDescriptorSet& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FileDescriptorSet* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FileDescriptorSet* other);

  // implements Message ----------------------------------------------

  inline FileDescriptorSet* New() const { return New(NULL); }

  FileDescriptorSet* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FileDescriptorSet& from);
  void MergeFrom(const FileDescriptorSet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FileDescriptorSet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .perfetto.protos.FileDescriptorProto file = 1;
  int file_size() const;
  void clear_file();
  static const int kFileFieldNumber = 1;
  const ::perfetto::protos::FileDescriptorProto& file(int index) const;
  ::perfetto::protos::FileDescriptorProto* mutable_file(int index);
  ::perfetto::protos::FileDescriptorProto* add_file();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::FileDescriptorProto >*
      mutable_file();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::FileDescriptorProto >&
      file() const;

  // @@protoc_insertion_point(class_scope:perfetto.protos.FileDescriptorSet)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::FileDescriptorProto > file_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fdescriptor_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fdescriptor_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2fdescriptor_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2fdescriptor_2eproto();

  void InitAsDefaultInstance();
  static FileDescriptorSet* default_instance_;
};
// -------------------------------------------------------------------

class FileDescriptorProto : public ::google::protobuf::MessageLite {
 public:
  FileDescriptorProto();
  virtual ~FileDescriptorProto();

  FileDescriptorProto(const FileDescriptorProto& from);

  inline FileDescriptorProto& operator=(const FileDescriptorProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const FileDescriptorProto& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FileDescriptorProto* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FileDescriptorProto* other);

  // implements Message ----------------------------------------------

  inline FileDescriptorProto* New() const { return New(NULL); }

  FileDescriptorProto* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FileDescriptorProto& from);
  void MergeFrom(const FileDescriptorProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FileDescriptorProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string package = 2;
  bool has_package() const;
  void clear_package();
  static const int kPackageFieldNumber = 2;
  const ::std::string& package() const;
  void set_package(const ::std::string& value);
  void set_package(const char* value);
  void set_package(const char* value, size_t size);
  ::std::string* mutable_package();
  ::std::string* release_package();
  void set_allocated_package(::std::string* package);

  // repeated string dependency = 3;
  int dependency_size() const;
  void clear_dependency();
  static const int kDependencyFieldNumber = 3;
  const ::std::string& dependency(int index) const;
  ::std::string* mutable_dependency(int index);
  void set_dependency(int index, const ::std::string& value);
  void set_dependency(int index, const char* value);
  void set_dependency(int index, const char* value, size_t size);
  ::std::string* add_dependency();
  void add_dependency(const ::std::string& value);
  void add_dependency(const char* value);
  void add_dependency(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& dependency() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_dependency();

  // repeated int32 public_dependency = 10;
  int public_dependency_size() const;
  void clear_public_dependency();
  static const int kPublicDependencyFieldNumber = 10;
  ::google::protobuf::int32 public_dependency(int index) const;
  void set_public_dependency(int index, ::google::protobuf::int32 value);
  void add_public_dependency(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      public_dependency() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_public_dependency();

  // repeated int32 weak_dependency = 11;
  int weak_dependency_size() const;
  void clear_weak_dependency();
  static const int kWeakDependencyFieldNumber = 11;
  ::google::protobuf::int32 weak_dependency(int index) const;
  void set_weak_dependency(int index, ::google::protobuf::int32 value);
  void add_weak_dependency(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      weak_dependency() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_weak_dependency();

  // repeated .perfetto.protos.DescriptorProto message_type = 4;
  int message_type_size() const;
  void clear_message_type();
  static const int kMessageTypeFieldNumber = 4;
  const ::perfetto::protos::DescriptorProto& message_type(int index) const;
  ::perfetto::protos::DescriptorProto* mutable_message_type(int index);
  ::perfetto::protos::DescriptorProto* add_message_type();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::DescriptorProto >*
      mutable_message_type();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::DescriptorProto >&
      message_type() const;

  // repeated .perfetto.protos.EnumDescriptorProto enum_type = 5;
  int enum_type_size() const;
  void clear_enum_type();
  static const int kEnumTypeFieldNumber = 5;
  const ::perfetto::protos::EnumDescriptorProto& enum_type(int index) const;
  ::perfetto::protos::EnumDescriptorProto* mutable_enum_type(int index);
  ::perfetto::protos::EnumDescriptorProto* add_enum_type();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::EnumDescriptorProto >*
      mutable_enum_type();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::EnumDescriptorProto >&
      enum_type() const;

  // repeated .perfetto.protos.FieldDescriptorProto extension = 7;
  int extension_size() const;
  void clear_extension();
  static const int kExtensionFieldNumber = 7;
  const ::perfetto::protos::FieldDescriptorProto& extension(int index) const;
  ::perfetto::protos::FieldDescriptorProto* mutable_extension(int index);
  ::perfetto::protos::FieldDescriptorProto* add_extension();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::FieldDescriptorProto >*
      mutable_extension();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::FieldDescriptorProto >&
      extension() const;

  // @@protoc_insertion_point(class_scope:perfetto.protos.FileDescriptorProto)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_package();
  inline void clear_has_package();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr package_;
  ::google::protobuf::RepeatedPtrField< ::std::string> dependency_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > public_dependency_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > weak_dependency_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::DescriptorProto > message_type_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::EnumDescriptorProto > enum_type_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::FieldDescriptorProto > extension_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fdescriptor_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fdescriptor_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2fdescriptor_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2fdescriptor_2eproto();

  void InitAsDefaultInstance();
  static FileDescriptorProto* default_instance_;
};
// -------------------------------------------------------------------

class DescriptorProto_ReservedRange : public ::google::protobuf::MessageLite {
 public:
  DescriptorProto_ReservedRange();
  virtual ~DescriptorProto_ReservedRange();

  DescriptorProto_ReservedRange(const DescriptorProto_ReservedRange& from);

  inline DescriptorProto_ReservedRange& operator=(const DescriptorProto_ReservedRange& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const DescriptorProto_ReservedRange& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DescriptorProto_ReservedRange* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DescriptorProto_ReservedRange* other);

  // implements Message ----------------------------------------------

  inline DescriptorProto_ReservedRange* New() const { return New(NULL); }

  DescriptorProto_ReservedRange* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DescriptorProto_ReservedRange& from);
  void MergeFrom(const DescriptorProto_ReservedRange& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DescriptorProto_ReservedRange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 start = 1;
  bool has_start() const;
  void clear_start();
  static const int kStartFieldNumber = 1;
  ::google::protobuf::int32 start() const;
  void set_start(::google::protobuf::int32 value);

  // optional int32 end = 2;
  bool has_end() const;
  void clear_end();
  static const int kEndFieldNumber = 2;
  ::google::protobuf::int32 end() const;
  void set_end(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.DescriptorProto.ReservedRange)
 private:
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_end();
  inline void clear_has_end();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 start_;
  ::google::protobuf::int32 end_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fdescriptor_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fdescriptor_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2fdescriptor_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2fdescriptor_2eproto();

  void InitAsDefaultInstance();
  static DescriptorProto_ReservedRange* default_instance_;
};
// -------------------------------------------------------------------

class DescriptorProto : public ::google::protobuf::MessageLite {
 public:
  DescriptorProto();
  virtual ~DescriptorProto();

  DescriptorProto(const DescriptorProto& from);

  inline DescriptorProto& operator=(const DescriptorProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const DescriptorProto& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DescriptorProto* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DescriptorProto* other);

  // implements Message ----------------------------------------------

  inline DescriptorProto* New() const { return New(NULL); }

  DescriptorProto* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DescriptorProto& from);
  void MergeFrom(const DescriptorProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DescriptorProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef DescriptorProto_ReservedRange ReservedRange;

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // repeated .perfetto.protos.FieldDescriptorProto field = 2;
  int field_size() const;
  void clear_field();
  static const int kFieldFieldNumber = 2;
  const ::perfetto::protos::FieldDescriptorProto& field(int index) const;
  ::perfetto::protos::FieldDescriptorProto* mutable_field(int index);
  ::perfetto::protos::FieldDescriptorProto* add_field();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::FieldDescriptorProto >*
      mutable_field();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::FieldDescriptorProto >&
      field() const;

  // repeated .perfetto.protos.FieldDescriptorProto extension = 6;
  int extension_size() const;
  void clear_extension();
  static const int kExtensionFieldNumber = 6;
  const ::perfetto::protos::FieldDescriptorProto& extension(int index) const;
  ::perfetto::protos::FieldDescriptorProto* mutable_extension(int index);
  ::perfetto::protos::FieldDescriptorProto* add_extension();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::FieldDescriptorProto >*
      mutable_extension();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::FieldDescriptorProto >&
      extension() const;

  // repeated .perfetto.protos.DescriptorProto nested_type = 3;
  int nested_type_size() const;
  void clear_nested_type();
  static const int kNestedTypeFieldNumber = 3;
  const ::perfetto::protos::DescriptorProto& nested_type(int index) const;
  ::perfetto::protos::DescriptorProto* mutable_nested_type(int index);
  ::perfetto::protos::DescriptorProto* add_nested_type();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::DescriptorProto >*
      mutable_nested_type();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::DescriptorProto >&
      nested_type() const;

  // repeated .perfetto.protos.EnumDescriptorProto enum_type = 4;
  int enum_type_size() const;
  void clear_enum_type();
  static const int kEnumTypeFieldNumber = 4;
  const ::perfetto::protos::EnumDescriptorProto& enum_type(int index) const;
  ::perfetto::protos::EnumDescriptorProto* mutable_enum_type(int index);
  ::perfetto::protos::EnumDescriptorProto* add_enum_type();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::EnumDescriptorProto >*
      mutable_enum_type();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::EnumDescriptorProto >&
      enum_type() const;

  // repeated .perfetto.protos.OneofDescriptorProto oneof_decl = 8;
  int oneof_decl_size() const;
  void clear_oneof_decl();
  static const int kOneofDeclFieldNumber = 8;
  const ::perfetto::protos::OneofDescriptorProto& oneof_decl(int index) const;
  ::perfetto::protos::OneofDescriptorProto* mutable_oneof_decl(int index);
  ::perfetto::protos::OneofDescriptorProto* add_oneof_decl();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::OneofDescriptorProto >*
      mutable_oneof_decl();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::OneofDescriptorProto >&
      oneof_decl() const;

  // repeated .perfetto.protos.DescriptorProto.ReservedRange reserved_range = 9;
  int reserved_range_size() const;
  void clear_reserved_range();
  static const int kReservedRangeFieldNumber = 9;
  const ::perfetto::protos::DescriptorProto_ReservedRange& reserved_range(int index) const;
  ::perfetto::protos::DescriptorProto_ReservedRange* mutable_reserved_range(int index);
  ::perfetto::protos::DescriptorProto_ReservedRange* add_reserved_range();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::DescriptorProto_ReservedRange >*
      mutable_reserved_range();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::DescriptorProto_ReservedRange >&
      reserved_range() const;

  // repeated string reserved_name = 10;
  int reserved_name_size() const;
  void clear_reserved_name();
  static const int kReservedNameFieldNumber = 10;
  const ::std::string& reserved_name(int index) const;
  ::std::string* mutable_reserved_name(int index);
  void set_reserved_name(int index, const ::std::string& value);
  void set_reserved_name(int index, const char* value);
  void set_reserved_name(int index, const char* value, size_t size);
  ::std::string* add_reserved_name();
  void add_reserved_name(const ::std::string& value);
  void add_reserved_name(const char* value);
  void add_reserved_name(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& reserved_name() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_reserved_name();

  // @@protoc_insertion_point(class_scope:perfetto.protos.DescriptorProto)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::FieldDescriptorProto > field_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::FieldDescriptorProto > extension_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::DescriptorProto > nested_type_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::EnumDescriptorProto > enum_type_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::OneofDescriptorProto > oneof_decl_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::DescriptorProto_ReservedRange > reserved_range_;
  ::google::protobuf::RepeatedPtrField< ::std::string> reserved_name_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fdescriptor_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fdescriptor_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2fdescriptor_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2fdescriptor_2eproto();

  void InitAsDefaultInstance();
  static DescriptorProto* default_instance_;
};
// -------------------------------------------------------------------

class FieldDescriptorProto : public ::google::protobuf::MessageLite {
 public:
  FieldDescriptorProto();
  virtual ~FieldDescriptorProto();

  FieldDescriptorProto(const FieldDescriptorProto& from);

  inline FieldDescriptorProto& operator=(const FieldDescriptorProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const FieldDescriptorProto& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FieldDescriptorProto* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FieldDescriptorProto* other);

  // implements Message ----------------------------------------------

  inline FieldDescriptorProto* New() const { return New(NULL); }

  FieldDescriptorProto* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FieldDescriptorProto& from);
  void MergeFrom(const FieldDescriptorProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FieldDescriptorProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef FieldDescriptorProto_Type Type;
  static const Type TYPE_DOUBLE =
    FieldDescriptorProto_Type_TYPE_DOUBLE;
  static const Type TYPE_FLOAT =
    FieldDescriptorProto_Type_TYPE_FLOAT;
  static const Type TYPE_INT64 =
    FieldDescriptorProto_Type_TYPE_INT64;
  static const Type TYPE_UINT64 =
    FieldDescriptorProto_Type_TYPE_UINT64;
  static const Type TYPE_INT32 =
    FieldDescriptorProto_Type_TYPE_INT32;
  static const Type TYPE_FIXED64 =
    FieldDescriptorProto_Type_TYPE_FIXED64;
  static const Type TYPE_FIXED32 =
    FieldDescriptorProto_Type_TYPE_FIXED32;
  static const Type TYPE_BOOL =
    FieldDescriptorProto_Type_TYPE_BOOL;
  static const Type TYPE_STRING =
    FieldDescriptorProto_Type_TYPE_STRING;
  static const Type TYPE_GROUP =
    FieldDescriptorProto_Type_TYPE_GROUP;
  static const Type TYPE_MESSAGE =
    FieldDescriptorProto_Type_TYPE_MESSAGE;
  static const Type TYPE_BYTES =
    FieldDescriptorProto_Type_TYPE_BYTES;
  static const Type TYPE_UINT32 =
    FieldDescriptorProto_Type_TYPE_UINT32;
  static const Type TYPE_ENUM =
    FieldDescriptorProto_Type_TYPE_ENUM;
  static const Type TYPE_SFIXED32 =
    FieldDescriptorProto_Type_TYPE_SFIXED32;
  static const Type TYPE_SFIXED64 =
    FieldDescriptorProto_Type_TYPE_SFIXED64;
  static const Type TYPE_SINT32 =
    FieldDescriptorProto_Type_TYPE_SINT32;
  static const Type TYPE_SINT64 =
    FieldDescriptorProto_Type_TYPE_SINT64;
  static inline bool Type_IsValid(int value) {
    return FieldDescriptorProto_Type_IsValid(value);
  }
  static const Type Type_MIN =
    FieldDescriptorProto_Type_Type_MIN;
  static const Type Type_MAX =
    FieldDescriptorProto_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    FieldDescriptorProto_Type_Type_ARRAYSIZE;

  typedef FieldDescriptorProto_Label Label;
  static const Label LABEL_OPTIONAL =
    FieldDescriptorProto_Label_LABEL_OPTIONAL;
  static const Label LABEL_REQUIRED =
    FieldDescriptorProto_Label_LABEL_REQUIRED;
  static const Label LABEL_REPEATED =
    FieldDescriptorProto_Label_LABEL_REPEATED;
  static inline bool Label_IsValid(int value) {
    return FieldDescriptorProto_Label_IsValid(value);
  }
  static const Label Label_MIN =
    FieldDescriptorProto_Label_Label_MIN;
  static const Label Label_MAX =
    FieldDescriptorProto_Label_Label_MAX;
  static const int Label_ARRAYSIZE =
    FieldDescriptorProto_Label_Label_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional int32 number = 3;
  bool has_number() const;
  void clear_number();
  static const int kNumberFieldNumber = 3;
  ::google::protobuf::int32 number() const;
  void set_number(::google::protobuf::int32 value);

  // optional .perfetto.protos.FieldDescriptorProto.Label label = 4;
  bool has_label() const;
  void clear_label();
  static const int kLabelFieldNumber = 4;
  ::perfetto::protos::FieldDescriptorProto_Label label() const;
  void set_label(::perfetto::protos::FieldDescriptorProto_Label value);

  // optional .perfetto.protos.FieldDescriptorProto.Type type = 5;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 5;
  ::perfetto::protos::FieldDescriptorProto_Type type() const;
  void set_type(::perfetto::protos::FieldDescriptorProto_Type value);

  // optional string type_name = 6;
  bool has_type_name() const;
  void clear_type_name();
  static const int kTypeNameFieldNumber = 6;
  const ::std::string& type_name() const;
  void set_type_name(const ::std::string& value);
  void set_type_name(const char* value);
  void set_type_name(const char* value, size_t size);
  ::std::string* mutable_type_name();
  ::std::string* release_type_name();
  void set_allocated_type_name(::std::string* type_name);

  // optional string extendee = 2;
  bool has_extendee() const;
  void clear_extendee();
  static const int kExtendeeFieldNumber = 2;
  const ::std::string& extendee() const;
  void set_extendee(const ::std::string& value);
  void set_extendee(const char* value);
  void set_extendee(const char* value, size_t size);
  ::std::string* mutable_extendee();
  ::std::string* release_extendee();
  void set_allocated_extendee(::std::string* extendee);

  // optional string default_value = 7;
  bool has_default_value() const;
  void clear_default_value();
  static const int kDefaultValueFieldNumber = 7;
  const ::std::string& default_value() const;
  void set_default_value(const ::std::string& value);
  void set_default_value(const char* value);
  void set_default_value(const char* value, size_t size);
  ::std::string* mutable_default_value();
  ::std::string* release_default_value();
  void set_allocated_default_value(::std::string* default_value);

  // optional int32 oneof_index = 9;
  bool has_oneof_index() const;
  void clear_oneof_index();
  static const int kOneofIndexFieldNumber = 9;
  ::google::protobuf::int32 oneof_index() const;
  void set_oneof_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.FieldDescriptorProto)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_number();
  inline void clear_has_number();
  inline void set_has_label();
  inline void clear_has_label();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_type_name();
  inline void clear_has_type_name();
  inline void set_has_extendee();
  inline void clear_has_extendee();
  inline void set_has_default_value();
  inline void clear_has_default_value();
  inline void set_has_oneof_index();
  inline void clear_has_oneof_index();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int32 number_;
  int label_;
  ::google::protobuf::internal::ArenaStringPtr type_name_;
  ::google::protobuf::internal::ArenaStringPtr extendee_;
  int type_;
  ::google::protobuf::int32 oneof_index_;
  ::google::protobuf::internal::ArenaStringPtr default_value_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fdescriptor_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fdescriptor_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2fdescriptor_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2fdescriptor_2eproto();

  void InitAsDefaultInstance();
  static FieldDescriptorProto* default_instance_;
};
// -------------------------------------------------------------------

class OneofDescriptorProto : public ::google::protobuf::MessageLite {
 public:
  OneofDescriptorProto();
  virtual ~OneofDescriptorProto();

  OneofDescriptorProto(const OneofDescriptorProto& from);

  inline OneofDescriptorProto& operator=(const OneofDescriptorProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const OneofDescriptorProto& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const OneofDescriptorProto* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(OneofDescriptorProto* other);

  // implements Message ----------------------------------------------

  inline OneofDescriptorProto* New() const { return New(NULL); }

  OneofDescriptorProto* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const OneofDescriptorProto& from);
  void MergeFrom(const OneofDescriptorProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OneofDescriptorProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional .perfetto.protos.OneofOptions options = 2;
  bool has_options() const;
  void clear_options();
  static const int kOptionsFieldNumber = 2;
  const ::perfetto::protos::OneofOptions& options() const;
  ::perfetto::protos::OneofOptions* mutable_options();
  ::perfetto::protos::OneofOptions* release_options();
  void set_allocated_options(::perfetto::protos::OneofOptions* options);

  // @@protoc_insertion_point(class_scope:perfetto.protos.OneofDescriptorProto)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_options();
  inline void clear_has_options();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::perfetto::protos::OneofOptions* options_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fdescriptor_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fdescriptor_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2fdescriptor_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2fdescriptor_2eproto();

  void InitAsDefaultInstance();
  static OneofDescriptorProto* default_instance_;
};
// -------------------------------------------------------------------

class EnumDescriptorProto : public ::google::protobuf::MessageLite {
 public:
  EnumDescriptorProto();
  virtual ~EnumDescriptorProto();

  EnumDescriptorProto(const EnumDescriptorProto& from);

  inline EnumDescriptorProto& operator=(const EnumDescriptorProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const EnumDescriptorProto& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EnumDescriptorProto* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EnumDescriptorProto* other);

  // implements Message ----------------------------------------------

  inline EnumDescriptorProto* New() const { return New(NULL); }

  EnumDescriptorProto* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EnumDescriptorProto& from);
  void MergeFrom(const EnumDescriptorProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EnumDescriptorProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // repeated .perfetto.protos.EnumValueDescriptorProto value = 2;
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::perfetto::protos::EnumValueDescriptorProto& value(int index) const;
  ::perfetto::protos::EnumValueDescriptorProto* mutable_value(int index);
  ::perfetto::protos::EnumValueDescriptorProto* add_value();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::EnumValueDescriptorProto >*
      mutable_value();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::EnumValueDescriptorProto >&
      value() const;

  // repeated string reserved_name = 5;
  int reserved_name_size() const;
  void clear_reserved_name();
  static const int kReservedNameFieldNumber = 5;
  const ::std::string& reserved_name(int index) const;
  ::std::string* mutable_reserved_name(int index);
  void set_reserved_name(int index, const ::std::string& value);
  void set_reserved_name(int index, const char* value);
  void set_reserved_name(int index, const char* value, size_t size);
  ::std::string* add_reserved_name();
  void add_reserved_name(const ::std::string& value);
  void add_reserved_name(const char* value);
  void add_reserved_name(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& reserved_name() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_reserved_name();

  // @@protoc_insertion_point(class_scope:perfetto.protos.EnumDescriptorProto)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::EnumValueDescriptorProto > value_;
  ::google::protobuf::RepeatedPtrField< ::std::string> reserved_name_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fdescriptor_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fdescriptor_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2fdescriptor_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2fdescriptor_2eproto();

  void InitAsDefaultInstance();
  static EnumDescriptorProto* default_instance_;
};
// -------------------------------------------------------------------

class EnumValueDescriptorProto : public ::google::protobuf::MessageLite {
 public:
  EnumValueDescriptorProto();
  virtual ~EnumValueDescriptorProto();

  EnumValueDescriptorProto(const EnumValueDescriptorProto& from);

  inline EnumValueDescriptorProto& operator=(const EnumValueDescriptorProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const EnumValueDescriptorProto& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EnumValueDescriptorProto* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EnumValueDescriptorProto* other);

  // implements Message ----------------------------------------------

  inline EnumValueDescriptorProto* New() const { return New(NULL); }

  EnumValueDescriptorProto* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EnumValueDescriptorProto& from);
  void MergeFrom(const EnumValueDescriptorProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EnumValueDescriptorProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional int32 number = 2;
  bool has_number() const;
  void clear_number();
  static const int kNumberFieldNumber = 2;
  ::google::protobuf::int32 number() const;
  void set_number(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.EnumValueDescriptorProto)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_number();
  inline void clear_has_number();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int32 number_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fdescriptor_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fdescriptor_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2fdescriptor_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2fdescriptor_2eproto();

  void InitAsDefaultInstance();
  static EnumValueDescriptorProto* default_instance_;
};
// -------------------------------------------------------------------

class OneofOptions : public ::google::protobuf::MessageLite {
 public:
  OneofOptions();
  virtual ~OneofOptions();

  OneofOptions(const OneofOptions& from);

  inline OneofOptions& operator=(const OneofOptions& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const OneofOptions& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const OneofOptions* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(OneofOptions* other);

  // implements Message ----------------------------------------------

  inline OneofOptions* New() const { return New(NULL); }

  OneofOptions* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const OneofOptions& from);
  void MergeFrom(const OneofOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OneofOptions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(OneofOptions)
  // @@protoc_insertion_point(class_scope:perfetto.protos.OneofOptions)
 private:

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fdescriptor_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fdescriptor_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2fdescriptor_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2fdescriptor_2eproto();

  void InitAsDefaultInstance();
  static OneofOptions* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// FileDescriptorSet

// repeated .perfetto.protos.FileDescriptorProto file = 1;
inline int FileDescriptorSet::file_size() const {
  return file_.size();
}
inline void FileDescriptorSet::clear_file() {
  file_.Clear();
}
inline const ::perfetto::protos::FileDescriptorProto& FileDescriptorSet::file(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FileDescriptorSet.file)
  return file_.Get(index);
}
inline ::perfetto::protos::FileDescriptorProto* FileDescriptorSet::mutable_file(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.FileDescriptorSet.file)
  return file_.Mutable(index);
}
inline ::perfetto::protos::FileDescriptorProto* FileDescriptorSet::add_file() {
  // @@protoc_insertion_point(field_add:perfetto.protos.FileDescriptorSet.file)
  return file_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::FileDescriptorProto >*
FileDescriptorSet::mutable_file() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.FileDescriptorSet.file)
  return &file_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::FileDescriptorProto >&
FileDescriptorSet::file() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.FileDescriptorSet.file)
  return file_;
}

// -------------------------------------------------------------------

// FileDescriptorProto

// optional string name = 1;
inline bool FileDescriptorProto::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FileDescriptorProto::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FileDescriptorProto::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FileDescriptorProto::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& FileDescriptorProto::name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FileDescriptorProto.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileDescriptorProto::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.FileDescriptorProto.name)
}
inline void FileDescriptorProto::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.FileDescriptorProto.name)
}
inline void FileDescriptorProto::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.FileDescriptorProto.name)
}
inline ::std::string* FileDescriptorProto::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.FileDescriptorProto.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileDescriptorProto::release_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.FileDescriptorProto.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileDescriptorProto::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.FileDescriptorProto.name)
}

// optional string package = 2;
inline bool FileDescriptorProto::has_package() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FileDescriptorProto::set_has_package() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FileDescriptorProto::clear_has_package() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FileDescriptorProto::clear_package() {
  package_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_package();
}
inline const ::std::string& FileDescriptorProto::package() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FileDescriptorProto.package)
  return package_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileDescriptorProto::set_package(const ::std::string& value) {
  set_has_package();
  package_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.FileDescriptorProto.package)
}
inline void FileDescriptorProto::set_package(const char* value) {
  set_has_package();
  package_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.FileDescriptorProto.package)
}
inline void FileDescriptorProto::set_package(const char* value, size_t size) {
  set_has_package();
  package_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.FileDescriptorProto.package)
}
inline ::std::string* FileDescriptorProto::mutable_package() {
  set_has_package();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.FileDescriptorProto.package)
  return package_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileDescriptorProto::release_package() {
  // @@protoc_insertion_point(field_release:perfetto.protos.FileDescriptorProto.package)
  clear_has_package();
  return package_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileDescriptorProto::set_allocated_package(::std::string* package) {
  if (package != NULL) {
    set_has_package();
  } else {
    clear_has_package();
  }
  package_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), package);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.FileDescriptorProto.package)
}

// repeated string dependency = 3;
inline int FileDescriptorProto::dependency_size() const {
  return dependency_.size();
}
inline void FileDescriptorProto::clear_dependency() {
  dependency_.Clear();
}
inline const ::std::string& FileDescriptorProto::dependency(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FileDescriptorProto.dependency)
  return dependency_.Get(index);
}
inline ::std::string* FileDescriptorProto::mutable_dependency(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.FileDescriptorProto.dependency)
  return dependency_.Mutable(index);
}
inline void FileDescriptorProto::set_dependency(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.FileDescriptorProto.dependency)
  dependency_.Mutable(index)->assign(value);
}
inline void FileDescriptorProto::set_dependency(int index, const char* value) {
  dependency_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.FileDescriptorProto.dependency)
}
inline void FileDescriptorProto::set_dependency(int index, const char* value, size_t size) {
  dependency_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.FileDescriptorProto.dependency)
}
inline ::std::string* FileDescriptorProto::add_dependency() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.FileDescriptorProto.dependency)
  return dependency_.Add();
}
inline void FileDescriptorProto::add_dependency(const ::std::string& value) {
  dependency_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.FileDescriptorProto.dependency)
}
inline void FileDescriptorProto::add_dependency(const char* value) {
  dependency_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.FileDescriptorProto.dependency)
}
inline void FileDescriptorProto::add_dependency(const char* value, size_t size) {
  dependency_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.FileDescriptorProto.dependency)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FileDescriptorProto::dependency() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.FileDescriptorProto.dependency)
  return dependency_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FileDescriptorProto::mutable_dependency() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.FileDescriptorProto.dependency)
  return &dependency_;
}

// repeated int32 public_dependency = 10;
inline int FileDescriptorProto::public_dependency_size() const {
  return public_dependency_.size();
}
inline void FileDescriptorProto::clear_public_dependency() {
  public_dependency_.Clear();
}
inline ::google::protobuf::int32 FileDescriptorProto::public_dependency(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FileDescriptorProto.public_dependency)
  return public_dependency_.Get(index);
}
inline void FileDescriptorProto::set_public_dependency(int index, ::google::protobuf::int32 value) {
  public_dependency_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.FileDescriptorProto.public_dependency)
}
inline void FileDescriptorProto::add_public_dependency(::google::protobuf::int32 value) {
  public_dependency_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.FileDescriptorProto.public_dependency)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
FileDescriptorProto::public_dependency() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.FileDescriptorProto.public_dependency)
  return public_dependency_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
FileDescriptorProto::mutable_public_dependency() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.FileDescriptorProto.public_dependency)
  return &public_dependency_;
}

// repeated int32 weak_dependency = 11;
inline int FileDescriptorProto::weak_dependency_size() const {
  return weak_dependency_.size();
}
inline void FileDescriptorProto::clear_weak_dependency() {
  weak_dependency_.Clear();
}
inline ::google::protobuf::int32 FileDescriptorProto::weak_dependency(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FileDescriptorProto.weak_dependency)
  return weak_dependency_.Get(index);
}
inline void FileDescriptorProto::set_weak_dependency(int index, ::google::protobuf::int32 value) {
  weak_dependency_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.FileDescriptorProto.weak_dependency)
}
inline void FileDescriptorProto::add_weak_dependency(::google::protobuf::int32 value) {
  weak_dependency_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.FileDescriptorProto.weak_dependency)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
FileDescriptorProto::weak_dependency() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.FileDescriptorProto.weak_dependency)
  return weak_dependency_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
FileDescriptorProto::mutable_weak_dependency() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.FileDescriptorProto.weak_dependency)
  return &weak_dependency_;
}

// repeated .perfetto.protos.DescriptorProto message_type = 4;
inline int FileDescriptorProto::message_type_size() const {
  return message_type_.size();
}
inline void FileDescriptorProto::clear_message_type() {
  message_type_.Clear();
}
inline const ::perfetto::protos::DescriptorProto& FileDescriptorProto::message_type(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FileDescriptorProto.message_type)
  return message_type_.Get(index);
}
inline ::perfetto::protos::DescriptorProto* FileDescriptorProto::mutable_message_type(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.FileDescriptorProto.message_type)
  return message_type_.Mutable(index);
}
inline ::perfetto::protos::DescriptorProto* FileDescriptorProto::add_message_type() {
  // @@protoc_insertion_point(field_add:perfetto.protos.FileDescriptorProto.message_type)
  return message_type_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::DescriptorProto >*
FileDescriptorProto::mutable_message_type() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.FileDescriptorProto.message_type)
  return &message_type_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::DescriptorProto >&
FileDescriptorProto::message_type() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.FileDescriptorProto.message_type)
  return message_type_;
}

// repeated .perfetto.protos.EnumDescriptorProto enum_type = 5;
inline int FileDescriptorProto::enum_type_size() const {
  return enum_type_.size();
}
inline void FileDescriptorProto::clear_enum_type() {
  enum_type_.Clear();
}
inline const ::perfetto::protos::EnumDescriptorProto& FileDescriptorProto::enum_type(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FileDescriptorProto.enum_type)
  return enum_type_.Get(index);
}
inline ::perfetto::protos::EnumDescriptorProto* FileDescriptorProto::mutable_enum_type(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.FileDescriptorProto.enum_type)
  return enum_type_.Mutable(index);
}
inline ::perfetto::protos::EnumDescriptorProto* FileDescriptorProto::add_enum_type() {
  // @@protoc_insertion_point(field_add:perfetto.protos.FileDescriptorProto.enum_type)
  return enum_type_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::EnumDescriptorProto >*
FileDescriptorProto::mutable_enum_type() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.FileDescriptorProto.enum_type)
  return &enum_type_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::EnumDescriptorProto >&
FileDescriptorProto::enum_type() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.FileDescriptorProto.enum_type)
  return enum_type_;
}

// repeated .perfetto.protos.FieldDescriptorProto extension = 7;
inline int FileDescriptorProto::extension_size() const {
  return extension_.size();
}
inline void FileDescriptorProto::clear_extension() {
  extension_.Clear();
}
inline const ::perfetto::protos::FieldDescriptorProto& FileDescriptorProto::extension(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FileDescriptorProto.extension)
  return extension_.Get(index);
}
inline ::perfetto::protos::FieldDescriptorProto* FileDescriptorProto::mutable_extension(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.FileDescriptorProto.extension)
  return extension_.Mutable(index);
}
inline ::perfetto::protos::FieldDescriptorProto* FileDescriptorProto::add_extension() {
  // @@protoc_insertion_point(field_add:perfetto.protos.FileDescriptorProto.extension)
  return extension_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::FieldDescriptorProto >*
FileDescriptorProto::mutable_extension() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.FileDescriptorProto.extension)
  return &extension_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::FieldDescriptorProto >&
FileDescriptorProto::extension() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.FileDescriptorProto.extension)
  return extension_;
}

// -------------------------------------------------------------------

// DescriptorProto_ReservedRange

// optional int32 start = 1;
inline bool DescriptorProto_ReservedRange::has_start() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DescriptorProto_ReservedRange::set_has_start() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DescriptorProto_ReservedRange::clear_has_start() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DescriptorProto_ReservedRange::clear_start() {
  start_ = 0;
  clear_has_start();
}
inline ::google::protobuf::int32 DescriptorProto_ReservedRange::start() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DescriptorProto.ReservedRange.start)
  return start_;
}
inline void DescriptorProto_ReservedRange::set_start(::google::protobuf::int32 value) {
  set_has_start();
  start_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.DescriptorProto.ReservedRange.start)
}

// optional int32 end = 2;
inline bool DescriptorProto_ReservedRange::has_end() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DescriptorProto_ReservedRange::set_has_end() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DescriptorProto_ReservedRange::clear_has_end() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DescriptorProto_ReservedRange::clear_end() {
  end_ = 0;
  clear_has_end();
}
inline ::google::protobuf::int32 DescriptorProto_ReservedRange::end() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DescriptorProto.ReservedRange.end)
  return end_;
}
inline void DescriptorProto_ReservedRange::set_end(::google::protobuf::int32 value) {
  set_has_end();
  end_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.DescriptorProto.ReservedRange.end)
}

// -------------------------------------------------------------------

// DescriptorProto

// optional string name = 1;
inline bool DescriptorProto::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DescriptorProto::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DescriptorProto::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DescriptorProto::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& DescriptorProto::name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DescriptorProto.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DescriptorProto::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.DescriptorProto.name)
}
inline void DescriptorProto::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.DescriptorProto.name)
}
inline void DescriptorProto::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.DescriptorProto.name)
}
inline ::std::string* DescriptorProto::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DescriptorProto.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DescriptorProto::release_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DescriptorProto.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DescriptorProto::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DescriptorProto.name)
}

// repeated .perfetto.protos.FieldDescriptorProto field = 2;
inline int DescriptorProto::field_size() const {
  return field_.size();
}
inline void DescriptorProto::clear_field() {
  field_.Clear();
}
inline const ::perfetto::protos::FieldDescriptorProto& DescriptorProto::field(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DescriptorProto.field)
  return field_.Get(index);
}
inline ::perfetto::protos::FieldDescriptorProto* DescriptorProto::mutable_field(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DescriptorProto.field)
  return field_.Mutable(index);
}
inline ::perfetto::protos::FieldDescriptorProto* DescriptorProto::add_field() {
  // @@protoc_insertion_point(field_add:perfetto.protos.DescriptorProto.field)
  return field_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::FieldDescriptorProto >*
DescriptorProto::mutable_field() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.DescriptorProto.field)
  return &field_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::FieldDescriptorProto >&
DescriptorProto::field() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.DescriptorProto.field)
  return field_;
}

// repeated .perfetto.protos.FieldDescriptorProto extension = 6;
inline int DescriptorProto::extension_size() const {
  return extension_.size();
}
inline void DescriptorProto::clear_extension() {
  extension_.Clear();
}
inline const ::perfetto::protos::FieldDescriptorProto& DescriptorProto::extension(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DescriptorProto.extension)
  return extension_.Get(index);
}
inline ::perfetto::protos::FieldDescriptorProto* DescriptorProto::mutable_extension(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DescriptorProto.extension)
  return extension_.Mutable(index);
}
inline ::perfetto::protos::FieldDescriptorProto* DescriptorProto::add_extension() {
  // @@protoc_insertion_point(field_add:perfetto.protos.DescriptorProto.extension)
  return extension_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::FieldDescriptorProto >*
DescriptorProto::mutable_extension() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.DescriptorProto.extension)
  return &extension_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::FieldDescriptorProto >&
DescriptorProto::extension() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.DescriptorProto.extension)
  return extension_;
}

// repeated .perfetto.protos.DescriptorProto nested_type = 3;
inline int DescriptorProto::nested_type_size() const {
  return nested_type_.size();
}
inline void DescriptorProto::clear_nested_type() {
  nested_type_.Clear();
}
inline const ::perfetto::protos::DescriptorProto& DescriptorProto::nested_type(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DescriptorProto.nested_type)
  return nested_type_.Get(index);
}
inline ::perfetto::protos::DescriptorProto* DescriptorProto::mutable_nested_type(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DescriptorProto.nested_type)
  return nested_type_.Mutable(index);
}
inline ::perfetto::protos::DescriptorProto* DescriptorProto::add_nested_type() {
  // @@protoc_insertion_point(field_add:perfetto.protos.DescriptorProto.nested_type)
  return nested_type_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::DescriptorProto >*
DescriptorProto::mutable_nested_type() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.DescriptorProto.nested_type)
  return &nested_type_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::DescriptorProto >&
DescriptorProto::nested_type() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.DescriptorProto.nested_type)
  return nested_type_;
}

// repeated .perfetto.protos.EnumDescriptorProto enum_type = 4;
inline int DescriptorProto::enum_type_size() const {
  return enum_type_.size();
}
inline void DescriptorProto::clear_enum_type() {
  enum_type_.Clear();
}
inline const ::perfetto::protos::EnumDescriptorProto& DescriptorProto::enum_type(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DescriptorProto.enum_type)
  return enum_type_.Get(index);
}
inline ::perfetto::protos::EnumDescriptorProto* DescriptorProto::mutable_enum_type(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DescriptorProto.enum_type)
  return enum_type_.Mutable(index);
}
inline ::perfetto::protos::EnumDescriptorProto* DescriptorProto::add_enum_type() {
  // @@protoc_insertion_point(field_add:perfetto.protos.DescriptorProto.enum_type)
  return enum_type_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::EnumDescriptorProto >*
DescriptorProto::mutable_enum_type() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.DescriptorProto.enum_type)
  return &enum_type_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::EnumDescriptorProto >&
DescriptorProto::enum_type() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.DescriptorProto.enum_type)
  return enum_type_;
}

// repeated .perfetto.protos.OneofDescriptorProto oneof_decl = 8;
inline int DescriptorProto::oneof_decl_size() const {
  return oneof_decl_.size();
}
inline void DescriptorProto::clear_oneof_decl() {
  oneof_decl_.Clear();
}
inline const ::perfetto::protos::OneofDescriptorProto& DescriptorProto::oneof_decl(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DescriptorProto.oneof_decl)
  return oneof_decl_.Get(index);
}
inline ::perfetto::protos::OneofDescriptorProto* DescriptorProto::mutable_oneof_decl(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DescriptorProto.oneof_decl)
  return oneof_decl_.Mutable(index);
}
inline ::perfetto::protos::OneofDescriptorProto* DescriptorProto::add_oneof_decl() {
  // @@protoc_insertion_point(field_add:perfetto.protos.DescriptorProto.oneof_decl)
  return oneof_decl_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::OneofDescriptorProto >*
DescriptorProto::mutable_oneof_decl() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.DescriptorProto.oneof_decl)
  return &oneof_decl_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::OneofDescriptorProto >&
DescriptorProto::oneof_decl() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.DescriptorProto.oneof_decl)
  return oneof_decl_;
}

// repeated .perfetto.protos.DescriptorProto.ReservedRange reserved_range = 9;
inline int DescriptorProto::reserved_range_size() const {
  return reserved_range_.size();
}
inline void DescriptorProto::clear_reserved_range() {
  reserved_range_.Clear();
}
inline const ::perfetto::protos::DescriptorProto_ReservedRange& DescriptorProto::reserved_range(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DescriptorProto.reserved_range)
  return reserved_range_.Get(index);
}
inline ::perfetto::protos::DescriptorProto_ReservedRange* DescriptorProto::mutable_reserved_range(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DescriptorProto.reserved_range)
  return reserved_range_.Mutable(index);
}
inline ::perfetto::protos::DescriptorProto_ReservedRange* DescriptorProto::add_reserved_range() {
  // @@protoc_insertion_point(field_add:perfetto.protos.DescriptorProto.reserved_range)
  return reserved_range_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::DescriptorProto_ReservedRange >*
DescriptorProto::mutable_reserved_range() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.DescriptorProto.reserved_range)
  return &reserved_range_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::DescriptorProto_ReservedRange >&
DescriptorProto::reserved_range() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.DescriptorProto.reserved_range)
  return reserved_range_;
}

// repeated string reserved_name = 10;
inline int DescriptorProto::reserved_name_size() const {
  return reserved_name_.size();
}
inline void DescriptorProto::clear_reserved_name() {
  reserved_name_.Clear();
}
inline const ::std::string& DescriptorProto::reserved_name(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DescriptorProto.reserved_name)
  return reserved_name_.Get(index);
}
inline ::std::string* DescriptorProto::mutable_reserved_name(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DescriptorProto.reserved_name)
  return reserved_name_.Mutable(index);
}
inline void DescriptorProto::set_reserved_name(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.DescriptorProto.reserved_name)
  reserved_name_.Mutable(index)->assign(value);
}
inline void DescriptorProto::set_reserved_name(int index, const char* value) {
  reserved_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.DescriptorProto.reserved_name)
}
inline void DescriptorProto::set_reserved_name(int index, const char* value, size_t size) {
  reserved_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.DescriptorProto.reserved_name)
}
inline ::std::string* DescriptorProto::add_reserved_name() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.DescriptorProto.reserved_name)
  return reserved_name_.Add();
}
inline void DescriptorProto::add_reserved_name(const ::std::string& value) {
  reserved_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.DescriptorProto.reserved_name)
}
inline void DescriptorProto::add_reserved_name(const char* value) {
  reserved_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.DescriptorProto.reserved_name)
}
inline void DescriptorProto::add_reserved_name(const char* value, size_t size) {
  reserved_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.DescriptorProto.reserved_name)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DescriptorProto::reserved_name() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.DescriptorProto.reserved_name)
  return reserved_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DescriptorProto::mutable_reserved_name() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.DescriptorProto.reserved_name)
  return &reserved_name_;
}

// -------------------------------------------------------------------

// FieldDescriptorProto

// optional string name = 1;
inline bool FieldDescriptorProto::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FieldDescriptorProto::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FieldDescriptorProto::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FieldDescriptorProto::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& FieldDescriptorProto::name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FieldDescriptorProto.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FieldDescriptorProto::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.FieldDescriptorProto.name)
}
inline void FieldDescriptorProto::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.FieldDescriptorProto.name)
}
inline void FieldDescriptorProto::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.FieldDescriptorProto.name)
}
inline ::std::string* FieldDescriptorProto::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.FieldDescriptorProto.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FieldDescriptorProto::release_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.FieldDescriptorProto.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FieldDescriptorProto::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.FieldDescriptorProto.name)
}

// optional int32 number = 3;
inline bool FieldDescriptorProto::has_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FieldDescriptorProto::set_has_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FieldDescriptorProto::clear_has_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FieldDescriptorProto::clear_number() {
  number_ = 0;
  clear_has_number();
}
inline ::google::protobuf::int32 FieldDescriptorProto::number() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FieldDescriptorProto.number)
  return number_;
}
inline void FieldDescriptorProto::set_number(::google::protobuf::int32 value) {
  set_has_number();
  number_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.FieldDescriptorProto.number)
}

// optional .perfetto.protos.FieldDescriptorProto.Label label = 4;
inline bool FieldDescriptorProto::has_label() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FieldDescriptorProto::set_has_label() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FieldDescriptorProto::clear_has_label() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FieldDescriptorProto::clear_label() {
  label_ = 1;
  clear_has_label();
}
inline ::perfetto::protos::FieldDescriptorProto_Label FieldDescriptorProto::label() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FieldDescriptorProto.label)
  return static_cast< ::perfetto::protos::FieldDescriptorProto_Label >(label_);
}
inline void FieldDescriptorProto::set_label(::perfetto::protos::FieldDescriptorProto_Label value) {
  assert(::perfetto::protos::FieldDescriptorProto_Label_IsValid(value));
  set_has_label();
  label_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.FieldDescriptorProto.label)
}

// optional .perfetto.protos.FieldDescriptorProto.Type type = 5;
inline bool FieldDescriptorProto::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FieldDescriptorProto::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FieldDescriptorProto::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FieldDescriptorProto::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::perfetto::protos::FieldDescriptorProto_Type FieldDescriptorProto::type() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FieldDescriptorProto.type)
  return static_cast< ::perfetto::protos::FieldDescriptorProto_Type >(type_);
}
inline void FieldDescriptorProto::set_type(::perfetto::protos::FieldDescriptorProto_Type value) {
  assert(::perfetto::protos::FieldDescriptorProto_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.FieldDescriptorProto.type)
}

// optional string type_name = 6;
inline bool FieldDescriptorProto::has_type_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FieldDescriptorProto::set_has_type_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FieldDescriptorProto::clear_has_type_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FieldDescriptorProto::clear_type_name() {
  type_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type_name();
}
inline const ::std::string& FieldDescriptorProto::type_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FieldDescriptorProto.type_name)
  return type_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FieldDescriptorProto::set_type_name(const ::std::string& value) {
  set_has_type_name();
  type_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.FieldDescriptorProto.type_name)
}
inline void FieldDescriptorProto::set_type_name(const char* value) {
  set_has_type_name();
  type_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.FieldDescriptorProto.type_name)
}
inline void FieldDescriptorProto::set_type_name(const char* value, size_t size) {
  set_has_type_name();
  type_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.FieldDescriptorProto.type_name)
}
inline ::std::string* FieldDescriptorProto::mutable_type_name() {
  set_has_type_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.FieldDescriptorProto.type_name)
  return type_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FieldDescriptorProto::release_type_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.FieldDescriptorProto.type_name)
  clear_has_type_name();
  return type_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FieldDescriptorProto::set_allocated_type_name(::std::string* type_name) {
  if (type_name != NULL) {
    set_has_type_name();
  } else {
    clear_has_type_name();
  }
  type_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type_name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.FieldDescriptorProto.type_name)
}

// optional string extendee = 2;
inline bool FieldDescriptorProto::has_extendee() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FieldDescriptorProto::set_has_extendee() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FieldDescriptorProto::clear_has_extendee() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FieldDescriptorProto::clear_extendee() {
  extendee_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_extendee();
}
inline const ::std::string& FieldDescriptorProto::extendee() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FieldDescriptorProto.extendee)
  return extendee_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FieldDescriptorProto::set_extendee(const ::std::string& value) {
  set_has_extendee();
  extendee_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.FieldDescriptorProto.extendee)
}
inline void FieldDescriptorProto::set_extendee(const char* value) {
  set_has_extendee();
  extendee_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.FieldDescriptorProto.extendee)
}
inline void FieldDescriptorProto::set_extendee(const char* value, size_t size) {
  set_has_extendee();
  extendee_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.FieldDescriptorProto.extendee)
}
inline ::std::string* FieldDescriptorProto::mutable_extendee() {
  set_has_extendee();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.FieldDescriptorProto.extendee)
  return extendee_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FieldDescriptorProto::release_extendee() {
  // @@protoc_insertion_point(field_release:perfetto.protos.FieldDescriptorProto.extendee)
  clear_has_extendee();
  return extendee_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FieldDescriptorProto::set_allocated_extendee(::std::string* extendee) {
  if (extendee != NULL) {
    set_has_extendee();
  } else {
    clear_has_extendee();
  }
  extendee_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), extendee);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.FieldDescriptorProto.extendee)
}

// optional string default_value = 7;
inline bool FieldDescriptorProto::has_default_value() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FieldDescriptorProto::set_has_default_value() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FieldDescriptorProto::clear_has_default_value() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FieldDescriptorProto::clear_default_value() {
  default_value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_default_value();
}
inline const ::std::string& FieldDescriptorProto::default_value() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FieldDescriptorProto.default_value)
  return default_value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FieldDescriptorProto::set_default_value(const ::std::string& value) {
  set_has_default_value();
  default_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.FieldDescriptorProto.default_value)
}
inline void FieldDescriptorProto::set_default_value(const char* value) {
  set_has_default_value();
  default_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.FieldDescriptorProto.default_value)
}
inline void FieldDescriptorProto::set_default_value(const char* value, size_t size) {
  set_has_default_value();
  default_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.FieldDescriptorProto.default_value)
}
inline ::std::string* FieldDescriptorProto::mutable_default_value() {
  set_has_default_value();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.FieldDescriptorProto.default_value)
  return default_value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FieldDescriptorProto::release_default_value() {
  // @@protoc_insertion_point(field_release:perfetto.protos.FieldDescriptorProto.default_value)
  clear_has_default_value();
  return default_value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FieldDescriptorProto::set_allocated_default_value(::std::string* default_value) {
  if (default_value != NULL) {
    set_has_default_value();
  } else {
    clear_has_default_value();
  }
  default_value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), default_value);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.FieldDescriptorProto.default_value)
}

// optional int32 oneof_index = 9;
inline bool FieldDescriptorProto::has_oneof_index() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FieldDescriptorProto::set_has_oneof_index() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FieldDescriptorProto::clear_has_oneof_index() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FieldDescriptorProto::clear_oneof_index() {
  oneof_index_ = 0;
  clear_has_oneof_index();
}
inline ::google::protobuf::int32 FieldDescriptorProto::oneof_index() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FieldDescriptorProto.oneof_index)
  return oneof_index_;
}
inline void FieldDescriptorProto::set_oneof_index(::google::protobuf::int32 value) {
  set_has_oneof_index();
  oneof_index_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.FieldDescriptorProto.oneof_index)
}

// -------------------------------------------------------------------

// OneofDescriptorProto

// optional string name = 1;
inline bool OneofDescriptorProto::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OneofDescriptorProto::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OneofDescriptorProto::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OneofDescriptorProto::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& OneofDescriptorProto::name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.OneofDescriptorProto.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OneofDescriptorProto::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.OneofDescriptorProto.name)
}
inline void OneofDescriptorProto::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.OneofDescriptorProto.name)
}
inline void OneofDescriptorProto::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.OneofDescriptorProto.name)
}
inline ::std::string* OneofDescriptorProto::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.OneofDescriptorProto.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OneofDescriptorProto::release_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.OneofDescriptorProto.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OneofDescriptorProto::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.OneofDescriptorProto.name)
}

// optional .perfetto.protos.OneofOptions options = 2;
inline bool OneofDescriptorProto::has_options() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OneofDescriptorProto::set_has_options() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OneofDescriptorProto::clear_has_options() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OneofDescriptorProto::clear_options() {
  if (options_ != NULL) options_->::perfetto::protos::OneofOptions::Clear();
  clear_has_options();
}
inline const ::perfetto::protos::OneofOptions& OneofDescriptorProto::options() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.OneofDescriptorProto.options)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return options_ != NULL ? *options_ : *default_instance().options_;
#else
  return options_ != NULL ? *options_ : *default_instance_->options_;
#endif
}
inline ::perfetto::protos::OneofOptions* OneofDescriptorProto::mutable_options() {
  set_has_options();
  if (options_ == NULL) {
    options_ = new ::perfetto::protos::OneofOptions;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.OneofDescriptorProto.options)
  return options_;
}
inline ::perfetto::protos::OneofOptions* OneofDescriptorProto::release_options() {
  // @@protoc_insertion_point(field_release:perfetto.protos.OneofDescriptorProto.options)
  clear_has_options();
  ::perfetto::protos::OneofOptions* temp = options_;
  options_ = NULL;
  return temp;
}
inline void OneofDescriptorProto::set_allocated_options(::perfetto::protos::OneofOptions* options) {
  delete options_;
  options_ = options;
  if (options) {
    set_has_options();
  } else {
    clear_has_options();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.OneofDescriptorProto.options)
}

// -------------------------------------------------------------------

// EnumDescriptorProto

// optional string name = 1;
inline bool EnumDescriptorProto::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnumDescriptorProto::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnumDescriptorProto::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnumDescriptorProto::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& EnumDescriptorProto::name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.EnumDescriptorProto.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EnumDescriptorProto::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.EnumDescriptorProto.name)
}
inline void EnumDescriptorProto::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.EnumDescriptorProto.name)
}
inline void EnumDescriptorProto::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.EnumDescriptorProto.name)
}
inline ::std::string* EnumDescriptorProto::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.EnumDescriptorProto.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EnumDescriptorProto::release_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.EnumDescriptorProto.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EnumDescriptorProto::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.EnumDescriptorProto.name)
}

// repeated .perfetto.protos.EnumValueDescriptorProto value = 2;
inline int EnumDescriptorProto::value_size() const {
  return value_.size();
}
inline void EnumDescriptorProto::clear_value() {
  value_.Clear();
}
inline const ::perfetto::protos::EnumValueDescriptorProto& EnumDescriptorProto::value(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.EnumDescriptorProto.value)
  return value_.Get(index);
}
inline ::perfetto::protos::EnumValueDescriptorProto* EnumDescriptorProto::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.EnumDescriptorProto.value)
  return value_.Mutable(index);
}
inline ::perfetto::protos::EnumValueDescriptorProto* EnumDescriptorProto::add_value() {
  // @@protoc_insertion_point(field_add:perfetto.protos.EnumDescriptorProto.value)
  return value_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::EnumValueDescriptorProto >*
EnumDescriptorProto::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.EnumDescriptorProto.value)
  return &value_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::EnumValueDescriptorProto >&
EnumDescriptorProto::value() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.EnumDescriptorProto.value)
  return value_;
}

// repeated string reserved_name = 5;
inline int EnumDescriptorProto::reserved_name_size() const {
  return reserved_name_.size();
}
inline void EnumDescriptorProto::clear_reserved_name() {
  reserved_name_.Clear();
}
inline const ::std::string& EnumDescriptorProto::reserved_name(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.EnumDescriptorProto.reserved_name)
  return reserved_name_.Get(index);
}
inline ::std::string* EnumDescriptorProto::mutable_reserved_name(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.EnumDescriptorProto.reserved_name)
  return reserved_name_.Mutable(index);
}
inline void EnumDescriptorProto::set_reserved_name(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.EnumDescriptorProto.reserved_name)
  reserved_name_.Mutable(index)->assign(value);
}
inline void EnumDescriptorProto::set_reserved_name(int index, const char* value) {
  reserved_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.EnumDescriptorProto.reserved_name)
}
inline void EnumDescriptorProto::set_reserved_name(int index, const char* value, size_t size) {
  reserved_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.EnumDescriptorProto.reserved_name)
}
inline ::std::string* EnumDescriptorProto::add_reserved_name() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.EnumDescriptorProto.reserved_name)
  return reserved_name_.Add();
}
inline void EnumDescriptorProto::add_reserved_name(const ::std::string& value) {
  reserved_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.EnumDescriptorProto.reserved_name)
}
inline void EnumDescriptorProto::add_reserved_name(const char* value) {
  reserved_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.EnumDescriptorProto.reserved_name)
}
inline void EnumDescriptorProto::add_reserved_name(const char* value, size_t size) {
  reserved_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.EnumDescriptorProto.reserved_name)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
EnumDescriptorProto::reserved_name() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.EnumDescriptorProto.reserved_name)
  return reserved_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
EnumDescriptorProto::mutable_reserved_name() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.EnumDescriptorProto.reserved_name)
  return &reserved_name_;
}

// -------------------------------------------------------------------

// EnumValueDescriptorProto

// optional string name = 1;
inline bool EnumValueDescriptorProto::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnumValueDescriptorProto::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnumValueDescriptorProto::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnumValueDescriptorProto::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& EnumValueDescriptorProto::name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.EnumValueDescriptorProto.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EnumValueDescriptorProto::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.EnumValueDescriptorProto.name)
}
inline void EnumValueDescriptorProto::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.EnumValueDescriptorProto.name)
}
inline void EnumValueDescriptorProto::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.EnumValueDescriptorProto.name)
}
inline ::std::string* EnumValueDescriptorProto::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.EnumValueDescriptorProto.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EnumValueDescriptorProto::release_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.EnumValueDescriptorProto.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EnumValueDescriptorProto::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.EnumValueDescriptorProto.name)
}

// optional int32 number = 2;
inline bool EnumValueDescriptorProto::has_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnumValueDescriptorProto::set_has_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnumValueDescriptorProto::clear_has_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnumValueDescriptorProto::clear_number() {
  number_ = 0;
  clear_has_number();
}
inline ::google::protobuf::int32 EnumValueDescriptorProto::number() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.EnumValueDescriptorProto.number)
  return number_;
}
inline void EnumValueDescriptorProto::set_number(::google::protobuf::int32 value) {
  set_has_number();
  number_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.EnumValueDescriptorProto.number)
}

// -------------------------------------------------------------------

// OneofOptions

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::perfetto::protos::FieldDescriptorProto_Type> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::perfetto::protos::FieldDescriptorProto_Label> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2fcommon_2fdescriptor_2eproto__INCLUDED
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/common/gpu_counter_descriptor.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/common/gpu_counter_descriptor.proto

#ifndef PROTOBUF_protos_2fperfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto();

class GpuCounterDescriptor;
class GpuCounterDescriptor_GpuCounterBlock;
class GpuCounterDescriptor_GpuCounterSpec;

enum GpuCounterDescriptor_MeasureUnit {
  GpuCounterDescriptor_MeasureUnit_NONE = 0,
  GpuCounterDescriptor_MeasureUnit_BIT = 1,
  GpuCounterDescriptor_MeasureUnit_KILOBIT = 2,
  GpuCounterDescriptor_MeasureUnit_MEGABIT = 3,
  GpuCounterDescriptor_MeasureUnit_GIGABIT = 4,
  GpuCounterDescriptor_MeasureUnit_TERABIT = 5,
  GpuCounterDescriptor_MeasureUnit_PETABIT = 6,
  GpuCounterDescriptor_MeasureUnit_BYTE = 7,
  GpuCounterDescriptor_MeasureUnit_KILOBYTE = 8,
  GpuCounterDescriptor_MeasureUnit_MEGABYTE = 9,
  GpuCounterDescriptor_MeasureUnit_GIGABYTE = 10,
  GpuCounterDescriptor_MeasureUnit_TERABYTE = 11,
  GpuCounterDescriptor_MeasureUnit_PETABYTE = 12,
  GpuCounterDescriptor_MeasureUnit_HERTZ = 13,
  GpuCounterDescriptor_MeasureUnit_KILOHERTZ = 14,
  GpuCounterDescriptor_MeasureUnit_MEGAHERTZ = 15,
  GpuCounterDescriptor_MeasureUnit_GIGAHERTZ = 16,
  GpuCounterDescriptor_MeasureUnit_TERAHERTZ = 17,
  GpuCounterDescriptor_MeasureUnit_PETAHERTZ = 18,
  GpuCounterDescriptor_MeasureUnit_NANOSECOND = 19,
  GpuCounterDescriptor_MeasureUnit_MICROSECOND = 20,
  GpuCounterDescriptor_MeasureUnit_MILLISECOND = 21,
  GpuCounterDescriptor_MeasureUnit_SECOND = 22,
  GpuCounterDescriptor_MeasureUnit_MINUTE = 23,
  GpuCounterDescriptor_MeasureUnit_HOUR = 24,
  GpuCounterDescriptor_MeasureUnit_VERTEX = 25,
  GpuCounterDescriptor_MeasureUnit_PIXEL = 26,
  GpuCounterDescriptor_MeasureUnit_TRIANGLE = 27,
  GpuCounterDescriptor_MeasureUnit_MILLIWATT = 28,
  GpuCounterDescriptor_MeasureUnit_WATT = 29,
  GpuCounterDescriptor_MeasureUnit_KILOWATT = 30,
  GpuCounterDescriptor_MeasureUnit_JOULE = 31,
  GpuCounterDescriptor_MeasureUnit_VOLT = 32,
  GpuCounterDescriptor_MeasureUnit_AMPERE = 33,
  GpuCounterDescriptor_MeasureUnit_CELSIUS = 34,
  GpuCounterDescriptor_MeasureUnit_FAHRENHEIT = 35,
  GpuCounterDescriptor_MeasureUnit_KELVIN = 36,
  GpuCounterDescriptor_MeasureUnit_PERCENT = 37
};
bool GpuCounterDescriptor_MeasureUnit_IsValid(int value);
const GpuCounterDescriptor_MeasureUnit GpuCounterDescriptor_MeasureUnit_MeasureUnit_MIN = GpuCounterDescriptor_MeasureUnit_NONE;
const GpuCounterDescriptor_MeasureUnit GpuCounterDescriptor_MeasureUnit_MeasureUnit_MAX = GpuCounterDescriptor_MeasureUnit_PERCENT;
const int GpuCounterDescriptor_MeasureUnit_MeasureUnit_ARRAYSIZE = GpuCounterDescriptor_MeasureUnit_MeasureUnit_MAX + 1;

// ===================================================================

class GpuCounterDescriptor_GpuCounterSpec : public ::google::protobuf::MessageLite {
 public:
  GpuCounterDescriptor_GpuCounterSpec();
  virtual ~GpuCounterDescriptor_GpuCounterSpec();

  GpuCounterDescriptor_GpuCounterSpec(const GpuCounterDescriptor_GpuCounterSpec& from);

  inline GpuCounterDescriptor_GpuCounterSpec& operator=(const GpuCounterDescriptor_GpuCounterSpec& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const GpuCounterDescriptor_GpuCounterSpec& default_instance();

  enum PeakValueCase {
    kIntPeakValue = 5,
    kDoublePeakValue = 6,
    PEAK_VALUE_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GpuCounterDescriptor_GpuCounterSpec* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GpuCounterDescriptor_GpuCounterSpec* other);

  // implements Message ----------------------------------------------

  inline GpuCounterDescriptor_GpuCounterSpec* New() const { return New(NULL); }

  GpuCounterDescriptor_GpuCounterSpec* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GpuCounterDescriptor_GpuCounterSpec& from);
  void MergeFrom(const GpuCounterDescriptor_GpuCounterSpec& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GpuCounterDescriptor_GpuCounterSpec* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 counter_id = 1;
  bool has_counter_id() const;
  void clear_counter_id();
  static const int kCounterIdFieldNumber = 1;
  ::google::protobuf::uint32 counter_id() const;
  void set_counter_id(::google::protobuf::uint32 value);

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string description = 3;
  bool has_description() const;
  void clear_description();
  static const int kDescriptionFieldNumber = 3;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // optional int64 int_peak_value = 5;
  bool has_int_peak_value() const;
  void clear_int_peak_value();
  static const int kIntPeakValueFieldNumber = 5;
  ::google::protobuf::int64 int_peak_value() const;
  void set_int_peak_value(::google::protobuf::int64 value);

  // optional double double_peak_value = 6;
  bool has_double_peak_value() const;
  void clear_double_peak_value();
  static const int kDoublePeakValueFieldNumber = 6;
  double double_peak_value() const;
  void set_double_peak_value(double value);

  // repeated .perfetto.protos.GpuCounterDescriptor.MeasureUnit numerator_units = 7;
  int numerator_units_size() const;
  void clear_numerator_units();
  static const int kNumeratorUnitsFieldNumber = 7;
  ::perfetto::protos::GpuCounterDescriptor_MeasureUnit numerator_units(int index) const;
  void set_numerator_units(int index, ::perfetto::protos::GpuCounterDescriptor_MeasureUnit value);
  void add_numerator_units(::perfetto::protos::GpuCounterDescriptor_MeasureUnit value);
  const ::google::protobuf::RepeatedField<int>& numerator_units() const;
  ::google::protobuf::RepeatedField<int>* mutable_numerator_units();

  // repeated .perfetto.protos.GpuCounterDescriptor.MeasureUnit denominator_units = 8;
  int denominator_units_size() const;
  void clear_denominator_units();
  static const int kDenominatorUnitsFieldNumber = 8;
  ::perfetto::protos::GpuCounterDescriptor_MeasureUnit denominator_units(int index) const;
  void set_denominator_units(int index, ::perfetto::protos::GpuCounterDescriptor_MeasureUnit value);
  void add_denominator_units(::perfetto::protos::GpuCounterDescriptor_MeasureUnit value);
  const ::google::protobuf::RepeatedField<int>& denominator_units() const;
  ::google::protobuf::RepeatedField<int>* mutable_denominator_units();

  // optional bool select_by_default = 9;
  bool has_select_by_default() const;
  void clear_select_by_default();
  static const int kSelectByDefaultFieldNumber = 9;
  bool select_by_default() const;
  void set_select_by_default(bool value);

  PeakValueCase peak_value_case() const;
  // @@protoc_insertion_point(class_scope:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec)
 private:
  inline void set_has_counter_id();
  inline void clear_has_counter_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_int_peak_value();
  inline void set_has_double_peak_value();
  inline void set_has_select_by_default();
  inline void clear_has_select_by_default();

  inline bool has_peak_value() const;
  void clear_peak_value();
  inline void clear_has_peak_value();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::uint32 counter_id_;
  bool select_by_default_;
  ::google::protobuf::RepeatedField<int> numerator_units_;
  ::google::protobuf::RepeatedField<int> denominator_units_;
  union PeakValueUnion {
    PeakValueUnion() {}
    ::google::protobuf::int64 int_peak_value_;
    double double_peak_value_;
  } peak_value_;
  ::google::protobuf::uint32 _oneof_case_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto();

  void InitAsDefaultInstance();
  static GpuCounterDescriptor_GpuCounterSpec* default_instance_;
};
// -------------------------------------------------------------------

class GpuCounterDescriptor_GpuCounterBlock : public ::google::protobuf::MessageLite {
 public:
  GpuCounterDescriptor_GpuCounterBlock();
  virtual ~GpuCounterDescriptor_GpuCounterBlock();

  GpuCounterDescriptor_GpuCounterBlock(const GpuCounterDescriptor_GpuCounterBlock& from);

  inline GpuCounterDescriptor_GpuCounterBlock& operator=(const GpuCounterDescriptor_GpuCounterBlock& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const GpuCounterDescriptor_GpuCounterBlock& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GpuCounterDescriptor_GpuCounterBlock* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GpuCounterDescriptor_GpuCounterBlock* other);

  // implements Message ----------------------------------------------

  inline GpuCounterDescriptor_GpuCounterBlock* New() const { return New(NULL); }

  GpuCounterDescriptor_GpuCounterBlock* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GpuCounterDescriptor_GpuCounterBlock& from);
  void MergeFrom(const GpuCounterDescriptor_GpuCounterBlock& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GpuCounterDescriptor_GpuCounterBlock* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 block_id = 1;
  bool has_block_id() const;
  void clear_block_id();
  static const int kBlockIdFieldNumber = 1;
  ::google::protobuf::uint32 block_id() const;
  void set_block_id(::google::protobuf::uint32 value);

  // optional uint32 block_capacity = 2;
  bool has_block_capacity() const;
  void clear_block_capacity();
  static const int kBlockCapacityFieldNumber = 2;
  ::google::protobuf::uint32 block_capacity() const;
  void set_block_capacity(::google::protobuf::uint32 value);

  // optional string name = 3;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string description = 4;
  bool has_description() const;
  void clear_description();
  static const int kDescriptionFieldNumber = 4;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // repeated uint32 counter_ids = 5;
  int counter_ids_size() const;
  void clear_counter_ids();
  static const int kCounterIdsFieldNumber = 5;
  ::google::protobuf::uint32 counter_ids(int index) const;
  void set_counter_ids(int index, ::google::protobuf::uint32 value);
  void add_counter_ids(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      counter_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_counter_ids();

  // @@protoc_insertion_point(class_scope:perfetto.protos.GpuCounterDescriptor.GpuCounterBlock)
 private:
  inline void set_has_block_id();
  inline void clear_has_block_id();
  inline void set_has_block_capacity();
  inline void clear_has_block_capacity();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_description();
  inline void clear_has_description();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 block_id_;
  ::google::protobuf::uint32 block_capacity_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > counter_ids_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto();

  void InitAsDefaultInstance();
  static GpuCounterDescriptor_GpuCounterBlock* default_instance_;
};
// -------------------------------------------------------------------

class GpuCounterDescriptor : public ::google::protobuf::MessageLite {
 public:
  GpuCounterDescriptor();
  virtual ~GpuCounterDescriptor();

  GpuCounterDescriptor(const GpuCounterDescriptor& from);

  inline GpuCounterDescriptor& operator=(const GpuCounterDescriptor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const GpuCounterDescriptor& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GpuCounterDescriptor* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GpuCounterDescriptor* other);

  // implements Message ----------------------------------------------

  inline GpuCounterDescriptor* New() const { return New(NULL); }

  GpuCounterDescriptor* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GpuCounterDescriptor& from);
  void MergeFrom(const GpuCounterDescriptor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GpuCounterDescriptor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef GpuCounterDescriptor_GpuCounterSpec GpuCounterSpec;
  typedef GpuCounterDescriptor_GpuCounterBlock GpuCounterBlock;

  typedef GpuCounterDescriptor_MeasureUnit MeasureUnit;
  static const MeasureUnit NONE =
    GpuCounterDescriptor_MeasureUnit_NONE;
  static const MeasureUnit BIT =
    GpuCounterDescriptor_MeasureUnit_BIT;
  static const MeasureUnit KILOBIT =
    GpuCounterDescriptor_MeasureUnit_KILOBIT;
  static const MeasureUnit MEGABIT =
    GpuCounterDescriptor_MeasureUnit_MEGABIT;
  static const MeasureUnit GIGABIT =
    GpuCounterDescriptor_MeasureUnit_GIGABIT;
  static const MeasureUnit TERABIT =
    GpuCounterDescriptor_MeasureUnit_TERABIT;
  static const MeasureUnit PETABIT =
    GpuCounterDescriptor_MeasureUnit_PETABIT;
  static const MeasureUnit BYTE =
    GpuCounterDescriptor_MeasureUnit_BYTE;
  static const MeasureUnit KILOBYTE =
    GpuCounterDescriptor_MeasureUnit_KILOBYTE;
  static const MeasureUnit MEGABYTE =
    GpuCounterDescriptor_MeasureUnit_MEGABYTE;
  static const MeasureUnit GIGABYTE =
    GpuCounterDescriptor_MeasureUnit_GIGABYTE;
  static const MeasureUnit TERABYTE =
    GpuCounterDescriptor_MeasureUnit_TERABYTE;
  static const MeasureUnit PETABYTE =
    GpuCounterDescriptor_MeasureUnit_PETABYTE;
  static const MeasureUnit HERTZ =
    GpuCounterDescriptor_MeasureUnit_HERTZ;
  static const MeasureUnit KILOHERTZ =
    GpuCounterDescriptor_MeasureUnit_KILOHERTZ;
  static const MeasureUnit MEGAHERTZ =
    GpuCounterDescriptor_MeasureUnit_MEGAHERTZ;
  static const MeasureUnit GIGAHERTZ =
    GpuCounterDescriptor_MeasureUnit_GIGAHERTZ;
  static const MeasureUnit TERAHERTZ =
    GpuCounterDescriptor_MeasureUnit_TERAHERTZ;
  static const MeasureUnit PETAHERTZ =
    GpuCounterDescriptor_MeasureUnit_PETAHERTZ;
  static const MeasureUnit NANOSECOND =
    GpuCounterDescriptor_MeasureUnit_NANOSECOND;
  static const MeasureUnit MICROSECOND =
    GpuCounterDescriptor_MeasureUnit_MICROSECOND;
  static const MeasureUnit MILLISECOND =
    GpuCounterDescriptor_MeasureUnit_MILLISECOND;
  static const MeasureUnit SECOND =
    GpuCounterDescriptor_MeasureUnit_SECOND;
  static const MeasureUnit MINUTE =
    GpuCounterDescriptor_MeasureUnit_MINUTE;
  static const MeasureUnit HOUR =
    GpuCounterDescriptor_MeasureUnit_HOUR;
  static const MeasureUnit VERTEX =
    GpuCounterDescriptor_MeasureUnit_VERTEX;
  static const MeasureUnit PIXEL =
    GpuCounterDescriptor_MeasureUnit_PIXEL;
  static const MeasureUnit TRIANGLE =
    GpuCounterDescriptor_MeasureUnit_TRIANGLE;
  static const MeasureUnit MILLIWATT =
    GpuCounterDescriptor_MeasureUnit_MILLIWATT;
  static const MeasureUnit WATT =
    GpuCounterDescriptor_MeasureUnit_WATT;
  static const MeasureUnit KILOWATT =
    GpuCounterDescriptor_MeasureUnit_KILOWATT;
  static const MeasureUnit JOULE =
    GpuCounterDescriptor_MeasureUnit_JOULE;
  static const MeasureUnit VOLT =
    GpuCounterDescriptor_MeasureUnit_VOLT;
  static const MeasureUnit AMPERE =
    GpuCounterDescriptor_MeasureUnit_AMPERE;
  static const MeasureUnit CELSIUS =
    GpuCounterDescriptor_MeasureUnit_CELSIUS;
  static const MeasureUnit FAHRENHEIT =
    GpuCounterDescriptor_MeasureUnit_FAHRENHEIT;
  static const MeasureUnit KELVIN =
    GpuCounterDescriptor_MeasureUnit_KELVIN;
  static const MeasureUnit PERCENT =
    GpuCounterDescriptor_MeasureUnit_PERCENT;
  static inline bool MeasureUnit_IsValid(int value) {
    return GpuCounterDescriptor_MeasureUnit_IsValid(value);
  }
  static const MeasureUnit MeasureUnit_MIN =
    GpuCounterDescriptor_MeasureUnit_MeasureUnit_MIN;
  static const MeasureUnit MeasureUnit_MAX =
    GpuCounterDescriptor_MeasureUnit_MeasureUnit_MAX;
  static const int MeasureUnit_ARRAYSIZE =
    GpuCounterDescriptor_MeasureUnit_MeasureUnit_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .perfetto.protos.GpuCounterDescriptor.GpuCounterSpec specs = 1;
  int specs_size() const;
  void clear_specs();
  static const int kSpecsFieldNumber = 1;
  const ::perfetto::protos::GpuCounterDescriptor_GpuCounterSpec& specs(int index) const;
  ::perfetto::protos::GpuCounterDescriptor_GpuCounterSpec* mutable_specs(int index);
  ::perfetto::protos::GpuCounterDescriptor_GpuCounterSpec* add_specs();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::GpuCounterDescriptor_GpuCounterSpec >*
      mutable_specs();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::GpuCounterDescriptor_GpuCounterSpec >&
      specs() const;

  // repeated .perfetto.protos.GpuCounterDescriptor.GpuCounterBlock blocks = 2;
  int blocks_size() const;
  void clear_blocks();
  static const int kBlocksFieldNumber = 2;
  const ::perfetto::protos::GpuCounterDescriptor_GpuCounterBlock& blocks(int index) const;
  ::perfetto::protos::GpuCounterDescriptor_GpuCounterBlock* mutable_blocks(int index);
  ::perfetto::protos::GpuCounterDescriptor_GpuCounterBlock* add_blocks();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::GpuCounterDescriptor_GpuCounterBlock >*
      mutable_blocks();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::GpuCounterDescriptor_GpuCounterBlock >&
      blocks() const;

  // optional uint64 min_sampling_period_ns = 3;
  bool has_min_sampling_period_ns() const;
  void clear_min_sampling_period_ns();
  static const int kMinSamplingPeriodNsFieldNumber = 3;
  ::google::protobuf::uint64 min_sampling_period_ns() const;
  void set_min_sampling_period_ns(::google::protobuf::uint64 value);

  // optional uint64 max_sampling_period_ns = 4;
  bool has_max_sampling_period_ns() const;
  void clear_max_sampling_period_ns();
  static const int kMaxSamplingPeriodNsFieldNumber = 4;
  ::google::protobuf::uint64 max_sampling_period_ns() const;
  void set_max_sampling_period_ns(::google::protobuf::uint64 value);

  // optional bool supports_instrumented_sampling = 5;
  bool has_supports_instrumented_sampling() const;
  void clear_supports_instrumented_sampling();
  static const int kSupportsInstrumentedSamplingFieldNumber = 5;
  bool supports_instrumented_sampling() const;
  void set_supports_instrumented_sampling(bool value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.GpuCounterDescriptor)
 private:
  inline void set_has_min_sampling_period_ns();
  inline void clear_has_min_sampling_period_ns();
  inline void set_has_max_sampling_period_ns();
  inline void clear_has_max_sampling_period_ns();
  inline void set_has_supports_instrumented_sampling();
  inline void clear_has_supports_instrumented_sampling();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::GpuCounterDescriptor_GpuCounterSpec > specs_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::GpuCounterDescriptor_GpuCounterBlock > blocks_;
  ::google::protobuf::uint64 min_sampling_period_ns_;
  ::google::protobuf::uint64 max_sampling_period_ns_;
  bool supports_instrumented_sampling_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto();

  void InitAsDefaultInstance();
  static GpuCounterDescriptor* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// GpuCounterDescriptor_GpuCounterSpec

// optional uint32 counter_id = 1;
inline bool GpuCounterDescriptor_GpuCounterSpec::has_counter_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GpuCounterDescriptor_GpuCounterSpec::set_has_counter_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GpuCounterDescriptor_GpuCounterSpec::clear_has_counter_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GpuCounterDescriptor_GpuCounterSpec::clear_counter_id() {
  counter_id_ = 0u;
  clear_has_counter_id();
}
inline ::google::protobuf::uint32 GpuCounterDescriptor_GpuCounterSpec::counter_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.counter_id)
  return counter_id_;
}
inline void GpuCounterDescriptor_GpuCounterSpec::set_counter_id(::google::protobuf::uint32 value) {
  set_has_counter_id();
  counter_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.counter_id)
}

// optional string name = 2;
inline bool GpuCounterDescriptor_GpuCounterSpec::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GpuCounterDescriptor_GpuCounterSpec::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GpuCounterDescriptor_GpuCounterSpec::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GpuCounterDescriptor_GpuCounterSpec::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& GpuCounterDescriptor_GpuCounterSpec::name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GpuCounterDescriptor_GpuCounterSpec::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.name)
}
inline void GpuCounterDescriptor_GpuCounterSpec::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.name)
}
inline void GpuCounterDescriptor_GpuCounterSpec::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.name)
}
inline ::std::string* GpuCounterDescriptor_GpuCounterSpec::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GpuCounterDescriptor_GpuCounterSpec::release_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GpuCounterDescriptor_GpuCounterSpec::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.name)
}

// optional string description = 3;
inline bool GpuCounterDescriptor_GpuCounterSpec::has_description() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GpuCounterDescriptor_GpuCounterSpec::set_has_description() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GpuCounterDescriptor_GpuCounterSpec::clear_has_description() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GpuCounterDescriptor_GpuCounterSpec::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_description();
}
inline const ::std::string& GpuCounterDescriptor_GpuCounterSpec::description() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.description)
  return description_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GpuCounterDescriptor_GpuCounterSpec::set_description(const ::std::string& value) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.description)
}
inline void GpuCounterDescriptor_GpuCounterSpec::set_description(const char* value) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.description)
}
inline void GpuCounterDescriptor_GpuCounterSpec::set_description(const char* value, size_t size) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.description)
}
inline ::std::string* GpuCounterDescriptor_GpuCounterSpec::mutable_description() {
  set_has_description();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GpuCounterDescriptor_GpuCounterSpec::release_description() {
  // @@protoc_insertion_point(field_release:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.description)
  clear_has_description();
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GpuCounterDescriptor_GpuCounterSpec::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    set_has_description();
  } else {
    clear_has_description();
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.description)
}

// optional int64 int_peak_value = 5;
inline bool GpuCounterDescriptor_GpuCounterSpec::has_int_peak_value() const {
  return peak_value_case() == kIntPeakValue;
}
inline void GpuCounterDescriptor_GpuCounterSpec::set_has_int_peak_value() {
  _oneof_case_[0] = kIntPeakValue;
}
inline void GpuCounterDescriptor_GpuCounterSpec::clear_int_peak_value() {
  if (has_int_peak_value()) {
    peak_value_.int_peak_value_ = GOOGLE_LONGLONG(0);
    clear_has_peak_value();
  }
}
inline ::google::protobuf::int64 GpuCounterDescriptor_GpuCounterSpec::int_peak_value() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.int_peak_value)
  if (has_int_peak_value()) {
    return peak_value_.int_peak_value_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void GpuCounterDescriptor_GpuCounterSpec::set_int_peak_value(::google::protobuf::int64 value) {
  if (!has_int_peak_value()) {
    clear_peak_value();
    set_has_int_peak_value();
  }
  peak_value_.int_peak_value_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.int_peak_value)
}

// optional double double_peak_value = 6;
inline bool GpuCounterDescriptor_GpuCounterSpec::has_double_peak_value() const {
  return peak_value_case() == kDoublePeakValue;
}
inline void GpuCounterDescriptor_GpuCounterSpec::set_has_double_peak_value() {
  _oneof_case_[0] = kDoublePeakValue;
}
inline void GpuCounterDescriptor_GpuCounterSpec::clear_double_peak_value() {
  if (has_double_peak_value()) {
    peak_value_.double_peak_value_ = 0;
    clear_has_peak_value();
  }
}
inline double GpuCounterDescriptor_GpuCounterSpec::double_peak_value() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.double_peak_value)
  if (has_double_peak_value()) {
    return peak_value_.double_peak_value_;
  }
  return 0;
}
inline void GpuCounterDescriptor_GpuCounterSpec::set_double_peak_value(double value) {
  if (!has_double_peak_value()) {
    clear_peak_value();
    set_has_double_peak_value();
  }
  peak_value_.double_peak_value_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.double_peak_value)
}

// repeated .perfetto.protos.GpuCounterDescriptor.MeasureUnit numerator_units = 7;
inline int GpuCounterDescriptor_GpuCounterSpec::numerator_units_size() const {
  return numerator_units_.size();
}
inline void GpuCounterDescriptor_GpuCounterSpec::clear_numerator_units() {
  numerator_units_.Clear();
}
inline ::perfetto::protos::GpuCounterDescriptor_MeasureUnit GpuCounterDescriptor_GpuCounterSpec::numerator_units(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.numerator_units)
  return static_cast< ::perfetto::protos::GpuCounterDescriptor_MeasureUnit >(numerator_units_.Get(index));
}
inline void GpuCounterDescriptor_GpuCounterSpec::set_numerator_units(int index, ::perfetto::protos::GpuCounterDescriptor_MeasureUnit value) {
  assert(::perfetto::protos::GpuCounterDescriptor_MeasureUnit_IsValid(value));
  numerator_units_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.numerator_units)
}
inline void GpuCounterDescriptor_GpuCounterSpec::add_numerator_units(::perfetto::protos::GpuCounterDescriptor_MeasureUnit value) {
  assert(::perfetto::protos::GpuCounterDescriptor_MeasureUnit_IsValid(value));
  numerator_units_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.numerator_units)
}
inline const ::google::protobuf::RepeatedField<int>&
GpuCounterDescriptor_GpuCounterSpec::numerator_units() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.numerator_units)
  return numerator_units_;
}
inline ::google::protobuf::RepeatedField<int>*
GpuCounterDescriptor_GpuCounterSpec::mutable_numerator_units() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.numerator_units)
  return &numerator_units_;
}

// repeated .perfetto.protos.GpuCounterDescriptor.MeasureUnit denominator_units = 8;
inline int GpuCounterDescriptor_GpuCounterSpec::denominator_units_size() const {
  return denominator_units_.size();
}
inline void GpuCounterDescriptor_GpuCounterSpec::clear_denominator_units() {
  denominator_units_.Clear();
}
inline ::perfetto::protos::GpuCounterDescriptor_MeasureUnit GpuCounterDescriptor_GpuCounterSpec::denominator_units(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.denominator_units)
  return static_cast< ::perfetto::protos::GpuCounterDescriptor_MeasureUnit >(denominator_units_.Get(index));
}
inline void GpuCounterDescriptor_GpuCounterSpec::set_denominator_units(int index, ::perfetto::protos::GpuCounterDescriptor_MeasureUnit value) {
  assert(::perfetto::protos::GpuCounterDescriptor_MeasureUnit_IsValid(value));
  denominator_units_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.denominator_units)
}
inline void GpuCounterDescriptor_GpuCounterSpec::add_denominator_units(::perfetto::protos::GpuCounterDescriptor_MeasureUnit value) {
  assert(::perfetto::protos::GpuCounterDescriptor_MeasureUnit_IsValid(value));
  denominator_units_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.denominator_units)
}
inline const ::google::protobuf::RepeatedField<int>&
GpuCounterDescriptor_GpuCounterSpec::denominator_units() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.denominator_units)
  return denominator_units_;
}
inline ::google::protobuf::RepeatedField<int>*
GpuCounterDescriptor_GpuCounterSpec::mutable_denominator_units() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.denominator_units)
  return &denominator_units_;
}

// optional bool select_by_default = 9;
inline bool GpuCounterDescriptor_GpuCounterSpec::has_select_by_default() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GpuCounterDescriptor_GpuCounterSpec::set_has_select_by_default() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GpuCounterDescriptor_GpuCounterSpec::clear_has_select_by_default() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GpuCounterDescriptor_GpuCounterSpec::clear_select_by_default() {
  select_by_default_ = false;
  clear_has_select_by_default();
}
inline bool GpuCounterDescriptor_GpuCounterSpec::select_by_default() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.select_by_default)
  return select_by_default_;
}
inline void GpuCounterDescriptor_GpuCounterSpec::set_select_by_default(bool value) {
  set_has_select_by_default();
  select_by_default_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.select_by_default)
}

inline bool GpuCounterDescriptor_GpuCounterSpec::has_peak_value() const {
  return peak_value_case() != PEAK_VALUE_NOT_SET;
}
inline void GpuCounterDescriptor_GpuCounterSpec::clear_has_peak_value() {
  _oneof_case_[0] = PEAK_VALUE_NOT_SET;
}
inline GpuCounterDescriptor_GpuCounterSpec::PeakValueCase GpuCounterDescriptor_GpuCounterSpec::peak_value_case() const {
  return GpuCounterDescriptor_GpuCounterSpec::PeakValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// GpuCounterDescriptor_GpuCounterBlock

// optional uint32 block_id = 1;
inline bool GpuCounterDescriptor_GpuCounterBlock::has_block_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GpuCounterDescriptor_GpuCounterBlock::set_has_block_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GpuCounterDescriptor_GpuCounterBlock::clear_has_block_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GpuCounterDescriptor_GpuCounterBlock::clear_block_id() {
  block_id_ = 0u;
  clear_has_block_id();
}
inline ::google::protobuf::uint32 GpuCounterDescriptor_GpuCounterBlock::block_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterDescriptor.GpuCounterBlock.block_id)
  return block_id_;
}
inline void GpuCounterDescriptor_GpuCounterBlock::set_block_id(::google::protobuf::uint32 value) {
  set_has_block_id();
  block_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.GpuCounterDescriptor.GpuCounterBlock.block_id)
}

// optional uint32 block_capacity = 2;
inline bool GpuCounterDescriptor_GpuCounterBlock::has_block_capacity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GpuCounterDescriptor_GpuCounterBlock::set_has_block_capacity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GpuCounterDescriptor_GpuCounterBlock::clear_has_block_capacity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GpuCounterDescriptor_GpuCounterBlock::clear_block_capacity() {
  block_capacity_ = 0u;
  clear_has_block_capacity();
}
inline ::google::protobuf::uint32 GpuCounterDescriptor_GpuCounterBlock::block_capacity() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterDescriptor.GpuCounterBlock.block_capacity)
  return block_capacity_;
}
inline void GpuCounterDescriptor_GpuCounterBlock::set_block_capacity(::google::protobuf::uint32 value) {
  set_has_block_capacity();
  block_capacity_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.GpuCounterDescriptor.GpuCounterBlock.block_capacity)
}

// optional string name = 3;
inline bool GpuCounterDescriptor_GpuCounterBlock::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GpuCounterDescriptor_GpuCounterBlock::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GpuCounterDescriptor_GpuCounterBlock::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GpuCounterDescriptor_GpuCounterBlock::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& GpuCounterDescriptor_GpuCounterBlock::name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterDescriptor.GpuCounterBlock.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GpuCounterDescriptor_GpuCounterBlock::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.GpuCounterDescriptor.GpuCounterBlock.name)
}
inline void GpuCounterDescriptor_GpuCounterBlock::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.GpuCounterDescriptor.GpuCounterBlock.name)
}
inline void GpuCounterDescriptor_GpuCounterBlock::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.GpuCounterDescriptor.GpuCounterBlock.name)
}
inline ::std::string* GpuCounterDescriptor_GpuCounterBlock::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GpuCounterDescriptor.GpuCounterBlock.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GpuCounterDescriptor_GpuCounterBlock::release_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.GpuCounterDescriptor.GpuCounterBlock.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GpuCounterDescriptor_GpuCounterBlock::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.GpuCounterDescriptor.GpuCounterBlock.name)
}

// optional string description = 4;
inline bool GpuCounterDescriptor_GpuCounterBlock::has_description() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GpuCounterDescriptor_GpuCounterBlock::set_has_description() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GpuCounterDescriptor_GpuCounterBlock::clear_has_description() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GpuCounterDescriptor_GpuCounterBlock::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_description();
}
inline const ::std::string& GpuCounterDescriptor_GpuCounterBlock::description() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterDescriptor.GpuCounterBlock.description)
  return description_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GpuCounterDescriptor_GpuCounterBlock::set_description(const ::std::string& value) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.GpuCounterDescriptor.GpuCounterBlock.description)
}
inline void GpuCounterDescriptor_GpuCounterBlock::set_description(const char* value) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.GpuCounterDescriptor.GpuCounterBlock.description)
}
inline void GpuCounterDescriptor_GpuCounterBlock::set_description(const char* value, size_t size) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.GpuCounterDescriptor.GpuCounterBlock.description)
}
inline ::std::string* GpuCounterDescriptor_GpuCounterBlock::mutable_description() {
  set_has_description();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GpuCounterDescriptor.GpuCounterBlock.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GpuCounterDescriptor_GpuCounterBlock::release_description() {
  // @@protoc_insertion_point(field_release:perfetto.protos.GpuCounterDescriptor.GpuCounterBlock.description)
  clear_has_description();
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GpuCounterDescriptor_GpuCounterBlock::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    set_has_description();
  } else {
    clear_has_description();
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.GpuCounterDescriptor.GpuCounterBlock.description)
}

// repeated uint32 counter_ids = 5;
inline int GpuCounterDescriptor_GpuCounterBlock::counter_ids_size() const {
  return counter_ids_.size();
}
inline void GpuCounterDescriptor_GpuCounterBlock::clear_counter_ids() {
  counter_ids_.Clear();
}
inline ::google::protobuf::uint32 GpuCounterDescriptor_GpuCounterBlock::counter_ids(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterDescriptor.GpuCounterBlock.counter_ids)
  return counter_ids_.Get(index);
}
inline void GpuCounterDescriptor_GpuCounterBlock::set_counter_ids(int index, ::google::protobuf::uint32 value) {
  counter_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.GpuCounterDescriptor.GpuCounterBlock.counter_ids)
}
inline void GpuCounterDescriptor_GpuCounterBlock::add_counter_ids(::google::protobuf::uint32 value) {
  counter_ids_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.GpuCounterDescriptor.GpuCounterBlock.counter_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
GpuCounterDescriptor_GpuCounterBlock::counter_ids() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.GpuCounterDescriptor.GpuCounterBlock.counter_ids)
  return counter_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
GpuCounterDescriptor_GpuCounterBlock::mutable_counter_ids() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.GpuCounterDescriptor.GpuCounterBlock.counter_ids)
  return &counter_ids_;
}

// -------------------------------------------------------------------

// GpuCounterDescriptor

// repeated .perfetto.protos.GpuCounterDescriptor.GpuCounterSpec specs = 1;
inline int GpuCounterDescriptor::specs_size() const {
  return specs_.size();
}
inline void GpuCounterDescriptor::clear_specs() {
  specs_.Clear();
}
inline const ::perfetto::protos::GpuCounterDescriptor_GpuCounterSpec& GpuCounterDescriptor::specs(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterDescriptor.specs)
  return specs_.Get(index);
}
inline ::perfetto::protos::GpuCounterDescriptor_GpuCounterSpec* GpuCounterDescriptor::mutable_specs(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GpuCounterDescriptor.specs)
  return specs_.Mutable(index);
}
inline ::perfetto::protos::GpuCounterDescriptor_GpuCounterSpec* GpuCounterDescriptor::add_specs() {
  // @@protoc_insertion_point(field_add:perfetto.protos.GpuCounterDescriptor.specs)
  return specs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::GpuCounterDescriptor_GpuCounterSpec >*
GpuCounterDescriptor::mutable_specs() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.GpuCounterDescriptor.specs)
  return &specs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::GpuCounterDescriptor_GpuCounterSpec >&
GpuCounterDescriptor::specs() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.GpuCounterDescriptor.specs)
  return specs_;
}

// repeated .perfetto.protos.GpuCounterDescriptor.GpuCounterBlock blocks = 2;
inline int GpuCounterDescriptor::blocks_size() const {
  return blocks_.size();
}
inline void GpuCounterDescriptor::clear_blocks() {
  blocks_.Clear();
}
inline const ::perfetto::protos::GpuCounterDescriptor_GpuCounterBlock& GpuCounterDescriptor::blocks(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterDescriptor.blocks)
  return blocks_.Get(index);
}
inline ::perfetto::protos::GpuCounterDescriptor_GpuCounterBlock* GpuCounterDescriptor::mutable_blocks(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GpuCounterDescriptor.blocks)
  return blocks_.Mutable(index);
}
inline ::perfetto::protos::GpuCounterDescriptor_GpuCounterBlock* GpuCounterDescriptor::add_blocks() {
  // @@protoc_insertion_point(field_add:perfetto.protos.GpuCounterDescriptor.blocks)
  return blocks_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::GpuCounterDescriptor_GpuCounterBlock >*
GpuCounterDescriptor::mutable_blocks() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.GpuCounterDescriptor.blocks)
  return &blocks_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::GpuCounterDescriptor_GpuCounterBlock >&
GpuCounterDescriptor::blocks() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.GpuCounterDescriptor.blocks)
  return blocks_;
}

// optional uint64 min_sampling_period_ns = 3;
inline bool GpuCounterDescriptor::has_min_sampling_period_ns() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GpuCounterDescriptor::set_has_min_sampling_period_ns() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GpuCounterDescriptor::clear_has_min_sampling_period_ns() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GpuCounterDescriptor::clear_min_sampling_period_ns() {
  min_sampling_period_ns_ = GOOGLE_ULONGLONG(0);
  clear_has_min_sampling_period_ns();
}
inline ::google::protobuf::uint64 GpuCounterDescriptor::min_sampling_period_ns() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterDescriptor.min_sampling_period_ns)
  return min_sampling_period_ns_;
}
inline void GpuCounterDescriptor::set_min_sampling_period_ns(::google::protobuf::uint64 value) {
  set_has_min_sampling_period_ns();
  min_sampling_period_ns_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.GpuCounterDescriptor.min_sampling_period_ns)
}

// optional uint64 max_sampling_period_ns = 4;
inline bool GpuCounterDescriptor::has_max_sampling_period_ns() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GpuCounterDescriptor::set_has_max_sampling_period_ns() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GpuCounterDescriptor::clear_has_max_sampling_period_ns() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GpuCounterDescriptor::clear_max_sampling_period_ns() {
  max_sampling_period_ns_ = GOOGLE_ULONGLONG(0);
  clear_has_max_sampling_period_ns();
}
inline ::google::protobuf::uint64 GpuCounterDescriptor::max_sampling_period_ns() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterDescriptor.max_sampling_period_ns)
  return max_sampling_period_ns_;
}
inline void GpuCounterDescriptor::set_max_sampling_period_ns(::google::protobuf::uint64 value) {
  set_has_max_sampling_period_ns();
  max_sampling_period_ns_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.GpuCounterDescriptor.max_sampling_period_ns)
}

// optional bool supports_instrumented_sampling = 5;
inline bool GpuCounterDescriptor::has_supports_instrumented_sampling() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GpuCounterDescriptor::set_has_supports_instrumented_sampling() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GpuCounterDescriptor::clear_has_supports_instrumented_sampling() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GpuCounterDescriptor::clear_supports_instrumented_sampling() {
  supports_instrumented_sampling_ = false;
  clear_has_supports_instrumented_sampling();
}
inline bool GpuCounterDescriptor::supports_instrumented_sampling() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterDescriptor.supports_instrumented_sampling)
  return supports_instrumented_sampling_;
}
inline void GpuCounterDescriptor::set_supports_instrumented_sampling(bool value) {
  set_has_supports_instrumented_sampling();
  supports_instrumented_sampling_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.GpuCounterDescriptor.supports_instrumented_sampling)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::perfetto::protos::GpuCounterDescriptor_MeasureUnit> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto__INCLUDED
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/common/observable_events.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/common/observable_events.proto

#ifndef PROTOBUF_protos_2fperfetto_2fcommon_2fobservable_5fevents_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2fcommon_2fobservable_5fevents_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2fcommon_2fobservable_5fevents_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2fobservable_5fevents_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2fobservable_5fevents_2eproto();

class ObservableEvents;
class ObservableEvents_DataSourceInstanceStateChange;

enum ObservableEvents_Type {
  ObservableEvents_Type_TYPE_UNSPECIFIED = 0,
  ObservableEvents_Type_TYPE_DATA_SOURCES_INSTANCES = 1
};
bool ObservableEvents_Type_IsValid(int value);
const ObservableEvents_Type ObservableEvents_Type_Type_MIN = ObservableEvents_Type_TYPE_UNSPECIFIED;
const ObservableEvents_Type ObservableEvents_Type_Type_MAX = ObservableEvents_Type_TYPE_DATA_SOURCES_INSTANCES;
const int ObservableEvents_Type_Type_ARRAYSIZE = ObservableEvents_Type_Type_MAX + 1;

enum ObservableEvents_DataSourceInstanceState {
  ObservableEvents_DataSourceInstanceState_DATA_SOURCE_INSTANCE_STATE_STOPPED = 1,
  ObservableEvents_DataSourceInstanceState_DATA_SOURCE_INSTANCE_STATE_STARTED = 2
};
bool ObservableEvents_DataSourceInstanceState_IsValid(int value);
const ObservableEvents_DataSourceInstanceState ObservableEvents_DataSourceInstanceState_DataSourceInstanceState_MIN = ObservableEvents_DataSourceInstanceState_DATA_SOURCE_INSTANCE_STATE_STOPPED;
const ObservableEvents_DataSourceInstanceState ObservableEvents_DataSourceInstanceState_DataSourceInstanceState_MAX = ObservableEvents_DataSourceInstanceState_DATA_SOURCE_INSTANCE_STATE_STARTED;
const int ObservableEvents_DataSourceInstanceState_DataSourceInstanceState_ARRAYSIZE = ObservableEvents_DataSourceInstanceState_DataSourceInstanceState_MAX + 1;

// ===================================================================

class ObservableEvents_DataSourceInstanceStateChange : public ::google::protobuf::MessageLite {
 public:
  ObservableEvents_DataSourceInstanceStateChange();
  virtual ~ObservableEvents_DataSourceInstanceStateChange();

  ObservableEvents_DataSourceInstanceStateChange(const ObservableEvents_DataSourceInstanceStateChange& from);

  inline ObservableEvents_DataSourceInstanceStateChange& operator=(const ObservableEvents_DataSourceInstanceStateChange& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ObservableEvents_DataSourceInstanceStateChange& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ObservableEvents_DataSourceInstanceStateChange* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ObservableEvents_DataSourceInstanceStateChange* other);

  // implements Message ----------------------------------------------

  inline ObservableEvents_DataSourceInstanceStateChange* New() const { return New(NULL); }

  ObservableEvents_DataSourceInstanceStateChange* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ObservableEvents_DataSourceInstanceStateChange& from);
  void MergeFrom(const ObservableEvents_DataSourceInstanceStateChange& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ObservableEvents_DataSourceInstanceStateChange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string producer_name = 1;
  bool has_producer_name() const;
  void clear_producer_name();
  static const int kProducerNameFieldNumber = 1;
  const ::std::string& producer_name() const;
  void set_producer_name(const ::std::string& value);
  void set_producer_name(const char* value);
  void set_producer_name(const char* value, size_t size);
  ::std::string* mutable_producer_name();
  ::std::string* release_producer_name();
  void set_allocated_producer_name(::std::string* producer_name);

  // optional string data_source_name = 2;
  bool has_data_source_name() const;
  void clear_data_source_name();
  static const int kDataSourceNameFieldNumber = 2;
  const ::std::string& data_source_name() const;
  void set_data_source_name(const ::std::string& value);
  void set_data_source_name(const char* value);
  void set_data_source_name(const char* value, size_t size);
  ::std::string* mutable_data_source_name();
  ::std::string* release_data_source_name();
  void set_allocated_data_source_name(::std::string* data_source_name);

  // optional .perfetto.protos.ObservableEvents.DataSourceInstanceState state = 3;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 3;
  ::perfetto::protos::ObservableEvents_DataSourceInstanceState state() const;
  void set_state(::perfetto::protos::ObservableEvents_DataSourceInstanceState value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange)
 private:
  inline void set_has_producer_name();
  inline void clear_has_producer_name();
  inline void set_has_data_source_name();
  inline void clear_has_data_source_name();
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr producer_name_;
  ::google::protobuf::internal::ArenaStringPtr data_source_name_;
  int state_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fobservable_5fevents_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fobservable_5fevents_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2fobservable_5fevents_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2fobservable_5fevents_2eproto();

  void InitAsDefaultInstance();
  static ObservableEvents_DataSourceInstanceStateChange* default_instance_;
};
// -------------------------------------------------------------------

class ObservableEvents : public ::google::protobuf::MessageLite {
 public:
  ObservableEvents();
  virtual ~ObservableEvents();

  ObservableEvents(const ObservableEvents& from);

  inline ObservableEvents& operator=(const ObservableEvents& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ObservableEvents& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ObservableEvents* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ObservableEvents* other);

  // implements Message ----------------------------------------------

  inline ObservableEvents* New() const { return New(NULL); }

  ObservableEvents* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ObservableEvents& from);
  void MergeFrom(const ObservableEvents& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ObservableEvents* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ObservableEvents_DataSourceInstanceStateChange DataSourceInstanceStateChange;

  typedef ObservableEvents_Type Type;
  static const Type TYPE_UNSPECIFIED =
    ObservableEvents_Type_TYPE_UNSPECIFIED;
  static const Type TYPE_DATA_SOURCES_INSTANCES =
    ObservableEvents_Type_TYPE_DATA_SOURCES_INSTANCES;
  static inline bool Type_IsValid(int value) {
    return ObservableEvents_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ObservableEvents_Type_Type_MIN;
  static const Type Type_MAX =
    ObservableEvents_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ObservableEvents_Type_Type_ARRAYSIZE;

  typedef ObservableEvents_DataSourceInstanceState DataSourceInstanceState;
  static const DataSourceInstanceState DATA_SOURCE_INSTANCE_STATE_STOPPED =
    ObservableEvents_DataSourceInstanceState_DATA_SOURCE_INSTANCE_STATE_STOPPED;
  static const DataSourceInstanceState DATA_SOURCE_INSTANCE_STATE_STARTED =
    ObservableEvents_DataSourceInstanceState_DATA_SOURCE_INSTANCE_STATE_STARTED;
  static inline bool DataSourceInstanceState_IsValid(int value) {
    return ObservableEvents_DataSourceInstanceState_IsValid(value);
  }
  static const DataSourceInstanceState DataSourceInstanceState_MIN =
    ObservableEvents_DataSourceInstanceState_DataSourceInstanceState_MIN;
  static const DataSourceInstanceState DataSourceInstanceState_MAX =
    ObservableEvents_DataSourceInstanceState_DataSourceInstanceState_MAX;
  static const int DataSourceInstanceState_ARRAYSIZE =
    ObservableEvents_DataSourceInstanceState_DataSourceInstanceState_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .perfetto.protos.ObservableEvents.DataSourceInstanceStateChange instance_state_changes = 1;
  int instance_state_changes_size() const;
  void clear_instance_state_changes();
  static const int kInstanceStateChangesFieldNumber = 1;
  const ::perfetto::protos::ObservableEvents_DataSourceInstanceStateChange& instance_state_changes(int index) const;
  ::perfetto::protos::ObservableEvents_DataSourceInstanceStateChange* mutable_instance_state_changes(int index);
  ::perfetto::protos::ObservableEvents_DataSourceInstanceStateChange* add_instance_state_changes();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::ObservableEvents_DataSourceInstanceStateChange >*
      mutable_instance_state_changes();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::ObservableEvents_DataSourceInstanceStateChange >&
      instance_state_changes() const;

  // @@protoc_insertion_point(class_scope:perfetto.protos.ObservableEvents)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::ObservableEvents_DataSourceInstanceStateChange > instance_state_changes_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fobservable_5fevents_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fobservable_5fevents_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2fobservable_5fevents_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2fobservable_5fevents_2eproto();

  void InitAsDefaultInstance();
  static ObservableEvents* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// ObservableEvents_DataSourceInstanceStateChange

// optional string producer_name = 1;
inline bool ObservableEvents_DataSourceInstanceStateChange::has_producer_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObservableEvents_DataSourceInstanceStateChange::set_has_producer_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ObservableEvents_DataSourceInstanceStateChange::clear_has_producer_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ObservableEvents_DataSourceInstanceStateChange::clear_producer_name() {
  producer_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_producer_name();
}
inline const ::std::string& ObservableEvents_DataSourceInstanceStateChange::producer_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.producer_name)
  return producer_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ObservableEvents_DataSourceInstanceStateChange::set_producer_name(const ::std::string& value) {
  set_has_producer_name();
  producer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.producer_name)
}
inline void ObservableEvents_DataSourceInstanceStateChange::set_producer_name(const char* value) {
  set_has_producer_name();
  producer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.producer_name)
}
inline void ObservableEvents_DataSourceInstanceStateChange::set_producer_name(const char* value, size_t size) {
  set_has_producer_name();
  producer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.producer_name)
}
inline ::std::string* ObservableEvents_DataSourceInstanceStateChange::mutable_producer_name() {
  set_has_producer_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.producer_name)
  return producer_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ObservableEvents_DataSourceInstanceStateChange::release_producer_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.producer_name)
  clear_has_producer_name();
  return producer_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ObservableEvents_DataSourceInstanceStateChange::set_allocated_producer_name(::std::string* producer_name) {
  if (producer_name != NULL) {
    set_has_producer_name();
  } else {
    clear_has_producer_name();
  }
  producer_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), producer_name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.producer_name)
}

// optional string data_source_name = 2;
inline bool ObservableEvents_DataSourceInstanceStateChange::has_data_source_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ObservableEvents_DataSourceInstanceStateChange::set_has_data_source_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ObservableEvents_DataSourceInstanceStateChange::clear_has_data_source_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ObservableEvents_DataSourceInstanceStateChange::clear_data_source_name() {
  data_source_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data_source_name();
}
inline const ::std::string& ObservableEvents_DataSourceInstanceStateChange::data_source_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.data_source_name)
  return data_source_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ObservableEvents_DataSourceInstanceStateChange::set_data_source_name(const ::std::string& value) {
  set_has_data_source_name();
  data_source_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.data_source_name)
}
inline void ObservableEvents_DataSourceInstanceStateChange::set_data_source_name(const char* value) {
  set_has_data_source_name();
  data_source_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.data_source_name)
}
inline void ObservableEvents_DataSourceInstanceStateChange::set_data_source_name(const char* value, size_t size) {
  set_has_data_source_name();
  data_source_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.data_source_name)
}
inline ::std::string* ObservableEvents_DataSourceInstanceStateChange::mutable_data_source_name() {
  set_has_data_source_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.data_source_name)
  return data_source_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ObservableEvents_DataSourceInstanceStateChange::release_data_source_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.data_source_name)
  clear_has_data_source_name();
  return data_source_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ObservableEvents_DataSourceInstanceStateChange::set_allocated_data_source_name(::std::string* data_source_name) {
  if (data_source_name != NULL) {
    set_has_data_source_name();
  } else {
    clear_has_data_source_name();
  }
  data_source_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data_source_name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.data_source_name)
}

// optional .perfetto.protos.ObservableEvents.DataSourceInstanceState state = 3;
inline bool ObservableEvents_DataSourceInstanceStateChange::has_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ObservableEvents_DataSourceInstanceStateChange::set_has_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ObservableEvents_DataSourceInstanceStateChange::clear_has_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ObservableEvents_DataSourceInstanceStateChange::clear_state() {
  state_ = 1;
  clear_has_state();
}
inline ::perfetto::protos::ObservableEvents_DataSourceInstanceState ObservableEvents_DataSourceInstanceStateChange::state() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.state)
  return static_cast< ::perfetto::protos::ObservableEvents_DataSourceInstanceState >(state_);
}
inline void ObservableEvents_DataSourceInstanceStateChange::set_state(::perfetto::protos::ObservableEvents_DataSourceInstanceState value) {
  assert(::perfetto::protos::ObservableEvents_DataSourceInstanceState_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.state)
}

// -------------------------------------------------------------------

// ObservableEvents

// repeated .perfetto.protos.ObservableEvents.DataSourceInstanceStateChange instance_state_changes = 1;
inline int ObservableEvents::instance_state_changes_size() const {
  return instance_state_changes_.size();
}
inline void ObservableEvents::clear_instance_state_changes() {
  instance_state_changes_.Clear();
}
inline const ::perfetto::protos::ObservableEvents_DataSourceInstanceStateChange& ObservableEvents::instance_state_changes(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ObservableEvents.instance_state_changes)
  return instance_state_changes_.Get(index);
}
inline ::perfetto::protos::ObservableEvents_DataSourceInstanceStateChange* ObservableEvents::mutable_instance_state_changes(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.ObservableEvents.instance_state_changes)
  return instance_state_changes_.Mutable(index);
}
inline ::perfetto::protos::ObservableEvents_DataSourceInstanceStateChange* ObservableEvents::add_instance_state_changes() {
  // @@protoc_insertion_point(field_add:perfetto.protos.ObservableEvents.instance_state_changes)
  return instance_state_changes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::ObservableEvents_DataSourceInstanceStateChange >*
ObservableEvents::mutable_instance_state_changes() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.ObservableEvents.instance_state_changes)
  return &instance_state_changes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::ObservableEvents_DataSourceInstanceStateChange >&
ObservableEvents::instance_state_changes() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.ObservableEvents.instance_state_changes)
  return instance_state_changes_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::perfetto::protos::ObservableEvents_Type> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::perfetto::protos::ObservableEvents_DataSourceInstanceState> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2fcommon_2fobservable_5fevents_2eproto__INCLUDED
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/common/sys_stats_counters.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/common/sys_stats_counters.proto

#ifndef PROTOBUF_protos_2fperfetto_2fcommon_2fsys_5fstats_5fcounters_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2fcommon_2fsys_5fstats_5fcounters_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2fcommon_2fsys_5fstats_5fcounters_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2fsys_5fstats_5fcounters_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2fsys_5fstats_5fcounters_2eproto();


enum MeminfoCounters {
  MEMINFO_UNSPECIFIED = 0,
  MEMINFO_MEM_TOTAL = 1,
  MEMINFO_MEM_FREE = 2,
  MEMINFO_MEM_AVAILABLE = 3,
  MEMINFO_BUFFERS = 4,
  MEMINFO_CACHED = 5,
  MEMINFO_SWAP_CACHED = 6,
  MEMINFO_ACTIVE = 7,
  MEMINFO_INACTIVE = 8,
  MEMINFO_ACTIVE_ANON = 9,
  MEMINFO_INACTIVE_ANON = 10,
  MEMINFO_ACTIVE_FILE = 11,
  MEMINFO_INACTIVE_FILE = 12,
  MEMINFO_UNEVICTABLE = 13,
  MEMINFO_MLOCKED = 14,
  MEMINFO_SWAP_TOTAL = 15,
  MEMINFO_SWAP_FREE = 16,
  MEMINFO_DIRTY = 17,
  MEMINFO_WRITEBACK = 18,
  MEMINFO_ANON_PAGES = 19,
  MEMINFO_MAPPED = 20,
  MEMINFO_SHMEM = 21,
  MEMINFO_SLAB = 22,
  MEMINFO_SLAB_RECLAIMABLE = 23,
  MEMINFO_SLAB_UNRECLAIMABLE = 24,
  MEMINFO_KERNEL_STACK = 25,
  MEMINFO_PAGE_TABLES = 26,
  MEMINFO_COMMIT_LIMIT = 27,
  MEMINFO_COMMITED_AS = 28,
  MEMINFO_VMALLOC_TOTAL = 29,
  MEMINFO_VMALLOC_USED = 30,
  MEMINFO_VMALLOC_CHUNK = 31,
  MEMINFO_CMA_TOTAL = 32,
  MEMINFO_CMA_FREE = 33
};
bool MeminfoCounters_IsValid(int value);
const MeminfoCounters MeminfoCounters_MIN = MEMINFO_UNSPECIFIED;
const MeminfoCounters MeminfoCounters_MAX = MEMINFO_CMA_FREE;
const int MeminfoCounters_ARRAYSIZE = MeminfoCounters_MAX + 1;

enum VmstatCounters {
  VMSTAT_UNSPECIFIED = 0,
  VMSTAT_NR_FREE_PAGES = 1,
  VMSTAT_NR_ALLOC_BATCH = 2,
  VMSTAT_NR_INACTIVE_ANON = 3,
  VMSTAT_NR_ACTIVE_ANON = 4,
  VMSTAT_NR_INACTIVE_FILE = 5,
  VMSTAT_NR_ACTIVE_FILE = 6,
  VMSTAT_NR_UNEVICTABLE = 7,
  VMSTAT_NR_MLOCK = 8,
  VMSTAT_NR_ANON_PAGES = 9,
  VMSTAT_NR_MAPPED = 10,
  VMSTAT_NR_FILE_PAGES = 11,
  VMSTAT_NR_DIRTY = 12,
  VMSTAT_NR_WRITEBACK = 13,
  VMSTAT_NR_SLAB_RECLAIMABLE = 14,
  VMSTAT_NR_SLAB_UNRECLAIMABLE = 15,
  VMSTAT_NR_PAGE_TABLE_PAGES = 16,
  VMSTAT_NR_KERNEL_STACK = 17,
  VMSTAT_NR_OVERHEAD = 18,
  VMSTAT_NR_UNSTABLE = 19,
  VMSTAT_NR_BOUNCE = 20,
  VMSTAT_NR_VMSCAN_WRITE = 21,
  VMSTAT_NR_VMSCAN_IMMEDIATE_RECLAIM = 22,
  VMSTAT_NR_WRITEBACK_TEMP = 23,
  VMSTAT_NR_ISOLATED_ANON = 24,
  VMSTAT_NR_ISOLATED_FILE = 25,
  VMSTAT_NR_SHMEM = 26,
  VMSTAT_NR_DIRTIED = 27,
  VMSTAT_NR_WRITTEN = 28,
  VMSTAT_NR_PAGES_SCANNED = 29,
  VMSTAT_WORKINGSET_REFAULT = 30,
  VMSTAT_WORKINGSET_ACTIVATE = 31,
  VMSTAT_WORKINGSET_NODERECLAIM = 32,
  VMSTAT_NR_ANON_TRANSPARENT_HUGEPAGES = 33,
  VMSTAT_NR_FREE_CMA = 34,
  VMSTAT_NR_SWAPCACHE = 35,
  VMSTAT_NR_DIRTY_THRESHOLD = 36,
  VMSTAT_NR_DIRTY_BACKGROUND_THRESHOLD = 37,
  VMSTAT_PGPGIN = 38,
  VMSTAT_PGPGOUT = 39,
  VMSTAT_PGPGOUTCLEAN = 40,
  VMSTAT_PSWPIN = 41,
  VMSTAT_PSWPOUT = 42,
  VMSTAT_PGALLOC_DMA = 43,
  VMSTAT_PGALLOC_NORMAL = 44,
  VMSTAT_PGALLOC_MOVABLE = 45,
  VMSTAT_PGFREE = 46,
  VMSTAT_PGACTIVATE = 47,
  VMSTAT_PGDEACTIVATE = 48,
  VMSTAT_PGFAULT = 49,
  VMSTAT_PGMAJFAULT = 50,
  VMSTAT_PGREFILL_DMA = 51,
  VMSTAT_PGREFILL_NORMAL = 52,
  VMSTAT_PGREFILL_MOVABLE = 53,
  VMSTAT_PGSTEAL_KSWAPD_DMA = 54,
  VMSTAT_PGSTEAL_KSWAPD_NORMAL = 55,
  VMSTAT_PGSTEAL_KSWAPD_MOVABLE = 56,
  VMSTAT_PGSTEAL_DIRECT_DMA = 57,
  VMSTAT_PGSTEAL_DIRECT_NORMAL = 58,
  VMSTAT_PGSTEAL_DIRECT_MOVABLE = 59,
  VMSTAT_PGSCAN_KSWAPD_DMA = 60,
  VMSTAT_PGSCAN_KSWAPD_NORMAL = 61,
  VMSTAT_PGSCAN_KSWAPD_MOVABLE = 62,
  VMSTAT_PGSCAN_DIRECT_DMA = 63,
  VMSTAT_PGSCAN_DIRECT_NORMAL = 64,
  VMSTAT_PGSCAN_DIRECT_MOVABLE = 65,
  VMSTAT_PGSCAN_DIRECT_THROTTLE = 66,
  VMSTAT_PGINODESTEAL = 67,
  VMSTAT_SLABS_SCANNED = 68,
  VMSTAT_KSWAPD_INODESTEAL = 69,
  VMSTAT_KSWAPD_LOW_WMARK_HIT_QUICKLY = 70,
  VMSTAT_KSWAPD_HIGH_WMARK_HIT_QUICKLY = 71,
  VMSTAT_PAGEOUTRUN = 72,
  VMSTAT_ALLOCSTALL = 73,
  VMSTAT_PGROTATED = 74,
  VMSTAT_DROP_PAGECACHE = 75,
  VMSTAT_DROP_SLAB = 76,
  VMSTAT_PGMIGRATE_SUCCESS = 77,
  VMSTAT_PGMIGRATE_FAIL = 78,
  VMSTAT_COMPACT_MIGRATE_SCANNED = 79,
  VMSTAT_COMPACT_FREE_SCANNED = 80,
  VMSTAT_COMPACT_ISOLATED = 81,
  VMSTAT_COMPACT_STALL = 82,
  VMSTAT_COMPACT_FAIL = 83,
  VMSTAT_COMPACT_SUCCESS = 84,
  VMSTAT_COMPACT_DAEMON_WAKE = 85,
  VMSTAT_UNEVICTABLE_PGS_CULLED = 86,
  VMSTAT_UNEVICTABLE_PGS_SCANNED = 87,
  VMSTAT_UNEVICTABLE_PGS_RESCUED = 88,
  VMSTAT_UNEVICTABLE_PGS_MLOCKED = 89,
  VMSTAT_UNEVICTABLE_PGS_MUNLOCKED = 90,
  VMSTAT_UNEVICTABLE_PGS_CLEARED = 91,
  VMSTAT_UNEVICTABLE_PGS_STRANDED = 92,
  VMSTAT_NR_ZSPAGES = 93,
  VMSTAT_NR_ION_HEAP = 94,
  VMSTAT_NR_GPU_HEAP = 95
};
bool VmstatCounters_IsValid(int value);
const VmstatCounters VmstatCounters_MIN = VMSTAT_UNSPECIFIED;
const VmstatCounters VmstatCounters_MAX = VMSTAT_NR_GPU_HEAP;
const int VmstatCounters_ARRAYSIZE = VmstatCounters_MAX + 1;

// ===================================================================


// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::perfetto::protos::MeminfoCounters> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::perfetto::protos::VmstatCounters> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2fcommon_2fsys_5fstats_5fcounters_2eproto__INCLUDED
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/common/trace_stats.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/common/trace_stats.proto

#ifndef PROTOBUF_protos_2fperfetto_2fcommon_2ftrace_5fstats_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2fcommon_2ftrace_5fstats_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2fcommon_2ftrace_5fstats_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2ftrace_5fstats_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2ftrace_5fstats_2eproto();

class TraceStats;
class TraceStats_BufferStats;

// ===================================================================

class TraceStats_BufferStats : public ::google::protobuf::MessageLite {
 public:
  TraceStats_BufferStats();
  virtual ~TraceStats_BufferStats();

  TraceStats_BufferStats(const TraceStats_BufferStats& from);

  inline TraceStats_BufferStats& operator=(const TraceStats_BufferStats& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TraceStats_BufferStats& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TraceStats_BufferStats* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TraceStats_BufferStats* other);

  // implements Message ----------------------------------------------

  inline TraceStats_BufferStats* New() const { return New(NULL); }

  TraceStats_BufferStats* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TraceStats_BufferStats& from);
  void MergeFrom(const TraceStats_BufferStats& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TraceStats_BufferStats* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 buffer_size = 12;
  bool has_buffer_size() const;
  void clear_buffer_size();
  static const int kBufferSizeFieldNumber = 12;
  ::google::protobuf::uint64 buffer_size() const;
  void set_buffer_size(::google::protobuf::uint64 value);

  // optional uint64 bytes_written = 1;
  bool has_bytes_written() const;
  void clear_bytes_written();
  static const int kBytesWrittenFieldNumber = 1;
  ::google::protobuf::uint64 bytes_written() const;
  void set_bytes_written(::google::protobuf::uint64 value);

  // optional uint64 bytes_overwritten = 13;
  bool has_bytes_overwritten() const;
  void clear_bytes_overwritten();
  static const int kBytesOverwrittenFieldNumber = 13;
  ::google::protobuf::uint64 bytes_overwritten() const;
  void set_bytes_overwritten(::google::protobuf::uint64 value);

  // optional uint64 bytes_read = 14;
  bool has_bytes_read() const;
  void clear_bytes_read();
  static const int kBytesReadFieldNumber = 14;
  ::google::protobuf::uint64 bytes_read() const;
  void set_bytes_read(::google::protobuf::uint64 value);

  // optional uint64 padding_bytes_written = 15;
  bool has_padding_bytes_written() const;
  void clear_padding_bytes_written();
  static const int kPaddingBytesWrittenFieldNumber = 15;
  ::google::protobuf::uint64 padding_bytes_written() const;
  void set_padding_bytes_written(::google::protobuf::uint64 value);

  // optional uint64 padding_bytes_cleared = 16;
  bool has_padding_bytes_cleared() const;
  void clear_padding_bytes_cleared();
  static const int kPaddingBytesClearedFieldNumber = 16;
  ::google::protobuf::uint64 padding_bytes_cleared() const;
  void set_padding_bytes_cleared(::google::protobuf::uint64 value);

  // optional uint64 chunks_written = 2;
  bool has_chunks_written() const;
  void clear_chunks_written();
  static const int kChunksWrittenFieldNumber = 2;
  ::google::protobuf::uint64 chunks_written() const;
  void set_chunks_written(::google::protobuf::uint64 value);

  // optional uint64 chunks_rewritten = 10;
  bool has_chunks_rewritten() const;
  void clear_chunks_rewritten();
  static const int kChunksRewrittenFieldNumber = 10;
  ::google::protobuf::uint64 chunks_rewritten() const;
  void set_chunks_rewritten(::google::protobuf::uint64 value);

  // optional uint64 chunks_overwritten = 3;
  bool has_chunks_overwritten() const;
  void clear_chunks_overwritten();
  static const int kChunksOverwrittenFieldNumber = 3;
  ::google::protobuf::uint64 chunks_overwritten() const;
  void set_chunks_overwritten(::google::protobuf::uint64 value);

  // optional uint64 chunks_discarded = 18;
  bool has_chunks_discarded() const;
  void clear_chunks_discarded();
  static const int kChunksDiscardedFieldNumber = 18;
  ::google::protobuf::uint64 chunks_discarded() const;
  void set_chunks_discarded(::google::protobuf::uint64 value);

  // optional uint64 chunks_read = 17;
  bool has_chunks_read() const;
  void clear_chunks_read();
  static const int kChunksReadFieldNumber = 17;
  ::google::protobuf::uint64 chunks_read() const;
  void set_chunks_read(::google::protobuf::uint64 value);

  // optional uint64 chunks_committed_out_of_order = 11;
  bool has_chunks_committed_out_of_order() const;
  void clear_chunks_committed_out_of_order();
  static const int kChunksCommittedOutOfOrderFieldNumber = 11;
  ::google::protobuf::uint64 chunks_committed_out_of_order() const;
  void set_chunks_committed_out_of_order(::google::protobuf::uint64 value);

  // optional uint64 write_wrap_count = 4;
  bool has_write_wrap_count() const;
  void clear_write_wrap_count();
  static const int kWriteWrapCountFieldNumber = 4;
  ::google::protobuf::uint64 write_wrap_count() const;
  void set_write_wrap_count(::google::protobuf::uint64 value);

  // optional uint64 patches_succeeded = 5;
  bool has_patches_succeeded() const;
  void clear_patches_succeeded();
  static const int kPatchesSucceededFieldNumber = 5;
  ::google::protobuf::uint64 patches_succeeded() const;
  void set_patches_succeeded(::google::protobuf::uint64 value);

  // optional uint64 patches_failed = 6;
  bool has_patches_failed() const;
  void clear_patches_failed();
  static const int kPatchesFailedFieldNumber = 6;
  ::google::protobuf::uint64 patches_failed() const;
  void set_patches_failed(::google::protobuf::uint64 value);

  // optional uint64 readaheads_succeeded = 7;
  bool has_readaheads_succeeded() const;
  void clear_readaheads_succeeded();
  static const int kReadaheadsSucceededFieldNumber = 7;
  ::google::protobuf::uint64 readaheads_succeeded() const;
  void set_readaheads_succeeded(::google::protobuf::uint64 value);

  // optional uint64 readaheads_failed = 8;
  bool has_readaheads_failed() const;
  void clear_readaheads_failed();
  static const int kReadaheadsFailedFieldNumber = 8;
  ::google::protobuf::uint64 readaheads_failed() const;
  void set_readaheads_failed(::google::protobuf::uint64 value);

  // optional uint64 abi_violations = 9;
  bool has_abi_violations() const;
  void clear_abi_violations();
  static const int kAbiViolationsFieldNumber = 9;
  ::google::protobuf::uint64 abi_violations() const;
  void set_abi_violations(::google::protobuf::uint64 value);

  // optional uint64 trace_writer_packet_loss = 19;
  bool has_trace_writer_packet_loss() const;
  void clear_trace_writer_packet_loss();
  static const int kTraceWriterPacketLossFieldNumber = 19;
  ::google::protobuf::uint64 trace_writer_packet_loss() const;
  void set_trace_writer_packet_loss(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.TraceStats.BufferStats)
 private:
  inline void set_has_buffer_size();
  inline void clear_has_buffer_size();
  inline void set_has_bytes_written();
  inline void clear_has_bytes_written();
  inline void set_has_bytes_overwritten();
  inline void clear_has_bytes_overwritten();
  inline void set_has_bytes_read();
  inline void clear_has_bytes_read();
  inline void set_has_padding_bytes_written();
  inline void clear_has_padding_bytes_written();
  inline void set_has_padding_bytes_cleared();
  inline void clear_has_padding_bytes_cleared();
  inline void set_has_chunks_written();
  inline void clear_has_chunks_written();
  inline void set_has_chunks_rewritten();
  inline void clear_has_chunks_rewritten();
  inline void set_has_chunks_overwritten();
  inline void clear_has_chunks_overwritten();
  inline void set_has_chunks_discarded();
  inline void clear_has_chunks_discarded();
  inline void set_has_chunks_read();
  inline void clear_has_chunks_read();
  inline void set_has_chunks_committed_out_of_order();
  inline void clear_has_chunks_committed_out_of_order();
  inline void set_has_write_wrap_count();
  inline void clear_has_write_wrap_count();
  inline void set_has_patches_succeeded();
  inline void clear_has_patches_succeeded();
  inline void set_has_patches_failed();
  inline void clear_has_patches_failed();
  inline void set_has_readaheads_succeeded();
  inline void clear_has_readaheads_succeeded();
  inline void set_has_readaheads_failed();
  inline void clear_has_readaheads_failed();
  inline void set_has_abi_violations();
  inline void clear_has_abi_violations();
  inline void set_has_trace_writer_packet_loss();
  inline void clear_has_trace_writer_packet_loss();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 buffer_size_;
  ::google::protobuf::uint64 bytes_written_;
  ::google::protobuf::uint64 bytes_overwritten_;
  ::google::protobuf::uint64 bytes_read_;
  ::google::protobuf::uint64 padding_bytes_written_;
  ::google::protobuf::uint64 padding_bytes_cleared_;
  ::google::protobuf::uint64 chunks_written_;
  ::google::protobuf::uint64 chunks_rewritten_;
  ::google::protobuf::uint64 chunks_overwritten_;
  ::google::protobuf::uint64 chunks_discarded_;
  ::google::protobuf::uint64 chunks_read_;
  ::google::protobuf::uint64 chunks_committed_out_of_order_;
  ::google::protobuf::uint64 write_wrap_count_;
  ::google::protobuf::uint64 patches_succeeded_;
  ::google::protobuf::uint64 patches_failed_;
  ::google::protobuf::uint64 readaheads_succeeded_;
  ::google::protobuf::uint64 readaheads_failed_;
  ::google::protobuf::uint64 abi_violations_;
  ::google::protobuf::uint64 trace_writer_packet_loss_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2ftrace_5fstats_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2ftrace_5fstats_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2ftrace_5fstats_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2ftrace_5fstats_2eproto();

  void InitAsDefaultInstance();
  static TraceStats_BufferStats* default_instance_;
};
// -------------------------------------------------------------------

class TraceStats : public ::google::protobuf::MessageLite {
 public:
  TraceStats();
  virtual ~TraceStats();

  TraceStats(const TraceStats& from);

  inline TraceStats& operator=(const TraceStats& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TraceStats& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TraceStats* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TraceStats* other);

  // implements Message ----------------------------------------------

  inline TraceStats* New() const { return New(NULL); }

  TraceStats* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TraceStats& from);
  void MergeFrom(const TraceStats& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TraceStats* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef TraceStats_BufferStats BufferStats;

  // accessors -------------------------------------------------------

  // repeated .perfetto.protos.TraceStats.BufferStats buffer_stats = 1;
  int buffer_stats_size() const;
  void clear_buffer_stats();
  static const int kBufferStatsFieldNumber = 1;
  const ::perfetto::protos::TraceStats_BufferStats& buffer_stats(int index) const;
  ::perfetto::protos::TraceStats_BufferStats* mutable_buffer_stats(int index);
  ::perfetto::protos::TraceStats_BufferStats* add_buffer_stats();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceStats_BufferStats >*
      mutable_buffer_stats();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceStats_BufferStats >&
      buffer_stats() const;

  // optional uint32 producers_connected = 2;
  bool has_producers_connected() const;
  void clear_producers_connected();
  static const int kProducersConnectedFieldNumber = 2;
  ::google::protobuf::uint32 producers_connected() const;
  void set_producers_connected(::google::protobuf::uint32 value);

  // optional uint64 producers_seen = 3;
  bool has_producers_seen() const;
  void clear_producers_seen();
  static const int kProducersSeenFieldNumber = 3;
  ::google::protobuf::uint64 producers_seen() const;
  void set_producers_seen(::google::protobuf::uint64 value);

  // optional uint32 data_sources_registered = 4;
  bool has_data_sources_registered() const;
  void clear_data_sources_registered();
  static const int kDataSourcesRegisteredFieldNumber = 4;
  ::google::protobuf::uint32 data_sources_registered() const;
  void set_data_sources_registered(::google::protobuf::uint32 value);

  // optional uint64 data_sources_seen = 5;
  bool has_data_sources_seen() const;
  void clear_data_sources_seen();
  static const int kDataSourcesSeenFieldNumber = 5;
  ::google::protobuf::uint64 data_sources_seen() const;
  void set_data_sources_seen(::google::protobuf::uint64 value);

  // optional uint32 tracing_sessions = 6;
  bool has_tracing_sessions() const;
  void clear_tracing_sessions();
  static const int kTracingSessionsFieldNumber = 6;
  ::google::protobuf::uint32 tracing_sessions() const;
  void set_tracing_sessions(::google::protobuf::uint32 value);

  // optional uint32 total_buffers = 7;
  bool has_total_buffers() const;
  void clear_total_buffers();
  static const int kTotalBuffersFieldNumber = 7;
  ::google::protobuf::uint32 total_buffers() const;
  void set_total_buffers(::google::protobuf::uint32 value);

  // optional uint64 chunks_discarded = 8;
  bool has_chunks_discarded() const;
  void clear_chunks_discarded();
  static const int kChunksDiscardedFieldNumber = 8;
  ::google::protobuf::uint64 chunks_discarded() const;
  void set_chunks_discarded(::google::protobuf::uint64 value);

  // optional uint64 patches_discarded = 9;
  bool has_patches_discarded() const;
  void clear_patches_discarded();
  static const int kPatchesDiscardedFieldNumber = 9;
  ::google::protobuf::uint64 patches_discarded() const;
  void set_patches_discarded(::google::protobuf::uint64 value);

  // optional uint64 invalid_packets = 10;
  bool has_invalid_packets() const;
  void clear_invalid_packets();
  static const int kInvalidPacketsFieldNumber = 10;
  ::google::protobuf::uint64 invalid_packets() const;
  void set_invalid_packets(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.TraceStats)
 private:
  inline void set_has_producers_connected();
  inline void clear_has_producers_connected();
  inline void set_has_producers_seen();
  inline void clear_has_producers_seen();
  inline void set_has_data_sources_registered();
  inline void clear_has_data_sources_registered();
  inline void set_has_data_sources_seen();
  inline void clear_has_data_sources_seen();
  inline void set_has_tracing_sessions();
  inline void clear_has_tracing_sessions();
  inline void set_has_total_buffers();
  inline void clear_has_total_buffers();
  inline void set_has_chunks_discarded();
  inline void clear_has_chunks_discarded();
  inline void set_has_patches_discarded();
  inline void clear_has_patches_discarded();
  inline void set_has_invalid_packets();
  inline void clear_has_invalid_packets();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceStats_BufferStats > buffer_stats_;
  ::google::protobuf::uint64 producers_seen_;
  ::google::protobuf::uint32 producers_connected_;
  ::google::protobuf::uint32 data_sources_registered_;
  ::google::protobuf::uint64 data_sources_seen_;
  ::google::protobuf::uint32 tracing_sessions_;
  ::google::protobuf::uint32 total_buffers_;
  ::google::protobuf::uint64 chunks_discarded_;
  ::google::protobuf::uint64 patches_discarded_;
  ::google::protobuf::uint64 invalid_packets_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2ftrace_5fstats_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2ftrace_5fstats_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2ftrace_5fstats_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2ftrace_5fstats_2eproto();

  void InitAsDefaultInstance();
  static TraceStats* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// TraceStats_BufferStats

// optional uint64 buffer_size = 12;
inline bool TraceStats_BufferStats::has_buffer_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TraceStats_BufferStats::set_has_buffer_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TraceStats_BufferStats::clear_has_buffer_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TraceStats_BufferStats::clear_buffer_size() {
  buffer_size_ = GOOGLE_ULONGLONG(0);
  clear_has_buffer_size();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::buffer_size() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.buffer_size)
  return buffer_size_;
}
inline void TraceStats_BufferStats::set_buffer_size(::google::protobuf::uint64 value) {
  set_has_buffer_size();
  buffer_size_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.buffer_size)
}

// optional uint64 bytes_written = 1;
inline bool TraceStats_BufferStats::has_bytes_written() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TraceStats_BufferStats::set_has_bytes_written() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TraceStats_BufferStats::clear_has_bytes_written() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TraceStats_BufferStats::clear_bytes_written() {
  bytes_written_ = GOOGLE_ULONGLONG(0);
  clear_has_bytes_written();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::bytes_written() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.bytes_written)
  return bytes_written_;
}
inline void TraceStats_BufferStats::set_bytes_written(::google::protobuf::uint64 value) {
  set_has_bytes_written();
  bytes_written_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.bytes_written)
}

// optional uint64 bytes_overwritten = 13;
inline bool TraceStats_BufferStats::has_bytes_overwritten() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TraceStats_BufferStats::set_has_bytes_overwritten() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TraceStats_BufferStats::clear_has_bytes_overwritten() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TraceStats_BufferStats::clear_bytes_overwritten() {
  bytes_overwritten_ = GOOGLE_ULONGLONG(0);
  clear_has_bytes_overwritten();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::bytes_overwritten() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.bytes_overwritten)
  return bytes_overwritten_;
}
inline void TraceStats_BufferStats::set_bytes_overwritten(::google::protobuf::uint64 value) {
  set_has_bytes_overwritten();
  bytes_overwritten_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.bytes_overwritten)
}

// optional uint64 bytes_read = 14;
inline bool TraceStats_BufferStats::has_bytes_read() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TraceStats_BufferStats::set_has_bytes_read() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TraceStats_BufferStats::clear_has_bytes_read() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TraceStats_BufferStats::clear_bytes_read() {
  bytes_read_ = GOOGLE_ULONGLONG(0);
  clear_has_bytes_read();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::bytes_read() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.bytes_read)
  return bytes_read_;
}
inline void TraceStats_BufferStats::set_bytes_read(::google::protobuf::uint64 value) {
  set_has_bytes_read();
  bytes_read_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.bytes_read)
}

// optional uint64 padding_bytes_written = 15;
inline bool TraceStats_BufferStats::has_padding_bytes_written() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TraceStats_BufferStats::set_has_padding_bytes_written() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TraceStats_BufferStats::clear_has_padding_bytes_written() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TraceStats_BufferStats::clear_padding_bytes_written() {
  padding_bytes_written_ = GOOGLE_ULONGLONG(0);
  clear_has_padding_bytes_written();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::padding_bytes_written() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.padding_bytes_written)
  return padding_bytes_written_;
}
inline void TraceStats_BufferStats::set_padding_bytes_written(::google::protobuf::uint64 value) {
  set_has_padding_bytes_written();
  padding_bytes_written_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.padding_bytes_written)
}

// optional uint64 padding_bytes_cleared = 16;
inline bool TraceStats_BufferStats::has_padding_bytes_cleared() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TraceStats_BufferStats::set_has_padding_bytes_cleared() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TraceStats_BufferStats::clear_has_padding_bytes_cleared() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TraceStats_BufferStats::clear_padding_bytes_cleared() {
  padding_bytes_cleared_ = GOOGLE_ULONGLONG(0);
  clear_has_padding_bytes_cleared();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::padding_bytes_cleared() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.padding_bytes_cleared)
  return padding_bytes_cleared_;
}
inline void TraceStats_BufferStats::set_padding_bytes_cleared(::google::protobuf::uint64 value) {
  set_has_padding_bytes_cleared();
  padding_bytes_cleared_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.padding_bytes_cleared)
}

// optional uint64 chunks_written = 2;
inline bool TraceStats_BufferStats::has_chunks_written() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TraceStats_BufferStats::set_has_chunks_written() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TraceStats_BufferStats::clear_has_chunks_written() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TraceStats_BufferStats::clear_chunks_written() {
  chunks_written_ = GOOGLE_ULONGLONG(0);
  clear_has_chunks_written();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::chunks_written() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.chunks_written)
  return chunks_written_;
}
inline void TraceStats_BufferStats::set_chunks_written(::google::protobuf::uint64 value) {
  set_has_chunks_written();
  chunks_written_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.chunks_written)
}

// optional uint64 chunks_rewritten = 10;
inline bool TraceStats_BufferStats::has_chunks_rewritten() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TraceStats_BufferStats::set_has_chunks_rewritten() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TraceStats_BufferStats::clear_has_chunks_rewritten() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TraceStats_BufferStats::clear_chunks_rewritten() {
  chunks_rewritten_ = GOOGLE_ULONGLONG(0);
  clear_has_chunks_rewritten();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::chunks_rewritten() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.chunks_rewritten)
  return chunks_rewritten_;
}
inline void TraceStats_BufferStats::set_chunks_rewritten(::google::protobuf::uint64 value) {
  set_has_chunks_rewritten();
  chunks_rewritten_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.chunks_rewritten)
}

// optional uint64 chunks_overwritten = 3;
inline bool TraceStats_BufferStats::has_chunks_overwritten() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TraceStats_BufferStats::set_has_chunks_overwritten() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TraceStats_BufferStats::clear_has_chunks_overwritten() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TraceStats_BufferStats::clear_chunks_overwritten() {
  chunks_overwritten_ = GOOGLE_ULONGLONG(0);
  clear_has_chunks_overwritten();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::chunks_overwritten() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.chunks_overwritten)
  return chunks_overwritten_;
}
inline void TraceStats_BufferStats::set_chunks_overwritten(::google::protobuf::uint64 value) {
  set_has_chunks_overwritten();
  chunks_overwritten_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.chunks_overwritten)
}

// optional uint64 chunks_discarded = 18;
inline bool TraceStats_BufferStats::has_chunks_discarded() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TraceStats_BufferStats::set_has_chunks_discarded() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TraceStats_BufferStats::clear_has_chunks_discarded() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TraceStats_BufferStats::clear_chunks_discarded() {
  chunks_discarded_ = GOOGLE_ULONGLONG(0);
  clear_has_chunks_discarded();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::chunks_discarded() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.chunks_discarded)
  return chunks_discarded_;
}
inline void TraceStats_BufferStats::set_chunks_discarded(::google::protobuf::uint64 value) {
  set_has_chunks_discarded();
  chunks_discarded_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.chunks_discarded)
}

// optional uint64 chunks_read = 17;
inline bool TraceStats_BufferStats::has_chunks_read() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TraceStats_BufferStats::set_has_chunks_read() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TraceStats_BufferStats::clear_has_chunks_read() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TraceStats_BufferStats::clear_chunks_read() {
  chunks_read_ = GOOGLE_ULONGLONG(0);
  clear_has_chunks_read();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::chunks_read() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.chunks_read)
  return chunks_read_;
}
inline void TraceStats_BufferStats::set_chunks_read(::google::protobuf::uint64 value) {
  set_has_chunks_read();
  chunks_read_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.chunks_read)
}

// optional uint64 chunks_committed_out_of_order = 11;
inline bool TraceStats_BufferStats::has_chunks_committed_out_of_order() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TraceStats_BufferStats::set_has_chunks_committed_out_of_order() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TraceStats_BufferStats::clear_has_chunks_committed_out_of_order() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TraceStats_BufferStats::clear_chunks_committed_out_of_order() {
  chunks_committed_out_of_order_ = GOOGLE_ULONGLONG(0);
  clear_has_chunks_committed_out_of_order();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::chunks_committed_out_of_order() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.chunks_committed_out_of_order)
  return chunks_committed_out_of_order_;
}
inline void TraceStats_BufferStats::set_chunks_committed_out_of_order(::google::protobuf::uint64 value) {
  set_has_chunks_committed_out_of_order();
  chunks_committed_out_of_order_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.chunks_committed_out_of_order)
}

// optional uint64 write_wrap_count = 4;
inline bool TraceStats_BufferStats::has_write_wrap_count() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TraceStats_BufferStats::set_has_write_wrap_count() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TraceStats_BufferStats::clear_has_write_wrap_count() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TraceStats_BufferStats::clear_write_wrap_count() {
  write_wrap_count_ = GOOGLE_ULONGLONG(0);
  clear_has_write_wrap_count();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::write_wrap_count() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.write_wrap_count)
  return write_wrap_count_;
}
inline void TraceStats_BufferStats::set_write_wrap_count(::google::protobuf::uint64 value) {
  set_has_write_wrap_count();
  write_wrap_count_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.write_wrap_count)
}

// optional uint64 patches_succeeded = 5;
inline bool TraceStats_BufferStats::has_patches_succeeded() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TraceStats_BufferStats::set_has_patches_succeeded() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TraceStats_BufferStats::clear_has_patches_succeeded() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TraceStats_BufferStats::clear_patches_succeeded() {
  patches_succeeded_ = GOOGLE_ULONGLONG(0);
  clear_has_patches_succeeded();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::patches_succeeded() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.patches_succeeded)
  return patches_succeeded_;
}
inline void TraceStats_BufferStats::set_patches_succeeded(::google::protobuf::uint64 value) {
  set_has_patches_succeeded();
  patches_succeeded_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.patches_succeeded)
}

// optional uint64 patches_failed = 6;
inline bool TraceStats_BufferStats::has_patches_failed() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TraceStats_BufferStats::set_has_patches_failed() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TraceStats_BufferStats::clear_has_patches_failed() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TraceStats_BufferStats::clear_patches_failed() {
  patches_failed_ = GOOGLE_ULONGLONG(0);
  clear_has_patches_failed();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::patches_failed() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.patches_failed)
  return patches_failed_;
}
inline void TraceStats_BufferStats::set_patches_failed(::google::protobuf::uint64 value) {
  set_has_patches_failed();
  patches_failed_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.patches_failed)
}

// optional uint64 readaheads_succeeded = 7;
inline bool TraceStats_BufferStats::has_readaheads_succeeded() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TraceStats_BufferStats::set_has_readaheads_succeeded() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TraceStats_BufferStats::clear_has_readaheads_succeeded() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TraceStats_BufferStats::clear_readaheads_succeeded() {
  readaheads_succeeded_ = GOOGLE_ULONGLONG(0);
  clear_has_readaheads_succeeded();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::readaheads_succeeded() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.readaheads_succeeded)
  return readaheads_succeeded_;
}
inline void TraceStats_BufferStats::set_readaheads_succeeded(::google::protobuf::uint64 value) {
  set_has_readaheads_succeeded();
  readaheads_succeeded_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.readaheads_succeeded)
}

// optional uint64 readaheads_failed = 8;
inline bool TraceStats_BufferStats::has_readaheads_failed() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TraceStats_BufferStats::set_has_readaheads_failed() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TraceStats_BufferStats::clear_has_readaheads_failed() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TraceStats_BufferStats::clear_readaheads_failed() {
  readaheads_failed_ = GOOGLE_ULONGLONG(0);
  clear_has_readaheads_failed();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::readaheads_failed() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.readaheads_failed)
  return readaheads_failed_;
}
inline void TraceStats_BufferStats::set_readaheads_failed(::google::protobuf::uint64 value) {
  set_has_readaheads_failed();
  readaheads_failed_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.readaheads_failed)
}

// optional uint64 abi_violations = 9;
inline bool TraceStats_BufferStats::has_abi_violations() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TraceStats_BufferStats::set_has_abi_violations() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TraceStats_BufferStats::clear_has_abi_violations() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TraceStats_BufferStats::clear_abi_violations() {
  abi_violations_ = GOOGLE_ULONGLONG(0);
  clear_has_abi_violations();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::abi_violations() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.abi_violations)
  return abi_violations_;
}
inline void TraceStats_BufferStats::set_abi_violations(::google::protobuf::uint64 value) {
  set_has_abi_violations();
  abi_violations_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.abi_violations)
}

// optional uint64 trace_writer_packet_loss = 19;
inline bool TraceStats_BufferStats::has_trace_writer_packet_loss() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void TraceStats_BufferStats::set_has_trace_writer_packet_loss() {
  _has_bits_[0] |= 0x00040000u;
}
inline void TraceStats_BufferStats::clear_has_trace_writer_packet_loss() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void TraceStats_BufferStats::clear_trace_writer_packet_loss() {
  trace_writer_packet_loss_ = GOOGLE_ULONGLONG(0);
  clear_has_trace_writer_packet_loss();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::trace_writer_packet_loss() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.trace_writer_packet_loss)
  return trace_writer_packet_loss_;
}
inline void TraceStats_BufferStats::set_trace_writer_packet_loss(::google::protobuf::uint64 value) {
  set_has_trace_writer_packet_loss();
  trace_writer_packet_loss_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.trace_writer_packet_loss)
}

// -------------------------------------------------------------------

// TraceStats

// repeated .perfetto.protos.TraceStats.BufferStats buffer_stats = 1;
inline int TraceStats::buffer_stats_size() const {
  return buffer_stats_.size();
}
inline void TraceStats::clear_buffer_stats() {
  buffer_stats_.Clear();
}
inline const ::perfetto::protos::TraceStats_BufferStats& TraceStats::buffer_stats(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.buffer_stats)
  return buffer_stats_.Get(index);
}
inline ::perfetto::protos::TraceStats_BufferStats* TraceStats::mutable_buffer_stats(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceStats.buffer_stats)
  return buffer_stats_.Mutable(index);
}
inline ::perfetto::protos::TraceStats_BufferStats* TraceStats::add_buffer_stats() {
  // @@protoc_insertion_point(field_add:perfetto.protos.TraceStats.buffer_stats)
  return buffer_stats_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceStats_BufferStats >*
TraceStats::mutable_buffer_stats() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.TraceStats.buffer_stats)
  return &buffer_stats_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceStats_BufferStats >&
TraceStats::buffer_stats() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.TraceStats.buffer_stats)
  return buffer_stats_;
}

// optional uint32 producers_connected = 2;
inline bool TraceStats::has_producers_connected() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TraceStats::set_has_producers_connected() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TraceStats::clear_has_producers_connected() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TraceStats::clear_producers_connected() {
  producers_connected_ = 0u;
  clear_has_producers_connected();
}
inline ::google::protobuf::uint32 TraceStats::producers_connected() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.producers_connected)
  return producers_connected_;
}
inline void TraceStats::set_producers_connected(::google::protobuf::uint32 value) {
  set_has_producers_connected();
  producers_connected_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.producers_connected)
}

// optional uint64 producers_seen = 3;
inline bool TraceStats::has_producers_seen() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TraceStats::set_has_producers_seen() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TraceStats::clear_has_producers_seen() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TraceStats::clear_producers_seen() {
  producers_seen_ = GOOGLE_ULONGLONG(0);
  clear_has_producers_seen();
}
inline ::google::protobuf::uint64 TraceStats::producers_seen() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.producers_seen)
  return producers_seen_;
}
inline void TraceStats::set_producers_seen(::google::protobuf::uint64 value) {
  set_has_producers_seen();
  producers_seen_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.producers_seen)
}

// optional uint32 data_sources_registered = 4;
inline bool TraceStats::has_data_sources_registered() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TraceStats::set_has_data_sources_registered() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TraceStats::clear_has_data_sources_registered() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TraceStats::clear_data_sources_registered() {
  data_sources_registered_ = 0u;
  clear_has_data_sources_registered();
}
inline ::google::protobuf::uint32 TraceStats::data_sources_registered() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.data_sources_registered)
  return data_sources_registered_;
}
inline void TraceStats::set_data_sources_registered(::google::protobuf::uint32 value) {
  set_has_data_sources_registered();
  data_sources_registered_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.data_sources_registered)
}

// optional uint64 data_sources_seen = 5;
inline bool TraceStats::has_data_sources_seen() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TraceStats::set_has_data_sources_seen() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TraceStats::clear_has_data_sources_seen() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TraceStats::clear_data_sources_seen() {
  data_sources_seen_ = GOOGLE_ULONGLONG(0);
  clear_has_data_sources_seen();
}
inline ::google::protobuf::uint64 TraceStats::data_sources_seen() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.data_sources_seen)
  return data_sources_seen_;
}
inline void TraceStats::set_data_sources_seen(::google::protobuf::uint64 value) {
  set_has_data_sources_seen();
  data_sources_seen_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.data_sources_seen)
}

// optional uint32 tracing_sessions = 6;
inline bool TraceStats::has_tracing_sessions() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TraceStats::set_has_tracing_sessions() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TraceStats::clear_has_tracing_sessions() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TraceStats::clear_tracing_sessions() {
  tracing_sessions_ = 0u;
  clear_has_tracing_sessions();
}
inline ::google::protobuf::uint32 TraceStats::tracing_sessions() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.tracing_sessions)
  return tracing_sessions_;
}
inline void TraceStats::set_tracing_sessions(::google::protobuf::uint32 value) {
  set_has_tracing_sessions();
  tracing_sessions_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.tracing_sessions)
}

// optional uint32 total_buffers = 7;
inline bool TraceStats::has_total_buffers() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TraceStats::set_has_total_buffers() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TraceStats::clear_has_total_buffers() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TraceStats::clear_total_buffers() {
  total_buffers_ = 0u;
  clear_has_total_buffers();
}
inline ::google::protobuf::uint32 TraceStats::total_buffers() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.total_buffers)
  return total_buffers_;
}
inline void TraceStats::set_total_buffers(::google::protobuf::uint32 value) {
  set_has_total_buffers();
  total_buffers_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.total_buffers)
}

// optional uint64 chunks_discarded = 8;
inline bool TraceStats::has_chunks_discarded() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TraceStats::set_has_chunks_discarded() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TraceStats::clear_has_chunks_discarded() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TraceStats::clear_chunks_discarded() {
  chunks_discarded_ = GOOGLE_ULONGLONG(0);
  clear_has_chunks_discarded();
}
inline ::google::protobuf::uint64 TraceStats::chunks_discarded() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.chunks_discarded)
  return chunks_discarded_;
}
inline void TraceStats::set_chunks_discarded(::google::protobuf::uint64 value) {
  set_has_chunks_discarded();
  chunks_discarded_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.chunks_discarded)
}

// optional uint64 patches_discarded = 9;
inline bool TraceStats::has_patches_discarded() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TraceStats::set_has_patches_discarded() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TraceStats::clear_has_patches_discarded() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TraceStats::clear_patches_discarded() {
  patches_discarded_ = GOOGLE_ULONGLONG(0);
  clear_has_patches_discarded();
}
inline ::google::protobuf::uint64 TraceStats::patches_discarded() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.patches_discarded)
  return patches_discarded_;
}
inline void TraceStats::set_patches_discarded(::google::protobuf::uint64 value) {
  set_has_patches_discarded();
  patches_discarded_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.patches_discarded)
}

// optional uint64 invalid_packets = 10;
inline bool TraceStats::has_invalid_packets() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TraceStats::set_has_invalid_packets() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TraceStats::clear_has_invalid_packets() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TraceStats::clear_invalid_packets() {
  invalid_packets_ = GOOGLE_ULONGLONG(0);
  clear_has_invalid_packets();
}
inline ::google::protobuf::uint64 TraceStats::invalid_packets() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.invalid_packets)
  return invalid_packets_;
}
inline void TraceStats::set_invalid_packets(::google::protobuf::uint64 value) {
  set_has_invalid_packets();
  invalid_packets_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.invalid_packets)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2fcommon_2ftrace_5fstats_2eproto__INCLUDED
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/common/tracing_service_state.pb.h
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/common/data_source_descriptor.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/common/data_source_descriptor.proto

#ifndef PROTOBUF_protos_2fperfetto_2fcommon_2fdata_5fsource_5fdescriptor_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2fcommon_2fdata_5fsource_5fdescriptor_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// gen_amalgamated expanded: #include "protos/perfetto/common/gpu_counter_descriptor.pb.h"
// gen_amalgamated expanded: #include "protos/perfetto/common/track_event_descriptor.pb.h"
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2fcommon_2fdata_5fsource_5fdescriptor_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2fdata_5fsource_5fdescriptor_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2fdata_5fsource_5fdescriptor_2eproto();

class DataSourceDescriptor;

// ===================================================================

class DataSourceDescriptor : public ::google::protobuf::MessageLite {
 public:
  DataSourceDescriptor();
  virtual ~DataSourceDescriptor();

  DataSourceDescriptor(const DataSourceDescriptor& from);

  inline DataSourceDescriptor& operator=(const DataSourceDescriptor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const DataSourceDescriptor& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DataSourceDescriptor* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DataSourceDescriptor* other);

  // implements Message ----------------------------------------------

  inline DataSourceDescriptor* New() const { return New(NULL); }

  DataSourceDescriptor* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DataSourceDescriptor& from);
  void MergeFrom(const DataSourceDescriptor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DataSourceDescriptor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional bool will_notify_on_stop = 2;
  bool has_will_notify_on_stop() const;
  void clear_will_notify_on_stop();
  static const int kWillNotifyOnStopFieldNumber = 2;
  bool will_notify_on_stop() const;
  void set_will_notify_on_stop(bool value);

  // optional bool will_notify_on_start = 3;
  bool has_will_notify_on_start() const;
  void clear_will_notify_on_start();
  static const int kWillNotifyOnStartFieldNumber = 3;
  bool will_notify_on_start() const;
  void set_will_notify_on_start(bool value);

  // optional bool handles_incremental_state_clear = 4;
  bool has_handles_incremental_state_clear() const;
  void clear_handles_incremental_state_clear();
  static const int kHandlesIncrementalStateClearFieldNumber = 4;
  bool handles_incremental_state_clear() const;
  void set_handles_incremental_state_clear(bool value);

  // optional .perfetto.protos.GpuCounterDescriptor gpu_counter_descriptor = 5 [lazy = true];
  bool has_gpu_counter_descriptor() const;
  void clear_gpu_counter_descriptor();
  static const int kGpuCounterDescriptorFieldNumber = 5;
  const ::perfetto::protos::GpuCounterDescriptor& gpu_counter_descriptor() const;
  ::perfetto::protos::GpuCounterDescriptor* mutable_gpu_counter_descriptor();
  ::perfetto::protos::GpuCounterDescriptor* release_gpu_counter_descriptor();
  void set_allocated_gpu_counter_descriptor(::perfetto::protos::GpuCounterDescriptor* gpu_counter_descriptor);

  // optional .perfetto.protos.TrackEventDescriptor track_event_descriptor = 6 [lazy = true];
  bool has_track_event_descriptor() const;
  void clear_track_event_descriptor();
  static const int kTrackEventDescriptorFieldNumber = 6;
  const ::perfetto::protos::TrackEventDescriptor& track_event_descriptor() const;
  ::perfetto::protos::TrackEventDescriptor* mutable_track_event_descriptor();
  ::perfetto::protos::TrackEventDescriptor* release_track_event_descriptor();
  void set_allocated_track_event_descriptor(::perfetto::protos::TrackEventDescriptor* track_event_descriptor);

  // @@protoc_insertion_point(class_scope:perfetto.protos.DataSourceDescriptor)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_will_notify_on_stop();
  inline void clear_has_will_notify_on_stop();
  inline void set_has_will_notify_on_start();
  inline void clear_has_will_notify_on_start();
  inline void set_has_handles_incremental_state_clear();
  inline void clear_has_handles_incremental_state_clear();
  inline void set_has_gpu_counter_descriptor();
  inline void clear_has_gpu_counter_descriptor();
  inline void set_has_track_event_descriptor();
  inline void clear_has_track_event_descriptor();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::perfetto::protos::GpuCounterDescriptor* gpu_counter_descriptor_;
  ::perfetto::protos::TrackEventDescriptor* track_event_descriptor_;
  bool will_notify_on_stop_;
  bool will_notify_on_start_;
  bool handles_incremental_state_clear_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fdata_5fsource_5fdescriptor_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fdata_5fsource_5fdescriptor_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2fdata_5fsource_5fdescriptor_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2fdata_5fsource_5fdescriptor_2eproto();

  void InitAsDefaultInstance();
  static DataSourceDescriptor* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// DataSourceDescriptor

// optional string name = 1;
inline bool DataSourceDescriptor::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataSourceDescriptor::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataSourceDescriptor::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataSourceDescriptor::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& DataSourceDescriptor::name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceDescriptor.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DataSourceDescriptor::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.DataSourceDescriptor.name)
}
inline void DataSourceDescriptor::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.DataSourceDescriptor.name)
}
inline void DataSourceDescriptor::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.DataSourceDescriptor.name)
}
inline ::std::string* DataSourceDescriptor::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceDescriptor.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DataSourceDescriptor::release_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceDescriptor.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DataSourceDescriptor::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceDescriptor.name)
}

// optional bool will_notify_on_stop = 2;
inline bool DataSourceDescriptor::has_will_notify_on_stop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataSourceDescriptor::set_has_will_notify_on_stop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataSourceDescriptor::clear_has_will_notify_on_stop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataSourceDescriptor::clear_will_notify_on_stop() {
  will_notify_on_stop_ = false;
  clear_has_will_notify_on_stop();
}
inline bool DataSourceDescriptor::will_notify_on_stop() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceDescriptor.will_notify_on_stop)
  return will_notify_on_stop_;
}
inline void DataSourceDescriptor::set_will_notify_on_stop(bool value) {
  set_has_will_notify_on_stop();
  will_notify_on_stop_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.DataSourceDescriptor.will_notify_on_stop)
}

// optional bool will_notify_on_start = 3;
inline bool DataSourceDescriptor::has_will_notify_on_start() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DataSourceDescriptor::set_has_will_notify_on_start() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DataSourceDescriptor::clear_has_will_notify_on_start() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DataSourceDescriptor::clear_will_notify_on_start() {
  will_notify_on_start_ = false;
  clear_has_will_notify_on_start();
}
inline bool DataSourceDescriptor::will_notify_on_start() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceDescriptor.will_notify_on_start)
  return will_notify_on_start_;
}
inline void DataSourceDescriptor::set_will_notify_on_start(bool value) {
  set_has_will_notify_on_start();
  will_notify_on_start_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.DataSourceDescriptor.will_notify_on_start)
}

// optional bool handles_incremental_state_clear = 4;
inline bool DataSourceDescriptor::has_handles_incremental_state_clear() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DataSourceDescriptor::set_has_handles_incremental_state_clear() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DataSourceDescriptor::clear_has_handles_incremental_state_clear() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DataSourceDescriptor::clear_handles_incremental_state_clear() {
  handles_incremental_state_clear_ = false;
  clear_has_handles_incremental_state_clear();
}
inline bool DataSourceDescriptor::handles_incremental_state_clear() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceDescriptor.handles_incremental_state_clear)
  return handles_incremental_state_clear_;
}
inline void DataSourceDescriptor::set_handles_incremental_state_clear(bool value) {
  set_has_handles_incremental_state_clear();
  handles_incremental_state_clear_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.DataSourceDescriptor.handles_incremental_state_clear)
}

// optional .perfetto.protos.GpuCounterDescriptor gpu_counter_descriptor = 5 [lazy = true];
inline bool DataSourceDescriptor::has_gpu_counter_descriptor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DataSourceDescriptor::set_has_gpu_counter_descriptor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DataSourceDescriptor::clear_has_gpu_counter_descriptor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DataSourceDescriptor::clear_gpu_counter_descriptor() {
  if (gpu_counter_descriptor_ != NULL) gpu_counter_descriptor_->::perfetto::protos::GpuCounterDescriptor::Clear();
  clear_has_gpu_counter_descriptor();
}
inline const ::perfetto::protos::GpuCounterDescriptor& DataSourceDescriptor::gpu_counter_descriptor() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceDescriptor.gpu_counter_descriptor)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return gpu_counter_descriptor_ != NULL ? *gpu_counter_descriptor_ : *default_instance().gpu_counter_descriptor_;
#else
  return gpu_counter_descriptor_ != NULL ? *gpu_counter_descriptor_ : *default_instance_->gpu_counter_descriptor_;
#endif
}
inline ::perfetto::protos::GpuCounterDescriptor* DataSourceDescriptor::mutable_gpu_counter_descriptor() {
  set_has_gpu_counter_descriptor();
  if (gpu_counter_descriptor_ == NULL) {
    gpu_counter_descriptor_ = new ::perfetto::protos::GpuCounterDescriptor;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceDescriptor.gpu_counter_descriptor)
  return gpu_counter_descriptor_;
}
inline ::perfetto::protos::GpuCounterDescriptor* DataSourceDescriptor::release_gpu_counter_descriptor() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceDescriptor.gpu_counter_descriptor)
  clear_has_gpu_counter_descriptor();
  ::perfetto::protos::GpuCounterDescriptor* temp = gpu_counter_descriptor_;
  gpu_counter_descriptor_ = NULL;
  return temp;
}
inline void DataSourceDescriptor::set_allocated_gpu_counter_descriptor(::perfetto::protos::GpuCounterDescriptor* gpu_counter_descriptor) {
  delete gpu_counter_descriptor_;
  gpu_counter_descriptor_ = gpu_counter_descriptor;
  if (gpu_counter_descriptor) {
    set_has_gpu_counter_descriptor();
  } else {
    clear_has_gpu_counter_descriptor();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceDescriptor.gpu_counter_descriptor)
}

// optional .perfetto.protos.TrackEventDescriptor track_event_descriptor = 6 [lazy = true];
inline bool DataSourceDescriptor::has_track_event_descriptor() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DataSourceDescriptor::set_has_track_event_descriptor() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DataSourceDescriptor::clear_has_track_event_descriptor() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DataSourceDescriptor::clear_track_event_descriptor() {
  if (track_event_descriptor_ != NULL) track_event_descriptor_->::perfetto::protos::TrackEventDescriptor::Clear();
  clear_has_track_event_descriptor();
}
inline const ::perfetto::protos::TrackEventDescriptor& DataSourceDescriptor::track_event_descriptor() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceDescriptor.track_event_descriptor)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return track_event_descriptor_ != NULL ? *track_event_descriptor_ : *default_instance().track_event_descriptor_;
#else
  return track_event_descriptor_ != NULL ? *track_event_descriptor_ : *default_instance_->track_event_descriptor_;
#endif
}
inline ::perfetto::protos::TrackEventDescriptor* DataSourceDescriptor::mutable_track_event_descriptor() {
  set_has_track_event_descriptor();
  if (track_event_descriptor_ == NULL) {
    track_event_descriptor_ = new ::perfetto::protos::TrackEventDescriptor;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceDescriptor.track_event_descriptor)
  return track_event_descriptor_;
}
inline ::perfetto::protos::TrackEventDescriptor* DataSourceDescriptor::release_track_event_descriptor() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceDescriptor.track_event_descriptor)
  clear_has_track_event_descriptor();
  ::perfetto::protos::TrackEventDescriptor* temp = track_event_descriptor_;
  track_event_descriptor_ = NULL;
  return temp;
}
inline void DataSourceDescriptor::set_allocated_track_event_descriptor(::perfetto::protos::TrackEventDescriptor* track_event_descriptor) {
  delete track_event_descriptor_;
  track_event_descriptor_ = track_event_descriptor;
  if (track_event_descriptor) {
    set_has_track_event_descriptor();
  } else {
    clear_has_track_event_descriptor();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceDescriptor.track_event_descriptor)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2fcommon_2fdata_5fsource_5fdescriptor_2eproto__INCLUDED
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/common/tracing_service_state.proto

#ifndef PROTOBUF_protos_2fperfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// gen_amalgamated expanded: #include "protos/perfetto/common/data_source_descriptor.pb.h"
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto();

class TracingServiceState;
class TracingServiceState_DataSource;
class TracingServiceState_Producer;

// ===================================================================

class TracingServiceState_Producer : public ::google::protobuf::MessageLite {
 public:
  TracingServiceState_Producer();
  virtual ~TracingServiceState_Producer();

  TracingServiceState_Producer(const TracingServiceState_Producer& from);

  inline TracingServiceState_Producer& operator=(const TracingServiceState_Producer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TracingServiceState_Producer& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TracingServiceState_Producer* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TracingServiceState_Producer* other);

  // implements Message ----------------------------------------------

  inline TracingServiceState_Producer* New() const { return New(NULL); }

  TracingServiceState_Producer* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TracingServiceState_Producer& from);
  void MergeFrom(const TracingServiceState_Producer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TracingServiceState_Producer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional int32 uid = 3;
  bool has_uid() const;
  void clear_uid();
  static const int kUidFieldNumber = 3;
  ::google::protobuf::int32 uid() const;
  void set_uid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.TracingServiceState.Producer)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_uid();
  inline void clear_has_uid();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 uid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto();

  void InitAsDefaultInstance();
  static TracingServiceState_Producer* default_instance_;
};
// -------------------------------------------------------------------

class TracingServiceState_DataSource : public ::google::protobuf::MessageLite {
 public:
  TracingServiceState_DataSource();
  virtual ~TracingServiceState_DataSource();

  TracingServiceState_DataSource(const TracingServiceState_DataSource& from);

  inline TracingServiceState_DataSource& operator=(const TracingServiceState_DataSource& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TracingServiceState_DataSource& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TracingServiceState_DataSource* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TracingServiceState_DataSource* other);

  // implements Message ----------------------------------------------

  inline TracingServiceState_DataSource* New() const { return New(NULL); }

  TracingServiceState_DataSource* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TracingServiceState_DataSource& from);
  void MergeFrom(const TracingServiceState_DataSource& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TracingServiceState_DataSource* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .perfetto.protos.DataSourceDescriptor ds_descriptor = 1;
  bool has_ds_descriptor() const;
  void clear_ds_descriptor();
  static const int kDsDescriptorFieldNumber = 1;
  const ::perfetto::protos::DataSourceDescriptor& ds_descriptor() const;
  ::perfetto::protos::DataSourceDescriptor* mutable_ds_descriptor();
  ::perfetto::protos::DataSourceDescriptor* release_ds_descriptor();
  void set_allocated_ds_descriptor(::perfetto::protos::DataSourceDescriptor* ds_descriptor);

  // optional int32 producer_id = 2;
  bool has_producer_id() const;
  void clear_producer_id();
  static const int kProducerIdFieldNumber = 2;
  ::google::protobuf::int32 producer_id() const;
  void set_producer_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.TracingServiceState.DataSource)
 private:
  inline void set_has_ds_descriptor();
  inline void clear_has_ds_descriptor();
  inline void set_has_producer_id();
  inline void clear_has_producer_id();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::perfetto::protos::DataSourceDescriptor* ds_descriptor_;
  ::google::protobuf::int32 producer_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto();

  void InitAsDefaultInstance();
  static TracingServiceState_DataSource* default_instance_;
};
// -------------------------------------------------------------------

class TracingServiceState : public ::google::protobuf::MessageLite {
 public:
  TracingServiceState();
  virtual ~TracingServiceState();

  TracingServiceState(const TracingServiceState& from);

  inline TracingServiceState& operator=(const TracingServiceState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TracingServiceState& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TracingServiceState* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TracingServiceState* other);

  // implements Message ----------------------------------------------

  inline TracingServiceState* New() const { return New(NULL); }

  TracingServiceState* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TracingServiceState& from);
  void MergeFrom(const TracingServiceState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TracingServiceState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef TracingServiceState_Producer Producer;
  typedef TracingServiceState_DataSource DataSource;

  // accessors -------------------------------------------------------

  // repeated .perfetto.protos.TracingServiceState.Producer producers = 1;
  int producers_size() const;
  void clear_producers();
  static const int kProducersFieldNumber = 1;
  const ::perfetto::protos::TracingServiceState_Producer& producers(int index) const;
  ::perfetto::protos::TracingServiceState_Producer* mutable_producers(int index);
  ::perfetto::protos::TracingServiceState_Producer* add_producers();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TracingServiceState_Producer >*
      mutable_producers();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TracingServiceState_Producer >&
      producers() const;

  // repeated .perfetto.protos.TracingServiceState.DataSource data_sources = 2;
  int data_sources_size() const;
  void clear_data_sources();
  static const int kDataSourcesFieldNumber = 2;
  const ::perfetto::protos::TracingServiceState_DataSource& data_sources(int index) const;
  ::perfetto::protos::TracingServiceState_DataSource* mutable_data_sources(int index);
  ::perfetto::protos::TracingServiceState_DataSource* add_data_sources();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TracingServiceState_DataSource >*
      mutable_data_sources();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TracingServiceState_DataSource >&
      data_sources() const;

  // optional int32 num_sessions = 3;
  bool has_num_sessions() const;
  void clear_num_sessions();
  static const int kNumSessionsFieldNumber = 3;
  ::google::protobuf::int32 num_sessions() const;
  void set_num_sessions(::google::protobuf::int32 value);

  // optional int32 num_sessions_started = 4;
  bool has_num_sessions_started() const;
  void clear_num_sessions_started();
  static const int kNumSessionsStartedFieldNumber = 4;
  ::google::protobuf::int32 num_sessions_started() const;
  void set_num_sessions_started(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.TracingServiceState)
 private:
  inline void set_has_num_sessions();
  inline void clear_has_num_sessions();
  inline void set_has_num_sessions_started();
  inline void clear_has_num_sessions_started();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TracingServiceState_Producer > producers_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TracingServiceState_DataSource > data_sources_;
  ::google::protobuf::int32 num_sessions_;
  ::google::protobuf::int32 num_sessions_started_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto();

  void InitAsDefaultInstance();
  static TracingServiceState* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// TracingServiceState_Producer

// optional int32 id = 1;
inline bool TracingServiceState_Producer::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TracingServiceState_Producer::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TracingServiceState_Producer::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TracingServiceState_Producer::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 TracingServiceState_Producer::id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TracingServiceState.Producer.id)
  return id_;
}
inline void TracingServiceState_Producer::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TracingServiceState.Producer.id)
}

// optional string name = 2;
inline bool TracingServiceState_Producer::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TracingServiceState_Producer::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TracingServiceState_Producer::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TracingServiceState_Producer::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& TracingServiceState_Producer::name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TracingServiceState.Producer.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TracingServiceState_Producer::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.TracingServiceState.Producer.name)
}
inline void TracingServiceState_Producer::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.TracingServiceState.Producer.name)
}
inline void TracingServiceState_Producer::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.TracingServiceState.Producer.name)
}
inline ::std::string* TracingServiceState_Producer::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TracingServiceState.Producer.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TracingServiceState_Producer::release_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TracingServiceState.Producer.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TracingServiceState_Producer::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TracingServiceState.Producer.name)
}

// optional int32 uid = 3;
inline bool TracingServiceState_Producer::has_uid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TracingServiceState_Producer::set_has_uid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TracingServiceState_Producer::clear_has_uid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TracingServiceState_Producer::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 TracingServiceState_Producer::uid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TracingServiceState.Producer.uid)
  return uid_;
}
inline void TracingServiceState_Producer::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TracingServiceState.Producer.uid)
}

// -------------------------------------------------------------------

// TracingServiceState_DataSource

// optional .perfetto.protos.DataSourceDescriptor ds_descriptor = 1;
inline bool TracingServiceState_DataSource::has_ds_descriptor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TracingServiceState_DataSource::set_has_ds_descriptor() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TracingServiceState_DataSource::clear_has_ds_descriptor() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TracingServiceState_DataSource::clear_ds_descriptor() {
  if (ds_descriptor_ != NULL) ds_descriptor_->::perfetto::protos::DataSourceDescriptor::Clear();
  clear_has_ds_descriptor();
}
inline const ::perfetto::protos::DataSourceDescriptor& TracingServiceState_DataSource::ds_descriptor() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TracingServiceState.DataSource.ds_descriptor)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return ds_descriptor_ != NULL ? *ds_descriptor_ : *default_instance().ds_descriptor_;
#else
  return ds_descriptor_ != NULL ? *ds_descriptor_ : *default_instance_->ds_descriptor_;
#endif
}
inline ::perfetto::protos::DataSourceDescriptor* TracingServiceState_DataSource::mutable_ds_descriptor() {
  set_has_ds_descriptor();
  if (ds_descriptor_ == NULL) {
    ds_descriptor_ = new ::perfetto::protos::DataSourceDescriptor;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TracingServiceState.DataSource.ds_descriptor)
  return ds_descriptor_;
}
inline ::perfetto::protos::DataSourceDescriptor* TracingServiceState_DataSource::release_ds_descriptor() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TracingServiceState.DataSource.ds_descriptor)
  clear_has_ds_descriptor();
  ::perfetto::protos::DataSourceDescriptor* temp = ds_descriptor_;
  ds_descriptor_ = NULL;
  return temp;
}
inline void TracingServiceState_DataSource::set_allocated_ds_descriptor(::perfetto::protos::DataSourceDescriptor* ds_descriptor) {
  delete ds_descriptor_;
  ds_descriptor_ = ds_descriptor;
  if (ds_descriptor) {
    set_has_ds_descriptor();
  } else {
    clear_has_ds_descriptor();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TracingServiceState.DataSource.ds_descriptor)
}

// optional int32 producer_id = 2;
inline bool TracingServiceState_DataSource::has_producer_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TracingServiceState_DataSource::set_has_producer_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TracingServiceState_DataSource::clear_has_producer_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TracingServiceState_DataSource::clear_producer_id() {
  producer_id_ = 0;
  clear_has_producer_id();
}
inline ::google::protobuf::int32 TracingServiceState_DataSource::producer_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TracingServiceState.DataSource.producer_id)
  return producer_id_;
}
inline void TracingServiceState_DataSource::set_producer_id(::google::protobuf::int32 value) {
  set_has_producer_id();
  producer_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TracingServiceState.DataSource.producer_id)
}

// -------------------------------------------------------------------

// TracingServiceState

// repeated .perfetto.protos.TracingServiceState.Producer producers = 1;
inline int TracingServiceState::producers_size() const {
  return producers_.size();
}
inline void TracingServiceState::clear_producers() {
  producers_.Clear();
}
inline const ::perfetto::protos::TracingServiceState_Producer& TracingServiceState::producers(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TracingServiceState.producers)
  return producers_.Get(index);
}
inline ::perfetto::protos::TracingServiceState_Producer* TracingServiceState::mutable_producers(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TracingServiceState.producers)
  return producers_.Mutable(index);
}
inline ::perfetto::protos::TracingServiceState_Producer* TracingServiceState::add_producers() {
  // @@protoc_insertion_point(field_add:perfetto.protos.TracingServiceState.producers)
  return producers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TracingServiceState_Producer >*
TracingServiceState::mutable_producers() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.TracingServiceState.producers)
  return &producers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TracingServiceState_Producer >&
TracingServiceState::producers() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.TracingServiceState.producers)
  return producers_;
}

// repeated .perfetto.protos.TracingServiceState.DataSource data_sources = 2;
inline int TracingServiceState::data_sources_size() const {
  return data_sources_.size();
}
inline void TracingServiceState::clear_data_sources() {
  data_sources_.Clear();
}
inline const ::perfetto::protos::TracingServiceState_DataSource& TracingServiceState::data_sources(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TracingServiceState.data_sources)
  return data_sources_.Get(index);
}
inline ::perfetto::protos::TracingServiceState_DataSource* TracingServiceState::mutable_data_sources(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TracingServiceState.data_sources)
  return data_sources_.Mutable(index);
}
inline ::perfetto::protos::TracingServiceState_DataSource* TracingServiceState::add_data_sources() {
  // @@protoc_insertion_point(field_add:perfetto.protos.TracingServiceState.data_sources)
  return data_sources_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TracingServiceState_DataSource >*
TracingServiceState::mutable_data_sources() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.TracingServiceState.data_sources)
  return &data_sources_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TracingServiceState_DataSource >&
TracingServiceState::data_sources() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.TracingServiceState.data_sources)
  return data_sources_;
}

// optional int32 num_sessions = 3;
inline bool TracingServiceState::has_num_sessions() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TracingServiceState::set_has_num_sessions() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TracingServiceState::clear_has_num_sessions() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TracingServiceState::clear_num_sessions() {
  num_sessions_ = 0;
  clear_has_num_sessions();
}
inline ::google::protobuf::int32 TracingServiceState::num_sessions() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TracingServiceState.num_sessions)
  return num_sessions_;
}
inline void TracingServiceState::set_num_sessions(::google::protobuf::int32 value) {
  set_has_num_sessions();
  num_sessions_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TracingServiceState.num_sessions)
}

// optional int32 num_sessions_started = 4;
inline bool TracingServiceState::has_num_sessions_started() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TracingServiceState::set_has_num_sessions_started() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TracingServiceState::clear_has_num_sessions_started() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TracingServiceState::clear_num_sessions_started() {
  num_sessions_started_ = 0;
  clear_has_num_sessions_started();
}
inline ::google::protobuf::int32 TracingServiceState::num_sessions_started() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TracingServiceState.num_sessions_started)
  return num_sessions_started_;
}
inline void TracingServiceState::set_num_sessions_started(::google::protobuf::int32 value) {
  set_has_num_sessions_started();
  num_sessions_started_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TracingServiceState.num_sessions_started)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto__INCLUDED
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/common/track_event_descriptor.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/common/track_event_descriptor.proto

#ifndef PROTOBUF_protos_2fperfetto_2fcommon_2ftrack_5fevent_5fdescriptor_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2fcommon_2ftrack_5fevent_5fdescriptor_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2fcommon_2ftrack_5fevent_5fdescriptor_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2ftrack_5fevent_5fdescriptor_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2ftrack_5fevent_5fdescriptor_2eproto();

class TrackEventDescriptor;

// ===================================================================

class TrackEventDescriptor : public ::google::protobuf::MessageLite {
 public:
  TrackEventDescriptor();
  virtual ~TrackEventDescriptor();

  TrackEventDescriptor(const TrackEventDescriptor& from);

  inline TrackEventDescriptor& operator=(const TrackEventDescriptor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TrackEventDescriptor& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TrackEventDescriptor* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TrackEventDescriptor* other);

  // implements Message ----------------------------------------------

  inline TrackEventDescriptor* New() const { return New(NULL); }

  TrackEventDescriptor* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TrackEventDescriptor& from);
  void MergeFrom(const TrackEventDescriptor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TrackEventDescriptor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string available_categories = 1;
  int available_categories_size() const;
  void clear_available_categories();
  static const int kAvailableCategoriesFieldNumber = 1;
  const ::std::string& available_categories(int index) const;
  ::std::string* mutable_available_categories(int index);
  void set_available_categories(int index, const ::std::string& value);
  void set_available_categories(int index, const char* value);
  void set_available_categories(int index, const char* value, size_t size);
  ::std::string* add_available_categories();
  void add_available_categories(const ::std::string& value);
  void add_available_categories(const char* value);
  void add_available_categories(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& available_categories() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_available_categories();

  // @@protoc_insertion_point(class_scope:perfetto.protos.TrackEventDescriptor)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> available_categories_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2ftrack_5fevent_5fdescriptor_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2ftrack_5fevent_5fdescriptor_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2ftrack_5fevent_5fdescriptor_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2ftrack_5fevent_5fdescriptor_2eproto();

  void InitAsDefaultInstance();
  static TrackEventDescriptor* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// TrackEventDescriptor

// repeated string available_categories = 1;
inline int TrackEventDescriptor::available_categories_size() const {
  return available_categories_.size();
}
inline void TrackEventDescriptor::clear_available_categories() {
  available_categories_.Clear();
}
inline const ::std::string& TrackEventDescriptor::available_categories(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TrackEventDescriptor.available_categories)
  return available_categories_.Get(index);
}
inline ::std::string* TrackEventDescriptor::mutable_available_categories(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TrackEventDescriptor.available_categories)
  return available_categories_.Mutable(index);
}
inline void TrackEventDescriptor::set_available_categories(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.TrackEventDescriptor.available_categories)
  available_categories_.Mutable(index)->assign(value);
}
inline void TrackEventDescriptor::set_available_categories(int index, const char* value) {
  available_categories_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.TrackEventDescriptor.available_categories)
}
inline void TrackEventDescriptor::set_available_categories(int index, const char* value, size_t size) {
  available_categories_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.TrackEventDescriptor.available_categories)
}
inline ::std::string* TrackEventDescriptor::add_available_categories() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.TrackEventDescriptor.available_categories)
  return available_categories_.Add();
}
inline void TrackEventDescriptor::add_available_categories(const ::std::string& value) {
  available_categories_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.TrackEventDescriptor.available_categories)
}
inline void TrackEventDescriptor::add_available_categories(const char* value) {
  available_categories_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.TrackEventDescriptor.available_categories)
}
inline void TrackEventDescriptor::add_available_categories(const char* value, size_t size) {
  available_categories_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.TrackEventDescriptor.available_categories)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TrackEventDescriptor::available_categories() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.TrackEventDescriptor.available_categories)
  return available_categories_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TrackEventDescriptor::mutable_available_categories() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.TrackEventDescriptor.available_categories)
  return &available_categories_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2fcommon_2ftrack_5fevent_5fdescriptor_2eproto__INCLUDED
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/config/android/android_log_config.pb.h
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/common/android_log_constants.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/common/android_log_constants.proto

#ifndef PROTOBUF_protos_2fperfetto_2fcommon_2fandroid_5flog_5fconstants_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2fcommon_2fandroid_5flog_5fconstants_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2fcommon_2fandroid_5flog_5fconstants_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2fandroid_5flog_5fconstants_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2fandroid_5flog_5fconstants_2eproto();


enum AndroidLogId {
  LID_DEFAULT = 0,
  LID_RADIO = 1,
  LID_EVENTS = 2,
  LID_SYSTEM = 3,
  LID_CRASH = 4,
  LID_STATS = 5,
  LID_SECURITY = 6,
  LID_KERNEL = 7
};
bool AndroidLogId_IsValid(int value);
const AndroidLogId AndroidLogId_MIN = LID_DEFAULT;
const AndroidLogId AndroidLogId_MAX = LID_KERNEL;
const int AndroidLogId_ARRAYSIZE = AndroidLogId_MAX + 1;

enum AndroidLogPriority {
  PRIO_UNSPECIFIED = 0,
  PRIO_UNUSED = 1,
  PRIO_VERBOSE = 2,
  PRIO_DEBUG = 3,
  PRIO_INFO = 4,
  PRIO_WARN = 5,
  PRIO_ERROR = 6,
  PRIO_FATAL = 7
};
bool AndroidLogPriority_IsValid(int value);
const AndroidLogPriority AndroidLogPriority_MIN = PRIO_UNSPECIFIED;
const AndroidLogPriority AndroidLogPriority_MAX = PRIO_FATAL;
const int AndroidLogPriority_ARRAYSIZE = AndroidLogPriority_MAX + 1;

// ===================================================================


// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::perfetto::protos::AndroidLogId> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::perfetto::protos::AndroidLogPriority> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2fcommon_2fandroid_5flog_5fconstants_2eproto__INCLUDED
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/config/android/android_log_config.proto

#ifndef PROTOBUF_protos_2fperfetto_2fconfig_2fandroid_2fandroid_5flog_5fconfig_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2fconfig_2fandroid_2fandroid_5flog_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// gen_amalgamated expanded: #include "protos/perfetto/common/android_log_constants.pb.h"
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2fconfig_2fandroid_2fandroid_5flog_5fconfig_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2fandroid_2fandroid_5flog_5fconfig_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2fandroid_2fandroid_5flog_5fconfig_2eproto();

class AndroidLogConfig;

// ===================================================================

class AndroidLogConfig : public ::google::protobuf::MessageLite {
 public:
  AndroidLogConfig();
  virtual ~AndroidLogConfig();

  AndroidLogConfig(const AndroidLogConfig& from);

  inline AndroidLogConfig& operator=(const AndroidLogConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const AndroidLogConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AndroidLogConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AndroidLogConfig* other);

  // implements Message ----------------------------------------------

  inline AndroidLogConfig* New() const { return New(NULL); }

  AndroidLogConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AndroidLogConfig& from);
  void MergeFrom(const AndroidLogConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AndroidLogConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .perfetto.protos.AndroidLogId log_ids = 1;
  int log_ids_size() const;
  void clear_log_ids();
  static const int kLogIdsFieldNumber = 1;
  ::perfetto::protos::AndroidLogId log_ids(int index) const;
  void set_log_ids(int index, ::perfetto::protos::AndroidLogId value);
  void add_log_ids(::perfetto::protos::AndroidLogId value);
  const ::google::protobuf::RepeatedField<int>& log_ids() const;
  ::google::protobuf::RepeatedField<int>* mutable_log_ids();

  // optional .perfetto.protos.AndroidLogPriority min_prio = 3;
  bool has_min_prio() const;
  void clear_min_prio();
  static const int kMinPrioFieldNumber = 3;
  ::perfetto::protos::AndroidLogPriority min_prio() const;
  void set_min_prio(::perfetto::protos::AndroidLogPriority value);

  // repeated string filter_tags = 4;
  int filter_tags_size() const;
  void clear_filter_tags();
  static const int kFilterTagsFieldNumber = 4;
  const ::std::string& filter_tags(int index) const;
  ::std::string* mutable_filter_tags(int index);
  void set_filter_tags(int index, const ::std::string& value);
  void set_filter_tags(int index, const char* value);
  void set_filter_tags(int index, const char* value, size_t size);
  ::std::string* add_filter_tags();
  void add_filter_tags(const ::std::string& value);
  void add_filter_tags(const char* value);
  void add_filter_tags(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& filter_tags() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_filter_tags();

  // @@protoc_insertion_point(class_scope:perfetto.protos.AndroidLogConfig)
 private:
  inline void set_has_min_prio();
  inline void clear_has_min_prio();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField<int> log_ids_;
  ::google::protobuf::RepeatedPtrField< ::std::string> filter_tags_;
  int min_prio_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2fandroid_2fandroid_5flog_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2fandroid_2fandroid_5flog_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2fandroid_2fandroid_5flog_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2fandroid_2fandroid_5flog_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static AndroidLogConfig* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// AndroidLogConfig

// repeated .perfetto.protos.AndroidLogId log_ids = 1;
inline int AndroidLogConfig::log_ids_size() const {
  return log_ids_.size();
}
inline void AndroidLogConfig::clear_log_ids() {
  log_ids_.Clear();
}
inline ::perfetto::protos::AndroidLogId AndroidLogConfig::log_ids(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AndroidLogConfig.log_ids)
  return static_cast< ::perfetto::protos::AndroidLogId >(log_ids_.Get(index));
}
inline void AndroidLogConfig::set_log_ids(int index, ::perfetto::protos::AndroidLogId value) {
  assert(::perfetto::protos::AndroidLogId_IsValid(value));
  log_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.AndroidLogConfig.log_ids)
}
inline void AndroidLogConfig::add_log_ids(::perfetto::protos::AndroidLogId value) {
  assert(::perfetto::protos::AndroidLogId_IsValid(value));
  log_ids_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.AndroidLogConfig.log_ids)
}
inline const ::google::protobuf::RepeatedField<int>&
AndroidLogConfig::log_ids() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.AndroidLogConfig.log_ids)
  return log_ids_;
}
inline ::google::protobuf::RepeatedField<int>*
AndroidLogConfig::mutable_log_ids() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.AndroidLogConfig.log_ids)
  return &log_ids_;
}

// optional .perfetto.protos.AndroidLogPriority min_prio = 3;
inline bool AndroidLogConfig::has_min_prio() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AndroidLogConfig::set_has_min_prio() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AndroidLogConfig::clear_has_min_prio() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AndroidLogConfig::clear_min_prio() {
  min_prio_ = 0;
  clear_has_min_prio();
}
inline ::perfetto::protos::AndroidLogPriority AndroidLogConfig::min_prio() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AndroidLogConfig.min_prio)
  return static_cast< ::perfetto::protos::AndroidLogPriority >(min_prio_);
}
inline void AndroidLogConfig::set_min_prio(::perfetto::protos::AndroidLogPriority value) {
  assert(::perfetto::protos::AndroidLogPriority_IsValid(value));
  set_has_min_prio();
  min_prio_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.AndroidLogConfig.min_prio)
}

// repeated string filter_tags = 4;
inline int AndroidLogConfig::filter_tags_size() const {
  return filter_tags_.size();
}
inline void AndroidLogConfig::clear_filter_tags() {
  filter_tags_.Clear();
}
inline const ::std::string& AndroidLogConfig::filter_tags(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AndroidLogConfig.filter_tags)
  return filter_tags_.Get(index);
}
inline ::std::string* AndroidLogConfig::mutable_filter_tags(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.AndroidLogConfig.filter_tags)
  return filter_tags_.Mutable(index);
}
inline void AndroidLogConfig::set_filter_tags(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.AndroidLogConfig.filter_tags)
  filter_tags_.Mutable(index)->assign(value);
}
inline void AndroidLogConfig::set_filter_tags(int index, const char* value) {
  filter_tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.AndroidLogConfig.filter_tags)
}
inline void AndroidLogConfig::set_filter_tags(int index, const char* value, size_t size) {
  filter_tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.AndroidLogConfig.filter_tags)
}
inline ::std::string* AndroidLogConfig::add_filter_tags() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.AndroidLogConfig.filter_tags)
  return filter_tags_.Add();
}
inline void AndroidLogConfig::add_filter_tags(const ::std::string& value) {
  filter_tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.AndroidLogConfig.filter_tags)
}
inline void AndroidLogConfig::add_filter_tags(const char* value) {
  filter_tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.AndroidLogConfig.filter_tags)
}
inline void AndroidLogConfig::add_filter_tags(const char* value, size_t size) {
  filter_tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.AndroidLogConfig.filter_tags)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AndroidLogConfig::filter_tags() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.AndroidLogConfig.filter_tags)
  return filter_tags_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AndroidLogConfig::mutable_filter_tags() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.AndroidLogConfig.filter_tags)
  return &filter_tags_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2fconfig_2fandroid_2fandroid_5flog_5fconfig_2eproto__INCLUDED
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/config/android/packages_list_config.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/config/android/packages_list_config.proto

#ifndef PROTOBUF_protos_2fperfetto_2fconfig_2fandroid_2fpackages_5flist_5fconfig_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2fconfig_2fandroid_2fpackages_5flist_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2fconfig_2fandroid_2fpackages_5flist_5fconfig_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2fandroid_2fpackages_5flist_5fconfig_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2fandroid_2fpackages_5flist_5fconfig_2eproto();

class PackagesListConfig;

// ===================================================================

class PackagesListConfig : public ::google::protobuf::MessageLite {
 public:
  PackagesListConfig();
  virtual ~PackagesListConfig();

  PackagesListConfig(const PackagesListConfig& from);

  inline PackagesListConfig& operator=(const PackagesListConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const PackagesListConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PackagesListConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PackagesListConfig* other);

  // implements Message ----------------------------------------------

  inline PackagesListConfig* New() const { return New(NULL); }

  PackagesListConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PackagesListConfig& from);
  void MergeFrom(const PackagesListConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PackagesListConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string package_name_filter = 1;
  int package_name_filter_size() const;
  void clear_package_name_filter();
  static const int kPackageNameFilterFieldNumber = 1;
  const ::std::string& package_name_filter(int index) const;
  ::std::string* mutable_package_name_filter(int index);
  void set_package_name_filter(int index, const ::std::string& value);
  void set_package_name_filter(int index, const char* value);
  void set_package_name_filter(int index, const char* value, size_t size);
  ::std::string* add_package_name_filter();
  void add_package_name_filter(const ::std::string& value);
  void add_package_name_filter(const char* value);
  void add_package_name_filter(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& package_name_filter() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_package_name_filter();

  // @@protoc_insertion_point(class_scope:perfetto.protos.PackagesListConfig)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> package_name_filter_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2fandroid_2fpackages_5flist_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2fandroid_2fpackages_5flist_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2fandroid_2fpackages_5flist_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2fandroid_2fpackages_5flist_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static PackagesListConfig* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// PackagesListConfig

// repeated string package_name_filter = 1;
inline int PackagesListConfig::package_name_filter_size() const {
  return package_name_filter_.size();
}
inline void PackagesListConfig::clear_package_name_filter() {
  package_name_filter_.Clear();
}
inline const ::std::string& PackagesListConfig::package_name_filter(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.PackagesListConfig.package_name_filter)
  return package_name_filter_.Get(index);
}
inline ::std::string* PackagesListConfig::mutable_package_name_filter(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.PackagesListConfig.package_name_filter)
  return package_name_filter_.Mutable(index);
}
inline void PackagesListConfig::set_package_name_filter(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.PackagesListConfig.package_name_filter)
  package_name_filter_.Mutable(index)->assign(value);
}
inline void PackagesListConfig::set_package_name_filter(int index, const char* value) {
  package_name_filter_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.PackagesListConfig.package_name_filter)
}
inline void PackagesListConfig::set_package_name_filter(int index, const char* value, size_t size) {
  package_name_filter_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.PackagesListConfig.package_name_filter)
}
inline ::std::string* PackagesListConfig::add_package_name_filter() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.PackagesListConfig.package_name_filter)
  return package_name_filter_.Add();
}
inline void PackagesListConfig::add_package_name_filter(const ::std::string& value) {
  package_name_filter_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.PackagesListConfig.package_name_filter)
}
inline void PackagesListConfig::add_package_name_filter(const char* value) {
  package_name_filter_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.PackagesListConfig.package_name_filter)
}
inline void PackagesListConfig::add_package_name_filter(const char* value, size_t size) {
  package_name_filter_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.PackagesListConfig.package_name_filter)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PackagesListConfig::package_name_filter() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.PackagesListConfig.package_name_filter)
  return package_name_filter_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PackagesListConfig::mutable_package_name_filter() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.PackagesListConfig.package_name_filter)
  return &package_name_filter_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2fconfig_2fandroid_2fpackages_5flist_5fconfig_2eproto__INCLUDED
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/config/ftrace/ftrace_config.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/config/ftrace/ftrace_config.proto

#ifndef PROTOBUF_protos_2fperfetto_2fconfig_2fftrace_2fftrace_5fconfig_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2fconfig_2fftrace_2fftrace_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2fconfig_2fftrace_2fftrace_5fconfig_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2fftrace_2fftrace_5fconfig_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2fftrace_2fftrace_5fconfig_2eproto();

class FtraceConfig;

// ===================================================================

class FtraceConfig : public ::google::protobuf::MessageLite {
 public:
  FtraceConfig();
  virtual ~FtraceConfig();

  FtraceConfig(const FtraceConfig& from);

  inline FtraceConfig& operator=(const FtraceConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const FtraceConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FtraceConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FtraceConfig* other);

  // implements Message ----------------------------------------------

  inline FtraceConfig* New() const { return New(NULL); }

  FtraceConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FtraceConfig& from);
  void MergeFrom(const FtraceConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FtraceConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string ftrace_events = 1;
  int ftrace_events_size() const;
  void clear_ftrace_events();
  static const int kFtraceEventsFieldNumber = 1;
  const ::std::string& ftrace_events(int index) const;
  ::std::string* mutable_ftrace_events(int index);
  void set_ftrace_events(int index, const ::std::string& value);
  void set_ftrace_events(int index, const char* value);
  void set_ftrace_events(int index, const char* value, size_t size);
  ::std::string* add_ftrace_events();
  void add_ftrace_events(const ::std::string& value);
  void add_ftrace_events(const char* value);
  void add_ftrace_events(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& ftrace_events() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_ftrace_events();

  // repeated string atrace_categories = 2;
  int atrace_categories_size() const;
  void clear_atrace_categories();
  static const int kAtraceCategoriesFieldNumber = 2;
  const ::std::string& atrace_categories(int index) const;
  ::std::string* mutable_atrace_categories(int index);
  void set_atrace_categories(int index, const ::std::string& value);
  void set_atrace_categories(int index, const char* value);
  void set_atrace_categories(int index, const char* value, size_t size);
  ::std::string* add_atrace_categories();
  void add_atrace_categories(const ::std::string& value);
  void add_atrace_categories(const char* value);
  void add_atrace_categories(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& atrace_categories() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_atrace_categories();

  // repeated string atrace_apps = 3;
  int atrace_apps_size() const;
  void clear_atrace_apps();
  static const int kAtraceAppsFieldNumber = 3;
  const ::std::string& atrace_apps(int index) const;
  ::std::string* mutable_atrace_apps(int index);
  void set_atrace_apps(int index, const ::std::string& value);
  void set_atrace_apps(int index, const char* value);
  void set_atrace_apps(int index, const char* value, size_t size);
  ::std::string* add_atrace_apps();
  void add_atrace_apps(const ::std::string& value);
  void add_atrace_apps(const char* value);
  void add_atrace_apps(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& atrace_apps() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_atrace_apps();

  // optional uint32 buffer_size_kb = 10;
  bool has_buffer_size_kb() const;
  void clear_buffer_size_kb();
  static const int kBufferSizeKbFieldNumber = 10;
  ::google::protobuf::uint32 buffer_size_kb() const;
  void set_buffer_size_kb(::google::protobuf::uint32 value);

  // optional uint32 drain_period_ms = 11;
  bool has_drain_period_ms() const;
  void clear_drain_period_ms();
  static const int kDrainPeriodMsFieldNumber = 11;
  ::google::protobuf::uint32 drain_period_ms() const;
  void set_drain_period_ms(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.FtraceConfig)
 private:
  inline void set_has_buffer_size_kb();
  inline void clear_has_buffer_size_kb();
  inline void set_has_drain_period_ms();
  inline void clear_has_drain_period_ms();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> ftrace_events_;
  ::google::protobuf::RepeatedPtrField< ::std::string> atrace_categories_;
  ::google::protobuf::RepeatedPtrField< ::std::string> atrace_apps_;
  ::google::protobuf::uint32 buffer_size_kb_;
  ::google::protobuf::uint32 drain_period_ms_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2fftrace_2fftrace_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2fftrace_2fftrace_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2fftrace_2fftrace_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2fftrace_2fftrace_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static FtraceConfig* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// FtraceConfig

// repeated string ftrace_events = 1;
inline int FtraceConfig::ftrace_events_size() const {
  return ftrace_events_.size();
}
inline void FtraceConfig::clear_ftrace_events() {
  ftrace_events_.Clear();
}
inline const ::std::string& FtraceConfig::ftrace_events(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FtraceConfig.ftrace_events)
  return ftrace_events_.Get(index);
}
inline ::std::string* FtraceConfig::mutable_ftrace_events(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.FtraceConfig.ftrace_events)
  return ftrace_events_.Mutable(index);
}
inline void FtraceConfig::set_ftrace_events(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.FtraceConfig.ftrace_events)
  ftrace_events_.Mutable(index)->assign(value);
}
inline void FtraceConfig::set_ftrace_events(int index, const char* value) {
  ftrace_events_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.FtraceConfig.ftrace_events)
}
inline void FtraceConfig::set_ftrace_events(int index, const char* value, size_t size) {
  ftrace_events_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.FtraceConfig.ftrace_events)
}
inline ::std::string* FtraceConfig::add_ftrace_events() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.FtraceConfig.ftrace_events)
  return ftrace_events_.Add();
}
inline void FtraceConfig::add_ftrace_events(const ::std::string& value) {
  ftrace_events_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.FtraceConfig.ftrace_events)
}
inline void FtraceConfig::add_ftrace_events(const char* value) {
  ftrace_events_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.FtraceConfig.ftrace_events)
}
inline void FtraceConfig::add_ftrace_events(const char* value, size_t size) {
  ftrace_events_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.FtraceConfig.ftrace_events)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FtraceConfig::ftrace_events() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.FtraceConfig.ftrace_events)
  return ftrace_events_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FtraceConfig::mutable_ftrace_events() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.FtraceConfig.ftrace_events)
  return &ftrace_events_;
}

// repeated string atrace_categories = 2;
inline int FtraceConfig::atrace_categories_size() const {
  return atrace_categories_.size();
}
inline void FtraceConfig::clear_atrace_categories() {
  atrace_categories_.Clear();
}
inline const ::std::string& FtraceConfig::atrace_categories(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FtraceConfig.atrace_categories)
  return atrace_categories_.Get(index);
}
inline ::std::string* FtraceConfig::mutable_atrace_categories(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.FtraceConfig.atrace_categories)
  return atrace_categories_.Mutable(index);
}
inline void FtraceConfig::set_atrace_categories(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.FtraceConfig.atrace_categories)
  atrace_categories_.Mutable(index)->assign(value);
}
inline void FtraceConfig::set_atrace_categories(int index, const char* value) {
  atrace_categories_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.FtraceConfig.atrace_categories)
}
inline void FtraceConfig::set_atrace_categories(int index, const char* value, size_t size) {
  atrace_categories_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.FtraceConfig.atrace_categories)
}
inline ::std::string* FtraceConfig::add_atrace_categories() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.FtraceConfig.atrace_categories)
  return atrace_categories_.Add();
}
inline void FtraceConfig::add_atrace_categories(const ::std::string& value) {
  atrace_categories_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.FtraceConfig.atrace_categories)
}
inline void FtraceConfig::add_atrace_categories(const char* value) {
  atrace_categories_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.FtraceConfig.atrace_categories)
}
inline void FtraceConfig::add_atrace_categories(const char* value, size_t size) {
  atrace_categories_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.FtraceConfig.atrace_categories)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FtraceConfig::atrace_categories() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.FtraceConfig.atrace_categories)
  return atrace_categories_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FtraceConfig::mutable_atrace_categories() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.FtraceConfig.atrace_categories)
  return &atrace_categories_;
}

// repeated string atrace_apps = 3;
inline int FtraceConfig::atrace_apps_size() const {
  return atrace_apps_.size();
}
inline void FtraceConfig::clear_atrace_apps() {
  atrace_apps_.Clear();
}
inline const ::std::string& FtraceConfig::atrace_apps(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FtraceConfig.atrace_apps)
  return atrace_apps_.Get(index);
}
inline ::std::string* FtraceConfig::mutable_atrace_apps(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.FtraceConfig.atrace_apps)
  return atrace_apps_.Mutable(index);
}
inline void FtraceConfig::set_atrace_apps(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.FtraceConfig.atrace_apps)
  atrace_apps_.Mutable(index)->assign(value);
}
inline void FtraceConfig::set_atrace_apps(int index, const char* value) {
  atrace_apps_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.FtraceConfig.atrace_apps)
}
inline void FtraceConfig::set_atrace_apps(int index, const char* value, size_t size) {
  atrace_apps_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.FtraceConfig.atrace_apps)
}
inline ::std::string* FtraceConfig::add_atrace_apps() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.FtraceConfig.atrace_apps)
  return atrace_apps_.Add();
}
inline void FtraceConfig::add_atrace_apps(const ::std::string& value) {
  atrace_apps_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.FtraceConfig.atrace_apps)
}
inline void FtraceConfig::add_atrace_apps(const char* value) {
  atrace_apps_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.FtraceConfig.atrace_apps)
}
inline void FtraceConfig::add_atrace_apps(const char* value, size_t size) {
  atrace_apps_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.FtraceConfig.atrace_apps)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FtraceConfig::atrace_apps() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.FtraceConfig.atrace_apps)
  return atrace_apps_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FtraceConfig::mutable_atrace_apps() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.FtraceConfig.atrace_apps)
  return &atrace_apps_;
}

// optional uint32 buffer_size_kb = 10;
inline bool FtraceConfig::has_buffer_size_kb() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FtraceConfig::set_has_buffer_size_kb() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FtraceConfig::clear_has_buffer_size_kb() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FtraceConfig::clear_buffer_size_kb() {
  buffer_size_kb_ = 0u;
  clear_has_buffer_size_kb();
}
inline ::google::protobuf::uint32 FtraceConfig::buffer_size_kb() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FtraceConfig.buffer_size_kb)
  return buffer_size_kb_;
}
inline void FtraceConfig::set_buffer_size_kb(::google::protobuf::uint32 value) {
  set_has_buffer_size_kb();
  buffer_size_kb_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.FtraceConfig.buffer_size_kb)
}

// optional uint32 drain_period_ms = 11;
inline bool FtraceConfig::has_drain_period_ms() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FtraceConfig::set_has_drain_period_ms() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FtraceConfig::clear_has_drain_period_ms() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FtraceConfig::clear_drain_period_ms() {
  drain_period_ms_ = 0u;
  clear_has_drain_period_ms();
}
inline ::google::protobuf::uint32 FtraceConfig::drain_period_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FtraceConfig.drain_period_ms)
  return drain_period_ms_;
}
inline void FtraceConfig::set_drain_period_ms(::google::protobuf::uint32 value) {
  set_has_drain_period_ms();
  drain_period_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.FtraceConfig.drain_period_ms)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2fconfig_2fftrace_2fftrace_5fconfig_2eproto__INCLUDED
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/config/gpu/gpu_counter_config.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/config/gpu/gpu_counter_config.proto

#ifndef PROTOBUF_protos_2fperfetto_2fconfig_2fgpu_2fgpu_5fcounter_5fconfig_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2fconfig_2fgpu_2fgpu_5fcounter_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2fconfig_2fgpu_2fgpu_5fcounter_5fconfig_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2fgpu_2fgpu_5fcounter_5fconfig_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2fgpu_2fgpu_5fcounter_5fconfig_2eproto();

class GpuCounterConfig;

// ===================================================================

class GpuCounterConfig : public ::google::protobuf::MessageLite {
 public:
  GpuCounterConfig();
  virtual ~GpuCounterConfig();

  GpuCounterConfig(const GpuCounterConfig& from);

  inline GpuCounterConfig& operator=(const GpuCounterConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const GpuCounterConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GpuCounterConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GpuCounterConfig* other);

  // implements Message ----------------------------------------------

  inline GpuCounterConfig* New() const { return New(NULL); }

  GpuCounterConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GpuCounterConfig& from);
  void MergeFrom(const GpuCounterConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GpuCounterConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 counter_period_ns = 1;
  bool has_counter_period_ns() const;
  void clear_counter_period_ns();
  static const int kCounterPeriodNsFieldNumber = 1;
  ::google::protobuf::uint64 counter_period_ns() const;
  void set_counter_period_ns(::google::protobuf::uint64 value);

  // repeated uint32 counter_ids = 2;
  int counter_ids_size() const;
  void clear_counter_ids();
  static const int kCounterIdsFieldNumber = 2;
  ::google::protobuf::uint32 counter_ids(int index) const;
  void set_counter_ids(int index, ::google::protobuf::uint32 value);
  void add_counter_ids(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      counter_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_counter_ids();

  // optional bool instrumented_sampling = 3;
  bool has_instrumented_sampling() const;
  void clear_instrumented_sampling();
  static const int kInstrumentedSamplingFieldNumber = 3;
  bool instrumented_sampling() const;
  void set_instrumented_sampling(bool value);

  // optional bool fix_gpu_clock = 4;
  bool has_fix_gpu_clock() const;
  void clear_fix_gpu_clock();
  static const int kFixGpuClockFieldNumber = 4;
  bool fix_gpu_clock() const;
  void set_fix_gpu_clock(bool value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.GpuCounterConfig)
 private:
  inline void set_has_counter_period_ns();
  inline void clear_has_counter_period_ns();
  inline void set_has_instrumented_sampling();
  inline void clear_has_instrumented_sampling();
  inline void set_has_fix_gpu_clock();
  inline void clear_has_fix_gpu_clock();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 counter_period_ns_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > counter_ids_;
  bool instrumented_sampling_;
  bool fix_gpu_clock_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2fgpu_2fgpu_5fcounter_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2fgpu_2fgpu_5fcounter_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2fgpu_2fgpu_5fcounter_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2fgpu_2fgpu_5fcounter_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static GpuCounterConfig* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// GpuCounterConfig

// optional uint64 counter_period_ns = 1;
inline bool GpuCounterConfig::has_counter_period_ns() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GpuCounterConfig::set_has_counter_period_ns() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GpuCounterConfig::clear_has_counter_period_ns() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GpuCounterConfig::clear_counter_period_ns() {
  counter_period_ns_ = GOOGLE_ULONGLONG(0);
  clear_has_counter_period_ns();
}
inline ::google::protobuf::uint64 GpuCounterConfig::counter_period_ns() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterConfig.counter_period_ns)
  return counter_period_ns_;
}
inline void GpuCounterConfig::set_counter_period_ns(::google::protobuf::uint64 value) {
  set_has_counter_period_ns();
  counter_period_ns_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.GpuCounterConfig.counter_period_ns)
}

// repeated uint32 counter_ids = 2;
inline int GpuCounterConfig::counter_ids_size() const {
  return counter_ids_.size();
}
inline void GpuCounterConfig::clear_counter_ids() {
  counter_ids_.Clear();
}
inline ::google::protobuf::uint32 GpuCounterConfig::counter_ids(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterConfig.counter_ids)
  return counter_ids_.Get(index);
}
inline void GpuCounterConfig::set_counter_ids(int index, ::google::protobuf::uint32 value) {
  counter_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.GpuCounterConfig.counter_ids)
}
inline void GpuCounterConfig::add_counter_ids(::google::protobuf::uint32 value) {
  counter_ids_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.GpuCounterConfig.counter_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
GpuCounterConfig::counter_ids() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.GpuCounterConfig.counter_ids)
  return counter_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
GpuCounterConfig::mutable_counter_ids() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.GpuCounterConfig.counter_ids)
  return &counter_ids_;
}

// optional bool instrumented_sampling = 3;
inline bool GpuCounterConfig::has_instrumented_sampling() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GpuCounterConfig::set_has_instrumented_sampling() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GpuCounterConfig::clear_has_instrumented_sampling() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GpuCounterConfig::clear_instrumented_sampling() {
  instrumented_sampling_ = false;
  clear_has_instrumented_sampling();
}
inline bool GpuCounterConfig::instrumented_sampling() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterConfig.instrumented_sampling)
  return instrumented_sampling_;
}
inline void GpuCounterConfig::set_instrumented_sampling(bool value) {
  set_has_instrumented_sampling();
  instrumented_sampling_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.GpuCounterConfig.instrumented_sampling)
}

// optional bool fix_gpu_clock = 4;
inline bool GpuCounterConfig::has_fix_gpu_clock() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GpuCounterConfig::set_has_fix_gpu_clock() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GpuCounterConfig::clear_has_fix_gpu_clock() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GpuCounterConfig::clear_fix_gpu_clock() {
  fix_gpu_clock_ = false;
  clear_has_fix_gpu_clock();
}
inline bool GpuCounterConfig::fix_gpu_clock() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterConfig.fix_gpu_clock)
  return fix_gpu_clock_;
}
inline void GpuCounterConfig::set_fix_gpu_clock(bool value) {
  set_has_fix_gpu_clock();
  fix_gpu_clock_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.GpuCounterConfig.fix_gpu_clock)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2fconfig_2fgpu_2fgpu_5fcounter_5fconfig_2eproto__INCLUDED
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/config/inode_file/inode_file_config.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/config/inode_file/inode_file_config.proto

#ifndef PROTOBUF_protos_2fperfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto();

class InodeFileConfig;
class InodeFileConfig_MountPointMappingEntry;

// ===================================================================

class InodeFileConfig_MountPointMappingEntry : public ::google::protobuf::MessageLite {
 public:
  InodeFileConfig_MountPointMappingEntry();
  virtual ~InodeFileConfig_MountPointMappingEntry();

  InodeFileConfig_MountPointMappingEntry(const InodeFileConfig_MountPointMappingEntry& from);

  inline InodeFileConfig_MountPointMappingEntry& operator=(const InodeFileConfig_MountPointMappingEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const InodeFileConfig_MountPointMappingEntry& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const InodeFileConfig_MountPointMappingEntry* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(InodeFileConfig_MountPointMappingEntry* other);

  // implements Message ----------------------------------------------

  inline InodeFileConfig_MountPointMappingEntry* New() const { return New(NULL); }

  InodeFileConfig_MountPointMappingEntry* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const InodeFileConfig_MountPointMappingEntry& from);
  void MergeFrom(const InodeFileConfig_MountPointMappingEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InodeFileConfig_MountPointMappingEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string mountpoint = 1;
  bool has_mountpoint() const;
  void clear_mountpoint();
  static const int kMountpointFieldNumber = 1;
  const ::std::string& mountpoint() const;
  void set_mountpoint(const ::std::string& value);
  void set_mountpoint(const char* value);
  void set_mountpoint(const char* value, size_t size);
  ::std::string* mutable_mountpoint();
  ::std::string* release_mountpoint();
  void set_allocated_mountpoint(::std::string* mountpoint);

  // repeated string scan_roots = 2;
  int scan_roots_size() const;
  void clear_scan_roots();
  static const int kScanRootsFieldNumber = 2;
  const ::std::string& scan_roots(int index) const;
  ::std::string* mutable_scan_roots(int index);
  void set_scan_roots(int index, const ::std::string& value);
  void set_scan_roots(int index, const char* value);
  void set_scan_roots(int index, const char* value, size_t size);
  ::std::string* add_scan_roots();
  void add_scan_roots(const ::std::string& value);
  void add_scan_roots(const char* value);
  void add_scan_roots(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& scan_roots() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_scan_roots();

  // @@protoc_insertion_point(class_scope:perfetto.protos.InodeFileConfig.MountPointMappingEntry)
 private:
  inline void set_has_mountpoint();
  inline void clear_has_mountpoint();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr mountpoint_;
  ::google::protobuf::RepeatedPtrField< ::std::string> scan_roots_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static InodeFileConfig_MountPointMappingEntry* default_instance_;
};
// -------------------------------------------------------------------

class InodeFileConfig : public ::google::protobuf::MessageLite {
 public:
  InodeFileConfig();
  virtual ~InodeFileConfig();

  InodeFileConfig(const InodeFileConfig& from);

  inline InodeFileConfig& operator=(const InodeFileConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const InodeFileConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const InodeFileConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(InodeFileConfig* other);

  // implements Message ----------------------------------------------

  inline InodeFileConfig* New() const { return New(NULL); }

  InodeFileConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const InodeFileConfig& from);
  void MergeFrom(const InodeFileConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InodeFileConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef InodeFileConfig_MountPointMappingEntry MountPointMappingEntry;

  // accessors -------------------------------------------------------

  // optional uint32 scan_interval_ms = 1;
  bool has_scan_interval_ms() const;
  void clear_scan_interval_ms();
  static const int kScanIntervalMsFieldNumber = 1;
  ::google::protobuf::uint32 scan_interval_ms() const;
  void set_scan_interval_ms(::google::protobuf::uint32 value);

  // optional uint32 scan_delay_ms = 2;
  bool has_scan_delay_ms() const;
  void clear_scan_delay_ms();
  static const int kScanDelayMsFieldNumber = 2;
  ::google::protobuf::uint32 scan_delay_ms() const;
  void set_scan_delay_ms(::google::protobuf::uint32 value);

  // optional uint32 scan_batch_size = 3;
  bool has_scan_batch_size() const;
  void clear_scan_batch_size();
  static const int kScanBatchSizeFieldNumber = 3;
  ::google::protobuf::uint32 scan_batch_size() const;
  void set_scan_batch_size(::google::protobuf::uint32 value);

  // optional bool do_not_scan = 4;
  bool has_do_not_scan() const;
  void clear_do_not_scan();
  static const int kDoNotScanFieldNumber = 4;
  bool do_not_scan() const;
  void set_do_not_scan(bool value);

  // repeated string scan_mount_points = 5;
  int scan_mount_points_size() const;
  void clear_scan_mount_points();
  static const int kScanMountPointsFieldNumber = 5;
  const ::std::string& scan_mount_points(int index) const;
  ::std::string* mutable_scan_mount_points(int index);
  void set_scan_mount_points(int index, const ::std::string& value);
  void set_scan_mount_points(int index, const char* value);
  void set_scan_mount_points(int index, const char* value, size_t size);
  ::std::string* add_scan_mount_points();
  void add_scan_mount_points(const ::std::string& value);
  void add_scan_mount_points(const char* value);
  void add_scan_mount_points(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& scan_mount_points() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_scan_mount_points();

  // repeated .perfetto.protos.InodeFileConfig.MountPointMappingEntry mount_point_mapping = 6;
  int mount_point_mapping_size() const;
  void clear_mount_point_mapping();
  static const int kMountPointMappingFieldNumber = 6;
  const ::perfetto::protos::InodeFileConfig_MountPointMappingEntry& mount_point_mapping(int index) const;
  ::perfetto::protos::InodeFileConfig_MountPointMappingEntry* mutable_mount_point_mapping(int index);
  ::perfetto::protos::InodeFileConfig_MountPointMappingEntry* add_mount_point_mapping();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::InodeFileConfig_MountPointMappingEntry >*
      mutable_mount_point_mapping();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::InodeFileConfig_MountPointMappingEntry >&
      mount_point_mapping() const;

  // @@protoc_insertion_point(class_scope:perfetto.protos.InodeFileConfig)
 private:
  inline void set_has_scan_interval_ms();
  inline void clear_has_scan_interval_ms();
  inline void set_has_scan_delay_ms();
  inline void clear_has_scan_delay_ms();
  inline void set_has_scan_batch_size();
  inline void clear_has_scan_batch_size();
  inline void set_has_do_not_scan();
  inline void clear_has_do_not_scan();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 scan_interval_ms_;
  ::google::protobuf::uint32 scan_delay_ms_;
  ::google::protobuf::uint32 scan_batch_size_;
  bool do_not_scan_;
  ::google::protobuf::RepeatedPtrField< ::std::string> scan_mount_points_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::InodeFileConfig_MountPointMappingEntry > mount_point_mapping_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static InodeFileConfig* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// InodeFileConfig_MountPointMappingEntry

// optional string mountpoint = 1;
inline bool InodeFileConfig_MountPointMappingEntry::has_mountpoint() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InodeFileConfig_MountPointMappingEntry::set_has_mountpoint() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InodeFileConfig_MountPointMappingEntry::clear_has_mountpoint() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InodeFileConfig_MountPointMappingEntry::clear_mountpoint() {
  mountpoint_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mountpoint();
}
inline const ::std::string& InodeFileConfig_MountPointMappingEntry::mountpoint() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InodeFileConfig.MountPointMappingEntry.mountpoint)
  return mountpoint_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InodeFileConfig_MountPointMappingEntry::set_mountpoint(const ::std::string& value) {
  set_has_mountpoint();
  mountpoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.InodeFileConfig.MountPointMappingEntry.mountpoint)
}
inline void InodeFileConfig_MountPointMappingEntry::set_mountpoint(const char* value) {
  set_has_mountpoint();
  mountpoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.InodeFileConfig.MountPointMappingEntry.mountpoint)
}
inline void InodeFileConfig_MountPointMappingEntry::set_mountpoint(const char* value, size_t size) {
  set_has_mountpoint();
  mountpoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.InodeFileConfig.MountPointMappingEntry.mountpoint)
}
inline ::std::string* InodeFileConfig_MountPointMappingEntry::mutable_mountpoint() {
  set_has_mountpoint();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.InodeFileConfig.MountPointMappingEntry.mountpoint)
  return mountpoint_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InodeFileConfig_MountPointMappingEntry::release_mountpoint() {
  // @@protoc_insertion_point(field_release:perfetto.protos.InodeFileConfig.MountPointMappingEntry.mountpoint)
  clear_has_mountpoint();
  return mountpoint_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InodeFileConfig_MountPointMappingEntry::set_allocated_mountpoint(::std::string* mountpoint) {
  if (mountpoint != NULL) {
    set_has_mountpoint();
  } else {
    clear_has_mountpoint();
  }
  mountpoint_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mountpoint);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.InodeFileConfig.MountPointMappingEntry.mountpoint)
}

// repeated string scan_roots = 2;
inline int InodeFileConfig_MountPointMappingEntry::scan_roots_size() const {
  return scan_roots_.size();
}
inline void InodeFileConfig_MountPointMappingEntry::clear_scan_roots() {
  scan_roots_.Clear();
}
inline const ::std::string& InodeFileConfig_MountPointMappingEntry::scan_roots(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InodeFileConfig.MountPointMappingEntry.scan_roots)
  return scan_roots_.Get(index);
}
inline ::std::string* InodeFileConfig_MountPointMappingEntry::mutable_scan_roots(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.InodeFileConfig.MountPointMappingEntry.scan_roots)
  return scan_roots_.Mutable(index);
}
inline void InodeFileConfig_MountPointMappingEntry::set_scan_roots(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.InodeFileConfig.MountPointMappingEntry.scan_roots)
  scan_roots_.Mutable(index)->assign(value);
}
inline void InodeFileConfig_MountPointMappingEntry::set_scan_roots(int index, const char* value) {
  scan_roots_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.InodeFileConfig.MountPointMappingEntry.scan_roots)
}
inline void InodeFileConfig_MountPointMappingEntry::set_scan_roots(int index, const char* value, size_t size) {
  scan_roots_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.InodeFileConfig.MountPointMappingEntry.scan_roots)
}
inline ::std::string* InodeFileConfig_MountPointMappingEntry::add_scan_roots() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.InodeFileConfig.MountPointMappingEntry.scan_roots)
  return scan_roots_.Add();
}
inline void InodeFileConfig_MountPointMappingEntry::add_scan_roots(const ::std::string& value) {
  scan_roots_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.InodeFileConfig.MountPointMappingEntry.scan_roots)
}
inline void InodeFileConfig_MountPointMappingEntry::add_scan_roots(const char* value) {
  scan_roots_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.InodeFileConfig.MountPointMappingEntry.scan_roots)
}
inline void InodeFileConfig_MountPointMappingEntry::add_scan_roots(const char* value, size_t size) {
  scan_roots_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.InodeFileConfig.MountPointMappingEntry.scan_roots)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
InodeFileConfig_MountPointMappingEntry::scan_roots() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.InodeFileConfig.MountPointMappingEntry.scan_roots)
  return scan_roots_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
InodeFileConfig_MountPointMappingEntry::mutable_scan_roots() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.InodeFileConfig.MountPointMappingEntry.scan_roots)
  return &scan_roots_;
}

// -------------------------------------------------------------------

// InodeFileConfig

// optional uint32 scan_interval_ms = 1;
inline bool InodeFileConfig::has_scan_interval_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InodeFileConfig::set_has_scan_interval_ms() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InodeFileConfig::clear_has_scan_interval_ms() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InodeFileConfig::clear_scan_interval_ms() {
  scan_interval_ms_ = 0u;
  clear_has_scan_interval_ms();
}
inline ::google::protobuf::uint32 InodeFileConfig::scan_interval_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InodeFileConfig.scan_interval_ms)
  return scan_interval_ms_;
}
inline void InodeFileConfig::set_scan_interval_ms(::google::protobuf::uint32 value) {
  set_has_scan_interval_ms();
  scan_interval_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.InodeFileConfig.scan_interval_ms)
}

// optional uint32 scan_delay_ms = 2;
inline bool InodeFileConfig::has_scan_delay_ms() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InodeFileConfig::set_has_scan_delay_ms() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InodeFileConfig::clear_has_scan_delay_ms() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InodeFileConfig::clear_scan_delay_ms() {
  scan_delay_ms_ = 0u;
  clear_has_scan_delay_ms();
}
inline ::google::protobuf::uint32 InodeFileConfig::scan_delay_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InodeFileConfig.scan_delay_ms)
  return scan_delay_ms_;
}
inline void InodeFileConfig::set_scan_delay_ms(::google::protobuf::uint32 value) {
  set_has_scan_delay_ms();
  scan_delay_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.InodeFileConfig.scan_delay_ms)
}

// optional uint32 scan_batch_size = 3;
inline bool InodeFileConfig::has_scan_batch_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InodeFileConfig::set_has_scan_batch_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InodeFileConfig::clear_has_scan_batch_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InodeFileConfig::clear_scan_batch_size() {
  scan_batch_size_ = 0u;
  clear_has_scan_batch_size();
}
inline ::google::protobuf::uint32 InodeFileConfig::scan_batch_size() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InodeFileConfig.scan_batch_size)
  return scan_batch_size_;
}
inline void InodeFileConfig::set_scan_batch_size(::google::protobuf::uint32 value) {
  set_has_scan_batch_size();
  scan_batch_size_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.InodeFileConfig.scan_batch_size)
}

// optional bool do_not_scan = 4;
inline bool InodeFileConfig::has_do_not_scan() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InodeFileConfig::set_has_do_not_scan() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InodeFileConfig::clear_has_do_not_scan() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InodeFileConfig::clear_do_not_scan() {
  do_not_scan_ = false;
  clear_has_do_not_scan();
}
inline bool InodeFileConfig::do_not_scan() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InodeFileConfig.do_not_scan)
  return do_not_scan_;
}
inline void InodeFileConfig::set_do_not_scan(bool value) {
  set_has_do_not_scan();
  do_not_scan_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.InodeFileConfig.do_not_scan)
}

// repeated string scan_mount_points = 5;
inline int InodeFileConfig::scan_mount_points_size() const {
  return scan_mount_points_.size();
}
inline void InodeFileConfig::clear_scan_mount_points() {
  scan_mount_points_.Clear();
}
inline const ::std::string& InodeFileConfig::scan_mount_points(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InodeFileConfig.scan_mount_points)
  return scan_mount_points_.Get(index);
}
inline ::std::string* InodeFileConfig::mutable_scan_mount_points(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.InodeFileConfig.scan_mount_points)
  return scan_mount_points_.Mutable(index);
}
inline void InodeFileConfig::set_scan_mount_points(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.InodeFileConfig.scan_mount_points)
  scan_mount_points_.Mutable(index)->assign(value);
}
inline void InodeFileConfig::set_scan_mount_points(int index, const char* value) {
  scan_mount_points_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.InodeFileConfig.scan_mount_points)
}
inline void InodeFileConfig::set_scan_mount_points(int index, const char* value, size_t size) {
  scan_mount_points_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.InodeFileConfig.scan_mount_points)
}
inline ::std::string* InodeFileConfig::add_scan_mount_points() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.InodeFileConfig.scan_mount_points)
  return scan_mount_points_.Add();
}
inline void InodeFileConfig::add_scan_mount_points(const ::std::string& value) {
  scan_mount_points_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.InodeFileConfig.scan_mount_points)
}
inline void InodeFileConfig::add_scan_mount_points(const char* value) {
  scan_mount_points_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.InodeFileConfig.scan_mount_points)
}
inline void InodeFileConfig::add_scan_mount_points(const char* value, size_t size) {
  scan_mount_points_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.InodeFileConfig.scan_mount_points)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
InodeFileConfig::scan_mount_points() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.InodeFileConfig.scan_mount_points)
  return scan_mount_points_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
InodeFileConfig::mutable_scan_mount_points() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.InodeFileConfig.scan_mount_points)
  return &scan_mount_points_;
}

// repeated .perfetto.protos.InodeFileConfig.MountPointMappingEntry mount_point_mapping = 6;
inline int InodeFileConfig::mount_point_mapping_size() const {
  return mount_point_mapping_.size();
}
inline void InodeFileConfig::clear_mount_point_mapping() {
  mount_point_mapping_.Clear();
}
inline const ::perfetto::protos::InodeFileConfig_MountPointMappingEntry& InodeFileConfig::mount_point_mapping(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InodeFileConfig.mount_point_mapping)
  return mount_point_mapping_.Get(index);
}
inline ::perfetto::protos::InodeFileConfig_MountPointMappingEntry* InodeFileConfig::mutable_mount_point_mapping(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.InodeFileConfig.mount_point_mapping)
  return mount_point_mapping_.Mutable(index);
}
inline ::perfetto::protos::InodeFileConfig_MountPointMappingEntry* InodeFileConfig::add_mount_point_mapping() {
  // @@protoc_insertion_point(field_add:perfetto.protos.InodeFileConfig.mount_point_mapping)
  return mount_point_mapping_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::InodeFileConfig_MountPointMappingEntry >*
InodeFileConfig::mutable_mount_point_mapping() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.InodeFileConfig.mount_point_mapping)
  return &mount_point_mapping_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::InodeFileConfig_MountPointMappingEntry >&
InodeFileConfig::mount_point_mapping() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.InodeFileConfig.mount_point_mapping)
  return mount_point_mapping_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto__INCLUDED
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/config/power/android_power_config.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/config/power/android_power_config.proto

#ifndef PROTOBUF_protos_2fperfetto_2fconfig_2fpower_2fandroid_5fpower_5fconfig_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2fconfig_2fpower_2fandroid_5fpower_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2fconfig_2fpower_2fandroid_5fpower_5fconfig_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2fpower_2fandroid_5fpower_5fconfig_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2fpower_2fandroid_5fpower_5fconfig_2eproto();

class AndroidPowerConfig;

enum AndroidPowerConfig_BatteryCounters {
  AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_UNSPECIFIED = 0,
  AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_CHARGE = 1,
  AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_CAPACITY_PERCENT = 2,
  AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_CURRENT = 3,
  AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_CURRENT_AVG = 4
};
bool AndroidPowerConfig_BatteryCounters_IsValid(int value);
const AndroidPowerConfig_BatteryCounters AndroidPowerConfig_BatteryCounters_BatteryCounters_MIN = AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_UNSPECIFIED;
const AndroidPowerConfig_BatteryCounters AndroidPowerConfig_BatteryCounters_BatteryCounters_MAX = AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_CURRENT_AVG;
const int AndroidPowerConfig_BatteryCounters_BatteryCounters_ARRAYSIZE = AndroidPowerConfig_BatteryCounters_BatteryCounters_MAX + 1;

// ===================================================================

class AndroidPowerConfig : public ::google::protobuf::MessageLite {
 public:
  AndroidPowerConfig();
  virtual ~AndroidPowerConfig();

  AndroidPowerConfig(const AndroidPowerConfig& from);

  inline AndroidPowerConfig& operator=(const AndroidPowerConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const AndroidPowerConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AndroidPowerConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AndroidPowerConfig* other);

  // implements Message ----------------------------------------------

  inline AndroidPowerConfig* New() const { return New(NULL); }

  AndroidPowerConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AndroidPowerConfig& from);
  void MergeFrom(const AndroidPowerConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AndroidPowerConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef AndroidPowerConfig_BatteryCounters BatteryCounters;
  static const BatteryCounters BATTERY_COUNTER_UNSPECIFIED =
    AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_UNSPECIFIED;
  static const BatteryCounters BATTERY_COUNTER_CHARGE =
    AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_CHARGE;
  static const BatteryCounters BATTERY_COUNTER_CAPACITY_PERCENT =
    AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_CAPACITY_PERCENT;
  static const BatteryCounters BATTERY_COUNTER_CURRENT =
    AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_CURRENT;
  static const BatteryCounters BATTERY_COUNTER_CURRENT_AVG =
    AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_CURRENT_AVG;
  static inline bool BatteryCounters_IsValid(int value) {
    return AndroidPowerConfig_BatteryCounters_IsValid(value);
  }
  static const BatteryCounters BatteryCounters_MIN =
    AndroidPowerConfig_BatteryCounters_BatteryCounters_MIN;
  static const BatteryCounters BatteryCounters_MAX =
    AndroidPowerConfig_BatteryCounters_BatteryCounters_MAX;
  static const int BatteryCounters_ARRAYSIZE =
    AndroidPowerConfig_BatteryCounters_BatteryCounters_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional uint32 battery_poll_ms = 1;
  bool has_battery_poll_ms() const;
  void clear_battery_poll_ms();
  static const int kBatteryPollMsFieldNumber = 1;
  ::google::protobuf::uint32 battery_poll_ms() const;
  void set_battery_poll_ms(::google::protobuf::uint32 value);

  // repeated .perfetto.protos.AndroidPowerConfig.BatteryCounters battery_counters = 2;
  int battery_counters_size() const;
  void clear_battery_counters();
  static const int kBatteryCountersFieldNumber = 2;
  ::perfetto::protos::AndroidPowerConfig_BatteryCounters battery_counters(int index) const;
  void set_battery_counters(int index, ::perfetto::protos::AndroidPowerConfig_BatteryCounters value);
  void add_battery_counters(::perfetto::protos::AndroidPowerConfig_BatteryCounters value);
  const ::google::protobuf::RepeatedField<int>& battery_counters() const;
  ::google::protobuf::RepeatedField<int>* mutable_battery_counters();

  // optional bool collect_power_rails = 3;
  bool has_collect_power_rails() const;
  void clear_collect_power_rails();
  static const int kCollectPowerRailsFieldNumber = 3;
  bool collect_power_rails() const;
  void set_collect_power_rails(bool value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.AndroidPowerConfig)
 private:
  inline void set_has_battery_poll_ms();
  inline void clear_has_battery_poll_ms();
  inline void set_has_collect_power_rails();
  inline void clear_has_collect_power_rails();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField<int> battery_counters_;
  ::google::protobuf::uint32 battery_poll_ms_;
  bool collect_power_rails_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2fpower_2fandroid_5fpower_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2fpower_2fandroid_5fpower_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2fpower_2fandroid_5fpower_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2fpower_2fandroid_5fpower_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static AndroidPowerConfig* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// AndroidPowerConfig

// optional uint32 battery_poll_ms = 1;
inline bool AndroidPowerConfig::has_battery_poll_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AndroidPowerConfig::set_has_battery_poll_ms() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AndroidPowerConfig::clear_has_battery_poll_ms() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AndroidPowerConfig::clear_battery_poll_ms() {
  battery_poll_ms_ = 0u;
  clear_has_battery_poll_ms();
}
inline ::google::protobuf::uint32 AndroidPowerConfig::battery_poll_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AndroidPowerConfig.battery_poll_ms)
  return battery_poll_ms_;
}
inline void AndroidPowerConfig::set_battery_poll_ms(::google::protobuf::uint32 value) {
  set_has_battery_poll_ms();
  battery_poll_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.AndroidPowerConfig.battery_poll_ms)
}

// repeated .perfetto.protos.AndroidPowerConfig.BatteryCounters battery_counters = 2;
inline int AndroidPowerConfig::battery_counters_size() const {
  return battery_counters_.size();
}
inline void AndroidPowerConfig::clear_battery_counters() {
  battery_counters_.Clear();
}
inline ::perfetto::protos::AndroidPowerConfig_BatteryCounters AndroidPowerConfig::battery_counters(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AndroidPowerConfig.battery_counters)
  return static_cast< ::perfetto::protos::AndroidPowerConfig_BatteryCounters >(battery_counters_.Get(index));
}
inline void AndroidPowerConfig::set_battery_counters(int index, ::perfetto::protos::AndroidPowerConfig_BatteryCounters value) {
  assert(::perfetto::protos::AndroidPowerConfig_BatteryCounters_IsValid(value));
  battery_counters_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.AndroidPowerConfig.battery_counters)
}
inline void AndroidPowerConfig::add_battery_counters(::perfetto::protos::AndroidPowerConfig_BatteryCounters value) {
  assert(::perfetto::protos::AndroidPowerConfig_BatteryCounters_IsValid(value));
  battery_counters_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.AndroidPowerConfig.battery_counters)
}
inline const ::google::protobuf::RepeatedField<int>&
AndroidPowerConfig::battery_counters() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.AndroidPowerConfig.battery_counters)
  return battery_counters_;
}
inline ::google::protobuf::RepeatedField<int>*
AndroidPowerConfig::mutable_battery_counters() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.AndroidPowerConfig.battery_counters)
  return &battery_counters_;
}

// optional bool collect_power_rails = 3;
inline bool AndroidPowerConfig::has_collect_power_rails() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AndroidPowerConfig::set_has_collect_power_rails() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AndroidPowerConfig::clear_has_collect_power_rails() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AndroidPowerConfig::clear_collect_power_rails() {
  collect_power_rails_ = false;
  clear_has_collect_power_rails();
}
inline bool AndroidPowerConfig::collect_power_rails() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AndroidPowerConfig.collect_power_rails)
  return collect_power_rails_;
}
inline void AndroidPowerConfig::set_collect_power_rails(bool value) {
  set_has_collect_power_rails();
  collect_power_rails_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.AndroidPowerConfig.collect_power_rails)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::perfetto::protos::AndroidPowerConfig_BatteryCounters> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2fconfig_2fpower_2fandroid_5fpower_5fconfig_2eproto__INCLUDED
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/config/process_stats/process_stats_config.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/config/process_stats/process_stats_config.proto

#ifndef PROTOBUF_protos_2fperfetto_2fconfig_2fprocess_5fstats_2fprocess_5fstats_5fconfig_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2fconfig_2fprocess_5fstats_2fprocess_5fstats_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2fconfig_2fprocess_5fstats_2fprocess_5fstats_5fconfig_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2fprocess_5fstats_2fprocess_5fstats_5fconfig_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2fprocess_5fstats_2fprocess_5fstats_5fconfig_2eproto();

class ProcessStatsConfig;

enum ProcessStatsConfig_Quirks {
  ProcessStatsConfig_Quirks_QUIRKS_UNSPECIFIED = 0,
  ProcessStatsConfig_Quirks_DISABLE_INITIAL_DUMP PROTOBUF_DEPRECATED = 1,
  ProcessStatsConfig_Quirks_DISABLE_ON_DEMAND = 2
};
bool ProcessStatsConfig_Quirks_IsValid(int value);
const ProcessStatsConfig_Quirks ProcessStatsConfig_Quirks_Quirks_MIN = ProcessStatsConfig_Quirks_QUIRKS_UNSPECIFIED;
const ProcessStatsConfig_Quirks ProcessStatsConfig_Quirks_Quirks_MAX = ProcessStatsConfig_Quirks_DISABLE_ON_DEMAND;
const int ProcessStatsConfig_Quirks_Quirks_ARRAYSIZE = ProcessStatsConfig_Quirks_Quirks_MAX + 1;

// ===================================================================

class ProcessStatsConfig : public ::google::protobuf::MessageLite {
 public:
  ProcessStatsConfig();
  virtual ~ProcessStatsConfig();

  ProcessStatsConfig(const ProcessStatsConfig& from);

  inline ProcessStatsConfig& operator=(const ProcessStatsConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ProcessStatsConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ProcessStatsConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ProcessStatsConfig* other);

  // implements Message ----------------------------------------------

  inline ProcessStatsConfig* New() const { return New(NULL); }

  ProcessStatsConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ProcessStatsConfig& from);
  void MergeFrom(const ProcessStatsConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ProcessStatsConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ProcessStatsConfig_Quirks Quirks;
  static const Quirks QUIRKS_UNSPECIFIED =
    ProcessStatsConfig_Quirks_QUIRKS_UNSPECIFIED;
  PROTOBUF_DEPRECATED_ATTR static const Quirks DISABLE_INITIAL_DUMP =
    ProcessStatsConfig_Quirks_DISABLE_INITIAL_DUMP;
  static const Quirks DISABLE_ON_DEMAND =
    ProcessStatsConfig_Quirks_DISABLE_ON_DEMAND;
  static inline bool Quirks_IsValid(int value) {
    return ProcessStatsConfig_Quirks_IsValid(value);
  }
  static const Quirks Quirks_MIN =
    ProcessStatsConfig_Quirks_Quirks_MIN;
  static const Quirks Quirks_MAX =
    ProcessStatsConfig_Quirks_Quirks_MAX;
  static const int Quirks_ARRAYSIZE =
    ProcessStatsConfig_Quirks_Quirks_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .perfetto.protos.ProcessStatsConfig.Quirks quirks = 1;
  int quirks_size() const;
  void clear_quirks();
  static const int kQuirksFieldNumber = 1;
  ::perfetto::protos::ProcessStatsConfig_Quirks quirks(int index) const;
  void set_quirks(int index, ::perfetto::protos::ProcessStatsConfig_Quirks value);
  void add_quirks(::perfetto::protos::ProcessStatsConfig_Quirks value);
  const ::google::protobuf::RepeatedField<int>& quirks() const;
  ::google::protobuf::RepeatedField<int>* mutable_quirks();

  // optional bool scan_all_processes_on_start = 2;
  bool has_scan_all_processes_on_start() const;
  void clear_scan_all_processes_on_start();
  static const int kScanAllProcessesOnStartFieldNumber = 2;
  bool scan_all_processes_on_start() const;
  void set_scan_all_processes_on_start(bool value);

  // optional bool record_thread_names = 3;
  bool has_record_thread_names() const;
  void clear_record_thread_names();
  static const int kRecordThreadNamesFieldNumber = 3;
  bool record_thread_names() const;
  void set_record_thread_names(bool value);

  // optional uint32 proc_stats_poll_ms = 4;
  bool has_proc_stats_poll_ms() const;
  void clear_proc_stats_poll_ms();
  static const int kProcStatsPollMsFieldNumber = 4;
  ::google::protobuf::uint32 proc_stats_poll_ms() const;
  void set_proc_stats_poll_ms(::google::protobuf::uint32 value);

  // optional uint32 proc_stats_cache_ttl_ms = 6;
  bool has_proc_stats_cache_ttl_ms() const;
  void clear_proc_stats_cache_ttl_ms();
  static const int kProcStatsCacheTtlMsFieldNumber = 6;
  ::google::protobuf::uint32 proc_stats_cache_ttl_ms() const;
  void set_proc_stats_cache_ttl_ms(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.ProcessStatsConfig)
 private:
  inline void set_has_scan_all_processes_on_start();
  inline void clear_has_scan_all_processes_on_start();
  inline void set_has_record_thread_names();
  inline void clear_has_record_thread_names();
  inline void set_has_proc_stats_poll_ms();
  inline void clear_has_proc_stats_poll_ms();
  inline void set_has_proc_stats_cache_ttl_ms();
  inline void clear_has_proc_stats_cache_ttl_ms();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField<int> quirks_;
  bool scan_all_processes_on_start_;
  bool record_thread_names_;
  ::google::protobuf::uint32 proc_stats_poll_ms_;
  ::google::protobuf::uint32 proc_stats_cache_ttl_ms_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2fprocess_5fstats_2fprocess_5fstats_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2fprocess_5fstats_2fprocess_5fstats_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2fprocess_5fstats_2fprocess_5fstats_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2fprocess_5fstats_2fprocess_5fstats_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static ProcessStatsConfig* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// ProcessStatsConfig

// repeated .perfetto.protos.ProcessStatsConfig.Quirks quirks = 1;
inline int ProcessStatsConfig::quirks_size() const {
  return quirks_.size();
}
inline void ProcessStatsConfig::clear_quirks() {
  quirks_.Clear();
}
inline ::perfetto::protos::ProcessStatsConfig_Quirks ProcessStatsConfig::quirks(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ProcessStatsConfig.quirks)
  return static_cast< ::perfetto::protos::ProcessStatsConfig_Quirks >(quirks_.Get(index));
}
inline void ProcessStatsConfig::set_quirks(int index, ::perfetto::protos::ProcessStatsConfig_Quirks value) {
  assert(::perfetto::protos::ProcessStatsConfig_Quirks_IsValid(value));
  quirks_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.ProcessStatsConfig.quirks)
}
inline void ProcessStatsConfig::add_quirks(::perfetto::protos::ProcessStatsConfig_Quirks value) {
  assert(::perfetto::protos::ProcessStatsConfig_Quirks_IsValid(value));
  quirks_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.ProcessStatsConfig.quirks)
}
inline const ::google::protobuf::RepeatedField<int>&
ProcessStatsConfig::quirks() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.ProcessStatsConfig.quirks)
  return quirks_;
}
inline ::google::protobuf::RepeatedField<int>*
ProcessStatsConfig::mutable_quirks() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.ProcessStatsConfig.quirks)
  return &quirks_;
}

// optional bool scan_all_processes_on_start = 2;
inline bool ProcessStatsConfig::has_scan_all_processes_on_start() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProcessStatsConfig::set_has_scan_all_processes_on_start() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProcessStatsConfig::clear_has_scan_all_processes_on_start() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProcessStatsConfig::clear_scan_all_processes_on_start() {
  scan_all_processes_on_start_ = false;
  clear_has_scan_all_processes_on_start();
}
inline bool ProcessStatsConfig::scan_all_processes_on_start() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ProcessStatsConfig.scan_all_processes_on_start)
  return scan_all_processes_on_start_;
}
inline void ProcessStatsConfig::set_scan_all_processes_on_start(bool value) {
  set_has_scan_all_processes_on_start();
  scan_all_processes_on_start_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.ProcessStatsConfig.scan_all_processes_on_start)
}

// optional bool record_thread_names = 3;
inline bool ProcessStatsConfig::has_record_thread_names() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProcessStatsConfig::set_has_record_thread_names() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProcessStatsConfig::clear_has_record_thread_names() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProcessStatsConfig::clear_record_thread_names() {
  record_thread_names_ = false;
  clear_has_record_thread_names();
}
inline bool ProcessStatsConfig::record_thread_names() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ProcessStatsConfig.record_thread_names)
  return record_thread_names_;
}
inline void ProcessStatsConfig::set_record_thread_names(bool value) {
  set_has_record_thread_names();
  record_thread_names_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.ProcessStatsConfig.record_thread_names)
}

// optional uint32 proc_stats_poll_ms = 4;
inline bool ProcessStatsConfig::has_proc_stats_poll_ms() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProcessStatsConfig::set_has_proc_stats_poll_ms() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProcessStatsConfig::clear_has_proc_stats_poll_ms() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProcessStatsConfig::clear_proc_stats_poll_ms() {
  proc_stats_poll_ms_ = 0u;
  clear_has_proc_stats_poll_ms();
}
inline ::google::protobuf::uint32 ProcessStatsConfig::proc_stats_poll_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ProcessStatsConfig.proc_stats_poll_ms)
  return proc_stats_poll_ms_;
}
inline void ProcessStatsConfig::set_proc_stats_poll_ms(::google::protobuf::uint32 value) {
  set_has_proc_stats_poll_ms();
  proc_stats_poll_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.ProcessStatsConfig.proc_stats_poll_ms)
}

// optional uint32 proc_stats_cache_ttl_ms = 6;
inline bool ProcessStatsConfig::has_proc_stats_cache_ttl_ms() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProcessStatsConfig::set_has_proc_stats_cache_ttl_ms() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProcessStatsConfig::clear_has_proc_stats_cache_ttl_ms() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProcessStatsConfig::clear_proc_stats_cache_ttl_ms() {
  proc_stats_cache_ttl_ms_ = 0u;
  clear_has_proc_stats_cache_ttl_ms();
}
inline ::google::protobuf::uint32 ProcessStatsConfig::proc_stats_cache_ttl_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ProcessStatsConfig.proc_stats_cache_ttl_ms)
  return proc_stats_cache_ttl_ms_;
}
inline void ProcessStatsConfig::set_proc_stats_cache_ttl_ms(::google::protobuf::uint32 value) {
  set_has_proc_stats_cache_ttl_ms();
  proc_stats_cache_ttl_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.ProcessStatsConfig.proc_stats_cache_ttl_ms)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::perfetto::protos::ProcessStatsConfig_Quirks> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2fconfig_2fprocess_5fstats_2fprocess_5fstats_5fconfig_2eproto__INCLUDED
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/config/profiling/heapprofd_config.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/config/profiling/heapprofd_config.proto

#ifndef PROTOBUF_protos_2fperfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto();

class HeapprofdConfig;
class HeapprofdConfig_ContinuousDumpConfig;

// ===================================================================

class HeapprofdConfig_ContinuousDumpConfig : public ::google::protobuf::MessageLite {
 public:
  HeapprofdConfig_ContinuousDumpConfig();
  virtual ~HeapprofdConfig_ContinuousDumpConfig();

  HeapprofdConfig_ContinuousDumpConfig(const HeapprofdConfig_ContinuousDumpConfig& from);

  inline HeapprofdConfig_ContinuousDumpConfig& operator=(const HeapprofdConfig_ContinuousDumpConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const HeapprofdConfig_ContinuousDumpConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const HeapprofdConfig_ContinuousDumpConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(HeapprofdConfig_ContinuousDumpConfig* other);

  // implements Message ----------------------------------------------

  inline HeapprofdConfig_ContinuousDumpConfig* New() const { return New(NULL); }

  HeapprofdConfig_ContinuousDumpConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const HeapprofdConfig_ContinuousDumpConfig& from);
  void MergeFrom(const HeapprofdConfig_ContinuousDumpConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HeapprofdConfig_ContinuousDumpConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 dump_phase_ms = 5;
  bool has_dump_phase_ms() const;
  void clear_dump_phase_ms();
  static const int kDumpPhaseMsFieldNumber = 5;
  ::google::protobuf::uint32 dump_phase_ms() const;
  void set_dump_phase_ms(::google::protobuf::uint32 value);

  // optional uint32 dump_interval_ms = 6;
  bool has_dump_interval_ms() const;
  void clear_dump_interval_ms();
  static const int kDumpIntervalMsFieldNumber = 6;
  ::google::protobuf::uint32 dump_interval_ms() const;
  void set_dump_interval_ms(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.HeapprofdConfig.ContinuousDumpConfig)
 private:
  inline void set_has_dump_phase_ms();
  inline void clear_has_dump_phase_ms();
  inline void set_has_dump_interval_ms();
  inline void clear_has_dump_interval_ms();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 dump_phase_ms_;
  ::google::protobuf::uint32 dump_interval_ms_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static HeapprofdConfig_ContinuousDumpConfig* default_instance_;
};
// -------------------------------------------------------------------

class HeapprofdConfig : public ::google::protobuf::MessageLite {
 public:
  HeapprofdConfig();
  virtual ~HeapprofdConfig();

  HeapprofdConfig(const HeapprofdConfig& from);

  inline HeapprofdConfig& operator=(const HeapprofdConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const HeapprofdConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const HeapprofdConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(HeapprofdConfig* other);

  // implements Message ----------------------------------------------

  inline HeapprofdConfig* New() const { return New(NULL); }

  HeapprofdConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const HeapprofdConfig& from);
  void MergeFrom(const HeapprofdConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HeapprofdConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef HeapprofdConfig_ContinuousDumpConfig ContinuousDumpConfig;

  // accessors -------------------------------------------------------

  // optional uint64 sampling_interval_bytes = 1;
  bool has_sampling_interval_bytes() const;
  void clear_sampling_interval_bytes();
  static const int kSamplingIntervalBytesFieldNumber = 1;
  ::google::protobuf::uint64 sampling_interval_bytes() const;
  void set_sampling_interval_bytes(::google::protobuf::uint64 value);

  // repeated string process_cmdline = 2;
  int process_cmdline_size() const;
  void clear_process_cmdline();
  static const int kProcessCmdlineFieldNumber = 2;
  const ::std::string& process_cmdline(int index) const;
  ::std::string* mutable_process_cmdline(int index);
  void set_process_cmdline(int index, const ::std::string& value);
  void set_process_cmdline(int index, const char* value);
  void set_process_cmdline(int index, const char* value, size_t size);
  ::std::string* add_process_cmdline();
  void add_process_cmdline(const ::std::string& value);
  void add_process_cmdline(const char* value);
  void add_process_cmdline(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& process_cmdline() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_process_cmdline();

  // repeated uint64 pid = 4;
  int pid_size() const;
  void clear_pid();
  static const int kPidFieldNumber = 4;
  ::google::protobuf::uint64 pid(int index) const;
  void set_pid(int index, ::google::protobuf::uint64 value);
  void add_pid(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      pid() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_pid();

  // optional bool all = 5;
  bool has_all() const;
  void clear_all();
  static const int kAllFieldNumber = 5;
  bool all() const;
  void set_all(bool value);

  // repeated string skip_symbol_prefix = 7;
  int skip_symbol_prefix_size() const;
  void clear_skip_symbol_prefix();
  static const int kSkipSymbolPrefixFieldNumber = 7;
  const ::std::string& skip_symbol_prefix(int index) const;
  ::std::string* mutable_skip_symbol_prefix(int index);
  void set_skip_symbol_prefix(int index, const ::std::string& value);
  void set_skip_symbol_prefix(int index, const char* value);
  void set_skip_symbol_prefix(int index, const char* value, size_t size);
  ::std::string* add_skip_symbol_prefix();
  void add_skip_symbol_prefix(const ::std::string& value);
  void add_skip_symbol_prefix(const char* value);
  void add_skip_symbol_prefix(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& skip_symbol_prefix() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_skip_symbol_prefix();

  // optional .perfetto.protos.HeapprofdConfig.ContinuousDumpConfig continuous_dump_config = 6;
  bool has_continuous_dump_config() const;
  void clear_continuous_dump_config();
  static const int kContinuousDumpConfigFieldNumber = 6;
  const ::perfetto::protos::HeapprofdConfig_ContinuousDumpConfig& continuous_dump_config() const;
  ::perfetto::protos::HeapprofdConfig_ContinuousDumpConfig* mutable_continuous_dump_config();
  ::perfetto::protos::HeapprofdConfig_ContinuousDumpConfig* release_continuous_dump_config();
  void set_allocated_continuous_dump_config(::perfetto::protos::HeapprofdConfig_ContinuousDumpConfig* continuous_dump_config);

  // optional uint64 shmem_size_bytes = 8;
  bool has_shmem_size_bytes() const;
  void clear_shmem_size_bytes();
  static const int kShmemSizeBytesFieldNumber = 8;
  ::google::protobuf::uint64 shmem_size_bytes() const;
  void set_shmem_size_bytes(::google::protobuf::uint64 value);

  // optional bool block_client = 9;
  bool has_block_client() const;
  void clear_block_client();
  static const int kBlockClientFieldNumber = 9;
  bool block_client() const;
  void set_block_client(bool value);

  // optional bool no_startup = 10;
  bool has_no_startup() const;
  void clear_no_startup();
  static const int kNoStartupFieldNumber = 10;
  bool no_startup() const;
  void set_no_startup(bool value);

  // optional bool no_running = 11;
  bool has_no_running() const;
  void clear_no_running();
  static const int kNoRunningFieldNumber = 11;
  bool no_running() const;
  void set_no_running(bool value);

  // optional bool idle_allocations = 12;
  bool has_idle_allocations() const;
  void clear_idle_allocations();
  static const int kIdleAllocationsFieldNumber = 12;
  bool idle_allocations() const;
  void set_idle_allocations(bool value);

  // optional bool dump_at_max = 13;
  bool has_dump_at_max() const;
  void clear_dump_at_max();
  static const int kDumpAtMaxFieldNumber = 13;
  bool dump_at_max() const;
  void set_dump_at_max(bool value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.HeapprofdConfig)
 private:
  inline void set_has_sampling_interval_bytes();
  inline void clear_has_sampling_interval_bytes();
  inline void set_has_all();
  inline void clear_has_all();
  inline void set_has_continuous_dump_config();
  inline void clear_has_continuous_dump_config();
  inline void set_has_shmem_size_bytes();
  inline void clear_has_shmem_size_bytes();
  inline void set_has_block_client();
  inline void clear_has_block_client();
  inline void set_has_no_startup();
  inline void clear_has_no_startup();
  inline void set_has_no_running();
  inline void clear_has_no_running();
  inline void set_has_idle_allocations();
  inline void clear_has_idle_allocations();
  inline void set_has_dump_at_max();
  inline void clear_has_dump_at_max();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 sampling_interval_bytes_;
  ::google::protobuf::RepeatedPtrField< ::std::string> process_cmdline_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > pid_;
  ::google::protobuf::RepeatedPtrField< ::std::string> skip_symbol_prefix_;
  ::perfetto::protos::HeapprofdConfig_ContinuousDumpConfig* continuous_dump_config_;
  ::google::protobuf::uint64 shmem_size_bytes_;
  bool all_;
  bool block_client_;
  bool no_startup_;
  bool no_running_;
  bool idle_allocations_;
  bool dump_at_max_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static HeapprofdConfig* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// HeapprofdConfig_ContinuousDumpConfig

// optional uint32 dump_phase_ms = 5;
inline bool HeapprofdConfig_ContinuousDumpConfig::has_dump_phase_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeapprofdConfig_ContinuousDumpConfig::set_has_dump_phase_ms() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeapprofdConfig_ContinuousDumpConfig::clear_has_dump_phase_ms() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeapprofdConfig_ContinuousDumpConfig::clear_dump_phase_ms() {
  dump_phase_ms_ = 0u;
  clear_has_dump_phase_ms();
}
inline ::google::protobuf::uint32 HeapprofdConfig_ContinuousDumpConfig::dump_phase_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.ContinuousDumpConfig.dump_phase_ms)
  return dump_phase_ms_;
}
inline void HeapprofdConfig_ContinuousDumpConfig::set_dump_phase_ms(::google::protobuf::uint32 value) {
  set_has_dump_phase_ms();
  dump_phase_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.HeapprofdConfig.ContinuousDumpConfig.dump_phase_ms)
}

// optional uint32 dump_interval_ms = 6;
inline bool HeapprofdConfig_ContinuousDumpConfig::has_dump_interval_ms() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HeapprofdConfig_ContinuousDumpConfig::set_has_dump_interval_ms() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HeapprofdConfig_ContinuousDumpConfig::clear_has_dump_interval_ms() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HeapprofdConfig_ContinuousDumpConfig::clear_dump_interval_ms() {
  dump_interval_ms_ = 0u;
  clear_has_dump_interval_ms();
}
inline ::google::protobuf::uint32 HeapprofdConfig_ContinuousDumpConfig::dump_interval_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.ContinuousDumpConfig.dump_interval_ms)
  return dump_interval_ms_;
}
inline void HeapprofdConfig_ContinuousDumpConfig::set_dump_interval_ms(::google::protobuf::uint32 value) {
  set_has_dump_interval_ms();
  dump_interval_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.HeapprofdConfig.ContinuousDumpConfig.dump_interval_ms)
}

// -------------------------------------------------------------------

// HeapprofdConfig

// optional uint64 sampling_interval_bytes = 1;
inline bool HeapprofdConfig::has_sampling_interval_bytes() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeapprofdConfig::set_has_sampling_interval_bytes() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeapprofdConfig::clear_has_sampling_interval_bytes() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeapprofdConfig::clear_sampling_interval_bytes() {
  sampling_interval_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_sampling_interval_bytes();
}
inline ::google::protobuf::uint64 HeapprofdConfig::sampling_interval_bytes() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.sampling_interval_bytes)
  return sampling_interval_bytes_;
}
inline void HeapprofdConfig::set_sampling_interval_bytes(::google::protobuf::uint64 value) {
  set_has_sampling_interval_bytes();
  sampling_interval_bytes_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.HeapprofdConfig.sampling_interval_bytes)
}

// repeated string process_cmdline = 2;
inline int HeapprofdConfig::process_cmdline_size() const {
  return process_cmdline_.size();
}
inline void HeapprofdConfig::clear_process_cmdline() {
  process_cmdline_.Clear();
}
inline const ::std::string& HeapprofdConfig::process_cmdline(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.process_cmdline)
  return process_cmdline_.Get(index);
}
inline ::std::string* HeapprofdConfig::mutable_process_cmdline(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.HeapprofdConfig.process_cmdline)
  return process_cmdline_.Mutable(index);
}
inline void HeapprofdConfig::set_process_cmdline(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.HeapprofdConfig.process_cmdline)
  process_cmdline_.Mutable(index)->assign(value);
}
inline void HeapprofdConfig::set_process_cmdline(int index, const char* value) {
  process_cmdline_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.HeapprofdConfig.process_cmdline)
}
inline void HeapprofdConfig::set_process_cmdline(int index, const char* value, size_t size) {
  process_cmdline_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.HeapprofdConfig.process_cmdline)
}
inline ::std::string* HeapprofdConfig::add_process_cmdline() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.HeapprofdConfig.process_cmdline)
  return process_cmdline_.Add();
}
inline void HeapprofdConfig::add_process_cmdline(const ::std::string& value) {
  process_cmdline_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.HeapprofdConfig.process_cmdline)
}
inline void HeapprofdConfig::add_process_cmdline(const char* value) {
  process_cmdline_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.HeapprofdConfig.process_cmdline)
}
inline void HeapprofdConfig::add_process_cmdline(const char* value, size_t size) {
  process_cmdline_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.HeapprofdConfig.process_cmdline)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
HeapprofdConfig::process_cmdline() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.HeapprofdConfig.process_cmdline)
  return process_cmdline_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
HeapprofdConfig::mutable_process_cmdline() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.HeapprofdConfig.process_cmdline)
  return &process_cmdline_;
}

// repeated uint64 pid = 4;
inline int HeapprofdConfig::pid_size() const {
  return pid_.size();
}
inline void HeapprofdConfig::clear_pid() {
  pid_.Clear();
}
inline ::google::protobuf::uint64 HeapprofdConfig::pid(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.pid)
  return pid_.Get(index);
}
inline void HeapprofdConfig::set_pid(int index, ::google::protobuf::uint64 value) {
  pid_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.HeapprofdConfig.pid)
}
inline void HeapprofdConfig::add_pid(::google::protobuf::uint64 value) {
  pid_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.HeapprofdConfig.pid)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
HeapprofdConfig::pid() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.HeapprofdConfig.pid)
  return pid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
HeapprofdConfig::mutable_pid() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.HeapprofdConfig.pid)
  return &pid_;
}

// optional bool all = 5;
inline bool HeapprofdConfig::has_all() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HeapprofdConfig::set_has_all() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HeapprofdConfig::clear_has_all() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HeapprofdConfig::clear_all() {
  all_ = false;
  clear_has_all();
}
inline bool HeapprofdConfig::all() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.all)
  return all_;
}
inline void HeapprofdConfig::set_all(bool value) {
  set_has_all();
  all_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.HeapprofdConfig.all)
}

// repeated string skip_symbol_prefix = 7;
inline int HeapprofdConfig::skip_symbol_prefix_size() const {
  return skip_symbol_prefix_.size();
}
inline void HeapprofdConfig::clear_skip_symbol_prefix() {
  skip_symbol_prefix_.Clear();
}
inline const ::std::string& HeapprofdConfig::skip_symbol_prefix(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.skip_symbol_prefix)
  return skip_symbol_prefix_.Get(index);
}
inline ::std::string* HeapprofdConfig::mutable_skip_symbol_prefix(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.HeapprofdConfig.skip_symbol_prefix)
  return skip_symbol_prefix_.Mutable(index);
}
inline void HeapprofdConfig::set_skip_symbol_prefix(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.HeapprofdConfig.skip_symbol_prefix)
  skip_symbol_prefix_.Mutable(index)->assign(value);
}
inline void HeapprofdConfig::set_skip_symbol_prefix(int index, const char* value) {
  skip_symbol_prefix_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.HeapprofdConfig.skip_symbol_prefix)
}
inline void HeapprofdConfig::set_skip_symbol_prefix(int index, const char* value, size_t size) {
  skip_symbol_prefix_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.HeapprofdConfig.skip_symbol_prefix)
}
inline ::std::string* HeapprofdConfig::add_skip_symbol_prefix() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.HeapprofdConfig.skip_symbol_prefix)
  return skip_symbol_prefix_.Add();
}
inline void HeapprofdConfig::add_skip_symbol_prefix(const ::std::string& value) {
  skip_symbol_prefix_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.HeapprofdConfig.skip_symbol_prefix)
}
inline void HeapprofdConfig::add_skip_symbol_prefix(const char* value) {
  skip_symbol_prefix_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.HeapprofdConfig.skip_symbol_prefix)
}
inline void HeapprofdConfig::add_skip_symbol_prefix(const char* value, size_t size) {
  skip_symbol_prefix_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.HeapprofdConfig.skip_symbol_prefix)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
HeapprofdConfig::skip_symbol_prefix() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.HeapprofdConfig.skip_symbol_prefix)
  return skip_symbol_prefix_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
HeapprofdConfig::mutable_skip_symbol_prefix() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.HeapprofdConfig.skip_symbol_prefix)
  return &skip_symbol_prefix_;
}

// optional .perfetto.protos.HeapprofdConfig.ContinuousDumpConfig continuous_dump_config = 6;
inline bool HeapprofdConfig::has_continuous_dump_config() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HeapprofdConfig::set_has_continuous_dump_config() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HeapprofdConfig::clear_has_continuous_dump_config() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HeapprofdConfig::clear_continuous_dump_config() {
  if (continuous_dump_config_ != NULL) continuous_dump_config_->::perfetto::protos::HeapprofdConfig_ContinuousDumpConfig::Clear();
  clear_has_continuous_dump_config();
}
inline const ::perfetto::protos::HeapprofdConfig_ContinuousDumpConfig& HeapprofdConfig::continuous_dump_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.continuous_dump_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return continuous_dump_config_ != NULL ? *continuous_dump_config_ : *default_instance().continuous_dump_config_;
#else
  return continuous_dump_config_ != NULL ? *continuous_dump_config_ : *default_instance_->continuous_dump_config_;
#endif
}
inline ::perfetto::protos::HeapprofdConfig_ContinuousDumpConfig* HeapprofdConfig::mutable_continuous_dump_config() {
  set_has_continuous_dump_config();
  if (continuous_dump_config_ == NULL) {
    continuous_dump_config_ = new ::perfetto::protos::HeapprofdConfig_ContinuousDumpConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.HeapprofdConfig.continuous_dump_config)
  return continuous_dump_config_;
}
inline ::perfetto::protos::HeapprofdConfig_ContinuousDumpConfig* HeapprofdConfig::release_continuous_dump_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.HeapprofdConfig.continuous_dump_config)
  clear_has_continuous_dump_config();
  ::perfetto::protos::HeapprofdConfig_ContinuousDumpConfig* temp = continuous_dump_config_;
  continuous_dump_config_ = NULL;
  return temp;
}
inline void HeapprofdConfig::set_allocated_continuous_dump_config(::perfetto::protos::HeapprofdConfig_ContinuousDumpConfig* continuous_dump_config) {
  delete continuous_dump_config_;
  continuous_dump_config_ = continuous_dump_config;
  if (continuous_dump_config) {
    set_has_continuous_dump_config();
  } else {
    clear_has_continuous_dump_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.HeapprofdConfig.continuous_dump_config)
}

// optional uint64 shmem_size_bytes = 8;
inline bool HeapprofdConfig::has_shmem_size_bytes() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void HeapprofdConfig::set_has_shmem_size_bytes() {
  _has_bits_[0] |= 0x00000040u;
}
inline void HeapprofdConfig::clear_has_shmem_size_bytes() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void HeapprofdConfig::clear_shmem_size_bytes() {
  shmem_size_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_shmem_size_bytes();
}
inline ::google::protobuf::uint64 HeapprofdConfig::shmem_size_bytes() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.shmem_size_bytes)
  return shmem_size_bytes_;
}
inline void HeapprofdConfig::set_shmem_size_bytes(::google::protobuf::uint64 value) {
  set_has_shmem_size_bytes();
  shmem_size_bytes_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.HeapprofdConfig.shmem_size_bytes)
}

// optional bool block_client = 9;
inline bool HeapprofdConfig::has_block_client() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void HeapprofdConfig::set_has_block_client() {
  _has_bits_[0] |= 0x00000080u;
}
inline void HeapprofdConfig::clear_has_block_client() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void HeapprofdConfig::clear_block_client() {
  block_client_ = false;
  clear_has_block_client();
}
inline bool HeapprofdConfig::block_client() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.block_client)
  return block_client_;
}
inline void HeapprofdConfig::set_block_client(bool value) {
  set_has_block_client();
  block_client_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.HeapprofdConfig.block_client)
}

// optional bool no_startup = 10;
inline bool HeapprofdConfig::has_no_startup() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void HeapprofdConfig::set_has_no_startup() {
  _has_bits_[0] |= 0x00000100u;
}
inline void HeapprofdConfig::clear_has_no_startup() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void HeapprofdConfig::clear_no_startup() {
  no_startup_ = false;
  clear_has_no_startup();
}
inline bool HeapprofdConfig::no_startup() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.no_startup)
  return no_startup_;
}
inline void HeapprofdConfig::set_no_startup(bool value) {
  set_has_no_startup();
  no_startup_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.HeapprofdConfig.no_startup)
}

// optional bool no_running = 11;
inline bool HeapprofdConfig::has_no_running() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void HeapprofdConfig::set_has_no_running() {
  _has_bits_[0] |= 0x00000200u;
}
inline void HeapprofdConfig::clear_has_no_running() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void HeapprofdConfig::clear_no_running() {
  no_running_ = false;
  clear_has_no_running();
}
inline bool HeapprofdConfig::no_running() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.no_running)
  return no_running_;
}
inline void HeapprofdConfig::set_no_running(bool value) {
  set_has_no_running();
  no_running_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.HeapprofdConfig.no_running)
}

// optional bool idle_allocations = 12;
inline bool HeapprofdConfig::has_idle_allocations() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void HeapprofdConfig::set_has_idle_allocations() {
  _has_bits_[0] |= 0x00000400u;
}
inline void HeapprofdConfig::clear_has_idle_allocations() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void HeapprofdConfig::clear_idle_allocations() {
  idle_allocations_ = false;
  clear_has_idle_allocations();
}
inline bool HeapprofdConfig::idle_allocations() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.idle_allocations)
  return idle_allocations_;
}
inline void HeapprofdConfig::set_idle_allocations(bool value) {
  set_has_idle_allocations();
  idle_allocations_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.HeapprofdConfig.idle_allocations)
}

// optional bool dump_at_max = 13;
inline bool HeapprofdConfig::has_dump_at_max() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void HeapprofdConfig::set_has_dump_at_max() {
  _has_bits_[0] |= 0x00000800u;
}
inline void HeapprofdConfig::clear_has_dump_at_max() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void HeapprofdConfig::clear_dump_at_max() {
  dump_at_max_ = false;
  clear_has_dump_at_max();
}
inline bool HeapprofdConfig::dump_at_max() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.dump_at_max)
  return dump_at_max_;
}
inline void HeapprofdConfig::set_dump_at_max(bool value) {
  set_has_dump_at_max();
  dump_at_max_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.HeapprofdConfig.dump_at_max)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto__INCLUDED
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/config/sys_stats/sys_stats_config.pb.h
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/common/sys_stats_counters.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/common/sys_stats_counters.proto

#ifndef PROTOBUF_protos_2fperfetto_2fcommon_2fsys_5fstats_5fcounters_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2fcommon_2fsys_5fstats_5fcounters_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2fcommon_2fsys_5fstats_5fcounters_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2fsys_5fstats_5fcounters_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2fsys_5fstats_5fcounters_2eproto();


enum MeminfoCounters {
  MEMINFO_UNSPECIFIED = 0,
  MEMINFO_MEM_TOTAL = 1,
  MEMINFO_MEM_FREE = 2,
  MEMINFO_MEM_AVAILABLE = 3,
  MEMINFO_BUFFERS = 4,
  MEMINFO_CACHED = 5,
  MEMINFO_SWAP_CACHED = 6,
  MEMINFO_ACTIVE = 7,
  MEMINFO_INACTIVE = 8,
  MEMINFO_ACTIVE_ANON = 9,
  MEMINFO_INACTIVE_ANON = 10,
  MEMINFO_ACTIVE_FILE = 11,
  MEMINFO_INACTIVE_FILE = 12,
  MEMINFO_UNEVICTABLE = 13,
  MEMINFO_MLOCKED = 14,
  MEMINFO_SWAP_TOTAL = 15,
  MEMINFO_SWAP_FREE = 16,
  MEMINFO_DIRTY = 17,
  MEMINFO_WRITEBACK = 18,
  MEMINFO_ANON_PAGES = 19,
  MEMINFO_MAPPED = 20,
  MEMINFO_SHMEM = 21,
  MEMINFO_SLAB = 22,
  MEMINFO_SLAB_RECLAIMABLE = 23,
  MEMINFO_SLAB_UNRECLAIMABLE = 24,
  MEMINFO_KERNEL_STACK = 25,
  MEMINFO_PAGE_TABLES = 26,
  MEMINFO_COMMIT_LIMIT = 27,
  MEMINFO_COMMITED_AS = 28,
  MEMINFO_VMALLOC_TOTAL = 29,
  MEMINFO_VMALLOC_USED = 30,
  MEMINFO_VMALLOC_CHUNK = 31,
  MEMINFO_CMA_TOTAL = 32,
  MEMINFO_CMA_FREE = 33
};
bool MeminfoCounters_IsValid(int value);
const MeminfoCounters MeminfoCounters_MIN = MEMINFO_UNSPECIFIED;
const MeminfoCounters MeminfoCounters_MAX = MEMINFO_CMA_FREE;
const int MeminfoCounters_ARRAYSIZE = MeminfoCounters_MAX + 1;

enum VmstatCounters {
  VMSTAT_UNSPECIFIED = 0,
  VMSTAT_NR_FREE_PAGES = 1,
  VMSTAT_NR_ALLOC_BATCH = 2,
  VMSTAT_NR_INACTIVE_ANON = 3,
  VMSTAT_NR_ACTIVE_ANON = 4,
  VMSTAT_NR_INACTIVE_FILE = 5,
  VMSTAT_NR_ACTIVE_FILE = 6,
  VMSTAT_NR_UNEVICTABLE = 7,
  VMSTAT_NR_MLOCK = 8,
  VMSTAT_NR_ANON_PAGES = 9,
  VMSTAT_NR_MAPPED = 10,
  VMSTAT_NR_FILE_PAGES = 11,
  VMSTAT_NR_DIRTY = 12,
  VMSTAT_NR_WRITEBACK = 13,
  VMSTAT_NR_SLAB_RECLAIMABLE = 14,
  VMSTAT_NR_SLAB_UNRECLAIMABLE = 15,
  VMSTAT_NR_PAGE_TABLE_PAGES = 16,
  VMSTAT_NR_KERNEL_STACK = 17,
  VMSTAT_NR_OVERHEAD = 18,
  VMSTAT_NR_UNSTABLE = 19,
  VMSTAT_NR_BOUNCE = 20,
  VMSTAT_NR_VMSCAN_WRITE = 21,
  VMSTAT_NR_VMSCAN_IMMEDIATE_RECLAIM = 22,
  VMSTAT_NR_WRITEBACK_TEMP = 23,
  VMSTAT_NR_ISOLATED_ANON = 24,
  VMSTAT_NR_ISOLATED_FILE = 25,
  VMSTAT_NR_SHMEM = 26,
  VMSTAT_NR_DIRTIED = 27,
  VMSTAT_NR_WRITTEN = 28,
  VMSTAT_NR_PAGES_SCANNED = 29,
  VMSTAT_WORKINGSET_REFAULT = 30,
  VMSTAT_WORKINGSET_ACTIVATE = 31,
  VMSTAT_WORKINGSET_NODERECLAIM = 32,
  VMSTAT_NR_ANON_TRANSPARENT_HUGEPAGES = 33,
  VMSTAT_NR_FREE_CMA = 34,
  VMSTAT_NR_SWAPCACHE = 35,
  VMSTAT_NR_DIRTY_THRESHOLD = 36,
  VMSTAT_NR_DIRTY_BACKGROUND_THRESHOLD = 37,
  VMSTAT_PGPGIN = 38,
  VMSTAT_PGPGOUT = 39,
  VMSTAT_PGPGOUTCLEAN = 40,
  VMSTAT_PSWPIN = 41,
  VMSTAT_PSWPOUT = 42,
  VMSTAT_PGALLOC_DMA = 43,
  VMSTAT_PGALLOC_NORMAL = 44,
  VMSTAT_PGALLOC_MOVABLE = 45,
  VMSTAT_PGFREE = 46,
  VMSTAT_PGACTIVATE = 47,
  VMSTAT_PGDEACTIVATE = 48,
  VMSTAT_PGFAULT = 49,
  VMSTAT_PGMAJFAULT = 50,
  VMSTAT_PGREFILL_DMA = 51,
  VMSTAT_PGREFILL_NORMAL = 52,
  VMSTAT_PGREFILL_MOVABLE = 53,
  VMSTAT_PGSTEAL_KSWAPD_DMA = 54,
  VMSTAT_PGSTEAL_KSWAPD_NORMAL = 55,
  VMSTAT_PGSTEAL_KSWAPD_MOVABLE = 56,
  VMSTAT_PGSTEAL_DIRECT_DMA = 57,
  VMSTAT_PGSTEAL_DIRECT_NORMAL = 58,
  VMSTAT_PGSTEAL_DIRECT_MOVABLE = 59,
  VMSTAT_PGSCAN_KSWAPD_DMA = 60,
  VMSTAT_PGSCAN_KSWAPD_NORMAL = 61,
  VMSTAT_PGSCAN_KSWAPD_MOVABLE = 62,
  VMSTAT_PGSCAN_DIRECT_DMA = 63,
  VMSTAT_PGSCAN_DIRECT_NORMAL = 64,
  VMSTAT_PGSCAN_DIRECT_MOVABLE = 65,
  VMSTAT_PGSCAN_DIRECT_THROTTLE = 66,
  VMSTAT_PGINODESTEAL = 67,
  VMSTAT_SLABS_SCANNED = 68,
  VMSTAT_KSWAPD_INODESTEAL = 69,
  VMSTAT_KSWAPD_LOW_WMARK_HIT_QUICKLY = 70,
  VMSTAT_KSWAPD_HIGH_WMARK_HIT_QUICKLY = 71,
  VMSTAT_PAGEOUTRUN = 72,
  VMSTAT_ALLOCSTALL = 73,
  VMSTAT_PGROTATED = 74,
  VMSTAT_DROP_PAGECACHE = 75,
  VMSTAT_DROP_SLAB = 76,
  VMSTAT_PGMIGRATE_SUCCESS = 77,
  VMSTAT_PGMIGRATE_FAIL = 78,
  VMSTAT_COMPACT_MIGRATE_SCANNED = 79,
  VMSTAT_COMPACT_FREE_SCANNED = 80,
  VMSTAT_COMPACT_ISOLATED = 81,
  VMSTAT_COMPACT_STALL = 82,
  VMSTAT_COMPACT_FAIL = 83,
  VMSTAT_COMPACT_SUCCESS = 84,
  VMSTAT_COMPACT_DAEMON_WAKE = 85,
  VMSTAT_UNEVICTABLE_PGS_CULLED = 86,
  VMSTAT_UNEVICTABLE_PGS_SCANNED = 87,
  VMSTAT_UNEVICTABLE_PGS_RESCUED = 88,
  VMSTAT_UNEVICTABLE_PGS_MLOCKED = 89,
  VMSTAT_UNEVICTABLE_PGS_MUNLOCKED = 90,
  VMSTAT_UNEVICTABLE_PGS_CLEARED = 91,
  VMSTAT_UNEVICTABLE_PGS_STRANDED = 92,
  VMSTAT_NR_ZSPAGES = 93,
  VMSTAT_NR_ION_HEAP = 94,
  VMSTAT_NR_GPU_HEAP = 95
};
bool VmstatCounters_IsValid(int value);
const VmstatCounters VmstatCounters_MIN = VMSTAT_UNSPECIFIED;
const VmstatCounters VmstatCounters_MAX = VMSTAT_NR_GPU_HEAP;
const int VmstatCounters_ARRAYSIZE = VmstatCounters_MAX + 1;

// ===================================================================


// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::perfetto::protos::MeminfoCounters> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::perfetto::protos::VmstatCounters> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2fcommon_2fsys_5fstats_5fcounters_2eproto__INCLUDED
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/config/sys_stats/sys_stats_config.proto

#ifndef PROTOBUF_protos_2fperfetto_2fconfig_2fsys_5fstats_2fsys_5fstats_5fconfig_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2fconfig_2fsys_5fstats_2fsys_5fstats_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
// gen_amalgamated expanded: #include "protos/perfetto/common/sys_stats_counters.pb.h"
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2fconfig_2fsys_5fstats_2fsys_5fstats_5fconfig_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2fsys_5fstats_2fsys_5fstats_5fconfig_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2fsys_5fstats_2fsys_5fstats_5fconfig_2eproto();

class SysStatsConfig;

enum SysStatsConfig_StatCounters {
  SysStatsConfig_StatCounters_STAT_UNSPECIFIED = 0,
  SysStatsConfig_StatCounters_STAT_CPU_TIMES = 1,
  SysStatsConfig_StatCounters_STAT_IRQ_COUNTS = 2,
  SysStatsConfig_StatCounters_STAT_SOFTIRQ_COUNTS = 3,
  SysStatsConfig_StatCounters_STAT_FORK_COUNT = 4
};
bool SysStatsConfig_StatCounters_IsValid(int value);
const SysStatsConfig_StatCounters SysStatsConfig_StatCounters_StatCounters_MIN = SysStatsConfig_StatCounters_STAT_UNSPECIFIED;
const SysStatsConfig_StatCounters SysStatsConfig_StatCounters_StatCounters_MAX = SysStatsConfig_StatCounters_STAT_FORK_COUNT;
const int SysStatsConfig_StatCounters_StatCounters_ARRAYSIZE = SysStatsConfig_StatCounters_StatCounters_MAX + 1;

// ===================================================================

class SysStatsConfig : public ::google::protobuf::MessageLite {
 public:
  SysStatsConfig();
  virtual ~SysStatsConfig();

  SysStatsConfig(const SysStatsConfig& from);

  inline SysStatsConfig& operator=(const SysStatsConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const SysStatsConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SysStatsConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SysStatsConfig* other);

  // implements Message ----------------------------------------------

  inline SysStatsConfig* New() const { return New(NULL); }

  SysStatsConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SysStatsConfig& from);
  void MergeFrom(const SysStatsConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SysStatsConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef SysStatsConfig_StatCounters StatCounters;
  static const StatCounters STAT_UNSPECIFIED =
    SysStatsConfig_StatCounters_STAT_UNSPECIFIED;
  static const StatCounters STAT_CPU_TIMES =
    SysStatsConfig_StatCounters_STAT_CPU_TIMES;
  static const StatCounters STAT_IRQ_COUNTS =
    SysStatsConfig_StatCounters_STAT_IRQ_COUNTS;
  static const StatCounters STAT_SOFTIRQ_COUNTS =
    SysStatsConfig_StatCounters_STAT_SOFTIRQ_COUNTS;
  static const StatCounters STAT_FORK_COUNT =
    SysStatsConfig_StatCounters_STAT_FORK_COUNT;
  static inline bool StatCounters_IsValid(int value) {
    return SysStatsConfig_StatCounters_IsValid(value);
  }
  static const StatCounters StatCounters_MIN =
    SysStatsConfig_StatCounters_StatCounters_MIN;
  static const StatCounters StatCounters_MAX =
    SysStatsConfig_StatCounters_StatCounters_MAX;
  static const int StatCounters_ARRAYSIZE =
    SysStatsConfig_StatCounters_StatCounters_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional uint32 meminfo_period_ms = 1;
  bool has_meminfo_period_ms() const;
  void clear_meminfo_period_ms();
  static const int kMeminfoPeriodMsFieldNumber = 1;
  ::google::protobuf::uint32 meminfo_period_ms() const;
  void set_meminfo_period_ms(::google::protobuf::uint32 value);

  // repeated .perfetto.protos.MeminfoCounters meminfo_counters = 2;
  int meminfo_counters_size() const;
  void clear_meminfo_counters();
  static const int kMeminfoCountersFieldNumber = 2;
  ::perfetto::protos::MeminfoCounters meminfo_counters(int index) const;
  void set_meminfo_counters(int index, ::perfetto::protos::MeminfoCounters value);
  void add_meminfo_counters(::perfetto::protos::MeminfoCounters value);
  const ::google::protobuf::RepeatedField<int>& meminfo_counters() const;
  ::google::protobuf::RepeatedField<int>* mutable_meminfo_counters();

  // optional uint32 vmstat_period_ms = 3;
  bool has_vmstat_period_ms() const;
  void clear_vmstat_period_ms();
  static const int kVmstatPeriodMsFieldNumber = 3;
  ::google::protobuf::uint32 vmstat_period_ms() const;
  void set_vmstat_period_ms(::google::protobuf::uint32 value);

  // repeated .perfetto.protos.VmstatCounters vmstat_counters = 4;
  int vmstat_counters_size() const;
  void clear_vmstat_counters();
  static const int kVmstatCountersFieldNumber = 4;
  ::perfetto::protos::VmstatCounters vmstat_counters(int index) const;
  void set_vmstat_counters(int index, ::perfetto::protos::VmstatCounters value);
  void add_vmstat_counters(::perfetto::protos::VmstatCounters value);
  const ::google::protobuf::RepeatedField<int>& vmstat_counters() const;
  ::google::protobuf::RepeatedField<int>* mutable_vmstat_counters();

  // optional uint32 stat_period_ms = 5;
  bool has_stat_period_ms() const;
  void clear_stat_period_ms();
  static const int kStatPeriodMsFieldNumber = 5;
  ::google::protobuf::uint32 stat_period_ms() const;
  void set_stat_period_ms(::google::protobuf::uint32 value);

  // repeated .perfetto.protos.SysStatsConfig.StatCounters stat_counters = 6;
  int stat_counters_size() const;
  void clear_stat_counters();
  static const int kStatCountersFieldNumber = 6;
  ::perfetto::protos::SysStatsConfig_StatCounters stat_counters(int index) const;
  void set_stat_counters(int index, ::perfetto::protos::SysStatsConfig_StatCounters value);
  void add_stat_counters(::perfetto::protos::SysStatsConfig_StatCounters value);
  const ::google::protobuf::RepeatedField<int>& stat_counters() const;
  ::google::protobuf::RepeatedField<int>* mutable_stat_counters();

  // @@protoc_insertion_point(class_scope:perfetto.protos.SysStatsConfig)
 private:
  inline void set_has_meminfo_period_ms();
  inline void clear_has_meminfo_period_ms();
  inline void set_has_vmstat_period_ms();
  inline void clear_has_vmstat_period_ms();
  inline void set_has_stat_period_ms();
  inline void clear_has_stat_period_ms();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField<int> meminfo_counters_;
  ::google::protobuf::uint32 meminfo_period_ms_;
  ::google::protobuf::uint32 vmstat_period_ms_;
  ::google::protobuf::RepeatedField<int> vmstat_counters_;
  ::google::protobuf::RepeatedField<int> stat_counters_;
  ::google::protobuf::uint32 stat_period_ms_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2fsys_5fstats_2fsys_5fstats_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2fsys_5fstats_2fsys_5fstats_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2fsys_5fstats_2fsys_5fstats_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2fsys_5fstats_2fsys_5fstats_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static SysStatsConfig* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// SysStatsConfig

// optional uint32 meminfo_period_ms = 1;
inline bool SysStatsConfig::has_meminfo_period_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SysStatsConfig::set_has_meminfo_period_ms() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SysStatsConfig::clear_has_meminfo_period_ms() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SysStatsConfig::clear_meminfo_period_ms() {
  meminfo_period_ms_ = 0u;
  clear_has_meminfo_period_ms();
}
inline ::google::protobuf::uint32 SysStatsConfig::meminfo_period_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SysStatsConfig.meminfo_period_ms)
  return meminfo_period_ms_;
}
inline void SysStatsConfig::set_meminfo_period_ms(::google::protobuf::uint32 value) {
  set_has_meminfo_period_ms();
  meminfo_period_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.SysStatsConfig.meminfo_period_ms)
}

// repeated .perfetto.protos.MeminfoCounters meminfo_counters = 2;
inline int SysStatsConfig::meminfo_counters_size() const {
  return meminfo_counters_.size();
}
inline void SysStatsConfig::clear_meminfo_counters() {
  meminfo_counters_.Clear();
}
inline ::perfetto::protos::MeminfoCounters SysStatsConfig::meminfo_counters(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SysStatsConfig.meminfo_counters)
  return static_cast< ::perfetto::protos::MeminfoCounters >(meminfo_counters_.Get(index));
}
inline void SysStatsConfig::set_meminfo_counters(int index, ::perfetto::protos::MeminfoCounters value) {
  assert(::perfetto::protos::MeminfoCounters_IsValid(value));
  meminfo_counters_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SysStatsConfig.meminfo_counters)
}
inline void SysStatsConfig::add_meminfo_counters(::perfetto::protos::MeminfoCounters value) {
  assert(::perfetto::protos::MeminfoCounters_IsValid(value));
  meminfo_counters_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.SysStatsConfig.meminfo_counters)
}
inline const ::google::protobuf::RepeatedField<int>&
SysStatsConfig::meminfo_counters() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.SysStatsConfig.meminfo_counters)
  return meminfo_counters_;
}
inline ::google::protobuf::RepeatedField<int>*
SysStatsConfig::mutable_meminfo_counters() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.SysStatsConfig.meminfo_counters)
  return &meminfo_counters_;
}

// optional uint32 vmstat_period_ms = 3;
inline bool SysStatsConfig::has_vmstat_period_ms() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SysStatsConfig::set_has_vmstat_period_ms() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SysStatsConfig::clear_has_vmstat_period_ms() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SysStatsConfig::clear_vmstat_period_ms() {
  vmstat_period_ms_ = 0u;
  clear_has_vmstat_period_ms();
}
inline ::google::protobuf::uint32 SysStatsConfig::vmstat_period_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SysStatsConfig.vmstat_period_ms)
  return vmstat_period_ms_;
}
inline void SysStatsConfig::set_vmstat_period_ms(::google::protobuf::uint32 value) {
  set_has_vmstat_period_ms();
  vmstat_period_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.SysStatsConfig.vmstat_period_ms)
}

// repeated .perfetto.protos.VmstatCounters vmstat_counters = 4;
inline int SysStatsConfig::vmstat_counters_size() const {
  return vmstat_counters_.size();
}
inline void SysStatsConfig::clear_vmstat_counters() {
  vmstat_counters_.Clear();
}
inline ::perfetto::protos::VmstatCounters SysStatsConfig::vmstat_counters(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SysStatsConfig.vmstat_counters)
  return static_cast< ::perfetto::protos::VmstatCounters >(vmstat_counters_.Get(index));
}
inline void SysStatsConfig::set_vmstat_counters(int index, ::perfetto::protos::VmstatCounters value) {
  assert(::perfetto::protos::VmstatCounters_IsValid(value));
  vmstat_counters_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SysStatsConfig.vmstat_counters)
}
inline void SysStatsConfig::add_vmstat_counters(::perfetto::protos::VmstatCounters value) {
  assert(::perfetto::protos::VmstatCounters_IsValid(value));
  vmstat_counters_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.SysStatsConfig.vmstat_counters)
}
inline const ::google::protobuf::RepeatedField<int>&
SysStatsConfig::vmstat_counters() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.SysStatsConfig.vmstat_counters)
  return vmstat_counters_;
}
inline ::google::protobuf::RepeatedField<int>*
SysStatsConfig::mutable_vmstat_counters() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.SysStatsConfig.vmstat_counters)
  return &vmstat_counters_;
}

// optional uint32 stat_period_ms = 5;
inline bool SysStatsConfig::has_stat_period_ms() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SysStatsConfig::set_has_stat_period_ms() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SysStatsConfig::clear_has_stat_period_ms() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SysStatsConfig::clear_stat_period_ms() {
  stat_period_ms_ = 0u;
  clear_has_stat_period_ms();
}
inline ::google::protobuf::uint32 SysStatsConfig::stat_period_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SysStatsConfig.stat_period_ms)
  return stat_period_ms_;
}
inline void SysStatsConfig::set_stat_period_ms(::google::protobuf::uint32 value) {
  set_has_stat_period_ms();
  stat_period_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.SysStatsConfig.stat_period_ms)
}

// repeated .perfetto.protos.SysStatsConfig.StatCounters stat_counters = 6;
inline int SysStatsConfig::stat_counters_size() const {
  return stat_counters_.size();
}
inline void SysStatsConfig::clear_stat_counters() {
  stat_counters_.Clear();
}
inline ::perfetto::protos::SysStatsConfig_StatCounters SysStatsConfig::stat_counters(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SysStatsConfig.stat_counters)
  return static_cast< ::perfetto::protos::SysStatsConfig_StatCounters >(stat_counters_.Get(index));
}
inline void SysStatsConfig::set_stat_counters(int index, ::perfetto::protos::SysStatsConfig_StatCounters value) {
  assert(::perfetto::protos::SysStatsConfig_StatCounters_IsValid(value));
  stat_counters_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SysStatsConfig.stat_counters)
}
inline void SysStatsConfig::add_stat_counters(::perfetto::protos::SysStatsConfig_StatCounters value) {
  assert(::perfetto::protos::SysStatsConfig_StatCounters_IsValid(value));
  stat_counters_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.SysStatsConfig.stat_counters)
}
inline const ::google::protobuf::RepeatedField<int>&
SysStatsConfig::stat_counters() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.SysStatsConfig.stat_counters)
  return stat_counters_;
}
inline ::google::protobuf::RepeatedField<int>*
SysStatsConfig::mutable_stat_counters() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.SysStatsConfig.stat_counters)
  return &stat_counters_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::perfetto::protos::SysStatsConfig_StatCounters> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2fconfig_2fsys_5fstats_2fsys_5fstats_5fconfig_2eproto__INCLUDED
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/config/chrome/chrome_config.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/config/chrome/chrome_config.proto

#ifndef PROTOBUF_protos_2fperfetto_2fconfig_2fchrome_2fchrome_5fconfig_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2fconfig_2fchrome_2fchrome_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2fconfig_2fchrome_2fchrome_5fconfig_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2fchrome_2fchrome_5fconfig_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2fchrome_2fchrome_5fconfig_2eproto();

class ChromeConfig;

// ===================================================================

class ChromeConfig : public ::google::protobuf::MessageLite {
 public:
  ChromeConfig();
  virtual ~ChromeConfig();

  ChromeConfig(const ChromeConfig& from);

  inline ChromeConfig& operator=(const ChromeConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ChromeConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ChromeConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ChromeConfig* other);

  // implements Message ----------------------------------------------

  inline ChromeConfig* New() const { return New(NULL); }

  ChromeConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChromeConfig& from);
  void MergeFrom(const ChromeConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChromeConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string trace_config = 1;
  bool has_trace_config() const;
  void clear_trace_config();
  static const int kTraceConfigFieldNumber = 1;
  const ::std::string& trace_config() const;
  void set_trace_config(const ::std::string& value);
  void set_trace_config(const char* value);
  void set_trace_config(const char* value, size_t size);
  ::std::string* mutable_trace_config();
  ::std::string* release_trace_config();
  void set_allocated_trace_config(::std::string* trace_config);

  // optional bool privacy_filtering_enabled = 2;
  bool has_privacy_filtering_enabled() const;
  void clear_privacy_filtering_enabled();
  static const int kPrivacyFilteringEnabledFieldNumber = 2;
  bool privacy_filtering_enabled() const;
  void set_privacy_filtering_enabled(bool value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.ChromeConfig)
 private:
  inline void set_has_trace_config();
  inline void clear_has_trace_config();
  inline void set_has_privacy_filtering_enabled();
  inline void clear_has_privacy_filtering_enabled();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr trace_config_;
  bool privacy_filtering_enabled_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2fchrome_2fchrome_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2fchrome_2fchrome_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2fchrome_2fchrome_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2fchrome_2fchrome_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static ChromeConfig* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// ChromeConfig

// optional string trace_config = 1;
inline bool ChromeConfig::has_trace_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChromeConfig::set_has_trace_config() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChromeConfig::clear_has_trace_config() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChromeConfig::clear_trace_config() {
  trace_config_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_trace_config();
}
inline const ::std::string& ChromeConfig::trace_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ChromeConfig.trace_config)
  return trace_config_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChromeConfig::set_trace_config(const ::std::string& value) {
  set_has_trace_config();
  trace_config_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.ChromeConfig.trace_config)
}
inline void ChromeConfig::set_trace_config(const char* value) {
  set_has_trace_config();
  trace_config_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.ChromeConfig.trace_config)
}
inline void ChromeConfig::set_trace_config(const char* value, size_t size) {
  set_has_trace_config();
  trace_config_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.ChromeConfig.trace_config)
}
inline ::std::string* ChromeConfig::mutable_trace_config() {
  set_has_trace_config();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.ChromeConfig.trace_config)
  return trace_config_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChromeConfig::release_trace_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.ChromeConfig.trace_config)
  clear_has_trace_config();
  return trace_config_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChromeConfig::set_allocated_trace_config(::std::string* trace_config) {
  if (trace_config != NULL) {
    set_has_trace_config();
  } else {
    clear_has_trace_config();
  }
  trace_config_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), trace_config);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.ChromeConfig.trace_config)
}

// optional bool privacy_filtering_enabled = 2;
inline bool ChromeConfig::has_privacy_filtering_enabled() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChromeConfig::set_has_privacy_filtering_enabled() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChromeConfig::clear_has_privacy_filtering_enabled() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChromeConfig::clear_privacy_filtering_enabled() {
  privacy_filtering_enabled_ = false;
  clear_has_privacy_filtering_enabled();
}
inline bool ChromeConfig::privacy_filtering_enabled() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ChromeConfig.privacy_filtering_enabled)
  return privacy_filtering_enabled_;
}
inline void ChromeConfig::set_privacy_filtering_enabled(bool value) {
  set_has_privacy_filtering_enabled();
  privacy_filtering_enabled_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.ChromeConfig.privacy_filtering_enabled)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2fconfig_2fchrome_2fchrome_5fconfig_2eproto__INCLUDED
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/config/data_source_config.pb.h
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/config/android/android_log_config.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/config/android/android_log_config.proto

#ifndef PROTOBUF_protos_2fperfetto_2fconfig_2fandroid_2fandroid_5flog_5fconfig_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2fconfig_2fandroid_2fandroid_5flog_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// gen_amalgamated expanded: #include "protos/perfetto/common/android_log_constants.pb.h"
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2fconfig_2fandroid_2fandroid_5flog_5fconfig_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2fandroid_2fandroid_5flog_5fconfig_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2fandroid_2fandroid_5flog_5fconfig_2eproto();

class AndroidLogConfig;

// ===================================================================

class AndroidLogConfig : public ::google::protobuf::MessageLite {
 public:
  AndroidLogConfig();
  virtual ~AndroidLogConfig();

  AndroidLogConfig(const AndroidLogConfig& from);

  inline AndroidLogConfig& operator=(const AndroidLogConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const AndroidLogConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AndroidLogConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AndroidLogConfig* other);

  // implements Message ----------------------------------------------

  inline AndroidLogConfig* New() const { return New(NULL); }

  AndroidLogConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AndroidLogConfig& from);
  void MergeFrom(const AndroidLogConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AndroidLogConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .perfetto.protos.AndroidLogId log_ids = 1;
  int log_ids_size() const;
  void clear_log_ids();
  static const int kLogIdsFieldNumber = 1;
  ::perfetto::protos::AndroidLogId log_ids(int index) const;
  void set_log_ids(int index, ::perfetto::protos::AndroidLogId value);
  void add_log_ids(::perfetto::protos::AndroidLogId value);
  const ::google::protobuf::RepeatedField<int>& log_ids() const;
  ::google::protobuf::RepeatedField<int>* mutable_log_ids();

  // optional .perfetto.protos.AndroidLogPriority min_prio = 3;
  bool has_min_prio() const;
  void clear_min_prio();
  static const int kMinPrioFieldNumber = 3;
  ::perfetto::protos::AndroidLogPriority min_prio() const;
  void set_min_prio(::perfetto::protos::AndroidLogPriority value);

  // repeated string filter_tags = 4;
  int filter_tags_size() const;
  void clear_filter_tags();
  static const int kFilterTagsFieldNumber = 4;
  const ::std::string& filter_tags(int index) const;
  ::std::string* mutable_filter_tags(int index);
  void set_filter_tags(int index, const ::std::string& value);
  void set_filter_tags(int index, const char* value);
  void set_filter_tags(int index, const char* value, size_t size);
  ::std::string* add_filter_tags();
  void add_filter_tags(const ::std::string& value);
  void add_filter_tags(const char* value);
  void add_filter_tags(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& filter_tags() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_filter_tags();

  // @@protoc_insertion_point(class_scope:perfetto.protos.AndroidLogConfig)
 private:
  inline void set_has_min_prio();
  inline void clear_has_min_prio();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField<int> log_ids_;
  ::google::protobuf::RepeatedPtrField< ::std::string> filter_tags_;
  int min_prio_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2fandroid_2fandroid_5flog_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2fandroid_2fandroid_5flog_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2fandroid_2fandroid_5flog_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2fandroid_2fandroid_5flog_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static AndroidLogConfig* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// AndroidLogConfig

// repeated .perfetto.protos.AndroidLogId log_ids = 1;
inline int AndroidLogConfig::log_ids_size() const {
  return log_ids_.size();
}
inline void AndroidLogConfig::clear_log_ids() {
  log_ids_.Clear();
}
inline ::perfetto::protos::AndroidLogId AndroidLogConfig::log_ids(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AndroidLogConfig.log_ids)
  return static_cast< ::perfetto::protos::AndroidLogId >(log_ids_.Get(index));
}
inline void AndroidLogConfig::set_log_ids(int index, ::perfetto::protos::AndroidLogId value) {
  assert(::perfetto::protos::AndroidLogId_IsValid(value));
  log_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.AndroidLogConfig.log_ids)
}
inline void AndroidLogConfig::add_log_ids(::perfetto::protos::AndroidLogId value) {
  assert(::perfetto::protos::AndroidLogId_IsValid(value));
  log_ids_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.AndroidLogConfig.log_ids)
}
inline const ::google::protobuf::RepeatedField<int>&
AndroidLogConfig::log_ids() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.AndroidLogConfig.log_ids)
  return log_ids_;
}
inline ::google::protobuf::RepeatedField<int>*
AndroidLogConfig::mutable_log_ids() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.AndroidLogConfig.log_ids)
  return &log_ids_;
}

// optional .perfetto.protos.AndroidLogPriority min_prio = 3;
inline bool AndroidLogConfig::has_min_prio() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AndroidLogConfig::set_has_min_prio() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AndroidLogConfig::clear_has_min_prio() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AndroidLogConfig::clear_min_prio() {
  min_prio_ = 0;
  clear_has_min_prio();
}
inline ::perfetto::protos::AndroidLogPriority AndroidLogConfig::min_prio() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AndroidLogConfig.min_prio)
  return static_cast< ::perfetto::protos::AndroidLogPriority >(min_prio_);
}
inline void AndroidLogConfig::set_min_prio(::perfetto::protos::AndroidLogPriority value) {
  assert(::perfetto::protos::AndroidLogPriority_IsValid(value));
  set_has_min_prio();
  min_prio_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.AndroidLogConfig.min_prio)
}

// repeated string filter_tags = 4;
inline int AndroidLogConfig::filter_tags_size() const {
  return filter_tags_.size();
}
inline void AndroidLogConfig::clear_filter_tags() {
  filter_tags_.Clear();
}
inline const ::std::string& AndroidLogConfig::filter_tags(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AndroidLogConfig.filter_tags)
  return filter_tags_.Get(index);
}
inline ::std::string* AndroidLogConfig::mutable_filter_tags(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.AndroidLogConfig.filter_tags)
  return filter_tags_.Mutable(index);
}
inline void AndroidLogConfig::set_filter_tags(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.AndroidLogConfig.filter_tags)
  filter_tags_.Mutable(index)->assign(value);
}
inline void AndroidLogConfig::set_filter_tags(int index, const char* value) {
  filter_tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.AndroidLogConfig.filter_tags)
}
inline void AndroidLogConfig::set_filter_tags(int index, const char* value, size_t size) {
  filter_tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.AndroidLogConfig.filter_tags)
}
inline ::std::string* AndroidLogConfig::add_filter_tags() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.AndroidLogConfig.filter_tags)
  return filter_tags_.Add();
}
inline void AndroidLogConfig::add_filter_tags(const ::std::string& value) {
  filter_tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.AndroidLogConfig.filter_tags)
}
inline void AndroidLogConfig::add_filter_tags(const char* value) {
  filter_tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.AndroidLogConfig.filter_tags)
}
inline void AndroidLogConfig::add_filter_tags(const char* value, size_t size) {
  filter_tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.AndroidLogConfig.filter_tags)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AndroidLogConfig::filter_tags() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.AndroidLogConfig.filter_tags)
  return filter_tags_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AndroidLogConfig::mutable_filter_tags() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.AndroidLogConfig.filter_tags)
  return &filter_tags_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2fconfig_2fandroid_2fandroid_5flog_5fconfig_2eproto__INCLUDED
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/config/android/packages_list_config.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/config/android/packages_list_config.proto

#ifndef PROTOBUF_protos_2fperfetto_2fconfig_2fandroid_2fpackages_5flist_5fconfig_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2fconfig_2fandroid_2fpackages_5flist_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2fconfig_2fandroid_2fpackages_5flist_5fconfig_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2fandroid_2fpackages_5flist_5fconfig_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2fandroid_2fpackages_5flist_5fconfig_2eproto();

class PackagesListConfig;

// ===================================================================

class PackagesListConfig : public ::google::protobuf::MessageLite {
 public:
  PackagesListConfig();
  virtual ~PackagesListConfig();

  PackagesListConfig(const PackagesListConfig& from);

  inline PackagesListConfig& operator=(const PackagesListConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const PackagesListConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PackagesListConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PackagesListConfig* other);

  // implements Message ----------------------------------------------

  inline PackagesListConfig* New() const { return New(NULL); }

  PackagesListConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PackagesListConfig& from);
  void MergeFrom(const PackagesListConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PackagesListConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string package_name_filter = 1;
  int package_name_filter_size() const;
  void clear_package_name_filter();
  static const int kPackageNameFilterFieldNumber = 1;
  const ::std::string& package_name_filter(int index) const;
  ::std::string* mutable_package_name_filter(int index);
  void set_package_name_filter(int index, const ::std::string& value);
  void set_package_name_filter(int index, const char* value);
  void set_package_name_filter(int index, const char* value, size_t size);
  ::std::string* add_package_name_filter();
  void add_package_name_filter(const ::std::string& value);
  void add_package_name_filter(const char* value);
  void add_package_name_filter(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& package_name_filter() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_package_name_filter();

  // @@protoc_insertion_point(class_scope:perfetto.protos.PackagesListConfig)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> package_name_filter_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2fandroid_2fpackages_5flist_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2fandroid_2fpackages_5flist_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2fandroid_2fpackages_5flist_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2fandroid_2fpackages_5flist_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static PackagesListConfig* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// PackagesListConfig

// repeated string package_name_filter = 1;
inline int PackagesListConfig::package_name_filter_size() const {
  return package_name_filter_.size();
}
inline void PackagesListConfig::clear_package_name_filter() {
  package_name_filter_.Clear();
}
inline const ::std::string& PackagesListConfig::package_name_filter(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.PackagesListConfig.package_name_filter)
  return package_name_filter_.Get(index);
}
inline ::std::string* PackagesListConfig::mutable_package_name_filter(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.PackagesListConfig.package_name_filter)
  return package_name_filter_.Mutable(index);
}
inline void PackagesListConfig::set_package_name_filter(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.PackagesListConfig.package_name_filter)
  package_name_filter_.Mutable(index)->assign(value);
}
inline void PackagesListConfig::set_package_name_filter(int index, const char* value) {
  package_name_filter_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.PackagesListConfig.package_name_filter)
}
inline void PackagesListConfig::set_package_name_filter(int index, const char* value, size_t size) {
  package_name_filter_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.PackagesListConfig.package_name_filter)
}
inline ::std::string* PackagesListConfig::add_package_name_filter() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.PackagesListConfig.package_name_filter)
  return package_name_filter_.Add();
}
inline void PackagesListConfig::add_package_name_filter(const ::std::string& value) {
  package_name_filter_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.PackagesListConfig.package_name_filter)
}
inline void PackagesListConfig::add_package_name_filter(const char* value) {
  package_name_filter_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.PackagesListConfig.package_name_filter)
}
inline void PackagesListConfig::add_package_name_filter(const char* value, size_t size) {
  package_name_filter_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.PackagesListConfig.package_name_filter)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PackagesListConfig::package_name_filter() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.PackagesListConfig.package_name_filter)
  return package_name_filter_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PackagesListConfig::mutable_package_name_filter() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.PackagesListConfig.package_name_filter)
  return &package_name_filter_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2fconfig_2fandroid_2fpackages_5flist_5fconfig_2eproto__INCLUDED
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/config/chrome/chrome_config.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/config/chrome/chrome_config.proto

#ifndef PROTOBUF_protos_2fperfetto_2fconfig_2fchrome_2fchrome_5fconfig_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2fconfig_2fchrome_2fchrome_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2fconfig_2fchrome_2fchrome_5fconfig_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2fchrome_2fchrome_5fconfig_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2fchrome_2fchrome_5fconfig_2eproto();

class ChromeConfig;

// ===================================================================

class ChromeConfig : public ::google::protobuf::MessageLite {
 public:
  ChromeConfig();
  virtual ~ChromeConfig();

  ChromeConfig(const ChromeConfig& from);

  inline ChromeConfig& operator=(const ChromeConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ChromeConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ChromeConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ChromeConfig* other);

  // implements Message ----------------------------------------------

  inline ChromeConfig* New() const { return New(NULL); }

  ChromeConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChromeConfig& from);
  void MergeFrom(const ChromeConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChromeConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string trace_config = 1;
  bool has_trace_config() const;
  void clear_trace_config();
  static const int kTraceConfigFieldNumber = 1;
  const ::std::string& trace_config() const;
  void set_trace_config(const ::std::string& value);
  void set_trace_config(const char* value);
  void set_trace_config(const char* value, size_t size);
  ::std::string* mutable_trace_config();
  ::std::string* release_trace_config();
  void set_allocated_trace_config(::std::string* trace_config);

  // optional bool privacy_filtering_enabled = 2;
  bool has_privacy_filtering_enabled() const;
  void clear_privacy_filtering_enabled();
  static const int kPrivacyFilteringEnabledFieldNumber = 2;
  bool privacy_filtering_enabled() const;
  void set_privacy_filtering_enabled(bool value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.ChromeConfig)
 private:
  inline void set_has_trace_config();
  inline void clear_has_trace_config();
  inline void set_has_privacy_filtering_enabled();
  inline void clear_has_privacy_filtering_enabled();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr trace_config_;
  bool privacy_filtering_enabled_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2fchrome_2fchrome_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2fchrome_2fchrome_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2fchrome_2fchrome_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2fchrome_2fchrome_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static ChromeConfig* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// ChromeConfig

// optional string trace_config = 1;
inline bool ChromeConfig::has_trace_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChromeConfig::set_has_trace_config() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChromeConfig::clear_has_trace_config() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChromeConfig::clear_trace_config() {
  trace_config_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_trace_config();
}
inline const ::std::string& ChromeConfig::trace_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ChromeConfig.trace_config)
  return trace_config_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChromeConfig::set_trace_config(const ::std::string& value) {
  set_has_trace_config();
  trace_config_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.ChromeConfig.trace_config)
}
inline void ChromeConfig::set_trace_config(const char* value) {
  set_has_trace_config();
  trace_config_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.ChromeConfig.trace_config)
}
inline void ChromeConfig::set_trace_config(const char* value, size_t size) {
  set_has_trace_config();
  trace_config_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.ChromeConfig.trace_config)
}
inline ::std::string* ChromeConfig::mutable_trace_config() {
  set_has_trace_config();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.ChromeConfig.trace_config)
  return trace_config_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChromeConfig::release_trace_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.ChromeConfig.trace_config)
  clear_has_trace_config();
  return trace_config_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChromeConfig::set_allocated_trace_config(::std::string* trace_config) {
  if (trace_config != NULL) {
    set_has_trace_config();
  } else {
    clear_has_trace_config();
  }
  trace_config_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), trace_config);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.ChromeConfig.trace_config)
}

// optional bool privacy_filtering_enabled = 2;
inline bool ChromeConfig::has_privacy_filtering_enabled() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChromeConfig::set_has_privacy_filtering_enabled() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChromeConfig::clear_has_privacy_filtering_enabled() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChromeConfig::clear_privacy_filtering_enabled() {
  privacy_filtering_enabled_ = false;
  clear_has_privacy_filtering_enabled();
}
inline bool ChromeConfig::privacy_filtering_enabled() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ChromeConfig.privacy_filtering_enabled)
  return privacy_filtering_enabled_;
}
inline void ChromeConfig::set_privacy_filtering_enabled(bool value) {
  set_has_privacy_filtering_enabled();
  privacy_filtering_enabled_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.ChromeConfig.privacy_filtering_enabled)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2fconfig_2fchrome_2fchrome_5fconfig_2eproto__INCLUDED
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/config/ftrace/ftrace_config.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/config/ftrace/ftrace_config.proto

#ifndef PROTOBUF_protos_2fperfetto_2fconfig_2fftrace_2fftrace_5fconfig_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2fconfig_2fftrace_2fftrace_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2fconfig_2fftrace_2fftrace_5fconfig_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2fftrace_2fftrace_5fconfig_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2fftrace_2fftrace_5fconfig_2eproto();

class FtraceConfig;

// ===================================================================

class FtraceConfig : public ::google::protobuf::MessageLite {
 public:
  FtraceConfig();
  virtual ~FtraceConfig();

  FtraceConfig(const FtraceConfig& from);

  inline FtraceConfig& operator=(const FtraceConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const FtraceConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FtraceConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FtraceConfig* other);

  // implements Message ----------------------------------------------

  inline FtraceConfig* New() const { return New(NULL); }

  FtraceConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FtraceConfig& from);
  void MergeFrom(const FtraceConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FtraceConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string ftrace_events = 1;
  int ftrace_events_size() const;
  void clear_ftrace_events();
  static const int kFtraceEventsFieldNumber = 1;
  const ::std::string& ftrace_events(int index) const;
  ::std::string* mutable_ftrace_events(int index);
  void set_ftrace_events(int index, const ::std::string& value);
  void set_ftrace_events(int index, const char* value);
  void set_ftrace_events(int index, const char* value, size_t size);
  ::std::string* add_ftrace_events();
  void add_ftrace_events(const ::std::string& value);
  void add_ftrace_events(const char* value);
  void add_ftrace_events(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& ftrace_events() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_ftrace_events();

  // repeated string atrace_categories = 2;
  int atrace_categories_size() const;
  void clear_atrace_categories();
  static const int kAtraceCategoriesFieldNumber = 2;
  const ::std::string& atrace_categories(int index) const;
  ::std::string* mutable_atrace_categories(int index);
  void set_atrace_categories(int index, const ::std::string& value);
  void set_atrace_categories(int index, const char* value);
  void set_atrace_categories(int index, const char* value, size_t size);
  ::std::string* add_atrace_categories();
  void add_atrace_categories(const ::std::string& value);
  void add_atrace_categories(const char* value);
  void add_atrace_categories(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& atrace_categories() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_atrace_categories();

  // repeated string atrace_apps = 3;
  int atrace_apps_size() const;
  void clear_atrace_apps();
  static const int kAtraceAppsFieldNumber = 3;
  const ::std::string& atrace_apps(int index) const;
  ::std::string* mutable_atrace_apps(int index);
  void set_atrace_apps(int index, const ::std::string& value);
  void set_atrace_apps(int index, const char* value);
  void set_atrace_apps(int index, const char* value, size_t size);
  ::std::string* add_atrace_apps();
  void add_atrace_apps(const ::std::string& value);
  void add_atrace_apps(const char* value);
  void add_atrace_apps(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& atrace_apps() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_atrace_apps();

  // optional uint32 buffer_size_kb = 10;
  bool has_buffer_size_kb() const;
  void clear_buffer_size_kb();
  static const int kBufferSizeKbFieldNumber = 10;
  ::google::protobuf::uint32 buffer_size_kb() const;
  void set_buffer_size_kb(::google::protobuf::uint32 value);

  // optional uint32 drain_period_ms = 11;
  bool has_drain_period_ms() const;
  void clear_drain_period_ms();
  static const int kDrainPeriodMsFieldNumber = 11;
  ::google::protobuf::uint32 drain_period_ms() const;
  void set_drain_period_ms(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.FtraceConfig)
 private:
  inline void set_has_buffer_size_kb();
  inline void clear_has_buffer_size_kb();
  inline void set_has_drain_period_ms();
  inline void clear_has_drain_period_ms();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> ftrace_events_;
  ::google::protobuf::RepeatedPtrField< ::std::string> atrace_categories_;
  ::google::protobuf::RepeatedPtrField< ::std::string> atrace_apps_;
  ::google::protobuf::uint32 buffer_size_kb_;
  ::google::protobuf::uint32 drain_period_ms_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2fftrace_2fftrace_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2fftrace_2fftrace_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2fftrace_2fftrace_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2fftrace_2fftrace_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static FtraceConfig* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// FtraceConfig

// repeated string ftrace_events = 1;
inline int FtraceConfig::ftrace_events_size() const {
  return ftrace_events_.size();
}
inline void FtraceConfig::clear_ftrace_events() {
  ftrace_events_.Clear();
}
inline const ::std::string& FtraceConfig::ftrace_events(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FtraceConfig.ftrace_events)
  return ftrace_events_.Get(index);
}
inline ::std::string* FtraceConfig::mutable_ftrace_events(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.FtraceConfig.ftrace_events)
  return ftrace_events_.Mutable(index);
}
inline void FtraceConfig::set_ftrace_events(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.FtraceConfig.ftrace_events)
  ftrace_events_.Mutable(index)->assign(value);
}
inline void FtraceConfig::set_ftrace_events(int index, const char* value) {
  ftrace_events_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.FtraceConfig.ftrace_events)
}
inline void FtraceConfig::set_ftrace_events(int index, const char* value, size_t size) {
  ftrace_events_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.FtraceConfig.ftrace_events)
}
inline ::std::string* FtraceConfig::add_ftrace_events() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.FtraceConfig.ftrace_events)
  return ftrace_events_.Add();
}
inline void FtraceConfig::add_ftrace_events(const ::std::string& value) {
  ftrace_events_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.FtraceConfig.ftrace_events)
}
inline void FtraceConfig::add_ftrace_events(const char* value) {
  ftrace_events_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.FtraceConfig.ftrace_events)
}
inline void FtraceConfig::add_ftrace_events(const char* value, size_t size) {
  ftrace_events_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.FtraceConfig.ftrace_events)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FtraceConfig::ftrace_events() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.FtraceConfig.ftrace_events)
  return ftrace_events_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FtraceConfig::mutable_ftrace_events() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.FtraceConfig.ftrace_events)
  return &ftrace_events_;
}

// repeated string atrace_categories = 2;
inline int FtraceConfig::atrace_categories_size() const {
  return atrace_categories_.size();
}
inline void FtraceConfig::clear_atrace_categories() {
  atrace_categories_.Clear();
}
inline const ::std::string& FtraceConfig::atrace_categories(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FtraceConfig.atrace_categories)
  return atrace_categories_.Get(index);
}
inline ::std::string* FtraceConfig::mutable_atrace_categories(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.FtraceConfig.atrace_categories)
  return atrace_categories_.Mutable(index);
}
inline void FtraceConfig::set_atrace_categories(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.FtraceConfig.atrace_categories)
  atrace_categories_.Mutable(index)->assign(value);
}
inline void FtraceConfig::set_atrace_categories(int index, const char* value) {
  atrace_categories_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.FtraceConfig.atrace_categories)
}
inline void FtraceConfig::set_atrace_categories(int index, const char* value, size_t size) {
  atrace_categories_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.FtraceConfig.atrace_categories)
}
inline ::std::string* FtraceConfig::add_atrace_categories() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.FtraceConfig.atrace_categories)
  return atrace_categories_.Add();
}
inline void FtraceConfig::add_atrace_categories(const ::std::string& value) {
  atrace_categories_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.FtraceConfig.atrace_categories)
}
inline void FtraceConfig::add_atrace_categories(const char* value) {
  atrace_categories_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.FtraceConfig.atrace_categories)
}
inline void FtraceConfig::add_atrace_categories(const char* value, size_t size) {
  atrace_categories_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.FtraceConfig.atrace_categories)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FtraceConfig::atrace_categories() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.FtraceConfig.atrace_categories)
  return atrace_categories_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FtraceConfig::mutable_atrace_categories() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.FtraceConfig.atrace_categories)
  return &atrace_categories_;
}

// repeated string atrace_apps = 3;
inline int FtraceConfig::atrace_apps_size() const {
  return atrace_apps_.size();
}
inline void FtraceConfig::clear_atrace_apps() {
  atrace_apps_.Clear();
}
inline const ::std::string& FtraceConfig::atrace_apps(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FtraceConfig.atrace_apps)
  return atrace_apps_.Get(index);
}
inline ::std::string* FtraceConfig::mutable_atrace_apps(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.FtraceConfig.atrace_apps)
  return atrace_apps_.Mutable(index);
}
inline void FtraceConfig::set_atrace_apps(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.FtraceConfig.atrace_apps)
  atrace_apps_.Mutable(index)->assign(value);
}
inline void FtraceConfig::set_atrace_apps(int index, const char* value) {
  atrace_apps_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.FtraceConfig.atrace_apps)
}
inline void FtraceConfig::set_atrace_apps(int index, const char* value, size_t size) {
  atrace_apps_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.FtraceConfig.atrace_apps)
}
inline ::std::string* FtraceConfig::add_atrace_apps() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.FtraceConfig.atrace_apps)
  return atrace_apps_.Add();
}
inline void FtraceConfig::add_atrace_apps(const ::std::string& value) {
  atrace_apps_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.FtraceConfig.atrace_apps)
}
inline void FtraceConfig::add_atrace_apps(const char* value) {
  atrace_apps_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.FtraceConfig.atrace_apps)
}
inline void FtraceConfig::add_atrace_apps(const char* value, size_t size) {
  atrace_apps_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.FtraceConfig.atrace_apps)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FtraceConfig::atrace_apps() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.FtraceConfig.atrace_apps)
  return atrace_apps_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FtraceConfig::mutable_atrace_apps() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.FtraceConfig.atrace_apps)
  return &atrace_apps_;
}

// optional uint32 buffer_size_kb = 10;
inline bool FtraceConfig::has_buffer_size_kb() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FtraceConfig::set_has_buffer_size_kb() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FtraceConfig::clear_has_buffer_size_kb() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FtraceConfig::clear_buffer_size_kb() {
  buffer_size_kb_ = 0u;
  clear_has_buffer_size_kb();
}
inline ::google::protobuf::uint32 FtraceConfig::buffer_size_kb() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FtraceConfig.buffer_size_kb)
  return buffer_size_kb_;
}
inline void FtraceConfig::set_buffer_size_kb(::google::protobuf::uint32 value) {
  set_has_buffer_size_kb();
  buffer_size_kb_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.FtraceConfig.buffer_size_kb)
}

// optional uint32 drain_period_ms = 11;
inline bool FtraceConfig::has_drain_period_ms() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FtraceConfig::set_has_drain_period_ms() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FtraceConfig::clear_has_drain_period_ms() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FtraceConfig::clear_drain_period_ms() {
  drain_period_ms_ = 0u;
  clear_has_drain_period_ms();
}
inline ::google::protobuf::uint32 FtraceConfig::drain_period_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FtraceConfig.drain_period_ms)
  return drain_period_ms_;
}
inline void FtraceConfig::set_drain_period_ms(::google::protobuf::uint32 value) {
  set_has_drain_period_ms();
  drain_period_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.FtraceConfig.drain_period_ms)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2fconfig_2fftrace_2fftrace_5fconfig_2eproto__INCLUDED
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/config/gpu/gpu_counter_config.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/config/gpu/gpu_counter_config.proto

#ifndef PROTOBUF_protos_2fperfetto_2fconfig_2fgpu_2fgpu_5fcounter_5fconfig_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2fconfig_2fgpu_2fgpu_5fcounter_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2fconfig_2fgpu_2fgpu_5fcounter_5fconfig_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2fgpu_2fgpu_5fcounter_5fconfig_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2fgpu_2fgpu_5fcounter_5fconfig_2eproto();

class GpuCounterConfig;

// ===================================================================

class GpuCounterConfig : public ::google::protobuf::MessageLite {
 public:
  GpuCounterConfig();
  virtual ~GpuCounterConfig();

  GpuCounterConfig(const GpuCounterConfig& from);

  inline GpuCounterConfig& operator=(const GpuCounterConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const GpuCounterConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GpuCounterConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GpuCounterConfig* other);

  // implements Message ----------------------------------------------

  inline GpuCounterConfig* New() const { return New(NULL); }

  GpuCounterConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GpuCounterConfig& from);
  void MergeFrom(const GpuCounterConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GpuCounterConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 counter_period_ns = 1;
  bool has_counter_period_ns() const;
  void clear_counter_period_ns();
  static const int kCounterPeriodNsFieldNumber = 1;
  ::google::protobuf::uint64 counter_period_ns() const;
  void set_counter_period_ns(::google::protobuf::uint64 value);

  // repeated uint32 counter_ids = 2;
  int counter_ids_size() const;
  void clear_counter_ids();
  static const int kCounterIdsFieldNumber = 2;
  ::google::protobuf::uint32 counter_ids(int index) const;
  void set_counter_ids(int index, ::google::protobuf::uint32 value);
  void add_counter_ids(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      counter_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_counter_ids();

  // optional bool instrumented_sampling = 3;
  bool has_instrumented_sampling() const;
  void clear_instrumented_sampling();
  static const int kInstrumentedSamplingFieldNumber = 3;
  bool instrumented_sampling() const;
  void set_instrumented_sampling(bool value);

  // optional bool fix_gpu_clock = 4;
  bool has_fix_gpu_clock() const;
  void clear_fix_gpu_clock();
  static const int kFixGpuClockFieldNumber = 4;
  bool fix_gpu_clock() const;
  void set_fix_gpu_clock(bool value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.GpuCounterConfig)
 private:
  inline void set_has_counter_period_ns();
  inline void clear_has_counter_period_ns();
  inline void set_has_instrumented_sampling();
  inline void clear_has_instrumented_sampling();
  inline void set_has_fix_gpu_clock();
  inline void clear_has_fix_gpu_clock();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 counter_period_ns_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > counter_ids_;
  bool instrumented_sampling_;
  bool fix_gpu_clock_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2fgpu_2fgpu_5fcounter_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2fgpu_2fgpu_5fcounter_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2fgpu_2fgpu_5fcounter_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2fgpu_2fgpu_5fcounter_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static GpuCounterConfig* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// GpuCounterConfig

// optional uint64 counter_period_ns = 1;
inline bool GpuCounterConfig::has_counter_period_ns() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GpuCounterConfig::set_has_counter_period_ns() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GpuCounterConfig::clear_has_counter_period_ns() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GpuCounterConfig::clear_counter_period_ns() {
  counter_period_ns_ = GOOGLE_ULONGLONG(0);
  clear_has_counter_period_ns();
}
inline ::google::protobuf::uint64 GpuCounterConfig::counter_period_ns() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterConfig.counter_period_ns)
  return counter_period_ns_;
}
inline void GpuCounterConfig::set_counter_period_ns(::google::protobuf::uint64 value) {
  set_has_counter_period_ns();
  counter_period_ns_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.GpuCounterConfig.counter_period_ns)
}

// repeated uint32 counter_ids = 2;
inline int GpuCounterConfig::counter_ids_size() const {
  return counter_ids_.size();
}
inline void GpuCounterConfig::clear_counter_ids() {
  counter_ids_.Clear();
}
inline ::google::protobuf::uint32 GpuCounterConfig::counter_ids(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterConfig.counter_ids)
  return counter_ids_.Get(index);
}
inline void GpuCounterConfig::set_counter_ids(int index, ::google::protobuf::uint32 value) {
  counter_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.GpuCounterConfig.counter_ids)
}
inline void GpuCounterConfig::add_counter_ids(::google::protobuf::uint32 value) {
  counter_ids_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.GpuCounterConfig.counter_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
GpuCounterConfig::counter_ids() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.GpuCounterConfig.counter_ids)
  return counter_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
GpuCounterConfig::mutable_counter_ids() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.GpuCounterConfig.counter_ids)
  return &counter_ids_;
}

// optional bool instrumented_sampling = 3;
inline bool GpuCounterConfig::has_instrumented_sampling() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GpuCounterConfig::set_has_instrumented_sampling() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GpuCounterConfig::clear_has_instrumented_sampling() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GpuCounterConfig::clear_instrumented_sampling() {
  instrumented_sampling_ = false;
  clear_has_instrumented_sampling();
}
inline bool GpuCounterConfig::instrumented_sampling() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterConfig.instrumented_sampling)
  return instrumented_sampling_;
}
inline void GpuCounterConfig::set_instrumented_sampling(bool value) {
  set_has_instrumented_sampling();
  instrumented_sampling_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.GpuCounterConfig.instrumented_sampling)
}

// optional bool fix_gpu_clock = 4;
inline bool GpuCounterConfig::has_fix_gpu_clock() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GpuCounterConfig::set_has_fix_gpu_clock() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GpuCounterConfig::clear_has_fix_gpu_clock() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GpuCounterConfig::clear_fix_gpu_clock() {
  fix_gpu_clock_ = false;
  clear_has_fix_gpu_clock();
}
inline bool GpuCounterConfig::fix_gpu_clock() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterConfig.fix_gpu_clock)
  return fix_gpu_clock_;
}
inline void GpuCounterConfig::set_fix_gpu_clock(bool value) {
  set_has_fix_gpu_clock();
  fix_gpu_clock_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.GpuCounterConfig.fix_gpu_clock)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2fconfig_2fgpu_2fgpu_5fcounter_5fconfig_2eproto__INCLUDED
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/config/inode_file/inode_file_config.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/config/inode_file/inode_file_config.proto

#ifndef PROTOBUF_protos_2fperfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto();

class InodeFileConfig;
class InodeFileConfig_MountPointMappingEntry;

// ===================================================================

class InodeFileConfig_MountPointMappingEntry : public ::google::protobuf::MessageLite {
 public:
  InodeFileConfig_MountPointMappingEntry();
  virtual ~InodeFileConfig_MountPointMappingEntry();

  InodeFileConfig_MountPointMappingEntry(const InodeFileConfig_MountPointMappingEntry& from);

  inline InodeFileConfig_MountPointMappingEntry& operator=(const InodeFileConfig_MountPointMappingEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const InodeFileConfig_MountPointMappingEntry& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const InodeFileConfig_MountPointMappingEntry* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(InodeFileConfig_MountPointMappingEntry* other);

  // implements Message ----------------------------------------------

  inline InodeFileConfig_MountPointMappingEntry* New() const { return New(NULL); }

  InodeFileConfig_MountPointMappingEntry* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const InodeFileConfig_MountPointMappingEntry& from);
  void MergeFrom(const InodeFileConfig_MountPointMappingEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InodeFileConfig_MountPointMappingEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string mountpoint = 1;
  bool has_mountpoint() const;
  void clear_mountpoint();
  static const int kMountpointFieldNumber = 1;
  const ::std::string& mountpoint() const;
  void set_mountpoint(const ::std::string& value);
  void set_mountpoint(const char* value);
  void set_mountpoint(const char* value, size_t size);
  ::std::string* mutable_mountpoint();
  ::std::string* release_mountpoint();
  void set_allocated_mountpoint(::std::string* mountpoint);

  // repeated string scan_roots = 2;
  int scan_roots_size() const;
  void clear_scan_roots();
  static const int kScanRootsFieldNumber = 2;
  const ::std::string& scan_roots(int index) const;
  ::std::string* mutable_scan_roots(int index);
  void set_scan_roots(int index, const ::std::string& value);
  void set_scan_roots(int index, const char* value);
  void set_scan_roots(int index, const char* value, size_t size);
  ::std::string* add_scan_roots();
  void add_scan_roots(const ::std::string& value);
  void add_scan_roots(const char* value);
  void add_scan_roots(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& scan_roots() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_scan_roots();

  // @@protoc_insertion_point(class_scope:perfetto.protos.InodeFileConfig.MountPointMappingEntry)
 private:
  inline void set_has_mountpoint();
  inline void clear_has_mountpoint();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr mountpoint_;
  ::google::protobuf::RepeatedPtrField< ::std::string> scan_roots_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static InodeFileConfig_MountPointMappingEntry* default_instance_;
};
// -------------------------------------------------------------------

class InodeFileConfig : public ::google::protobuf::MessageLite {
 public:
  InodeFileConfig();
  virtual ~InodeFileConfig();

  InodeFileConfig(const InodeFileConfig& from);

  inline InodeFileConfig& operator=(const InodeFileConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const InodeFileConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const InodeFileConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(InodeFileConfig* other);

  // implements Message ----------------------------------------------

  inline InodeFileConfig* New() const { return New(NULL); }

  InodeFileConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const InodeFileConfig& from);
  void MergeFrom(const InodeFileConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InodeFileConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef InodeFileConfig_MountPointMappingEntry MountPointMappingEntry;

  // accessors -------------------------------------------------------

  // optional uint32 scan_interval_ms = 1;
  bool has_scan_interval_ms() const;
  void clear_scan_interval_ms();
  static const int kScanIntervalMsFieldNumber = 1;
  ::google::protobuf::uint32 scan_interval_ms() const;
  void set_scan_interval_ms(::google::protobuf::uint32 value);

  // optional uint32 scan_delay_ms = 2;
  bool has_scan_delay_ms() const;
  void clear_scan_delay_ms();
  static const int kScanDelayMsFieldNumber = 2;
  ::google::protobuf::uint32 scan_delay_ms() const;
  void set_scan_delay_ms(::google::protobuf::uint32 value);

  // optional uint32 scan_batch_size = 3;
  bool has_scan_batch_size() const;
  void clear_scan_batch_size();
  static const int kScanBatchSizeFieldNumber = 3;
  ::google::protobuf::uint32 scan_batch_size() const;
  void set_scan_batch_size(::google::protobuf::uint32 value);

  // optional bool do_not_scan = 4;
  bool has_do_not_scan() const;
  void clear_do_not_scan();
  static const int kDoNotScanFieldNumber = 4;
  bool do_not_scan() const;
  void set_do_not_scan(bool value);

  // repeated string scan_mount_points = 5;
  int scan_mount_points_size() const;
  void clear_scan_mount_points();
  static const int kScanMountPointsFieldNumber = 5;
  const ::std::string& scan_mount_points(int index) const;
  ::std::string* mutable_scan_mount_points(int index);
  void set_scan_mount_points(int index, const ::std::string& value);
  void set_scan_mount_points(int index, const char* value);
  void set_scan_mount_points(int index, const char* value, size_t size);
  ::std::string* add_scan_mount_points();
  void add_scan_mount_points(const ::std::string& value);
  void add_scan_mount_points(const char* value);
  void add_scan_mount_points(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& scan_mount_points() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_scan_mount_points();

  // repeated .perfetto.protos.InodeFileConfig.MountPointMappingEntry mount_point_mapping = 6;
  int mount_point_mapping_size() const;
  void clear_mount_point_mapping();
  static const int kMountPointMappingFieldNumber = 6;
  const ::perfetto::protos::InodeFileConfig_MountPointMappingEntry& mount_point_mapping(int index) const;
  ::perfetto::protos::InodeFileConfig_MountPointMappingEntry* mutable_mount_point_mapping(int index);
  ::perfetto::protos::InodeFileConfig_MountPointMappingEntry* add_mount_point_mapping();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::InodeFileConfig_MountPointMappingEntry >*
      mutable_mount_point_mapping();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::InodeFileConfig_MountPointMappingEntry >&
      mount_point_mapping() const;

  // @@protoc_insertion_point(class_scope:perfetto.protos.InodeFileConfig)
 private:
  inline void set_has_scan_interval_ms();
  inline void clear_has_scan_interval_ms();
  inline void set_has_scan_delay_ms();
  inline void clear_has_scan_delay_ms();
  inline void set_has_scan_batch_size();
  inline void clear_has_scan_batch_size();
  inline void set_has_do_not_scan();
  inline void clear_has_do_not_scan();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 scan_interval_ms_;
  ::google::protobuf::uint32 scan_delay_ms_;
  ::google::protobuf::uint32 scan_batch_size_;
  bool do_not_scan_;
  ::google::protobuf::RepeatedPtrField< ::std::string> scan_mount_points_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::InodeFileConfig_MountPointMappingEntry > mount_point_mapping_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static InodeFileConfig* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// InodeFileConfig_MountPointMappingEntry

// optional string mountpoint = 1;
inline bool InodeFileConfig_MountPointMappingEntry::has_mountpoint() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InodeFileConfig_MountPointMappingEntry::set_has_mountpoint() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InodeFileConfig_MountPointMappingEntry::clear_has_mountpoint() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InodeFileConfig_MountPointMappingEntry::clear_mountpoint() {
  mountpoint_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mountpoint();
}
inline const ::std::string& InodeFileConfig_MountPointMappingEntry::mountpoint() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InodeFileConfig.MountPointMappingEntry.mountpoint)
  return mountpoint_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InodeFileConfig_MountPointMappingEntry::set_mountpoint(const ::std::string& value) {
  set_has_mountpoint();
  mountpoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.InodeFileConfig.MountPointMappingEntry.mountpoint)
}
inline void InodeFileConfig_MountPointMappingEntry::set_mountpoint(const char* value) {
  set_has_mountpoint();
  mountpoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.InodeFileConfig.MountPointMappingEntry.mountpoint)
}
inline void InodeFileConfig_MountPointMappingEntry::set_mountpoint(const char* value, size_t size) {
  set_has_mountpoint();
  mountpoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.InodeFileConfig.MountPointMappingEntry.mountpoint)
}
inline ::std::string* InodeFileConfig_MountPointMappingEntry::mutable_mountpoint() {
  set_has_mountpoint();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.InodeFileConfig.MountPointMappingEntry.mountpoint)
  return mountpoint_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InodeFileConfig_MountPointMappingEntry::release_mountpoint() {
  // @@protoc_insertion_point(field_release:perfetto.protos.InodeFileConfig.MountPointMappingEntry.mountpoint)
  clear_has_mountpoint();
  return mountpoint_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InodeFileConfig_MountPointMappingEntry::set_allocated_mountpoint(::std::string* mountpoint) {
  if (mountpoint != NULL) {
    set_has_mountpoint();
  } else {
    clear_has_mountpoint();
  }
  mountpoint_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mountpoint);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.InodeFileConfig.MountPointMappingEntry.mountpoint)
}

// repeated string scan_roots = 2;
inline int InodeFileConfig_MountPointMappingEntry::scan_roots_size() const {
  return scan_roots_.size();
}
inline void InodeFileConfig_MountPointMappingEntry::clear_scan_roots() {
  scan_roots_.Clear();
}
inline const ::std::string& InodeFileConfig_MountPointMappingEntry::scan_roots(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InodeFileConfig.MountPointMappingEntry.scan_roots)
  return scan_roots_.Get(index);
}
inline ::std::string* InodeFileConfig_MountPointMappingEntry::mutable_scan_roots(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.InodeFileConfig.MountPointMappingEntry.scan_roots)
  return scan_roots_.Mutable(index);
}
inline void InodeFileConfig_MountPointMappingEntry::set_scan_roots(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.InodeFileConfig.MountPointMappingEntry.scan_roots)
  scan_roots_.Mutable(index)->assign(value);
}
inline void InodeFileConfig_MountPointMappingEntry::set_scan_roots(int index, const char* value) {
  scan_roots_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.InodeFileConfig.MountPointMappingEntry.scan_roots)
}
inline void InodeFileConfig_MountPointMappingEntry::set_scan_roots(int index, const char* value, size_t size) {
  scan_roots_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.InodeFileConfig.MountPointMappingEntry.scan_roots)
}
inline ::std::string* InodeFileConfig_MountPointMappingEntry::add_scan_roots() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.InodeFileConfig.MountPointMappingEntry.scan_roots)
  return scan_roots_.Add();
}
inline void InodeFileConfig_MountPointMappingEntry::add_scan_roots(const ::std::string& value) {
  scan_roots_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.InodeFileConfig.MountPointMappingEntry.scan_roots)
}
inline void InodeFileConfig_MountPointMappingEntry::add_scan_roots(const char* value) {
  scan_roots_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.InodeFileConfig.MountPointMappingEntry.scan_roots)
}
inline void InodeFileConfig_MountPointMappingEntry::add_scan_roots(const char* value, size_t size) {
  scan_roots_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.InodeFileConfig.MountPointMappingEntry.scan_roots)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
InodeFileConfig_MountPointMappingEntry::scan_roots() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.InodeFileConfig.MountPointMappingEntry.scan_roots)
  return scan_roots_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
InodeFileConfig_MountPointMappingEntry::mutable_scan_roots() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.InodeFileConfig.MountPointMappingEntry.scan_roots)
  return &scan_roots_;
}

// -------------------------------------------------------------------

// InodeFileConfig

// optional uint32 scan_interval_ms = 1;
inline bool InodeFileConfig::has_scan_interval_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InodeFileConfig::set_has_scan_interval_ms() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InodeFileConfig::clear_has_scan_interval_ms() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InodeFileConfig::clear_scan_interval_ms() {
  scan_interval_ms_ = 0u;
  clear_has_scan_interval_ms();
}
inline ::google::protobuf::uint32 InodeFileConfig::scan_interval_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InodeFileConfig.scan_interval_ms)
  return scan_interval_ms_;
}
inline void InodeFileConfig::set_scan_interval_ms(::google::protobuf::uint32 value) {
  set_has_scan_interval_ms();
  scan_interval_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.InodeFileConfig.scan_interval_ms)
}

// optional uint32 scan_delay_ms = 2;
inline bool InodeFileConfig::has_scan_delay_ms() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InodeFileConfig::set_has_scan_delay_ms() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InodeFileConfig::clear_has_scan_delay_ms() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InodeFileConfig::clear_scan_delay_ms() {
  scan_delay_ms_ = 0u;
  clear_has_scan_delay_ms();
}
inline ::google::protobuf::uint32 InodeFileConfig::scan_delay_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InodeFileConfig.scan_delay_ms)
  return scan_delay_ms_;
}
inline void InodeFileConfig::set_scan_delay_ms(::google::protobuf::uint32 value) {
  set_has_scan_delay_ms();
  scan_delay_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.InodeFileConfig.scan_delay_ms)
}

// optional uint32 scan_batch_size = 3;
inline bool InodeFileConfig::has_scan_batch_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InodeFileConfig::set_has_scan_batch_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InodeFileConfig::clear_has_scan_batch_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InodeFileConfig::clear_scan_batch_size() {
  scan_batch_size_ = 0u;
  clear_has_scan_batch_size();
}
inline ::google::protobuf::uint32 InodeFileConfig::scan_batch_size() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InodeFileConfig.scan_batch_size)
  return scan_batch_size_;
}
inline void InodeFileConfig::set_scan_batch_size(::google::protobuf::uint32 value) {
  set_has_scan_batch_size();
  scan_batch_size_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.InodeFileConfig.scan_batch_size)
}

// optional bool do_not_scan = 4;
inline bool InodeFileConfig::has_do_not_scan() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InodeFileConfig::set_has_do_not_scan() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InodeFileConfig::clear_has_do_not_scan() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InodeFileConfig::clear_do_not_scan() {
  do_not_scan_ = false;
  clear_has_do_not_scan();
}
inline bool InodeFileConfig::do_not_scan() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InodeFileConfig.do_not_scan)
  return do_not_scan_;
}
inline void InodeFileConfig::set_do_not_scan(bool value) {
  set_has_do_not_scan();
  do_not_scan_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.InodeFileConfig.do_not_scan)
}

// repeated string scan_mount_points = 5;
inline int InodeFileConfig::scan_mount_points_size() const {
  return scan_mount_points_.size();
}
inline void InodeFileConfig::clear_scan_mount_points() {
  scan_mount_points_.Clear();
}
inline const ::std::string& InodeFileConfig::scan_mount_points(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InodeFileConfig.scan_mount_points)
  return scan_mount_points_.Get(index);
}
inline ::std::string* InodeFileConfig::mutable_scan_mount_points(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.InodeFileConfig.scan_mount_points)
  return scan_mount_points_.Mutable(index);
}
inline void InodeFileConfig::set_scan_mount_points(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.InodeFileConfig.scan_mount_points)
  scan_mount_points_.Mutable(index)->assign(value);
}
inline void InodeFileConfig::set_scan_mount_points(int index, const char* value) {
  scan_mount_points_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.InodeFileConfig.scan_mount_points)
}
inline void InodeFileConfig::set_scan_mount_points(int index, const char* value, size_t size) {
  scan_mount_points_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.InodeFileConfig.scan_mount_points)
}
inline ::std::string* InodeFileConfig::add_scan_mount_points() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.InodeFileConfig.scan_mount_points)
  return scan_mount_points_.Add();
}
inline void InodeFileConfig::add_scan_mount_points(const ::std::string& value) {
  scan_mount_points_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.InodeFileConfig.scan_mount_points)
}
inline void InodeFileConfig::add_scan_mount_points(const char* value) {
  scan_mount_points_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.InodeFileConfig.scan_mount_points)
}
inline void InodeFileConfig::add_scan_mount_points(const char* value, size_t size) {
  scan_mount_points_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.InodeFileConfig.scan_mount_points)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
InodeFileConfig::scan_mount_points() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.InodeFileConfig.scan_mount_points)
  return scan_mount_points_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
InodeFileConfig::mutable_scan_mount_points() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.InodeFileConfig.scan_mount_points)
  return &scan_mount_points_;
}

// repeated .perfetto.protos.InodeFileConfig.MountPointMappingEntry mount_point_mapping = 6;
inline int InodeFileConfig::mount_point_mapping_size() const {
  return mount_point_mapping_.size();
}
inline void InodeFileConfig::clear_mount_point_mapping() {
  mount_point_mapping_.Clear();
}
inline const ::perfetto::protos::InodeFileConfig_MountPointMappingEntry& InodeFileConfig::mount_point_mapping(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InodeFileConfig.mount_point_mapping)
  return mount_point_mapping_.Get(index);
}
inline ::perfetto::protos::InodeFileConfig_MountPointMappingEntry* InodeFileConfig::mutable_mount_point_mapping(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.InodeFileConfig.mount_point_mapping)
  return mount_point_mapping_.Mutable(index);
}
inline ::perfetto::protos::InodeFileConfig_MountPointMappingEntry* InodeFileConfig::add_mount_point_mapping() {
  // @@protoc_insertion_point(field_add:perfetto.protos.InodeFileConfig.mount_point_mapping)
  return mount_point_mapping_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::InodeFileConfig_MountPointMappingEntry >*
InodeFileConfig::mutable_mount_point_mapping() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.InodeFileConfig.mount_point_mapping)
  return &mount_point_mapping_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::InodeFileConfig_MountPointMappingEntry >&
InodeFileConfig::mount_point_mapping() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.InodeFileConfig.mount_point_mapping)
  return mount_point_mapping_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto__INCLUDED
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/config/power/android_power_config.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/config/power/android_power_config.proto

#ifndef PROTOBUF_protos_2fperfetto_2fconfig_2fpower_2fandroid_5fpower_5fconfig_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2fconfig_2fpower_2fandroid_5fpower_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2fconfig_2fpower_2fandroid_5fpower_5fconfig_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2fpower_2fandroid_5fpower_5fconfig_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2fpower_2fandroid_5fpower_5fconfig_2eproto();

class AndroidPowerConfig;

enum AndroidPowerConfig_BatteryCounters {
  AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_UNSPECIFIED = 0,
  AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_CHARGE = 1,
  AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_CAPACITY_PERCENT = 2,
  AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_CURRENT = 3,
  AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_CURRENT_AVG = 4
};
bool AndroidPowerConfig_BatteryCounters_IsValid(int value);
const AndroidPowerConfig_BatteryCounters AndroidPowerConfig_BatteryCounters_BatteryCounters_MIN = AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_UNSPECIFIED;
const AndroidPowerConfig_BatteryCounters AndroidPowerConfig_BatteryCounters_BatteryCounters_MAX = AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_CURRENT_AVG;
const int AndroidPowerConfig_BatteryCounters_BatteryCounters_ARRAYSIZE = AndroidPowerConfig_BatteryCounters_BatteryCounters_MAX + 1;

// ===================================================================

class AndroidPowerConfig : public ::google::protobuf::MessageLite {
 public:
  AndroidPowerConfig();
  virtual ~AndroidPowerConfig();

  AndroidPowerConfig(const AndroidPowerConfig& from);

  inline AndroidPowerConfig& operator=(const AndroidPowerConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const AndroidPowerConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AndroidPowerConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AndroidPowerConfig* other);

  // implements Message ----------------------------------------------

  inline AndroidPowerConfig* New() const { return New(NULL); }

  AndroidPowerConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AndroidPowerConfig& from);
  void MergeFrom(const AndroidPowerConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AndroidPowerConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef AndroidPowerConfig_BatteryCounters BatteryCounters;
  static const BatteryCounters BATTERY_COUNTER_UNSPECIFIED =
    AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_UNSPECIFIED;
  static const BatteryCounters BATTERY_COUNTER_CHARGE =
    AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_CHARGE;
  static const BatteryCounters BATTERY_COUNTER_CAPACITY_PERCENT =
    AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_CAPACITY_PERCENT;
  static const BatteryCounters BATTERY_COUNTER_CURRENT =
    AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_CURRENT;
  static const BatteryCounters BATTERY_COUNTER_CURRENT_AVG =
    AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_CURRENT_AVG;
  static inline bool BatteryCounters_IsValid(int value) {
    return AndroidPowerConfig_BatteryCounters_IsValid(value);
  }
  static const BatteryCounters BatteryCounters_MIN =
    AndroidPowerConfig_BatteryCounters_BatteryCounters_MIN;
  static const BatteryCounters BatteryCounters_MAX =
    AndroidPowerConfig_BatteryCounters_BatteryCounters_MAX;
  static const int BatteryCounters_ARRAYSIZE =
    AndroidPowerConfig_BatteryCounters_BatteryCounters_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional uint32 battery_poll_ms = 1;
  bool has_battery_poll_ms() const;
  void clear_battery_poll_ms();
  static const int kBatteryPollMsFieldNumber = 1;
  ::google::protobuf::uint32 battery_poll_ms() const;
  void set_battery_poll_ms(::google::protobuf::uint32 value);

  // repeated .perfetto.protos.AndroidPowerConfig.BatteryCounters battery_counters = 2;
  int battery_counters_size() const;
  void clear_battery_counters();
  static const int kBatteryCountersFieldNumber = 2;
  ::perfetto::protos::AndroidPowerConfig_BatteryCounters battery_counters(int index) const;
  void set_battery_counters(int index, ::perfetto::protos::AndroidPowerConfig_BatteryCounters value);
  void add_battery_counters(::perfetto::protos::AndroidPowerConfig_BatteryCounters value);
  const ::google::protobuf::RepeatedField<int>& battery_counters() const;
  ::google::protobuf::RepeatedField<int>* mutable_battery_counters();

  // optional bool collect_power_rails = 3;
  bool has_collect_power_rails() const;
  void clear_collect_power_rails();
  static const int kCollectPowerRailsFieldNumber = 3;
  bool collect_power_rails() const;
  void set_collect_power_rails(bool value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.AndroidPowerConfig)
 private:
  inline void set_has_battery_poll_ms();
  inline void clear_has_battery_poll_ms();
  inline void set_has_collect_power_rails();
  inline void clear_has_collect_power_rails();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField<int> battery_counters_;
  ::google::protobuf::uint32 battery_poll_ms_;
  bool collect_power_rails_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2fpower_2fandroid_5fpower_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2fpower_2fandroid_5fpower_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2fpower_2fandroid_5fpower_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2fpower_2fandroid_5fpower_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static AndroidPowerConfig* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// AndroidPowerConfig

// optional uint32 battery_poll_ms = 1;
inline bool AndroidPowerConfig::has_battery_poll_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AndroidPowerConfig::set_has_battery_poll_ms() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AndroidPowerConfig::clear_has_battery_poll_ms() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AndroidPowerConfig::clear_battery_poll_ms() {
  battery_poll_ms_ = 0u;
  clear_has_battery_poll_ms();
}
inline ::google::protobuf::uint32 AndroidPowerConfig::battery_poll_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AndroidPowerConfig.battery_poll_ms)
  return battery_poll_ms_;
}
inline void AndroidPowerConfig::set_battery_poll_ms(::google::protobuf::uint32 value) {
  set_has_battery_poll_ms();
  battery_poll_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.AndroidPowerConfig.battery_poll_ms)
}

// repeated .perfetto.protos.AndroidPowerConfig.BatteryCounters battery_counters = 2;
inline int AndroidPowerConfig::battery_counters_size() const {
  return battery_counters_.size();
}
inline void AndroidPowerConfig::clear_battery_counters() {
  battery_counters_.Clear();
}
inline ::perfetto::protos::AndroidPowerConfig_BatteryCounters AndroidPowerConfig::battery_counters(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AndroidPowerConfig.battery_counters)
  return static_cast< ::perfetto::protos::AndroidPowerConfig_BatteryCounters >(battery_counters_.Get(index));
}
inline void AndroidPowerConfig::set_battery_counters(int index, ::perfetto::protos::AndroidPowerConfig_BatteryCounters value) {
  assert(::perfetto::protos::AndroidPowerConfig_BatteryCounters_IsValid(value));
  battery_counters_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.AndroidPowerConfig.battery_counters)
}
inline void AndroidPowerConfig::add_battery_counters(::perfetto::protos::AndroidPowerConfig_BatteryCounters value) {
  assert(::perfetto::protos::AndroidPowerConfig_BatteryCounters_IsValid(value));
  battery_counters_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.AndroidPowerConfig.battery_counters)
}
inline const ::google::protobuf::RepeatedField<int>&
AndroidPowerConfig::battery_counters() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.AndroidPowerConfig.battery_counters)
  return battery_counters_;
}
inline ::google::protobuf::RepeatedField<int>*
AndroidPowerConfig::mutable_battery_counters() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.AndroidPowerConfig.battery_counters)
  return &battery_counters_;
}

// optional bool collect_power_rails = 3;
inline bool AndroidPowerConfig::has_collect_power_rails() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AndroidPowerConfig::set_has_collect_power_rails() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AndroidPowerConfig::clear_has_collect_power_rails() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AndroidPowerConfig::clear_collect_power_rails() {
  collect_power_rails_ = false;
  clear_has_collect_power_rails();
}
inline bool AndroidPowerConfig::collect_power_rails() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AndroidPowerConfig.collect_power_rails)
  return collect_power_rails_;
}
inline void AndroidPowerConfig::set_collect_power_rails(bool value) {
  set_has_collect_power_rails();
  collect_power_rails_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.AndroidPowerConfig.collect_power_rails)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::perfetto::protos::AndroidPowerConfig_BatteryCounters> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2fconfig_2fpower_2fandroid_5fpower_5fconfig_2eproto__INCLUDED
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/config/process_stats/process_stats_config.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/config/process_stats/process_stats_config.proto

#ifndef PROTOBUF_protos_2fperfetto_2fconfig_2fprocess_5fstats_2fprocess_5fstats_5fconfig_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2fconfig_2fprocess_5fstats_2fprocess_5fstats_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2fconfig_2fprocess_5fstats_2fprocess_5fstats_5fconfig_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2fprocess_5fstats_2fprocess_5fstats_5fconfig_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2fprocess_5fstats_2fprocess_5fstats_5fconfig_2eproto();

class ProcessStatsConfig;

enum ProcessStatsConfig_Quirks {
  ProcessStatsConfig_Quirks_QUIRKS_UNSPECIFIED = 0,
  ProcessStatsConfig_Quirks_DISABLE_INITIAL_DUMP PROTOBUF_DEPRECATED = 1,
  ProcessStatsConfig_Quirks_DISABLE_ON_DEMAND = 2
};
bool ProcessStatsConfig_Quirks_IsValid(int value);
const ProcessStatsConfig_Quirks ProcessStatsConfig_Quirks_Quirks_MIN = ProcessStatsConfig_Quirks_QUIRKS_UNSPECIFIED;
const ProcessStatsConfig_Quirks ProcessStatsConfig_Quirks_Quirks_MAX = ProcessStatsConfig_Quirks_DISABLE_ON_DEMAND;
const int ProcessStatsConfig_Quirks_Quirks_ARRAYSIZE = ProcessStatsConfig_Quirks_Quirks_MAX + 1;

// ===================================================================

class ProcessStatsConfig : public ::google::protobuf::MessageLite {
 public:
  ProcessStatsConfig();
  virtual ~ProcessStatsConfig();

  ProcessStatsConfig(const ProcessStatsConfig& from);

  inline ProcessStatsConfig& operator=(const ProcessStatsConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ProcessStatsConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ProcessStatsConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ProcessStatsConfig* other);

  // implements Message ----------------------------------------------

  inline ProcessStatsConfig* New() const { return New(NULL); }

  ProcessStatsConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ProcessStatsConfig& from);
  void MergeFrom(const ProcessStatsConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ProcessStatsConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ProcessStatsConfig_Quirks Quirks;
  static const Quirks QUIRKS_UNSPECIFIED =
    ProcessStatsConfig_Quirks_QUIRKS_UNSPECIFIED;
  PROTOBUF_DEPRECATED_ATTR static const Quirks DISABLE_INITIAL_DUMP =
    ProcessStatsConfig_Quirks_DISABLE_INITIAL_DUMP;
  static const Quirks DISABLE_ON_DEMAND =
    ProcessStatsConfig_Quirks_DISABLE_ON_DEMAND;
  static inline bool Quirks_IsValid(int value) {
    return ProcessStatsConfig_Quirks_IsValid(value);
  }
  static const Quirks Quirks_MIN =
    ProcessStatsConfig_Quirks_Quirks_MIN;
  static const Quirks Quirks_MAX =
    ProcessStatsConfig_Quirks_Quirks_MAX;
  static const int Quirks_ARRAYSIZE =
    ProcessStatsConfig_Quirks_Quirks_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .perfetto.protos.ProcessStatsConfig.Quirks quirks = 1;
  int quirks_size() const;
  void clear_quirks();
  static const int kQuirksFieldNumber = 1;
  ::perfetto::protos::ProcessStatsConfig_Quirks quirks(int index) const;
  void set_quirks(int index, ::perfetto::protos::ProcessStatsConfig_Quirks value);
  void add_quirks(::perfetto::protos::ProcessStatsConfig_Quirks value);
  const ::google::protobuf::RepeatedField<int>& quirks() const;
  ::google::protobuf::RepeatedField<int>* mutable_quirks();

  // optional bool scan_all_processes_on_start = 2;
  bool has_scan_all_processes_on_start() const;
  void clear_scan_all_processes_on_start();
  static const int kScanAllProcessesOnStartFieldNumber = 2;
  bool scan_all_processes_on_start() const;
  void set_scan_all_processes_on_start(bool value);

  // optional bool record_thread_names = 3;
  bool has_record_thread_names() const;
  void clear_record_thread_names();
  static const int kRecordThreadNamesFieldNumber = 3;
  bool record_thread_names() const;
  void set_record_thread_names(bool value);

  // optional uint32 proc_stats_poll_ms = 4;
  bool has_proc_stats_poll_ms() const;
  void clear_proc_stats_poll_ms();
  static const int kProcStatsPollMsFieldNumber = 4;
  ::google::protobuf::uint32 proc_stats_poll_ms() const;
  void set_proc_stats_poll_ms(::google::protobuf::uint32 value);

  // optional uint32 proc_stats_cache_ttl_ms = 6;
  bool has_proc_stats_cache_ttl_ms() const;
  void clear_proc_stats_cache_ttl_ms();
  static const int kProcStatsCacheTtlMsFieldNumber = 6;
  ::google::protobuf::uint32 proc_stats_cache_ttl_ms() const;
  void set_proc_stats_cache_ttl_ms(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.ProcessStatsConfig)
 private:
  inline void set_has_scan_all_processes_on_start();
  inline void clear_has_scan_all_processes_on_start();
  inline void set_has_record_thread_names();
  inline void clear_has_record_thread_names();
  inline void set_has_proc_stats_poll_ms();
  inline void clear_has_proc_stats_poll_ms();
  inline void set_has_proc_stats_cache_ttl_ms();
  inline void clear_has_proc_stats_cache_ttl_ms();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField<int> quirks_;
  bool scan_all_processes_on_start_;
  bool record_thread_names_;
  ::google::protobuf::uint32 proc_stats_poll_ms_;
  ::google::protobuf::uint32 proc_stats_cache_ttl_ms_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2fprocess_5fstats_2fprocess_5fstats_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2fprocess_5fstats_2fprocess_5fstats_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2fprocess_5fstats_2fprocess_5fstats_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2fprocess_5fstats_2fprocess_5fstats_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static ProcessStatsConfig* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// ProcessStatsConfig

// repeated .perfetto.protos.ProcessStatsConfig.Quirks quirks = 1;
inline int ProcessStatsConfig::quirks_size() const {
  return quirks_.size();
}
inline void ProcessStatsConfig::clear_quirks() {
  quirks_.Clear();
}
inline ::perfetto::protos::ProcessStatsConfig_Quirks ProcessStatsConfig::quirks(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ProcessStatsConfig.quirks)
  return static_cast< ::perfetto::protos::ProcessStatsConfig_Quirks >(quirks_.Get(index));
}
inline void ProcessStatsConfig::set_quirks(int index, ::perfetto::protos::ProcessStatsConfig_Quirks value) {
  assert(::perfetto::protos::ProcessStatsConfig_Quirks_IsValid(value));
  quirks_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.ProcessStatsConfig.quirks)
}
inline void ProcessStatsConfig::add_quirks(::perfetto::protos::ProcessStatsConfig_Quirks value) {
  assert(::perfetto::protos::ProcessStatsConfig_Quirks_IsValid(value));
  quirks_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.ProcessStatsConfig.quirks)
}
inline const ::google::protobuf::RepeatedField<int>&
ProcessStatsConfig::quirks() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.ProcessStatsConfig.quirks)
  return quirks_;
}
inline ::google::protobuf::RepeatedField<int>*
ProcessStatsConfig::mutable_quirks() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.ProcessStatsConfig.quirks)
  return &quirks_;
}

// optional bool scan_all_processes_on_start = 2;
inline bool ProcessStatsConfig::has_scan_all_processes_on_start() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProcessStatsConfig::set_has_scan_all_processes_on_start() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProcessStatsConfig::clear_has_scan_all_processes_on_start() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProcessStatsConfig::clear_scan_all_processes_on_start() {
  scan_all_processes_on_start_ = false;
  clear_has_scan_all_processes_on_start();
}
inline bool ProcessStatsConfig::scan_all_processes_on_start() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ProcessStatsConfig.scan_all_processes_on_start)
  return scan_all_processes_on_start_;
}
inline void ProcessStatsConfig::set_scan_all_processes_on_start(bool value) {
  set_has_scan_all_processes_on_start();
  scan_all_processes_on_start_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.ProcessStatsConfig.scan_all_processes_on_start)
}

// optional bool record_thread_names = 3;
inline bool ProcessStatsConfig::has_record_thread_names() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProcessStatsConfig::set_has_record_thread_names() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProcessStatsConfig::clear_has_record_thread_names() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProcessStatsConfig::clear_record_thread_names() {
  record_thread_names_ = false;
  clear_has_record_thread_names();
}
inline bool ProcessStatsConfig::record_thread_names() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ProcessStatsConfig.record_thread_names)
  return record_thread_names_;
}
inline void ProcessStatsConfig::set_record_thread_names(bool value) {
  set_has_record_thread_names();
  record_thread_names_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.ProcessStatsConfig.record_thread_names)
}

// optional uint32 proc_stats_poll_ms = 4;
inline bool ProcessStatsConfig::has_proc_stats_poll_ms() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProcessStatsConfig::set_has_proc_stats_poll_ms() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProcessStatsConfig::clear_has_proc_stats_poll_ms() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProcessStatsConfig::clear_proc_stats_poll_ms() {
  proc_stats_poll_ms_ = 0u;
  clear_has_proc_stats_poll_ms();
}
inline ::google::protobuf::uint32 ProcessStatsConfig::proc_stats_poll_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ProcessStatsConfig.proc_stats_poll_ms)
  return proc_stats_poll_ms_;
}
inline void ProcessStatsConfig::set_proc_stats_poll_ms(::google::protobuf::uint32 value) {
  set_has_proc_stats_poll_ms();
  proc_stats_poll_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.ProcessStatsConfig.proc_stats_poll_ms)
}

// optional uint32 proc_stats_cache_ttl_ms = 6;
inline bool ProcessStatsConfig::has_proc_stats_cache_ttl_ms() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProcessStatsConfig::set_has_proc_stats_cache_ttl_ms() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProcessStatsConfig::clear_has_proc_stats_cache_ttl_ms() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProcessStatsConfig::clear_proc_stats_cache_ttl_ms() {
  proc_stats_cache_ttl_ms_ = 0u;
  clear_has_proc_stats_cache_ttl_ms();
}
inline ::google::protobuf::uint32 ProcessStatsConfig::proc_stats_cache_ttl_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ProcessStatsConfig.proc_stats_cache_ttl_ms)
  return proc_stats_cache_ttl_ms_;
}
inline void ProcessStatsConfig::set_proc_stats_cache_ttl_ms(::google::protobuf::uint32 value) {
  set_has_proc_stats_cache_ttl_ms();
  proc_stats_cache_ttl_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.ProcessStatsConfig.proc_stats_cache_ttl_ms)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::perfetto::protos::ProcessStatsConfig_Quirks> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2fconfig_2fprocess_5fstats_2fprocess_5fstats_5fconfig_2eproto__INCLUDED
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/config/profiling/heapprofd_config.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/config/profiling/heapprofd_config.proto

#ifndef PROTOBUF_protos_2fperfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto();

class HeapprofdConfig;
class HeapprofdConfig_ContinuousDumpConfig;

// ===================================================================

class HeapprofdConfig_ContinuousDumpConfig : public ::google::protobuf::MessageLite {
 public:
  HeapprofdConfig_ContinuousDumpConfig();
  virtual ~HeapprofdConfig_ContinuousDumpConfig();

  HeapprofdConfig_ContinuousDumpConfig(const HeapprofdConfig_ContinuousDumpConfig& from);

  inline HeapprofdConfig_ContinuousDumpConfig& operator=(const HeapprofdConfig_ContinuousDumpConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const HeapprofdConfig_ContinuousDumpConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const HeapprofdConfig_ContinuousDumpConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(HeapprofdConfig_ContinuousDumpConfig* other);

  // implements Message ----------------------------------------------

  inline HeapprofdConfig_ContinuousDumpConfig* New() const { return New(NULL); }

  HeapprofdConfig_ContinuousDumpConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const HeapprofdConfig_ContinuousDumpConfig& from);
  void MergeFrom(const HeapprofdConfig_ContinuousDumpConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HeapprofdConfig_ContinuousDumpConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 dump_phase_ms = 5;
  bool has_dump_phase_ms() const;
  void clear_dump_phase_ms();
  static const int kDumpPhaseMsFieldNumber = 5;
  ::google::protobuf::uint32 dump_phase_ms() const;
  void set_dump_phase_ms(::google::protobuf::uint32 value);

  // optional uint32 dump_interval_ms = 6;
  bool has_dump_interval_ms() const;
  void clear_dump_interval_ms();
  static const int kDumpIntervalMsFieldNumber = 6;
  ::google::protobuf::uint32 dump_interval_ms() const;
  void set_dump_interval_ms(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.HeapprofdConfig.ContinuousDumpConfig)
 private:
  inline void set_has_dump_phase_ms();
  inline void clear_has_dump_phase_ms();
  inline void set_has_dump_interval_ms();
  inline void clear_has_dump_interval_ms();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 dump_phase_ms_;
  ::google::protobuf::uint32 dump_interval_ms_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static HeapprofdConfig_ContinuousDumpConfig* default_instance_;
};
// -------------------------------------------------------------------

class HeapprofdConfig : public ::google::protobuf::MessageLite {
 public:
  HeapprofdConfig();
  virtual ~HeapprofdConfig();

  HeapprofdConfig(const HeapprofdConfig& from);

  inline HeapprofdConfig& operator=(const HeapprofdConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const HeapprofdConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const HeapprofdConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(HeapprofdConfig* other);

  // implements Message ----------------------------------------------

  inline HeapprofdConfig* New() const { return New(NULL); }

  HeapprofdConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const HeapprofdConfig& from);
  void MergeFrom(const HeapprofdConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HeapprofdConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef HeapprofdConfig_ContinuousDumpConfig ContinuousDumpConfig;

  // accessors -------------------------------------------------------

  // optional uint64 sampling_interval_bytes = 1;
  bool has_sampling_interval_bytes() const;
  void clear_sampling_interval_bytes();
  static const int kSamplingIntervalBytesFieldNumber = 1;
  ::google::protobuf::uint64 sampling_interval_bytes() const;
  void set_sampling_interval_bytes(::google::protobuf::uint64 value);

  // repeated string process_cmdline = 2;
  int process_cmdline_size() const;
  void clear_process_cmdline();
  static const int kProcessCmdlineFieldNumber = 2;
  const ::std::string& process_cmdline(int index) const;
  ::std::string* mutable_process_cmdline(int index);
  void set_process_cmdline(int index, const ::std::string& value);
  void set_process_cmdline(int index, const char* value);
  void set_process_cmdline(int index, const char* value, size_t size);
  ::std::string* add_process_cmdline();
  void add_process_cmdline(const ::std::string& value);
  void add_process_cmdline(const char* value);
  void add_process_cmdline(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& process_cmdline() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_process_cmdline();

  // repeated uint64 pid = 4;
  int pid_size() const;
  void clear_pid();
  static const int kPidFieldNumber = 4;
  ::google::protobuf::uint64 pid(int index) const;
  void set_pid(int index, ::google::protobuf::uint64 value);
  void add_pid(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      pid() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_pid();

  // optional bool all = 5;
  bool has_all() const;
  void clear_all();
  static const int kAllFieldNumber = 5;
  bool all() const;
  void set_all(bool value);

  // repeated string skip_symbol_prefix = 7;
  int skip_symbol_prefix_size() const;
  void clear_skip_symbol_prefix();
  static const int kSkipSymbolPrefixFieldNumber = 7;
  const ::std::string& skip_symbol_prefix(int index) const;
  ::std::string* mutable_skip_symbol_prefix(int index);
  void set_skip_symbol_prefix(int index, const ::std::string& value);
  void set_skip_symbol_prefix(int index, const char* value);
  void set_skip_symbol_prefix(int index, const char* value, size_t size);
  ::std::string* add_skip_symbol_prefix();
  void add_skip_symbol_prefix(const ::std::string& value);
  void add_skip_symbol_prefix(const char* value);
  void add_skip_symbol_prefix(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& skip_symbol_prefix() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_skip_symbol_prefix();

  // optional .perfetto.protos.HeapprofdConfig.ContinuousDumpConfig continuous_dump_config = 6;
  bool has_continuous_dump_config() const;
  void clear_continuous_dump_config();
  static const int kContinuousDumpConfigFieldNumber = 6;
  const ::perfetto::protos::HeapprofdConfig_ContinuousDumpConfig& continuous_dump_config() const;
  ::perfetto::protos::HeapprofdConfig_ContinuousDumpConfig* mutable_continuous_dump_config();
  ::perfetto::protos::HeapprofdConfig_ContinuousDumpConfig* release_continuous_dump_config();
  void set_allocated_continuous_dump_config(::perfetto::protos::HeapprofdConfig_ContinuousDumpConfig* continuous_dump_config);

  // optional uint64 shmem_size_bytes = 8;
  bool has_shmem_size_bytes() const;
  void clear_shmem_size_bytes();
  static const int kShmemSizeBytesFieldNumber = 8;
  ::google::protobuf::uint64 shmem_size_bytes() const;
  void set_shmem_size_bytes(::google::protobuf::uint64 value);

  // optional bool block_client = 9;
  bool has_block_client() const;
  void clear_block_client();
  static const int kBlockClientFieldNumber = 9;
  bool block_client() const;
  void set_block_client(bool value);

  // optional bool no_startup = 10;
  bool has_no_startup() const;
  void clear_no_startup();
  static const int kNoStartupFieldNumber = 10;
  bool no_startup() const;
  void set_no_startup(bool value);

  // optional bool no_running = 11;
  bool has_no_running() const;
  void clear_no_running();
  static const int kNoRunningFieldNumber = 11;
  bool no_running() const;
  void set_no_running(bool value);

  // optional bool idle_allocations = 12;
  bool has_idle_allocations() const;
  void clear_idle_allocations();
  static const int kIdleAllocationsFieldNumber = 12;
  bool idle_allocations() const;
  void set_idle_allocations(bool value);

  // optional bool dump_at_max = 13;
  bool has_dump_at_max() const;
  void clear_dump_at_max();
  static const int kDumpAtMaxFieldNumber = 13;
  bool dump_at_max() const;
  void set_dump_at_max(bool value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.HeapprofdConfig)
 private:
  inline void set_has_sampling_interval_bytes();
  inline void clear_has_sampling_interval_bytes();
  inline void set_has_all();
  inline void clear_has_all();
  inline void set_has_continuous_dump_config();
  inline void clear_has_continuous_dump_config();
  inline void set_has_shmem_size_bytes();
  inline void clear_has_shmem_size_bytes();
  inline void set_has_block_client();
  inline void clear_has_block_client();
  inline void set_has_no_startup();
  inline void clear_has_no_startup();
  inline void set_has_no_running();
  inline void clear_has_no_running();
  inline void set_has_idle_allocations();
  inline void clear_has_idle_allocations();
  inline void set_has_dump_at_max();
  inline void clear_has_dump_at_max();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 sampling_interval_bytes_;
  ::google::protobuf::RepeatedPtrField< ::std::string> process_cmdline_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > pid_;
  ::google::protobuf::RepeatedPtrField< ::std::string> skip_symbol_prefix_;
  ::perfetto::protos::HeapprofdConfig_ContinuousDumpConfig* continuous_dump_config_;
  ::google::protobuf::uint64 shmem_size_bytes_;
  bool all_;
  bool block_client_;
  bool no_startup_;
  bool no_running_;
  bool idle_allocations_;
  bool dump_at_max_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static HeapprofdConfig* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// HeapprofdConfig_ContinuousDumpConfig

// optional uint32 dump_phase_ms = 5;
inline bool HeapprofdConfig_ContinuousDumpConfig::has_dump_phase_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeapprofdConfig_ContinuousDumpConfig::set_has_dump_phase_ms() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeapprofdConfig_ContinuousDumpConfig::clear_has_dump_phase_ms() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeapprofdConfig_ContinuousDumpConfig::clear_dump_phase_ms() {
  dump_phase_ms_ = 0u;
  clear_has_dump_phase_ms();
}
inline ::google::protobuf::uint32 HeapprofdConfig_ContinuousDumpConfig::dump_phase_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.ContinuousDumpConfig.dump_phase_ms)
  return dump_phase_ms_;
}
inline void HeapprofdConfig_ContinuousDumpConfig::set_dump_phase_ms(::google::protobuf::uint32 value) {
  set_has_dump_phase_ms();
  dump_phase_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.HeapprofdConfig.ContinuousDumpConfig.dump_phase_ms)
}

// optional uint32 dump_interval_ms = 6;
inline bool HeapprofdConfig_ContinuousDumpConfig::has_dump_interval_ms() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HeapprofdConfig_ContinuousDumpConfig::set_has_dump_interval_ms() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HeapprofdConfig_ContinuousDumpConfig::clear_has_dump_interval_ms() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HeapprofdConfig_ContinuousDumpConfig::clear_dump_interval_ms() {
  dump_interval_ms_ = 0u;
  clear_has_dump_interval_ms();
}
inline ::google::protobuf::uint32 HeapprofdConfig_ContinuousDumpConfig::dump_interval_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.ContinuousDumpConfig.dump_interval_ms)
  return dump_interval_ms_;
}
inline void HeapprofdConfig_ContinuousDumpConfig::set_dump_interval_ms(::google::protobuf::uint32 value) {
  set_has_dump_interval_ms();
  dump_interval_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.HeapprofdConfig.ContinuousDumpConfig.dump_interval_ms)
}

// -------------------------------------------------------------------

// HeapprofdConfig

// optional uint64 sampling_interval_bytes = 1;
inline bool HeapprofdConfig::has_sampling_interval_bytes() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeapprofdConfig::set_has_sampling_interval_bytes() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeapprofdConfig::clear_has_sampling_interval_bytes() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeapprofdConfig::clear_sampling_interval_bytes() {
  sampling_interval_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_sampling_interval_bytes();
}
inline ::google::protobuf::uint64 HeapprofdConfig::sampling_interval_bytes() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.sampling_interval_bytes)
  return sampling_interval_bytes_;
}
inline void HeapprofdConfig::set_sampling_interval_bytes(::google::protobuf::uint64 value) {
  set_has_sampling_interval_bytes();
  sampling_interval_bytes_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.HeapprofdConfig.sampling_interval_bytes)
}

// repeated string process_cmdline = 2;
inline int HeapprofdConfig::process_cmdline_size() const {
  return process_cmdline_.size();
}
inline void HeapprofdConfig::clear_process_cmdline() {
  process_cmdline_.Clear();
}
inline const ::std::string& HeapprofdConfig::process_cmdline(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.process_cmdline)
  return process_cmdline_.Get(index);
}
inline ::std::string* HeapprofdConfig::mutable_process_cmdline(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.HeapprofdConfig.process_cmdline)
  return process_cmdline_.Mutable(index);
}
inline void HeapprofdConfig::set_process_cmdline(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.HeapprofdConfig.process_cmdline)
  process_cmdline_.Mutable(index)->assign(value);
}
inline void HeapprofdConfig::set_process_cmdline(int index, const char* value) {
  process_cmdline_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.HeapprofdConfig.process_cmdline)
}
inline void HeapprofdConfig::set_process_cmdline(int index, const char* value, size_t size) {
  process_cmdline_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.HeapprofdConfig.process_cmdline)
}
inline ::std::string* HeapprofdConfig::add_process_cmdline() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.HeapprofdConfig.process_cmdline)
  return process_cmdline_.Add();
}
inline void HeapprofdConfig::add_process_cmdline(const ::std::string& value) {
  process_cmdline_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.HeapprofdConfig.process_cmdline)
}
inline void HeapprofdConfig::add_process_cmdline(const char* value) {
  process_cmdline_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.HeapprofdConfig.process_cmdline)
}
inline void HeapprofdConfig::add_process_cmdline(const char* value, size_t size) {
  process_cmdline_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.HeapprofdConfig.process_cmdline)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
HeapprofdConfig::process_cmdline() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.HeapprofdConfig.process_cmdline)
  return process_cmdline_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
HeapprofdConfig::mutable_process_cmdline() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.HeapprofdConfig.process_cmdline)
  return &process_cmdline_;
}

// repeated uint64 pid = 4;
inline int HeapprofdConfig::pid_size() const {
  return pid_.size();
}
inline void HeapprofdConfig::clear_pid() {
  pid_.Clear();
}
inline ::google::protobuf::uint64 HeapprofdConfig::pid(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.pid)
  return pid_.Get(index);
}
inline void HeapprofdConfig::set_pid(int index, ::google::protobuf::uint64 value) {
  pid_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.HeapprofdConfig.pid)
}
inline void HeapprofdConfig::add_pid(::google::protobuf::uint64 value) {
  pid_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.HeapprofdConfig.pid)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
HeapprofdConfig::pid() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.HeapprofdConfig.pid)
  return pid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
HeapprofdConfig::mutable_pid() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.HeapprofdConfig.pid)
  return &pid_;
}

// optional bool all = 5;
inline bool HeapprofdConfig::has_all() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HeapprofdConfig::set_has_all() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HeapprofdConfig::clear_has_all() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HeapprofdConfig::clear_all() {
  all_ = false;
  clear_has_all();
}
inline bool HeapprofdConfig::all() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.all)
  return all_;
}
inline void HeapprofdConfig::set_all(bool value) {
  set_has_all();
  all_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.HeapprofdConfig.all)
}

// repeated string skip_symbol_prefix = 7;
inline int HeapprofdConfig::skip_symbol_prefix_size() const {
  return skip_symbol_prefix_.size();
}
inline void HeapprofdConfig::clear_skip_symbol_prefix() {
  skip_symbol_prefix_.Clear();
}
inline const ::std::string& HeapprofdConfig::skip_symbol_prefix(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.skip_symbol_prefix)
  return skip_symbol_prefix_.Get(index);
}
inline ::std::string* HeapprofdConfig::mutable_skip_symbol_prefix(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.HeapprofdConfig.skip_symbol_prefix)
  return skip_symbol_prefix_.Mutable(index);
}
inline void HeapprofdConfig::set_skip_symbol_prefix(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.HeapprofdConfig.skip_symbol_prefix)
  skip_symbol_prefix_.Mutable(index)->assign(value);
}
inline void HeapprofdConfig::set_skip_symbol_prefix(int index, const char* value) {
  skip_symbol_prefix_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.HeapprofdConfig.skip_symbol_prefix)
}
inline void HeapprofdConfig::set_skip_symbol_prefix(int index, const char* value, size_t size) {
  skip_symbol_prefix_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.HeapprofdConfig.skip_symbol_prefix)
}
inline ::std::string* HeapprofdConfig::add_skip_symbol_prefix() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.HeapprofdConfig.skip_symbol_prefix)
  return skip_symbol_prefix_.Add();
}
inline void HeapprofdConfig::add_skip_symbol_prefix(const ::std::string& value) {
  skip_symbol_prefix_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.HeapprofdConfig.skip_symbol_prefix)
}
inline void HeapprofdConfig::add_skip_symbol_prefix(const char* value) {
  skip_symbol_prefix_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.HeapprofdConfig.skip_symbol_prefix)
}
inline void HeapprofdConfig::add_skip_symbol_prefix(const char* value, size_t size) {
  skip_symbol_prefix_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.HeapprofdConfig.skip_symbol_prefix)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
HeapprofdConfig::skip_symbol_prefix() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.HeapprofdConfig.skip_symbol_prefix)
  return skip_symbol_prefix_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
HeapprofdConfig::mutable_skip_symbol_prefix() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.HeapprofdConfig.skip_symbol_prefix)
  return &skip_symbol_prefix_;
}

// optional .perfetto.protos.HeapprofdConfig.ContinuousDumpConfig continuous_dump_config = 6;
inline bool HeapprofdConfig::has_continuous_dump_config() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HeapprofdConfig::set_has_continuous_dump_config() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HeapprofdConfig::clear_has_continuous_dump_config() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HeapprofdConfig::clear_continuous_dump_config() {
  if (continuous_dump_config_ != NULL) continuous_dump_config_->::perfetto::protos::HeapprofdConfig_ContinuousDumpConfig::Clear();
  clear_has_continuous_dump_config();
}
inline const ::perfetto::protos::HeapprofdConfig_ContinuousDumpConfig& HeapprofdConfig::continuous_dump_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.continuous_dump_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return continuous_dump_config_ != NULL ? *continuous_dump_config_ : *default_instance().continuous_dump_config_;
#else
  return continuous_dump_config_ != NULL ? *continuous_dump_config_ : *default_instance_->continuous_dump_config_;
#endif
}
inline ::perfetto::protos::HeapprofdConfig_ContinuousDumpConfig* HeapprofdConfig::mutable_continuous_dump_config() {
  set_has_continuous_dump_config();
  if (continuous_dump_config_ == NULL) {
    continuous_dump_config_ = new ::perfetto::protos::HeapprofdConfig_ContinuousDumpConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.HeapprofdConfig.continuous_dump_config)
  return continuous_dump_config_;
}
inline ::perfetto::protos::HeapprofdConfig_ContinuousDumpConfig* HeapprofdConfig::release_continuous_dump_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.HeapprofdConfig.continuous_dump_config)
  clear_has_continuous_dump_config();
  ::perfetto::protos::HeapprofdConfig_ContinuousDumpConfig* temp = continuous_dump_config_;
  continuous_dump_config_ = NULL;
  return temp;
}
inline void HeapprofdConfig::set_allocated_continuous_dump_config(::perfetto::protos::HeapprofdConfig_ContinuousDumpConfig* continuous_dump_config) {
  delete continuous_dump_config_;
  continuous_dump_config_ = continuous_dump_config;
  if (continuous_dump_config) {
    set_has_continuous_dump_config();
  } else {
    clear_has_continuous_dump_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.HeapprofdConfig.continuous_dump_config)
}

// optional uint64 shmem_size_bytes = 8;
inline bool HeapprofdConfig::has_shmem_size_bytes() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void HeapprofdConfig::set_has_shmem_size_bytes() {
  _has_bits_[0] |= 0x00000040u;
}
inline void HeapprofdConfig::clear_has_shmem_size_bytes() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void HeapprofdConfig::clear_shmem_size_bytes() {
  shmem_size_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_shmem_size_bytes();
}
inline ::google::protobuf::uint64 HeapprofdConfig::shmem_size_bytes() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.shmem_size_bytes)
  return shmem_size_bytes_;
}
inline void HeapprofdConfig::set_shmem_size_bytes(::google::protobuf::uint64 value) {
  set_has_shmem_size_bytes();
  shmem_size_bytes_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.HeapprofdConfig.shmem_size_bytes)
}

// optional bool block_client = 9;
inline bool HeapprofdConfig::has_block_client() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void HeapprofdConfig::set_has_block_client() {
  _has_bits_[0] |= 0x00000080u;
}
inline void HeapprofdConfig::clear_has_block_client() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void HeapprofdConfig::clear_block_client() {
  block_client_ = false;
  clear_has_block_client();
}
inline bool HeapprofdConfig::block_client() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.block_client)
  return block_client_;
}
inline void HeapprofdConfig::set_block_client(bool value) {
  set_has_block_client();
  block_client_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.HeapprofdConfig.block_client)
}

// optional bool no_startup = 10;
inline bool HeapprofdConfig::has_no_startup() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void HeapprofdConfig::set_has_no_startup() {
  _has_bits_[0] |= 0x00000100u;
}
inline void HeapprofdConfig::clear_has_no_startup() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void HeapprofdConfig::clear_no_startup() {
  no_startup_ = false;
  clear_has_no_startup();
}
inline bool HeapprofdConfig::no_startup() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.no_startup)
  return no_startup_;
}
inline void HeapprofdConfig::set_no_startup(bool value) {
  set_has_no_startup();
  no_startup_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.HeapprofdConfig.no_startup)
}

// optional bool no_running = 11;
inline bool HeapprofdConfig::has_no_running() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void HeapprofdConfig::set_has_no_running() {
  _has_bits_[0] |= 0x00000200u;
}
inline void HeapprofdConfig::clear_has_no_running() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void HeapprofdConfig::clear_no_running() {
  no_running_ = false;
  clear_has_no_running();
}
inline bool HeapprofdConfig::no_running() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.no_running)
  return no_running_;
}
inline void HeapprofdConfig::set_no_running(bool value) {
  set_has_no_running();
  no_running_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.HeapprofdConfig.no_running)
}

// optional bool idle_allocations = 12;
inline bool HeapprofdConfig::has_idle_allocations() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void HeapprofdConfig::set_has_idle_allocations() {
  _has_bits_[0] |= 0x00000400u;
}
inline void HeapprofdConfig::clear_has_idle_allocations() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void HeapprofdConfig::clear_idle_allocations() {
  idle_allocations_ = false;
  clear_has_idle_allocations();
}
inline bool HeapprofdConfig::idle_allocations() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.idle_allocations)
  return idle_allocations_;
}
inline void HeapprofdConfig::set_idle_allocations(bool value) {
  set_has_idle_allocations();
  idle_allocations_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.HeapprofdConfig.idle_allocations)
}

// optional bool dump_at_max = 13;
inline bool HeapprofdConfig::has_dump_at_max() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void HeapprofdConfig::set_has_dump_at_max() {
  _has_bits_[0] |= 0x00000800u;
}
inline void HeapprofdConfig::clear_has_dump_at_max() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void HeapprofdConfig::clear_dump_at_max() {
  dump_at_max_ = false;
  clear_has_dump_at_max();
}
inline bool HeapprofdConfig::dump_at_max() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.dump_at_max)
  return dump_at_max_;
}
inline void HeapprofdConfig::set_dump_at_max(bool value) {
  set_has_dump_at_max();
  dump_at_max_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.HeapprofdConfig.dump_at_max)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto__INCLUDED
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/config/sys_stats/sys_stats_config.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/config/sys_stats/sys_stats_config.proto

#ifndef PROTOBUF_protos_2fperfetto_2fconfig_2fsys_5fstats_2fsys_5fstats_5fconfig_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2fconfig_2fsys_5fstats_2fsys_5fstats_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
// gen_amalgamated expanded: #include "protos/perfetto/common/sys_stats_counters.pb.h"
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2fconfig_2fsys_5fstats_2fsys_5fstats_5fconfig_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2fsys_5fstats_2fsys_5fstats_5fconfig_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2fsys_5fstats_2fsys_5fstats_5fconfig_2eproto();

class SysStatsConfig;

enum SysStatsConfig_StatCounters {
  SysStatsConfig_StatCounters_STAT_UNSPECIFIED = 0,
  SysStatsConfig_StatCounters_STAT_CPU_TIMES = 1,
  SysStatsConfig_StatCounters_STAT_IRQ_COUNTS = 2,
  SysStatsConfig_StatCounters_STAT_SOFTIRQ_COUNTS = 3,
  SysStatsConfig_StatCounters_STAT_FORK_COUNT = 4
};
bool SysStatsConfig_StatCounters_IsValid(int value);
const SysStatsConfig_StatCounters SysStatsConfig_StatCounters_StatCounters_MIN = SysStatsConfig_StatCounters_STAT_UNSPECIFIED;
const SysStatsConfig_StatCounters SysStatsConfig_StatCounters_StatCounters_MAX = SysStatsConfig_StatCounters_STAT_FORK_COUNT;
const int SysStatsConfig_StatCounters_StatCounters_ARRAYSIZE = SysStatsConfig_StatCounters_StatCounters_MAX + 1;

// ===================================================================

class SysStatsConfig : public ::google::protobuf::MessageLite {
 public:
  SysStatsConfig();
  virtual ~SysStatsConfig();

  SysStatsConfig(const SysStatsConfig& from);

  inline SysStatsConfig& operator=(const SysStatsConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const SysStatsConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SysStatsConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SysStatsConfig* other);

  // implements Message ----------------------------------------------

  inline SysStatsConfig* New() const { return New(NULL); }

  SysStatsConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SysStatsConfig& from);
  void MergeFrom(const SysStatsConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SysStatsConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef SysStatsConfig_StatCounters StatCounters;
  static const StatCounters STAT_UNSPECIFIED =
    SysStatsConfig_StatCounters_STAT_UNSPECIFIED;
  static const StatCounters STAT_CPU_TIMES =
    SysStatsConfig_StatCounters_STAT_CPU_TIMES;
  static const StatCounters STAT_IRQ_COUNTS =
    SysStatsConfig_StatCounters_STAT_IRQ_COUNTS;
  static const StatCounters STAT_SOFTIRQ_COUNTS =
    SysStatsConfig_StatCounters_STAT_SOFTIRQ_COUNTS;
  static const StatCounters STAT_FORK_COUNT =
    SysStatsConfig_StatCounters_STAT_FORK_COUNT;
  static inline bool StatCounters_IsValid(int value) {
    return SysStatsConfig_StatCounters_IsValid(value);
  }
  static const StatCounters StatCounters_MIN =
    SysStatsConfig_StatCounters_StatCounters_MIN;
  static const StatCounters StatCounters_MAX =
    SysStatsConfig_StatCounters_StatCounters_MAX;
  static const int StatCounters_ARRAYSIZE =
    SysStatsConfig_StatCounters_StatCounters_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional uint32 meminfo_period_ms = 1;
  bool has_meminfo_period_ms() const;
  void clear_meminfo_period_ms();
  static const int kMeminfoPeriodMsFieldNumber = 1;
  ::google::protobuf::uint32 meminfo_period_ms() const;
  void set_meminfo_period_ms(::google::protobuf::uint32 value);

  // repeated .perfetto.protos.MeminfoCounters meminfo_counters = 2;
  int meminfo_counters_size() const;
  void clear_meminfo_counters();
  static const int kMeminfoCountersFieldNumber = 2;
  ::perfetto::protos::MeminfoCounters meminfo_counters(int index) const;
  void set_meminfo_counters(int index, ::perfetto::protos::MeminfoCounters value);
  void add_meminfo_counters(::perfetto::protos::MeminfoCounters value);
  const ::google::protobuf::RepeatedField<int>& meminfo_counters() const;
  ::google::protobuf::RepeatedField<int>* mutable_meminfo_counters();

  // optional uint32 vmstat_period_ms = 3;
  bool has_vmstat_period_ms() const;
  void clear_vmstat_period_ms();
  static const int kVmstatPeriodMsFieldNumber = 3;
  ::google::protobuf::uint32 vmstat_period_ms() const;
  void set_vmstat_period_ms(::google::protobuf::uint32 value);

  // repeated .perfetto.protos.VmstatCounters vmstat_counters = 4;
  int vmstat_counters_size() const;
  void clear_vmstat_counters();
  static const int kVmstatCountersFieldNumber = 4;
  ::perfetto::protos::VmstatCounters vmstat_counters(int index) const;
  void set_vmstat_counters(int index, ::perfetto::protos::VmstatCounters value);
  void add_vmstat_counters(::perfetto::protos::VmstatCounters value);
  const ::google::protobuf::RepeatedField<int>& vmstat_counters() const;
  ::google::protobuf::RepeatedField<int>* mutable_vmstat_counters();

  // optional uint32 stat_period_ms = 5;
  bool has_stat_period_ms() const;
  void clear_stat_period_ms();
  static const int kStatPeriodMsFieldNumber = 5;
  ::google::protobuf::uint32 stat_period_ms() const;
  void set_stat_period_ms(::google::protobuf::uint32 value);

  // repeated .perfetto.protos.SysStatsConfig.StatCounters stat_counters = 6;
  int stat_counters_size() const;
  void clear_stat_counters();
  static const int kStatCountersFieldNumber = 6;
  ::perfetto::protos::SysStatsConfig_StatCounters stat_counters(int index) const;
  void set_stat_counters(int index, ::perfetto::protos::SysStatsConfig_StatCounters value);
  void add_stat_counters(::perfetto::protos::SysStatsConfig_StatCounters value);
  const ::google::protobuf::RepeatedField<int>& stat_counters() const;
  ::google::protobuf::RepeatedField<int>* mutable_stat_counters();

  // @@protoc_insertion_point(class_scope:perfetto.protos.SysStatsConfig)
 private:
  inline void set_has_meminfo_period_ms();
  inline void clear_has_meminfo_period_ms();
  inline void set_has_vmstat_period_ms();
  inline void clear_has_vmstat_period_ms();
  inline void set_has_stat_period_ms();
  inline void clear_has_stat_period_ms();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField<int> meminfo_counters_;
  ::google::protobuf::uint32 meminfo_period_ms_;
  ::google::protobuf::uint32 vmstat_period_ms_;
  ::google::protobuf::RepeatedField<int> vmstat_counters_;
  ::google::protobuf::RepeatedField<int> stat_counters_;
  ::google::protobuf::uint32 stat_period_ms_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2fsys_5fstats_2fsys_5fstats_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2fsys_5fstats_2fsys_5fstats_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2fsys_5fstats_2fsys_5fstats_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2fsys_5fstats_2fsys_5fstats_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static SysStatsConfig* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// SysStatsConfig

// optional uint32 meminfo_period_ms = 1;
inline bool SysStatsConfig::has_meminfo_period_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SysStatsConfig::set_has_meminfo_period_ms() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SysStatsConfig::clear_has_meminfo_period_ms() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SysStatsConfig::clear_meminfo_period_ms() {
  meminfo_period_ms_ = 0u;
  clear_has_meminfo_period_ms();
}
inline ::google::protobuf::uint32 SysStatsConfig::meminfo_period_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SysStatsConfig.meminfo_period_ms)
  return meminfo_period_ms_;
}
inline void SysStatsConfig::set_meminfo_period_ms(::google::protobuf::uint32 value) {
  set_has_meminfo_period_ms();
  meminfo_period_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.SysStatsConfig.meminfo_period_ms)
}

// repeated .perfetto.protos.MeminfoCounters meminfo_counters = 2;
inline int SysStatsConfig::meminfo_counters_size() const {
  return meminfo_counters_.size();
}
inline void SysStatsConfig::clear_meminfo_counters() {
  meminfo_counters_.Clear();
}
inline ::perfetto::protos::MeminfoCounters SysStatsConfig::meminfo_counters(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SysStatsConfig.meminfo_counters)
  return static_cast< ::perfetto::protos::MeminfoCounters >(meminfo_counters_.Get(index));
}
inline void SysStatsConfig::set_meminfo_counters(int index, ::perfetto::protos::MeminfoCounters value) {
  assert(::perfetto::protos::MeminfoCounters_IsValid(value));
  meminfo_counters_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SysStatsConfig.meminfo_counters)
}
inline void SysStatsConfig::add_meminfo_counters(::perfetto::protos::MeminfoCounters value) {
  assert(::perfetto::protos::MeminfoCounters_IsValid(value));
  meminfo_counters_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.SysStatsConfig.meminfo_counters)
}
inline const ::google::protobuf::RepeatedField<int>&
SysStatsConfig::meminfo_counters() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.SysStatsConfig.meminfo_counters)
  return meminfo_counters_;
}
inline ::google::protobuf::RepeatedField<int>*
SysStatsConfig::mutable_meminfo_counters() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.SysStatsConfig.meminfo_counters)
  return &meminfo_counters_;
}

// optional uint32 vmstat_period_ms = 3;
inline bool SysStatsConfig::has_vmstat_period_ms() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SysStatsConfig::set_has_vmstat_period_ms() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SysStatsConfig::clear_has_vmstat_period_ms() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SysStatsConfig::clear_vmstat_period_ms() {
  vmstat_period_ms_ = 0u;
  clear_has_vmstat_period_ms();
}
inline ::google::protobuf::uint32 SysStatsConfig::vmstat_period_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SysStatsConfig.vmstat_period_ms)
  return vmstat_period_ms_;
}
inline void SysStatsConfig::set_vmstat_period_ms(::google::protobuf::uint32 value) {
  set_has_vmstat_period_ms();
  vmstat_period_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.SysStatsConfig.vmstat_period_ms)
}

// repeated .perfetto.protos.VmstatCounters vmstat_counters = 4;
inline int SysStatsConfig::vmstat_counters_size() const {
  return vmstat_counters_.size();
}
inline void SysStatsConfig::clear_vmstat_counters() {
  vmstat_counters_.Clear();
}
inline ::perfetto::protos::VmstatCounters SysStatsConfig::vmstat_counters(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SysStatsConfig.vmstat_counters)
  return static_cast< ::perfetto::protos::VmstatCounters >(vmstat_counters_.Get(index));
}
inline void SysStatsConfig::set_vmstat_counters(int index, ::perfetto::protos::VmstatCounters value) {
  assert(::perfetto::protos::VmstatCounters_IsValid(value));
  vmstat_counters_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SysStatsConfig.vmstat_counters)
}
inline void SysStatsConfig::add_vmstat_counters(::perfetto::protos::VmstatCounters value) {
  assert(::perfetto::protos::VmstatCounters_IsValid(value));
  vmstat_counters_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.SysStatsConfig.vmstat_counters)
}
inline const ::google::protobuf::RepeatedField<int>&
SysStatsConfig::vmstat_counters() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.SysStatsConfig.vmstat_counters)
  return vmstat_counters_;
}
inline ::google::protobuf::RepeatedField<int>*
SysStatsConfig::mutable_vmstat_counters() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.SysStatsConfig.vmstat_counters)
  return &vmstat_counters_;
}

// optional uint32 stat_period_ms = 5;
inline bool SysStatsConfig::has_stat_period_ms() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SysStatsConfig::set_has_stat_period_ms() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SysStatsConfig::clear_has_stat_period_ms() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SysStatsConfig::clear_stat_period_ms() {
  stat_period_ms_ = 0u;
  clear_has_stat_period_ms();
}
inline ::google::protobuf::uint32 SysStatsConfig::stat_period_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SysStatsConfig.stat_period_ms)
  return stat_period_ms_;
}
inline void SysStatsConfig::set_stat_period_ms(::google::protobuf::uint32 value) {
  set_has_stat_period_ms();
  stat_period_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.SysStatsConfig.stat_period_ms)
}

// repeated .perfetto.protos.SysStatsConfig.StatCounters stat_counters = 6;
inline int SysStatsConfig::stat_counters_size() const {
  return stat_counters_.size();
}
inline void SysStatsConfig::clear_stat_counters() {
  stat_counters_.Clear();
}
inline ::perfetto::protos::SysStatsConfig_StatCounters SysStatsConfig::stat_counters(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SysStatsConfig.stat_counters)
  return static_cast< ::perfetto::protos::SysStatsConfig_StatCounters >(stat_counters_.Get(index));
}
inline void SysStatsConfig::set_stat_counters(int index, ::perfetto::protos::SysStatsConfig_StatCounters value) {
  assert(::perfetto::protos::SysStatsConfig_StatCounters_IsValid(value));
  stat_counters_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SysStatsConfig.stat_counters)
}
inline void SysStatsConfig::add_stat_counters(::perfetto::protos::SysStatsConfig_StatCounters value) {
  assert(::perfetto::protos::SysStatsConfig_StatCounters_IsValid(value));
  stat_counters_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.SysStatsConfig.stat_counters)
}
inline const ::google::protobuf::RepeatedField<int>&
SysStatsConfig::stat_counters() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.SysStatsConfig.stat_counters)
  return stat_counters_;
}
inline ::google::protobuf::RepeatedField<int>*
SysStatsConfig::mutable_stat_counters() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.SysStatsConfig.stat_counters)
  return &stat_counters_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::perfetto::protos::SysStatsConfig_StatCounters> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2fconfig_2fsys_5fstats_2fsys_5fstats_5fconfig_2eproto__INCLUDED
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/config/test_config.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/config/test_config.proto

#ifndef PROTOBUF_protos_2fperfetto_2fconfig_2ftest_5fconfig_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2fconfig_2ftest_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftest_5fconfig_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2ftest_5fconfig_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2ftest_5fconfig_2eproto();

class TestConfig;
class TestConfig_DummyFields;

// ===================================================================

class TestConfig_DummyFields : public ::google::protobuf::MessageLite {
 public:
  TestConfig_DummyFields();
  virtual ~TestConfig_DummyFields();

  TestConfig_DummyFields(const TestConfig_DummyFields& from);

  inline TestConfig_DummyFields& operator=(const TestConfig_DummyFields& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TestConfig_DummyFields& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TestConfig_DummyFields* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TestConfig_DummyFields* other);

  // implements Message ----------------------------------------------

  inline TestConfig_DummyFields* New() const { return New(NULL); }

  TestConfig_DummyFields* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TestConfig_DummyFields& from);
  void MergeFrom(const TestConfig_DummyFields& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TestConfig_DummyFields* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 field_uint32 = 1;
  bool has_field_uint32() const;
  void clear_field_uint32();
  static const int kFieldUint32FieldNumber = 1;
  ::google::protobuf::uint32 field_uint32() const;
  void set_field_uint32(::google::protobuf::uint32 value);

  // optional int32 field_int32 = 2;
  bool has_field_int32() const;
  void clear_field_int32();
  static const int kFieldInt32FieldNumber = 2;
  ::google::protobuf::int32 field_int32() const;
  void set_field_int32(::google::protobuf::int32 value);

  // optional uint64 field_uint64 = 3;
  bool has_field_uint64() const;
  void clear_field_uint64();
  static const int kFieldUint64FieldNumber = 3;
  ::google::protobuf::uint64 field_uint64() const;
  void set_field_uint64(::google::protobuf::uint64 value);

  // optional int64 field_int64 = 4;
  bool has_field_int64() const;
  void clear_field_int64();
  static const int kFieldInt64FieldNumber = 4;
  ::google::protobuf::int64 field_int64() const;
  void set_field_int64(::google::protobuf::int64 value);

  // optional fixed64 field_fixed64 = 5;
  bool has_field_fixed64() const;
  void clear_field_fixed64();
  static const int kFieldFixed64FieldNumber = 5;
  ::google::protobuf::uint64 field_fixed64() const;
  void set_field_fixed64(::google::protobuf::uint64 value);

  // optional sfixed64 field_sfixed64 = 6;
  bool has_field_sfixed64() const;
  void clear_field_sfixed64();
  static const int kFieldSfixed64FieldNumber = 6;
  ::google::protobuf::int64 field_sfixed64() const;
  void set_field_sfixed64(::google::protobuf::int64 value);

  // optional fixed32 field_fixed32 = 7;
  bool has_field_fixed32() const;
  void clear_field_fixed32();
  static const int kFieldFixed32FieldNumber = 7;
  ::google::protobuf::uint32 field_fixed32() const;
  void set_field_fixed32(::google::protobuf::uint32 value);

  // optional sfixed32 field_sfixed32 = 8;
  bool has_field_sfixed32() const;
  void clear_field_sfixed32();
  static const int kFieldSfixed32FieldNumber = 8;
  ::google::protobuf::int32 field_sfixed32() const;
  void set_field_sfixed32(::google::protobuf::int32 value);

  // optional double field_double = 9;
  bool has_field_double() const;
  void clear_field_double();
  static const int kFieldDoubleFieldNumber = 9;
  double field_double() const;
  void set_field_double(double value);

  // optional float field_float = 10;
  bool has_field_float() const;
  void clear_field_float();
  static const int kFieldFloatFieldNumber = 10;
  float field_float() const;
  void set_field_float(float value);

  // optional sint64 field_sint64 = 11;
  bool has_field_sint64() const;
  void clear_field_sint64();
  static const int kFieldSint64FieldNumber = 11;
  ::google::protobuf::int64 field_sint64() const;
  void set_field_sint64(::google::protobuf::int64 value);

  // optional sint32 field_sint32 = 12;
  bool has_field_sint32() const;
  void clear_field_sint32();
  static const int kFieldSint32FieldNumber = 12;
  ::google::protobuf::int32 field_sint32() const;
  void set_field_sint32(::google::protobuf::int32 value);

  // optional string field_string = 13;
  bool has_field_string() const;
  void clear_field_string();
  static const int kFieldStringFieldNumber = 13;
  const ::std::string& field_string() const;
  void set_field_string(const ::std::string& value);
  void set_field_string(const char* value);
  void set_field_string(const char* value, size_t size);
  ::std::string* mutable_field_string();
  ::std::string* release_field_string();
  void set_allocated_field_string(::std::string* field_string);

  // optional bytes field_bytes = 14;
  bool has_field_bytes() const;
  void clear_field_bytes();
  static const int kFieldBytesFieldNumber = 14;
  const ::std::string& field_bytes() const;
  void set_field_bytes(const ::std::string& value);
  void set_field_bytes(const char* value);
  void set_field_bytes(const void* value, size_t size);
  ::std::string* mutable_field_bytes();
  ::std::string* release_field_bytes();
  void set_allocated_field_bytes(::std::string* field_bytes);

  // @@protoc_insertion_point(class_scope:perfetto.protos.TestConfig.DummyFields)
 private:
  inline void set_has_field_uint32();
  inline void clear_has_field_uint32();
  inline void set_has_field_int32();
  inline void clear_has_field_int32();
  inline void set_has_field_uint64();
  inline void clear_has_field_uint64();
  inline void set_has_field_int64();
  inline void clear_has_field_int64();
  inline void set_has_field_fixed64();
  inline void clear_has_field_fixed64();
  inline void set_has_field_sfixed64();
  inline void clear_has_field_sfixed64();
  inline void set_has_field_fixed32();
  inline void clear_has_field_fixed32();
  inline void set_has_field_sfixed32();
  inline void clear_has_field_sfixed32();
  inline void set_has_field_double();
  inline void clear_has_field_double();
  inline void set_has_field_float();
  inline void clear_has_field_float();
  inline void set_has_field_sint64();
  inline void clear_has_field_sint64();
  inline void set_has_field_sint32();
  inline void clear_has_field_sint32();
  inline void set_has_field_string();
  inline void clear_has_field_string();
  inline void set_has_field_bytes();
  inline void clear_has_field_bytes();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 field_uint32_;
  ::google::protobuf::int32 field_int32_;
  ::google::protobuf::uint64 field_uint64_;
  ::google::protobuf::int64 field_int64_;
  ::google::protobuf::uint64 field_fixed64_;
  ::google::protobuf::int64 field_sfixed64_;
  ::google::protobuf::uint32 field_fixed32_;
  ::google::protobuf::int32 field_sfixed32_;
  double field_double_;
  ::google::protobuf::int64 field_sint64_;
  float field_float_;
  ::google::protobuf::int32 field_sint32_;
  ::google::protobuf::internal::ArenaStringPtr field_string_;
  ::google::protobuf::internal::ArenaStringPtr field_bytes_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftest_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftest_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2ftest_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2ftest_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static TestConfig_DummyFields* default_instance_;
};
// -------------------------------------------------------------------

class TestConfig : public ::google::protobuf::MessageLite {
 public:
  TestConfig();
  virtual ~TestConfig();

  TestConfig(const TestConfig& from);

  inline TestConfig& operator=(const TestConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TestConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TestConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TestConfig* other);

  // implements Message ----------------------------------------------

  inline TestConfig* New() const { return New(NULL); }

  TestConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TestConfig& from);
  void MergeFrom(const TestConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TestConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef TestConfig_DummyFields DummyFields;

  // accessors -------------------------------------------------------

  // optional uint32 message_count = 1;
  bool has_message_count() const;
  void clear_message_count();
  static const int kMessageCountFieldNumber = 1;
  ::google::protobuf::uint32 message_count() const;
  void set_message_count(::google::protobuf::uint32 value);

  // optional uint32 max_messages_per_second = 2;
  bool has_max_messages_per_second() const;
  void clear_max_messages_per_second();
  static const int kMaxMessagesPerSecondFieldNumber = 2;
  ::google::protobuf::uint32 max_messages_per_second() const;
  void set_max_messages_per_second(::google::protobuf::uint32 value);

  // optional uint32 seed = 3;
  bool has_seed() const;
  void clear_seed();
  static const int kSeedFieldNumber = 3;
  ::google::protobuf::uint32 seed() const;
  void set_seed(::google::protobuf::uint32 value);

  // optional uint32 message_size = 4;
  bool has_message_size() const;
  void clear_message_size();
  static const int kMessageSizeFieldNumber = 4;
  ::google::protobuf::uint32 message_size() const;
  void set_message_size(::google::protobuf::uint32 value);

  // optional bool send_batch_on_register = 5;
  bool has_send_batch_on_register() const;
  void clear_send_batch_on_register();
  static const int kSendBatchOnRegisterFieldNumber = 5;
  bool send_batch_on_register() const;
  void set_send_batch_on_register(bool value);

  // optional .perfetto.protos.TestConfig.DummyFields dummy_fields = 6;
  bool has_dummy_fields() const;
  void clear_dummy_fields();
  static const int kDummyFieldsFieldNumber = 6;
  const ::perfetto::protos::TestConfig_DummyFields& dummy_fields() const;
  ::perfetto::protos::TestConfig_DummyFields* mutable_dummy_fields();
  ::perfetto::protos::TestConfig_DummyFields* release_dummy_fields();
  void set_allocated_dummy_fields(::perfetto::protos::TestConfig_DummyFields* dummy_fields);

  // @@protoc_insertion_point(class_scope:perfetto.protos.TestConfig)
 private:
  inline void set_has_message_count();
  inline void clear_has_message_count();
  inline void set_has_max_messages_per_second();
  inline void clear_has_max_messages_per_second();
  inline void set_has_seed();
  inline void clear_has_seed();
  inline void set_has_message_size();
  inline void clear_has_message_size();
  inline void set_has_send_batch_on_register();
  inline void clear_has_send_batch_on_register();
  inline void set_has_dummy_fields();
  inline void clear_has_dummy_fields();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 message_count_;
  ::google::protobuf::uint32 max_messages_per_second_;
  ::google::protobuf::uint32 seed_;
  ::google::protobuf::uint32 message_size_;
  ::perfetto::protos::TestConfig_DummyFields* dummy_fields_;
  bool send_batch_on_register_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftest_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftest_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2ftest_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2ftest_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static TestConfig* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// TestConfig_DummyFields

// optional uint32 field_uint32 = 1;
inline bool TestConfig_DummyFields::has_field_uint32() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TestConfig_DummyFields::set_has_field_uint32() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TestConfig_DummyFields::clear_has_field_uint32() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TestConfig_DummyFields::clear_field_uint32() {
  field_uint32_ = 0u;
  clear_has_field_uint32();
}
inline ::google::protobuf::uint32 TestConfig_DummyFields::field_uint32() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_uint32)
  return field_uint32_;
}
inline void TestConfig_DummyFields::set_field_uint32(::google::protobuf::uint32 value) {
  set_has_field_uint32();
  field_uint32_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_uint32)
}

// optional int32 field_int32 = 2;
inline bool TestConfig_DummyFields::has_field_int32() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TestConfig_DummyFields::set_has_field_int32() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TestConfig_DummyFields::clear_has_field_int32() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TestConfig_DummyFields::clear_field_int32() {
  field_int32_ = 0;
  clear_has_field_int32();
}
inline ::google::protobuf::int32 TestConfig_DummyFields::field_int32() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_int32)
  return field_int32_;
}
inline void TestConfig_DummyFields::set_field_int32(::google::protobuf::int32 value) {
  set_has_field_int32();
  field_int32_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_int32)
}

// optional uint64 field_uint64 = 3;
inline bool TestConfig_DummyFields::has_field_uint64() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TestConfig_DummyFields::set_has_field_uint64() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TestConfig_DummyFields::clear_has_field_uint64() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TestConfig_DummyFields::clear_field_uint64() {
  field_uint64_ = GOOGLE_ULONGLONG(0);
  clear_has_field_uint64();
}
inline ::google::protobuf::uint64 TestConfig_DummyFields::field_uint64() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_uint64)
  return field_uint64_;
}
inline void TestConfig_DummyFields::set_field_uint64(::google::protobuf::uint64 value) {
  set_has_field_uint64();
  field_uint64_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_uint64)
}

// optional int64 field_int64 = 4;
inline bool TestConfig_DummyFields::has_field_int64() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TestConfig_DummyFields::set_has_field_int64() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TestConfig_DummyFields::clear_has_field_int64() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TestConfig_DummyFields::clear_field_int64() {
  field_int64_ = GOOGLE_LONGLONG(0);
  clear_has_field_int64();
}
inline ::google::protobuf::int64 TestConfig_DummyFields::field_int64() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_int64)
  return field_int64_;
}
inline void TestConfig_DummyFields::set_field_int64(::google::protobuf::int64 value) {
  set_has_field_int64();
  field_int64_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_int64)
}

// optional fixed64 field_fixed64 = 5;
inline bool TestConfig_DummyFields::has_field_fixed64() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TestConfig_DummyFields::set_has_field_fixed64() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TestConfig_DummyFields::clear_has_field_fixed64() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TestConfig_DummyFields::clear_field_fixed64() {
  field_fixed64_ = GOOGLE_ULONGLONG(0);
  clear_has_field_fixed64();
}
inline ::google::protobuf::uint64 TestConfig_DummyFields::field_fixed64() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_fixed64)
  return field_fixed64_;
}
inline void TestConfig_DummyFields::set_field_fixed64(::google::protobuf::uint64 value) {
  set_has_field_fixed64();
  field_fixed64_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_fixed64)
}

// optional sfixed64 field_sfixed64 = 6;
inline bool TestConfig_DummyFields::has_field_sfixed64() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TestConfig_DummyFields::set_has_field_sfixed64() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TestConfig_DummyFields::clear_has_field_sfixed64() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TestConfig_DummyFields::clear_field_sfixed64() {
  field_sfixed64_ = GOOGLE_LONGLONG(0);
  clear_has_field_sfixed64();
}
inline ::google::protobuf::int64 TestConfig_DummyFields::field_sfixed64() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_sfixed64)
  return field_sfixed64_;
}
inline void TestConfig_DummyFields::set_field_sfixed64(::google::protobuf::int64 value) {
  set_has_field_sfixed64();
  field_sfixed64_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_sfixed64)
}

// optional fixed32 field_fixed32 = 7;
inline bool TestConfig_DummyFields::has_field_fixed32() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TestConfig_DummyFields::set_has_field_fixed32() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TestConfig_DummyFields::clear_has_field_fixed32() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TestConfig_DummyFields::clear_field_fixed32() {
  field_fixed32_ = 0u;
  clear_has_field_fixed32();
}
inline ::google::protobuf::uint32 TestConfig_DummyFields::field_fixed32() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_fixed32)
  return field_fixed32_;
}
inline void TestConfig_DummyFields::set_field_fixed32(::google::protobuf::uint32 value) {
  set_has_field_fixed32();
  field_fixed32_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_fixed32)
}

// optional sfixed32 field_sfixed32 = 8;
inline bool TestConfig_DummyFields::has_field_sfixed32() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TestConfig_DummyFields::set_has_field_sfixed32() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TestConfig_DummyFields::clear_has_field_sfixed32() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TestConfig_DummyFields::clear_field_sfixed32() {
  field_sfixed32_ = 0;
  clear_has_field_sfixed32();
}
inline ::google::protobuf::int32 TestConfig_DummyFields::field_sfixed32() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_sfixed32)
  return field_sfixed32_;
}
inline void TestConfig_DummyFields::set_field_sfixed32(::google::protobuf::int32 value) {
  set_has_field_sfixed32();
  field_sfixed32_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_sfixed32)
}

// optional double field_double = 9;
inline bool TestConfig_DummyFields::has_field_double() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TestConfig_DummyFields::set_has_field_double() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TestConfig_DummyFields::clear_has_field_double() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TestConfig_DummyFields::clear_field_double() {
  field_double_ = 0;
  clear_has_field_double();
}
inline double TestConfig_DummyFields::field_double() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_double)
  return field_double_;
}
inline void TestConfig_DummyFields::set_field_double(double value) {
  set_has_field_double();
  field_double_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_double)
}

// optional float field_float = 10;
inline bool TestConfig_DummyFields::has_field_float() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TestConfig_DummyFields::set_has_field_float() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TestConfig_DummyFields::clear_has_field_float() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TestConfig_DummyFields::clear_field_float() {
  field_float_ = 0;
  clear_has_field_float();
}
inline float TestConfig_DummyFields::field_float() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_float)
  return field_float_;
}
inline void TestConfig_DummyFields::set_field_float(float value) {
  set_has_field_float();
  field_float_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_float)
}

// optional sint64 field_sint64 = 11;
inline bool TestConfig_DummyFields::has_field_sint64() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TestConfig_DummyFields::set_has_field_sint64() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TestConfig_DummyFields::clear_has_field_sint64() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TestConfig_DummyFields::clear_field_sint64() {
  field_sint64_ = GOOGLE_LONGLONG(0);
  clear_has_field_sint64();
}
inline ::google::protobuf::int64 TestConfig_DummyFields::field_sint64() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_sint64)
  return field_sint64_;
}
inline void TestConfig_DummyFields::set_field_sint64(::google::protobuf::int64 value) {
  set_has_field_sint64();
  field_sint64_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_sint64)
}

// optional sint32 field_sint32 = 12;
inline bool TestConfig_DummyFields::has_field_sint32() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TestConfig_DummyFields::set_has_field_sint32() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TestConfig_DummyFields::clear_has_field_sint32() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TestConfig_DummyFields::clear_field_sint32() {
  field_sint32_ = 0;
  clear_has_field_sint32();
}
inline ::google::protobuf::int32 TestConfig_DummyFields::field_sint32() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_sint32)
  return field_sint32_;
}
inline void TestConfig_DummyFields::set_field_sint32(::google::protobuf::int32 value) {
  set_has_field_sint32();
  field_sint32_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_sint32)
}

// optional string field_string = 13;
inline bool TestConfig_DummyFields::has_field_string() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TestConfig_DummyFields::set_has_field_string() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TestConfig_DummyFields::clear_has_field_string() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TestConfig_DummyFields::clear_field_string() {
  field_string_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_field_string();
}
inline const ::std::string& TestConfig_DummyFields::field_string() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_string)
  return field_string_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TestConfig_DummyFields::set_field_string(const ::std::string& value) {
  set_has_field_string();
  field_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_string)
}
inline void TestConfig_DummyFields::set_field_string(const char* value) {
  set_has_field_string();
  field_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.TestConfig.DummyFields.field_string)
}
inline void TestConfig_DummyFields::set_field_string(const char* value, size_t size) {
  set_has_field_string();
  field_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.TestConfig.DummyFields.field_string)
}
inline ::std::string* TestConfig_DummyFields::mutable_field_string() {
  set_has_field_string();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TestConfig.DummyFields.field_string)
  return field_string_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TestConfig_DummyFields::release_field_string() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TestConfig.DummyFields.field_string)
  clear_has_field_string();
  return field_string_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TestConfig_DummyFields::set_allocated_field_string(::std::string* field_string) {
  if (field_string != NULL) {
    set_has_field_string();
  } else {
    clear_has_field_string();
  }
  field_string_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), field_string);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TestConfig.DummyFields.field_string)
}

// optional bytes field_bytes = 14;
inline bool TestConfig_DummyFields::has_field_bytes() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TestConfig_DummyFields::set_has_field_bytes() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TestConfig_DummyFields::clear_has_field_bytes() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TestConfig_DummyFields::clear_field_bytes() {
  field_bytes_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_field_bytes();
}
inline const ::std::string& TestConfig_DummyFields::field_bytes() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_bytes)
  return field_bytes_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TestConfig_DummyFields::set_field_bytes(const ::std::string& value) {
  set_has_field_bytes();
  field_bytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_bytes)
}
inline void TestConfig_DummyFields::set_field_bytes(const char* value) {
  set_has_field_bytes();
  field_bytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.TestConfig.DummyFields.field_bytes)
}
inline void TestConfig_DummyFields::set_field_bytes(const void* value, size_t size) {
  set_has_field_bytes();
  field_bytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.TestConfig.DummyFields.field_bytes)
}
inline ::std::string* TestConfig_DummyFields::mutable_field_bytes() {
  set_has_field_bytes();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TestConfig.DummyFields.field_bytes)
  return field_bytes_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TestConfig_DummyFields::release_field_bytes() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TestConfig.DummyFields.field_bytes)
  clear_has_field_bytes();
  return field_bytes_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TestConfig_DummyFields::set_allocated_field_bytes(::std::string* field_bytes) {
  if (field_bytes != NULL) {
    set_has_field_bytes();
  } else {
    clear_has_field_bytes();
  }
  field_bytes_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), field_bytes);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TestConfig.DummyFields.field_bytes)
}

// -------------------------------------------------------------------

// TestConfig

// optional uint32 message_count = 1;
inline bool TestConfig::has_message_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TestConfig::set_has_message_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TestConfig::clear_has_message_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TestConfig::clear_message_count() {
  message_count_ = 0u;
  clear_has_message_count();
}
inline ::google::protobuf::uint32 TestConfig::message_count() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.message_count)
  return message_count_;
}
inline void TestConfig::set_message_count(::google::protobuf::uint32 value) {
  set_has_message_count();
  message_count_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.message_count)
}

// optional uint32 max_messages_per_second = 2;
inline bool TestConfig::has_max_messages_per_second() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TestConfig::set_has_max_messages_per_second() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TestConfig::clear_has_max_messages_per_second() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TestConfig::clear_max_messages_per_second() {
  max_messages_per_second_ = 0u;
  clear_has_max_messages_per_second();
}
inline ::google::protobuf::uint32 TestConfig::max_messages_per_second() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.max_messages_per_second)
  return max_messages_per_second_;
}
inline void TestConfig::set_max_messages_per_second(::google::protobuf::uint32 value) {
  set_has_max_messages_per_second();
  max_messages_per_second_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.max_messages_per_second)
}

// optional uint32 seed = 3;
inline bool TestConfig::has_seed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TestConfig::set_has_seed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TestConfig::clear_has_seed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TestConfig::clear_seed() {
  seed_ = 0u;
  clear_has_seed();
}
inline ::google::protobuf::uint32 TestConfig::seed() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.seed)
  return seed_;
}
inline void TestConfig::set_seed(::google::protobuf::uint32 value) {
  set_has_seed();
  seed_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.seed)
}

// optional uint32 message_size = 4;
inline bool TestConfig::has_message_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TestConfig::set_has_message_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TestConfig::clear_has_message_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TestConfig::clear_message_size() {
  message_size_ = 0u;
  clear_has_message_size();
}
inline ::google::protobuf::uint32 TestConfig::message_size() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.message_size)
  return message_size_;
}
inline void TestConfig::set_message_size(::google::protobuf::uint32 value) {
  set_has_message_size();
  message_size_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.message_size)
}

// optional bool send_batch_on_register = 5;
inline bool TestConfig::has_send_batch_on_register() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TestConfig::set_has_send_batch_on_register() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TestConfig::clear_has_send_batch_on_register() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TestConfig::clear_send_batch_on_register() {
  send_batch_on_register_ = false;
  clear_has_send_batch_on_register();
}
inline bool TestConfig::send_batch_on_register() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.send_batch_on_register)
  return send_batch_on_register_;
}
inline void TestConfig::set_send_batch_on_register(bool value) {
  set_has_send_batch_on_register();
  send_batch_on_register_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.send_batch_on_register)
}

// optional .perfetto.protos.TestConfig.DummyFields dummy_fields = 6;
inline bool TestConfig::has_dummy_fields() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TestConfig::set_has_dummy_fields() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TestConfig::clear_has_dummy_fields() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TestConfig::clear_dummy_fields() {
  if (dummy_fields_ != NULL) dummy_fields_->::perfetto::protos::TestConfig_DummyFields::Clear();
  clear_has_dummy_fields();
}
inline const ::perfetto::protos::TestConfig_DummyFields& TestConfig::dummy_fields() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.dummy_fields)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return dummy_fields_ != NULL ? *dummy_fields_ : *default_instance().dummy_fields_;
#else
  return dummy_fields_ != NULL ? *dummy_fields_ : *default_instance_->dummy_fields_;
#endif
}
inline ::perfetto::protos::TestConfig_DummyFields* TestConfig::mutable_dummy_fields() {
  set_has_dummy_fields();
  if (dummy_fields_ == NULL) {
    dummy_fields_ = new ::perfetto::protos::TestConfig_DummyFields;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TestConfig.dummy_fields)
  return dummy_fields_;
}
inline ::perfetto::protos::TestConfig_DummyFields* TestConfig::release_dummy_fields() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TestConfig.dummy_fields)
  clear_has_dummy_fields();
  ::perfetto::protos::TestConfig_DummyFields* temp = dummy_fields_;
  dummy_fields_ = NULL;
  return temp;
}
inline void TestConfig::set_allocated_dummy_fields(::perfetto::protos::TestConfig_DummyFields* dummy_fields) {
  delete dummy_fields_;
  dummy_fields_ = dummy_fields;
  if (dummy_fields) {
    set_has_dummy_fields();
  } else {
    clear_has_dummy_fields();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TestConfig.dummy_fields)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2fconfig_2ftest_5fconfig_2eproto__INCLUDED
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/config/data_source_config.proto

#ifndef PROTOBUF_protos_2fperfetto_2fconfig_2fdata_5fsource_5fconfig_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2fconfig_2fdata_5fsource_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// gen_amalgamated expanded: #include "protos/perfetto/config/android/android_log_config.pb.h"
// gen_amalgamated expanded: #include "protos/perfetto/config/android/packages_list_config.pb.h"
// gen_amalgamated expanded: #include "protos/perfetto/config/chrome/chrome_config.pb.h"
// gen_amalgamated expanded: #include "protos/perfetto/config/ftrace/ftrace_config.pb.h"
// gen_amalgamated expanded: #include "protos/perfetto/config/gpu/gpu_counter_config.pb.h"
// gen_amalgamated expanded: #include "protos/perfetto/config/inode_file/inode_file_config.pb.h"
// gen_amalgamated expanded: #include "protos/perfetto/config/power/android_power_config.pb.h"
// gen_amalgamated expanded: #include "protos/perfetto/config/process_stats/process_stats_config.pb.h"
// gen_amalgamated expanded: #include "protos/perfetto/config/profiling/heapprofd_config.pb.h"
// gen_amalgamated expanded: #include "protos/perfetto/config/sys_stats/sys_stats_config.pb.h"
// gen_amalgamated expanded: #include "protos/perfetto/config/test_config.pb.h"
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2fconfig_2fdata_5fsource_5fconfig_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2fdata_5fsource_5fconfig_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2fdata_5fsource_5fconfig_2eproto();

class DataSourceConfig;

// ===================================================================

class DataSourceConfig : public ::google::protobuf::MessageLite {
 public:
  DataSourceConfig();
  virtual ~DataSourceConfig();

  DataSourceConfig(const DataSourceConfig& from);

  inline DataSourceConfig& operator=(const DataSourceConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const DataSourceConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DataSourceConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DataSourceConfig* other);

  // implements Message ----------------------------------------------

  inline DataSourceConfig* New() const { return New(NULL); }

  DataSourceConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DataSourceConfig& from);
  void MergeFrom(const DataSourceConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DataSourceConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional uint32 target_buffer = 2;
  bool has_target_buffer() const;
  void clear_target_buffer();
  static const int kTargetBufferFieldNumber = 2;
  ::google::protobuf::uint32 target_buffer() const;
  void set_target_buffer(::google::protobuf::uint32 value);

  // optional uint32 trace_duration_ms = 3;
  bool has_trace_duration_ms() const;
  void clear_trace_duration_ms();
  static const int kTraceDurationMsFieldNumber = 3;
  ::google::protobuf::uint32 trace_duration_ms() const;
  void set_trace_duration_ms(::google::protobuf::uint32 value);

  // optional uint32 stop_timeout_ms = 7;
  bool has_stop_timeout_ms() const;
  void clear_stop_timeout_ms();
  static const int kStopTimeoutMsFieldNumber = 7;
  ::google::protobuf::uint32 stop_timeout_ms() const;
  void set_stop_timeout_ms(::google::protobuf::uint32 value);

  // optional bool enable_extra_guardrails = 6;
  bool has_enable_extra_guardrails() const;
  void clear_enable_extra_guardrails();
  static const int kEnableExtraGuardrailsFieldNumber = 6;
  bool enable_extra_guardrails() const;
  void set_enable_extra_guardrails(bool value);

  // optional uint64 tracing_session_id = 4;
  bool has_tracing_session_id() const;
  void clear_tracing_session_id();
  static const int kTracingSessionIdFieldNumber = 4;
  ::google::protobuf::uint64 tracing_session_id() const;
  void set_tracing_session_id(::google::protobuf::uint64 value);

  // optional .perfetto.protos.FtraceConfig ftrace_config = 100 [lazy = true];
  bool has_ftrace_config() const;
  void clear_ftrace_config();
  static const int kFtraceConfigFieldNumber = 100;
  const ::perfetto::protos::FtraceConfig& ftrace_config() const;
  ::perfetto::protos::FtraceConfig* mutable_ftrace_config();
  ::perfetto::protos::FtraceConfig* release_ftrace_config();
  void set_allocated_ftrace_config(::perfetto::protos::FtraceConfig* ftrace_config);

  // optional .perfetto.protos.InodeFileConfig inode_file_config = 102 [lazy = true];
  bool has_inode_file_config() const;
  void clear_inode_file_config();
  static const int kInodeFileConfigFieldNumber = 102;
  const ::perfetto::protos::InodeFileConfig& inode_file_config() const;
  ::perfetto::protos::InodeFileConfig* mutable_inode_file_config();
  ::perfetto::protos::InodeFileConfig* release_inode_file_config();
  void set_allocated_inode_file_config(::perfetto::protos::InodeFileConfig* inode_file_config);

  // optional .perfetto.protos.ProcessStatsConfig process_stats_config = 103 [lazy = true];
  bool has_process_stats_config() const;
  void clear_process_stats_config();
  static const int kProcessStatsConfigFieldNumber = 103;
  const ::perfetto::protos::ProcessStatsConfig& process_stats_config() const;
  ::perfetto::protos::ProcessStatsConfig* mutable_process_stats_config();
  ::perfetto::protos::ProcessStatsConfig* release_process_stats_config();
  void set_allocated_process_stats_config(::perfetto::protos::ProcessStatsConfig* process_stats_config);

  // optional .perfetto.protos.SysStatsConfig sys_stats_config = 104 [lazy = true];
  bool has_sys_stats_config() const;
  void clear_sys_stats_config();
  static const int kSysStatsConfigFieldNumber = 104;
  const ::perfetto::protos::SysStatsConfig& sys_stats_config() const;
  ::perfetto::protos::SysStatsConfig* mutable_sys_stats_config();
  ::perfetto::protos::SysStatsConfig* release_sys_stats_config();
  void set_allocated_sys_stats_config(::perfetto::protos::SysStatsConfig* sys_stats_config);

  // optional .perfetto.protos.HeapprofdConfig heapprofd_config = 105 [lazy = true];
  bool has_heapprofd_config() const;
  void clear_heapprofd_config();
  static const int kHeapprofdConfigFieldNumber = 105;
  const ::perfetto::protos::HeapprofdConfig& heapprofd_config() const;
  ::perfetto::protos::HeapprofdConfig* mutable_heapprofd_config();
  ::perfetto::protos::HeapprofdConfig* release_heapprofd_config();
  void set_allocated_heapprofd_config(::perfetto::protos::HeapprofdConfig* heapprofd_config);

  // optional .perfetto.protos.AndroidPowerConfig android_power_config = 106 [lazy = true];
  bool has_android_power_config() const;
  void clear_android_power_config();
  static const int kAndroidPowerConfigFieldNumber = 106;
  const ::perfetto::protos::AndroidPowerConfig& android_power_config() const;
  ::perfetto::protos::AndroidPowerConfig* mutable_android_power_config();
  ::perfetto::protos::AndroidPowerConfig* release_android_power_config();
  void set_allocated_android_power_config(::perfetto::protos::AndroidPowerConfig* android_power_config);

  // optional .perfetto.protos.AndroidLogConfig android_log_config = 107 [lazy = true];
  bool has_android_log_config() const;
  void clear_android_log_config();
  static const int kAndroidLogConfigFieldNumber = 107;
  const ::perfetto::protos::AndroidLogConfig& android_log_config() const;
  ::perfetto::protos::AndroidLogConfig* mutable_android_log_config();
  ::perfetto::protos::AndroidLogConfig* release_android_log_config();
  void set_allocated_android_log_config(::perfetto::protos::AndroidLogConfig* android_log_config);

  // optional .perfetto.protos.GpuCounterConfig gpu_counter_config = 108 [lazy = true];
  bool has_gpu_counter_config() const;
  void clear_gpu_counter_config();
  static const int kGpuCounterConfigFieldNumber = 108;
  const ::perfetto::protos::GpuCounterConfig& gpu_counter_config() const;
  ::perfetto::protos::GpuCounterConfig* mutable_gpu_counter_config();
  ::perfetto::protos::GpuCounterConfig* release_gpu_counter_config();
  void set_allocated_gpu_counter_config(::perfetto::protos::GpuCounterConfig* gpu_counter_config);

  // optional .perfetto.protos.PackagesListConfig packages_list_config = 109 [lazy = true];
  bool has_packages_list_config() const;
  void clear_packages_list_config();
  static const int kPackagesListConfigFieldNumber = 109;
  const ::perfetto::protos::PackagesListConfig& packages_list_config() const;
  ::perfetto::protos::PackagesListConfig* mutable_packages_list_config();
  ::perfetto::protos::PackagesListConfig* release_packages_list_config();
  void set_allocated_packages_list_config(::perfetto::protos::PackagesListConfig* packages_list_config);

  // optional .perfetto.protos.ChromeConfig chrome_config = 101;
  bool has_chrome_config() const;
  void clear_chrome_config();
  static const int kChromeConfigFieldNumber = 101;
  const ::perfetto::protos::ChromeConfig& chrome_config() const;
  ::perfetto::protos::ChromeConfig* mutable_chrome_config();
  ::perfetto::protos::ChromeConfig* release_chrome_config();
  void set_allocated_chrome_config(::perfetto::protos::ChromeConfig* chrome_config);

  // optional string legacy_config = 1000;
  bool has_legacy_config() const;
  void clear_legacy_config();
  static const int kLegacyConfigFieldNumber = 1000;
  const ::std::string& legacy_config() const;
  void set_legacy_config(const ::std::string& value);
  void set_legacy_config(const char* value);
  void set_legacy_config(const char* value, size_t size);
  ::std::string* mutable_legacy_config();
  ::std::string* release_legacy_config();
  void set_allocated_legacy_config(::std::string* legacy_config);

  // optional .perfetto.protos.TestConfig for_testing = 1001;
  bool has_for_testing() const;
  void clear_for_testing();
  static const int kForTestingFieldNumber = 1001;
  const ::perfetto::protos::TestConfig& for_testing() const;
  ::perfetto::protos::TestConfig* mutable_for_testing();
  ::perfetto::protos::TestConfig* release_for_testing();
  void set_allocated_for_testing(::perfetto::protos::TestConfig* for_testing);

  // @@protoc_insertion_point(class_scope:perfetto.protos.DataSourceConfig)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_target_buffer();
  inline void clear_has_target_buffer();
  inline void set_has_trace_duration_ms();
  inline void clear_has_trace_duration_ms();
  inline void set_has_stop_timeout_ms();
  inline void clear_has_stop_timeout_ms();
  inline void set_has_enable_extra_guardrails();
  inline void clear_has_enable_extra_guardrails();
  inline void set_has_tracing_session_id();
  inline void clear_has_tracing_session_id();
  inline void set_has_ftrace_config();
  inline void clear_has_ftrace_config();
  inline void set_has_inode_file_config();
  inline void clear_has_inode_file_config();
  inline void set_has_process_stats_config();
  inline void clear_has_process_stats_config();
  inline void set_has_sys_stats_config();
  inline void clear_has_sys_stats_config();
  inline void set_has_heapprofd_config();
  inline void clear_has_heapprofd_config();
  inline void set_has_android_power_config();
  inline void clear_has_android_power_config();
  inline void set_has_android_log_config();
  inline void clear_has_android_log_config();
  inline void set_has_gpu_counter_config();
  inline void clear_has_gpu_counter_config();
  inline void set_has_packages_list_config();
  inline void clear_has_packages_list_config();
  inline void set_has_chrome_config();
  inline void clear_has_chrome_config();
  inline void set_has_legacy_config();
  inline void clear_has_legacy_config();
  inline void set_has_for_testing();
  inline void clear_has_for_testing();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint32 target_buffer_;
  ::google::protobuf::uint32 trace_duration_ms_;
  ::google::protobuf::uint32 stop_timeout_ms_;
  bool enable_extra_guardrails_;
  ::google::protobuf::uint64 tracing_session_id_;
  ::perfetto::protos::FtraceConfig* ftrace_config_;
  ::perfetto::protos::InodeFileConfig* inode_file_config_;
  ::perfetto::protos::ProcessStatsConfig* process_stats_config_;
  ::perfetto::protos::SysStatsConfig* sys_stats_config_;
  ::perfetto::protos::HeapprofdConfig* heapprofd_config_;
  ::perfetto::protos::AndroidPowerConfig* android_power_config_;
  ::perfetto::protos::AndroidLogConfig* android_log_config_;
  ::perfetto::protos::GpuCounterConfig* gpu_counter_config_;
  ::perfetto::protos::PackagesListConfig* packages_list_config_;
  ::perfetto::protos::ChromeConfig* chrome_config_;
  ::google::protobuf::internal::ArenaStringPtr legacy_config_;
  ::perfetto::protos::TestConfig* for_testing_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2fdata_5fsource_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2fdata_5fsource_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2fdata_5fsource_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2fdata_5fsource_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static DataSourceConfig* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// DataSourceConfig

// optional string name = 1;
inline bool DataSourceConfig::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataSourceConfig::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataSourceConfig::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataSourceConfig::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& DataSourceConfig::name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DataSourceConfig::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.DataSourceConfig.name)
}
inline void DataSourceConfig::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.DataSourceConfig.name)
}
inline void DataSourceConfig::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.DataSourceConfig.name)
}
inline ::std::string* DataSourceConfig::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceConfig.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DataSourceConfig::release_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceConfig.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DataSourceConfig::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceConfig.name)
}

// optional uint32 target_buffer = 2;
inline bool DataSourceConfig::has_target_buffer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataSourceConfig::set_has_target_buffer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataSourceConfig::clear_has_target_buffer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataSourceConfig::clear_target_buffer() {
  target_buffer_ = 0u;
  clear_has_target_buffer();
}
inline ::google::protobuf::uint32 DataSourceConfig::target_buffer() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.target_buffer)
  return target_buffer_;
}
inline void DataSourceConfig::set_target_buffer(::google::protobuf::uint32 value) {
  set_has_target_buffer();
  target_buffer_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.DataSourceConfig.target_buffer)
}

// optional uint32 trace_duration_ms = 3;
inline bool DataSourceConfig::has_trace_duration_ms() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DataSourceConfig::set_has_trace_duration_ms() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DataSourceConfig::clear_has_trace_duration_ms() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DataSourceConfig::clear_trace_duration_ms() {
  trace_duration_ms_ = 0u;
  clear_has_trace_duration_ms();
}
inline ::google::protobuf::uint32 DataSourceConfig::trace_duration_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.trace_duration_ms)
  return trace_duration_ms_;
}
inline void DataSourceConfig::set_trace_duration_ms(::google::protobuf::uint32 value) {
  set_has_trace_duration_ms();
  trace_duration_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.DataSourceConfig.trace_duration_ms)
}

// optional uint32 stop_timeout_ms = 7;
inline bool DataSourceConfig::has_stop_timeout_ms() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DataSourceConfig::set_has_stop_timeout_ms() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DataSourceConfig::clear_has_stop_timeout_ms() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DataSourceConfig::clear_stop_timeout_ms() {
  stop_timeout_ms_ = 0u;
  clear_has_stop_timeout_ms();
}
inline ::google::protobuf::uint32 DataSourceConfig::stop_timeout_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.stop_timeout_ms)
  return stop_timeout_ms_;
}
inline void DataSourceConfig::set_stop_timeout_ms(::google::protobuf::uint32 value) {
  set_has_stop_timeout_ms();
  stop_timeout_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.DataSourceConfig.stop_timeout_ms)
}

// optional bool enable_extra_guardrails = 6;
inline bool DataSourceConfig::has_enable_extra_guardrails() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DataSourceConfig::set_has_enable_extra_guardrails() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DataSourceConfig::clear_has_enable_extra_guardrails() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DataSourceConfig::clear_enable_extra_guardrails() {
  enable_extra_guardrails_ = false;
  clear_has_enable_extra_guardrails();
}
inline bool DataSourceConfig::enable_extra_guardrails() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.enable_extra_guardrails)
  return enable_extra_guardrails_;
}
inline void DataSourceConfig::set_enable_extra_guardrails(bool value) {
  set_has_enable_extra_guardrails();
  enable_extra_guardrails_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.DataSourceConfig.enable_extra_guardrails)
}

// optional uint64 tracing_session_id = 4;
inline bool DataSourceConfig::has_tracing_session_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DataSourceConfig::set_has_tracing_session_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DataSourceConfig::clear_has_tracing_session_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DataSourceConfig::clear_tracing_session_id() {
  tracing_session_id_ = GOOGLE_ULONGLONG(0);
  clear_has_tracing_session_id();
}
inline ::google::protobuf::uint64 DataSourceConfig::tracing_session_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.tracing_session_id)
  return tracing_session_id_;
}
inline void DataSourceConfig::set_tracing_session_id(::google::protobuf::uint64 value) {
  set_has_tracing_session_id();
  tracing_session_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.DataSourceConfig.tracing_session_id)
}

// optional .perfetto.protos.FtraceConfig ftrace_config = 100 [lazy = true];
inline bool DataSourceConfig::has_ftrace_config() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DataSourceConfig::set_has_ftrace_config() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DataSourceConfig::clear_has_ftrace_config() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DataSourceConfig::clear_ftrace_config() {
  if (ftrace_config_ != NULL) ftrace_config_->::perfetto::protos::FtraceConfig::Clear();
  clear_has_ftrace_config();
}
inline const ::perfetto::protos::FtraceConfig& DataSourceConfig::ftrace_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.ftrace_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return ftrace_config_ != NULL ? *ftrace_config_ : *default_instance().ftrace_config_;
#else
  return ftrace_config_ != NULL ? *ftrace_config_ : *default_instance_->ftrace_config_;
#endif
}
inline ::perfetto::protos::FtraceConfig* DataSourceConfig::mutable_ftrace_config() {
  set_has_ftrace_config();
  if (ftrace_config_ == NULL) {
    ftrace_config_ = new ::perfetto::protos::FtraceConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceConfig.ftrace_config)
  return ftrace_config_;
}
inline ::perfetto::protos::FtraceConfig* DataSourceConfig::release_ftrace_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceConfig.ftrace_config)
  clear_has_ftrace_config();
  ::perfetto::protos::FtraceConfig* temp = ftrace_config_;
  ftrace_config_ = NULL;
  return temp;
}
inline void DataSourceConfig::set_allocated_ftrace_config(::perfetto::protos::FtraceConfig* ftrace_config) {
  delete ftrace_config_;
  ftrace_config_ = ftrace_config;
  if (ftrace_config) {
    set_has_ftrace_config();
  } else {
    clear_has_ftrace_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceConfig.ftrace_config)
}

// optional .perfetto.protos.InodeFileConfig inode_file_config = 102 [lazy = true];
inline bool DataSourceConfig::has_inode_file_config() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DataSourceConfig::set_has_inode_file_config() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DataSourceConfig::clear_has_inode_file_config() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DataSourceConfig::clear_inode_file_config() {
  if (inode_file_config_ != NULL) inode_file_config_->::perfetto::protos::InodeFileConfig::Clear();
  clear_has_inode_file_config();
}
inline const ::perfetto::protos::InodeFileConfig& DataSourceConfig::inode_file_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.inode_file_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return inode_file_config_ != NULL ? *inode_file_config_ : *default_instance().inode_file_config_;
#else
  return inode_file_config_ != NULL ? *inode_file_config_ : *default_instance_->inode_file_config_;
#endif
}
inline ::perfetto::protos::InodeFileConfig* DataSourceConfig::mutable_inode_file_config() {
  set_has_inode_file_config();
  if (inode_file_config_ == NULL) {
    inode_file_config_ = new ::perfetto::protos::InodeFileConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceConfig.inode_file_config)
  return inode_file_config_;
}
inline ::perfetto::protos::InodeFileConfig* DataSourceConfig::release_inode_file_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceConfig.inode_file_config)
  clear_has_inode_file_config();
  ::perfetto::protos::InodeFileConfig* temp = inode_file_config_;
  inode_file_config_ = NULL;
  return temp;
}
inline void DataSourceConfig::set_allocated_inode_file_config(::perfetto::protos::InodeFileConfig* inode_file_config) {
  delete inode_file_config_;
  inode_file_config_ = inode_file_config;
  if (inode_file_config) {
    set_has_inode_file_config();
  } else {
    clear_has_inode_file_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceConfig.inode_file_config)
}

// optional .perfetto.protos.ProcessStatsConfig process_stats_config = 103 [lazy = true];
inline bool DataSourceConfig::has_process_stats_config() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DataSourceConfig::set_has_process_stats_config() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DataSourceConfig::clear_has_process_stats_config() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DataSourceConfig::clear_process_stats_config() {
  if (process_stats_config_ != NULL) process_stats_config_->::perfetto::protos::ProcessStatsConfig::Clear();
  clear_has_process_stats_config();
}
inline const ::perfetto::protos::ProcessStatsConfig& DataSourceConfig::process_stats_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.process_stats_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return process_stats_config_ != NULL ? *process_stats_config_ : *default_instance().process_stats_config_;
#else
  return process_stats_config_ != NULL ? *process_stats_config_ : *default_instance_->process_stats_config_;
#endif
}
inline ::perfetto::protos::ProcessStatsConfig* DataSourceConfig::mutable_process_stats_config() {
  set_has_process_stats_config();
  if (process_stats_config_ == NULL) {
    process_stats_config_ = new ::perfetto::protos::ProcessStatsConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceConfig.process_stats_config)
  return process_stats_config_;
}
inline ::perfetto::protos::ProcessStatsConfig* DataSourceConfig::release_process_stats_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceConfig.process_stats_config)
  clear_has_process_stats_config();
  ::perfetto::protos::ProcessStatsConfig* temp = process_stats_config_;
  process_stats_config_ = NULL;
  return temp;
}
inline void DataSourceConfig::set_allocated_process_stats_config(::perfetto::protos::ProcessStatsConfig* process_stats_config) {
  delete process_stats_config_;
  process_stats_config_ = process_stats_config;
  if (process_stats_config) {
    set_has_process_stats_config();
  } else {
    clear_has_process_stats_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceConfig.process_stats_config)
}

// optional .perfetto.protos.SysStatsConfig sys_stats_config = 104 [lazy = true];
inline bool DataSourceConfig::has_sys_stats_config() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DataSourceConfig::set_has_sys_stats_config() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DataSourceConfig::clear_has_sys_stats_config() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DataSourceConfig::clear_sys_stats_config() {
  if (sys_stats_config_ != NULL) sys_stats_config_->::perfetto::protos::SysStatsConfig::Clear();
  clear_has_sys_stats_config();
}
inline const ::perfetto::protos::SysStatsConfig& DataSourceConfig::sys_stats_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.sys_stats_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return sys_stats_config_ != NULL ? *sys_stats_config_ : *default_instance().sys_stats_config_;
#else
  return sys_stats_config_ != NULL ? *sys_stats_config_ : *default_instance_->sys_stats_config_;
#endif
}
inline ::perfetto::protos::SysStatsConfig* DataSourceConfig::mutable_sys_stats_config() {
  set_has_sys_stats_config();
  if (sys_stats_config_ == NULL) {
    sys_stats_config_ = new ::perfetto::protos::SysStatsConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceConfig.sys_stats_config)
  return sys_stats_config_;
}
inline ::perfetto::protos::SysStatsConfig* DataSourceConfig::release_sys_stats_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceConfig.sys_stats_config)
  clear_has_sys_stats_config();
  ::perfetto::protos::SysStatsConfig* temp = sys_stats_config_;
  sys_stats_config_ = NULL;
  return temp;
}
inline void DataSourceConfig::set_allocated_sys_stats_config(::perfetto::protos::SysStatsConfig* sys_stats_config) {
  delete sys_stats_config_;
  sys_stats_config_ = sys_stats_config;
  if (sys_stats_config) {
    set_has_sys_stats_config();
  } else {
    clear_has_sys_stats_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceConfig.sys_stats_config)
}

// optional .perfetto.protos.HeapprofdConfig heapprofd_config = 105 [lazy = true];
inline bool DataSourceConfig::has_heapprofd_config() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DataSourceConfig::set_has_heapprofd_config() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DataSourceConfig::clear_has_heapprofd_config() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DataSourceConfig::clear_heapprofd_config() {
  if (heapprofd_config_ != NULL) heapprofd_config_->::perfetto::protos::HeapprofdConfig::Clear();
  clear_has_heapprofd_config();
}
inline const ::perfetto::protos::HeapprofdConfig& DataSourceConfig::heapprofd_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.heapprofd_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return heapprofd_config_ != NULL ? *heapprofd_config_ : *default_instance().heapprofd_config_;
#else
  return heapprofd_config_ != NULL ? *heapprofd_config_ : *default_instance_->heapprofd_config_;
#endif
}
inline ::perfetto::protos::HeapprofdConfig* DataSourceConfig::mutable_heapprofd_config() {
  set_has_heapprofd_config();
  if (heapprofd_config_ == NULL) {
    heapprofd_config_ = new ::perfetto::protos::HeapprofdConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceConfig.heapprofd_config)
  return heapprofd_config_;
}
inline ::perfetto::protos::HeapprofdConfig* DataSourceConfig::release_heapprofd_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceConfig.heapprofd_config)
  clear_has_heapprofd_config();
  ::perfetto::protos::HeapprofdConfig* temp = heapprofd_config_;
  heapprofd_config_ = NULL;
  return temp;
}
inline void DataSourceConfig::set_allocated_heapprofd_config(::perfetto::protos::HeapprofdConfig* heapprofd_config) {
  delete heapprofd_config_;
  heapprofd_config_ = heapprofd_config;
  if (heapprofd_config) {
    set_has_heapprofd_config();
  } else {
    clear_has_heapprofd_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceConfig.heapprofd_config)
}

// optional .perfetto.protos.AndroidPowerConfig android_power_config = 106 [lazy = true];
inline bool DataSourceConfig::has_android_power_config() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DataSourceConfig::set_has_android_power_config() {
  _has_bits_[0] |= 0x00000800u;
}
inline void DataSourceConfig::clear_has_android_power_config() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void DataSourceConfig::clear_android_power_config() {
  if (android_power_config_ != NULL) android_power_config_->::perfetto::protos::AndroidPowerConfig::Clear();
  clear_has_android_power_config();
}
inline const ::perfetto::protos::AndroidPowerConfig& DataSourceConfig::android_power_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.android_power_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return android_power_config_ != NULL ? *android_power_config_ : *default_instance().android_power_config_;
#else
  return android_power_config_ != NULL ? *android_power_config_ : *default_instance_->android_power_config_;
#endif
}
inline ::perfetto::protos::AndroidPowerConfig* DataSourceConfig::mutable_android_power_config() {
  set_has_android_power_config();
  if (android_power_config_ == NULL) {
    android_power_config_ = new ::perfetto::protos::AndroidPowerConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceConfig.android_power_config)
  return android_power_config_;
}
inline ::perfetto::protos::AndroidPowerConfig* DataSourceConfig::release_android_power_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceConfig.android_power_config)
  clear_has_android_power_config();
  ::perfetto::protos::AndroidPowerConfig* temp = android_power_config_;
  android_power_config_ = NULL;
  return temp;
}
inline void DataSourceConfig::set_allocated_android_power_config(::perfetto::protos::AndroidPowerConfig* android_power_config) {
  delete android_power_config_;
  android_power_config_ = android_power_config;
  if (android_power_config) {
    set_has_android_power_config();
  } else {
    clear_has_android_power_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceConfig.android_power_config)
}

// optional .perfetto.protos.AndroidLogConfig android_log_config = 107 [lazy = true];
inline bool DataSourceConfig::has_android_log_config() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void DataSourceConfig::set_has_android_log_config() {
  _has_bits_[0] |= 0x00001000u;
}
inline void DataSourceConfig::clear_has_android_log_config() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void DataSourceConfig::clear_android_log_config() {
  if (android_log_config_ != NULL) android_log_config_->::perfetto::protos::AndroidLogConfig::Clear();
  clear_has_android_log_config();
}
inline const ::perfetto::protos::AndroidLogConfig& DataSourceConfig::android_log_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.android_log_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return android_log_config_ != NULL ? *android_log_config_ : *default_instance().android_log_config_;
#else
  return android_log_config_ != NULL ? *android_log_config_ : *default_instance_->android_log_config_;
#endif
}
inline ::perfetto::protos::AndroidLogConfig* DataSourceConfig::mutable_android_log_config() {
  set_has_android_log_config();
  if (android_log_config_ == NULL) {
    android_log_config_ = new ::perfetto::protos::AndroidLogConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceConfig.android_log_config)
  return android_log_config_;
}
inline ::perfetto::protos::AndroidLogConfig* DataSourceConfig::release_android_log_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceConfig.android_log_config)
  clear_has_android_log_config();
  ::perfetto::protos::AndroidLogConfig* temp = android_log_config_;
  android_log_config_ = NULL;
  return temp;
}
inline void DataSourceConfig::set_allocated_android_log_config(::perfetto::protos::AndroidLogConfig* android_log_config) {
  delete android_log_config_;
  android_log_config_ = android_log_config;
  if (android_log_config) {
    set_has_android_log_config();
  } else {
    clear_has_android_log_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceConfig.android_log_config)
}

// optional .perfetto.protos.GpuCounterConfig gpu_counter_config = 108 [lazy = true];
inline bool DataSourceConfig::has_gpu_counter_config() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void DataSourceConfig::set_has_gpu_counter_config() {
  _has_bits_[0] |= 0x00002000u;
}
inline void DataSourceConfig::clear_has_gpu_counter_config() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void DataSourceConfig::clear_gpu_counter_config() {
  if (gpu_counter_config_ != NULL) gpu_counter_config_->::perfetto::protos::GpuCounterConfig::Clear();
  clear_has_gpu_counter_config();
}
inline const ::perfetto::protos::GpuCounterConfig& DataSourceConfig::gpu_counter_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.gpu_counter_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return gpu_counter_config_ != NULL ? *gpu_counter_config_ : *default_instance().gpu_counter_config_;
#else
  return gpu_counter_config_ != NULL ? *gpu_counter_config_ : *default_instance_->gpu_counter_config_;
#endif
}
inline ::perfetto::protos::GpuCounterConfig* DataSourceConfig::mutable_gpu_counter_config() {
  set_has_gpu_counter_config();
  if (gpu_counter_config_ == NULL) {
    gpu_counter_config_ = new ::perfetto::protos::GpuCounterConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceConfig.gpu_counter_config)
  return gpu_counter_config_;
}
inline ::perfetto::protos::GpuCounterConfig* DataSourceConfig::release_gpu_counter_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceConfig.gpu_counter_config)
  clear_has_gpu_counter_config();
  ::perfetto::protos::GpuCounterConfig* temp = gpu_counter_config_;
  gpu_counter_config_ = NULL;
  return temp;
}
inline void DataSourceConfig::set_allocated_gpu_counter_config(::perfetto::protos::GpuCounterConfig* gpu_counter_config) {
  delete gpu_counter_config_;
  gpu_counter_config_ = gpu_counter_config;
  if (gpu_counter_config) {
    set_has_gpu_counter_config();
  } else {
    clear_has_gpu_counter_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceConfig.gpu_counter_config)
}

// optional .perfetto.protos.PackagesListConfig packages_list_config = 109 [lazy = true];
inline bool DataSourceConfig::has_packages_list_config() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void DataSourceConfig::set_has_packages_list_config() {
  _has_bits_[0] |= 0x00004000u;
}
inline void DataSourceConfig::clear_has_packages_list_config() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void DataSourceConfig::clear_packages_list_config() {
  if (packages_list_config_ != NULL) packages_list_config_->::perfetto::protos::PackagesListConfig::Clear();
  clear_has_packages_list_config();
}
inline const ::perfetto::protos::PackagesListConfig& DataSourceConfig::packages_list_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.packages_list_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return packages_list_config_ != NULL ? *packages_list_config_ : *default_instance().packages_list_config_;
#else
  return packages_list_config_ != NULL ? *packages_list_config_ : *default_instance_->packages_list_config_;
#endif
}
inline ::perfetto::protos::PackagesListConfig* DataSourceConfig::mutable_packages_list_config() {
  set_has_packages_list_config();
  if (packages_list_config_ == NULL) {
    packages_list_config_ = new ::perfetto::protos::PackagesListConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceConfig.packages_list_config)
  return packages_list_config_;
}
inline ::perfetto::protos::PackagesListConfig* DataSourceConfig::release_packages_list_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceConfig.packages_list_config)
  clear_has_packages_list_config();
  ::perfetto::protos::PackagesListConfig* temp = packages_list_config_;
  packages_list_config_ = NULL;
  return temp;
}
inline void DataSourceConfig::set_allocated_packages_list_config(::perfetto::protos::PackagesListConfig* packages_list_config) {
  delete packages_list_config_;
  packages_list_config_ = packages_list_config;
  if (packages_list_config) {
    set_has_packages_list_config();
  } else {
    clear_has_packages_list_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceConfig.packages_list_config)
}

// optional .perfetto.protos.ChromeConfig chrome_config = 101;
inline bool DataSourceConfig::has_chrome_config() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void DataSourceConfig::set_has_chrome_config() {
  _has_bits_[0] |= 0x00008000u;
}
inline void DataSourceConfig::clear_has_chrome_config() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void DataSourceConfig::clear_chrome_config() {
  if (chrome_config_ != NULL) chrome_config_->::perfetto::protos::ChromeConfig::Clear();
  clear_has_chrome_config();
}
inline const ::perfetto::protos::ChromeConfig& DataSourceConfig::chrome_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.chrome_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return chrome_config_ != NULL ? *chrome_config_ : *default_instance().chrome_config_;
#else
  return chrome_config_ != NULL ? *chrome_config_ : *default_instance_->chrome_config_;
#endif
}
inline ::perfetto::protos::ChromeConfig* DataSourceConfig::mutable_chrome_config() {
  set_has_chrome_config();
  if (chrome_config_ == NULL) {
    chrome_config_ = new ::perfetto::protos::ChromeConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceConfig.chrome_config)
  return chrome_config_;
}
inline ::perfetto::protos::ChromeConfig* DataSourceConfig::release_chrome_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceConfig.chrome_config)
  clear_has_chrome_config();
  ::perfetto::protos::ChromeConfig* temp = chrome_config_;
  chrome_config_ = NULL;
  return temp;
}
inline void DataSourceConfig::set_allocated_chrome_config(::perfetto::protos::ChromeConfig* chrome_config) {
  delete chrome_config_;
  chrome_config_ = chrome_config;
  if (chrome_config) {
    set_has_chrome_config();
  } else {
    clear_has_chrome_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceConfig.chrome_config)
}

// optional string legacy_config = 1000;
inline bool DataSourceConfig::has_legacy_config() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void DataSourceConfig::set_has_legacy_config() {
  _has_bits_[0] |= 0x00010000u;
}
inline void DataSourceConfig::clear_has_legacy_config() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void DataSourceConfig::clear_legacy_config() {
  legacy_config_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_legacy_config();
}
inline const ::std::string& DataSourceConfig::legacy_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.legacy_config)
  return legacy_config_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DataSourceConfig::set_legacy_config(const ::std::string& value) {
  set_has_legacy_config();
  legacy_config_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.DataSourceConfig.legacy_config)
}
inline void DataSourceConfig::set_legacy_config(const char* value) {
  set_has_legacy_config();
  legacy_config_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.DataSourceConfig.legacy_config)
}
inline void DataSourceConfig::set_legacy_config(const char* value, size_t size) {
  set_has_legacy_config();
  legacy_config_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.DataSourceConfig.legacy_config)
}
inline ::std::string* DataSourceConfig::mutable_legacy_config() {
  set_has_legacy_config();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceConfig.legacy_config)
  return legacy_config_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DataSourceConfig::release_legacy_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceConfig.legacy_config)
  clear_has_legacy_config();
  return legacy_config_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DataSourceConfig::set_allocated_legacy_config(::std::string* legacy_config) {
  if (legacy_config != NULL) {
    set_has_legacy_config();
  } else {
    clear_has_legacy_config();
  }
  legacy_config_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), legacy_config);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceConfig.legacy_config)
}

// optional .perfetto.protos.TestConfig for_testing = 1001;
inline bool DataSourceConfig::has_for_testing() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void DataSourceConfig::set_has_for_testing() {
  _has_bits_[0] |= 0x00020000u;
}
inline void DataSourceConfig::clear_has_for_testing() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void DataSourceConfig::clear_for_testing() {
  if (for_testing_ != NULL) for_testing_->::perfetto::protos::TestConfig::Clear();
  clear_has_for_testing();
}
inline const ::perfetto::protos::TestConfig& DataSourceConfig::for_testing() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.for_testing)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return for_testing_ != NULL ? *for_testing_ : *default_instance().for_testing_;
#else
  return for_testing_ != NULL ? *for_testing_ : *default_instance_->for_testing_;
#endif
}
inline ::perfetto::protos::TestConfig* DataSourceConfig::mutable_for_testing() {
  set_has_for_testing();
  if (for_testing_ == NULL) {
    for_testing_ = new ::perfetto::protos::TestConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceConfig.for_testing)
  return for_testing_;
}
inline ::perfetto::protos::TestConfig* DataSourceConfig::release_for_testing() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceConfig.for_testing)
  clear_has_for_testing();
  ::perfetto::protos::TestConfig* temp = for_testing_;
  for_testing_ = NULL;
  return temp;
}
inline void DataSourceConfig::set_allocated_for_testing(::perfetto::protos::TestConfig* for_testing) {
  delete for_testing_;
  for_testing_ = for_testing;
  if (for_testing) {
    set_has_for_testing();
  } else {
    clear_has_for_testing();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceConfig.for_testing)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2fconfig_2fdata_5fsource_5fconfig_2eproto__INCLUDED
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/config/test_config.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/config/test_config.proto

#ifndef PROTOBUF_protos_2fperfetto_2fconfig_2ftest_5fconfig_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2fconfig_2ftest_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftest_5fconfig_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2ftest_5fconfig_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2ftest_5fconfig_2eproto();

class TestConfig;
class TestConfig_DummyFields;

// ===================================================================

class TestConfig_DummyFields : public ::google::protobuf::MessageLite {
 public:
  TestConfig_DummyFields();
  virtual ~TestConfig_DummyFields();

  TestConfig_DummyFields(const TestConfig_DummyFields& from);

  inline TestConfig_DummyFields& operator=(const TestConfig_DummyFields& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TestConfig_DummyFields& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TestConfig_DummyFields* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TestConfig_DummyFields* other);

  // implements Message ----------------------------------------------

  inline TestConfig_DummyFields* New() const { return New(NULL); }

  TestConfig_DummyFields* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TestConfig_DummyFields& from);
  void MergeFrom(const TestConfig_DummyFields& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TestConfig_DummyFields* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 field_uint32 = 1;
  bool has_field_uint32() const;
  void clear_field_uint32();
  static const int kFieldUint32FieldNumber = 1;
  ::google::protobuf::uint32 field_uint32() const;
  void set_field_uint32(::google::protobuf::uint32 value);

  // optional int32 field_int32 = 2;
  bool has_field_int32() const;
  void clear_field_int32();
  static const int kFieldInt32FieldNumber = 2;
  ::google::protobuf::int32 field_int32() const;
  void set_field_int32(::google::protobuf::int32 value);

  // optional uint64 field_uint64 = 3;
  bool has_field_uint64() const;
  void clear_field_uint64();
  static const int kFieldUint64FieldNumber = 3;
  ::google::protobuf::uint64 field_uint64() const;
  void set_field_uint64(::google::protobuf::uint64 value);

  // optional int64 field_int64 = 4;
  bool has_field_int64() const;
  void clear_field_int64();
  static const int kFieldInt64FieldNumber = 4;
  ::google::protobuf::int64 field_int64() const;
  void set_field_int64(::google::protobuf::int64 value);

  // optional fixed64 field_fixed64 = 5;
  bool has_field_fixed64() const;
  void clear_field_fixed64();
  static const int kFieldFixed64FieldNumber = 5;
  ::google::protobuf::uint64 field_fixed64() const;
  void set_field_fixed64(::google::protobuf::uint64 value);

  // optional sfixed64 field_sfixed64 = 6;
  bool has_field_sfixed64() const;
  void clear_field_sfixed64();
  static const int kFieldSfixed64FieldNumber = 6;
  ::google::protobuf::int64 field_sfixed64() const;
  void set_field_sfixed64(::google::protobuf::int64 value);

  // optional fixed32 field_fixed32 = 7;
  bool has_field_fixed32() const;
  void clear_field_fixed32();
  static const int kFieldFixed32FieldNumber = 7;
  ::google::protobuf::uint32 field_fixed32() const;
  void set_field_fixed32(::google::protobuf::uint32 value);

  // optional sfixed32 field_sfixed32 = 8;
  bool has_field_sfixed32() const;
  void clear_field_sfixed32();
  static const int kFieldSfixed32FieldNumber = 8;
  ::google::protobuf::int32 field_sfixed32() const;
  void set_field_sfixed32(::google::protobuf::int32 value);

  // optional double field_double = 9;
  bool has_field_double() const;
  void clear_field_double();
  static const int kFieldDoubleFieldNumber = 9;
  double field_double() const;
  void set_field_double(double value);

  // optional float field_float = 10;
  bool has_field_float() const;
  void clear_field_float();
  static const int kFieldFloatFieldNumber = 10;
  float field_float() const;
  void set_field_float(float value);

  // optional sint64 field_sint64 = 11;
  bool has_field_sint64() const;
  void clear_field_sint64();
  static const int kFieldSint64FieldNumber = 11;
  ::google::protobuf::int64 field_sint64() const;
  void set_field_sint64(::google::protobuf::int64 value);

  // optional sint32 field_sint32 = 12;
  bool has_field_sint32() const;
  void clear_field_sint32();
  static const int kFieldSint32FieldNumber = 12;
  ::google::protobuf::int32 field_sint32() const;
  void set_field_sint32(::google::protobuf::int32 value);

  // optional string field_string = 13;
  bool has_field_string() const;
  void clear_field_string();
  static const int kFieldStringFieldNumber = 13;
  const ::std::string& field_string() const;
  void set_field_string(const ::std::string& value);
  void set_field_string(const char* value);
  void set_field_string(const char* value, size_t size);
  ::std::string* mutable_field_string();
  ::std::string* release_field_string();
  void set_allocated_field_string(::std::string* field_string);

  // optional bytes field_bytes = 14;
  bool has_field_bytes() const;
  void clear_field_bytes();
  static const int kFieldBytesFieldNumber = 14;
  const ::std::string& field_bytes() const;
  void set_field_bytes(const ::std::string& value);
  void set_field_bytes(const char* value);
  void set_field_bytes(const void* value, size_t size);
  ::std::string* mutable_field_bytes();
  ::std::string* release_field_bytes();
  void set_allocated_field_bytes(::std::string* field_bytes);

  // @@protoc_insertion_point(class_scope:perfetto.protos.TestConfig.DummyFields)
 private:
  inline void set_has_field_uint32();
  inline void clear_has_field_uint32();
  inline void set_has_field_int32();
  inline void clear_has_field_int32();
  inline void set_has_field_uint64();
  inline void clear_has_field_uint64();
  inline void set_has_field_int64();
  inline void clear_has_field_int64();
  inline void set_has_field_fixed64();
  inline void clear_has_field_fixed64();
  inline void set_has_field_sfixed64();
  inline void clear_has_field_sfixed64();
  inline void set_has_field_fixed32();
  inline void clear_has_field_fixed32();
  inline void set_has_field_sfixed32();
  inline void clear_has_field_sfixed32();
  inline void set_has_field_double();
  inline void clear_has_field_double();
  inline void set_has_field_float();
  inline void clear_has_field_float();
  inline void set_has_field_sint64();
  inline void clear_has_field_sint64();
  inline void set_has_field_sint32();
  inline void clear_has_field_sint32();
  inline void set_has_field_string();
  inline void clear_has_field_string();
  inline void set_has_field_bytes();
  inline void clear_has_field_bytes();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 field_uint32_;
  ::google::protobuf::int32 field_int32_;
  ::google::protobuf::uint64 field_uint64_;
  ::google::protobuf::int64 field_int64_;
  ::google::protobuf::uint64 field_fixed64_;
  ::google::protobuf::int64 field_sfixed64_;
  ::google::protobuf::uint32 field_fixed32_;
  ::google::protobuf::int32 field_sfixed32_;
  double field_double_;
  ::google::protobuf::int64 field_sint64_;
  float field_float_;
  ::google::protobuf::int32 field_sint32_;
  ::google::protobuf::internal::ArenaStringPtr field_string_;
  ::google::protobuf::internal::ArenaStringPtr field_bytes_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftest_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftest_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2ftest_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2ftest_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static TestConfig_DummyFields* default_instance_;
};
// -------------------------------------------------------------------

class TestConfig : public ::google::protobuf::MessageLite {
 public:
  TestConfig();
  virtual ~TestConfig();

  TestConfig(const TestConfig& from);

  inline TestConfig& operator=(const TestConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TestConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TestConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TestConfig* other);

  // implements Message ----------------------------------------------

  inline TestConfig* New() const { return New(NULL); }

  TestConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TestConfig& from);
  void MergeFrom(const TestConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TestConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef TestConfig_DummyFields DummyFields;

  // accessors -------------------------------------------------------

  // optional uint32 message_count = 1;
  bool has_message_count() const;
  void clear_message_count();
  static const int kMessageCountFieldNumber = 1;
  ::google::protobuf::uint32 message_count() const;
  void set_message_count(::google::protobuf::uint32 value);

  // optional uint32 max_messages_per_second = 2;
  bool has_max_messages_per_second() const;
  void clear_max_messages_per_second();
  static const int kMaxMessagesPerSecondFieldNumber = 2;
  ::google::protobuf::uint32 max_messages_per_second() const;
  void set_max_messages_per_second(::google::protobuf::uint32 value);

  // optional uint32 seed = 3;
  bool has_seed() const;
  void clear_seed();
  static const int kSeedFieldNumber = 3;
  ::google::protobuf::uint32 seed() const;
  void set_seed(::google::protobuf::uint32 value);

  // optional uint32 message_size = 4;
  bool has_message_size() const;
  void clear_message_size();
  static const int kMessageSizeFieldNumber = 4;
  ::google::protobuf::uint32 message_size() const;
  void set_message_size(::google::protobuf::uint32 value);

  // optional bool send_batch_on_register = 5;
  bool has_send_batch_on_register() const;
  void clear_send_batch_on_register();
  static const int kSendBatchOnRegisterFieldNumber = 5;
  bool send_batch_on_register() const;
  void set_send_batch_on_register(bool value);

  // optional .perfetto.protos.TestConfig.DummyFields dummy_fields = 6;
  bool has_dummy_fields() const;
  void clear_dummy_fields();
  static const int kDummyFieldsFieldNumber = 6;
  const ::perfetto::protos::TestConfig_DummyFields& dummy_fields() const;
  ::perfetto::protos::TestConfig_DummyFields* mutable_dummy_fields();
  ::perfetto::protos::TestConfig_DummyFields* release_dummy_fields();
  void set_allocated_dummy_fields(::perfetto::protos::TestConfig_DummyFields* dummy_fields);

  // @@protoc_insertion_point(class_scope:perfetto.protos.TestConfig)
 private:
  inline void set_has_message_count();
  inline void clear_has_message_count();
  inline void set_has_max_messages_per_second();
  inline void clear_has_max_messages_per_second();
  inline void set_has_seed();
  inline void clear_has_seed();
  inline void set_has_message_size();
  inline void clear_has_message_size();
  inline void set_has_send_batch_on_register();
  inline void clear_has_send_batch_on_register();
  inline void set_has_dummy_fields();
  inline void clear_has_dummy_fields();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 message_count_;
  ::google::protobuf::uint32 max_messages_per_second_;
  ::google::protobuf::uint32 seed_;
  ::google::protobuf::uint32 message_size_;
  ::perfetto::protos::TestConfig_DummyFields* dummy_fields_;
  bool send_batch_on_register_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftest_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftest_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2ftest_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2ftest_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static TestConfig* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// TestConfig_DummyFields

// optional uint32 field_uint32 = 1;
inline bool TestConfig_DummyFields::has_field_uint32() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TestConfig_DummyFields::set_has_field_uint32() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TestConfig_DummyFields::clear_has_field_uint32() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TestConfig_DummyFields::clear_field_uint32() {
  field_uint32_ = 0u;
  clear_has_field_uint32();
}
inline ::google::protobuf::uint32 TestConfig_DummyFields::field_uint32() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_uint32)
  return field_uint32_;
}
inline void TestConfig_DummyFields::set_field_uint32(::google::protobuf::uint32 value) {
  set_has_field_uint32();
  field_uint32_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_uint32)
}

// optional int32 field_int32 = 2;
inline bool TestConfig_DummyFields::has_field_int32() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TestConfig_DummyFields::set_has_field_int32() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TestConfig_DummyFields::clear_has_field_int32() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TestConfig_DummyFields::clear_field_int32() {
  field_int32_ = 0;
  clear_has_field_int32();
}
inline ::google::protobuf::int32 TestConfig_DummyFields::field_int32() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_int32)
  return field_int32_;
}
inline void TestConfig_DummyFields::set_field_int32(::google::protobuf::int32 value) {
  set_has_field_int32();
  field_int32_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_int32)
}

// optional uint64 field_uint64 = 3;
inline bool TestConfig_DummyFields::has_field_uint64() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TestConfig_DummyFields::set_has_field_uint64() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TestConfig_DummyFields::clear_has_field_uint64() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TestConfig_DummyFields::clear_field_uint64() {
  field_uint64_ = GOOGLE_ULONGLONG(0);
  clear_has_field_uint64();
}
inline ::google::protobuf::uint64 TestConfig_DummyFields::field_uint64() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_uint64)
  return field_uint64_;
}
inline void TestConfig_DummyFields::set_field_uint64(::google::protobuf::uint64 value) {
  set_has_field_uint64();
  field_uint64_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_uint64)
}

// optional int64 field_int64 = 4;
inline bool TestConfig_DummyFields::has_field_int64() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TestConfig_DummyFields::set_has_field_int64() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TestConfig_DummyFields::clear_has_field_int64() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TestConfig_DummyFields::clear_field_int64() {
  field_int64_ = GOOGLE_LONGLONG(0);
  clear_has_field_int64();
}
inline ::google::protobuf::int64 TestConfig_DummyFields::field_int64() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_int64)
  return field_int64_;
}
inline void TestConfig_DummyFields::set_field_int64(::google::protobuf::int64 value) {
  set_has_field_int64();
  field_int64_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_int64)
}

// optional fixed64 field_fixed64 = 5;
inline bool TestConfig_DummyFields::has_field_fixed64() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TestConfig_DummyFields::set_has_field_fixed64() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TestConfig_DummyFields::clear_has_field_fixed64() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TestConfig_DummyFields::clear_field_fixed64() {
  field_fixed64_ = GOOGLE_ULONGLONG(0);
  clear_has_field_fixed64();
}
inline ::google::protobuf::uint64 TestConfig_DummyFields::field_fixed64() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_fixed64)
  return field_fixed64_;
}
inline void TestConfig_DummyFields::set_field_fixed64(::google::protobuf::uint64 value) {
  set_has_field_fixed64();
  field_fixed64_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_fixed64)
}

// optional sfixed64 field_sfixed64 = 6;
inline bool TestConfig_DummyFields::has_field_sfixed64() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TestConfig_DummyFields::set_has_field_sfixed64() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TestConfig_DummyFields::clear_has_field_sfixed64() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TestConfig_DummyFields::clear_field_sfixed64() {
  field_sfixed64_ = GOOGLE_LONGLONG(0);
  clear_has_field_sfixed64();
}
inline ::google::protobuf::int64 TestConfig_DummyFields::field_sfixed64() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_sfixed64)
  return field_sfixed64_;
}
inline void TestConfig_DummyFields::set_field_sfixed64(::google::protobuf::int64 value) {
  set_has_field_sfixed64();
  field_sfixed64_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_sfixed64)
}

// optional fixed32 field_fixed32 = 7;
inline bool TestConfig_DummyFields::has_field_fixed32() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TestConfig_DummyFields::set_has_field_fixed32() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TestConfig_DummyFields::clear_has_field_fixed32() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TestConfig_DummyFields::clear_field_fixed32() {
  field_fixed32_ = 0u;
  clear_has_field_fixed32();
}
inline ::google::protobuf::uint32 TestConfig_DummyFields::field_fixed32() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_fixed32)
  return field_fixed32_;
}
inline void TestConfig_DummyFields::set_field_fixed32(::google::protobuf::uint32 value) {
  set_has_field_fixed32();
  field_fixed32_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_fixed32)
}

// optional sfixed32 field_sfixed32 = 8;
inline bool TestConfig_DummyFields::has_field_sfixed32() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TestConfig_DummyFields::set_has_field_sfixed32() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TestConfig_DummyFields::clear_has_field_sfixed32() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TestConfig_DummyFields::clear_field_sfixed32() {
  field_sfixed32_ = 0;
  clear_has_field_sfixed32();
}
inline ::google::protobuf::int32 TestConfig_DummyFields::field_sfixed32() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_sfixed32)
  return field_sfixed32_;
}
inline void TestConfig_DummyFields::set_field_sfixed32(::google::protobuf::int32 value) {
  set_has_field_sfixed32();
  field_sfixed32_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_sfixed32)
}

// optional double field_double = 9;
inline bool TestConfig_DummyFields::has_field_double() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TestConfig_DummyFields::set_has_field_double() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TestConfig_DummyFields::clear_has_field_double() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TestConfig_DummyFields::clear_field_double() {
  field_double_ = 0;
  clear_has_field_double();
}
inline double TestConfig_DummyFields::field_double() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_double)
  return field_double_;
}
inline void TestConfig_DummyFields::set_field_double(double value) {
  set_has_field_double();
  field_double_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_double)
}

// optional float field_float = 10;
inline bool TestConfig_DummyFields::has_field_float() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TestConfig_DummyFields::set_has_field_float() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TestConfig_DummyFields::clear_has_field_float() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TestConfig_DummyFields::clear_field_float() {
  field_float_ = 0;
  clear_has_field_float();
}
inline float TestConfig_DummyFields::field_float() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_float)
  return field_float_;
}
inline void TestConfig_DummyFields::set_field_float(float value) {
  set_has_field_float();
  field_float_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_float)
}

// optional sint64 field_sint64 = 11;
inline bool TestConfig_DummyFields::has_field_sint64() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TestConfig_DummyFields::set_has_field_sint64() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TestConfig_DummyFields::clear_has_field_sint64() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TestConfig_DummyFields::clear_field_sint64() {
  field_sint64_ = GOOGLE_LONGLONG(0);
  clear_has_field_sint64();
}
inline ::google::protobuf::int64 TestConfig_DummyFields::field_sint64() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_sint64)
  return field_sint64_;
}
inline void TestConfig_DummyFields::set_field_sint64(::google::protobuf::int64 value) {
  set_has_field_sint64();
  field_sint64_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_sint64)
}

// optional sint32 field_sint32 = 12;
inline bool TestConfig_DummyFields::has_field_sint32() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TestConfig_DummyFields::set_has_field_sint32() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TestConfig_DummyFields::clear_has_field_sint32() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TestConfig_DummyFields::clear_field_sint32() {
  field_sint32_ = 0;
  clear_has_field_sint32();
}
inline ::google::protobuf::int32 TestConfig_DummyFields::field_sint32() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_sint32)
  return field_sint32_;
}
inline void TestConfig_DummyFields::set_field_sint32(::google::protobuf::int32 value) {
  set_has_field_sint32();
  field_sint32_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_sint32)
}

// optional string field_string = 13;
inline bool TestConfig_DummyFields::has_field_string() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TestConfig_DummyFields::set_has_field_string() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TestConfig_DummyFields::clear_has_field_string() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TestConfig_DummyFields::clear_field_string() {
  field_string_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_field_string();
}
inline const ::std::string& TestConfig_DummyFields::field_string() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_string)
  return field_string_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TestConfig_DummyFields::set_field_string(const ::std::string& value) {
  set_has_field_string();
  field_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_string)
}
inline void TestConfig_DummyFields::set_field_string(const char* value) {
  set_has_field_string();
  field_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.TestConfig.DummyFields.field_string)
}
inline void TestConfig_DummyFields::set_field_string(const char* value, size_t size) {
  set_has_field_string();
  field_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.TestConfig.DummyFields.field_string)
}
inline ::std::string* TestConfig_DummyFields::mutable_field_string() {
  set_has_field_string();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TestConfig.DummyFields.field_string)
  return field_string_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TestConfig_DummyFields::release_field_string() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TestConfig.DummyFields.field_string)
  clear_has_field_string();
  return field_string_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TestConfig_DummyFields::set_allocated_field_string(::std::string* field_string) {
  if (field_string != NULL) {
    set_has_field_string();
  } else {
    clear_has_field_string();
  }
  field_string_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), field_string);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TestConfig.DummyFields.field_string)
}

// optional bytes field_bytes = 14;
inline bool TestConfig_DummyFields::has_field_bytes() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TestConfig_DummyFields::set_has_field_bytes() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TestConfig_DummyFields::clear_has_field_bytes() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TestConfig_DummyFields::clear_field_bytes() {
  field_bytes_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_field_bytes();
}
inline const ::std::string& TestConfig_DummyFields::field_bytes() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_bytes)
  return field_bytes_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TestConfig_DummyFields::set_field_bytes(const ::std::string& value) {
  set_has_field_bytes();
  field_bytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_bytes)
}
inline void TestConfig_DummyFields::set_field_bytes(const char* value) {
  set_has_field_bytes();
  field_bytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.TestConfig.DummyFields.field_bytes)
}
inline void TestConfig_DummyFields::set_field_bytes(const void* value, size_t size) {
  set_has_field_bytes();
  field_bytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.TestConfig.DummyFields.field_bytes)
}
inline ::std::string* TestConfig_DummyFields::mutable_field_bytes() {
  set_has_field_bytes();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TestConfig.DummyFields.field_bytes)
  return field_bytes_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TestConfig_DummyFields::release_field_bytes() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TestConfig.DummyFields.field_bytes)
  clear_has_field_bytes();
  return field_bytes_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TestConfig_DummyFields::set_allocated_field_bytes(::std::string* field_bytes) {
  if (field_bytes != NULL) {
    set_has_field_bytes();
  } else {
    clear_has_field_bytes();
  }
  field_bytes_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), field_bytes);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TestConfig.DummyFields.field_bytes)
}

// -------------------------------------------------------------------

// TestConfig

// optional uint32 message_count = 1;
inline bool TestConfig::has_message_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TestConfig::set_has_message_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TestConfig::clear_has_message_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TestConfig::clear_message_count() {
  message_count_ = 0u;
  clear_has_message_count();
}
inline ::google::protobuf::uint32 TestConfig::message_count() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.message_count)
  return message_count_;
}
inline void TestConfig::set_message_count(::google::protobuf::uint32 value) {
  set_has_message_count();
  message_count_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.message_count)
}

// optional uint32 max_messages_per_second = 2;
inline bool TestConfig::has_max_messages_per_second() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TestConfig::set_has_max_messages_per_second() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TestConfig::clear_has_max_messages_per_second() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TestConfig::clear_max_messages_per_second() {
  max_messages_per_second_ = 0u;
  clear_has_max_messages_per_second();
}
inline ::google::protobuf::uint32 TestConfig::max_messages_per_second() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.max_messages_per_second)
  return max_messages_per_second_;
}
inline void TestConfig::set_max_messages_per_second(::google::protobuf::uint32 value) {
  set_has_max_messages_per_second();
  max_messages_per_second_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.max_messages_per_second)
}

// optional uint32 seed = 3;
inline bool TestConfig::has_seed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TestConfig::set_has_seed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TestConfig::clear_has_seed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TestConfig::clear_seed() {
  seed_ = 0u;
  clear_has_seed();
}
inline ::google::protobuf::uint32 TestConfig::seed() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.seed)
  return seed_;
}
inline void TestConfig::set_seed(::google::protobuf::uint32 value) {
  set_has_seed();
  seed_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.seed)
}

// optional uint32 message_size = 4;
inline bool TestConfig::has_message_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TestConfig::set_has_message_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TestConfig::clear_has_message_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TestConfig::clear_message_size() {
  message_size_ = 0u;
  clear_has_message_size();
}
inline ::google::protobuf::uint32 TestConfig::message_size() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.message_size)
  return message_size_;
}
inline void TestConfig::set_message_size(::google::protobuf::uint32 value) {
  set_has_message_size();
  message_size_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.message_size)
}

// optional bool send_batch_on_register = 5;
inline bool TestConfig::has_send_batch_on_register() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TestConfig::set_has_send_batch_on_register() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TestConfig::clear_has_send_batch_on_register() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TestConfig::clear_send_batch_on_register() {
  send_batch_on_register_ = false;
  clear_has_send_batch_on_register();
}
inline bool TestConfig::send_batch_on_register() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.send_batch_on_register)
  return send_batch_on_register_;
}
inline void TestConfig::set_send_batch_on_register(bool value) {
  set_has_send_batch_on_register();
  send_batch_on_register_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.send_batch_on_register)
}

// optional .perfetto.protos.TestConfig.DummyFields dummy_fields = 6;
inline bool TestConfig::has_dummy_fields() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TestConfig::set_has_dummy_fields() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TestConfig::clear_has_dummy_fields() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TestConfig::clear_dummy_fields() {
  if (dummy_fields_ != NULL) dummy_fields_->::perfetto::protos::TestConfig_DummyFields::Clear();
  clear_has_dummy_fields();
}
inline const ::perfetto::protos::TestConfig_DummyFields& TestConfig::dummy_fields() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.dummy_fields)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return dummy_fields_ != NULL ? *dummy_fields_ : *default_instance().dummy_fields_;
#else
  return dummy_fields_ != NULL ? *dummy_fields_ : *default_instance_->dummy_fields_;
#endif
}
inline ::perfetto::protos::TestConfig_DummyFields* TestConfig::mutable_dummy_fields() {
  set_has_dummy_fields();
  if (dummy_fields_ == NULL) {
    dummy_fields_ = new ::perfetto::protos::TestConfig_DummyFields;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TestConfig.dummy_fields)
  return dummy_fields_;
}
inline ::perfetto::protos::TestConfig_DummyFields* TestConfig::release_dummy_fields() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TestConfig.dummy_fields)
  clear_has_dummy_fields();
  ::perfetto::protos::TestConfig_DummyFields* temp = dummy_fields_;
  dummy_fields_ = NULL;
  return temp;
}
inline void TestConfig::set_allocated_dummy_fields(::perfetto::protos::TestConfig_DummyFields* dummy_fields) {
  delete dummy_fields_;
  dummy_fields_ = dummy_fields;
  if (dummy_fields) {
    set_has_dummy_fields();
  } else {
    clear_has_dummy_fields();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TestConfig.dummy_fields)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2fconfig_2ftest_5fconfig_2eproto__INCLUDED
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/config/trace_config.pb.h
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/config/data_source_config.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/config/data_source_config.proto

#ifndef PROTOBUF_protos_2fperfetto_2fconfig_2fdata_5fsource_5fconfig_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2fconfig_2fdata_5fsource_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// gen_amalgamated expanded: #include "protos/perfetto/config/android/android_log_config.pb.h"
// gen_amalgamated expanded: #include "protos/perfetto/config/android/packages_list_config.pb.h"
// gen_amalgamated expanded: #include "protos/perfetto/config/chrome/chrome_config.pb.h"
// gen_amalgamated expanded: #include "protos/perfetto/config/ftrace/ftrace_config.pb.h"
// gen_amalgamated expanded: #include "protos/perfetto/config/gpu/gpu_counter_config.pb.h"
// gen_amalgamated expanded: #include "protos/perfetto/config/inode_file/inode_file_config.pb.h"
// gen_amalgamated expanded: #include "protos/perfetto/config/power/android_power_config.pb.h"
// gen_amalgamated expanded: #include "protos/perfetto/config/process_stats/process_stats_config.pb.h"
// gen_amalgamated expanded: #include "protos/perfetto/config/profiling/heapprofd_config.pb.h"
// gen_amalgamated expanded: #include "protos/perfetto/config/sys_stats/sys_stats_config.pb.h"
// gen_amalgamated expanded: #include "protos/perfetto/config/test_config.pb.h"
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2fconfig_2fdata_5fsource_5fconfig_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2fdata_5fsource_5fconfig_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2fdata_5fsource_5fconfig_2eproto();

class DataSourceConfig;

// ===================================================================

class DataSourceConfig : public ::google::protobuf::MessageLite {
 public:
  DataSourceConfig();
  virtual ~DataSourceConfig();

  DataSourceConfig(const DataSourceConfig& from);

  inline DataSourceConfig& operator=(const DataSourceConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const DataSourceConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DataSourceConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DataSourceConfig* other);

  // implements Message ----------------------------------------------

  inline DataSourceConfig* New() const { return New(NULL); }

  DataSourceConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DataSourceConfig& from);
  void MergeFrom(const DataSourceConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DataSourceConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional uint32 target_buffer = 2;
  bool has_target_buffer() const;
  void clear_target_buffer();
  static const int kTargetBufferFieldNumber = 2;
  ::google::protobuf::uint32 target_buffer() const;
  void set_target_buffer(::google::protobuf::uint32 value);

  // optional uint32 trace_duration_ms = 3;
  bool has_trace_duration_ms() const;
  void clear_trace_duration_ms();
  static const int kTraceDurationMsFieldNumber = 3;
  ::google::protobuf::uint32 trace_duration_ms() const;
  void set_trace_duration_ms(::google::protobuf::uint32 value);

  // optional uint32 stop_timeout_ms = 7;
  bool has_stop_timeout_ms() const;
  void clear_stop_timeout_ms();
  static const int kStopTimeoutMsFieldNumber = 7;
  ::google::protobuf::uint32 stop_timeout_ms() const;
  void set_stop_timeout_ms(::google::protobuf::uint32 value);

  // optional bool enable_extra_guardrails = 6;
  bool has_enable_extra_guardrails() const;
  void clear_enable_extra_guardrails();
  static const int kEnableExtraGuardrailsFieldNumber = 6;
  bool enable_extra_guardrails() const;
  void set_enable_extra_guardrails(bool value);

  // optional uint64 tracing_session_id = 4;
  bool has_tracing_session_id() const;
  void clear_tracing_session_id();
  static const int kTracingSessionIdFieldNumber = 4;
  ::google::protobuf::uint64 tracing_session_id() const;
  void set_tracing_session_id(::google::protobuf::uint64 value);

  // optional .perfetto.protos.FtraceConfig ftrace_config = 100 [lazy = true];
  bool has_ftrace_config() const;
  void clear_ftrace_config();
  static const int kFtraceConfigFieldNumber = 100;
  const ::perfetto::protos::FtraceConfig& ftrace_config() const;
  ::perfetto::protos::FtraceConfig* mutable_ftrace_config();
  ::perfetto::protos::FtraceConfig* release_ftrace_config();
  void set_allocated_ftrace_config(::perfetto::protos::FtraceConfig* ftrace_config);

  // optional .perfetto.protos.InodeFileConfig inode_file_config = 102 [lazy = true];
  bool has_inode_file_config() const;
  void clear_inode_file_config();
  static const int kInodeFileConfigFieldNumber = 102;
  const ::perfetto::protos::InodeFileConfig& inode_file_config() const;
  ::perfetto::protos::InodeFileConfig* mutable_inode_file_config();
  ::perfetto::protos::InodeFileConfig* release_inode_file_config();
  void set_allocated_inode_file_config(::perfetto::protos::InodeFileConfig* inode_file_config);

  // optional .perfetto.protos.ProcessStatsConfig process_stats_config = 103 [lazy = true];
  bool has_process_stats_config() const;
  void clear_process_stats_config();
  static const int kProcessStatsConfigFieldNumber = 103;
  const ::perfetto::protos::ProcessStatsConfig& process_stats_config() const;
  ::perfetto::protos::ProcessStatsConfig* mutable_process_stats_config();
  ::perfetto::protos::ProcessStatsConfig* release_process_stats_config();
  void set_allocated_process_stats_config(::perfetto::protos::ProcessStatsConfig* process_stats_config);

  // optional .perfetto.protos.SysStatsConfig sys_stats_config = 104 [lazy = true];
  bool has_sys_stats_config() const;
  void clear_sys_stats_config();
  static const int kSysStatsConfigFieldNumber = 104;
  const ::perfetto::protos::SysStatsConfig& sys_stats_config() const;
  ::perfetto::protos::SysStatsConfig* mutable_sys_stats_config();
  ::perfetto::protos::SysStatsConfig* release_sys_stats_config();
  void set_allocated_sys_stats_config(::perfetto::protos::SysStatsConfig* sys_stats_config);

  // optional .perfetto.protos.HeapprofdConfig heapprofd_config = 105 [lazy = true];
  bool has_heapprofd_config() const;
  void clear_heapprofd_config();
  static const int kHeapprofdConfigFieldNumber = 105;
  const ::perfetto::protos::HeapprofdConfig& heapprofd_config() const;
  ::perfetto::protos::HeapprofdConfig* mutable_heapprofd_config();
  ::perfetto::protos::HeapprofdConfig* release_heapprofd_config();
  void set_allocated_heapprofd_config(::perfetto::protos::HeapprofdConfig* heapprofd_config);

  // optional .perfetto.protos.AndroidPowerConfig android_power_config = 106 [lazy = true];
  bool has_android_power_config() const;
  void clear_android_power_config();
  static const int kAndroidPowerConfigFieldNumber = 106;
  const ::perfetto::protos::AndroidPowerConfig& android_power_config() const;
  ::perfetto::protos::AndroidPowerConfig* mutable_android_power_config();
  ::perfetto::protos::AndroidPowerConfig* release_android_power_config();
  void set_allocated_android_power_config(::perfetto::protos::AndroidPowerConfig* android_power_config);

  // optional .perfetto.protos.AndroidLogConfig android_log_config = 107 [lazy = true];
  bool has_android_log_config() const;
  void clear_android_log_config();
  static const int kAndroidLogConfigFieldNumber = 107;
  const ::perfetto::protos::AndroidLogConfig& android_log_config() const;
  ::perfetto::protos::AndroidLogConfig* mutable_android_log_config();
  ::perfetto::protos::AndroidLogConfig* release_android_log_config();
  void set_allocated_android_log_config(::perfetto::protos::AndroidLogConfig* android_log_config);

  // optional .perfetto.protos.GpuCounterConfig gpu_counter_config = 108 [lazy = true];
  bool has_gpu_counter_config() const;
  void clear_gpu_counter_config();
  static const int kGpuCounterConfigFieldNumber = 108;
  const ::perfetto::protos::GpuCounterConfig& gpu_counter_config() const;
  ::perfetto::protos::GpuCounterConfig* mutable_gpu_counter_config();
  ::perfetto::protos::GpuCounterConfig* release_gpu_counter_config();
  void set_allocated_gpu_counter_config(::perfetto::protos::GpuCounterConfig* gpu_counter_config);

  // optional .perfetto.protos.PackagesListConfig packages_list_config = 109 [lazy = true];
  bool has_packages_list_config() const;
  void clear_packages_list_config();
  static const int kPackagesListConfigFieldNumber = 109;
  const ::perfetto::protos::PackagesListConfig& packages_list_config() const;
  ::perfetto::protos::PackagesListConfig* mutable_packages_list_config();
  ::perfetto::protos::PackagesListConfig* release_packages_list_config();
  void set_allocated_packages_list_config(::perfetto::protos::PackagesListConfig* packages_list_config);

  // optional .perfetto.protos.ChromeConfig chrome_config = 101;
  bool has_chrome_config() const;
  void clear_chrome_config();
  static const int kChromeConfigFieldNumber = 101;
  const ::perfetto::protos::ChromeConfig& chrome_config() const;
  ::perfetto::protos::ChromeConfig* mutable_chrome_config();
  ::perfetto::protos::ChromeConfig* release_chrome_config();
  void set_allocated_chrome_config(::perfetto::protos::ChromeConfig* chrome_config);

  // optional string legacy_config = 1000;
  bool has_legacy_config() const;
  void clear_legacy_config();
  static const int kLegacyConfigFieldNumber = 1000;
  const ::std::string& legacy_config() const;
  void set_legacy_config(const ::std::string& value);
  void set_legacy_config(const char* value);
  void set_legacy_config(const char* value, size_t size);
  ::std::string* mutable_legacy_config();
  ::std::string* release_legacy_config();
  void set_allocated_legacy_config(::std::string* legacy_config);

  // optional .perfetto.protos.TestConfig for_testing = 1001;
  bool has_for_testing() const;
  void clear_for_testing();
  static const int kForTestingFieldNumber = 1001;
  const ::perfetto::protos::TestConfig& for_testing() const;
  ::perfetto::protos::TestConfig* mutable_for_testing();
  ::perfetto::protos::TestConfig* release_for_testing();
  void set_allocated_for_testing(::perfetto::protos::TestConfig* for_testing);

  // @@protoc_insertion_point(class_scope:perfetto.protos.DataSourceConfig)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_target_buffer();
  inline void clear_has_target_buffer();
  inline void set_has_trace_duration_ms();
  inline void clear_has_trace_duration_ms();
  inline void set_has_stop_timeout_ms();
  inline void clear_has_stop_timeout_ms();
  inline void set_has_enable_extra_guardrails();
  inline void clear_has_enable_extra_guardrails();
  inline void set_has_tracing_session_id();
  inline void clear_has_tracing_session_id();
  inline void set_has_ftrace_config();
  inline void clear_has_ftrace_config();
  inline void set_has_inode_file_config();
  inline void clear_has_inode_file_config();
  inline void set_has_process_stats_config();
  inline void clear_has_process_stats_config();
  inline void set_has_sys_stats_config();
  inline void clear_has_sys_stats_config();
  inline void set_has_heapprofd_config();
  inline void clear_has_heapprofd_config();
  inline void set_has_android_power_config();
  inline void clear_has_android_power_config();
  inline void set_has_android_log_config();
  inline void clear_has_android_log_config();
  inline void set_has_gpu_counter_config();
  inline void clear_has_gpu_counter_config();
  inline void set_has_packages_list_config();
  inline void clear_has_packages_list_config();
  inline void set_has_chrome_config();
  inline void clear_has_chrome_config();
  inline void set_has_legacy_config();
  inline void clear_has_legacy_config();
  inline void set_has_for_testing();
  inline void clear_has_for_testing();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint32 target_buffer_;
  ::google::protobuf::uint32 trace_duration_ms_;
  ::google::protobuf::uint32 stop_timeout_ms_;
  bool enable_extra_guardrails_;
  ::google::protobuf::uint64 tracing_session_id_;
  ::perfetto::protos::FtraceConfig* ftrace_config_;
  ::perfetto::protos::InodeFileConfig* inode_file_config_;
  ::perfetto::protos::ProcessStatsConfig* process_stats_config_;
  ::perfetto::protos::SysStatsConfig* sys_stats_config_;
  ::perfetto::protos::HeapprofdConfig* heapprofd_config_;
  ::perfetto::protos::AndroidPowerConfig* android_power_config_;
  ::perfetto::protos::AndroidLogConfig* android_log_config_;
  ::perfetto::protos::GpuCounterConfig* gpu_counter_config_;
  ::perfetto::protos::PackagesListConfig* packages_list_config_;
  ::perfetto::protos::ChromeConfig* chrome_config_;
  ::google::protobuf::internal::ArenaStringPtr legacy_config_;
  ::perfetto::protos::TestConfig* for_testing_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2fdata_5fsource_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2fdata_5fsource_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2fdata_5fsource_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2fdata_5fsource_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static DataSourceConfig* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// DataSourceConfig

// optional string name = 1;
inline bool DataSourceConfig::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataSourceConfig::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataSourceConfig::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataSourceConfig::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& DataSourceConfig::name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DataSourceConfig::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.DataSourceConfig.name)
}
inline void DataSourceConfig::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.DataSourceConfig.name)
}
inline void DataSourceConfig::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.DataSourceConfig.name)
}
inline ::std::string* DataSourceConfig::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceConfig.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DataSourceConfig::release_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceConfig.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DataSourceConfig::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceConfig.name)
}

// optional uint32 target_buffer = 2;
inline bool DataSourceConfig::has_target_buffer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataSourceConfig::set_has_target_buffer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataSourceConfig::clear_has_target_buffer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataSourceConfig::clear_target_buffer() {
  target_buffer_ = 0u;
  clear_has_target_buffer();
}
inline ::google::protobuf::uint32 DataSourceConfig::target_buffer() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.target_buffer)
  return target_buffer_;
}
inline void DataSourceConfig::set_target_buffer(::google::protobuf::uint32 value) {
  set_has_target_buffer();
  target_buffer_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.DataSourceConfig.target_buffer)
}

// optional uint32 trace_duration_ms = 3;
inline bool DataSourceConfig::has_trace_duration_ms() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DataSourceConfig::set_has_trace_duration_ms() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DataSourceConfig::clear_has_trace_duration_ms() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DataSourceConfig::clear_trace_duration_ms() {
  trace_duration_ms_ = 0u;
  clear_has_trace_duration_ms();
}
inline ::google::protobuf::uint32 DataSourceConfig::trace_duration_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.trace_duration_ms)
  return trace_duration_ms_;
}
inline void DataSourceConfig::set_trace_duration_ms(::google::protobuf::uint32 value) {
  set_has_trace_duration_ms();
  trace_duration_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.DataSourceConfig.trace_duration_ms)
}

// optional uint32 stop_timeout_ms = 7;
inline bool DataSourceConfig::has_stop_timeout_ms() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DataSourceConfig::set_has_stop_timeout_ms() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DataSourceConfig::clear_has_stop_timeout_ms() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DataSourceConfig::clear_stop_timeout_ms() {
  stop_timeout_ms_ = 0u;
  clear_has_stop_timeout_ms();
}
inline ::google::protobuf::uint32 DataSourceConfig::stop_timeout_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.stop_timeout_ms)
  return stop_timeout_ms_;
}
inline void DataSourceConfig::set_stop_timeout_ms(::google::protobuf::uint32 value) {
  set_has_stop_timeout_ms();
  stop_timeout_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.DataSourceConfig.stop_timeout_ms)
}

// optional bool enable_extra_guardrails = 6;
inline bool DataSourceConfig::has_enable_extra_guardrails() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DataSourceConfig::set_has_enable_extra_guardrails() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DataSourceConfig::clear_has_enable_extra_guardrails() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DataSourceConfig::clear_enable_extra_guardrails() {
  enable_extra_guardrails_ = false;
  clear_has_enable_extra_guardrails();
}
inline bool DataSourceConfig::enable_extra_guardrails() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.enable_extra_guardrails)
  return enable_extra_guardrails_;
}
inline void DataSourceConfig::set_enable_extra_guardrails(bool value) {
  set_has_enable_extra_guardrails();
  enable_extra_guardrails_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.DataSourceConfig.enable_extra_guardrails)
}

// optional uint64 tracing_session_id = 4;
inline bool DataSourceConfig::has_tracing_session_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DataSourceConfig::set_has_tracing_session_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DataSourceConfig::clear_has_tracing_session_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DataSourceConfig::clear_tracing_session_id() {
  tracing_session_id_ = GOOGLE_ULONGLONG(0);
  clear_has_tracing_session_id();
}
inline ::google::protobuf::uint64 DataSourceConfig::tracing_session_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.tracing_session_id)
  return tracing_session_id_;
}
inline void DataSourceConfig::set_tracing_session_id(::google::protobuf::uint64 value) {
  set_has_tracing_session_id();
  tracing_session_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.DataSourceConfig.tracing_session_id)
}

// optional .perfetto.protos.FtraceConfig ftrace_config = 100 [lazy = true];
inline bool DataSourceConfig::has_ftrace_config() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DataSourceConfig::set_has_ftrace_config() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DataSourceConfig::clear_has_ftrace_config() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DataSourceConfig::clear_ftrace_config() {
  if (ftrace_config_ != NULL) ftrace_config_->::perfetto::protos::FtraceConfig::Clear();
  clear_has_ftrace_config();
}
inline const ::perfetto::protos::FtraceConfig& DataSourceConfig::ftrace_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.ftrace_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return ftrace_config_ != NULL ? *ftrace_config_ : *default_instance().ftrace_config_;
#else
  return ftrace_config_ != NULL ? *ftrace_config_ : *default_instance_->ftrace_config_;
#endif
}
inline ::perfetto::protos::FtraceConfig* DataSourceConfig::mutable_ftrace_config() {
  set_has_ftrace_config();
  if (ftrace_config_ == NULL) {
    ftrace_config_ = new ::perfetto::protos::FtraceConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceConfig.ftrace_config)
  return ftrace_config_;
}
inline ::perfetto::protos::FtraceConfig* DataSourceConfig::release_ftrace_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceConfig.ftrace_config)
  clear_has_ftrace_config();
  ::perfetto::protos::FtraceConfig* temp = ftrace_config_;
  ftrace_config_ = NULL;
  return temp;
}
inline void DataSourceConfig::set_allocated_ftrace_config(::perfetto::protos::FtraceConfig* ftrace_config) {
  delete ftrace_config_;
  ftrace_config_ = ftrace_config;
  if (ftrace_config) {
    set_has_ftrace_config();
  } else {
    clear_has_ftrace_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceConfig.ftrace_config)
}

// optional .perfetto.protos.InodeFileConfig inode_file_config = 102 [lazy = true];
inline bool DataSourceConfig::has_inode_file_config() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DataSourceConfig::set_has_inode_file_config() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DataSourceConfig::clear_has_inode_file_config() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DataSourceConfig::clear_inode_file_config() {
  if (inode_file_config_ != NULL) inode_file_config_->::perfetto::protos::InodeFileConfig::Clear();
  clear_has_inode_file_config();
}
inline const ::perfetto::protos::InodeFileConfig& DataSourceConfig::inode_file_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.inode_file_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return inode_file_config_ != NULL ? *inode_file_config_ : *default_instance().inode_file_config_;
#else
  return inode_file_config_ != NULL ? *inode_file_config_ : *default_instance_->inode_file_config_;
#endif
}
inline ::perfetto::protos::InodeFileConfig* DataSourceConfig::mutable_inode_file_config() {
  set_has_inode_file_config();
  if (inode_file_config_ == NULL) {
    inode_file_config_ = new ::perfetto::protos::InodeFileConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceConfig.inode_file_config)
  return inode_file_config_;
}
inline ::perfetto::protos::InodeFileConfig* DataSourceConfig::release_inode_file_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceConfig.inode_file_config)
  clear_has_inode_file_config();
  ::perfetto::protos::InodeFileConfig* temp = inode_file_config_;
  inode_file_config_ = NULL;
  return temp;
}
inline void DataSourceConfig::set_allocated_inode_file_config(::perfetto::protos::InodeFileConfig* inode_file_config) {
  delete inode_file_config_;
  inode_file_config_ = inode_file_config;
  if (inode_file_config) {
    set_has_inode_file_config();
  } else {
    clear_has_inode_file_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceConfig.inode_file_config)
}

// optional .perfetto.protos.ProcessStatsConfig process_stats_config = 103 [lazy = true];
inline bool DataSourceConfig::has_process_stats_config() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DataSourceConfig::set_has_process_stats_config() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DataSourceConfig::clear_has_process_stats_config() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DataSourceConfig::clear_process_stats_config() {
  if (process_stats_config_ != NULL) process_stats_config_->::perfetto::protos::ProcessStatsConfig::Clear();
  clear_has_process_stats_config();
}
inline const ::perfetto::protos::ProcessStatsConfig& DataSourceConfig::process_stats_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.process_stats_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return process_stats_config_ != NULL ? *process_stats_config_ : *default_instance().process_stats_config_;
#else
  return process_stats_config_ != NULL ? *process_stats_config_ : *default_instance_->process_stats_config_;
#endif
}
inline ::perfetto::protos::ProcessStatsConfig* DataSourceConfig::mutable_process_stats_config() {
  set_has_process_stats_config();
  if (process_stats_config_ == NULL) {
    process_stats_config_ = new ::perfetto::protos::ProcessStatsConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceConfig.process_stats_config)
  return process_stats_config_;
}
inline ::perfetto::protos::ProcessStatsConfig* DataSourceConfig::release_process_stats_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceConfig.process_stats_config)
  clear_has_process_stats_config();
  ::perfetto::protos::ProcessStatsConfig* temp = process_stats_config_;
  process_stats_config_ = NULL;
  return temp;
}
inline void DataSourceConfig::set_allocated_process_stats_config(::perfetto::protos::ProcessStatsConfig* process_stats_config) {
  delete process_stats_config_;
  process_stats_config_ = process_stats_config;
  if (process_stats_config) {
    set_has_process_stats_config();
  } else {
    clear_has_process_stats_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceConfig.process_stats_config)
}

// optional .perfetto.protos.SysStatsConfig sys_stats_config = 104 [lazy = true];
inline bool DataSourceConfig::has_sys_stats_config() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DataSourceConfig::set_has_sys_stats_config() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DataSourceConfig::clear_has_sys_stats_config() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DataSourceConfig::clear_sys_stats_config() {
  if (sys_stats_config_ != NULL) sys_stats_config_->::perfetto::protos::SysStatsConfig::Clear();
  clear_has_sys_stats_config();
}
inline const ::perfetto::protos::SysStatsConfig& DataSourceConfig::sys_stats_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.sys_stats_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return sys_stats_config_ != NULL ? *sys_stats_config_ : *default_instance().sys_stats_config_;
#else
  return sys_stats_config_ != NULL ? *sys_stats_config_ : *default_instance_->sys_stats_config_;
#endif
}
inline ::perfetto::protos::SysStatsConfig* DataSourceConfig::mutable_sys_stats_config() {
  set_has_sys_stats_config();
  if (sys_stats_config_ == NULL) {
    sys_stats_config_ = new ::perfetto::protos::SysStatsConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceConfig.sys_stats_config)
  return sys_stats_config_;
}
inline ::perfetto::protos::SysStatsConfig* DataSourceConfig::release_sys_stats_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceConfig.sys_stats_config)
  clear_has_sys_stats_config();
  ::perfetto::protos::SysStatsConfig* temp = sys_stats_config_;
  sys_stats_config_ = NULL;
  return temp;
}
inline void DataSourceConfig::set_allocated_sys_stats_config(::perfetto::protos::SysStatsConfig* sys_stats_config) {
  delete sys_stats_config_;
  sys_stats_config_ = sys_stats_config;
  if (sys_stats_config) {
    set_has_sys_stats_config();
  } else {
    clear_has_sys_stats_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceConfig.sys_stats_config)
}

// optional .perfetto.protos.HeapprofdConfig heapprofd_config = 105 [lazy = true];
inline bool DataSourceConfig::has_heapprofd_config() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DataSourceConfig::set_has_heapprofd_config() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DataSourceConfig::clear_has_heapprofd_config() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DataSourceConfig::clear_heapprofd_config() {
  if (heapprofd_config_ != NULL) heapprofd_config_->::perfetto::protos::HeapprofdConfig::Clear();
  clear_has_heapprofd_config();
}
inline const ::perfetto::protos::HeapprofdConfig& DataSourceConfig::heapprofd_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.heapprofd_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return heapprofd_config_ != NULL ? *heapprofd_config_ : *default_instance().heapprofd_config_;
#else
  return heapprofd_config_ != NULL ? *heapprofd_config_ : *default_instance_->heapprofd_config_;
#endif
}
inline ::perfetto::protos::HeapprofdConfig* DataSourceConfig::mutable_heapprofd_config() {
  set_has_heapprofd_config();
  if (heapprofd_config_ == NULL) {
    heapprofd_config_ = new ::perfetto::protos::HeapprofdConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceConfig.heapprofd_config)
  return heapprofd_config_;
}
inline ::perfetto::protos::HeapprofdConfig* DataSourceConfig::release_heapprofd_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceConfig.heapprofd_config)
  clear_has_heapprofd_config();
  ::perfetto::protos::HeapprofdConfig* temp = heapprofd_config_;
  heapprofd_config_ = NULL;
  return temp;
}
inline void DataSourceConfig::set_allocated_heapprofd_config(::perfetto::protos::HeapprofdConfig* heapprofd_config) {
  delete heapprofd_config_;
  heapprofd_config_ = heapprofd_config;
  if (heapprofd_config) {
    set_has_heapprofd_config();
  } else {
    clear_has_heapprofd_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceConfig.heapprofd_config)
}

// optional .perfetto.protos.AndroidPowerConfig android_power_config = 106 [lazy = true];
inline bool DataSourceConfig::has_android_power_config() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DataSourceConfig::set_has_android_power_config() {
  _has_bits_[0] |= 0x00000800u;
}
inline void DataSourceConfig::clear_has_android_power_config() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void DataSourceConfig::clear_android_power_config() {
  if (android_power_config_ != NULL) android_power_config_->::perfetto::protos::AndroidPowerConfig::Clear();
  clear_has_android_power_config();
}
inline const ::perfetto::protos::AndroidPowerConfig& DataSourceConfig::android_power_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.android_power_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return android_power_config_ != NULL ? *android_power_config_ : *default_instance().android_power_config_;
#else
  return android_power_config_ != NULL ? *android_power_config_ : *default_instance_->android_power_config_;
#endif
}
inline ::perfetto::protos::AndroidPowerConfig* DataSourceConfig::mutable_android_power_config() {
  set_has_android_power_config();
  if (android_power_config_ == NULL) {
    android_power_config_ = new ::perfetto::protos::AndroidPowerConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceConfig.android_power_config)
  return android_power_config_;
}
inline ::perfetto::protos::AndroidPowerConfig* DataSourceConfig::release_android_power_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceConfig.android_power_config)
  clear_has_android_power_config();
  ::perfetto::protos::AndroidPowerConfig* temp = android_power_config_;
  android_power_config_ = NULL;
  return temp;
}
inline void DataSourceConfig::set_allocated_android_power_config(::perfetto::protos::AndroidPowerConfig* android_power_config) {
  delete android_power_config_;
  android_power_config_ = android_power_config;
  if (android_power_config) {
    set_has_android_power_config();
  } else {
    clear_has_android_power_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceConfig.android_power_config)
}

// optional .perfetto.protos.AndroidLogConfig android_log_config = 107 [lazy = true];
inline bool DataSourceConfig::has_android_log_config() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void DataSourceConfig::set_has_android_log_config() {
  _has_bits_[0] |= 0x00001000u;
}
inline void DataSourceConfig::clear_has_android_log_config() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void DataSourceConfig::clear_android_log_config() {
  if (android_log_config_ != NULL) android_log_config_->::perfetto::protos::AndroidLogConfig::Clear();
  clear_has_android_log_config();
}
inline const ::perfetto::protos::AndroidLogConfig& DataSourceConfig::android_log_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.android_log_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return android_log_config_ != NULL ? *android_log_config_ : *default_instance().android_log_config_;
#else
  return android_log_config_ != NULL ? *android_log_config_ : *default_instance_->android_log_config_;
#endif
}
inline ::perfetto::protos::AndroidLogConfig* DataSourceConfig::mutable_android_log_config() {
  set_has_android_log_config();
  if (android_log_config_ == NULL) {
    android_log_config_ = new ::perfetto::protos::AndroidLogConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceConfig.android_log_config)
  return android_log_config_;
}
inline ::perfetto::protos::AndroidLogConfig* DataSourceConfig::release_android_log_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceConfig.android_log_config)
  clear_has_android_log_config();
  ::perfetto::protos::AndroidLogConfig* temp = android_log_config_;
  android_log_config_ = NULL;
  return temp;
}
inline void DataSourceConfig::set_allocated_android_log_config(::perfetto::protos::AndroidLogConfig* android_log_config) {
  delete android_log_config_;
  android_log_config_ = android_log_config;
  if (android_log_config) {
    set_has_android_log_config();
  } else {
    clear_has_android_log_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceConfig.android_log_config)
}

// optional .perfetto.protos.GpuCounterConfig gpu_counter_config = 108 [lazy = true];
inline bool DataSourceConfig::has_gpu_counter_config() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void DataSourceConfig::set_has_gpu_counter_config() {
  _has_bits_[0] |= 0x00002000u;
}
inline void DataSourceConfig::clear_has_gpu_counter_config() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void DataSourceConfig::clear_gpu_counter_config() {
  if (gpu_counter_config_ != NULL) gpu_counter_config_->::perfetto::protos::GpuCounterConfig::Clear();
  clear_has_gpu_counter_config();
}
inline const ::perfetto::protos::GpuCounterConfig& DataSourceConfig::gpu_counter_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.gpu_counter_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return gpu_counter_config_ != NULL ? *gpu_counter_config_ : *default_instance().gpu_counter_config_;
#else
  return gpu_counter_config_ != NULL ? *gpu_counter_config_ : *default_instance_->gpu_counter_config_;
#endif
}
inline ::perfetto::protos::GpuCounterConfig* DataSourceConfig::mutable_gpu_counter_config() {
  set_has_gpu_counter_config();
  if (gpu_counter_config_ == NULL) {
    gpu_counter_config_ = new ::perfetto::protos::GpuCounterConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceConfig.gpu_counter_config)
  return gpu_counter_config_;
}
inline ::perfetto::protos::GpuCounterConfig* DataSourceConfig::release_gpu_counter_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceConfig.gpu_counter_config)
  clear_has_gpu_counter_config();
  ::perfetto::protos::GpuCounterConfig* temp = gpu_counter_config_;
  gpu_counter_config_ = NULL;
  return temp;
}
inline void DataSourceConfig::set_allocated_gpu_counter_config(::perfetto::protos::GpuCounterConfig* gpu_counter_config) {
  delete gpu_counter_config_;
  gpu_counter_config_ = gpu_counter_config;
  if (gpu_counter_config) {
    set_has_gpu_counter_config();
  } else {
    clear_has_gpu_counter_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceConfig.gpu_counter_config)
}

// optional .perfetto.protos.PackagesListConfig packages_list_config = 109 [lazy = true];
inline bool DataSourceConfig::has_packages_list_config() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void DataSourceConfig::set_has_packages_list_config() {
  _has_bits_[0] |= 0x00004000u;
}
inline void DataSourceConfig::clear_has_packages_list_config() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void DataSourceConfig::clear_packages_list_config() {
  if (packages_list_config_ != NULL) packages_list_config_->::perfetto::protos::PackagesListConfig::Clear();
  clear_has_packages_list_config();
}
inline const ::perfetto::protos::PackagesListConfig& DataSourceConfig::packages_list_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.packages_list_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return packages_list_config_ != NULL ? *packages_list_config_ : *default_instance().packages_list_config_;
#else
  return packages_list_config_ != NULL ? *packages_list_config_ : *default_instance_->packages_list_config_;
#endif
}
inline ::perfetto::protos::PackagesListConfig* DataSourceConfig::mutable_packages_list_config() {
  set_has_packages_list_config();
  if (packages_list_config_ == NULL) {
    packages_list_config_ = new ::perfetto::protos::PackagesListConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceConfig.packages_list_config)
  return packages_list_config_;
}
inline ::perfetto::protos::PackagesListConfig* DataSourceConfig::release_packages_list_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceConfig.packages_list_config)
  clear_has_packages_list_config();
  ::perfetto::protos::PackagesListConfig* temp = packages_list_config_;
  packages_list_config_ = NULL;
  return temp;
}
inline void DataSourceConfig::set_allocated_packages_list_config(::perfetto::protos::PackagesListConfig* packages_list_config) {
  delete packages_list_config_;
  packages_list_config_ = packages_list_config;
  if (packages_list_config) {
    set_has_packages_list_config();
  } else {
    clear_has_packages_list_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceConfig.packages_list_config)
}

// optional .perfetto.protos.ChromeConfig chrome_config = 101;
inline bool DataSourceConfig::has_chrome_config() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void DataSourceConfig::set_has_chrome_config() {
  _has_bits_[0] |= 0x00008000u;
}
inline void DataSourceConfig::clear_has_chrome_config() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void DataSourceConfig::clear_chrome_config() {
  if (chrome_config_ != NULL) chrome_config_->::perfetto::protos::ChromeConfig::Clear();
  clear_has_chrome_config();
}
inline const ::perfetto::protos::ChromeConfig& DataSourceConfig::chrome_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.chrome_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return chrome_config_ != NULL ? *chrome_config_ : *default_instance().chrome_config_;
#else
  return chrome_config_ != NULL ? *chrome_config_ : *default_instance_->chrome_config_;
#endif
}
inline ::perfetto::protos::ChromeConfig* DataSourceConfig::mutable_chrome_config() {
  set_has_chrome_config();
  if (chrome_config_ == NULL) {
    chrome_config_ = new ::perfetto::protos::ChromeConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceConfig.chrome_config)
  return chrome_config_;
}
inline ::perfetto::protos::ChromeConfig* DataSourceConfig::release_chrome_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceConfig.chrome_config)
  clear_has_chrome_config();
  ::perfetto::protos::ChromeConfig* temp = chrome_config_;
  chrome_config_ = NULL;
  return temp;
}
inline void DataSourceConfig::set_allocated_chrome_config(::perfetto::protos::ChromeConfig* chrome_config) {
  delete chrome_config_;
  chrome_config_ = chrome_config;
  if (chrome_config) {
    set_has_chrome_config();
  } else {
    clear_has_chrome_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceConfig.chrome_config)
}

// optional string legacy_config = 1000;
inline bool DataSourceConfig::has_legacy_config() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void DataSourceConfig::set_has_legacy_config() {
  _has_bits_[0] |= 0x00010000u;
}
inline void DataSourceConfig::clear_has_legacy_config() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void DataSourceConfig::clear_legacy_config() {
  legacy_config_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_legacy_config();
}
inline const ::std::string& DataSourceConfig::legacy_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.legacy_config)
  return legacy_config_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DataSourceConfig::set_legacy_config(const ::std::string& value) {
  set_has_legacy_config();
  legacy_config_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.DataSourceConfig.legacy_config)
}
inline void DataSourceConfig::set_legacy_config(const char* value) {
  set_has_legacy_config();
  legacy_config_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.DataSourceConfig.legacy_config)
}
inline void DataSourceConfig::set_legacy_config(const char* value, size_t size) {
  set_has_legacy_config();
  legacy_config_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.DataSourceConfig.legacy_config)
}
inline ::std::string* DataSourceConfig::mutable_legacy_config() {
  set_has_legacy_config();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceConfig.legacy_config)
  return legacy_config_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DataSourceConfig::release_legacy_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceConfig.legacy_config)
  clear_has_legacy_config();
  return legacy_config_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DataSourceConfig::set_allocated_legacy_config(::std::string* legacy_config) {
  if (legacy_config != NULL) {
    set_has_legacy_config();
  } else {
    clear_has_legacy_config();
  }
  legacy_config_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), legacy_config);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceConfig.legacy_config)
}

// optional .perfetto.protos.TestConfig for_testing = 1001;
inline bool DataSourceConfig::has_for_testing() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void DataSourceConfig::set_has_for_testing() {
  _has_bits_[0] |= 0x00020000u;
}
inline void DataSourceConfig::clear_has_for_testing() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void DataSourceConfig::clear_for_testing() {
  if (for_testing_ != NULL) for_testing_->::perfetto::protos::TestConfig::Clear();
  clear_has_for_testing();
}
inline const ::perfetto::protos::TestConfig& DataSourceConfig::for_testing() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.for_testing)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return for_testing_ != NULL ? *for_testing_ : *default_instance().for_testing_;
#else
  return for_testing_ != NULL ? *for_testing_ : *default_instance_->for_testing_;
#endif
}
inline ::perfetto::protos::TestConfig* DataSourceConfig::mutable_for_testing() {
  set_has_for_testing();
  if (for_testing_ == NULL) {
    for_testing_ = new ::perfetto::protos::TestConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceConfig.for_testing)
  return for_testing_;
}
inline ::perfetto::protos::TestConfig* DataSourceConfig::release_for_testing() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceConfig.for_testing)
  clear_has_for_testing();
  ::perfetto::protos::TestConfig* temp = for_testing_;
  for_testing_ = NULL;
  return temp;
}
inline void DataSourceConfig::set_allocated_for_testing(::perfetto::protos::TestConfig* for_testing) {
  delete for_testing_;
  for_testing_ = for_testing;
  if (for_testing) {
    set_has_for_testing();
  } else {
    clear_has_for_testing();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceConfig.for_testing)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2fconfig_2fdata_5fsource_5fconfig_2eproto__INCLUDED
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/config/trace_config.proto

#ifndef PROTOBUF_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
// gen_amalgamated expanded: #include "protos/perfetto/config/data_source_config.pb.h"
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();

class TraceConfig;
class TraceConfig_BufferConfig;
class TraceConfig_BuiltinDataSource;
class TraceConfig_DataSource;
class TraceConfig_GuardrailOverrides;
class TraceConfig_IncidentReportConfig;
class TraceConfig_IncrementalStateConfig;
class TraceConfig_ProducerConfig;
class TraceConfig_StatsdMetadata;
class TraceConfig_TriggerConfig;
class TraceConfig_TriggerConfig_Trigger;

enum TraceConfig_BufferConfig_FillPolicy {
  TraceConfig_BufferConfig_FillPolicy_UNSPECIFIED = 0,
  TraceConfig_BufferConfig_FillPolicy_RING_BUFFER = 1,
  TraceConfig_BufferConfig_FillPolicy_DISCARD = 2
};
bool TraceConfig_BufferConfig_FillPolicy_IsValid(int value);
const TraceConfig_BufferConfig_FillPolicy TraceConfig_BufferConfig_FillPolicy_FillPolicy_MIN = TraceConfig_BufferConfig_FillPolicy_UNSPECIFIED;
const TraceConfig_BufferConfig_FillPolicy TraceConfig_BufferConfig_FillPolicy_FillPolicy_MAX = TraceConfig_BufferConfig_FillPolicy_DISCARD;
const int TraceConfig_BufferConfig_FillPolicy_FillPolicy_ARRAYSIZE = TraceConfig_BufferConfig_FillPolicy_FillPolicy_MAX + 1;

enum TraceConfig_TriggerConfig_TriggerMode {
  TraceConfig_TriggerConfig_TriggerMode_UNSPECIFIED = 0,
  TraceConfig_TriggerConfig_TriggerMode_START_TRACING = 1,
  TraceConfig_TriggerConfig_TriggerMode_STOP_TRACING = 2
};
bool TraceConfig_TriggerConfig_TriggerMode_IsValid(int value);
const TraceConfig_TriggerConfig_TriggerMode TraceConfig_TriggerConfig_TriggerMode_TriggerMode_MIN = TraceConfig_TriggerConfig_TriggerMode_UNSPECIFIED;
const TraceConfig_TriggerConfig_TriggerMode TraceConfig_TriggerConfig_TriggerMode_TriggerMode_MAX = TraceConfig_TriggerConfig_TriggerMode_STOP_TRACING;
const int TraceConfig_TriggerConfig_TriggerMode_TriggerMode_ARRAYSIZE = TraceConfig_TriggerConfig_TriggerMode_TriggerMode_MAX + 1;

enum TraceConfig_LockdownModeOperation {
  TraceConfig_LockdownModeOperation_LOCKDOWN_UNCHANGED = 0,
  TraceConfig_LockdownModeOperation_LOCKDOWN_CLEAR = 1,
  TraceConfig_LockdownModeOperation_LOCKDOWN_SET = 2
};
bool TraceConfig_LockdownModeOperation_IsValid(int value);
const TraceConfig_LockdownModeOperation TraceConfig_LockdownModeOperation_LockdownModeOperation_MIN = TraceConfig_LockdownModeOperation_LOCKDOWN_UNCHANGED;
const TraceConfig_LockdownModeOperation TraceConfig_LockdownModeOperation_LockdownModeOperation_MAX = TraceConfig_LockdownModeOperation_LOCKDOWN_SET;
const int TraceConfig_LockdownModeOperation_LockdownModeOperation_ARRAYSIZE = TraceConfig_LockdownModeOperation_LockdownModeOperation_MAX + 1;

enum TraceConfig_CompressionType {
  TraceConfig_CompressionType_COMPRESSION_TYPE_UNSPECIFIED = 0,
  TraceConfig_CompressionType_COMPRESSION_TYPE_DEFLATE = 1
};
bool TraceConfig_CompressionType_IsValid(int value);
const TraceConfig_CompressionType TraceConfig_CompressionType_CompressionType_MIN = TraceConfig_CompressionType_COMPRESSION_TYPE_UNSPECIFIED;
const TraceConfig_CompressionType TraceConfig_CompressionType_CompressionType_MAX = TraceConfig_CompressionType_COMPRESSION_TYPE_DEFLATE;
const int TraceConfig_CompressionType_CompressionType_ARRAYSIZE = TraceConfig_CompressionType_CompressionType_MAX + 1;

// ===================================================================

class TraceConfig_BufferConfig : public ::google::protobuf::MessageLite {
 public:
  TraceConfig_BufferConfig();
  virtual ~TraceConfig_BufferConfig();

  TraceConfig_BufferConfig(const TraceConfig_BufferConfig& from);

  inline TraceConfig_BufferConfig& operator=(const TraceConfig_BufferConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TraceConfig_BufferConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TraceConfig_BufferConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TraceConfig_BufferConfig* other);

  // implements Message ----------------------------------------------

  inline TraceConfig_BufferConfig* New() const { return New(NULL); }

  TraceConfig_BufferConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TraceConfig_BufferConfig& from);
  void MergeFrom(const TraceConfig_BufferConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TraceConfig_BufferConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef TraceConfig_BufferConfig_FillPolicy FillPolicy;
  static const FillPolicy UNSPECIFIED =
    TraceConfig_BufferConfig_FillPolicy_UNSPECIFIED;
  static const FillPolicy RING_BUFFER =
    TraceConfig_BufferConfig_FillPolicy_RING_BUFFER;
  static const FillPolicy DISCARD =
    TraceConfig_BufferConfig_FillPolicy_DISCARD;
  static inline bool FillPolicy_IsValid(int value) {
    return TraceConfig_BufferConfig_FillPolicy_IsValid(value);
  }
  static const FillPolicy FillPolicy_MIN =
    TraceConfig_BufferConfig_FillPolicy_FillPolicy_MIN;
  static const FillPolicy FillPolicy_MAX =
    TraceConfig_BufferConfig_FillPolicy_FillPolicy_MAX;
  static const int FillPolicy_ARRAYSIZE =
    TraceConfig_BufferConfig_FillPolicy_FillPolicy_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional uint32 size_kb = 1;
  bool has_size_kb() const;
  void clear_size_kb();
  static const int kSizeKbFieldNumber = 1;
  ::google::protobuf::uint32 size_kb() const;
  void set_size_kb(::google::protobuf::uint32 value);

  // optional .perfetto.protos.TraceConfig.BufferConfig.FillPolicy fill_policy = 4;
  bool has_fill_policy() const;
  void clear_fill_policy();
  static const int kFillPolicyFieldNumber = 4;
  ::perfetto::protos::TraceConfig_BufferConfig_FillPolicy fill_policy() const;
  void set_fill_policy(::perfetto::protos::TraceConfig_BufferConfig_FillPolicy value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.TraceConfig.BufferConfig)
 private:
  inline void set_has_size_kb();
  inline void clear_has_size_kb();
  inline void set_has_fill_policy();
  inline void clear_has_fill_policy();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 size_kb_;
  int fill_policy_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static TraceConfig_BufferConfig* default_instance_;
};
// -------------------------------------------------------------------

class TraceConfig_DataSource : public ::google::protobuf::MessageLite {
 public:
  TraceConfig_DataSource();
  virtual ~TraceConfig_DataSource();

  TraceConfig_DataSource(const TraceConfig_DataSource& from);

  inline TraceConfig_DataSource& operator=(const TraceConfig_DataSource& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TraceConfig_DataSource& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TraceConfig_DataSource* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TraceConfig_DataSource* other);

  // implements Message ----------------------------------------------

  inline TraceConfig_DataSource* New() const { return New(NULL); }

  TraceConfig_DataSource* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TraceConfig_DataSource& from);
  void MergeFrom(const TraceConfig_DataSource& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TraceConfig_DataSource* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .perfetto.protos.DataSourceConfig config = 1;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 1;
  const ::perfetto::protos::DataSourceConfig& config() const;
  ::perfetto::protos::DataSourceConfig* mutable_config();
  ::perfetto::protos::DataSourceConfig* release_config();
  void set_allocated_config(::perfetto::protos::DataSourceConfig* config);

  // repeated string producer_name_filter = 2;
  int producer_name_filter_size() const;
  void clear_producer_name_filter();
  static const int kProducerNameFilterFieldNumber = 2;
  const ::std::string& producer_name_filter(int index) const;
  ::std::string* mutable_producer_name_filter(int index);
  void set_producer_name_filter(int index, const ::std::string& value);
  void set_producer_name_filter(int index, const char* value);
  void set_producer_name_filter(int index, const char* value, size_t size);
  ::std::string* add_producer_name_filter();
  void add_producer_name_filter(const ::std::string& value);
  void add_producer_name_filter(const char* value);
  void add_producer_name_filter(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& producer_name_filter() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_producer_name_filter();

  // @@protoc_insertion_point(class_scope:perfetto.protos.TraceConfig.DataSource)
 private:
  inline void set_has_config();
  inline void clear_has_config();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::perfetto::protos::DataSourceConfig* config_;
  ::google::protobuf::RepeatedPtrField< ::std::string> producer_name_filter_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static TraceConfig_DataSource* default_instance_;
};
// -------------------------------------------------------------------

class TraceConfig_BuiltinDataSource : public ::google::protobuf::MessageLite {
 public:
  TraceConfig_BuiltinDataSource();
  virtual ~TraceConfig_BuiltinDataSource();

  TraceConfig_BuiltinDataSource(const TraceConfig_BuiltinDataSource& from);

  inline TraceConfig_BuiltinDataSource& operator=(const TraceConfig_BuiltinDataSource& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TraceConfig_BuiltinDataSource& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TraceConfig_BuiltinDataSource* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TraceConfig_BuiltinDataSource* other);

  // implements Message ----------------------------------------------

  inline TraceConfig_BuiltinDataSource* New() const { return New(NULL); }

  TraceConfig_BuiltinDataSource* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TraceConfig_BuiltinDataSource& from);
  void MergeFrom(const TraceConfig_BuiltinDataSource& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TraceConfig_BuiltinDataSource* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool disable_clock_snapshotting = 1;
  bool has_disable_clock_snapshotting() const;
  void clear_disable_clock_snapshotting();
  static const int kDisableClockSnapshottingFieldNumber = 1;
  bool disable_clock_snapshotting() const;
  void set_disable_clock_snapshotting(bool value);

  // optional bool disable_trace_config = 2;
  bool has_disable_trace_config() const;
  void clear_disable_trace_config();
  static const int kDisableTraceConfigFieldNumber = 2;
  bool disable_trace_config() const;
  void set_disable_trace_config(bool value);

  // optional bool disable_system_info = 3;
  bool has_disable_system_info() const;
  void clear_disable_system_info();
  static const int kDisableSystemInfoFieldNumber = 3;
  bool disable_system_info() const;
  void set_disable_system_info(bool value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.TraceConfig.BuiltinDataSource)
 private:
  inline void set_has_disable_clock_snapshotting();
  inline void clear_has_disable_clock_snapshotting();
  inline void set_has_disable_trace_config();
  inline void clear_has_disable_trace_config();
  inline void set_has_disable_system_info();
  inline void clear_has_disable_system_info();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool disable_clock_snapshotting_;
  bool disable_trace_config_;
  bool disable_system_info_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static TraceConfig_BuiltinDataSource* default_instance_;
};
// -------------------------------------------------------------------

class TraceConfig_ProducerConfig : public ::google::protobuf::MessageLite {
 public:
  TraceConfig_ProducerConfig();
  virtual ~TraceConfig_ProducerConfig();

  TraceConfig_ProducerConfig(const TraceConfig_ProducerConfig& from);

  inline TraceConfig_ProducerConfig& operator=(const TraceConfig_ProducerConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TraceConfig_ProducerConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TraceConfig_ProducerConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TraceConfig_ProducerConfig* other);

  // implements Message ----------------------------------------------

  inline TraceConfig_ProducerConfig* New() const { return New(NULL); }

  TraceConfig_ProducerConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TraceConfig_ProducerConfig& from);
  void MergeFrom(const TraceConfig_ProducerConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TraceConfig_ProducerConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string producer_name = 1;
  bool has_producer_name() const;
  void clear_producer_name();
  static const int kProducerNameFieldNumber = 1;
  const ::std::string& producer_name() const;
  void set_producer_name(const ::std::string& value);
  void set_producer_name(const char* value);
  void set_producer_name(const char* value, size_t size);
  ::std::string* mutable_producer_name();
  ::std::string* release_producer_name();
  void set_allocated_producer_name(::std::string* producer_name);

  // optional uint32 shm_size_kb = 2;
  bool has_shm_size_kb() const;
  void clear_shm_size_kb();
  static const int kShmSizeKbFieldNumber = 2;
  ::google::protobuf::uint32 shm_size_kb() const;
  void set_shm_size_kb(::google::protobuf::uint32 value);

  // optional uint32 page_size_kb = 3;
  bool has_page_size_kb() const;
  void clear_page_size_kb();
  static const int kPageSizeKbFieldNumber = 3;
  ::google::protobuf::uint32 page_size_kb() const;
  void set_page_size_kb(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.TraceConfig.ProducerConfig)
 private:
  inline void set_has_producer_name();
  inline void clear_has_producer_name();
  inline void set_has_shm_size_kb();
  inline void clear_has_shm_size_kb();
  inline void set_has_page_size_kb();
  inline void clear_has_page_size_kb();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr producer_name_;
  ::google::protobuf::uint32 shm_size_kb_;
  ::google::protobuf::uint32 page_size_kb_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static TraceConfig_ProducerConfig* default_instance_;
};
// -------------------------------------------------------------------

class TraceConfig_StatsdMetadata : public ::google::protobuf::MessageLite {
 public:
  TraceConfig_StatsdMetadata();
  virtual ~TraceConfig_StatsdMetadata();

  TraceConfig_StatsdMetadata(const TraceConfig_StatsdMetadata& from);

  inline TraceConfig_StatsdMetadata& operator=(const TraceConfig_StatsdMetadata& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TraceConfig_StatsdMetadata& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TraceConfig_StatsdMetadata* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TraceConfig_StatsdMetadata* other);

  // implements Message ----------------------------------------------

  inline TraceConfig_StatsdMetadata* New() const { return New(NULL); }

  TraceConfig_StatsdMetadata* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TraceConfig_StatsdMetadata& from);
  void MergeFrom(const TraceConfig_StatsdMetadata& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TraceConfig_StatsdMetadata* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 triggering_alert_id = 1;
  bool has_triggering_alert_id() const;
  void clear_triggering_alert_id();
  static const int kTriggeringAlertIdFieldNumber = 1;
  ::google::protobuf::int64 triggering_alert_id() const;
  void set_triggering_alert_id(::google::protobuf::int64 value);

  // optional int32 triggering_config_uid = 2;
  bool has_triggering_config_uid() const;
  void clear_triggering_config_uid();
  static const int kTriggeringConfigUidFieldNumber = 2;
  ::google::protobuf::int32 triggering_config_uid() const;
  void set_triggering_config_uid(::google::protobuf::int32 value);

  // optional int64 triggering_config_id = 3;
  bool has_triggering_config_id() const;
  void clear_triggering_config_id();
  static const int kTriggeringConfigIdFieldNumber = 3;
  ::google::protobuf::int64 triggering_config_id() const;
  void set_triggering_config_id(::google::protobuf::int64 value);

  // optional int64 triggering_subscription_id = 4;
  bool has_triggering_subscription_id() const;
  void clear_triggering_subscription_id();
  static const int kTriggeringSubscriptionIdFieldNumber = 4;
  ::google::protobuf::int64 triggering_subscription_id() const;
  void set_triggering_subscription_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.TraceConfig.StatsdMetadata)
 private:
  inline void set_has_triggering_alert_id();
  inline void clear_has_triggering_alert_id();
  inline void set_has_triggering_config_uid();
  inline void clear_has_triggering_config_uid();
  inline void set_has_triggering_config_id();
  inline void clear_has_triggering_config_id();
  inline void set_has_triggering_subscription_id();
  inline void clear_has_triggering_subscription_id();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 triggering_alert_id_;
  ::google::protobuf::int64 triggering_config_id_;
  ::google::protobuf::int64 triggering_subscription_id_;
  ::google::protobuf::int32 triggering_config_uid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static TraceConfig_StatsdMetadata* default_instance_;
};
// -------------------------------------------------------------------

class TraceConfig_GuardrailOverrides : public ::google::protobuf::MessageLite {
 public:
  TraceConfig_GuardrailOverrides();
  virtual ~TraceConfig_GuardrailOverrides();

  TraceConfig_GuardrailOverrides(const TraceConfig_GuardrailOverrides& from);

  inline TraceConfig_GuardrailOverrides& operator=(const TraceConfig_GuardrailOverrides& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TraceConfig_GuardrailOverrides& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TraceConfig_GuardrailOverrides* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TraceConfig_GuardrailOverrides* other);

  // implements Message ----------------------------------------------

  inline TraceConfig_GuardrailOverrides* New() const { return New(NULL); }

  TraceConfig_GuardrailOverrides* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TraceConfig_GuardrailOverrides& from);
  void MergeFrom(const TraceConfig_GuardrailOverrides& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TraceConfig_GuardrailOverrides* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 max_upload_per_day_bytes = 1;
  bool has_max_upload_per_day_bytes() const;
  void clear_max_upload_per_day_bytes();
  static const int kMaxUploadPerDayBytesFieldNumber = 1;
  ::google::protobuf::uint64 max_upload_per_day_bytes() const;
  void set_max_upload_per_day_bytes(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.TraceConfig.GuardrailOverrides)
 private:
  inline void set_has_max_upload_per_day_bytes();
  inline void clear_has_max_upload_per_day_bytes();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 max_upload_per_day_bytes_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static TraceConfig_GuardrailOverrides* default_instance_;
};
// -------------------------------------------------------------------

class TraceConfig_TriggerConfig_Trigger : public ::google::protobuf::MessageLite {
 public:
  TraceConfig_TriggerConfig_Trigger();
  virtual ~TraceConfig_TriggerConfig_Trigger();

  TraceConfig_TriggerConfig_Trigger(const TraceConfig_TriggerConfig_Trigger& from);

  inline TraceConfig_TriggerConfig_Trigger& operator=(const TraceConfig_TriggerConfig_Trigger& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TraceConfig_TriggerConfig_Trigger& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TraceConfig_TriggerConfig_Trigger* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TraceConfig_TriggerConfig_Trigger* other);

  // implements Message ----------------------------------------------

  inline TraceConfig_TriggerConfig_Trigger* New() const { return New(NULL); }

  TraceConfig_TriggerConfig_Trigger* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TraceConfig_TriggerConfig_Trigger& from);
  void MergeFrom(const TraceConfig_TriggerConfig_Trigger& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TraceConfig_TriggerConfig_Trigger* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string producer_name_regex = 2;
  bool has_producer_name_regex() const;
  void clear_producer_name_regex();
  static const int kProducerNameRegexFieldNumber = 2;
  const ::std::string& producer_name_regex() const;
  void set_producer_name_regex(const ::std::string& value);
  void set_producer_name_regex(const char* value);
  void set_producer_name_regex(const char* value, size_t size);
  ::std::string* mutable_producer_name_regex();
  ::std::string* release_producer_name_regex();
  void set_allocated_producer_name_regex(::std::string* producer_name_regex);

  // optional uint32 stop_delay_ms = 3;
  bool has_stop_delay_ms() const;
  void clear_stop_delay_ms();
  static const int kStopDelayMsFieldNumber = 3;
  ::google::protobuf::uint32 stop_delay_ms() const;
  void set_stop_delay_ms(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.TraceConfig.TriggerConfig.Trigger)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_producer_name_regex();
  inline void clear_has_producer_name_regex();
  inline void set_has_stop_delay_ms();
  inline void clear_has_stop_delay_ms();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr producer_name_regex_;
  ::google::protobuf::uint32 stop_delay_ms_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static TraceConfig_TriggerConfig_Trigger* default_instance_;
};
// -------------------------------------------------------------------

class TraceConfig_TriggerConfig : public ::google::protobuf::MessageLite {
 public:
  TraceConfig_TriggerConfig();
  virtual ~TraceConfig_TriggerConfig();

  TraceConfig_TriggerConfig(const TraceConfig_TriggerConfig& from);

  inline TraceConfig_TriggerConfig& operator=(const TraceConfig_TriggerConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TraceConfig_TriggerConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TraceConfig_TriggerConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TraceConfig_TriggerConfig* other);

  // implements Message ----------------------------------------------

  inline TraceConfig_TriggerConfig* New() const { return New(NULL); }

  TraceConfig_TriggerConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TraceConfig_TriggerConfig& from);
  void MergeFrom(const TraceConfig_TriggerConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TraceConfig_TriggerConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef TraceConfig_TriggerConfig_Trigger Trigger;

  typedef TraceConfig_TriggerConfig_TriggerMode TriggerMode;
  static const TriggerMode UNSPECIFIED =
    TraceConfig_TriggerConfig_TriggerMode_UNSPECIFIED;
  static const TriggerMode START_TRACING =
    TraceConfig_TriggerConfig_TriggerMode_START_TRACING;
  static const TriggerMode STOP_TRACING =
    TraceConfig_TriggerConfig_TriggerMode_STOP_TRACING;
  static inline bool TriggerMode_IsValid(int value) {
    return TraceConfig_TriggerConfig_TriggerMode_IsValid(value);
  }
  static const TriggerMode TriggerMode_MIN =
    TraceConfig_TriggerConfig_TriggerMode_TriggerMode_MIN;
  static const TriggerMode TriggerMode_MAX =
    TraceConfig_TriggerConfig_TriggerMode_TriggerMode_MAX;
  static const int TriggerMode_ARRAYSIZE =
    TraceConfig_TriggerConfig_TriggerMode_TriggerMode_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .perfetto.protos.TraceConfig.TriggerConfig.TriggerMode trigger_mode = 1;
  bool has_trigger_mode() const;
  void clear_trigger_mode();
  static const int kTriggerModeFieldNumber = 1;
  ::perfetto::protos::TraceConfig_TriggerConfig_TriggerMode trigger_mode() const;
  void set_trigger_mode(::perfetto::protos::TraceConfig_TriggerConfig_TriggerMode value);

  // repeated .perfetto.protos.TraceConfig.TriggerConfig.Trigger triggers = 2;
  int triggers_size() const;
  void clear_triggers();
  static const int kTriggersFieldNumber = 2;
  const ::perfetto::protos::TraceConfig_TriggerConfig_Trigger& triggers(int index) const;
  ::perfetto::protos::TraceConfig_TriggerConfig_Trigger* mutable_triggers(int index);
  ::perfetto::protos::TraceConfig_TriggerConfig_Trigger* add_triggers();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_TriggerConfig_Trigger >*
      mutable_triggers();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_TriggerConfig_Trigger >&
      triggers() const;

  // optional uint32 trigger_timeout_ms = 3;
  bool has_trigger_timeout_ms() const;
  void clear_trigger_timeout_ms();
  static const int kTriggerTimeoutMsFieldNumber = 3;
  ::google::protobuf::uint32 trigger_timeout_ms() const;
  void set_trigger_timeout_ms(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.TraceConfig.TriggerConfig)
 private:
  inline void set_has_trigger_mode();
  inline void clear_has_trigger_mode();
  inline void set_has_trigger_timeout_ms();
  inline void clear_has_trigger_timeout_ms();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_TriggerConfig_Trigger > triggers_;
  int trigger_mode_;
  ::google::protobuf::uint32 trigger_timeout_ms_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static TraceConfig_TriggerConfig* default_instance_;
};
// -------------------------------------------------------------------

class TraceConfig_IncrementalStateConfig : public ::google::protobuf::MessageLite {
 public:
  TraceConfig_IncrementalStateConfig();
  virtual ~TraceConfig_IncrementalStateConfig();

  TraceConfig_IncrementalStateConfig(const TraceConfig_IncrementalStateConfig& from);

  inline TraceConfig_IncrementalStateConfig& operator=(const TraceConfig_IncrementalStateConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TraceConfig_IncrementalStateConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TraceConfig_IncrementalStateConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TraceConfig_IncrementalStateConfig* other);

  // implements Message ----------------------------------------------

  inline TraceConfig_IncrementalStateConfig* New() const { return New(NULL); }

  TraceConfig_IncrementalStateConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TraceConfig_IncrementalStateConfig& from);
  void MergeFrom(const TraceConfig_IncrementalStateConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TraceConfig_IncrementalStateConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 clear_period_ms = 1;
  bool has_clear_period_ms() const;
  void clear_clear_period_ms();
  static const int kClearPeriodMsFieldNumber = 1;
  ::google::protobuf::uint32 clear_period_ms() const;
  void set_clear_period_ms(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.TraceConfig.IncrementalStateConfig)
 private:
  inline void set_has_clear_period_ms();
  inline void clear_has_clear_period_ms();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 clear_period_ms_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static TraceConfig_IncrementalStateConfig* default_instance_;
};
// -------------------------------------------------------------------

class TraceConfig_IncidentReportConfig : public ::google::protobuf::MessageLite {
 public:
  TraceConfig_IncidentReportConfig();
  virtual ~TraceConfig_IncidentReportConfig();

  TraceConfig_IncidentReportConfig(const TraceConfig_IncidentReportConfig& from);

  inline TraceConfig_IncidentReportConfig& operator=(const TraceConfig_IncidentReportConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TraceConfig_IncidentReportConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TraceConfig_IncidentReportConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TraceConfig_IncidentReportConfig* other);

  // implements Message ----------------------------------------------

  inline TraceConfig_IncidentReportConfig* New() const { return New(NULL); }

  TraceConfig_IncidentReportConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TraceConfig_IncidentReportConfig& from);
  void MergeFrom(const TraceConfig_IncidentReportConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TraceConfig_IncidentReportConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string destination_package = 1;
  bool has_destination_package() const;
  void clear_destination_package();
  static const int kDestinationPackageFieldNumber = 1;
  const ::std::string& destination_package() const;
  void set_destination_package(const ::std::string& value);
  void set_destination_package(const char* value);
  void set_destination_package(const char* value, size_t size);
  ::std::string* mutable_destination_package();
  ::std::string* release_destination_package();
  void set_allocated_destination_package(::std::string* destination_package);

  // optional string destination_class = 2;
  bool has_destination_class() const;
  void clear_destination_class();
  static const int kDestinationClassFieldNumber = 2;
  const ::std::string& destination_class() const;
  void set_destination_class(const ::std::string& value);
  void set_destination_class(const char* value);
  void set_destination_class(const char* value, size_t size);
  ::std::string* mutable_destination_class();
  ::std::string* release_destination_class();
  void set_allocated_destination_class(::std::string* destination_class);

  // optional int32 privacy_level = 3;
  bool has_privacy_level() const;
  void clear_privacy_level();
  static const int kPrivacyLevelFieldNumber = 3;
  ::google::protobuf::int32 privacy_level() const;
  void set_privacy_level(::google::protobuf::int32 value);

  // optional bool skip_dropbox = 4;
  bool has_skip_dropbox() const;
  void clear_skip_dropbox();
  static const int kSkipDropboxFieldNumber = 4;
  bool skip_dropbox() const;
  void set_skip_dropbox(bool value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.TraceConfig.IncidentReportConfig)
 private:
  inline void set_has_destination_package();
  inline void clear_has_destination_package();
  inline void set_has_destination_class();
  inline void clear_has_destination_class();
  inline void set_has_privacy_level();
  inline void clear_has_privacy_level();
  inline void set_has_skip_dropbox();
  inline void clear_has_skip_dropbox();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr destination_package_;
  ::google::protobuf::internal::ArenaStringPtr destination_class_;
  ::google::protobuf::int32 privacy_level_;
  bool skip_dropbox_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static TraceConfig_IncidentReportConfig* default_instance_;
};
// -------------------------------------------------------------------

class TraceConfig : public ::google::protobuf::MessageLite {
 public:
  TraceConfig();
  virtual ~TraceConfig();

  TraceConfig(const TraceConfig& from);

  inline TraceConfig& operator=(const TraceConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TraceConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TraceConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TraceConfig* other);

  // implements Message ----------------------------------------------

  inline TraceConfig* New() const { return New(NULL); }

  TraceConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TraceConfig& from);
  void MergeFrom(const TraceConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TraceConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef TraceConfig_BufferConfig BufferConfig;
  typedef TraceConfig_DataSource DataSource;
  typedef TraceConfig_BuiltinDataSource BuiltinDataSource;
  typedef TraceConfig_ProducerConfig ProducerConfig;
  typedef TraceConfig_StatsdMetadata StatsdMetadata;
  typedef TraceConfig_GuardrailOverrides GuardrailOverrides;
  typedef TraceConfig_TriggerConfig TriggerConfig;
  typedef TraceConfig_IncrementalStateConfig IncrementalStateConfig;
  typedef TraceConfig_IncidentReportConfig IncidentReportConfig;

  typedef TraceConfig_LockdownModeOperation LockdownModeOperation;
  static const LockdownModeOperation LOCKDOWN_UNCHANGED =
    TraceConfig_LockdownModeOperation_LOCKDOWN_UNCHANGED;
  static const LockdownModeOperation LOCKDOWN_CLEAR =
    TraceConfig_LockdownModeOperation_LOCKDOWN_CLEAR;
  static const LockdownModeOperation LOCKDOWN_SET =
    TraceConfig_LockdownModeOperation_LOCKDOWN_SET;
  static inline bool LockdownModeOperation_IsValid(int value) {
    return TraceConfig_LockdownModeOperation_IsValid(value);
  }
  static const LockdownModeOperation LockdownModeOperation_MIN =
    TraceConfig_LockdownModeOperation_LockdownModeOperation_MIN;
  static const LockdownModeOperation LockdownModeOperation_MAX =
    TraceConfig_LockdownModeOperation_LockdownModeOperation_MAX;
  static const int LockdownModeOperation_ARRAYSIZE =
    TraceConfig_LockdownModeOperation_LockdownModeOperation_ARRAYSIZE;

  typedef TraceConfig_CompressionType CompressionType;
  static const CompressionType COMPRESSION_TYPE_UNSPECIFIED =
    TraceConfig_CompressionType_COMPRESSION_TYPE_UNSPECIFIED;
  static const CompressionType COMPRESSION_TYPE_DEFLATE =
    TraceConfig_CompressionType_COMPRESSION_TYPE_DEFLATE;
  static inline bool CompressionType_IsValid(int value) {
    return TraceConfig_CompressionType_IsValid(value);
  }
  static const CompressionType CompressionType_MIN =
    TraceConfig_CompressionType_CompressionType_MIN;
  static const CompressionType CompressionType_MAX =
    TraceConfig_CompressionType_CompressionType_MAX;
  static const int CompressionType_ARRAYSIZE =
    TraceConfig_CompressionType_CompressionType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .perfetto.protos.TraceConfig.BufferConfig buffers = 1;
  int buffers_size() const;
  void clear_buffers();
  static const int kBuffersFieldNumber = 1;
  const ::perfetto::protos::TraceConfig_BufferConfig& buffers(int index) const;
  ::perfetto::protos::TraceConfig_BufferConfig* mutable_buffers(int index);
  ::perfetto::protos::TraceConfig_BufferConfig* add_buffers();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_BufferConfig >*
      mutable_buffers();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_BufferConfig >&
      buffers() const;

  // repeated .perfetto.protos.TraceConfig.DataSource data_sources = 2;
  int data_sources_size() const;
  void clear_data_sources();
  static const int kDataSourcesFieldNumber = 2;
  const ::perfetto::protos::TraceConfig_DataSource& data_sources(int index) const;
  ::perfetto::protos::TraceConfig_DataSource* mutable_data_sources(int index);
  ::perfetto::protos::TraceConfig_DataSource* add_data_sources();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_DataSource >*
      mutable_data_sources();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_DataSource >&
      data_sources() const;

  // optional .perfetto.protos.TraceConfig.BuiltinDataSource builtin_data_sources = 20;
  bool has_builtin_data_sources() const;
  void clear_builtin_data_sources();
  static const int kBuiltinDataSourcesFieldNumber = 20;
  const ::perfetto::protos::TraceConfig_BuiltinDataSource& builtin_data_sources() const;
  ::perfetto::protos::TraceConfig_BuiltinDataSource* mutable_builtin_data_sources();
  ::perfetto::protos::TraceConfig_BuiltinDataSource* release_builtin_data_sources();
  void set_allocated_builtin_data_sources(::perfetto::protos::TraceConfig_BuiltinDataSource* builtin_data_sources);

  // optional uint32 duration_ms = 3;
  bool has_duration_ms() const;
  void clear_duration_ms();
  static const int kDurationMsFieldNumber = 3;
  ::google::protobuf::uint32 duration_ms() const;
  void set_duration_ms(::google::protobuf::uint32 value);

  // optional bool enable_extra_guardrails = 4;
  bool has_enable_extra_guardrails() const;
  void clear_enable_extra_guardrails();
  static const int kEnableExtraGuardrailsFieldNumber = 4;
  bool enable_extra_guardrails() const;
  void set_enable_extra_guardrails(bool value);

  // optional .perfetto.protos.TraceConfig.LockdownModeOperation lockdown_mode = 5;
  bool has_lockdown_mode() const;
  void clear_lockdown_mode();
  static const int kLockdownModeFieldNumber = 5;
  ::perfetto::protos::TraceConfig_LockdownModeOperation lockdown_mode() const;
  void set_lockdown_mode(::perfetto::protos::TraceConfig_LockdownModeOperation value);

  // repeated .perfetto.protos.TraceConfig.ProducerConfig producers = 6;
  int producers_size() const;
  void clear_producers();
  static const int kProducersFieldNumber = 6;
  const ::perfetto::protos::TraceConfig_ProducerConfig& producers(int index) const;
  ::perfetto::protos::TraceConfig_ProducerConfig* mutable_producers(int index);
  ::perfetto::protos::TraceConfig_ProducerConfig* add_producers();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_ProducerConfig >*
      mutable_producers();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_ProducerConfig >&
      producers() const;

  // optional .perfetto.protos.TraceConfig.StatsdMetadata statsd_metadata = 7;
  bool has_statsd_metadata() const;
  void clear_statsd_metadata();
  static const int kStatsdMetadataFieldNumber = 7;
  const ::perfetto::protos::TraceConfig_StatsdMetadata& statsd_metadata() const;
  ::perfetto::protos::TraceConfig_StatsdMetadata* mutable_statsd_metadata();
  ::perfetto::protos::TraceConfig_StatsdMetadata* release_statsd_metadata();
  void set_allocated_statsd_metadata(::perfetto::protos::TraceConfig_StatsdMetadata* statsd_metadata);

  // optional bool write_into_file = 8;
  bool has_write_into_file() const;
  void clear_write_into_file();
  static const int kWriteIntoFileFieldNumber = 8;
  bool write_into_file() const;
  void set_write_into_file(bool value);

  // optional uint32 file_write_period_ms = 9;
  bool has_file_write_period_ms() const;
  void clear_file_write_period_ms();
  static const int kFileWritePeriodMsFieldNumber = 9;
  ::google::protobuf::uint32 file_write_period_ms() const;
  void set_file_write_period_ms(::google::protobuf::uint32 value);

  // optional uint64 max_file_size_bytes = 10;
  bool has_max_file_size_bytes() const;
  void clear_max_file_size_bytes();
  static const int kMaxFileSizeBytesFieldNumber = 10;
  ::google::protobuf::uint64 max_file_size_bytes() const;
  void set_max_file_size_bytes(::google::protobuf::uint64 value);

  // optional .perfetto.protos.TraceConfig.GuardrailOverrides guardrail_overrides = 11;
  bool has_guardrail_overrides() const;
  void clear_guardrail_overrides();
  static const int kGuardrailOverridesFieldNumber = 11;
  const ::perfetto::protos::TraceConfig_GuardrailOverrides& guardrail_overrides() const;
  ::perfetto::protos::TraceConfig_GuardrailOverrides* mutable_guardrail_overrides();
  ::perfetto::protos::TraceConfig_GuardrailOverrides* release_guardrail_overrides();
  void set_allocated_guardrail_overrides(::perfetto::protos::TraceConfig_GuardrailOverrides* guardrail_overrides);

  // optional bool deferred_start = 12;
  bool has_deferred_start() const;
  void clear_deferred_start();
  static const int kDeferredStartFieldNumber = 12;
  bool deferred_start() const;
  void set_deferred_start(bool value);

  // optional uint32 flush_period_ms = 13;
  bool has_flush_period_ms() const;
  void clear_flush_period_ms();
  static const int kFlushPeriodMsFieldNumber = 13;
  ::google::protobuf::uint32 flush_period_ms() const;
  void set_flush_period_ms(::google::protobuf::uint32 value);

  // optional uint32 flush_timeout_ms = 14;
  bool has_flush_timeout_ms() const;
  void clear_flush_timeout_ms();
  static const int kFlushTimeoutMsFieldNumber = 14;
  ::google::protobuf::uint32 flush_timeout_ms() const;
  void set_flush_timeout_ms(::google::protobuf::uint32 value);

  // optional uint32 data_source_stop_timeout_ms = 23;
  bool has_data_source_stop_timeout_ms() const;
  void clear_data_source_stop_timeout_ms();
  static const int kDataSourceStopTimeoutMsFieldNumber = 23;
  ::google::protobuf::uint32 data_source_stop_timeout_ms() const;
  void set_data_source_stop_timeout_ms(::google::protobuf::uint32 value);

  // optional bool notify_traceur = 16;
  bool has_notify_traceur() const;
  void clear_notify_traceur();
  static const int kNotifyTraceurFieldNumber = 16;
  bool notify_traceur() const;
  void set_notify_traceur(bool value);

  // optional .perfetto.protos.TraceConfig.TriggerConfig trigger_config = 17;
  bool has_trigger_config() const;
  void clear_trigger_config();
  static const int kTriggerConfigFieldNumber = 17;
  const ::perfetto::protos::TraceConfig_TriggerConfig& trigger_config() const;
  ::perfetto::protos::TraceConfig_TriggerConfig* mutable_trigger_config();
  ::perfetto::protos::TraceConfig_TriggerConfig* release_trigger_config();
  void set_allocated_trigger_config(::perfetto::protos::TraceConfig_TriggerConfig* trigger_config);

  // repeated string activate_triggers = 18;
  int activate_triggers_size() const;
  void clear_activate_triggers();
  static const int kActivateTriggersFieldNumber = 18;
  const ::std::string& activate_triggers(int index) const;
  ::std::string* mutable_activate_triggers(int index);
  void set_activate_triggers(int index, const ::std::string& value);
  void set_activate_triggers(int index, const char* value);
  void set_activate_triggers(int index, const char* value, size_t size);
  ::std::string* add_activate_triggers();
  void add_activate_triggers(const ::std::string& value);
  void add_activate_triggers(const char* value);
  void add_activate_triggers(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& activate_triggers() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_activate_triggers();

  // optional .perfetto.protos.TraceConfig.IncrementalStateConfig incremental_state_config = 21;
  bool has_incremental_state_config() const;
  void clear_incremental_state_config();
  static const int kIncrementalStateConfigFieldNumber = 21;
  const ::perfetto::protos::TraceConfig_IncrementalStateConfig& incremental_state_config() const;
  ::perfetto::protos::TraceConfig_IncrementalStateConfig* mutable_incremental_state_config();
  ::perfetto::protos::TraceConfig_IncrementalStateConfig* release_incremental_state_config();
  void set_allocated_incremental_state_config(::perfetto::protos::TraceConfig_IncrementalStateConfig* incremental_state_config);

  // optional bool allow_user_build_tracing = 19;
  bool has_allow_user_build_tracing() const;
  void clear_allow_user_build_tracing();
  static const int kAllowUserBuildTracingFieldNumber = 19;
  bool allow_user_build_tracing() const;
  void set_allow_user_build_tracing(bool value);

  // optional string unique_session_name = 22;
  bool has_unique_session_name() const;
  void clear_unique_session_name();
  static const int kUniqueSessionNameFieldNumber = 22;
  const ::std::string& unique_session_name() const;
  void set_unique_session_name(const ::std::string& value);
  void set_unique_session_name(const char* value);
  void set_unique_session_name(const char* value, size_t size);
  ::std::string* mutable_unique_session_name();
  ::std::string* release_unique_session_name();
  void set_allocated_unique_session_name(::std::string* unique_session_name);

  // optional .perfetto.protos.TraceConfig.CompressionType compression_type = 24;
  bool has_compression_type() const;
  void clear_compression_type();
  static const int kCompressionTypeFieldNumber = 24;
  ::perfetto::protos::TraceConfig_CompressionType compression_type() const;
  void set_compression_type(::perfetto::protos::TraceConfig_CompressionType value);

  // optional .perfetto.protos.TraceConfig.IncidentReportConfig incident_report_config = 25;
  bool has_incident_report_config() const;
  void clear_incident_report_config();
  static const int kIncidentReportConfigFieldNumber = 25;
  const ::perfetto::protos::TraceConfig_IncidentReportConfig& incident_report_config() const;
  ::perfetto::protos::TraceConfig_IncidentReportConfig* mutable_incident_report_config();
  ::perfetto::protos::TraceConfig_IncidentReportConfig* release_incident_report_config();
  void set_allocated_incident_report_config(::perfetto::protos::TraceConfig_IncidentReportConfig* incident_report_config);

  // optional bytes trace_uuid = 26;
  bool has_trace_uuid() const;
  void clear_trace_uuid();
  static const int kTraceUuidFieldNumber = 26;
  const ::std::string& trace_uuid() const;
  void set_trace_uuid(const ::std::string& value);
  void set_trace_uuid(const char* value);
  void set_trace_uuid(const void* value, size_t size);
  ::std::string* mutable_trace_uuid();
  ::std::string* release_trace_uuid();
  void set_allocated_trace_uuid(::std::string* trace_uuid);

  // @@protoc_insertion_point(class_scope:perfetto.protos.TraceConfig)
 private:
  inline void set_has_builtin_data_sources();
  inline void clear_has_builtin_data_sources();
  inline void set_has_duration_ms();
  inline void clear_has_duration_ms();
  inline void set_has_enable_extra_guardrails();
  inline void clear_has_enable_extra_guardrails();
  inline void set_has_lockdown_mode();
  inline void clear_has_lockdown_mode();
  inline void set_has_statsd_metadata();
  inline void clear_has_statsd_metadata();
  inline void set_has_write_into_file();
  inline void clear_has_write_into_file();
  inline void set_has_file_write_period_ms();
  inline void clear_has_file_write_period_ms();
  inline void set_has_max_file_size_bytes();
  inline void clear_has_max_file_size_bytes();
  inline void set_has_guardrail_overrides();
  inline void clear_has_guardrail_overrides();
  inline void set_has_deferred_start();
  inline void clear_has_deferred_start();
  inline void set_has_flush_period_ms();
  inline void clear_has_flush_period_ms();
  inline void set_has_flush_timeout_ms();
  inline void clear_has_flush_timeout_ms();
  inline void set_has_data_source_stop_timeout_ms();
  inline void clear_has_data_source_stop_timeout_ms();
  inline void set_has_notify_traceur();
  inline void clear_has_notify_traceur();
  inline void set_has_trigger_config();
  inline void clear_has_trigger_config();
  inline void set_has_incremental_state_config();
  inline void clear_has_incremental_state_config();
  inline void set_has_allow_user_build_tracing();
  inline void clear_has_allow_user_build_tracing();
  inline void set_has_unique_session_name();
  inline void clear_has_unique_session_name();
  inline void set_has_compression_type();
  inline void clear_has_compression_type();
  inline void set_has_incident_report_config();
  inline void clear_has_incident_report_config();
  inline void set_has_trace_uuid();
  inline void clear_has_trace_uuid();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_BufferConfig > buffers_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_DataSource > data_sources_;
  ::perfetto::protos::TraceConfig_BuiltinDataSource* builtin_data_sources_;
  ::google::protobuf::uint32 duration_ms_;
  int lockdown_mode_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_ProducerConfig > producers_;
  ::perfetto::protos::TraceConfig_StatsdMetadata* statsd_metadata_;
  ::google::protobuf::uint32 file_write_period_ms_;
  bool enable_extra_guardrails_;
  bool write_into_file_;
  bool deferred_start_;
  bool notify_traceur_;
  ::google::protobuf::uint64 max_file_size_bytes_;
  ::perfetto::protos::TraceConfig_GuardrailOverrides* guardrail_overrides_;
  ::google::protobuf::uint32 flush_period_ms_;
  ::google::protobuf::uint32 flush_timeout_ms_;
  ::perfetto::protos::TraceConfig_TriggerConfig* trigger_config_;
  ::google::protobuf::uint32 data_source_stop_timeout_ms_;
  bool allow_user_build_tracing_;
  ::google::protobuf::RepeatedPtrField< ::std::string> activate_triggers_;
  ::perfetto::protos::TraceConfig_IncrementalStateConfig* incremental_state_config_;
  ::google::protobuf::internal::ArenaStringPtr unique_session_name_;
  ::perfetto::protos::TraceConfig_IncidentReportConfig* incident_report_config_;
  ::google::protobuf::internal::ArenaStringPtr trace_uuid_;
  int compression_type_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static TraceConfig* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// TraceConfig_BufferConfig

// optional uint32 size_kb = 1;
inline bool TraceConfig_BufferConfig::has_size_kb() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TraceConfig_BufferConfig::set_has_size_kb() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TraceConfig_BufferConfig::clear_has_size_kb() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TraceConfig_BufferConfig::clear_size_kb() {
  size_kb_ = 0u;
  clear_has_size_kb();
}
inline ::google::protobuf::uint32 TraceConfig_BufferConfig::size_kb() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.BufferConfig.size_kb)
  return size_kb_;
}
inline void TraceConfig_BufferConfig::set_size_kb(::google::protobuf::uint32 value) {
  set_has_size_kb();
  size_kb_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.BufferConfig.size_kb)
}

// optional .perfetto.protos.TraceConfig.BufferConfig.FillPolicy fill_policy = 4;
inline bool TraceConfig_BufferConfig::has_fill_policy() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TraceConfig_BufferConfig::set_has_fill_policy() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TraceConfig_BufferConfig::clear_has_fill_policy() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TraceConfig_BufferConfig::clear_fill_policy() {
  fill_policy_ = 0;
  clear_has_fill_policy();
}
inline ::perfetto::protos::TraceConfig_BufferConfig_FillPolicy TraceConfig_BufferConfig::fill_policy() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.BufferConfig.fill_policy)
  return static_cast< ::perfetto::protos::TraceConfig_BufferConfig_FillPolicy >(fill_policy_);
}
inline void TraceConfig_BufferConfig::set_fill_policy(::perfetto::protos::TraceConfig_BufferConfig_FillPolicy value) {
  assert(::perfetto::protos::TraceConfig_BufferConfig_FillPolicy_IsValid(value));
  set_has_fill_policy();
  fill_policy_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.BufferConfig.fill_policy)
}

// -------------------------------------------------------------------

// TraceConfig_DataSource

// optional .perfetto.protos.DataSourceConfig config = 1;
inline bool TraceConfig_DataSource::has_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TraceConfig_DataSource::set_has_config() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TraceConfig_DataSource::clear_has_config() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TraceConfig_DataSource::clear_config() {
  if (config_ != NULL) config_->::perfetto::protos::DataSourceConfig::Clear();
  clear_has_config();
}
inline const ::perfetto::protos::DataSourceConfig& TraceConfig_DataSource::config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.DataSource.config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return config_ != NULL ? *config_ : *default_instance().config_;
#else
  return config_ != NULL ? *config_ : *default_instance_->config_;
#endif
}
inline ::perfetto::protos::DataSourceConfig* TraceConfig_DataSource::mutable_config() {
  set_has_config();
  if (config_ == NULL) {
    config_ = new ::perfetto::protos::DataSourceConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.DataSource.config)
  return config_;
}
inline ::perfetto::protos::DataSourceConfig* TraceConfig_DataSource::release_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.DataSource.config)
  clear_has_config();
  ::perfetto::protos::DataSourceConfig* temp = config_;
  config_ = NULL;
  return temp;
}
inline void TraceConfig_DataSource::set_allocated_config(::perfetto::protos::DataSourceConfig* config) {
  delete config_;
  config_ = config;
  if (config) {
    set_has_config();
  } else {
    clear_has_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.DataSource.config)
}

// repeated string producer_name_filter = 2;
inline int TraceConfig_DataSource::producer_name_filter_size() const {
  return producer_name_filter_.size();
}
inline void TraceConfig_DataSource::clear_producer_name_filter() {
  producer_name_filter_.Clear();
}
inline const ::std::string& TraceConfig_DataSource::producer_name_filter(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.DataSource.producer_name_filter)
  return producer_name_filter_.Get(index);
}
inline ::std::string* TraceConfig_DataSource::mutable_producer_name_filter(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.DataSource.producer_name_filter)
  return producer_name_filter_.Mutable(index);
}
inline void TraceConfig_DataSource::set_producer_name_filter(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.DataSource.producer_name_filter)
  producer_name_filter_.Mutable(index)->assign(value);
}
inline void TraceConfig_DataSource::set_producer_name_filter(int index, const char* value) {
  producer_name_filter_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.TraceConfig.DataSource.producer_name_filter)
}
inline void TraceConfig_DataSource::set_producer_name_filter(int index, const char* value, size_t size) {
  producer_name_filter_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.TraceConfig.DataSource.producer_name_filter)
}
inline ::std::string* TraceConfig_DataSource::add_producer_name_filter() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.TraceConfig.DataSource.producer_name_filter)
  return producer_name_filter_.Add();
}
inline void TraceConfig_DataSource::add_producer_name_filter(const ::std::string& value) {
  producer_name_filter_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.TraceConfig.DataSource.producer_name_filter)
}
inline void TraceConfig_DataSource::add_producer_name_filter(const char* value) {
  producer_name_filter_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.TraceConfig.DataSource.producer_name_filter)
}
inline void TraceConfig_DataSource::add_producer_name_filter(const char* value, size_t size) {
  producer_name_filter_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.TraceConfig.DataSource.producer_name_filter)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TraceConfig_DataSource::producer_name_filter() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.TraceConfig.DataSource.producer_name_filter)
  return producer_name_filter_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TraceConfig_DataSource::mutable_producer_name_filter() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.TraceConfig.DataSource.producer_name_filter)
  return &producer_name_filter_;
}

// -------------------------------------------------------------------

// TraceConfig_BuiltinDataSource

// optional bool disable_clock_snapshotting = 1;
inline bool TraceConfig_BuiltinDataSource::has_disable_clock_snapshotting() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TraceConfig_BuiltinDataSource::set_has_disable_clock_snapshotting() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TraceConfig_BuiltinDataSource::clear_has_disable_clock_snapshotting() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TraceConfig_BuiltinDataSource::clear_disable_clock_snapshotting() {
  disable_clock_snapshotting_ = false;
  clear_has_disable_clock_snapshotting();
}
inline bool TraceConfig_BuiltinDataSource::disable_clock_snapshotting() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.BuiltinDataSource.disable_clock_snapshotting)
  return disable_clock_snapshotting_;
}
inline void TraceConfig_BuiltinDataSource::set_disable_clock_snapshotting(bool value) {
  set_has_disable_clock_snapshotting();
  disable_clock_snapshotting_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.BuiltinDataSource.disable_clock_snapshotting)
}

// optional bool disable_trace_config = 2;
inline bool TraceConfig_BuiltinDataSource::has_disable_trace_config() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TraceConfig_BuiltinDataSource::set_has_disable_trace_config() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TraceConfig_BuiltinDataSource::clear_has_disable_trace_config() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TraceConfig_BuiltinDataSource::clear_disable_trace_config() {
  disable_trace_config_ = false;
  clear_has_disable_trace_config();
}
inline bool TraceConfig_BuiltinDataSource::disable_trace_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.BuiltinDataSource.disable_trace_config)
  return disable_trace_config_;
}
inline void TraceConfig_BuiltinDataSource::set_disable_trace_config(bool value) {
  set_has_disable_trace_config();
  disable_trace_config_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.BuiltinDataSource.disable_trace_config)
}

// optional bool disable_system_info = 3;
inline bool TraceConfig_BuiltinDataSource::has_disable_system_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TraceConfig_BuiltinDataSource::set_has_disable_system_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TraceConfig_BuiltinDataSource::clear_has_disable_system_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TraceConfig_BuiltinDataSource::clear_disable_system_info() {
  disable_system_info_ = false;
  clear_has_disable_system_info();
}
inline bool TraceConfig_BuiltinDataSource::disable_system_info() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.BuiltinDataSource.disable_system_info)
  return disable_system_info_;
}
inline void TraceConfig_BuiltinDataSource::set_disable_system_info(bool value) {
  set_has_disable_system_info();
  disable_system_info_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.BuiltinDataSource.disable_system_info)
}

// -------------------------------------------------------------------

// TraceConfig_ProducerConfig

// optional string producer_name = 1;
inline bool TraceConfig_ProducerConfig::has_producer_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TraceConfig_ProducerConfig::set_has_producer_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TraceConfig_ProducerConfig::clear_has_producer_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TraceConfig_ProducerConfig::clear_producer_name() {
  producer_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_producer_name();
}
inline const ::std::string& TraceConfig_ProducerConfig::producer_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.ProducerConfig.producer_name)
  return producer_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TraceConfig_ProducerConfig::set_producer_name(const ::std::string& value) {
  set_has_producer_name();
  producer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.ProducerConfig.producer_name)
}
inline void TraceConfig_ProducerConfig::set_producer_name(const char* value) {
  set_has_producer_name();
  producer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.TraceConfig.ProducerConfig.producer_name)
}
inline void TraceConfig_ProducerConfig::set_producer_name(const char* value, size_t size) {
  set_has_producer_name();
  producer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.TraceConfig.ProducerConfig.producer_name)
}
inline ::std::string* TraceConfig_ProducerConfig::mutable_producer_name() {
  set_has_producer_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.ProducerConfig.producer_name)
  return producer_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TraceConfig_ProducerConfig::release_producer_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.ProducerConfig.producer_name)
  clear_has_producer_name();
  return producer_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TraceConfig_ProducerConfig::set_allocated_producer_name(::std::string* producer_name) {
  if (producer_name != NULL) {
    set_has_producer_name();
  } else {
    clear_has_producer_name();
  }
  producer_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), producer_name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.ProducerConfig.producer_name)
}

// optional uint32 shm_size_kb = 2;
inline bool TraceConfig_ProducerConfig::has_shm_size_kb() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TraceConfig_ProducerConfig::set_has_shm_size_kb() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TraceConfig_ProducerConfig::clear_has_shm_size_kb() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TraceConfig_ProducerConfig::clear_shm_size_kb() {
  shm_size_kb_ = 0u;
  clear_has_shm_size_kb();
}
inline ::google::protobuf::uint32 TraceConfig_ProducerConfig::shm_size_kb() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.ProducerConfig.shm_size_kb)
  return shm_size_kb_;
}
inline void TraceConfig_ProducerConfig::set_shm_size_kb(::google::protobuf::uint32 value) {
  set_has_shm_size_kb();
  shm_size_kb_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.ProducerConfig.shm_size_kb)
}

// optional uint32 page_size_kb = 3;
inline bool TraceConfig_ProducerConfig::has_page_size_kb() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TraceConfig_ProducerConfig::set_has_page_size_kb() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TraceConfig_ProducerConfig::clear_has_page_size_kb() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TraceConfig_ProducerConfig::clear_page_size_kb() {
  page_size_kb_ = 0u;
  clear_has_page_size_kb();
}
inline ::google::protobuf::uint32 TraceConfig_ProducerConfig::page_size_kb() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.ProducerConfig.page_size_kb)
  return page_size_kb_;
}
inline void TraceConfig_ProducerConfig::set_page_size_kb(::google::protobuf::uint32 value) {
  set_has_page_size_kb();
  page_size_kb_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.ProducerConfig.page_size_kb)
}

// -------------------------------------------------------------------

// TraceConfig_StatsdMetadata

// optional int64 triggering_alert_id = 1;
inline bool TraceConfig_StatsdMetadata::has_triggering_alert_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TraceConfig_StatsdMetadata::set_has_triggering_alert_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TraceConfig_StatsdMetadata::clear_has_triggering_alert_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TraceConfig_StatsdMetadata::clear_triggering_alert_id() {
  triggering_alert_id_ = GOOGLE_LONGLONG(0);
  clear_has_triggering_alert_id();
}
inline ::google::protobuf::int64 TraceConfig_StatsdMetadata::triggering_alert_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.StatsdMetadata.triggering_alert_id)
  return triggering_alert_id_;
}
inline void TraceConfig_StatsdMetadata::set_triggering_alert_id(::google::protobuf::int64 value) {
  set_has_triggering_alert_id();
  triggering_alert_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.StatsdMetadata.triggering_alert_id)
}

// optional int32 triggering_config_uid = 2;
inline bool TraceConfig_StatsdMetadata::has_triggering_config_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TraceConfig_StatsdMetadata::set_has_triggering_config_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TraceConfig_StatsdMetadata::clear_has_triggering_config_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TraceConfig_StatsdMetadata::clear_triggering_config_uid() {
  triggering_config_uid_ = 0;
  clear_has_triggering_config_uid();
}
inline ::google::protobuf::int32 TraceConfig_StatsdMetadata::triggering_config_uid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.StatsdMetadata.triggering_config_uid)
  return triggering_config_uid_;
}
inline void TraceConfig_StatsdMetadata::set_triggering_config_uid(::google::protobuf::int32 value) {
  set_has_triggering_config_uid();
  triggering_config_uid_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.StatsdMetadata.triggering_config_uid)
}

// optional int64 triggering_config_id = 3;
inline bool TraceConfig_StatsdMetadata::has_triggering_config_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TraceConfig_StatsdMetadata::set_has_triggering_config_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TraceConfig_StatsdMetadata::clear_has_triggering_config_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TraceConfig_StatsdMetadata::clear_triggering_config_id() {
  triggering_config_id_ = GOOGLE_LONGLONG(0);
  clear_has_triggering_config_id();
}
inline ::google::protobuf::int64 TraceConfig_StatsdMetadata::triggering_config_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.StatsdMetadata.triggering_config_id)
  return triggering_config_id_;
}
inline void TraceConfig_StatsdMetadata::set_triggering_config_id(::google::protobuf::int64 value) {
  set_has_triggering_config_id();
  triggering_config_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.StatsdMetadata.triggering_config_id)
}

// optional int64 triggering_subscription_id = 4;
inline bool TraceConfig_StatsdMetadata::has_triggering_subscription_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TraceConfig_StatsdMetadata::set_has_triggering_subscription_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TraceConfig_StatsdMetadata::clear_has_triggering_subscription_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TraceConfig_StatsdMetadata::clear_triggering_subscription_id() {
  triggering_subscription_id_ = GOOGLE_LONGLONG(0);
  clear_has_triggering_subscription_id();
}
inline ::google::protobuf::int64 TraceConfig_StatsdMetadata::triggering_subscription_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.StatsdMetadata.triggering_subscription_id)
  return triggering_subscription_id_;
}
inline void TraceConfig_StatsdMetadata::set_triggering_subscription_id(::google::protobuf::int64 value) {
  set_has_triggering_subscription_id();
  triggering_subscription_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.StatsdMetadata.triggering_subscription_id)
}

// -------------------------------------------------------------------

// TraceConfig_GuardrailOverrides

// optional uint64 max_upload_per_day_bytes = 1;
inline bool TraceConfig_GuardrailOverrides::has_max_upload_per_day_bytes() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TraceConfig_GuardrailOverrides::set_has_max_upload_per_day_bytes() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TraceConfig_GuardrailOverrides::clear_has_max_upload_per_day_bytes() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TraceConfig_GuardrailOverrides::clear_max_upload_per_day_bytes() {
  max_upload_per_day_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_max_upload_per_day_bytes();
}
inline ::google::protobuf::uint64 TraceConfig_GuardrailOverrides::max_upload_per_day_bytes() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.GuardrailOverrides.max_upload_per_day_bytes)
  return max_upload_per_day_bytes_;
}
inline void TraceConfig_GuardrailOverrides::set_max_upload_per_day_bytes(::google::protobuf::uint64 value) {
  set_has_max_upload_per_day_bytes();
  max_upload_per_day_bytes_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.GuardrailOverrides.max_upload_per_day_bytes)
}

// -------------------------------------------------------------------

// TraceConfig_TriggerConfig_Trigger

// optional string name = 1;
inline bool TraceConfig_TriggerConfig_Trigger::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TraceConfig_TriggerConfig_Trigger::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TraceConfig_TriggerConfig_Trigger::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TraceConfig_TriggerConfig_Trigger::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& TraceConfig_TriggerConfig_Trigger::name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.TriggerConfig.Trigger.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TraceConfig_TriggerConfig_Trigger::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.TriggerConfig.Trigger.name)
}
inline void TraceConfig_TriggerConfig_Trigger::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.TraceConfig.TriggerConfig.Trigger.name)
}
inline void TraceConfig_TriggerConfig_Trigger::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.TraceConfig.TriggerConfig.Trigger.name)
}
inline ::std::string* TraceConfig_TriggerConfig_Trigger::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.TriggerConfig.Trigger.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TraceConfig_TriggerConfig_Trigger::release_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.TriggerConfig.Trigger.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TraceConfig_TriggerConfig_Trigger::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.TriggerConfig.Trigger.name)
}

// optional string producer_name_regex = 2;
inline bool TraceConfig_TriggerConfig_Trigger::has_producer_name_regex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TraceConfig_TriggerConfig_Trigger::set_has_producer_name_regex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TraceConfig_TriggerConfig_Trigger::clear_has_producer_name_regex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TraceConfig_TriggerConfig_Trigger::clear_producer_name_regex() {
  producer_name_regex_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_producer_name_regex();
}
inline const ::std::string& TraceConfig_TriggerConfig_Trigger::producer_name_regex() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.TriggerConfig.Trigger.producer_name_regex)
  return producer_name_regex_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TraceConfig_TriggerConfig_Trigger::set_producer_name_regex(const ::std::string& value) {
  set_has_producer_name_regex();
  producer_name_regex_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.TriggerConfig.Trigger.producer_name_regex)
}
inline void TraceConfig_TriggerConfig_Trigger::set_producer_name_regex(const char* value) {
  set_has_producer_name_regex();
  producer_name_regex_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.TraceConfig.TriggerConfig.Trigger.producer_name_regex)
}
inline void TraceConfig_TriggerConfig_Trigger::set_producer_name_regex(const char* value, size_t size) {
  set_has_producer_name_regex();
  producer_name_regex_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.TraceConfig.TriggerConfig.Trigger.producer_name_regex)
}
inline ::std::string* TraceConfig_TriggerConfig_Trigger::mutable_producer_name_regex() {
  set_has_producer_name_regex();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.TriggerConfig.Trigger.producer_name_regex)
  return producer_name_regex_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TraceConfig_TriggerConfig_Trigger::release_producer_name_regex() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.TriggerConfig.Trigger.producer_name_regex)
  clear_has_producer_name_regex();
  return producer_name_regex_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TraceConfig_TriggerConfig_Trigger::set_allocated_producer_name_regex(::std::string* producer_name_regex) {
  if (producer_name_regex != NULL) {
    set_has_producer_name_regex();
  } else {
    clear_has_producer_name_regex();
  }
  producer_name_regex_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), producer_name_regex);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.TriggerConfig.Trigger.producer_name_regex)
}

// optional uint32 stop_delay_ms = 3;
inline bool TraceConfig_TriggerConfig_Trigger::has_stop_delay_ms() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TraceConfig_TriggerConfig_Trigger::set_has_stop_delay_ms() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TraceConfig_TriggerConfig_Trigger::clear_has_stop_delay_ms() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TraceConfig_TriggerConfig_Trigger::clear_stop_delay_ms() {
  stop_delay_ms_ = 0u;
  clear_has_stop_delay_ms();
}
inline ::google::protobuf::uint32 TraceConfig_TriggerConfig_Trigger::stop_delay_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.TriggerConfig.Trigger.stop_delay_ms)
  return stop_delay_ms_;
}
inline void TraceConfig_TriggerConfig_Trigger::set_stop_delay_ms(::google::protobuf::uint32 value) {
  set_has_stop_delay_ms();
  stop_delay_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.TriggerConfig.Trigger.stop_delay_ms)
}

// -------------------------------------------------------------------

// TraceConfig_TriggerConfig

// optional .perfetto.protos.TraceConfig.TriggerConfig.TriggerMode trigger_mode = 1;
inline bool TraceConfig_TriggerConfig::has_trigger_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TraceConfig_TriggerConfig::set_has_trigger_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TraceConfig_TriggerConfig::clear_has_trigger_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TraceConfig_TriggerConfig::clear_trigger_mode() {
  trigger_mode_ = 0;
  clear_has_trigger_mode();
}
inline ::perfetto::protos::TraceConfig_TriggerConfig_TriggerMode TraceConfig_TriggerConfig::trigger_mode() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.TriggerConfig.trigger_mode)
  return static_cast< ::perfetto::protos::TraceConfig_TriggerConfig_TriggerMode >(trigger_mode_);
}
inline void TraceConfig_TriggerConfig::set_trigger_mode(::perfetto::protos::TraceConfig_TriggerConfig_TriggerMode value) {
  assert(::perfetto::protos::TraceConfig_TriggerConfig_TriggerMode_IsValid(value));
  set_has_trigger_mode();
  trigger_mode_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.TriggerConfig.trigger_mode)
}

// repeated .perfetto.protos.TraceConfig.TriggerConfig.Trigger triggers = 2;
inline int TraceConfig_TriggerConfig::triggers_size() const {
  return triggers_.size();
}
inline void TraceConfig_TriggerConfig::clear_triggers() {
  triggers_.Clear();
}
inline const ::perfetto::protos::TraceConfig_TriggerConfig_Trigger& TraceConfig_TriggerConfig::triggers(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.TriggerConfig.triggers)
  return triggers_.Get(index);
}
inline ::perfetto::protos::TraceConfig_TriggerConfig_Trigger* TraceConfig_TriggerConfig::mutable_triggers(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.TriggerConfig.triggers)
  return triggers_.Mutable(index);
}
inline ::perfetto::protos::TraceConfig_TriggerConfig_Trigger* TraceConfig_TriggerConfig::add_triggers() {
  // @@protoc_insertion_point(field_add:perfetto.protos.TraceConfig.TriggerConfig.triggers)
  return triggers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_TriggerConfig_Trigger >*
TraceConfig_TriggerConfig::mutable_triggers() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.TraceConfig.TriggerConfig.triggers)
  return &triggers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_TriggerConfig_Trigger >&
TraceConfig_TriggerConfig::triggers() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.TraceConfig.TriggerConfig.triggers)
  return triggers_;
}

// optional uint32 trigger_timeout_ms = 3;
inline bool TraceConfig_TriggerConfig::has_trigger_timeout_ms() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TraceConfig_TriggerConfig::set_has_trigger_timeout_ms() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TraceConfig_TriggerConfig::clear_has_trigger_timeout_ms() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TraceConfig_TriggerConfig::clear_trigger_timeout_ms() {
  trigger_timeout_ms_ = 0u;
  clear_has_trigger_timeout_ms();
}
inline ::google::protobuf::uint32 TraceConfig_TriggerConfig::trigger_timeout_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.TriggerConfig.trigger_timeout_ms)
  return trigger_timeout_ms_;
}
inline void TraceConfig_TriggerConfig::set_trigger_timeout_ms(::google::protobuf::uint32 value) {
  set_has_trigger_timeout_ms();
  trigger_timeout_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.TriggerConfig.trigger_timeout_ms)
}

// -------------------------------------------------------------------

// TraceConfig_IncrementalStateConfig

// optional uint32 clear_period_ms = 1;
inline bool TraceConfig_IncrementalStateConfig::has_clear_period_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TraceConfig_IncrementalStateConfig::set_has_clear_period_ms() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TraceConfig_IncrementalStateConfig::clear_has_clear_period_ms() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TraceConfig_IncrementalStateConfig::clear_clear_period_ms() {
  clear_period_ms_ = 0u;
  clear_has_clear_period_ms();
}
inline ::google::protobuf::uint32 TraceConfig_IncrementalStateConfig::clear_period_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.IncrementalStateConfig.clear_period_ms)
  return clear_period_ms_;
}
inline void TraceConfig_IncrementalStateConfig::set_clear_period_ms(::google::protobuf::uint32 value) {
  set_has_clear_period_ms();
  clear_period_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.IncrementalStateConfig.clear_period_ms)
}

// -------------------------------------------------------------------

// TraceConfig_IncidentReportConfig

// optional string destination_package = 1;
inline bool TraceConfig_IncidentReportConfig::has_destination_package() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TraceConfig_IncidentReportConfig::set_has_destination_package() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TraceConfig_IncidentReportConfig::clear_has_destination_package() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TraceConfig_IncidentReportConfig::clear_destination_package() {
  destination_package_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_destination_package();
}
inline const ::std::string& TraceConfig_IncidentReportConfig::destination_package() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.IncidentReportConfig.destination_package)
  return destination_package_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TraceConfig_IncidentReportConfig::set_destination_package(const ::std::string& value) {
  set_has_destination_package();
  destination_package_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.IncidentReportConfig.destination_package)
}
inline void TraceConfig_IncidentReportConfig::set_destination_package(const char* value) {
  set_has_destination_package();
  destination_package_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.TraceConfig.IncidentReportConfig.destination_package)
}
inline void TraceConfig_IncidentReportConfig::set_destination_package(const char* value, size_t size) {
  set_has_destination_package();
  destination_package_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.TraceConfig.IncidentReportConfig.destination_package)
}
inline ::std::string* TraceConfig_IncidentReportConfig::mutable_destination_package() {
  set_has_destination_package();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.IncidentReportConfig.destination_package)
  return destination_package_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TraceConfig_IncidentReportConfig::release_destination_package() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.IncidentReportConfig.destination_package)
  clear_has_destination_package();
  return destination_package_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TraceConfig_IncidentReportConfig::set_allocated_destination_package(::std::string* destination_package) {
  if (destination_package != NULL) {
    set_has_destination_package();
  } else {
    clear_has_destination_package();
  }
  destination_package_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), destination_package);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.IncidentReportConfig.destination_package)
}

// optional string destination_class = 2;
inline bool TraceConfig_IncidentReportConfig::has_destination_class() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TraceConfig_IncidentReportConfig::set_has_destination_class() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TraceConfig_IncidentReportConfig::clear_has_destination_class() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TraceConfig_IncidentReportConfig::clear_destination_class() {
  destination_class_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_destination_class();
}
inline const ::std::string& TraceConfig_IncidentReportConfig::destination_class() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.IncidentReportConfig.destination_class)
  return destination_class_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TraceConfig_IncidentReportConfig::set_destination_class(const ::std::string& value) {
  set_has_destination_class();
  destination_class_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.IncidentReportConfig.destination_class)
}
inline void TraceConfig_IncidentReportConfig::set_destination_class(const char* value) {
  set_has_destination_class();
  destination_class_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.TraceConfig.IncidentReportConfig.destination_class)
}
inline void TraceConfig_IncidentReportConfig::set_destination_class(const char* value, size_t size) {
  set_has_destination_class();
  destination_class_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.TraceConfig.IncidentReportConfig.destination_class)
}
inline ::std::string* TraceConfig_IncidentReportConfig::mutable_destination_class() {
  set_has_destination_class();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.IncidentReportConfig.destination_class)
  return destination_class_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TraceConfig_IncidentReportConfig::release_destination_class() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.IncidentReportConfig.destination_class)
  clear_has_destination_class();
  return destination_class_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TraceConfig_IncidentReportConfig::set_allocated_destination_class(::std::string* destination_class) {
  if (destination_class != NULL) {
    set_has_destination_class();
  } else {
    clear_has_destination_class();
  }
  destination_class_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), destination_class);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.IncidentReportConfig.destination_class)
}

// optional int32 privacy_level = 3;
inline bool TraceConfig_IncidentReportConfig::has_privacy_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TraceConfig_IncidentReportConfig::set_has_privacy_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TraceConfig_IncidentReportConfig::clear_has_privacy_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TraceConfig_IncidentReportConfig::clear_privacy_level() {
  privacy_level_ = 0;
  clear_has_privacy_level();
}
inline ::google::protobuf::int32 TraceConfig_IncidentReportConfig::privacy_level() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.IncidentReportConfig.privacy_level)
  return privacy_level_;
}
inline void TraceConfig_IncidentReportConfig::set_privacy_level(::google::protobuf::int32 value) {
  set_has_privacy_level();
  privacy_level_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.IncidentReportConfig.privacy_level)
}

// optional bool skip_dropbox = 4;
inline bool TraceConfig_IncidentReportConfig::has_skip_dropbox() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TraceConfig_IncidentReportConfig::set_has_skip_dropbox() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TraceConfig_IncidentReportConfig::clear_has_skip_dropbox() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TraceConfig_IncidentReportConfig::clear_skip_dropbox() {
  skip_dropbox_ = false;
  clear_has_skip_dropbox();
}
inline bool TraceConfig_IncidentReportConfig::skip_dropbox() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.IncidentReportConfig.skip_dropbox)
  return skip_dropbox_;
}
inline void TraceConfig_IncidentReportConfig::set_skip_dropbox(bool value) {
  set_has_skip_dropbox();
  skip_dropbox_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.IncidentReportConfig.skip_dropbox)
}

// -------------------------------------------------------------------

// TraceConfig

// repeated .perfetto.protos.TraceConfig.BufferConfig buffers = 1;
inline int TraceConfig::buffers_size() const {
  return buffers_.size();
}
inline void TraceConfig::clear_buffers() {
  buffers_.Clear();
}
inline const ::perfetto::protos::TraceConfig_BufferConfig& TraceConfig::buffers(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.buffers)
  return buffers_.Get(index);
}
inline ::perfetto::protos::TraceConfig_BufferConfig* TraceConfig::mutable_buffers(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.buffers)
  return buffers_.Mutable(index);
}
inline ::perfetto::protos::TraceConfig_BufferConfig* TraceConfig::add_buffers() {
  // @@protoc_insertion_point(field_add:perfetto.protos.TraceConfig.buffers)
  return buffers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_BufferConfig >*
TraceConfig::mutable_buffers() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.TraceConfig.buffers)
  return &buffers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_BufferConfig >&
TraceConfig::buffers() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.TraceConfig.buffers)
  return buffers_;
}

// repeated .perfetto.protos.TraceConfig.DataSource data_sources = 2;
inline int TraceConfig::data_sources_size() const {
  return data_sources_.size();
}
inline void TraceConfig::clear_data_sources() {
  data_sources_.Clear();
}
inline const ::perfetto::protos::TraceConfig_DataSource& TraceConfig::data_sources(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.data_sources)
  return data_sources_.Get(index);
}
inline ::perfetto::protos::TraceConfig_DataSource* TraceConfig::mutable_data_sources(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.data_sources)
  return data_sources_.Mutable(index);
}
inline ::perfetto::protos::TraceConfig_DataSource* TraceConfig::add_data_sources() {
  // @@protoc_insertion_point(field_add:perfetto.protos.TraceConfig.data_sources)
  return data_sources_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_DataSource >*
TraceConfig::mutable_data_sources() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.TraceConfig.data_sources)
  return &data_sources_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_DataSource >&
TraceConfig::data_sources() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.TraceConfig.data_sources)
  return data_sources_;
}

// optional .perfetto.protos.TraceConfig.BuiltinDataSource builtin_data_sources = 20;
inline bool TraceConfig::has_builtin_data_sources() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TraceConfig::set_has_builtin_data_sources() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TraceConfig::clear_has_builtin_data_sources() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TraceConfig::clear_builtin_data_sources() {
  if (builtin_data_sources_ != NULL) builtin_data_sources_->::perfetto::protos::TraceConfig_BuiltinDataSource::Clear();
  clear_has_builtin_data_sources();
}
inline const ::perfetto::protos::TraceConfig_BuiltinDataSource& TraceConfig::builtin_data_sources() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.builtin_data_sources)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return builtin_data_sources_ != NULL ? *builtin_data_sources_ : *default_instance().builtin_data_sources_;
#else
  return builtin_data_sources_ != NULL ? *builtin_data_sources_ : *default_instance_->builtin_data_sources_;
#endif
}
inline ::perfetto::protos::TraceConfig_BuiltinDataSource* TraceConfig::mutable_builtin_data_sources() {
  set_has_builtin_data_sources();
  if (builtin_data_sources_ == NULL) {
    builtin_data_sources_ = new ::perfetto::protos::TraceConfig_BuiltinDataSource;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.builtin_data_sources)
  return builtin_data_sources_;
}
inline ::perfetto::protos::TraceConfig_BuiltinDataSource* TraceConfig::release_builtin_data_sources() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.builtin_data_sources)
  clear_has_builtin_data_sources();
  ::perfetto::protos::TraceConfig_BuiltinDataSource* temp = builtin_data_sources_;
  builtin_data_sources_ = NULL;
  return temp;
}
inline void TraceConfig::set_allocated_builtin_data_sources(::perfetto::protos::TraceConfig_BuiltinDataSource* builtin_data_sources) {
  delete builtin_data_sources_;
  builtin_data_sources_ = builtin_data_sources;
  if (builtin_data_sources) {
    set_has_builtin_data_sources();
  } else {
    clear_has_builtin_data_sources();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.builtin_data_sources)
}

// optional uint32 duration_ms = 3;
inline bool TraceConfig::has_duration_ms() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TraceConfig::set_has_duration_ms() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TraceConfig::clear_has_duration_ms() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TraceConfig::clear_duration_ms() {
  duration_ms_ = 0u;
  clear_has_duration_ms();
}
inline ::google::protobuf::uint32 TraceConfig::duration_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.duration_ms)
  return duration_ms_;
}
inline void TraceConfig::set_duration_ms(::google::protobuf::uint32 value) {
  set_has_duration_ms();
  duration_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.duration_ms)
}

// optional bool enable_extra_guardrails = 4;
inline bool TraceConfig::has_enable_extra_guardrails() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TraceConfig::set_has_enable_extra_guardrails() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TraceConfig::clear_has_enable_extra_guardrails() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TraceConfig::clear_enable_extra_guardrails() {
  enable_extra_guardrails_ = false;
  clear_has_enable_extra_guardrails();
}
inline bool TraceConfig::enable_extra_guardrails() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.enable_extra_guardrails)
  return enable_extra_guardrails_;
}
inline void TraceConfig::set_enable_extra_guardrails(bool value) {
  set_has_enable_extra_guardrails();
  enable_extra_guardrails_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.enable_extra_guardrails)
}

// optional .perfetto.protos.TraceConfig.LockdownModeOperation lockdown_mode = 5;
inline bool TraceConfig::has_lockdown_mode() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TraceConfig::set_has_lockdown_mode() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TraceConfig::clear_has_lockdown_mode() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TraceConfig::clear_lockdown_mode() {
  lockdown_mode_ = 0;
  clear_has_lockdown_mode();
}
inline ::perfetto::protos::TraceConfig_LockdownModeOperation TraceConfig::lockdown_mode() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.lockdown_mode)
  return static_cast< ::perfetto::protos::TraceConfig_LockdownModeOperation >(lockdown_mode_);
}
inline void TraceConfig::set_lockdown_mode(::perfetto::protos::TraceConfig_LockdownModeOperation value) {
  assert(::perfetto::protos::TraceConfig_LockdownModeOperation_IsValid(value));
  set_has_lockdown_mode();
  lockdown_mode_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.lockdown_mode)
}

// repeated .perfetto.protos.TraceConfig.ProducerConfig producers = 6;
inline int TraceConfig::producers_size() const {
  return producers_.size();
}
inline void TraceConfig::clear_producers() {
  producers_.Clear();
}
inline const ::perfetto::protos::TraceConfig_ProducerConfig& TraceConfig::producers(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.producers)
  return producers_.Get(index);
}
inline ::perfetto::protos::TraceConfig_ProducerConfig* TraceConfig::mutable_producers(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.producers)
  return producers_.Mutable(index);
}
inline ::perfetto::protos::TraceConfig_ProducerConfig* TraceConfig::add_producers() {
  // @@protoc_insertion_point(field_add:perfetto.protos.TraceConfig.producers)
  return producers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_ProducerConfig >*
TraceConfig::mutable_producers() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.TraceConfig.producers)
  return &producers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_ProducerConfig >&
TraceConfig::producers() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.TraceConfig.producers)
  return producers_;
}

// optional .perfetto.protos.TraceConfig.StatsdMetadata statsd_metadata = 7;
inline bool TraceConfig::has_statsd_metadata() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TraceConfig::set_has_statsd_metadata() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TraceConfig::clear_has_statsd_metadata() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TraceConfig::clear_statsd_metadata() {
  if (statsd_metadata_ != NULL) statsd_metadata_->::perfetto::protos::TraceConfig_StatsdMetadata::Clear();
  clear_has_statsd_metadata();
}
inline const ::perfetto::protos::TraceConfig_StatsdMetadata& TraceConfig::statsd_metadata() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.statsd_metadata)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return statsd_metadata_ != NULL ? *statsd_metadata_ : *default_instance().statsd_metadata_;
#else
  return statsd_metadata_ != NULL ? *statsd_metadata_ : *default_instance_->statsd_metadata_;
#endif
}
inline ::perfetto::protos::TraceConfig_StatsdMetadata* TraceConfig::mutable_statsd_metadata() {
  set_has_statsd_metadata();
  if (statsd_metadata_ == NULL) {
    statsd_metadata_ = new ::perfetto::protos::TraceConfig_StatsdMetadata;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.statsd_metadata)
  return statsd_metadata_;
}
inline ::perfetto::protos::TraceConfig_StatsdMetadata* TraceConfig::release_statsd_metadata() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.statsd_metadata)
  clear_has_statsd_metadata();
  ::perfetto::protos::TraceConfig_StatsdMetadata* temp = statsd_metadata_;
  statsd_metadata_ = NULL;
  return temp;
}
inline void TraceConfig::set_allocated_statsd_metadata(::perfetto::protos::TraceConfig_StatsdMetadata* statsd_metadata) {
  delete statsd_metadata_;
  statsd_metadata_ = statsd_metadata;
  if (statsd_metadata) {
    set_has_statsd_metadata();
  } else {
    clear_has_statsd_metadata();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.statsd_metadata)
}

// optional bool write_into_file = 8;
inline bool TraceConfig::has_write_into_file() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TraceConfig::set_has_write_into_file() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TraceConfig::clear_has_write_into_file() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TraceConfig::clear_write_into_file() {
  write_into_file_ = false;
  clear_has_write_into_file();
}
inline bool TraceConfig::write_into_file() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.write_into_file)
  return write_into_file_;
}
inline void TraceConfig::set_write_into_file(bool value) {
  set_has_write_into_file();
  write_into_file_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.write_into_file)
}

// optional uint32 file_write_period_ms = 9;
inline bool TraceConfig::has_file_write_period_ms() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TraceConfig::set_has_file_write_period_ms() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TraceConfig::clear_has_file_write_period_ms() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TraceConfig::clear_file_write_period_ms() {
  file_write_period_ms_ = 0u;
  clear_has_file_write_period_ms();
}
inline ::google::protobuf::uint32 TraceConfig::file_write_period_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.file_write_period_ms)
  return file_write_period_ms_;
}
inline void TraceConfig::set_file_write_period_ms(::google::protobuf::uint32 value) {
  set_has_file_write_period_ms();
  file_write_period_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.file_write_period_ms)
}

// optional uint64 max_file_size_bytes = 10;
inline bool TraceConfig::has_max_file_size_bytes() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TraceConfig::set_has_max_file_size_bytes() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TraceConfig::clear_has_max_file_size_bytes() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TraceConfig::clear_max_file_size_bytes() {
  max_file_size_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_max_file_size_bytes();
}
inline ::google::protobuf::uint64 TraceConfig::max_file_size_bytes() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.max_file_size_bytes)
  return max_file_size_bytes_;
}
inline void TraceConfig::set_max_file_size_bytes(::google::protobuf::uint64 value) {
  set_has_max_file_size_bytes();
  max_file_size_bytes_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.max_file_size_bytes)
}

// optional .perfetto.protos.TraceConfig.GuardrailOverrides guardrail_overrides = 11;
inline bool TraceConfig::has_guardrail_overrides() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TraceConfig::set_has_guardrail_overrides() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TraceConfig::clear_has_guardrail_overrides() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TraceConfig::clear_guardrail_overrides() {
  if (guardrail_overrides_ != NULL) guardrail_overrides_->::perfetto::protos::TraceConfig_GuardrailOverrides::Clear();
  clear_has_guardrail_overrides();
}
inline const ::perfetto::protos::TraceConfig_GuardrailOverrides& TraceConfig::guardrail_overrides() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.guardrail_overrides)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return guardrail_overrides_ != NULL ? *guardrail_overrides_ : *default_instance().guardrail_overrides_;
#else
  return guardrail_overrides_ != NULL ? *guardrail_overrides_ : *default_instance_->guardrail_overrides_;
#endif
}
inline ::perfetto::protos::TraceConfig_GuardrailOverrides* TraceConfig::mutable_guardrail_overrides() {
  set_has_guardrail_overrides();
  if (guardrail_overrides_ == NULL) {
    guardrail_overrides_ = new ::perfetto::protos::TraceConfig_GuardrailOverrides;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.guardrail_overrides)
  return guardrail_overrides_;
}
inline ::perfetto::protos::TraceConfig_GuardrailOverrides* TraceConfig::release_guardrail_overrides() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.guardrail_overrides)
  clear_has_guardrail_overrides();
  ::perfetto::protos::TraceConfig_GuardrailOverrides* temp = guardrail_overrides_;
  guardrail_overrides_ = NULL;
  return temp;
}
inline void TraceConfig::set_allocated_guardrail_overrides(::perfetto::protos::TraceConfig_GuardrailOverrides* guardrail_overrides) {
  delete guardrail_overrides_;
  guardrail_overrides_ = guardrail_overrides;
  if (guardrail_overrides) {
    set_has_guardrail_overrides();
  } else {
    clear_has_guardrail_overrides();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.guardrail_overrides)
}

// optional bool deferred_start = 12;
inline bool TraceConfig::has_deferred_start() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TraceConfig::set_has_deferred_start() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TraceConfig::clear_has_deferred_start() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TraceConfig::clear_deferred_start() {
  deferred_start_ = false;
  clear_has_deferred_start();
}
inline bool TraceConfig::deferred_start() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.deferred_start)
  return deferred_start_;
}
inline void TraceConfig::set_deferred_start(bool value) {
  set_has_deferred_start();
  deferred_start_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.deferred_start)
}

// optional uint32 flush_period_ms = 13;
inline bool TraceConfig::has_flush_period_ms() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TraceConfig::set_has_flush_period_ms() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TraceConfig::clear_has_flush_period_ms() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TraceConfig::clear_flush_period_ms() {
  flush_period_ms_ = 0u;
  clear_has_flush_period_ms();
}
inline ::google::protobuf::uint32 TraceConfig::flush_period_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.flush_period_ms)
  return flush_period_ms_;
}
inline void TraceConfig::set_flush_period_ms(::google::protobuf::uint32 value) {
  set_has_flush_period_ms();
  flush_period_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.flush_period_ms)
}

// optional uint32 flush_timeout_ms = 14;
inline bool TraceConfig::has_flush_timeout_ms() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TraceConfig::set_has_flush_timeout_ms() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TraceConfig::clear_has_flush_timeout_ms() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TraceConfig::clear_flush_timeout_ms() {
  flush_timeout_ms_ = 0u;
  clear_has_flush_timeout_ms();
}
inline ::google::protobuf::uint32 TraceConfig::flush_timeout_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.flush_timeout_ms)
  return flush_timeout_ms_;
}
inline void TraceConfig::set_flush_timeout_ms(::google::protobuf::uint32 value) {
  set_has_flush_timeout_ms();
  flush_timeout_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.flush_timeout_ms)
}

// optional uint32 data_source_stop_timeout_ms = 23;
inline bool TraceConfig::has_data_source_stop_timeout_ms() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TraceConfig::set_has_data_source_stop_timeout_ms() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TraceConfig::clear_has_data_source_stop_timeout_ms() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TraceConfig::clear_data_source_stop_timeout_ms() {
  data_source_stop_timeout_ms_ = 0u;
  clear_has_data_source_stop_timeout_ms();
}
inline ::google::protobuf::uint32 TraceConfig::data_source_stop_timeout_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.data_source_stop_timeout_ms)
  return data_source_stop_timeout_ms_;
}
inline void TraceConfig::set_data_source_stop_timeout_ms(::google::protobuf::uint32 value) {
  set_has_data_source_stop_timeout_ms();
  data_source_stop_timeout_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.data_source_stop_timeout_ms)
}

// optional bool notify_traceur = 16;
inline bool TraceConfig::has_notify_traceur() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TraceConfig::set_has_notify_traceur() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TraceConfig::clear_has_notify_traceur() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TraceConfig::clear_notify_traceur() {
  notify_traceur_ = false;
  clear_has_notify_traceur();
}
inline bool TraceConfig::notify_traceur() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.notify_traceur)
  return notify_traceur_;
}
inline void TraceConfig::set_notify_traceur(bool value) {
  set_has_notify_traceur();
  notify_traceur_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.notify_traceur)
}

// optional .perfetto.protos.TraceConfig.TriggerConfig trigger_config = 17;
inline bool TraceConfig::has_trigger_config() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TraceConfig::set_has_trigger_config() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TraceConfig::clear_has_trigger_config() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TraceConfig::clear_trigger_config() {
  if (trigger_config_ != NULL) trigger_config_->::perfetto::protos::TraceConfig_TriggerConfig::Clear();
  clear_has_trigger_config();
}
inline const ::perfetto::protos::TraceConfig_TriggerConfig& TraceConfig::trigger_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.trigger_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return trigger_config_ != NULL ? *trigger_config_ : *default_instance().trigger_config_;
#else
  return trigger_config_ != NULL ? *trigger_config_ : *default_instance_->trigger_config_;
#endif
}
inline ::perfetto::protos::TraceConfig_TriggerConfig* TraceConfig::mutable_trigger_config() {
  set_has_trigger_config();
  if (trigger_config_ == NULL) {
    trigger_config_ = new ::perfetto::protos::TraceConfig_TriggerConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.trigger_config)
  return trigger_config_;
}
inline ::perfetto::protos::TraceConfig_TriggerConfig* TraceConfig::release_trigger_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.trigger_config)
  clear_has_trigger_config();
  ::perfetto::protos::TraceConfig_TriggerConfig* temp = trigger_config_;
  trigger_config_ = NULL;
  return temp;
}
inline void TraceConfig::set_allocated_trigger_config(::perfetto::protos::TraceConfig_TriggerConfig* trigger_config) {
  delete trigger_config_;
  trigger_config_ = trigger_config;
  if (trigger_config) {
    set_has_trigger_config();
  } else {
    clear_has_trigger_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.trigger_config)
}

// repeated string activate_triggers = 18;
inline int TraceConfig::activate_triggers_size() const {
  return activate_triggers_.size();
}
inline void TraceConfig::clear_activate_triggers() {
  activate_triggers_.Clear();
}
inline const ::std::string& TraceConfig::activate_triggers(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.activate_triggers)
  return activate_triggers_.Get(index);
}
inline ::std::string* TraceConfig::mutable_activate_triggers(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.activate_triggers)
  return activate_triggers_.Mutable(index);
}
inline void TraceConfig::set_activate_triggers(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.activate_triggers)
  activate_triggers_.Mutable(index)->assign(value);
}
inline void TraceConfig::set_activate_triggers(int index, const char* value) {
  activate_triggers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.TraceConfig.activate_triggers)
}
inline void TraceConfig::set_activate_triggers(int index, const char* value, size_t size) {
  activate_triggers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.TraceConfig.activate_triggers)
}
inline ::std::string* TraceConfig::add_activate_triggers() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.TraceConfig.activate_triggers)
  return activate_triggers_.Add();
}
inline void TraceConfig::add_activate_triggers(const ::std::string& value) {
  activate_triggers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.TraceConfig.activate_triggers)
}
inline void TraceConfig::add_activate_triggers(const char* value) {
  activate_triggers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.TraceConfig.activate_triggers)
}
inline void TraceConfig::add_activate_triggers(const char* value, size_t size) {
  activate_triggers_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.TraceConfig.activate_triggers)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TraceConfig::activate_triggers() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.TraceConfig.activate_triggers)
  return activate_triggers_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TraceConfig::mutable_activate_triggers() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.TraceConfig.activate_triggers)
  return &activate_triggers_;
}

// optional .perfetto.protos.TraceConfig.IncrementalStateConfig incremental_state_config = 21;
inline bool TraceConfig::has_incremental_state_config() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void TraceConfig::set_has_incremental_state_config() {
  _has_bits_[0] |= 0x00080000u;
}
inline void TraceConfig::clear_has_incremental_state_config() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void TraceConfig::clear_incremental_state_config() {
  if (incremental_state_config_ != NULL) incremental_state_config_->::perfetto::protos::TraceConfig_IncrementalStateConfig::Clear();
  clear_has_incremental_state_config();
}
inline const ::perfetto::protos::TraceConfig_IncrementalStateConfig& TraceConfig::incremental_state_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.incremental_state_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return incremental_state_config_ != NULL ? *incremental_state_config_ : *default_instance().incremental_state_config_;
#else
  return incremental_state_config_ != NULL ? *incremental_state_config_ : *default_instance_->incremental_state_config_;
#endif
}
inline ::perfetto::protos::TraceConfig_IncrementalStateConfig* TraceConfig::mutable_incremental_state_config() {
  set_has_incremental_state_config();
  if (incremental_state_config_ == NULL) {
    incremental_state_config_ = new ::perfetto::protos::TraceConfig_IncrementalStateConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.incremental_state_config)
  return incremental_state_config_;
}
inline ::perfetto::protos::TraceConfig_IncrementalStateConfig* TraceConfig::release_incremental_state_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.incremental_state_config)
  clear_has_incremental_state_config();
  ::perfetto::protos::TraceConfig_IncrementalStateConfig* temp = incremental_state_config_;
  incremental_state_config_ = NULL;
  return temp;
}
inline void TraceConfig::set_allocated_incremental_state_config(::perfetto::protos::TraceConfig_IncrementalStateConfig* incremental_state_config) {
  delete incremental_state_config_;
  incremental_state_config_ = incremental_state_config;
  if (incremental_state_config) {
    set_has_incremental_state_config();
  } else {
    clear_has_incremental_state_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.incremental_state_config)
}

// optional bool allow_user_build_tracing = 19;
inline bool TraceConfig::has_allow_user_build_tracing() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void TraceConfig::set_has_allow_user_build_tracing() {
  _has_bits_[0] |= 0x00100000u;
}
inline void TraceConfig::clear_has_allow_user_build_tracing() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void TraceConfig::clear_allow_user_build_tracing() {
  allow_user_build_tracing_ = false;
  clear_has_allow_user_build_tracing();
}
inline bool TraceConfig::allow_user_build_tracing() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.allow_user_build_tracing)
  return allow_user_build_tracing_;
}
inline void TraceConfig::set_allow_user_build_tracing(bool value) {
  set_has_allow_user_build_tracing();
  allow_user_build_tracing_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.allow_user_build_tracing)
}

// optional string unique_session_name = 22;
inline bool TraceConfig::has_unique_session_name() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void TraceConfig::set_has_unique_session_name() {
  _has_bits_[0] |= 0x00200000u;
}
inline void TraceConfig::clear_has_unique_session_name() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void TraceConfig::clear_unique_session_name() {
  unique_session_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_unique_session_name();
}
inline const ::std::string& TraceConfig::unique_session_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.unique_session_name)
  return unique_session_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TraceConfig::set_unique_session_name(const ::std::string& value) {
  set_has_unique_session_name();
  unique_session_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.unique_session_name)
}
inline void TraceConfig::set_unique_session_name(const char* value) {
  set_has_unique_session_name();
  unique_session_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.TraceConfig.unique_session_name)
}
inline void TraceConfig::set_unique_session_name(const char* value, size_t size) {
  set_has_unique_session_name();
  unique_session_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.TraceConfig.unique_session_name)
}
inline ::std::string* TraceConfig::mutable_unique_session_name() {
  set_has_unique_session_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.unique_session_name)
  return unique_session_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TraceConfig::release_unique_session_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.unique_session_name)
  clear_has_unique_session_name();
  return unique_session_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TraceConfig::set_allocated_unique_session_name(::std::string* unique_session_name) {
  if (unique_session_name != NULL) {
    set_has_unique_session_name();
  } else {
    clear_has_unique_session_name();
  }
  unique_session_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), unique_session_name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.unique_session_name)
}

// optional .perfetto.protos.TraceConfig.CompressionType compression_type = 24;
inline bool TraceConfig::has_compression_type() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void TraceConfig::set_has_compression_type() {
  _has_bits_[0] |= 0x00400000u;
}
inline void TraceConfig::clear_has_compression_type() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void TraceConfig::clear_compression_type() {
  compression_type_ = 0;
  clear_has_compression_type();
}
inline ::perfetto::protos::TraceConfig_CompressionType TraceConfig::compression_type() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.compression_type)
  return static_cast< ::perfetto::protos::TraceConfig_CompressionType >(compression_type_);
}
inline void TraceConfig::set_compression_type(::perfetto::protos::TraceConfig_CompressionType value) {
  assert(::perfetto::protos::TraceConfig_CompressionType_IsValid(value));
  set_has_compression_type();
  compression_type_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.compression_type)
}

// optional .perfetto.protos.TraceConfig.IncidentReportConfig incident_report_config = 25;
inline bool TraceConfig::has_incident_report_config() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void TraceConfig::set_has_incident_report_config() {
  _has_bits_[0] |= 0x00800000u;
}
inline void TraceConfig::clear_has_incident_report_config() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void TraceConfig::clear_incident_report_config() {
  if (incident_report_config_ != NULL) incident_report_config_->::perfetto::protos::TraceConfig_IncidentReportConfig::Clear();
  clear_has_incident_report_config();
}
inline const ::perfetto::protos::TraceConfig_IncidentReportConfig& TraceConfig::incident_report_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.incident_report_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return incident_report_config_ != NULL ? *incident_report_config_ : *default_instance().incident_report_config_;
#else
  return incident_report_config_ != NULL ? *incident_report_config_ : *default_instance_->incident_report_config_;
#endif
}
inline ::perfetto::protos::TraceConfig_IncidentReportConfig* TraceConfig::mutable_incident_report_config() {
  set_has_incident_report_config();
  if (incident_report_config_ == NULL) {
    incident_report_config_ = new ::perfetto::protos::TraceConfig_IncidentReportConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.incident_report_config)
  return incident_report_config_;
}
inline ::perfetto::protos::TraceConfig_IncidentReportConfig* TraceConfig::release_incident_report_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.incident_report_config)
  clear_has_incident_report_config();
  ::perfetto::protos::TraceConfig_IncidentReportConfig* temp = incident_report_config_;
  incident_report_config_ = NULL;
  return temp;
}
inline void TraceConfig::set_allocated_incident_report_config(::perfetto::protos::TraceConfig_IncidentReportConfig* incident_report_config) {
  delete incident_report_config_;
  incident_report_config_ = incident_report_config;
  if (incident_report_config) {
    set_has_incident_report_config();
  } else {
    clear_has_incident_report_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.incident_report_config)
}

// optional bytes trace_uuid = 26;
inline bool TraceConfig::has_trace_uuid() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void TraceConfig::set_has_trace_uuid() {
  _has_bits_[0] |= 0x01000000u;
}
inline void TraceConfig::clear_has_trace_uuid() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void TraceConfig::clear_trace_uuid() {
  trace_uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_trace_uuid();
}
inline const ::std::string& TraceConfig::trace_uuid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.trace_uuid)
  return trace_uuid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TraceConfig::set_trace_uuid(const ::std::string& value) {
  set_has_trace_uuid();
  trace_uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.trace_uuid)
}
inline void TraceConfig::set_trace_uuid(const char* value) {
  set_has_trace_uuid();
  trace_uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.TraceConfig.trace_uuid)
}
inline void TraceConfig::set_trace_uuid(const void* value, size_t size) {
  set_has_trace_uuid();
  trace_uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.TraceConfig.trace_uuid)
}
inline ::std::string* TraceConfig::mutable_trace_uuid() {
  set_has_trace_uuid();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.trace_uuid)
  return trace_uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TraceConfig::release_trace_uuid() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.trace_uuid)
  clear_has_trace_uuid();
  return trace_uuid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TraceConfig::set_allocated_trace_uuid(::std::string* trace_uuid) {
  if (trace_uuid != NULL) {
    set_has_trace_uuid();
  } else {
    clear_has_trace_uuid();
  }
  trace_uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), trace_uuid);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.trace_uuid)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::perfetto::protos::TraceConfig_BufferConfig_FillPolicy> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::perfetto::protos::TraceConfig_TriggerConfig_TriggerMode> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::perfetto::protos::TraceConfig_LockdownModeOperation> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::perfetto::protos::TraceConfig_CompressionType> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto__INCLUDED
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/ipc/wire_protocol.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/ipc/wire_protocol.proto

#ifndef PROTOBUF_protos_2fperfetto_2fipc_2fwire_5fprotocol_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2fipc_2fwire_5fprotocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace ipc {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2fipc_2fwire_5fprotocol_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fwire_5fprotocol_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fwire_5fprotocol_2eproto();

class Frame;
class Frame_BindService;
class Frame_BindServiceReply;
class Frame_BindServiceReply_MethodInfo;
class Frame_InvokeMethod;
class Frame_InvokeMethodReply;
class Frame_RequestError;

// ===================================================================

class Frame_BindService : public ::google::protobuf::MessageLite {
 public:
  Frame_BindService();
  virtual ~Frame_BindService();

  Frame_BindService(const Frame_BindService& from);

  inline Frame_BindService& operator=(const Frame_BindService& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Frame_BindService& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Frame_BindService* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Frame_BindService* other);

  // implements Message ----------------------------------------------

  inline Frame_BindService* New() const { return New(NULL); }

  Frame_BindService* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Frame_BindService& from);
  void MergeFrom(const Frame_BindService& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Frame_BindService* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string service_name = 1;
  bool has_service_name() const;
  void clear_service_name();
  static const int kServiceNameFieldNumber = 1;
  const ::std::string& service_name() const;
  void set_service_name(const ::std::string& value);
  void set_service_name(const char* value);
  void set_service_name(const char* value, size_t size);
  ::std::string* mutable_service_name();
  ::std::string* release_service_name();
  void set_allocated_service_name(::std::string* service_name);

  // @@protoc_insertion_point(class_scope:perfetto.ipc.Frame.BindService)
 private:
  inline void set_has_service_name();
  inline void clear_has_service_name();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr service_name_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fwire_5fprotocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fwire_5fprotocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fwire_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fwire_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static Frame_BindService* default_instance_;
};
// -------------------------------------------------------------------

class Frame_BindServiceReply_MethodInfo : public ::google::protobuf::MessageLite {
 public:
  Frame_BindServiceReply_MethodInfo();
  virtual ~Frame_BindServiceReply_MethodInfo();

  Frame_BindServiceReply_MethodInfo(const Frame_BindServiceReply_MethodInfo& from);

  inline Frame_BindServiceReply_MethodInfo& operator=(const Frame_BindServiceReply_MethodInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Frame_BindServiceReply_MethodInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Frame_BindServiceReply_MethodInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Frame_BindServiceReply_MethodInfo* other);

  // implements Message ----------------------------------------------

  inline Frame_BindServiceReply_MethodInfo* New() const { return New(NULL); }

  Frame_BindServiceReply_MethodInfo* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Frame_BindServiceReply_MethodInfo& from);
  void MergeFrom(const Frame_BindServiceReply_MethodInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Frame_BindServiceReply_MethodInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:perfetto.ipc.Frame.BindServiceReply.MethodInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint32 id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fwire_5fprotocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fwire_5fprotocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fwire_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fwire_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static Frame_BindServiceReply_MethodInfo* default_instance_;
};
// -------------------------------------------------------------------

class Frame_BindServiceReply : public ::google::protobuf::MessageLite {
 public:
  Frame_BindServiceReply();
  virtual ~Frame_BindServiceReply();

  Frame_BindServiceReply(const Frame_BindServiceReply& from);

  inline Frame_BindServiceReply& operator=(const Frame_BindServiceReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Frame_BindServiceReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Frame_BindServiceReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Frame_BindServiceReply* other);

  // implements Message ----------------------------------------------

  inline Frame_BindServiceReply* New() const { return New(NULL); }

  Frame_BindServiceReply* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Frame_BindServiceReply& from);
  void MergeFrom(const Frame_BindServiceReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Frame_BindServiceReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Frame_BindServiceReply_MethodInfo MethodInfo;

  // accessors -------------------------------------------------------

  // optional bool success = 1;
  bool has_success() const;
  void clear_success();
  static const int kSuccessFieldNumber = 1;
  bool success() const;
  void set_success(bool value);

  // optional uint32 service_id = 2;
  bool has_service_id() const;
  void clear_service_id();
  static const int kServiceIdFieldNumber = 2;
  ::google::protobuf::uint32 service_id() const;
  void set_service_id(::google::protobuf::uint32 value);

  // repeated .perfetto.ipc.Frame.BindServiceReply.MethodInfo methods = 3;
  int methods_size() const;
  void clear_methods();
  static const int kMethodsFieldNumber = 3;
  const ::perfetto::ipc::Frame_BindServiceReply_MethodInfo& methods(int index) const;
  ::perfetto::ipc::Frame_BindServiceReply_MethodInfo* mutable_methods(int index);
  ::perfetto::ipc::Frame_BindServiceReply_MethodInfo* add_methods();
  ::google::protobuf::RepeatedPtrField< ::perfetto::ipc::Frame_BindServiceReply_MethodInfo >*
      mutable_methods();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::ipc::Frame_BindServiceReply_MethodInfo >&
      methods() const;

  // @@protoc_insertion_point(class_scope:perfetto.ipc.Frame.BindServiceReply)
 private:
  inline void set_has_success();
  inline void clear_has_success();
  inline void set_has_service_id();
  inline void clear_has_service_id();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool success_;
  ::google::protobuf::uint32 service_id_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::ipc::Frame_BindServiceReply_MethodInfo > methods_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fwire_5fprotocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fwire_5fprotocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fwire_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fwire_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static Frame_BindServiceReply* default_instance_;
};
// -------------------------------------------------------------------

class Frame_InvokeMethod : public ::google::protobuf::MessageLite {
 public:
  Frame_InvokeMethod();
  virtual ~Frame_InvokeMethod();

  Frame_InvokeMethod(const Frame_InvokeMethod& from);

  inline Frame_InvokeMethod& operator=(const Frame_InvokeMethod& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Frame_InvokeMethod& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Frame_InvokeMethod* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Frame_InvokeMethod* other);

  // implements Message ----------------------------------------------

  inline Frame_InvokeMethod* New() const { return New(NULL); }

  Frame_InvokeMethod* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Frame_InvokeMethod& from);
  void MergeFrom(const Frame_InvokeMethod& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Frame_InvokeMethod* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 service_id = 1;
  bool has_service_id() const;
  void clear_service_id();
  static const int kServiceIdFieldNumber = 1;
  ::google::protobuf::uint32 service_id() const;
  void set_service_id(::google::protobuf::uint32 value);

  // optional uint32 method_id = 2;
  bool has_method_id() const;
  void clear_method_id();
  static const int kMethodIdFieldNumber = 2;
  ::google::protobuf::uint32 method_id() const;
  void set_method_id(::google::protobuf::uint32 value);

  // optional bytes args_proto = 3;
  bool has_args_proto() const;
  void clear_args_proto();
  static const int kArgsProtoFieldNumber = 3;
  const ::std::string& args_proto() const;
  void set_args_proto(const ::std::string& value);
  void set_args_proto(const char* value);
  void set_args_proto(const void* value, size_t size);
  ::std::string* mutable_args_proto();
  ::std::string* release_args_proto();
  void set_allocated_args_proto(::std::string* args_proto);

  // optional bool drop_reply = 4;
  bool has_drop_reply() const;
  void clear_drop_reply();
  static const int kDropReplyFieldNumber = 4;
  bool drop_reply() const;
  void set_drop_reply(bool value);

  // @@protoc_insertion_point(class_scope:perfetto.ipc.Frame.InvokeMethod)
 private:
  inline void set_has_service_id();
  inline void clear_has_service_id();
  inline void set_has_method_id();
  inline void clear_has_method_id();
  inline void set_has_args_proto();
  inline void clear_has_args_proto();
  inline void set_has_drop_reply();
  inline void clear_has_drop_reply();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 service_id_;
  ::google::protobuf::uint32 method_id_;
  ::google::protobuf::internal::ArenaStringPtr args_proto_;
  bool drop_reply_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fwire_5fprotocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fwire_5fprotocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fwire_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fwire_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static Frame_InvokeMethod* default_instance_;
};
// -------------------------------------------------------------------

class Frame_InvokeMethodReply : public ::google::protobuf::MessageLite {
 public:
  Frame_InvokeMethodReply();
  virtual ~Frame_InvokeMethodReply();

  Frame_InvokeMethodReply(const Frame_InvokeMethodReply& from);

  inline Frame_InvokeMethodReply& operator=(const Frame_InvokeMethodReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Frame_InvokeMethodReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Frame_InvokeMethodReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Frame_InvokeMethodReply* other);

  // implements Message ----------------------------------------------

  inline Frame_InvokeMethodReply* New() const { return New(NULL); }

  Frame_InvokeMethodReply* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Frame_InvokeMethodReply& from);
  void MergeFrom(const Frame_InvokeMethodReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Frame_InvokeMethodReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool success = 1;
  bool has_success() const;
  void clear_success();
  static const int kSuccessFieldNumber = 1;
  bool success() const;
  void set_success(bool value);

  // optional bool has_more = 2;
  bool has_has_more() const;
  void clear_has_more();
  static const int kHasMoreFieldNumber = 2;
  bool has_more() const;
  void set_has_more(bool value);

  // optional bytes reply_proto = 3;
  bool has_reply_proto() const;
  void clear_reply_proto();
  static const int kReplyProtoFieldNumber = 3;
  const ::std::string& reply_proto() const;
  void set_reply_proto(const ::std::string& value);
  void set_reply_proto(const char* value);
  void set_reply_proto(const void* value, size_t size);
  ::std::string* mutable_reply_proto();
  ::std::string* release_reply_proto();
  void set_allocated_reply_proto(::std::string* reply_proto);

  // @@protoc_insertion_point(class_scope:perfetto.ipc.Frame.InvokeMethodReply)
 private:
  inline void set_has_success();
  inline void clear_has_success();
  inline void set_has_has_more();
  inline void clear_has_has_more();
  inline void set_has_reply_proto();
  inline void clear_has_reply_proto();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr reply_proto_;
  bool success_;
  bool has_more_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fwire_5fprotocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fwire_5fprotocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fwire_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fwire_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static Frame_InvokeMethodReply* default_instance_;
};
// -------------------------------------------------------------------

class Frame_RequestError : public ::google::protobuf::MessageLite {
 public:
  Frame_RequestError();
  virtual ~Frame_RequestError();

  Frame_RequestError(const Frame_RequestError& from);

  inline Frame_RequestError& operator=(const Frame_RequestError& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Frame_RequestError& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Frame_RequestError* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Frame_RequestError* other);

  // implements Message ----------------------------------------------

  inline Frame_RequestError* New() const { return New(NULL); }

  Frame_RequestError* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Frame_RequestError& from);
  void MergeFrom(const Frame_RequestError& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Frame_RequestError* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string error = 1;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // @@protoc_insertion_point(class_scope:perfetto.ipc.Frame.RequestError)
 private:
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fwire_5fprotocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fwire_5fprotocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fwire_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fwire_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static Frame_RequestError* default_instance_;
};
// -------------------------------------------------------------------

class Frame : public ::google::protobuf::MessageLite {
 public:
  Frame();
  virtual ~Frame();

  Frame(const Frame& from);

  inline Frame& operator=(const Frame& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Frame& default_instance();

  enum MsgCase {
    kMsgBindService = 3,
    kMsgBindServiceReply = 4,
    kMsgInvokeMethod = 5,
    kMsgInvokeMethodReply = 6,
    kMsgRequestError = 7,
    MSG_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Frame* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Frame* other);

  // implements Message ----------------------------------------------

  inline Frame* New() const { return New(NULL); }

  Frame* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Frame& from);
  void MergeFrom(const Frame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Frame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Frame_BindService BindService;
  typedef Frame_BindServiceReply BindServiceReply;
  typedef Frame_InvokeMethod InvokeMethod;
  typedef Frame_InvokeMethodReply InvokeMethodReply;
  typedef Frame_RequestError RequestError;

  // accessors -------------------------------------------------------

  // optional uint64 request_id = 2;
  bool has_request_id() const;
  void clear_request_id();
  static const int kRequestIdFieldNumber = 2;
  ::google::protobuf::uint64 request_id() const;
  void set_request_id(::google::protobuf::uint64 value);

  // optional .perfetto.ipc.Frame.BindService msg_bind_service = 3;
  bool has_msg_bind_service() const;
  void clear_msg_bind_service();
  static const int kMsgBindServiceFieldNumber = 3;
  const ::perfetto::ipc::Frame_BindService& msg_bind_service() const;
  ::perfetto::ipc::Frame_BindService* mutable_msg_bind_service();
  ::perfetto::ipc::Frame_BindService* release_msg_bind_service();
  void set_allocated_msg_bind_service(::perfetto::ipc::Frame_BindService* msg_bind_service);

  // optional .perfetto.ipc.Frame.BindServiceReply msg_bind_service_reply = 4;
  bool has_msg_bind_service_reply() const;
  void clear_msg_bind_service_reply();
  static const int kMsgBindServiceReplyFieldNumber = 4;
  const ::perfetto::ipc::Frame_BindServiceReply& msg_bind_service_reply() const;
  ::perfetto::ipc::Frame_BindServiceReply* mutable_msg_bind_service_reply();
  ::perfetto::ipc::Frame_BindServiceReply* release_msg_bind_service_reply();
  void set_allocated_msg_bind_service_reply(::perfetto::ipc::Frame_BindServiceReply* msg_bind_service_reply);

  // optional .perfetto.ipc.Frame.InvokeMethod msg_invoke_method = 5;
  bool has_msg_invoke_method() const;
  void clear_msg_invoke_method();
  static const int kMsgInvokeMethodFieldNumber = 5;
  const ::perfetto::ipc::Frame_InvokeMethod& msg_invoke_method() const;
  ::perfetto::ipc::Frame_InvokeMethod* mutable_msg_invoke_method();
  ::perfetto::ipc::Frame_InvokeMethod* release_msg_invoke_method();
  void set_allocated_msg_invoke_method(::perfetto::ipc::Frame_InvokeMethod* msg_invoke_method);

  // optional .perfetto.ipc.Frame.InvokeMethodReply msg_invoke_method_reply = 6;
  bool has_msg_invoke_method_reply() const;
  void clear_msg_invoke_method_reply();
  static const int kMsgInvokeMethodReplyFieldNumber = 6;
  const ::perfetto::ipc::Frame_InvokeMethodReply& msg_invoke_method_reply() const;
  ::perfetto::ipc::Frame_InvokeMethodReply* mutable_msg_invoke_method_reply();
  ::perfetto::ipc::Frame_InvokeMethodReply* release_msg_invoke_method_reply();
  void set_allocated_msg_invoke_method_reply(::perfetto::ipc::Frame_InvokeMethodReply* msg_invoke_method_reply);

  // optional .perfetto.ipc.Frame.RequestError msg_request_error = 7;
  bool has_msg_request_error() const;
  void clear_msg_request_error();
  static const int kMsgRequestErrorFieldNumber = 7;
  const ::perfetto::ipc::Frame_RequestError& msg_request_error() const;
  ::perfetto::ipc::Frame_RequestError* mutable_msg_request_error();
  ::perfetto::ipc::Frame_RequestError* release_msg_request_error();
  void set_allocated_msg_request_error(::perfetto::ipc::Frame_RequestError* msg_request_error);

  // repeated bytes data_for_testing = 1;
  int data_for_testing_size() const;
  void clear_data_for_testing();
  static const int kDataForTestingFieldNumber = 1;
  const ::std::string& data_for_testing(int index) const;
  ::std::string* mutable_data_for_testing(int index);
  void set_data_for_testing(int index, const ::std::string& value);
  void set_data_for_testing(int index, const char* value);
  void set_data_for_testing(int index, const void* value, size_t size);
  ::std::string* add_data_for_testing();
  void add_data_for_testing(const ::std::string& value);
  void add_data_for_testing(const char* value);
  void add_data_for_testing(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& data_for_testing() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_data_for_testing();

  MsgCase msg_case() const;
  // @@protoc_insertion_point(class_scope:perfetto.ipc.Frame)
 private:
  inline void set_has_request_id();
  inline void clear_has_request_id();
  inline void set_has_msg_bind_service();
  inline void set_has_msg_bind_service_reply();
  inline void set_has_msg_invoke_method();
  inline void set_has_msg_invoke_method_reply();
  inline void set_has_msg_request_error();

  inline bool has_msg() const;
  void clear_msg();
  inline void clear_has_msg();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 request_id_;
  ::google::protobuf::RepeatedPtrField< ::std::string> data_for_testing_;
  union MsgUnion {
    MsgUnion() {}
    ::perfetto::ipc::Frame_BindService* msg_bind_service_;
    ::perfetto::ipc::Frame_BindServiceReply* msg_bind_service_reply_;
    ::perfetto::ipc::Frame_InvokeMethod* msg_invoke_method_;
    ::perfetto::ipc::Frame_InvokeMethodReply* msg_invoke_method_reply_;
    ::perfetto::ipc::Frame_RequestError* msg_request_error_;
  } msg_;
  ::google::protobuf::uint32 _oneof_case_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fwire_5fprotocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fwire_5fprotocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fwire_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fwire_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static Frame* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Frame_BindService

// optional string service_name = 1;
inline bool Frame_BindService::has_service_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Frame_BindService::set_has_service_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Frame_BindService::clear_has_service_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Frame_BindService::clear_service_name() {
  service_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_service_name();
}
inline const ::std::string& Frame_BindService::service_name() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.BindService.service_name)
  return service_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Frame_BindService::set_service_name(const ::std::string& value) {
  set_has_service_name();
  service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.ipc.Frame.BindService.service_name)
}
inline void Frame_BindService::set_service_name(const char* value) {
  set_has_service_name();
  service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.ipc.Frame.BindService.service_name)
}
inline void Frame_BindService::set_service_name(const char* value, size_t size) {
  set_has_service_name();
  service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.ipc.Frame.BindService.service_name)
}
inline ::std::string* Frame_BindService::mutable_service_name() {
  set_has_service_name();
  // @@protoc_insertion_point(field_mutable:perfetto.ipc.Frame.BindService.service_name)
  return service_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Frame_BindService::release_service_name() {
  // @@protoc_insertion_point(field_release:perfetto.ipc.Frame.BindService.service_name)
  clear_has_service_name();
  return service_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Frame_BindService::set_allocated_service_name(::std::string* service_name) {
  if (service_name != NULL) {
    set_has_service_name();
  } else {
    clear_has_service_name();
  }
  service_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), service_name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.ipc.Frame.BindService.service_name)
}

// -------------------------------------------------------------------

// Frame_BindServiceReply_MethodInfo

// optional uint32 id = 1;
inline bool Frame_BindServiceReply_MethodInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Frame_BindServiceReply_MethodInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Frame_BindServiceReply_MethodInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Frame_BindServiceReply_MethodInfo::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Frame_BindServiceReply_MethodInfo::id() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.BindServiceReply.MethodInfo.id)
  return id_;
}
inline void Frame_BindServiceReply_MethodInfo::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.ipc.Frame.BindServiceReply.MethodInfo.id)
}

// optional string name = 2;
inline bool Frame_BindServiceReply_MethodInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Frame_BindServiceReply_MethodInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Frame_BindServiceReply_MethodInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Frame_BindServiceReply_MethodInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Frame_BindServiceReply_MethodInfo::name() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.BindServiceReply.MethodInfo.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Frame_BindServiceReply_MethodInfo::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.ipc.Frame.BindServiceReply.MethodInfo.name)
}
inline void Frame_BindServiceReply_MethodInfo::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.ipc.Frame.BindServiceReply.MethodInfo.name)
}
inline void Frame_BindServiceReply_MethodInfo::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.ipc.Frame.BindServiceReply.MethodInfo.name)
}
inline ::std::string* Frame_BindServiceReply_MethodInfo::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:perfetto.ipc.Frame.BindServiceReply.MethodInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Frame_BindServiceReply_MethodInfo::release_name() {
  // @@protoc_insertion_point(field_release:perfetto.ipc.Frame.BindServiceReply.MethodInfo.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Frame_BindServiceReply_MethodInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.ipc.Frame.BindServiceReply.MethodInfo.name)
}

// -------------------------------------------------------------------

// Frame_BindServiceReply

// optional bool success = 1;
inline bool Frame_BindServiceReply::has_success() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Frame_BindServiceReply::set_has_success() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Frame_BindServiceReply::clear_has_success() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Frame_BindServiceReply::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool Frame_BindServiceReply::success() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.BindServiceReply.success)
  return success_;
}
inline void Frame_BindServiceReply::set_success(bool value) {
  set_has_success();
  success_ = value;
  // @@protoc_insertion_point(field_set:perfetto.ipc.Frame.BindServiceReply.success)
}

// optional uint32 service_id = 2;
inline bool Frame_BindServiceReply::has_service_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Frame_BindServiceReply::set_has_service_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Frame_BindServiceReply::clear_has_service_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Frame_BindServiceReply::clear_service_id() {
  service_id_ = 0u;
  clear_has_service_id();
}
inline ::google::protobuf::uint32 Frame_BindServiceReply::service_id() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.BindServiceReply.service_id)
  return service_id_;
}
inline void Frame_BindServiceReply::set_service_id(::google::protobuf::uint32 value) {
  set_has_service_id();
  service_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.ipc.Frame.BindServiceReply.service_id)
}

// repeated .perfetto.ipc.Frame.BindServiceReply.MethodInfo methods = 3;
inline int Frame_BindServiceReply::methods_size() const {
  return methods_.size();
}
inline void Frame_BindServiceReply::clear_methods() {
  methods_.Clear();
}
inline const ::perfetto::ipc::Frame_BindServiceReply_MethodInfo& Frame_BindServiceReply::methods(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.BindServiceReply.methods)
  return methods_.Get(index);
}
inline ::perfetto::ipc::Frame_BindServiceReply_MethodInfo* Frame_BindServiceReply::mutable_methods(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.ipc.Frame.BindServiceReply.methods)
  return methods_.Mutable(index);
}
inline ::perfetto::ipc::Frame_BindServiceReply_MethodInfo* Frame_BindServiceReply::add_methods() {
  // @@protoc_insertion_point(field_add:perfetto.ipc.Frame.BindServiceReply.methods)
  return methods_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::ipc::Frame_BindServiceReply_MethodInfo >*
Frame_BindServiceReply::mutable_methods() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.ipc.Frame.BindServiceReply.methods)
  return &methods_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::ipc::Frame_BindServiceReply_MethodInfo >&
Frame_BindServiceReply::methods() const {
  // @@protoc_insertion_point(field_list:perfetto.ipc.Frame.BindServiceReply.methods)
  return methods_;
}

// -------------------------------------------------------------------

// Frame_InvokeMethod

// optional uint32 service_id = 1;
inline bool Frame_InvokeMethod::has_service_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Frame_InvokeMethod::set_has_service_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Frame_InvokeMethod::clear_has_service_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Frame_InvokeMethod::clear_service_id() {
  service_id_ = 0u;
  clear_has_service_id();
}
inline ::google::protobuf::uint32 Frame_InvokeMethod::service_id() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.InvokeMethod.service_id)
  return service_id_;
}
inline void Frame_InvokeMethod::set_service_id(::google::protobuf::uint32 value) {
  set_has_service_id();
  service_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.ipc.Frame.InvokeMethod.service_id)
}

// optional uint32 method_id = 2;
inline bool Frame_InvokeMethod::has_method_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Frame_InvokeMethod::set_has_method_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Frame_InvokeMethod::clear_has_method_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Frame_InvokeMethod::clear_method_id() {
  method_id_ = 0u;
  clear_has_method_id();
}
inline ::google::protobuf::uint32 Frame_InvokeMethod::method_id() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.InvokeMethod.method_id)
  return method_id_;
}
inline void Frame_InvokeMethod::set_method_id(::google::protobuf::uint32 value) {
  set_has_method_id();
  method_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.ipc.Frame.InvokeMethod.method_id)
}

// optional bytes args_proto = 3;
inline bool Frame_InvokeMethod::has_args_proto() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Frame_InvokeMethod::set_has_args_proto() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Frame_InvokeMethod::clear_has_args_proto() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Frame_InvokeMethod::clear_args_proto() {
  args_proto_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_args_proto();
}
inline const ::std::string& Frame_InvokeMethod::args_proto() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.InvokeMethod.args_proto)
  return args_proto_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Frame_InvokeMethod::set_args_proto(const ::std::string& value) {
  set_has_args_proto();
  args_proto_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.ipc.Frame.InvokeMethod.args_proto)
}
inline void Frame_InvokeMethod::set_args_proto(const char* value) {
  set_has_args_proto();
  args_proto_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.ipc.Frame.InvokeMethod.args_proto)
}
inline void Frame_InvokeMethod::set_args_proto(const void* value, size_t size) {
  set_has_args_proto();
  args_proto_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.ipc.Frame.InvokeMethod.args_proto)
}
inline ::std::string* Frame_InvokeMethod::mutable_args_proto() {
  set_has_args_proto();
  // @@protoc_insertion_point(field_mutable:perfetto.ipc.Frame.InvokeMethod.args_proto)
  return args_proto_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Frame_InvokeMethod::release_args_proto() {
  // @@protoc_insertion_point(field_release:perfetto.ipc.Frame.InvokeMethod.args_proto)
  clear_has_args_proto();
  return args_proto_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Frame_InvokeMethod::set_allocated_args_proto(::std::string* args_proto) {
  if (args_proto != NULL) {
    set_has_args_proto();
  } else {
    clear_has_args_proto();
  }
  args_proto_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), args_proto);
  // @@protoc_insertion_point(field_set_allocated:perfetto.ipc.Frame.InvokeMethod.args_proto)
}

// optional bool drop_reply = 4;
inline bool Frame_InvokeMethod::has_drop_reply() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Frame_InvokeMethod::set_has_drop_reply() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Frame_InvokeMethod::clear_has_drop_reply() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Frame_InvokeMethod::clear_drop_reply() {
  drop_reply_ = false;
  clear_has_drop_reply();
}
inline bool Frame_InvokeMethod::drop_reply() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.InvokeMethod.drop_reply)
  return drop_reply_;
}
inline void Frame_InvokeMethod::set_drop_reply(bool value) {
  set_has_drop_reply();
  drop_reply_ = value;
  // @@protoc_insertion_point(field_set:perfetto.ipc.Frame.InvokeMethod.drop_reply)
}

// -------------------------------------------------------------------

// Frame_InvokeMethodReply

// optional bool success = 1;
inline bool Frame_InvokeMethodReply::has_success() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Frame_InvokeMethodReply::set_has_success() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Frame_InvokeMethodReply::clear_has_success() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Frame_InvokeMethodReply::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool Frame_InvokeMethodReply::success() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.InvokeMethodReply.success)
  return success_;
}
inline void Frame_InvokeMethodReply::set_success(bool value) {
  set_has_success();
  success_ = value;
  // @@protoc_insertion_point(field_set:perfetto.ipc.Frame.InvokeMethodReply.success)
}

// optional bool has_more = 2;
inline bool Frame_InvokeMethodReply::has_has_more() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Frame_InvokeMethodReply::set_has_has_more() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Frame_InvokeMethodReply::clear_has_has_more() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Frame_InvokeMethodReply::clear_has_more() {
  has_more_ = false;
  clear_has_has_more();
}
inline bool Frame_InvokeMethodReply::has_more() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.InvokeMethodReply.has_more)
  return has_more_;
}
inline void Frame_InvokeMethodReply::set_has_more(bool value) {
  set_has_has_more();
  has_more_ = value;
  // @@protoc_insertion_point(field_set:perfetto.ipc.Frame.InvokeMethodReply.has_more)
}

// optional bytes reply_proto = 3;
inline bool Frame_InvokeMethodReply::has_reply_proto() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Frame_InvokeMethodReply::set_has_reply_proto() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Frame_InvokeMethodReply::clear_has_reply_proto() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Frame_InvokeMethodReply::clear_reply_proto() {
  reply_proto_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_reply_proto();
}
inline const ::std::string& Frame_InvokeMethodReply::reply_proto() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.InvokeMethodReply.reply_proto)
  return reply_proto_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Frame_InvokeMethodReply::set_reply_proto(const ::std::string& value) {
  set_has_reply_proto();
  reply_proto_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.ipc.Frame.InvokeMethodReply.reply_proto)
}
inline void Frame_InvokeMethodReply::set_reply_proto(const char* value) {
  set_has_reply_proto();
  reply_proto_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.ipc.Frame.InvokeMethodReply.reply_proto)
}
inline void Frame_InvokeMethodReply::set_reply_proto(const void* value, size_t size) {
  set_has_reply_proto();
  reply_proto_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.ipc.Frame.InvokeMethodReply.reply_proto)
}
inline ::std::string* Frame_InvokeMethodReply::mutable_reply_proto() {
  set_has_reply_proto();
  // @@protoc_insertion_point(field_mutable:perfetto.ipc.Frame.InvokeMethodReply.reply_proto)
  return reply_proto_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Frame_InvokeMethodReply::release_reply_proto() {
  // @@protoc_insertion_point(field_release:perfetto.ipc.Frame.InvokeMethodReply.reply_proto)
  clear_has_reply_proto();
  return reply_proto_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Frame_InvokeMethodReply::set_allocated_reply_proto(::std::string* reply_proto) {
  if (reply_proto != NULL) {
    set_has_reply_proto();
  } else {
    clear_has_reply_proto();
  }
  reply_proto_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reply_proto);
  // @@protoc_insertion_point(field_set_allocated:perfetto.ipc.Frame.InvokeMethodReply.reply_proto)
}

// -------------------------------------------------------------------

// Frame_RequestError

// optional string error = 1;
inline bool Frame_RequestError::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Frame_RequestError::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Frame_RequestError::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Frame_RequestError::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error();
}
inline const ::std::string& Frame_RequestError::error() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.RequestError.error)
  return error_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Frame_RequestError::set_error(const ::std::string& value) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.ipc.Frame.RequestError.error)
}
inline void Frame_RequestError::set_error(const char* value) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.ipc.Frame.RequestError.error)
}
inline void Frame_RequestError::set_error(const char* value, size_t size) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.ipc.Frame.RequestError.error)
}
inline ::std::string* Frame_RequestError::mutable_error() {
  set_has_error();
  // @@protoc_insertion_point(field_mutable:perfetto.ipc.Frame.RequestError.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Frame_RequestError::release_error() {
  // @@protoc_insertion_point(field_release:perfetto.ipc.Frame.RequestError.error)
  clear_has_error();
  return error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Frame_RequestError::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    set_has_error();
  } else {
    clear_has_error();
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:perfetto.ipc.Frame.RequestError.error)
}

// -------------------------------------------------------------------

// Frame

// optional uint64 request_id = 2;
inline bool Frame::has_request_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Frame::set_has_request_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Frame::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Frame::clear_request_id() {
  request_id_ = GOOGLE_ULONGLONG(0);
  clear_has_request_id();
}
inline ::google::protobuf::uint64 Frame::request_id() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.request_id)
  return request_id_;
}
inline void Frame::set_request_id(::google::protobuf::uint64 value) {
  set_has_request_id();
  request_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.ipc.Frame.request_id)
}

// optional .perfetto.ipc.Frame.BindService msg_bind_service = 3;
inline bool Frame::has_msg_bind_service() const {
  return msg_case() == kMsgBindService;
}
inline void Frame::set_has_msg_bind_service() {
  _oneof_case_[0] = kMsgBindService;
}
inline void Frame::clear_msg_bind_service() {
  if (has_msg_bind_service()) {
    delete msg_.msg_bind_service_;
    clear_has_msg();
  }
}
inline  const ::perfetto::ipc::Frame_BindService& Frame::msg_bind_service() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.msg_bind_service)
  return has_msg_bind_service()
      ? *msg_.msg_bind_service_
      : ::perfetto::ipc::Frame_BindService::default_instance();
}
inline ::perfetto::ipc::Frame_BindService* Frame::mutable_msg_bind_service() {
  if (!has_msg_bind_service()) {
    clear_msg();
    set_has_msg_bind_service();
    msg_.msg_bind_service_ = new ::perfetto::ipc::Frame_BindService;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.ipc.Frame.msg_bind_service)
  return msg_.msg_bind_service_;
}
inline ::perfetto::ipc::Frame_BindService* Frame::release_msg_bind_service() {
  // @@protoc_insertion_point(field_release:perfetto.ipc.Frame.msg_bind_service)
  if (has_msg_bind_service()) {
    clear_has_msg();
    ::perfetto::ipc::Frame_BindService* temp = msg_.msg_bind_service_;
    msg_.msg_bind_service_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Frame::set_allocated_msg_bind_service(::perfetto::ipc::Frame_BindService* msg_bind_service) {
  clear_msg();
  if (msg_bind_service) {
    set_has_msg_bind_service();
    msg_.msg_bind_service_ = msg_bind_service;
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.ipc.Frame.msg_bind_service)
}

// optional .perfetto.ipc.Frame.BindServiceReply msg_bind_service_reply = 4;
inline bool Frame::has_msg_bind_service_reply() const {
  return msg_case() == kMsgBindServiceReply;
}
inline void Frame::set_has_msg_bind_service_reply() {
  _oneof_case_[0] = kMsgBindServiceReply;
}
inline void Frame::clear_msg_bind_service_reply() {
  if (has_msg_bind_service_reply()) {
    delete msg_.msg_bind_service_reply_;
    clear_has_msg();
  }
}
inline  const ::perfetto::ipc::Frame_BindServiceReply& Frame::msg_bind_service_reply() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.msg_bind_service_reply)
  return has_msg_bind_service_reply()
      ? *msg_.msg_bind_service_reply_
      : ::perfetto::ipc::Frame_BindServiceReply::default_instance();
}
inline ::perfetto::ipc::Frame_BindServiceReply* Frame::mutable_msg_bind_service_reply() {
  if (!has_msg_bind_service_reply()) {
    clear_msg();
    set_has_msg_bind_service_reply();
    msg_.msg_bind_service_reply_ = new ::perfetto::ipc::Frame_BindServiceReply;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.ipc.Frame.msg_bind_service_reply)
  return msg_.msg_bind_service_reply_;
}
inline ::perfetto::ipc::Frame_BindServiceReply* Frame::release_msg_bind_service_reply() {
  // @@protoc_insertion_point(field_release:perfetto.ipc.Frame.msg_bind_service_reply)
  if (has_msg_bind_service_reply()) {
    clear_has_msg();
    ::perfetto::ipc::Frame_BindServiceReply* temp = msg_.msg_bind_service_reply_;
    msg_.msg_bind_service_reply_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Frame::set_allocated_msg_bind_service_reply(::perfetto::ipc::Frame_BindServiceReply* msg_bind_service_reply) {
  clear_msg();
  if (msg_bind_service_reply) {
    set_has_msg_bind_service_reply();
    msg_.msg_bind_service_reply_ = msg_bind_service_reply;
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.ipc.Frame.msg_bind_service_reply)
}

// optional .perfetto.ipc.Frame.InvokeMethod msg_invoke_method = 5;
inline bool Frame::has_msg_invoke_method() const {
  return msg_case() == kMsgInvokeMethod;
}
inline void Frame::set_has_msg_invoke_method() {
  _oneof_case_[0] = kMsgInvokeMethod;
}
inline void Frame::clear_msg_invoke_method() {
  if (has_msg_invoke_method()) {
    delete msg_.msg_invoke_method_;
    clear_has_msg();
  }
}
inline  const ::perfetto::ipc::Frame_InvokeMethod& Frame::msg_invoke_method() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.msg_invoke_method)
  return has_msg_invoke_method()
      ? *msg_.msg_invoke_method_
      : ::perfetto::ipc::Frame_InvokeMethod::default_instance();
}
inline ::perfetto::ipc::Frame_InvokeMethod* Frame::mutable_msg_invoke_method() {
  if (!has_msg_invoke_method()) {
    clear_msg();
    set_has_msg_invoke_method();
    msg_.msg_invoke_method_ = new ::perfetto::ipc::Frame_InvokeMethod;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.ipc.Frame.msg_invoke_method)
  return msg_.msg_invoke_method_;
}
inline ::perfetto::ipc::Frame_InvokeMethod* Frame::release_msg_invoke_method() {
  // @@protoc_insertion_point(field_release:perfetto.ipc.Frame.msg_invoke_method)
  if (has_msg_invoke_method()) {
    clear_has_msg();
    ::perfetto::ipc::Frame_InvokeMethod* temp = msg_.msg_invoke_method_;
    msg_.msg_invoke_method_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Frame::set_allocated_msg_invoke_method(::perfetto::ipc::Frame_InvokeMethod* msg_invoke_method) {
  clear_msg();
  if (msg_invoke_method) {
    set_has_msg_invoke_method();
    msg_.msg_invoke_method_ = msg_invoke_method;
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.ipc.Frame.msg_invoke_method)
}

// optional .perfetto.ipc.Frame.InvokeMethodReply msg_invoke_method_reply = 6;
inline bool Frame::has_msg_invoke_method_reply() const {
  return msg_case() == kMsgInvokeMethodReply;
}
inline void Frame::set_has_msg_invoke_method_reply() {
  _oneof_case_[0] = kMsgInvokeMethodReply;
}
inline void Frame::clear_msg_invoke_method_reply() {
  if (has_msg_invoke_method_reply()) {
    delete msg_.msg_invoke_method_reply_;
    clear_has_msg();
  }
}
inline  const ::perfetto::ipc::Frame_InvokeMethodReply& Frame::msg_invoke_method_reply() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.msg_invoke_method_reply)
  return has_msg_invoke_method_reply()
      ? *msg_.msg_invoke_method_reply_
      : ::perfetto::ipc::Frame_InvokeMethodReply::default_instance();
}
inline ::perfetto::ipc::Frame_InvokeMethodReply* Frame::mutable_msg_invoke_method_reply() {
  if (!has_msg_invoke_method_reply()) {
    clear_msg();
    set_has_msg_invoke_method_reply();
    msg_.msg_invoke_method_reply_ = new ::perfetto::ipc::Frame_InvokeMethodReply;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.ipc.Frame.msg_invoke_method_reply)
  return msg_.msg_invoke_method_reply_;
}
inline ::perfetto::ipc::Frame_InvokeMethodReply* Frame::release_msg_invoke_method_reply() {
  // @@protoc_insertion_point(field_release:perfetto.ipc.Frame.msg_invoke_method_reply)
  if (has_msg_invoke_method_reply()) {
    clear_has_msg();
    ::perfetto::ipc::Frame_InvokeMethodReply* temp = msg_.msg_invoke_method_reply_;
    msg_.msg_invoke_method_reply_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Frame::set_allocated_msg_invoke_method_reply(::perfetto::ipc::Frame_InvokeMethodReply* msg_invoke_method_reply) {
  clear_msg();
  if (msg_invoke_method_reply) {
    set_has_msg_invoke_method_reply();
    msg_.msg_invoke_method_reply_ = msg_invoke_method_reply;
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.ipc.Frame.msg_invoke_method_reply)
}

// optional .perfetto.ipc.Frame.RequestError msg_request_error = 7;
inline bool Frame::has_msg_request_error() const {
  return msg_case() == kMsgRequestError;
}
inline void Frame::set_has_msg_request_error() {
  _oneof_case_[0] = kMsgRequestError;
}
inline void Frame::clear_msg_request_error() {
  if (has_msg_request_error()) {
    delete msg_.msg_request_error_;
    clear_has_msg();
  }
}
inline  const ::perfetto::ipc::Frame_RequestError& Frame::msg_request_error() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.msg_request_error)
  return has_msg_request_error()
      ? *msg_.msg_request_error_
      : ::perfetto::ipc::Frame_RequestError::default_instance();
}
inline ::perfetto::ipc::Frame_RequestError* Frame::mutable_msg_request_error() {
  if (!has_msg_request_error()) {
    clear_msg();
    set_has_msg_request_error();
    msg_.msg_request_error_ = new ::perfetto::ipc::Frame_RequestError;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.ipc.Frame.msg_request_error)
  return msg_.msg_request_error_;
}
inline ::perfetto::ipc::Frame_RequestError* Frame::release_msg_request_error() {
  // @@protoc_insertion_point(field_release:perfetto.ipc.Frame.msg_request_error)
  if (has_msg_request_error()) {
    clear_has_msg();
    ::perfetto::ipc::Frame_RequestError* temp = msg_.msg_request_error_;
    msg_.msg_request_error_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Frame::set_allocated_msg_request_error(::perfetto::ipc::Frame_RequestError* msg_request_error) {
  clear_msg();
  if (msg_request_error) {
    set_has_msg_request_error();
    msg_.msg_request_error_ = msg_request_error;
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.ipc.Frame.msg_request_error)
}

// repeated bytes data_for_testing = 1;
inline int Frame::data_for_testing_size() const {
  return data_for_testing_.size();
}
inline void Frame::clear_data_for_testing() {
  data_for_testing_.Clear();
}
inline const ::std::string& Frame::data_for_testing(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.data_for_testing)
  return data_for_testing_.Get(index);
}
inline ::std::string* Frame::mutable_data_for_testing(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.ipc.Frame.data_for_testing)
  return data_for_testing_.Mutable(index);
}
inline void Frame::set_data_for_testing(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.ipc.Frame.data_for_testing)
  data_for_testing_.Mutable(index)->assign(value);
}
inline void Frame::set_data_for_testing(int index, const char* value) {
  data_for_testing_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.ipc.Frame.data_for_testing)
}
inline void Frame::set_data_for_testing(int index, const void* value, size_t size) {
  data_for_testing_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.ipc.Frame.data_for_testing)
}
inline ::std::string* Frame::add_data_for_testing() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.ipc.Frame.data_for_testing)
  return data_for_testing_.Add();
}
inline void Frame::add_data_for_testing(const ::std::string& value) {
  data_for_testing_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.ipc.Frame.data_for_testing)
}
inline void Frame::add_data_for_testing(const char* value) {
  data_for_testing_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.ipc.Frame.data_for_testing)
}
inline void Frame::add_data_for_testing(const void* value, size_t size) {
  data_for_testing_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.ipc.Frame.data_for_testing)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Frame::data_for_testing() const {
  // @@protoc_insertion_point(field_list:perfetto.ipc.Frame.data_for_testing)
  return data_for_testing_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Frame::mutable_data_for_testing() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.ipc.Frame.data_for_testing)
  return &data_for_testing_;
}

inline bool Frame::has_msg() const {
  return msg_case() != MSG_NOT_SET;
}
inline void Frame::clear_has_msg() {
  _oneof_case_[0] = MSG_NOT_SET;
}
inline Frame::MsgCase Frame::msg_case() const {
  return Frame::MsgCase(_oneof_case_[0]);
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ipc
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2fipc_2fwire_5fprotocol_2eproto__INCLUDED
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/ipc/consumer_port.pb.h
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/common/observable_events.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/common/observable_events.proto

#ifndef PROTOBUF_protos_2fperfetto_2fcommon_2fobservable_5fevents_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2fcommon_2fobservable_5fevents_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2fcommon_2fobservable_5fevents_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2fobservable_5fevents_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2fobservable_5fevents_2eproto();

class ObservableEvents;
class ObservableEvents_DataSourceInstanceStateChange;

enum ObservableEvents_Type {
  ObservableEvents_Type_TYPE_UNSPECIFIED = 0,
  ObservableEvents_Type_TYPE_DATA_SOURCES_INSTANCES = 1
};
bool ObservableEvents_Type_IsValid(int value);
const ObservableEvents_Type ObservableEvents_Type_Type_MIN = ObservableEvents_Type_TYPE_UNSPECIFIED;
const ObservableEvents_Type ObservableEvents_Type_Type_MAX = ObservableEvents_Type_TYPE_DATA_SOURCES_INSTANCES;
const int ObservableEvents_Type_Type_ARRAYSIZE = ObservableEvents_Type_Type_MAX + 1;

enum ObservableEvents_DataSourceInstanceState {
  ObservableEvents_DataSourceInstanceState_DATA_SOURCE_INSTANCE_STATE_STOPPED = 1,
  ObservableEvents_DataSourceInstanceState_DATA_SOURCE_INSTANCE_STATE_STARTED = 2
};
bool ObservableEvents_DataSourceInstanceState_IsValid(int value);
const ObservableEvents_DataSourceInstanceState ObservableEvents_DataSourceInstanceState_DataSourceInstanceState_MIN = ObservableEvents_DataSourceInstanceState_DATA_SOURCE_INSTANCE_STATE_STOPPED;
const ObservableEvents_DataSourceInstanceState ObservableEvents_DataSourceInstanceState_DataSourceInstanceState_MAX = ObservableEvents_DataSourceInstanceState_DATA_SOURCE_INSTANCE_STATE_STARTED;
const int ObservableEvents_DataSourceInstanceState_DataSourceInstanceState_ARRAYSIZE = ObservableEvents_DataSourceInstanceState_DataSourceInstanceState_MAX + 1;

// ===================================================================

class ObservableEvents_DataSourceInstanceStateChange : public ::google::protobuf::MessageLite {
 public:
  ObservableEvents_DataSourceInstanceStateChange();
  virtual ~ObservableEvents_DataSourceInstanceStateChange();

  ObservableEvents_DataSourceInstanceStateChange(const ObservableEvents_DataSourceInstanceStateChange& from);

  inline ObservableEvents_DataSourceInstanceStateChange& operator=(const ObservableEvents_DataSourceInstanceStateChange& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ObservableEvents_DataSourceInstanceStateChange& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ObservableEvents_DataSourceInstanceStateChange* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ObservableEvents_DataSourceInstanceStateChange* other);

  // implements Message ----------------------------------------------

  inline ObservableEvents_DataSourceInstanceStateChange* New() const { return New(NULL); }

  ObservableEvents_DataSourceInstanceStateChange* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ObservableEvents_DataSourceInstanceStateChange& from);
  void MergeFrom(const ObservableEvents_DataSourceInstanceStateChange& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ObservableEvents_DataSourceInstanceStateChange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string producer_name = 1;
  bool has_producer_name() const;
  void clear_producer_name();
  static const int kProducerNameFieldNumber = 1;
  const ::std::string& producer_name() const;
  void set_producer_name(const ::std::string& value);
  void set_producer_name(const char* value);
  void set_producer_name(const char* value, size_t size);
  ::std::string* mutable_producer_name();
  ::std::string* release_producer_name();
  void set_allocated_producer_name(::std::string* producer_name);

  // optional string data_source_name = 2;
  bool has_data_source_name() const;
  void clear_data_source_name();
  static const int kDataSourceNameFieldNumber = 2;
  const ::std::string& data_source_name() const;
  void set_data_source_name(const ::std::string& value);
  void set_data_source_name(const char* value);
  void set_data_source_name(const char* value, size_t size);
  ::std::string* mutable_data_source_name();
  ::std::string* release_data_source_name();
  void set_allocated_data_source_name(::std::string* data_source_name);

  // optional .perfetto.protos.ObservableEvents.DataSourceInstanceState state = 3;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 3;
  ::perfetto::protos::ObservableEvents_DataSourceInstanceState state() const;
  void set_state(::perfetto::protos::ObservableEvents_DataSourceInstanceState value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange)
 private:
  inline void set_has_producer_name();
  inline void clear_has_producer_name();
  inline void set_has_data_source_name();
  inline void clear_has_data_source_name();
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr producer_name_;
  ::google::protobuf::internal::ArenaStringPtr data_source_name_;
  int state_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fobservable_5fevents_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fobservable_5fevents_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2fobservable_5fevents_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2fobservable_5fevents_2eproto();

  void InitAsDefaultInstance();
  static ObservableEvents_DataSourceInstanceStateChange* default_instance_;
};
// -------------------------------------------------------------------

class ObservableEvents : public ::google::protobuf::MessageLite {
 public:
  ObservableEvents();
  virtual ~ObservableEvents();

  ObservableEvents(const ObservableEvents& from);

  inline ObservableEvents& operator=(const ObservableEvents& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ObservableEvents& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ObservableEvents* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ObservableEvents* other);

  // implements Message ----------------------------------------------

  inline ObservableEvents* New() const { return New(NULL); }

  ObservableEvents* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ObservableEvents& from);
  void MergeFrom(const ObservableEvents& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ObservableEvents* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ObservableEvents_DataSourceInstanceStateChange DataSourceInstanceStateChange;

  typedef ObservableEvents_Type Type;
  static const Type TYPE_UNSPECIFIED =
    ObservableEvents_Type_TYPE_UNSPECIFIED;
  static const Type TYPE_DATA_SOURCES_INSTANCES =
    ObservableEvents_Type_TYPE_DATA_SOURCES_INSTANCES;
  static inline bool Type_IsValid(int value) {
    return ObservableEvents_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ObservableEvents_Type_Type_MIN;
  static const Type Type_MAX =
    ObservableEvents_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ObservableEvents_Type_Type_ARRAYSIZE;

  typedef ObservableEvents_DataSourceInstanceState DataSourceInstanceState;
  static const DataSourceInstanceState DATA_SOURCE_INSTANCE_STATE_STOPPED =
    ObservableEvents_DataSourceInstanceState_DATA_SOURCE_INSTANCE_STATE_STOPPED;
  static const DataSourceInstanceState DATA_SOURCE_INSTANCE_STATE_STARTED =
    ObservableEvents_DataSourceInstanceState_DATA_SOURCE_INSTANCE_STATE_STARTED;
  static inline bool DataSourceInstanceState_IsValid(int value) {
    return ObservableEvents_DataSourceInstanceState_IsValid(value);
  }
  static const DataSourceInstanceState DataSourceInstanceState_MIN =
    ObservableEvents_DataSourceInstanceState_DataSourceInstanceState_MIN;
  static const DataSourceInstanceState DataSourceInstanceState_MAX =
    ObservableEvents_DataSourceInstanceState_DataSourceInstanceState_MAX;
  static const int DataSourceInstanceState_ARRAYSIZE =
    ObservableEvents_DataSourceInstanceState_DataSourceInstanceState_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .perfetto.protos.ObservableEvents.DataSourceInstanceStateChange instance_state_changes = 1;
  int instance_state_changes_size() const;
  void clear_instance_state_changes();
  static const int kInstanceStateChangesFieldNumber = 1;
  const ::perfetto::protos::ObservableEvents_DataSourceInstanceStateChange& instance_state_changes(int index) const;
  ::perfetto::protos::ObservableEvents_DataSourceInstanceStateChange* mutable_instance_state_changes(int index);
  ::perfetto::protos::ObservableEvents_DataSourceInstanceStateChange* add_instance_state_changes();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::ObservableEvents_DataSourceInstanceStateChange >*
      mutable_instance_state_changes();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::ObservableEvents_DataSourceInstanceStateChange >&
      instance_state_changes() const;

  // @@protoc_insertion_point(class_scope:perfetto.protos.ObservableEvents)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::ObservableEvents_DataSourceInstanceStateChange > instance_state_changes_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fobservable_5fevents_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fobservable_5fevents_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2fobservable_5fevents_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2fobservable_5fevents_2eproto();

  void InitAsDefaultInstance();
  static ObservableEvents* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// ObservableEvents_DataSourceInstanceStateChange

// optional string producer_name = 1;
inline bool ObservableEvents_DataSourceInstanceStateChange::has_producer_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObservableEvents_DataSourceInstanceStateChange::set_has_producer_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ObservableEvents_DataSourceInstanceStateChange::clear_has_producer_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ObservableEvents_DataSourceInstanceStateChange::clear_producer_name() {
  producer_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_producer_name();
}
inline const ::std::string& ObservableEvents_DataSourceInstanceStateChange::producer_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.producer_name)
  return producer_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ObservableEvents_DataSourceInstanceStateChange::set_producer_name(const ::std::string& value) {
  set_has_producer_name();
  producer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.producer_name)
}
inline void ObservableEvents_DataSourceInstanceStateChange::set_producer_name(const char* value) {
  set_has_producer_name();
  producer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.producer_name)
}
inline void ObservableEvents_DataSourceInstanceStateChange::set_producer_name(const char* value, size_t size) {
  set_has_producer_name();
  producer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.producer_name)
}
inline ::std::string* ObservableEvents_DataSourceInstanceStateChange::mutable_producer_name() {
  set_has_producer_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.producer_name)
  return producer_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ObservableEvents_DataSourceInstanceStateChange::release_producer_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.producer_name)
  clear_has_producer_name();
  return producer_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ObservableEvents_DataSourceInstanceStateChange::set_allocated_producer_name(::std::string* producer_name) {
  if (producer_name != NULL) {
    set_has_producer_name();
  } else {
    clear_has_producer_name();
  }
  producer_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), producer_name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.producer_name)
}

// optional string data_source_name = 2;
inline bool ObservableEvents_DataSourceInstanceStateChange::has_data_source_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ObservableEvents_DataSourceInstanceStateChange::set_has_data_source_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ObservableEvents_DataSourceInstanceStateChange::clear_has_data_source_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ObservableEvents_DataSourceInstanceStateChange::clear_data_source_name() {
  data_source_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data_source_name();
}
inline const ::std::string& ObservableEvents_DataSourceInstanceStateChange::data_source_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.data_source_name)
  return data_source_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ObservableEvents_DataSourceInstanceStateChange::set_data_source_name(const ::std::string& value) {
  set_has_data_source_name();
  data_source_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.data_source_name)
}
inline void ObservableEvents_DataSourceInstanceStateChange::set_data_source_name(const char* value) {
  set_has_data_source_name();
  data_source_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.data_source_name)
}
inline void ObservableEvents_DataSourceInstanceStateChange::set_data_source_name(const char* value, size_t size) {
  set_has_data_source_name();
  data_source_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.data_source_name)
}
inline ::std::string* ObservableEvents_DataSourceInstanceStateChange::mutable_data_source_name() {
  set_has_data_source_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.data_source_name)
  return data_source_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ObservableEvents_DataSourceInstanceStateChange::release_data_source_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.data_source_name)
  clear_has_data_source_name();
  return data_source_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ObservableEvents_DataSourceInstanceStateChange::set_allocated_data_source_name(::std::string* data_source_name) {
  if (data_source_name != NULL) {
    set_has_data_source_name();
  } else {
    clear_has_data_source_name();
  }
  data_source_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data_source_name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.data_source_name)
}

// optional .perfetto.protos.ObservableEvents.DataSourceInstanceState state = 3;
inline bool ObservableEvents_DataSourceInstanceStateChange::has_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ObservableEvents_DataSourceInstanceStateChange::set_has_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ObservableEvents_DataSourceInstanceStateChange::clear_has_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ObservableEvents_DataSourceInstanceStateChange::clear_state() {
  state_ = 1;
  clear_has_state();
}
inline ::perfetto::protos::ObservableEvents_DataSourceInstanceState ObservableEvents_DataSourceInstanceStateChange::state() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.state)
  return static_cast< ::perfetto::protos::ObservableEvents_DataSourceInstanceState >(state_);
}
inline void ObservableEvents_DataSourceInstanceStateChange::set_state(::perfetto::protos::ObservableEvents_DataSourceInstanceState value) {
  assert(::perfetto::protos::ObservableEvents_DataSourceInstanceState_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.state)
}

// -------------------------------------------------------------------

// ObservableEvents

// repeated .perfetto.protos.ObservableEvents.DataSourceInstanceStateChange instance_state_changes = 1;
inline int ObservableEvents::instance_state_changes_size() const {
  return instance_state_changes_.size();
}
inline void ObservableEvents::clear_instance_state_changes() {
  instance_state_changes_.Clear();
}
inline const ::perfetto::protos::ObservableEvents_DataSourceInstanceStateChange& ObservableEvents::instance_state_changes(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ObservableEvents.instance_state_changes)
  return instance_state_changes_.Get(index);
}
inline ::perfetto::protos::ObservableEvents_DataSourceInstanceStateChange* ObservableEvents::mutable_instance_state_changes(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.ObservableEvents.instance_state_changes)
  return instance_state_changes_.Mutable(index);
}
inline ::perfetto::protos::ObservableEvents_DataSourceInstanceStateChange* ObservableEvents::add_instance_state_changes() {
  // @@protoc_insertion_point(field_add:perfetto.protos.ObservableEvents.instance_state_changes)
  return instance_state_changes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::ObservableEvents_DataSourceInstanceStateChange >*
ObservableEvents::mutable_instance_state_changes() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.ObservableEvents.instance_state_changes)
  return &instance_state_changes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::ObservableEvents_DataSourceInstanceStateChange >&
ObservableEvents::instance_state_changes() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.ObservableEvents.instance_state_changes)
  return instance_state_changes_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::perfetto::protos::ObservableEvents_Type> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::perfetto::protos::ObservableEvents_DataSourceInstanceState> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2fcommon_2fobservable_5fevents_2eproto__INCLUDED
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/common/tracing_service_state.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/common/tracing_service_state.proto

#ifndef PROTOBUF_protos_2fperfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// gen_amalgamated expanded: #include "protos/perfetto/common/data_source_descriptor.pb.h"
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto();

class TracingServiceState;
class TracingServiceState_DataSource;
class TracingServiceState_Producer;

// ===================================================================

class TracingServiceState_Producer : public ::google::protobuf::MessageLite {
 public:
  TracingServiceState_Producer();
  virtual ~TracingServiceState_Producer();

  TracingServiceState_Producer(const TracingServiceState_Producer& from);

  inline TracingServiceState_Producer& operator=(const TracingServiceState_Producer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TracingServiceState_Producer& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TracingServiceState_Producer* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TracingServiceState_Producer* other);

  // implements Message ----------------------------------------------

  inline TracingServiceState_Producer* New() const { return New(NULL); }

  TracingServiceState_Producer* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TracingServiceState_Producer& from);
  void MergeFrom(const TracingServiceState_Producer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TracingServiceState_Producer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional int32 uid = 3;
  bool has_uid() const;
  void clear_uid();
  static const int kUidFieldNumber = 3;
  ::google::protobuf::int32 uid() const;
  void set_uid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.TracingServiceState.Producer)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_uid();
  inline void clear_has_uid();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 uid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto();

  void InitAsDefaultInstance();
  static TracingServiceState_Producer* default_instance_;
};
// -------------------------------------------------------------------

class TracingServiceState_DataSource : public ::google::protobuf::MessageLite {
 public:
  TracingServiceState_DataSource();
  virtual ~TracingServiceState_DataSource();

  TracingServiceState_DataSource(const TracingServiceState_DataSource& from);

  inline TracingServiceState_DataSource& operator=(const TracingServiceState_DataSource& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TracingServiceState_DataSource& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TracingServiceState_DataSource* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TracingServiceState_DataSource* other);

  // implements Message ----------------------------------------------

  inline TracingServiceState_DataSource* New() const { return New(NULL); }

  TracingServiceState_DataSource* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TracingServiceState_DataSource& from);
  void MergeFrom(const TracingServiceState_DataSource& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TracingServiceState_DataSource* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .perfetto.protos.DataSourceDescriptor ds_descriptor = 1;
  bool has_ds_descriptor() const;
  void clear_ds_descriptor();
  static const int kDsDescriptorFieldNumber = 1;
  const ::perfetto::protos::DataSourceDescriptor& ds_descriptor() const;
  ::perfetto::protos::DataSourceDescriptor* mutable_ds_descriptor();
  ::perfetto::protos::DataSourceDescriptor* release_ds_descriptor();
  void set_allocated_ds_descriptor(::perfetto::protos::DataSourceDescriptor* ds_descriptor);

  // optional int32 producer_id = 2;
  bool has_producer_id() const;
  void clear_producer_id();
  static const int kProducerIdFieldNumber = 2;
  ::google::protobuf::int32 producer_id() const;
  void set_producer_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.TracingServiceState.DataSource)
 private:
  inline void set_has_ds_descriptor();
  inline void clear_has_ds_descriptor();
  inline void set_has_producer_id();
  inline void clear_has_producer_id();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::perfetto::protos::DataSourceDescriptor* ds_descriptor_;
  ::google::protobuf::int32 producer_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto();

  void InitAsDefaultInstance();
  static TracingServiceState_DataSource* default_instance_;
};
// -------------------------------------------------------------------

class TracingServiceState : public ::google::protobuf::MessageLite {
 public:
  TracingServiceState();
  virtual ~TracingServiceState();

  TracingServiceState(const TracingServiceState& from);

  inline TracingServiceState& operator=(const TracingServiceState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TracingServiceState& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TracingServiceState* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TracingServiceState* other);

  // implements Message ----------------------------------------------

  inline TracingServiceState* New() const { return New(NULL); }

  TracingServiceState* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TracingServiceState& from);
  void MergeFrom(const TracingServiceState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TracingServiceState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef TracingServiceState_Producer Producer;
  typedef TracingServiceState_DataSource DataSource;

  // accessors -------------------------------------------------------

  // repeated .perfetto.protos.TracingServiceState.Producer producers = 1;
  int producers_size() const;
  void clear_producers();
  static const int kProducersFieldNumber = 1;
  const ::perfetto::protos::TracingServiceState_Producer& producers(int index) const;
  ::perfetto::protos::TracingServiceState_Producer* mutable_producers(int index);
  ::perfetto::protos::TracingServiceState_Producer* add_producers();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TracingServiceState_Producer >*
      mutable_producers();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TracingServiceState_Producer >&
      producers() const;

  // repeated .perfetto.protos.TracingServiceState.DataSource data_sources = 2;
  int data_sources_size() const;
  void clear_data_sources();
  static const int kDataSourcesFieldNumber = 2;
  const ::perfetto::protos::TracingServiceState_DataSource& data_sources(int index) const;
  ::perfetto::protos::TracingServiceState_DataSource* mutable_data_sources(int index);
  ::perfetto::protos::TracingServiceState_DataSource* add_data_sources();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TracingServiceState_DataSource >*
      mutable_data_sources();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TracingServiceState_DataSource >&
      data_sources() const;

  // optional int32 num_sessions = 3;
  bool has_num_sessions() const;
  void clear_num_sessions();
  static const int kNumSessionsFieldNumber = 3;
  ::google::protobuf::int32 num_sessions() const;
  void set_num_sessions(::google::protobuf::int32 value);

  // optional int32 num_sessions_started = 4;
  bool has_num_sessions_started() const;
  void clear_num_sessions_started();
  static const int kNumSessionsStartedFieldNumber = 4;
  ::google::protobuf::int32 num_sessions_started() const;
  void set_num_sessions_started(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.TracingServiceState)
 private:
  inline void set_has_num_sessions();
  inline void clear_has_num_sessions();
  inline void set_has_num_sessions_started();
  inline void clear_has_num_sessions_started();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TracingServiceState_Producer > producers_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TracingServiceState_DataSource > data_sources_;
  ::google::protobuf::int32 num_sessions_;
  ::google::protobuf::int32 num_sessions_started_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto();

  void InitAsDefaultInstance();
  static TracingServiceState* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// TracingServiceState_Producer

// optional int32 id = 1;
inline bool TracingServiceState_Producer::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TracingServiceState_Producer::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TracingServiceState_Producer::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TracingServiceState_Producer::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 TracingServiceState_Producer::id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TracingServiceState.Producer.id)
  return id_;
}
inline void TracingServiceState_Producer::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TracingServiceState.Producer.id)
}

// optional string name = 2;
inline bool TracingServiceState_Producer::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TracingServiceState_Producer::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TracingServiceState_Producer::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TracingServiceState_Producer::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& TracingServiceState_Producer::name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TracingServiceState.Producer.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TracingServiceState_Producer::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.TracingServiceState.Producer.name)
}
inline void TracingServiceState_Producer::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.TracingServiceState.Producer.name)
}
inline void TracingServiceState_Producer::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.TracingServiceState.Producer.name)
}
inline ::std::string* TracingServiceState_Producer::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TracingServiceState.Producer.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TracingServiceState_Producer::release_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TracingServiceState.Producer.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TracingServiceState_Producer::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TracingServiceState.Producer.name)
}

// optional int32 uid = 3;
inline bool TracingServiceState_Producer::has_uid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TracingServiceState_Producer::set_has_uid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TracingServiceState_Producer::clear_has_uid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TracingServiceState_Producer::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 TracingServiceState_Producer::uid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TracingServiceState.Producer.uid)
  return uid_;
}
inline void TracingServiceState_Producer::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TracingServiceState.Producer.uid)
}

// -------------------------------------------------------------------

// TracingServiceState_DataSource

// optional .perfetto.protos.DataSourceDescriptor ds_descriptor = 1;
inline bool TracingServiceState_DataSource::has_ds_descriptor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TracingServiceState_DataSource::set_has_ds_descriptor() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TracingServiceState_DataSource::clear_has_ds_descriptor() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TracingServiceState_DataSource::clear_ds_descriptor() {
  if (ds_descriptor_ != NULL) ds_descriptor_->::perfetto::protos::DataSourceDescriptor::Clear();
  clear_has_ds_descriptor();
}
inline const ::perfetto::protos::DataSourceDescriptor& TracingServiceState_DataSource::ds_descriptor() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TracingServiceState.DataSource.ds_descriptor)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return ds_descriptor_ != NULL ? *ds_descriptor_ : *default_instance().ds_descriptor_;
#else
  return ds_descriptor_ != NULL ? *ds_descriptor_ : *default_instance_->ds_descriptor_;
#endif
}
inline ::perfetto::protos::DataSourceDescriptor* TracingServiceState_DataSource::mutable_ds_descriptor() {
  set_has_ds_descriptor();
  if (ds_descriptor_ == NULL) {
    ds_descriptor_ = new ::perfetto::protos::DataSourceDescriptor;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TracingServiceState.DataSource.ds_descriptor)
  return ds_descriptor_;
}
inline ::perfetto::protos::DataSourceDescriptor* TracingServiceState_DataSource::release_ds_descriptor() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TracingServiceState.DataSource.ds_descriptor)
  clear_has_ds_descriptor();
  ::perfetto::protos::DataSourceDescriptor* temp = ds_descriptor_;
  ds_descriptor_ = NULL;
  return temp;
}
inline void TracingServiceState_DataSource::set_allocated_ds_descriptor(::perfetto::protos::DataSourceDescriptor* ds_descriptor) {
  delete ds_descriptor_;
  ds_descriptor_ = ds_descriptor;
  if (ds_descriptor) {
    set_has_ds_descriptor();
  } else {
    clear_has_ds_descriptor();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TracingServiceState.DataSource.ds_descriptor)
}

// optional int32 producer_id = 2;
inline bool TracingServiceState_DataSource::has_producer_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TracingServiceState_DataSource::set_has_producer_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TracingServiceState_DataSource::clear_has_producer_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TracingServiceState_DataSource::clear_producer_id() {
  producer_id_ = 0;
  clear_has_producer_id();
}
inline ::google::protobuf::int32 TracingServiceState_DataSource::producer_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TracingServiceState.DataSource.producer_id)
  return producer_id_;
}
inline void TracingServiceState_DataSource::set_producer_id(::google::protobuf::int32 value) {
  set_has_producer_id();
  producer_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TracingServiceState.DataSource.producer_id)
}

// -------------------------------------------------------------------

// TracingServiceState

// repeated .perfetto.protos.TracingServiceState.Producer producers = 1;
inline int TracingServiceState::producers_size() const {
  return producers_.size();
}
inline void TracingServiceState::clear_producers() {
  producers_.Clear();
}
inline const ::perfetto::protos::TracingServiceState_Producer& TracingServiceState::producers(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TracingServiceState.producers)
  return producers_.Get(index);
}
inline ::perfetto::protos::TracingServiceState_Producer* TracingServiceState::mutable_producers(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TracingServiceState.producers)
  return producers_.Mutable(index);
}
inline ::perfetto::protos::TracingServiceState_Producer* TracingServiceState::add_producers() {
  // @@protoc_insertion_point(field_add:perfetto.protos.TracingServiceState.producers)
  return producers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TracingServiceState_Producer >*
TracingServiceState::mutable_producers() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.TracingServiceState.producers)
  return &producers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TracingServiceState_Producer >&
TracingServiceState::producers() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.TracingServiceState.producers)
  return producers_;
}

// repeated .perfetto.protos.TracingServiceState.DataSource data_sources = 2;
inline int TracingServiceState::data_sources_size() const {
  return data_sources_.size();
}
inline void TracingServiceState::clear_data_sources() {
  data_sources_.Clear();
}
inline const ::perfetto::protos::TracingServiceState_DataSource& TracingServiceState::data_sources(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TracingServiceState.data_sources)
  return data_sources_.Get(index);
}
inline ::perfetto::protos::TracingServiceState_DataSource* TracingServiceState::mutable_data_sources(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TracingServiceState.data_sources)
  return data_sources_.Mutable(index);
}
inline ::perfetto::protos::TracingServiceState_DataSource* TracingServiceState::add_data_sources() {
  // @@protoc_insertion_point(field_add:perfetto.protos.TracingServiceState.data_sources)
  return data_sources_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TracingServiceState_DataSource >*
TracingServiceState::mutable_data_sources() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.TracingServiceState.data_sources)
  return &data_sources_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TracingServiceState_DataSource >&
TracingServiceState::data_sources() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.TracingServiceState.data_sources)
  return data_sources_;
}

// optional int32 num_sessions = 3;
inline bool TracingServiceState::has_num_sessions() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TracingServiceState::set_has_num_sessions() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TracingServiceState::clear_has_num_sessions() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TracingServiceState::clear_num_sessions() {
  num_sessions_ = 0;
  clear_has_num_sessions();
}
inline ::google::protobuf::int32 TracingServiceState::num_sessions() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TracingServiceState.num_sessions)
  return num_sessions_;
}
inline void TracingServiceState::set_num_sessions(::google::protobuf::int32 value) {
  set_has_num_sessions();
  num_sessions_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TracingServiceState.num_sessions)
}

// optional int32 num_sessions_started = 4;
inline bool TracingServiceState::has_num_sessions_started() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TracingServiceState::set_has_num_sessions_started() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TracingServiceState::clear_has_num_sessions_started() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TracingServiceState::clear_num_sessions_started() {
  num_sessions_started_ = 0;
  clear_has_num_sessions_started();
}
inline ::google::protobuf::int32 TracingServiceState::num_sessions_started() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TracingServiceState.num_sessions_started)
  return num_sessions_started_;
}
inline void TracingServiceState::set_num_sessions_started(::google::protobuf::int32 value) {
  set_has_num_sessions_started();
  num_sessions_started_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TracingServiceState.num_sessions_started)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto__INCLUDED
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/common/trace_stats.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/common/trace_stats.proto

#ifndef PROTOBUF_protos_2fperfetto_2fcommon_2ftrace_5fstats_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2fcommon_2ftrace_5fstats_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2fcommon_2ftrace_5fstats_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2ftrace_5fstats_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2ftrace_5fstats_2eproto();

class TraceStats;
class TraceStats_BufferStats;

// ===================================================================

class TraceStats_BufferStats : public ::google::protobuf::MessageLite {
 public:
  TraceStats_BufferStats();
  virtual ~TraceStats_BufferStats();

  TraceStats_BufferStats(const TraceStats_BufferStats& from);

  inline TraceStats_BufferStats& operator=(const TraceStats_BufferStats& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TraceStats_BufferStats& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TraceStats_BufferStats* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TraceStats_BufferStats* other);

  // implements Message ----------------------------------------------

  inline TraceStats_BufferStats* New() const { return New(NULL); }

  TraceStats_BufferStats* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TraceStats_BufferStats& from);
  void MergeFrom(const TraceStats_BufferStats& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TraceStats_BufferStats* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 buffer_size = 12;
  bool has_buffer_size() const;
  void clear_buffer_size();
  static const int kBufferSizeFieldNumber = 12;
  ::google::protobuf::uint64 buffer_size() const;
  void set_buffer_size(::google::protobuf::uint64 value);

  // optional uint64 bytes_written = 1;
  bool has_bytes_written() const;
  void clear_bytes_written();
  static const int kBytesWrittenFieldNumber = 1;
  ::google::protobuf::uint64 bytes_written() const;
  void set_bytes_written(::google::protobuf::uint64 value);

  // optional uint64 bytes_overwritten = 13;
  bool has_bytes_overwritten() const;
  void clear_bytes_overwritten();
  static const int kBytesOverwrittenFieldNumber = 13;
  ::google::protobuf::uint64 bytes_overwritten() const;
  void set_bytes_overwritten(::google::protobuf::uint64 value);

  // optional uint64 bytes_read = 14;
  bool has_bytes_read() const;
  void clear_bytes_read();
  static const int kBytesReadFieldNumber = 14;
  ::google::protobuf::uint64 bytes_read() const;
  void set_bytes_read(::google::protobuf::uint64 value);

  // optional uint64 padding_bytes_written = 15;
  bool has_padding_bytes_written() const;
  void clear_padding_bytes_written();
  static const int kPaddingBytesWrittenFieldNumber = 15;
  ::google::protobuf::uint64 padding_bytes_written() const;
  void set_padding_bytes_written(::google::protobuf::uint64 value);

  // optional uint64 padding_bytes_cleared = 16;
  bool has_padding_bytes_cleared() const;
  void clear_padding_bytes_cleared();
  static const int kPaddingBytesClearedFieldNumber = 16;
  ::google::protobuf::uint64 padding_bytes_cleared() const;
  void set_padding_bytes_cleared(::google::protobuf::uint64 value);

  // optional uint64 chunks_written = 2;
  bool has_chunks_written() const;
  void clear_chunks_written();
  static const int kChunksWrittenFieldNumber = 2;
  ::google::protobuf::uint64 chunks_written() const;
  void set_chunks_written(::google::protobuf::uint64 value);

  // optional uint64 chunks_rewritten = 10;
  bool has_chunks_rewritten() const;
  void clear_chunks_rewritten();
  static const int kChunksRewrittenFieldNumber = 10;
  ::google::protobuf::uint64 chunks_rewritten() const;
  void set_chunks_rewritten(::google::protobuf::uint64 value);

  // optional uint64 chunks_overwritten = 3;
  bool has_chunks_overwritten() const;
  void clear_chunks_overwritten();
  static const int kChunksOverwrittenFieldNumber = 3;
  ::google::protobuf::uint64 chunks_overwritten() const;
  void set_chunks_overwritten(::google::protobuf::uint64 value);

  // optional uint64 chunks_discarded = 18;
  bool has_chunks_discarded() const;
  void clear_chunks_discarded();
  static const int kChunksDiscardedFieldNumber = 18;
  ::google::protobuf::uint64 chunks_discarded() const;
  void set_chunks_discarded(::google::protobuf::uint64 value);

  // optional uint64 chunks_read = 17;
  bool has_chunks_read() const;
  void clear_chunks_read();
  static const int kChunksReadFieldNumber = 17;
  ::google::protobuf::uint64 chunks_read() const;
  void set_chunks_read(::google::protobuf::uint64 value);

  // optional uint64 chunks_committed_out_of_order = 11;
  bool has_chunks_committed_out_of_order() const;
  void clear_chunks_committed_out_of_order();
  static const int kChunksCommittedOutOfOrderFieldNumber = 11;
  ::google::protobuf::uint64 chunks_committed_out_of_order() const;
  void set_chunks_committed_out_of_order(::google::protobuf::uint64 value);

  // optional uint64 write_wrap_count = 4;
  bool has_write_wrap_count() const;
  void clear_write_wrap_count();
  static const int kWriteWrapCountFieldNumber = 4;
  ::google::protobuf::uint64 write_wrap_count() const;
  void set_write_wrap_count(::google::protobuf::uint64 value);

  // optional uint64 patches_succeeded = 5;
  bool has_patches_succeeded() const;
  void clear_patches_succeeded();
  static const int kPatchesSucceededFieldNumber = 5;
  ::google::protobuf::uint64 patches_succeeded() const;
  void set_patches_succeeded(::google::protobuf::uint64 value);

  // optional uint64 patches_failed = 6;
  bool has_patches_failed() const;
  void clear_patches_failed();
  static const int kPatchesFailedFieldNumber = 6;
  ::google::protobuf::uint64 patches_failed() const;
  void set_patches_failed(::google::protobuf::uint64 value);

  // optional uint64 readaheads_succeeded = 7;
  bool has_readaheads_succeeded() const;
  void clear_readaheads_succeeded();
  static const int kReadaheadsSucceededFieldNumber = 7;
  ::google::protobuf::uint64 readaheads_succeeded() const;
  void set_readaheads_succeeded(::google::protobuf::uint64 value);

  // optional uint64 readaheads_failed = 8;
  bool has_readaheads_failed() const;
  void clear_readaheads_failed();
  static const int kReadaheadsFailedFieldNumber = 8;
  ::google::protobuf::uint64 readaheads_failed() const;
  void set_readaheads_failed(::google::protobuf::uint64 value);

  // optional uint64 abi_violations = 9;
  bool has_abi_violations() const;
  void clear_abi_violations();
  static const int kAbiViolationsFieldNumber = 9;
  ::google::protobuf::uint64 abi_violations() const;
  void set_abi_violations(::google::protobuf::uint64 value);

  // optional uint64 trace_writer_packet_loss = 19;
  bool has_trace_writer_packet_loss() const;
  void clear_trace_writer_packet_loss();
  static const int kTraceWriterPacketLossFieldNumber = 19;
  ::google::protobuf::uint64 trace_writer_packet_loss() const;
  void set_trace_writer_packet_loss(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.TraceStats.BufferStats)
 private:
  inline void set_has_buffer_size();
  inline void clear_has_buffer_size();
  inline void set_has_bytes_written();
  inline void clear_has_bytes_written();
  inline void set_has_bytes_overwritten();
  inline void clear_has_bytes_overwritten();
  inline void set_has_bytes_read();
  inline void clear_has_bytes_read();
  inline void set_has_padding_bytes_written();
  inline void clear_has_padding_bytes_written();
  inline void set_has_padding_bytes_cleared();
  inline void clear_has_padding_bytes_cleared();
  inline void set_has_chunks_written();
  inline void clear_has_chunks_written();
  inline void set_has_chunks_rewritten();
  inline void clear_has_chunks_rewritten();
  inline void set_has_chunks_overwritten();
  inline void clear_has_chunks_overwritten();
  inline void set_has_chunks_discarded();
  inline void clear_has_chunks_discarded();
  inline void set_has_chunks_read();
  inline void clear_has_chunks_read();
  inline void set_has_chunks_committed_out_of_order();
  inline void clear_has_chunks_committed_out_of_order();
  inline void set_has_write_wrap_count();
  inline void clear_has_write_wrap_count();
  inline void set_has_patches_succeeded();
  inline void clear_has_patches_succeeded();
  inline void set_has_patches_failed();
  inline void clear_has_patches_failed();
  inline void set_has_readaheads_succeeded();
  inline void clear_has_readaheads_succeeded();
  inline void set_has_readaheads_failed();
  inline void clear_has_readaheads_failed();
  inline void set_has_abi_violations();
  inline void clear_has_abi_violations();
  inline void set_has_trace_writer_packet_loss();
  inline void clear_has_trace_writer_packet_loss();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 buffer_size_;
  ::google::protobuf::uint64 bytes_written_;
  ::google::protobuf::uint64 bytes_overwritten_;
  ::google::protobuf::uint64 bytes_read_;
  ::google::protobuf::uint64 padding_bytes_written_;
  ::google::protobuf::uint64 padding_bytes_cleared_;
  ::google::protobuf::uint64 chunks_written_;
  ::google::protobuf::uint64 chunks_rewritten_;
  ::google::protobuf::uint64 chunks_overwritten_;
  ::google::protobuf::uint64 chunks_discarded_;
  ::google::protobuf::uint64 chunks_read_;
  ::google::protobuf::uint64 chunks_committed_out_of_order_;
  ::google::protobuf::uint64 write_wrap_count_;
  ::google::protobuf::uint64 patches_succeeded_;
  ::google::protobuf::uint64 patches_failed_;
  ::google::protobuf::uint64 readaheads_succeeded_;
  ::google::protobuf::uint64 readaheads_failed_;
  ::google::protobuf::uint64 abi_violations_;
  ::google::protobuf::uint64 trace_writer_packet_loss_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2ftrace_5fstats_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2ftrace_5fstats_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2ftrace_5fstats_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2ftrace_5fstats_2eproto();

  void InitAsDefaultInstance();
  static TraceStats_BufferStats* default_instance_;
};
// -------------------------------------------------------------------

class TraceStats : public ::google::protobuf::MessageLite {
 public:
  TraceStats();
  virtual ~TraceStats();

  TraceStats(const TraceStats& from);

  inline TraceStats& operator=(const TraceStats& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TraceStats& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TraceStats* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TraceStats* other);

  // implements Message ----------------------------------------------

  inline TraceStats* New() const { return New(NULL); }

  TraceStats* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TraceStats& from);
  void MergeFrom(const TraceStats& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TraceStats* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef TraceStats_BufferStats BufferStats;

  // accessors -------------------------------------------------------

  // repeated .perfetto.protos.TraceStats.BufferStats buffer_stats = 1;
  int buffer_stats_size() const;
  void clear_buffer_stats();
  static const int kBufferStatsFieldNumber = 1;
  const ::perfetto::protos::TraceStats_BufferStats& buffer_stats(int index) const;
  ::perfetto::protos::TraceStats_BufferStats* mutable_buffer_stats(int index);
  ::perfetto::protos::TraceStats_BufferStats* add_buffer_stats();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceStats_BufferStats >*
      mutable_buffer_stats();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceStats_BufferStats >&
      buffer_stats() const;

  // optional uint32 producers_connected = 2;
  bool has_producers_connected() const;
  void clear_producers_connected();
  static const int kProducersConnectedFieldNumber = 2;
  ::google::protobuf::uint32 producers_connected() const;
  void set_producers_connected(::google::protobuf::uint32 value);

  // optional uint64 producers_seen = 3;
  bool has_producers_seen() const;
  void clear_producers_seen();
  static const int kProducersSeenFieldNumber = 3;
  ::google::protobuf::uint64 producers_seen() const;
  void set_producers_seen(::google::protobuf::uint64 value);

  // optional uint32 data_sources_registered = 4;
  bool has_data_sources_registered() const;
  void clear_data_sources_registered();
  static const int kDataSourcesRegisteredFieldNumber = 4;
  ::google::protobuf::uint32 data_sources_registered() const;
  void set_data_sources_registered(::google::protobuf::uint32 value);

  // optional uint64 data_sources_seen = 5;
  bool has_data_sources_seen() const;
  void clear_data_sources_seen();
  static const int kDataSourcesSeenFieldNumber = 5;
  ::google::protobuf::uint64 data_sources_seen() const;
  void set_data_sources_seen(::google::protobuf::uint64 value);

  // optional uint32 tracing_sessions = 6;
  bool has_tracing_sessions() const;
  void clear_tracing_sessions();
  static const int kTracingSessionsFieldNumber = 6;
  ::google::protobuf::uint32 tracing_sessions() const;
  void set_tracing_sessions(::google::protobuf::uint32 value);

  // optional uint32 total_buffers = 7;
  bool has_total_buffers() const;
  void clear_total_buffers();
  static const int kTotalBuffersFieldNumber = 7;
  ::google::protobuf::uint32 total_buffers() const;
  void set_total_buffers(::google::protobuf::uint32 value);

  // optional uint64 chunks_discarded = 8;
  bool has_chunks_discarded() const;
  void clear_chunks_discarded();
  static const int kChunksDiscardedFieldNumber = 8;
  ::google::protobuf::uint64 chunks_discarded() const;
  void set_chunks_discarded(::google::protobuf::uint64 value);

  // optional uint64 patches_discarded = 9;
  bool has_patches_discarded() const;
  void clear_patches_discarded();
  static const int kPatchesDiscardedFieldNumber = 9;
  ::google::protobuf::uint64 patches_discarded() const;
  void set_patches_discarded(::google::protobuf::uint64 value);

  // optional uint64 invalid_packets = 10;
  bool has_invalid_packets() const;
  void clear_invalid_packets();
  static const int kInvalidPacketsFieldNumber = 10;
  ::google::protobuf::uint64 invalid_packets() const;
  void set_invalid_packets(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.TraceStats)
 private:
  inline void set_has_producers_connected();
  inline void clear_has_producers_connected();
  inline void set_has_producers_seen();
  inline void clear_has_producers_seen();
  inline void set_has_data_sources_registered();
  inline void clear_has_data_sources_registered();
  inline void set_has_data_sources_seen();
  inline void clear_has_data_sources_seen();
  inline void set_has_tracing_sessions();
  inline void clear_has_tracing_sessions();
  inline void set_has_total_buffers();
  inline void clear_has_total_buffers();
  inline void set_has_chunks_discarded();
  inline void clear_has_chunks_discarded();
  inline void set_has_patches_discarded();
  inline void clear_has_patches_discarded();
  inline void set_has_invalid_packets();
  inline void clear_has_invalid_packets();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceStats_BufferStats > buffer_stats_;
  ::google::protobuf::uint64 producers_seen_;
  ::google::protobuf::uint32 producers_connected_;
  ::google::protobuf::uint32 data_sources_registered_;
  ::google::protobuf::uint64 data_sources_seen_;
  ::google::protobuf::uint32 tracing_sessions_;
  ::google::protobuf::uint32 total_buffers_;
  ::google::protobuf::uint64 chunks_discarded_;
  ::google::protobuf::uint64 patches_discarded_;
  ::google::protobuf::uint64 invalid_packets_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2ftrace_5fstats_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2ftrace_5fstats_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2ftrace_5fstats_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2ftrace_5fstats_2eproto();

  void InitAsDefaultInstance();
  static TraceStats* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// TraceStats_BufferStats

// optional uint64 buffer_size = 12;
inline bool TraceStats_BufferStats::has_buffer_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TraceStats_BufferStats::set_has_buffer_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TraceStats_BufferStats::clear_has_buffer_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TraceStats_BufferStats::clear_buffer_size() {
  buffer_size_ = GOOGLE_ULONGLONG(0);
  clear_has_buffer_size();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::buffer_size() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.buffer_size)
  return buffer_size_;
}
inline void TraceStats_BufferStats::set_buffer_size(::google::protobuf::uint64 value) {
  set_has_buffer_size();
  buffer_size_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.buffer_size)
}

// optional uint64 bytes_written = 1;
inline bool TraceStats_BufferStats::has_bytes_written() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TraceStats_BufferStats::set_has_bytes_written() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TraceStats_BufferStats::clear_has_bytes_written() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TraceStats_BufferStats::clear_bytes_written() {
  bytes_written_ = GOOGLE_ULONGLONG(0);
  clear_has_bytes_written();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::bytes_written() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.bytes_written)
  return bytes_written_;
}
inline void TraceStats_BufferStats::set_bytes_written(::google::protobuf::uint64 value) {
  set_has_bytes_written();
  bytes_written_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.bytes_written)
}

// optional uint64 bytes_overwritten = 13;
inline bool TraceStats_BufferStats::has_bytes_overwritten() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TraceStats_BufferStats::set_has_bytes_overwritten() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TraceStats_BufferStats::clear_has_bytes_overwritten() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TraceStats_BufferStats::clear_bytes_overwritten() {
  bytes_overwritten_ = GOOGLE_ULONGLONG(0);
  clear_has_bytes_overwritten();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::bytes_overwritten() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.bytes_overwritten)
  return bytes_overwritten_;
}
inline void TraceStats_BufferStats::set_bytes_overwritten(::google::protobuf::uint64 value) {
  set_has_bytes_overwritten();
  bytes_overwritten_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.bytes_overwritten)
}

// optional uint64 bytes_read = 14;
inline bool TraceStats_BufferStats::has_bytes_read() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TraceStats_BufferStats::set_has_bytes_read() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TraceStats_BufferStats::clear_has_bytes_read() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TraceStats_BufferStats::clear_bytes_read() {
  bytes_read_ = GOOGLE_ULONGLONG(0);
  clear_has_bytes_read();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::bytes_read() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.bytes_read)
  return bytes_read_;
}
inline void TraceStats_BufferStats::set_bytes_read(::google::protobuf::uint64 value) {
  set_has_bytes_read();
  bytes_read_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.bytes_read)
}

// optional uint64 padding_bytes_written = 15;
inline bool TraceStats_BufferStats::has_padding_bytes_written() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TraceStats_BufferStats::set_has_padding_bytes_written() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TraceStats_BufferStats::clear_has_padding_bytes_written() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TraceStats_BufferStats::clear_padding_bytes_written() {
  padding_bytes_written_ = GOOGLE_ULONGLONG(0);
  clear_has_padding_bytes_written();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::padding_bytes_written() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.padding_bytes_written)
  return padding_bytes_written_;
}
inline void TraceStats_BufferStats::set_padding_bytes_written(::google::protobuf::uint64 value) {
  set_has_padding_bytes_written();
  padding_bytes_written_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.padding_bytes_written)
}

// optional uint64 padding_bytes_cleared = 16;
inline bool TraceStats_BufferStats::has_padding_bytes_cleared() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TraceStats_BufferStats::set_has_padding_bytes_cleared() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TraceStats_BufferStats::clear_has_padding_bytes_cleared() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TraceStats_BufferStats::clear_padding_bytes_cleared() {
  padding_bytes_cleared_ = GOOGLE_ULONGLONG(0);
  clear_has_padding_bytes_cleared();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::padding_bytes_cleared() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.padding_bytes_cleared)
  return padding_bytes_cleared_;
}
inline void TraceStats_BufferStats::set_padding_bytes_cleared(::google::protobuf::uint64 value) {
  set_has_padding_bytes_cleared();
  padding_bytes_cleared_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.padding_bytes_cleared)
}

// optional uint64 chunks_written = 2;
inline bool TraceStats_BufferStats::has_chunks_written() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TraceStats_BufferStats::set_has_chunks_written() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TraceStats_BufferStats::clear_has_chunks_written() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TraceStats_BufferStats::clear_chunks_written() {
  chunks_written_ = GOOGLE_ULONGLONG(0);
  clear_has_chunks_written();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::chunks_written() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.chunks_written)
  return chunks_written_;
}
inline void TraceStats_BufferStats::set_chunks_written(::google::protobuf::uint64 value) {
  set_has_chunks_written();
  chunks_written_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.chunks_written)
}

// optional uint64 chunks_rewritten = 10;
inline bool TraceStats_BufferStats::has_chunks_rewritten() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TraceStats_BufferStats::set_has_chunks_rewritten() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TraceStats_BufferStats::clear_has_chunks_rewritten() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TraceStats_BufferStats::clear_chunks_rewritten() {
  chunks_rewritten_ = GOOGLE_ULONGLONG(0);
  clear_has_chunks_rewritten();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::chunks_rewritten() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.chunks_rewritten)
  return chunks_rewritten_;
}
inline void TraceStats_BufferStats::set_chunks_rewritten(::google::protobuf::uint64 value) {
  set_has_chunks_rewritten();
  chunks_rewritten_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.chunks_rewritten)
}

// optional uint64 chunks_overwritten = 3;
inline bool TraceStats_BufferStats::has_chunks_overwritten() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TraceStats_BufferStats::set_has_chunks_overwritten() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TraceStats_BufferStats::clear_has_chunks_overwritten() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TraceStats_BufferStats::clear_chunks_overwritten() {
  chunks_overwritten_ = GOOGLE_ULONGLONG(0);
  clear_has_chunks_overwritten();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::chunks_overwritten() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.chunks_overwritten)
  return chunks_overwritten_;
}
inline void TraceStats_BufferStats::set_chunks_overwritten(::google::protobuf::uint64 value) {
  set_has_chunks_overwritten();
  chunks_overwritten_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.chunks_overwritten)
}

// optional uint64 chunks_discarded = 18;
inline bool TraceStats_BufferStats::has_chunks_discarded() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TraceStats_BufferStats::set_has_chunks_discarded() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TraceStats_BufferStats::clear_has_chunks_discarded() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TraceStats_BufferStats::clear_chunks_discarded() {
  chunks_discarded_ = GOOGLE_ULONGLONG(0);
  clear_has_chunks_discarded();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::chunks_discarded() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.chunks_discarded)
  return chunks_discarded_;
}
inline void TraceStats_BufferStats::set_chunks_discarded(::google::protobuf::uint64 value) {
  set_has_chunks_discarded();
  chunks_discarded_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.chunks_discarded)
}

// optional uint64 chunks_read = 17;
inline bool TraceStats_BufferStats::has_chunks_read() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TraceStats_BufferStats::set_has_chunks_read() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TraceStats_BufferStats::clear_has_chunks_read() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TraceStats_BufferStats::clear_chunks_read() {
  chunks_read_ = GOOGLE_ULONGLONG(0);
  clear_has_chunks_read();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::chunks_read() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.chunks_read)
  return chunks_read_;
}
inline void TraceStats_BufferStats::set_chunks_read(::google::protobuf::uint64 value) {
  set_has_chunks_read();
  chunks_read_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.chunks_read)
}

// optional uint64 chunks_committed_out_of_order = 11;
inline bool TraceStats_BufferStats::has_chunks_committed_out_of_order() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TraceStats_BufferStats::set_has_chunks_committed_out_of_order() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TraceStats_BufferStats::clear_has_chunks_committed_out_of_order() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TraceStats_BufferStats::clear_chunks_committed_out_of_order() {
  chunks_committed_out_of_order_ = GOOGLE_ULONGLONG(0);
  clear_has_chunks_committed_out_of_order();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::chunks_committed_out_of_order() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.chunks_committed_out_of_order)
  return chunks_committed_out_of_order_;
}
inline void TraceStats_BufferStats::set_chunks_committed_out_of_order(::google::protobuf::uint64 value) {
  set_has_chunks_committed_out_of_order();
  chunks_committed_out_of_order_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.chunks_committed_out_of_order)
}

// optional uint64 write_wrap_count = 4;
inline bool TraceStats_BufferStats::has_write_wrap_count() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TraceStats_BufferStats::set_has_write_wrap_count() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TraceStats_BufferStats::clear_has_write_wrap_count() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TraceStats_BufferStats::clear_write_wrap_count() {
  write_wrap_count_ = GOOGLE_ULONGLONG(0);
  clear_has_write_wrap_count();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::write_wrap_count() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.write_wrap_count)
  return write_wrap_count_;
}
inline void TraceStats_BufferStats::set_write_wrap_count(::google::protobuf::uint64 value) {
  set_has_write_wrap_count();
  write_wrap_count_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.write_wrap_count)
}

// optional uint64 patches_succeeded = 5;
inline bool TraceStats_BufferStats::has_patches_succeeded() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TraceStats_BufferStats::set_has_patches_succeeded() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TraceStats_BufferStats::clear_has_patches_succeeded() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TraceStats_BufferStats::clear_patches_succeeded() {
  patches_succeeded_ = GOOGLE_ULONGLONG(0);
  clear_has_patches_succeeded();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::patches_succeeded() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.patches_succeeded)
  return patches_succeeded_;
}
inline void TraceStats_BufferStats::set_patches_succeeded(::google::protobuf::uint64 value) {
  set_has_patches_succeeded();
  patches_succeeded_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.patches_succeeded)
}

// optional uint64 patches_failed = 6;
inline bool TraceStats_BufferStats::has_patches_failed() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TraceStats_BufferStats::set_has_patches_failed() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TraceStats_BufferStats::clear_has_patches_failed() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TraceStats_BufferStats::clear_patches_failed() {
  patches_failed_ = GOOGLE_ULONGLONG(0);
  clear_has_patches_failed();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::patches_failed() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.patches_failed)
  return patches_failed_;
}
inline void TraceStats_BufferStats::set_patches_failed(::google::protobuf::uint64 value) {
  set_has_patches_failed();
  patches_failed_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.patches_failed)
}

// optional uint64 readaheads_succeeded = 7;
inline bool TraceStats_BufferStats::has_readaheads_succeeded() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TraceStats_BufferStats::set_has_readaheads_succeeded() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TraceStats_BufferStats::clear_has_readaheads_succeeded() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TraceStats_BufferStats::clear_readaheads_succeeded() {
  readaheads_succeeded_ = GOOGLE_ULONGLONG(0);
  clear_has_readaheads_succeeded();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::readaheads_succeeded() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.readaheads_succeeded)
  return readaheads_succeeded_;
}
inline void TraceStats_BufferStats::set_readaheads_succeeded(::google::protobuf::uint64 value) {
  set_has_readaheads_succeeded();
  readaheads_succeeded_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.readaheads_succeeded)
}

// optional uint64 readaheads_failed = 8;
inline bool TraceStats_BufferStats::has_readaheads_failed() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TraceStats_BufferStats::set_has_readaheads_failed() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TraceStats_BufferStats::clear_has_readaheads_failed() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TraceStats_BufferStats::clear_readaheads_failed() {
  readaheads_failed_ = GOOGLE_ULONGLONG(0);
  clear_has_readaheads_failed();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::readaheads_failed() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.readaheads_failed)
  return readaheads_failed_;
}
inline void TraceStats_BufferStats::set_readaheads_failed(::google::protobuf::uint64 value) {
  set_has_readaheads_failed();
  readaheads_failed_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.readaheads_failed)
}

// optional uint64 abi_violations = 9;
inline bool TraceStats_BufferStats::has_abi_violations() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TraceStats_BufferStats::set_has_abi_violations() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TraceStats_BufferStats::clear_has_abi_violations() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TraceStats_BufferStats::clear_abi_violations() {
  abi_violations_ = GOOGLE_ULONGLONG(0);
  clear_has_abi_violations();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::abi_violations() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.abi_violations)
  return abi_violations_;
}
inline void TraceStats_BufferStats::set_abi_violations(::google::protobuf::uint64 value) {
  set_has_abi_violations();
  abi_violations_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.abi_violations)
}

// optional uint64 trace_writer_packet_loss = 19;
inline bool TraceStats_BufferStats::has_trace_writer_packet_loss() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void TraceStats_BufferStats::set_has_trace_writer_packet_loss() {
  _has_bits_[0] |= 0x00040000u;
}
inline void TraceStats_BufferStats::clear_has_trace_writer_packet_loss() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void TraceStats_BufferStats::clear_trace_writer_packet_loss() {
  trace_writer_packet_loss_ = GOOGLE_ULONGLONG(0);
  clear_has_trace_writer_packet_loss();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::trace_writer_packet_loss() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.trace_writer_packet_loss)
  return trace_writer_packet_loss_;
}
inline void TraceStats_BufferStats::set_trace_writer_packet_loss(::google::protobuf::uint64 value) {
  set_has_trace_writer_packet_loss();
  trace_writer_packet_loss_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.trace_writer_packet_loss)
}

// -------------------------------------------------------------------

// TraceStats

// repeated .perfetto.protos.TraceStats.BufferStats buffer_stats = 1;
inline int TraceStats::buffer_stats_size() const {
  return buffer_stats_.size();
}
inline void TraceStats::clear_buffer_stats() {
  buffer_stats_.Clear();
}
inline const ::perfetto::protos::TraceStats_BufferStats& TraceStats::buffer_stats(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.buffer_stats)
  return buffer_stats_.Get(index);
}
inline ::perfetto::protos::TraceStats_BufferStats* TraceStats::mutable_buffer_stats(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceStats.buffer_stats)
  return buffer_stats_.Mutable(index);
}
inline ::perfetto::protos::TraceStats_BufferStats* TraceStats::add_buffer_stats() {
  // @@protoc_insertion_point(field_add:perfetto.protos.TraceStats.buffer_stats)
  return buffer_stats_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceStats_BufferStats >*
TraceStats::mutable_buffer_stats() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.TraceStats.buffer_stats)
  return &buffer_stats_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceStats_BufferStats >&
TraceStats::buffer_stats() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.TraceStats.buffer_stats)
  return buffer_stats_;
}

// optional uint32 producers_connected = 2;
inline bool TraceStats::has_producers_connected() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TraceStats::set_has_producers_connected() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TraceStats::clear_has_producers_connected() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TraceStats::clear_producers_connected() {
  producers_connected_ = 0u;
  clear_has_producers_connected();
}
inline ::google::protobuf::uint32 TraceStats::producers_connected() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.producers_connected)
  return producers_connected_;
}
inline void TraceStats::set_producers_connected(::google::protobuf::uint32 value) {
  set_has_producers_connected();
  producers_connected_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.producers_connected)
}

// optional uint64 producers_seen = 3;
inline bool TraceStats::has_producers_seen() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TraceStats::set_has_producers_seen() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TraceStats::clear_has_producers_seen() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TraceStats::clear_producers_seen() {
  producers_seen_ = GOOGLE_ULONGLONG(0);
  clear_has_producers_seen();
}
inline ::google::protobuf::uint64 TraceStats::producers_seen() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.producers_seen)
  return producers_seen_;
}
inline void TraceStats::set_producers_seen(::google::protobuf::uint64 value) {
  set_has_producers_seen();
  producers_seen_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.producers_seen)
}

// optional uint32 data_sources_registered = 4;
inline bool TraceStats::has_data_sources_registered() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TraceStats::set_has_data_sources_registered() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TraceStats::clear_has_data_sources_registered() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TraceStats::clear_data_sources_registered() {
  data_sources_registered_ = 0u;
  clear_has_data_sources_registered();
}
inline ::google::protobuf::uint32 TraceStats::data_sources_registered() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.data_sources_registered)
  return data_sources_registered_;
}
inline void TraceStats::set_data_sources_registered(::google::protobuf::uint32 value) {
  set_has_data_sources_registered();
  data_sources_registered_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.data_sources_registered)
}

// optional uint64 data_sources_seen = 5;
inline bool TraceStats::has_data_sources_seen() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TraceStats::set_has_data_sources_seen() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TraceStats::clear_has_data_sources_seen() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TraceStats::clear_data_sources_seen() {
  data_sources_seen_ = GOOGLE_ULONGLONG(0);
  clear_has_data_sources_seen();
}
inline ::google::protobuf::uint64 TraceStats::data_sources_seen() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.data_sources_seen)
  return data_sources_seen_;
}
inline void TraceStats::set_data_sources_seen(::google::protobuf::uint64 value) {
  set_has_data_sources_seen();
  data_sources_seen_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.data_sources_seen)
}

// optional uint32 tracing_sessions = 6;
inline bool TraceStats::has_tracing_sessions() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TraceStats::set_has_tracing_sessions() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TraceStats::clear_has_tracing_sessions() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TraceStats::clear_tracing_sessions() {
  tracing_sessions_ = 0u;
  clear_has_tracing_sessions();
}
inline ::google::protobuf::uint32 TraceStats::tracing_sessions() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.tracing_sessions)
  return tracing_sessions_;
}
inline void TraceStats::set_tracing_sessions(::google::protobuf::uint32 value) {
  set_has_tracing_sessions();
  tracing_sessions_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.tracing_sessions)
}

// optional uint32 total_buffers = 7;
inline bool TraceStats::has_total_buffers() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TraceStats::set_has_total_buffers() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TraceStats::clear_has_total_buffers() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TraceStats::clear_total_buffers() {
  total_buffers_ = 0u;
  clear_has_total_buffers();
}
inline ::google::protobuf::uint32 TraceStats::total_buffers() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.total_buffers)
  return total_buffers_;
}
inline void TraceStats::set_total_buffers(::google::protobuf::uint32 value) {
  set_has_total_buffers();
  total_buffers_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.total_buffers)
}

// optional uint64 chunks_discarded = 8;
inline bool TraceStats::has_chunks_discarded() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TraceStats::set_has_chunks_discarded() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TraceStats::clear_has_chunks_discarded() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TraceStats::clear_chunks_discarded() {
  chunks_discarded_ = GOOGLE_ULONGLONG(0);
  clear_has_chunks_discarded();
}
inline ::google::protobuf::uint64 TraceStats::chunks_discarded() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.chunks_discarded)
  return chunks_discarded_;
}
inline void TraceStats::set_chunks_discarded(::google::protobuf::uint64 value) {
  set_has_chunks_discarded();
  chunks_discarded_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.chunks_discarded)
}

// optional uint64 patches_discarded = 9;
inline bool TraceStats::has_patches_discarded() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TraceStats::set_has_patches_discarded() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TraceStats::clear_has_patches_discarded() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TraceStats::clear_patches_discarded() {
  patches_discarded_ = GOOGLE_ULONGLONG(0);
  clear_has_patches_discarded();
}
inline ::google::protobuf::uint64 TraceStats::patches_discarded() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.patches_discarded)
  return patches_discarded_;
}
inline void TraceStats::set_patches_discarded(::google::protobuf::uint64 value) {
  set_has_patches_discarded();
  patches_discarded_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.patches_discarded)
}

// optional uint64 invalid_packets = 10;
inline bool TraceStats::has_invalid_packets() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TraceStats::set_has_invalid_packets() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TraceStats::clear_has_invalid_packets() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TraceStats::clear_invalid_packets() {
  invalid_packets_ = GOOGLE_ULONGLONG(0);
  clear_has_invalid_packets();
}
inline ::google::protobuf::uint64 TraceStats::invalid_packets() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.invalid_packets)
  return invalid_packets_;
}
inline void TraceStats::set_invalid_packets(::google::protobuf::uint64 value) {
  set_has_invalid_packets();
  invalid_packets_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.invalid_packets)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2fcommon_2ftrace_5fstats_2eproto__INCLUDED
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/config/trace_config.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/config/trace_config.proto

#ifndef PROTOBUF_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
// gen_amalgamated expanded: #include "protos/perfetto/config/data_source_config.pb.h"
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();

class TraceConfig;
class TraceConfig_BufferConfig;
class TraceConfig_BuiltinDataSource;
class TraceConfig_DataSource;
class TraceConfig_GuardrailOverrides;
class TraceConfig_IncidentReportConfig;
class TraceConfig_IncrementalStateConfig;
class TraceConfig_ProducerConfig;
class TraceConfig_StatsdMetadata;
class TraceConfig_TriggerConfig;
class TraceConfig_TriggerConfig_Trigger;

enum TraceConfig_BufferConfig_FillPolicy {
  TraceConfig_BufferConfig_FillPolicy_UNSPECIFIED = 0,
  TraceConfig_BufferConfig_FillPolicy_RING_BUFFER = 1,
  TraceConfig_BufferConfig_FillPolicy_DISCARD = 2
};
bool TraceConfig_BufferConfig_FillPolicy_IsValid(int value);
const TraceConfig_BufferConfig_FillPolicy TraceConfig_BufferConfig_FillPolicy_FillPolicy_MIN = TraceConfig_BufferConfig_FillPolicy_UNSPECIFIED;
const TraceConfig_BufferConfig_FillPolicy TraceConfig_BufferConfig_FillPolicy_FillPolicy_MAX = TraceConfig_BufferConfig_FillPolicy_DISCARD;
const int TraceConfig_BufferConfig_FillPolicy_FillPolicy_ARRAYSIZE = TraceConfig_BufferConfig_FillPolicy_FillPolicy_MAX + 1;

enum TraceConfig_TriggerConfig_TriggerMode {
  TraceConfig_TriggerConfig_TriggerMode_UNSPECIFIED = 0,
  TraceConfig_TriggerConfig_TriggerMode_START_TRACING = 1,
  TraceConfig_TriggerConfig_TriggerMode_STOP_TRACING = 2
};
bool TraceConfig_TriggerConfig_TriggerMode_IsValid(int value);
const TraceConfig_TriggerConfig_TriggerMode TraceConfig_TriggerConfig_TriggerMode_TriggerMode_MIN = TraceConfig_TriggerConfig_TriggerMode_UNSPECIFIED;
const TraceConfig_TriggerConfig_TriggerMode TraceConfig_TriggerConfig_TriggerMode_TriggerMode_MAX = TraceConfig_TriggerConfig_TriggerMode_STOP_TRACING;
const int TraceConfig_TriggerConfig_TriggerMode_TriggerMode_ARRAYSIZE = TraceConfig_TriggerConfig_TriggerMode_TriggerMode_MAX + 1;

enum TraceConfig_LockdownModeOperation {
  TraceConfig_LockdownModeOperation_LOCKDOWN_UNCHANGED = 0,
  TraceConfig_LockdownModeOperation_LOCKDOWN_CLEAR = 1,
  TraceConfig_LockdownModeOperation_LOCKDOWN_SET = 2
};
bool TraceConfig_LockdownModeOperation_IsValid(int value);
const TraceConfig_LockdownModeOperation TraceConfig_LockdownModeOperation_LockdownModeOperation_MIN = TraceConfig_LockdownModeOperation_LOCKDOWN_UNCHANGED;
const TraceConfig_LockdownModeOperation TraceConfig_LockdownModeOperation_LockdownModeOperation_MAX = TraceConfig_LockdownModeOperation_LOCKDOWN_SET;
const int TraceConfig_LockdownModeOperation_LockdownModeOperation_ARRAYSIZE = TraceConfig_LockdownModeOperation_LockdownModeOperation_MAX + 1;

enum TraceConfig_CompressionType {
  TraceConfig_CompressionType_COMPRESSION_TYPE_UNSPECIFIED = 0,
  TraceConfig_CompressionType_COMPRESSION_TYPE_DEFLATE = 1
};
bool TraceConfig_CompressionType_IsValid(int value);
const TraceConfig_CompressionType TraceConfig_CompressionType_CompressionType_MIN = TraceConfig_CompressionType_COMPRESSION_TYPE_UNSPECIFIED;
const TraceConfig_CompressionType TraceConfig_CompressionType_CompressionType_MAX = TraceConfig_CompressionType_COMPRESSION_TYPE_DEFLATE;
const int TraceConfig_CompressionType_CompressionType_ARRAYSIZE = TraceConfig_CompressionType_CompressionType_MAX + 1;

// ===================================================================

class TraceConfig_BufferConfig : public ::google::protobuf::MessageLite {
 public:
  TraceConfig_BufferConfig();
  virtual ~TraceConfig_BufferConfig();

  TraceConfig_BufferConfig(const TraceConfig_BufferConfig& from);

  inline TraceConfig_BufferConfig& operator=(const TraceConfig_BufferConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TraceConfig_BufferConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TraceConfig_BufferConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TraceConfig_BufferConfig* other);

  // implements Message ----------------------------------------------

  inline TraceConfig_BufferConfig* New() const { return New(NULL); }

  TraceConfig_BufferConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TraceConfig_BufferConfig& from);
  void MergeFrom(const TraceConfig_BufferConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TraceConfig_BufferConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef TraceConfig_BufferConfig_FillPolicy FillPolicy;
  static const FillPolicy UNSPECIFIED =
    TraceConfig_BufferConfig_FillPolicy_UNSPECIFIED;
  static const FillPolicy RING_BUFFER =
    TraceConfig_BufferConfig_FillPolicy_RING_BUFFER;
  static const FillPolicy DISCARD =
    TraceConfig_BufferConfig_FillPolicy_DISCARD;
  static inline bool FillPolicy_IsValid(int value) {
    return TraceConfig_BufferConfig_FillPolicy_IsValid(value);
  }
  static const FillPolicy FillPolicy_MIN =
    TraceConfig_BufferConfig_FillPolicy_FillPolicy_MIN;
  static const FillPolicy FillPolicy_MAX =
    TraceConfig_BufferConfig_FillPolicy_FillPolicy_MAX;
  static const int FillPolicy_ARRAYSIZE =
    TraceConfig_BufferConfig_FillPolicy_FillPolicy_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional uint32 size_kb = 1;
  bool has_size_kb() const;
  void clear_size_kb();
  static const int kSizeKbFieldNumber = 1;
  ::google::protobuf::uint32 size_kb() const;
  void set_size_kb(::google::protobuf::uint32 value);

  // optional .perfetto.protos.TraceConfig.BufferConfig.FillPolicy fill_policy = 4;
  bool has_fill_policy() const;
  void clear_fill_policy();
  static const int kFillPolicyFieldNumber = 4;
  ::perfetto::protos::TraceConfig_BufferConfig_FillPolicy fill_policy() const;
  void set_fill_policy(::perfetto::protos::TraceConfig_BufferConfig_FillPolicy value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.TraceConfig.BufferConfig)
 private:
  inline void set_has_size_kb();
  inline void clear_has_size_kb();
  inline void set_has_fill_policy();
  inline void clear_has_fill_policy();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 size_kb_;
  int fill_policy_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static TraceConfig_BufferConfig* default_instance_;
};
// -------------------------------------------------------------------

class TraceConfig_DataSource : public ::google::protobuf::MessageLite {
 public:
  TraceConfig_DataSource();
  virtual ~TraceConfig_DataSource();

  TraceConfig_DataSource(const TraceConfig_DataSource& from);

  inline TraceConfig_DataSource& operator=(const TraceConfig_DataSource& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TraceConfig_DataSource& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TraceConfig_DataSource* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TraceConfig_DataSource* other);

  // implements Message ----------------------------------------------

  inline TraceConfig_DataSource* New() const { return New(NULL); }

  TraceConfig_DataSource* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TraceConfig_DataSource& from);
  void MergeFrom(const TraceConfig_DataSource& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TraceConfig_DataSource* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .perfetto.protos.DataSourceConfig config = 1;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 1;
  const ::perfetto::protos::DataSourceConfig& config() const;
  ::perfetto::protos::DataSourceConfig* mutable_config();
  ::perfetto::protos::DataSourceConfig* release_config();
  void set_allocated_config(::perfetto::protos::DataSourceConfig* config);

  // repeated string producer_name_filter = 2;
  int producer_name_filter_size() const;
  void clear_producer_name_filter();
  static const int kProducerNameFilterFieldNumber = 2;
  const ::std::string& producer_name_filter(int index) const;
  ::std::string* mutable_producer_name_filter(int index);
  void set_producer_name_filter(int index, const ::std::string& value);
  void set_producer_name_filter(int index, const char* value);
  void set_producer_name_filter(int index, const char* value, size_t size);
  ::std::string* add_producer_name_filter();
  void add_producer_name_filter(const ::std::string& value);
  void add_producer_name_filter(const char* value);
  void add_producer_name_filter(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& producer_name_filter() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_producer_name_filter();

  // @@protoc_insertion_point(class_scope:perfetto.protos.TraceConfig.DataSource)
 private:
  inline void set_has_config();
  inline void clear_has_config();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::perfetto::protos::DataSourceConfig* config_;
  ::google::protobuf::RepeatedPtrField< ::std::string> producer_name_filter_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static TraceConfig_DataSource* default_instance_;
};
// -------------------------------------------------------------------

class TraceConfig_BuiltinDataSource : public ::google::protobuf::MessageLite {
 public:
  TraceConfig_BuiltinDataSource();
  virtual ~TraceConfig_BuiltinDataSource();

  TraceConfig_BuiltinDataSource(const TraceConfig_BuiltinDataSource& from);

  inline TraceConfig_BuiltinDataSource& operator=(const TraceConfig_BuiltinDataSource& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TraceConfig_BuiltinDataSource& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TraceConfig_BuiltinDataSource* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TraceConfig_BuiltinDataSource* other);

  // implements Message ----------------------------------------------

  inline TraceConfig_BuiltinDataSource* New() const { return New(NULL); }

  TraceConfig_BuiltinDataSource* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TraceConfig_BuiltinDataSource& from);
  void MergeFrom(const TraceConfig_BuiltinDataSource& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TraceConfig_BuiltinDataSource* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool disable_clock_snapshotting = 1;
  bool has_disable_clock_snapshotting() const;
  void clear_disable_clock_snapshotting();
  static const int kDisableClockSnapshottingFieldNumber = 1;
  bool disable_clock_snapshotting() const;
  void set_disable_clock_snapshotting(bool value);

  // optional bool disable_trace_config = 2;
  bool has_disable_trace_config() const;
  void clear_disable_trace_config();
  static const int kDisableTraceConfigFieldNumber = 2;
  bool disable_trace_config() const;
  void set_disable_trace_config(bool value);

  // optional bool disable_system_info = 3;
  bool has_disable_system_info() const;
  void clear_disable_system_info();
  static const int kDisableSystemInfoFieldNumber = 3;
  bool disable_system_info() const;
  void set_disable_system_info(bool value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.TraceConfig.BuiltinDataSource)
 private:
  inline void set_has_disable_clock_snapshotting();
  inline void clear_has_disable_clock_snapshotting();
  inline void set_has_disable_trace_config();
  inline void clear_has_disable_trace_config();
  inline void set_has_disable_system_info();
  inline void clear_has_disable_system_info();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool disable_clock_snapshotting_;
  bool disable_trace_config_;
  bool disable_system_info_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static TraceConfig_BuiltinDataSource* default_instance_;
};
// -------------------------------------------------------------------

class TraceConfig_ProducerConfig : public ::google::protobuf::MessageLite {
 public:
  TraceConfig_ProducerConfig();
  virtual ~TraceConfig_ProducerConfig();

  TraceConfig_ProducerConfig(const TraceConfig_ProducerConfig& from);

  inline TraceConfig_ProducerConfig& operator=(const TraceConfig_ProducerConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TraceConfig_ProducerConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TraceConfig_ProducerConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TraceConfig_ProducerConfig* other);

  // implements Message ----------------------------------------------

  inline TraceConfig_ProducerConfig* New() const { return New(NULL); }

  TraceConfig_ProducerConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TraceConfig_ProducerConfig& from);
  void MergeFrom(const TraceConfig_ProducerConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TraceConfig_ProducerConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string producer_name = 1;
  bool has_producer_name() const;
  void clear_producer_name();
  static const int kProducerNameFieldNumber = 1;
  const ::std::string& producer_name() const;
  void set_producer_name(const ::std::string& value);
  void set_producer_name(const char* value);
  void set_producer_name(const char* value, size_t size);
  ::std::string* mutable_producer_name();
  ::std::string* release_producer_name();
  void set_allocated_producer_name(::std::string* producer_name);

  // optional uint32 shm_size_kb = 2;
  bool has_shm_size_kb() const;
  void clear_shm_size_kb();
  static const int kShmSizeKbFieldNumber = 2;
  ::google::protobuf::uint32 shm_size_kb() const;
  void set_shm_size_kb(::google::protobuf::uint32 value);

  // optional uint32 page_size_kb = 3;
  bool has_page_size_kb() const;
  void clear_page_size_kb();
  static const int kPageSizeKbFieldNumber = 3;
  ::google::protobuf::uint32 page_size_kb() const;
  void set_page_size_kb(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.TraceConfig.ProducerConfig)
 private:
  inline void set_has_producer_name();
  inline void clear_has_producer_name();
  inline void set_has_shm_size_kb();
  inline void clear_has_shm_size_kb();
  inline void set_has_page_size_kb();
  inline void clear_has_page_size_kb();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr producer_name_;
  ::google::protobuf::uint32 shm_size_kb_;
  ::google::protobuf::uint32 page_size_kb_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static TraceConfig_ProducerConfig* default_instance_;
};
// -------------------------------------------------------------------

class TraceConfig_StatsdMetadata : public ::google::protobuf::MessageLite {
 public:
  TraceConfig_StatsdMetadata();
  virtual ~TraceConfig_StatsdMetadata();

  TraceConfig_StatsdMetadata(const TraceConfig_StatsdMetadata& from);

  inline TraceConfig_StatsdMetadata& operator=(const TraceConfig_StatsdMetadata& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TraceConfig_StatsdMetadata& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TraceConfig_StatsdMetadata* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TraceConfig_StatsdMetadata* other);

  // implements Message ----------------------------------------------

  inline TraceConfig_StatsdMetadata* New() const { return New(NULL); }

  TraceConfig_StatsdMetadata* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TraceConfig_StatsdMetadata& from);
  void MergeFrom(const TraceConfig_StatsdMetadata& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TraceConfig_StatsdMetadata* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 triggering_alert_id = 1;
  bool has_triggering_alert_id() const;
  void clear_triggering_alert_id();
  static const int kTriggeringAlertIdFieldNumber = 1;
  ::google::protobuf::int64 triggering_alert_id() const;
  void set_triggering_alert_id(::google::protobuf::int64 value);

  // optional int32 triggering_config_uid = 2;
  bool has_triggering_config_uid() const;
  void clear_triggering_config_uid();
  static const int kTriggeringConfigUidFieldNumber = 2;
  ::google::protobuf::int32 triggering_config_uid() const;
  void set_triggering_config_uid(::google::protobuf::int32 value);

  // optional int64 triggering_config_id = 3;
  bool has_triggering_config_id() const;
  void clear_triggering_config_id();
  static const int kTriggeringConfigIdFieldNumber = 3;
  ::google::protobuf::int64 triggering_config_id() const;
  void set_triggering_config_id(::google::protobuf::int64 value);

  // optional int64 triggering_subscription_id = 4;
  bool has_triggering_subscription_id() const;
  void clear_triggering_subscription_id();
  static const int kTriggeringSubscriptionIdFieldNumber = 4;
  ::google::protobuf::int64 triggering_subscription_id() const;
  void set_triggering_subscription_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.TraceConfig.StatsdMetadata)
 private:
  inline void set_has_triggering_alert_id();
  inline void clear_has_triggering_alert_id();
  inline void set_has_triggering_config_uid();
  inline void clear_has_triggering_config_uid();
  inline void set_has_triggering_config_id();
  inline void clear_has_triggering_config_id();
  inline void set_has_triggering_subscription_id();
  inline void clear_has_triggering_subscription_id();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 triggering_alert_id_;
  ::google::protobuf::int64 triggering_config_id_;
  ::google::protobuf::int64 triggering_subscription_id_;
  ::google::protobuf::int32 triggering_config_uid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static TraceConfig_StatsdMetadata* default_instance_;
};
// -------------------------------------------------------------------

class TraceConfig_GuardrailOverrides : public ::google::protobuf::MessageLite {
 public:
  TraceConfig_GuardrailOverrides();
  virtual ~TraceConfig_GuardrailOverrides();

  TraceConfig_GuardrailOverrides(const TraceConfig_GuardrailOverrides& from);

  inline TraceConfig_GuardrailOverrides& operator=(const TraceConfig_GuardrailOverrides& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TraceConfig_GuardrailOverrides& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TraceConfig_GuardrailOverrides* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TraceConfig_GuardrailOverrides* other);

  // implements Message ----------------------------------------------

  inline TraceConfig_GuardrailOverrides* New() const { return New(NULL); }

  TraceConfig_GuardrailOverrides* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TraceConfig_GuardrailOverrides& from);
  void MergeFrom(const TraceConfig_GuardrailOverrides& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TraceConfig_GuardrailOverrides* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 max_upload_per_day_bytes = 1;
  bool has_max_upload_per_day_bytes() const;
  void clear_max_upload_per_day_bytes();
  static const int kMaxUploadPerDayBytesFieldNumber = 1;
  ::google::protobuf::uint64 max_upload_per_day_bytes() const;
  void set_max_upload_per_day_bytes(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.TraceConfig.GuardrailOverrides)
 private:
  inline void set_has_max_upload_per_day_bytes();
  inline void clear_has_max_upload_per_day_bytes();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 max_upload_per_day_bytes_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static TraceConfig_GuardrailOverrides* default_instance_;
};
// -------------------------------------------------------------------

class TraceConfig_TriggerConfig_Trigger : public ::google::protobuf::MessageLite {
 public:
  TraceConfig_TriggerConfig_Trigger();
  virtual ~TraceConfig_TriggerConfig_Trigger();

  TraceConfig_TriggerConfig_Trigger(const TraceConfig_TriggerConfig_Trigger& from);

  inline TraceConfig_TriggerConfig_Trigger& operator=(const TraceConfig_TriggerConfig_Trigger& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TraceConfig_TriggerConfig_Trigger& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TraceConfig_TriggerConfig_Trigger* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TraceConfig_TriggerConfig_Trigger* other);

  // implements Message ----------------------------------------------

  inline TraceConfig_TriggerConfig_Trigger* New() const { return New(NULL); }

  TraceConfig_TriggerConfig_Trigger* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TraceConfig_TriggerConfig_Trigger& from);
  void MergeFrom(const TraceConfig_TriggerConfig_Trigger& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TraceConfig_TriggerConfig_Trigger* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string producer_name_regex = 2;
  bool has_producer_name_regex() const;
  void clear_producer_name_regex();
  static const int kProducerNameRegexFieldNumber = 2;
  const ::std::string& producer_name_regex() const;
  void set_producer_name_regex(const ::std::string& value);
  void set_producer_name_regex(const char* value);
  void set_producer_name_regex(const char* value, size_t size);
  ::std::string* mutable_producer_name_regex();
  ::std::string* release_producer_name_regex();
  void set_allocated_producer_name_regex(::std::string* producer_name_regex);

  // optional uint32 stop_delay_ms = 3;
  bool has_stop_delay_ms() const;
  void clear_stop_delay_ms();
  static const int kStopDelayMsFieldNumber = 3;
  ::google::protobuf::uint32 stop_delay_ms() const;
  void set_stop_delay_ms(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.TraceConfig.TriggerConfig.Trigger)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_producer_name_regex();
  inline void clear_has_producer_name_regex();
  inline void set_has_stop_delay_ms();
  inline void clear_has_stop_delay_ms();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr producer_name_regex_;
  ::google::protobuf::uint32 stop_delay_ms_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static TraceConfig_TriggerConfig_Trigger* default_instance_;
};
// -------------------------------------------------------------------

class TraceConfig_TriggerConfig : public ::google::protobuf::MessageLite {
 public:
  TraceConfig_TriggerConfig();
  virtual ~TraceConfig_TriggerConfig();

  TraceConfig_TriggerConfig(const TraceConfig_TriggerConfig& from);

  inline TraceConfig_TriggerConfig& operator=(const TraceConfig_TriggerConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TraceConfig_TriggerConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TraceConfig_TriggerConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TraceConfig_TriggerConfig* other);

  // implements Message ----------------------------------------------

  inline TraceConfig_TriggerConfig* New() const { return New(NULL); }

  TraceConfig_TriggerConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TraceConfig_TriggerConfig& from);
  void MergeFrom(const TraceConfig_TriggerConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TraceConfig_TriggerConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef TraceConfig_TriggerConfig_Trigger Trigger;

  typedef TraceConfig_TriggerConfig_TriggerMode TriggerMode;
  static const TriggerMode UNSPECIFIED =
    TraceConfig_TriggerConfig_TriggerMode_UNSPECIFIED;
  static const TriggerMode START_TRACING =
    TraceConfig_TriggerConfig_TriggerMode_START_TRACING;
  static const TriggerMode STOP_TRACING =
    TraceConfig_TriggerConfig_TriggerMode_STOP_TRACING;
  static inline bool TriggerMode_IsValid(int value) {
    return TraceConfig_TriggerConfig_TriggerMode_IsValid(value);
  }
  static const TriggerMode TriggerMode_MIN =
    TraceConfig_TriggerConfig_TriggerMode_TriggerMode_MIN;
  static const TriggerMode TriggerMode_MAX =
    TraceConfig_TriggerConfig_TriggerMode_TriggerMode_MAX;
  static const int TriggerMode_ARRAYSIZE =
    TraceConfig_TriggerConfig_TriggerMode_TriggerMode_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .perfetto.protos.TraceConfig.TriggerConfig.TriggerMode trigger_mode = 1;
  bool has_trigger_mode() const;
  void clear_trigger_mode();
  static const int kTriggerModeFieldNumber = 1;
  ::perfetto::protos::TraceConfig_TriggerConfig_TriggerMode trigger_mode() const;
  void set_trigger_mode(::perfetto::protos::TraceConfig_TriggerConfig_TriggerMode value);

  // repeated .perfetto.protos.TraceConfig.TriggerConfig.Trigger triggers = 2;
  int triggers_size() const;
  void clear_triggers();
  static const int kTriggersFieldNumber = 2;
  const ::perfetto::protos::TraceConfig_TriggerConfig_Trigger& triggers(int index) const;
  ::perfetto::protos::TraceConfig_TriggerConfig_Trigger* mutable_triggers(int index);
  ::perfetto::protos::TraceConfig_TriggerConfig_Trigger* add_triggers();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_TriggerConfig_Trigger >*
      mutable_triggers();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_TriggerConfig_Trigger >&
      triggers() const;

  // optional uint32 trigger_timeout_ms = 3;
  bool has_trigger_timeout_ms() const;
  void clear_trigger_timeout_ms();
  static const int kTriggerTimeoutMsFieldNumber = 3;
  ::google::protobuf::uint32 trigger_timeout_ms() const;
  void set_trigger_timeout_ms(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.TraceConfig.TriggerConfig)
 private:
  inline void set_has_trigger_mode();
  inline void clear_has_trigger_mode();
  inline void set_has_trigger_timeout_ms();
  inline void clear_has_trigger_timeout_ms();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_TriggerConfig_Trigger > triggers_;
  int trigger_mode_;
  ::google::protobuf::uint32 trigger_timeout_ms_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static TraceConfig_TriggerConfig* default_instance_;
};
// -------------------------------------------------------------------

class TraceConfig_IncrementalStateConfig : public ::google::protobuf::MessageLite {
 public:
  TraceConfig_IncrementalStateConfig();
  virtual ~TraceConfig_IncrementalStateConfig();

  TraceConfig_IncrementalStateConfig(const TraceConfig_IncrementalStateConfig& from);

  inline TraceConfig_IncrementalStateConfig& operator=(const TraceConfig_IncrementalStateConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TraceConfig_IncrementalStateConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TraceConfig_IncrementalStateConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TraceConfig_IncrementalStateConfig* other);

  // implements Message ----------------------------------------------

  inline TraceConfig_IncrementalStateConfig* New() const { return New(NULL); }

  TraceConfig_IncrementalStateConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TraceConfig_IncrementalStateConfig& from);
  void MergeFrom(const TraceConfig_IncrementalStateConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TraceConfig_IncrementalStateConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 clear_period_ms = 1;
  bool has_clear_period_ms() const;
  void clear_clear_period_ms();
  static const int kClearPeriodMsFieldNumber = 1;
  ::google::protobuf::uint32 clear_period_ms() const;
  void set_clear_period_ms(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.TraceConfig.IncrementalStateConfig)
 private:
  inline void set_has_clear_period_ms();
  inline void clear_has_clear_period_ms();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 clear_period_ms_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static TraceConfig_IncrementalStateConfig* default_instance_;
};
// -------------------------------------------------------------------

class TraceConfig_IncidentReportConfig : public ::google::protobuf::MessageLite {
 public:
  TraceConfig_IncidentReportConfig();
  virtual ~TraceConfig_IncidentReportConfig();

  TraceConfig_IncidentReportConfig(const TraceConfig_IncidentReportConfig& from);

  inline TraceConfig_IncidentReportConfig& operator=(const TraceConfig_IncidentReportConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TraceConfig_IncidentReportConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TraceConfig_IncidentReportConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TraceConfig_IncidentReportConfig* other);

  // implements Message ----------------------------------------------

  inline TraceConfig_IncidentReportConfig* New() const { return New(NULL); }

  TraceConfig_IncidentReportConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TraceConfig_IncidentReportConfig& from);
  void MergeFrom(const TraceConfig_IncidentReportConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TraceConfig_IncidentReportConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string destination_package = 1;
  bool has_destination_package() const;
  void clear_destination_package();
  static const int kDestinationPackageFieldNumber = 1;
  const ::std::string& destination_package() const;
  void set_destination_package(const ::std::string& value);
  void set_destination_package(const char* value);
  void set_destination_package(const char* value, size_t size);
  ::std::string* mutable_destination_package();
  ::std::string* release_destination_package();
  void set_allocated_destination_package(::std::string* destination_package);

  // optional string destination_class = 2;
  bool has_destination_class() const;
  void clear_destination_class();
  static const int kDestinationClassFieldNumber = 2;
  const ::std::string& destination_class() const;
  void set_destination_class(const ::std::string& value);
  void set_destination_class(const char* value);
  void set_destination_class(const char* value, size_t size);
  ::std::string* mutable_destination_class();
  ::std::string* release_destination_class();
  void set_allocated_destination_class(::std::string* destination_class);

  // optional int32 privacy_level = 3;
  bool has_privacy_level() const;
  void clear_privacy_level();
  static const int kPrivacyLevelFieldNumber = 3;
  ::google::protobuf::int32 privacy_level() const;
  void set_privacy_level(::google::protobuf::int32 value);

  // optional bool skip_dropbox = 4;
  bool has_skip_dropbox() const;
  void clear_skip_dropbox();
  static const int kSkipDropboxFieldNumber = 4;
  bool skip_dropbox() const;
  void set_skip_dropbox(bool value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.TraceConfig.IncidentReportConfig)
 private:
  inline void set_has_destination_package();
  inline void clear_has_destination_package();
  inline void set_has_destination_class();
  inline void clear_has_destination_class();
  inline void set_has_privacy_level();
  inline void clear_has_privacy_level();
  inline void set_has_skip_dropbox();
  inline void clear_has_skip_dropbox();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr destination_package_;
  ::google::protobuf::internal::ArenaStringPtr destination_class_;
  ::google::protobuf::int32 privacy_level_;
  bool skip_dropbox_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static TraceConfig_IncidentReportConfig* default_instance_;
};
// -------------------------------------------------------------------

class TraceConfig : public ::google::protobuf::MessageLite {
 public:
  TraceConfig();
  virtual ~TraceConfig();

  TraceConfig(const TraceConfig& from);

  inline TraceConfig& operator=(const TraceConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TraceConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TraceConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TraceConfig* other);

  // implements Message ----------------------------------------------

  inline TraceConfig* New() const { return New(NULL); }

  TraceConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TraceConfig& from);
  void MergeFrom(const TraceConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TraceConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef TraceConfig_BufferConfig BufferConfig;
  typedef TraceConfig_DataSource DataSource;
  typedef TraceConfig_BuiltinDataSource BuiltinDataSource;
  typedef TraceConfig_ProducerConfig ProducerConfig;
  typedef TraceConfig_StatsdMetadata StatsdMetadata;
  typedef TraceConfig_GuardrailOverrides GuardrailOverrides;
  typedef TraceConfig_TriggerConfig TriggerConfig;
  typedef TraceConfig_IncrementalStateConfig IncrementalStateConfig;
  typedef TraceConfig_IncidentReportConfig IncidentReportConfig;

  typedef TraceConfig_LockdownModeOperation LockdownModeOperation;
  static const LockdownModeOperation LOCKDOWN_UNCHANGED =
    TraceConfig_LockdownModeOperation_LOCKDOWN_UNCHANGED;
  static const LockdownModeOperation LOCKDOWN_CLEAR =
    TraceConfig_LockdownModeOperation_LOCKDOWN_CLEAR;
  static const LockdownModeOperation LOCKDOWN_SET =
    TraceConfig_LockdownModeOperation_LOCKDOWN_SET;
  static inline bool LockdownModeOperation_IsValid(int value) {
    return TraceConfig_LockdownModeOperation_IsValid(value);
  }
  static const LockdownModeOperation LockdownModeOperation_MIN =
    TraceConfig_LockdownModeOperation_LockdownModeOperation_MIN;
  static const LockdownModeOperation LockdownModeOperation_MAX =
    TraceConfig_LockdownModeOperation_LockdownModeOperation_MAX;
  static const int LockdownModeOperation_ARRAYSIZE =
    TraceConfig_LockdownModeOperation_LockdownModeOperation_ARRAYSIZE;

  typedef TraceConfig_CompressionType CompressionType;
  static const CompressionType COMPRESSION_TYPE_UNSPECIFIED =
    TraceConfig_CompressionType_COMPRESSION_TYPE_UNSPECIFIED;
  static const CompressionType COMPRESSION_TYPE_DEFLATE =
    TraceConfig_CompressionType_COMPRESSION_TYPE_DEFLATE;
  static inline bool CompressionType_IsValid(int value) {
    return TraceConfig_CompressionType_IsValid(value);
  }
  static const CompressionType CompressionType_MIN =
    TraceConfig_CompressionType_CompressionType_MIN;
  static const CompressionType CompressionType_MAX =
    TraceConfig_CompressionType_CompressionType_MAX;
  static const int CompressionType_ARRAYSIZE =
    TraceConfig_CompressionType_CompressionType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .perfetto.protos.TraceConfig.BufferConfig buffers = 1;
  int buffers_size() const;
  void clear_buffers();
  static const int kBuffersFieldNumber = 1;
  const ::perfetto::protos::TraceConfig_BufferConfig& buffers(int index) const;
  ::perfetto::protos::TraceConfig_BufferConfig* mutable_buffers(int index);
  ::perfetto::protos::TraceConfig_BufferConfig* add_buffers();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_BufferConfig >*
      mutable_buffers();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_BufferConfig >&
      buffers() const;

  // repeated .perfetto.protos.TraceConfig.DataSource data_sources = 2;
  int data_sources_size() const;
  void clear_data_sources();
  static const int kDataSourcesFieldNumber = 2;
  const ::perfetto::protos::TraceConfig_DataSource& data_sources(int index) const;
  ::perfetto::protos::TraceConfig_DataSource* mutable_data_sources(int index);
  ::perfetto::protos::TraceConfig_DataSource* add_data_sources();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_DataSource >*
      mutable_data_sources();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_DataSource >&
      data_sources() const;

  // optional .perfetto.protos.TraceConfig.BuiltinDataSource builtin_data_sources = 20;
  bool has_builtin_data_sources() const;
  void clear_builtin_data_sources();
  static const int kBuiltinDataSourcesFieldNumber = 20;
  const ::perfetto::protos::TraceConfig_BuiltinDataSource& builtin_data_sources() const;
  ::perfetto::protos::TraceConfig_BuiltinDataSource* mutable_builtin_data_sources();
  ::perfetto::protos::TraceConfig_BuiltinDataSource* release_builtin_data_sources();
  void set_allocated_builtin_data_sources(::perfetto::protos::TraceConfig_BuiltinDataSource* builtin_data_sources);

  // optional uint32 duration_ms = 3;
  bool has_duration_ms() const;
  void clear_duration_ms();
  static const int kDurationMsFieldNumber = 3;
  ::google::protobuf::uint32 duration_ms() const;
  void set_duration_ms(::google::protobuf::uint32 value);

  // optional bool enable_extra_guardrails = 4;
  bool has_enable_extra_guardrails() const;
  void clear_enable_extra_guardrails();
  static const int kEnableExtraGuardrailsFieldNumber = 4;
  bool enable_extra_guardrails() const;
  void set_enable_extra_guardrails(bool value);

  // optional .perfetto.protos.TraceConfig.LockdownModeOperation lockdown_mode = 5;
  bool has_lockdown_mode() const;
  void clear_lockdown_mode();
  static const int kLockdownModeFieldNumber = 5;
  ::perfetto::protos::TraceConfig_LockdownModeOperation lockdown_mode() const;
  void set_lockdown_mode(::perfetto::protos::TraceConfig_LockdownModeOperation value);

  // repeated .perfetto.protos.TraceConfig.ProducerConfig producers = 6;
  int producers_size() const;
  void clear_producers();
  static const int kProducersFieldNumber = 6;
  const ::perfetto::protos::TraceConfig_ProducerConfig& producers(int index) const;
  ::perfetto::protos::TraceConfig_ProducerConfig* mutable_producers(int index);
  ::perfetto::protos::TraceConfig_ProducerConfig* add_producers();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_ProducerConfig >*
      mutable_producers();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_ProducerConfig >&
      producers() const;

  // optional .perfetto.protos.TraceConfig.StatsdMetadata statsd_metadata = 7;
  bool has_statsd_metadata() const;
  void clear_statsd_metadata();
  static const int kStatsdMetadataFieldNumber = 7;
  const ::perfetto::protos::TraceConfig_StatsdMetadata& statsd_metadata() const;
  ::perfetto::protos::TraceConfig_StatsdMetadata* mutable_statsd_metadata();
  ::perfetto::protos::TraceConfig_StatsdMetadata* release_statsd_metadata();
  void set_allocated_statsd_metadata(::perfetto::protos::TraceConfig_StatsdMetadata* statsd_metadata);

  // optional bool write_into_file = 8;
  bool has_write_into_file() const;
  void clear_write_into_file();
  static const int kWriteIntoFileFieldNumber = 8;
  bool write_into_file() const;
  void set_write_into_file(bool value);

  // optional uint32 file_write_period_ms = 9;
  bool has_file_write_period_ms() const;
  void clear_file_write_period_ms();
  static const int kFileWritePeriodMsFieldNumber = 9;
  ::google::protobuf::uint32 file_write_period_ms() const;
  void set_file_write_period_ms(::google::protobuf::uint32 value);

  // optional uint64 max_file_size_bytes = 10;
  bool has_max_file_size_bytes() const;
  void clear_max_file_size_bytes();
  static const int kMaxFileSizeBytesFieldNumber = 10;
  ::google::protobuf::uint64 max_file_size_bytes() const;
  void set_max_file_size_bytes(::google::protobuf::uint64 value);

  // optional .perfetto.protos.TraceConfig.GuardrailOverrides guardrail_overrides = 11;
  bool has_guardrail_overrides() const;
  void clear_guardrail_overrides();
  static const int kGuardrailOverridesFieldNumber = 11;
  const ::perfetto::protos::TraceConfig_GuardrailOverrides& guardrail_overrides() const;
  ::perfetto::protos::TraceConfig_GuardrailOverrides* mutable_guardrail_overrides();
  ::perfetto::protos::TraceConfig_GuardrailOverrides* release_guardrail_overrides();
  void set_allocated_guardrail_overrides(::perfetto::protos::TraceConfig_GuardrailOverrides* guardrail_overrides);

  // optional bool deferred_start = 12;
  bool has_deferred_start() const;
  void clear_deferred_start();
  static const int kDeferredStartFieldNumber = 12;
  bool deferred_start() const;
  void set_deferred_start(bool value);

  // optional uint32 flush_period_ms = 13;
  bool has_flush_period_ms() const;
  void clear_flush_period_ms();
  static const int kFlushPeriodMsFieldNumber = 13;
  ::google::protobuf::uint32 flush_period_ms() const;
  void set_flush_period_ms(::google::protobuf::uint32 value);

  // optional uint32 flush_timeout_ms = 14;
  bool has_flush_timeout_ms() const;
  void clear_flush_timeout_ms();
  static const int kFlushTimeoutMsFieldNumber = 14;
  ::google::protobuf::uint32 flush_timeout_ms() const;
  void set_flush_timeout_ms(::google::protobuf::uint32 value);

  // optional uint32 data_source_stop_timeout_ms = 23;
  bool has_data_source_stop_timeout_ms() const;
  void clear_data_source_stop_timeout_ms();
  static const int kDataSourceStopTimeoutMsFieldNumber = 23;
  ::google::protobuf::uint32 data_source_stop_timeout_ms() const;
  void set_data_source_stop_timeout_ms(::google::protobuf::uint32 value);

  // optional bool notify_traceur = 16;
  bool has_notify_traceur() const;
  void clear_notify_traceur();
  static const int kNotifyTraceurFieldNumber = 16;
  bool notify_traceur() const;
  void set_notify_traceur(bool value);

  // optional .perfetto.protos.TraceConfig.TriggerConfig trigger_config = 17;
  bool has_trigger_config() const;
  void clear_trigger_config();
  static const int kTriggerConfigFieldNumber = 17;
  const ::perfetto::protos::TraceConfig_TriggerConfig& trigger_config() const;
  ::perfetto::protos::TraceConfig_TriggerConfig* mutable_trigger_config();
  ::perfetto::protos::TraceConfig_TriggerConfig* release_trigger_config();
  void set_allocated_trigger_config(::perfetto::protos::TraceConfig_TriggerConfig* trigger_config);

  // repeated string activate_triggers = 18;
  int activate_triggers_size() const;
  void clear_activate_triggers();
  static const int kActivateTriggersFieldNumber = 18;
  const ::std::string& activate_triggers(int index) const;
  ::std::string* mutable_activate_triggers(int index);
  void set_activate_triggers(int index, const ::std::string& value);
  void set_activate_triggers(int index, const char* value);
  void set_activate_triggers(int index, const char* value, size_t size);
  ::std::string* add_activate_triggers();
  void add_activate_triggers(const ::std::string& value);
  void add_activate_triggers(const char* value);
  void add_activate_triggers(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& activate_triggers() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_activate_triggers();

  // optional .perfetto.protos.TraceConfig.IncrementalStateConfig incremental_state_config = 21;
  bool has_incremental_state_config() const;
  void clear_incremental_state_config();
  static const int kIncrementalStateConfigFieldNumber = 21;
  const ::perfetto::protos::TraceConfig_IncrementalStateConfig& incremental_state_config() const;
  ::perfetto::protos::TraceConfig_IncrementalStateConfig* mutable_incremental_state_config();
  ::perfetto::protos::TraceConfig_IncrementalStateConfig* release_incremental_state_config();
  void set_allocated_incremental_state_config(::perfetto::protos::TraceConfig_IncrementalStateConfig* incremental_state_config);

  // optional bool allow_user_build_tracing = 19;
  bool has_allow_user_build_tracing() const;
  void clear_allow_user_build_tracing();
  static const int kAllowUserBuildTracingFieldNumber = 19;
  bool allow_user_build_tracing() const;
  void set_allow_user_build_tracing(bool value);

  // optional string unique_session_name = 22;
  bool has_unique_session_name() const;
  void clear_unique_session_name();
  static const int kUniqueSessionNameFieldNumber = 22;
  const ::std::string& unique_session_name() const;
  void set_unique_session_name(const ::std::string& value);
  void set_unique_session_name(const char* value);
  void set_unique_session_name(const char* value, size_t size);
  ::std::string* mutable_unique_session_name();
  ::std::string* release_unique_session_name();
  void set_allocated_unique_session_name(::std::string* unique_session_name);

  // optional .perfetto.protos.TraceConfig.CompressionType compression_type = 24;
  bool has_compression_type() const;
  void clear_compression_type();
  static const int kCompressionTypeFieldNumber = 24;
  ::perfetto::protos::TraceConfig_CompressionType compression_type() const;
  void set_compression_type(::perfetto::protos::TraceConfig_CompressionType value);

  // optional .perfetto.protos.TraceConfig.IncidentReportConfig incident_report_config = 25;
  bool has_incident_report_config() const;
  void clear_incident_report_config();
  static const int kIncidentReportConfigFieldNumber = 25;
  const ::perfetto::protos::TraceConfig_IncidentReportConfig& incident_report_config() const;
  ::perfetto::protos::TraceConfig_IncidentReportConfig* mutable_incident_report_config();
  ::perfetto::protos::TraceConfig_IncidentReportConfig* release_incident_report_config();
  void set_allocated_incident_report_config(::perfetto::protos::TraceConfig_IncidentReportConfig* incident_report_config);

  // optional bytes trace_uuid = 26;
  bool has_trace_uuid() const;
  void clear_trace_uuid();
  static const int kTraceUuidFieldNumber = 26;
  const ::std::string& trace_uuid() const;
  void set_trace_uuid(const ::std::string& value);
  void set_trace_uuid(const char* value);
  void set_trace_uuid(const void* value, size_t size);
  ::std::string* mutable_trace_uuid();
  ::std::string* release_trace_uuid();
  void set_allocated_trace_uuid(::std::string* trace_uuid);

  // @@protoc_insertion_point(class_scope:perfetto.protos.TraceConfig)
 private:
  inline void set_has_builtin_data_sources();
  inline void clear_has_builtin_data_sources();
  inline void set_has_duration_ms();
  inline void clear_has_duration_ms();
  inline void set_has_enable_extra_guardrails();
  inline void clear_has_enable_extra_guardrails();
  inline void set_has_lockdown_mode();
  inline void clear_has_lockdown_mode();
  inline void set_has_statsd_metadata();
  inline void clear_has_statsd_metadata();
  inline void set_has_write_into_file();
  inline void clear_has_write_into_file();
  inline void set_has_file_write_period_ms();
  inline void clear_has_file_write_period_ms();
  inline void set_has_max_file_size_bytes();
  inline void clear_has_max_file_size_bytes();
  inline void set_has_guardrail_overrides();
  inline void clear_has_guardrail_overrides();
  inline void set_has_deferred_start();
  inline void clear_has_deferred_start();
  inline void set_has_flush_period_ms();
  inline void clear_has_flush_period_ms();
  inline void set_has_flush_timeout_ms();
  inline void clear_has_flush_timeout_ms();
  inline void set_has_data_source_stop_timeout_ms();
  inline void clear_has_data_source_stop_timeout_ms();
  inline void set_has_notify_traceur();
  inline void clear_has_notify_traceur();
  inline void set_has_trigger_config();
  inline void clear_has_trigger_config();
  inline void set_has_incremental_state_config();
  inline void clear_has_incremental_state_config();
  inline void set_has_allow_user_build_tracing();
  inline void clear_has_allow_user_build_tracing();
  inline void set_has_unique_session_name();
  inline void clear_has_unique_session_name();
  inline void set_has_compression_type();
  inline void clear_has_compression_type();
  inline void set_has_incident_report_config();
  inline void clear_has_incident_report_config();
  inline void set_has_trace_uuid();
  inline void clear_has_trace_uuid();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_BufferConfig > buffers_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_DataSource > data_sources_;
  ::perfetto::protos::TraceConfig_BuiltinDataSource* builtin_data_sources_;
  ::google::protobuf::uint32 duration_ms_;
  int lockdown_mode_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_ProducerConfig > producers_;
  ::perfetto::protos::TraceConfig_StatsdMetadata* statsd_metadata_;
  ::google::protobuf::uint32 file_write_period_ms_;
  bool enable_extra_guardrails_;
  bool write_into_file_;
  bool deferred_start_;
  bool notify_traceur_;
  ::google::protobuf::uint64 max_file_size_bytes_;
  ::perfetto::protos::TraceConfig_GuardrailOverrides* guardrail_overrides_;
  ::google::protobuf::uint32 flush_period_ms_;
  ::google::protobuf::uint32 flush_timeout_ms_;
  ::perfetto::protos::TraceConfig_TriggerConfig* trigger_config_;
  ::google::protobuf::uint32 data_source_stop_timeout_ms_;
  bool allow_user_build_tracing_;
  ::google::protobuf::RepeatedPtrField< ::std::string> activate_triggers_;
  ::perfetto::protos::TraceConfig_IncrementalStateConfig* incremental_state_config_;
  ::google::protobuf::internal::ArenaStringPtr unique_session_name_;
  ::perfetto::protos::TraceConfig_IncidentReportConfig* incident_report_config_;
  ::google::protobuf::internal::ArenaStringPtr trace_uuid_;
  int compression_type_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static TraceConfig* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// TraceConfig_BufferConfig

// optional uint32 size_kb = 1;
inline bool TraceConfig_BufferConfig::has_size_kb() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TraceConfig_BufferConfig::set_has_size_kb() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TraceConfig_BufferConfig::clear_has_size_kb() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TraceConfig_BufferConfig::clear_size_kb() {
  size_kb_ = 0u;
  clear_has_size_kb();
}
inline ::google::protobuf::uint32 TraceConfig_BufferConfig::size_kb() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.BufferConfig.size_kb)
  return size_kb_;
}
inline void TraceConfig_BufferConfig::set_size_kb(::google::protobuf::uint32 value) {
  set_has_size_kb();
  size_kb_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.BufferConfig.size_kb)
}

// optional .perfetto.protos.TraceConfig.BufferConfig.FillPolicy fill_policy = 4;
inline bool TraceConfig_BufferConfig::has_fill_policy() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TraceConfig_BufferConfig::set_has_fill_policy() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TraceConfig_BufferConfig::clear_has_fill_policy() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TraceConfig_BufferConfig::clear_fill_policy() {
  fill_policy_ = 0;
  clear_has_fill_policy();
}
inline ::perfetto::protos::TraceConfig_BufferConfig_FillPolicy TraceConfig_BufferConfig::fill_policy() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.BufferConfig.fill_policy)
  return static_cast< ::perfetto::protos::TraceConfig_BufferConfig_FillPolicy >(fill_policy_);
}
inline void TraceConfig_BufferConfig::set_fill_policy(::perfetto::protos::TraceConfig_BufferConfig_FillPolicy value) {
  assert(::perfetto::protos::TraceConfig_BufferConfig_FillPolicy_IsValid(value));
  set_has_fill_policy();
  fill_policy_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.BufferConfig.fill_policy)
}

// -------------------------------------------------------------------

// TraceConfig_DataSource

// optional .perfetto.protos.DataSourceConfig config = 1;
inline bool TraceConfig_DataSource::has_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TraceConfig_DataSource::set_has_config() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TraceConfig_DataSource::clear_has_config() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TraceConfig_DataSource::clear_config() {
  if (config_ != NULL) config_->::perfetto::protos::DataSourceConfig::Clear();
  clear_has_config();
}
inline const ::perfetto::protos::DataSourceConfig& TraceConfig_DataSource::config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.DataSource.config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return config_ != NULL ? *config_ : *default_instance().config_;
#else
  return config_ != NULL ? *config_ : *default_instance_->config_;
#endif
}
inline ::perfetto::protos::DataSourceConfig* TraceConfig_DataSource::mutable_config() {
  set_has_config();
  if (config_ == NULL) {
    config_ = new ::perfetto::protos::DataSourceConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.DataSource.config)
  return config_;
}
inline ::perfetto::protos::DataSourceConfig* TraceConfig_DataSource::release_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.DataSource.config)
  clear_has_config();
  ::perfetto::protos::DataSourceConfig* temp = config_;
  config_ = NULL;
  return temp;
}
inline void TraceConfig_DataSource::set_allocated_config(::perfetto::protos::DataSourceConfig* config) {
  delete config_;
  config_ = config;
  if (config) {
    set_has_config();
  } else {
    clear_has_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.DataSource.config)
}

// repeated string producer_name_filter = 2;
inline int TraceConfig_DataSource::producer_name_filter_size() const {
  return producer_name_filter_.size();
}
inline void TraceConfig_DataSource::clear_producer_name_filter() {
  producer_name_filter_.Clear();
}
inline const ::std::string& TraceConfig_DataSource::producer_name_filter(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.DataSource.producer_name_filter)
  return producer_name_filter_.Get(index);
}
inline ::std::string* TraceConfig_DataSource::mutable_producer_name_filter(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.DataSource.producer_name_filter)
  return producer_name_filter_.Mutable(index);
}
inline void TraceConfig_DataSource::set_producer_name_filter(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.DataSource.producer_name_filter)
  producer_name_filter_.Mutable(index)->assign(value);
}
inline void TraceConfig_DataSource::set_producer_name_filter(int index, const char* value) {
  producer_name_filter_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.TraceConfig.DataSource.producer_name_filter)
}
inline void TraceConfig_DataSource::set_producer_name_filter(int index, const char* value, size_t size) {
  producer_name_filter_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.TraceConfig.DataSource.producer_name_filter)
}
inline ::std::string* TraceConfig_DataSource::add_producer_name_filter() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.TraceConfig.DataSource.producer_name_filter)
  return producer_name_filter_.Add();
}
inline void TraceConfig_DataSource::add_producer_name_filter(const ::std::string& value) {
  producer_name_filter_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.TraceConfig.DataSource.producer_name_filter)
}
inline void TraceConfig_DataSource::add_producer_name_filter(const char* value) {
  producer_name_filter_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.TraceConfig.DataSource.producer_name_filter)
}
inline void TraceConfig_DataSource::add_producer_name_filter(const char* value, size_t size) {
  producer_name_filter_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.TraceConfig.DataSource.producer_name_filter)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TraceConfig_DataSource::producer_name_filter() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.TraceConfig.DataSource.producer_name_filter)
  return producer_name_filter_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TraceConfig_DataSource::mutable_producer_name_filter() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.TraceConfig.DataSource.producer_name_filter)
  return &producer_name_filter_;
}

// -------------------------------------------------------------------

// TraceConfig_BuiltinDataSource

// optional bool disable_clock_snapshotting = 1;
inline bool TraceConfig_BuiltinDataSource::has_disable_clock_snapshotting() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TraceConfig_BuiltinDataSource::set_has_disable_clock_snapshotting() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TraceConfig_BuiltinDataSource::clear_has_disable_clock_snapshotting() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TraceConfig_BuiltinDataSource::clear_disable_clock_snapshotting() {
  disable_clock_snapshotting_ = false;
  clear_has_disable_clock_snapshotting();
}
inline bool TraceConfig_BuiltinDataSource::disable_clock_snapshotting() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.BuiltinDataSource.disable_clock_snapshotting)
  return disable_clock_snapshotting_;
}
inline void TraceConfig_BuiltinDataSource::set_disable_clock_snapshotting(bool value) {
  set_has_disable_clock_snapshotting();
  disable_clock_snapshotting_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.BuiltinDataSource.disable_clock_snapshotting)
}

// optional bool disable_trace_config = 2;
inline bool TraceConfig_BuiltinDataSource::has_disable_trace_config() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TraceConfig_BuiltinDataSource::set_has_disable_trace_config() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TraceConfig_BuiltinDataSource::clear_has_disable_trace_config() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TraceConfig_BuiltinDataSource::clear_disable_trace_config() {
  disable_trace_config_ = false;
  clear_has_disable_trace_config();
}
inline bool TraceConfig_BuiltinDataSource::disable_trace_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.BuiltinDataSource.disable_trace_config)
  return disable_trace_config_;
}
inline void TraceConfig_BuiltinDataSource::set_disable_trace_config(bool value) {
  set_has_disable_trace_config();
  disable_trace_config_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.BuiltinDataSource.disable_trace_config)
}

// optional bool disable_system_info = 3;
inline bool TraceConfig_BuiltinDataSource::has_disable_system_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TraceConfig_BuiltinDataSource::set_has_disable_system_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TraceConfig_BuiltinDataSource::clear_has_disable_system_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TraceConfig_BuiltinDataSource::clear_disable_system_info() {
  disable_system_info_ = false;
  clear_has_disable_system_info();
}
inline bool TraceConfig_BuiltinDataSource::disable_system_info() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.BuiltinDataSource.disable_system_info)
  return disable_system_info_;
}
inline void TraceConfig_BuiltinDataSource::set_disable_system_info(bool value) {
  set_has_disable_system_info();
  disable_system_info_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.BuiltinDataSource.disable_system_info)
}

// -------------------------------------------------------------------

// TraceConfig_ProducerConfig

// optional string producer_name = 1;
inline bool TraceConfig_ProducerConfig::has_producer_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TraceConfig_ProducerConfig::set_has_producer_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TraceConfig_ProducerConfig::clear_has_producer_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TraceConfig_ProducerConfig::clear_producer_name() {
  producer_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_producer_name();
}
inline const ::std::string& TraceConfig_ProducerConfig::producer_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.ProducerConfig.producer_name)
  return producer_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TraceConfig_ProducerConfig::set_producer_name(const ::std::string& value) {
  set_has_producer_name();
  producer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.ProducerConfig.producer_name)
}
inline void TraceConfig_ProducerConfig::set_producer_name(const char* value) {
  set_has_producer_name();
  producer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.TraceConfig.ProducerConfig.producer_name)
}
inline void TraceConfig_ProducerConfig::set_producer_name(const char* value, size_t size) {
  set_has_producer_name();
  producer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.TraceConfig.ProducerConfig.producer_name)
}
inline ::std::string* TraceConfig_ProducerConfig::mutable_producer_name() {
  set_has_producer_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.ProducerConfig.producer_name)
  return producer_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TraceConfig_ProducerConfig::release_producer_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.ProducerConfig.producer_name)
  clear_has_producer_name();
  return producer_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TraceConfig_ProducerConfig::set_allocated_producer_name(::std::string* producer_name) {
  if (producer_name != NULL) {
    set_has_producer_name();
  } else {
    clear_has_producer_name();
  }
  producer_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), producer_name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.ProducerConfig.producer_name)
}

// optional uint32 shm_size_kb = 2;
inline bool TraceConfig_ProducerConfig::has_shm_size_kb() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TraceConfig_ProducerConfig::set_has_shm_size_kb() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TraceConfig_ProducerConfig::clear_has_shm_size_kb() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TraceConfig_ProducerConfig::clear_shm_size_kb() {
  shm_size_kb_ = 0u;
  clear_has_shm_size_kb();
}
inline ::google::protobuf::uint32 TraceConfig_ProducerConfig::shm_size_kb() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.ProducerConfig.shm_size_kb)
  return shm_size_kb_;
}
inline void TraceConfig_ProducerConfig::set_shm_size_kb(::google::protobuf::uint32 value) {
  set_has_shm_size_kb();
  shm_size_kb_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.ProducerConfig.shm_size_kb)
}

// optional uint32 page_size_kb = 3;
inline bool TraceConfig_ProducerConfig::has_page_size_kb() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TraceConfig_ProducerConfig::set_has_page_size_kb() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TraceConfig_ProducerConfig::clear_has_page_size_kb() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TraceConfig_ProducerConfig::clear_page_size_kb() {
  page_size_kb_ = 0u;
  clear_has_page_size_kb();
}
inline ::google::protobuf::uint32 TraceConfig_ProducerConfig::page_size_kb() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.ProducerConfig.page_size_kb)
  return page_size_kb_;
}
inline void TraceConfig_ProducerConfig::set_page_size_kb(::google::protobuf::uint32 value) {
  set_has_page_size_kb();
  page_size_kb_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.ProducerConfig.page_size_kb)
}

// -------------------------------------------------------------------

// TraceConfig_StatsdMetadata

// optional int64 triggering_alert_id = 1;
inline bool TraceConfig_StatsdMetadata::has_triggering_alert_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TraceConfig_StatsdMetadata::set_has_triggering_alert_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TraceConfig_StatsdMetadata::clear_has_triggering_alert_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TraceConfig_StatsdMetadata::clear_triggering_alert_id() {
  triggering_alert_id_ = GOOGLE_LONGLONG(0);
  clear_has_triggering_alert_id();
}
inline ::google::protobuf::int64 TraceConfig_StatsdMetadata::triggering_alert_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.StatsdMetadata.triggering_alert_id)
  return triggering_alert_id_;
}
inline void TraceConfig_StatsdMetadata::set_triggering_alert_id(::google::protobuf::int64 value) {
  set_has_triggering_alert_id();
  triggering_alert_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.StatsdMetadata.triggering_alert_id)
}

// optional int32 triggering_config_uid = 2;
inline bool TraceConfig_StatsdMetadata::has_triggering_config_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TraceConfig_StatsdMetadata::set_has_triggering_config_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TraceConfig_StatsdMetadata::clear_has_triggering_config_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TraceConfig_StatsdMetadata::clear_triggering_config_uid() {
  triggering_config_uid_ = 0;
  clear_has_triggering_config_uid();
}
inline ::google::protobuf::int32 TraceConfig_StatsdMetadata::triggering_config_uid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.StatsdMetadata.triggering_config_uid)
  return triggering_config_uid_;
}
inline void TraceConfig_StatsdMetadata::set_triggering_config_uid(::google::protobuf::int32 value) {
  set_has_triggering_config_uid();
  triggering_config_uid_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.StatsdMetadata.triggering_config_uid)
}

// optional int64 triggering_config_id = 3;
inline bool TraceConfig_StatsdMetadata::has_triggering_config_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TraceConfig_StatsdMetadata::set_has_triggering_config_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TraceConfig_StatsdMetadata::clear_has_triggering_config_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TraceConfig_StatsdMetadata::clear_triggering_config_id() {
  triggering_config_id_ = GOOGLE_LONGLONG(0);
  clear_has_triggering_config_id();
}
inline ::google::protobuf::int64 TraceConfig_StatsdMetadata::triggering_config_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.StatsdMetadata.triggering_config_id)
  return triggering_config_id_;
}
inline void TraceConfig_StatsdMetadata::set_triggering_config_id(::google::protobuf::int64 value) {
  set_has_triggering_config_id();
  triggering_config_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.StatsdMetadata.triggering_config_id)
}

// optional int64 triggering_subscription_id = 4;
inline bool TraceConfig_StatsdMetadata::has_triggering_subscription_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TraceConfig_StatsdMetadata::set_has_triggering_subscription_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TraceConfig_StatsdMetadata::clear_has_triggering_subscription_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TraceConfig_StatsdMetadata::clear_triggering_subscription_id() {
  triggering_subscription_id_ = GOOGLE_LONGLONG(0);
  clear_has_triggering_subscription_id();
}
inline ::google::protobuf::int64 TraceConfig_StatsdMetadata::triggering_subscription_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.StatsdMetadata.triggering_subscription_id)
  return triggering_subscription_id_;
}
inline void TraceConfig_StatsdMetadata::set_triggering_subscription_id(::google::protobuf::int64 value) {
  set_has_triggering_subscription_id();
  triggering_subscription_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.StatsdMetadata.triggering_subscription_id)
}

// -------------------------------------------------------------------

// TraceConfig_GuardrailOverrides

// optional uint64 max_upload_per_day_bytes = 1;
inline bool TraceConfig_GuardrailOverrides::has_max_upload_per_day_bytes() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TraceConfig_GuardrailOverrides::set_has_max_upload_per_day_bytes() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TraceConfig_GuardrailOverrides::clear_has_max_upload_per_day_bytes() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TraceConfig_GuardrailOverrides::clear_max_upload_per_day_bytes() {
  max_upload_per_day_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_max_upload_per_day_bytes();
}
inline ::google::protobuf::uint64 TraceConfig_GuardrailOverrides::max_upload_per_day_bytes() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.GuardrailOverrides.max_upload_per_day_bytes)
  return max_upload_per_day_bytes_;
}
inline void TraceConfig_GuardrailOverrides::set_max_upload_per_day_bytes(::google::protobuf::uint64 value) {
  set_has_max_upload_per_day_bytes();
  max_upload_per_day_bytes_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.GuardrailOverrides.max_upload_per_day_bytes)
}

// -------------------------------------------------------------------

// TraceConfig_TriggerConfig_Trigger

// optional string name = 1;
inline bool TraceConfig_TriggerConfig_Trigger::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TraceConfig_TriggerConfig_Trigger::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TraceConfig_TriggerConfig_Trigger::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TraceConfig_TriggerConfig_Trigger::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& TraceConfig_TriggerConfig_Trigger::name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.TriggerConfig.Trigger.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TraceConfig_TriggerConfig_Trigger::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.TriggerConfig.Trigger.name)
}
inline void TraceConfig_TriggerConfig_Trigger::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.TraceConfig.TriggerConfig.Trigger.name)
}
inline void TraceConfig_TriggerConfig_Trigger::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.TraceConfig.TriggerConfig.Trigger.name)
}
inline ::std::string* TraceConfig_TriggerConfig_Trigger::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.TriggerConfig.Trigger.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TraceConfig_TriggerConfig_Trigger::release_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.TriggerConfig.Trigger.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TraceConfig_TriggerConfig_Trigger::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.TriggerConfig.Trigger.name)
}

// optional string producer_name_regex = 2;
inline bool TraceConfig_TriggerConfig_Trigger::has_producer_name_regex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TraceConfig_TriggerConfig_Trigger::set_has_producer_name_regex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TraceConfig_TriggerConfig_Trigger::clear_has_producer_name_regex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TraceConfig_TriggerConfig_Trigger::clear_producer_name_regex() {
  producer_name_regex_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_producer_name_regex();
}
inline const ::std::string& TraceConfig_TriggerConfig_Trigger::producer_name_regex() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.TriggerConfig.Trigger.producer_name_regex)
  return producer_name_regex_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TraceConfig_TriggerConfig_Trigger::set_producer_name_regex(const ::std::string& value) {
  set_has_producer_name_regex();
  producer_name_regex_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.TriggerConfig.Trigger.producer_name_regex)
}
inline void TraceConfig_TriggerConfig_Trigger::set_producer_name_regex(const char* value) {
  set_has_producer_name_regex();
  producer_name_regex_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.TraceConfig.TriggerConfig.Trigger.producer_name_regex)
}
inline void TraceConfig_TriggerConfig_Trigger::set_producer_name_regex(const char* value, size_t size) {
  set_has_producer_name_regex();
  producer_name_regex_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.TraceConfig.TriggerConfig.Trigger.producer_name_regex)
}
inline ::std::string* TraceConfig_TriggerConfig_Trigger::mutable_producer_name_regex() {
  set_has_producer_name_regex();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.TriggerConfig.Trigger.producer_name_regex)
  return producer_name_regex_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TraceConfig_TriggerConfig_Trigger::release_producer_name_regex() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.TriggerConfig.Trigger.producer_name_regex)
  clear_has_producer_name_regex();
  return producer_name_regex_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TraceConfig_TriggerConfig_Trigger::set_allocated_producer_name_regex(::std::string* producer_name_regex) {
  if (producer_name_regex != NULL) {
    set_has_producer_name_regex();
  } else {
    clear_has_producer_name_regex();
  }
  producer_name_regex_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), producer_name_regex);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.TriggerConfig.Trigger.producer_name_regex)
}

// optional uint32 stop_delay_ms = 3;
inline bool TraceConfig_TriggerConfig_Trigger::has_stop_delay_ms() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TraceConfig_TriggerConfig_Trigger::set_has_stop_delay_ms() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TraceConfig_TriggerConfig_Trigger::clear_has_stop_delay_ms() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TraceConfig_TriggerConfig_Trigger::clear_stop_delay_ms() {
  stop_delay_ms_ = 0u;
  clear_has_stop_delay_ms();
}
inline ::google::protobuf::uint32 TraceConfig_TriggerConfig_Trigger::stop_delay_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.TriggerConfig.Trigger.stop_delay_ms)
  return stop_delay_ms_;
}
inline void TraceConfig_TriggerConfig_Trigger::set_stop_delay_ms(::google::protobuf::uint32 value) {
  set_has_stop_delay_ms();
  stop_delay_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.TriggerConfig.Trigger.stop_delay_ms)
}

// -------------------------------------------------------------------

// TraceConfig_TriggerConfig

// optional .perfetto.protos.TraceConfig.TriggerConfig.TriggerMode trigger_mode = 1;
inline bool TraceConfig_TriggerConfig::has_trigger_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TraceConfig_TriggerConfig::set_has_trigger_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TraceConfig_TriggerConfig::clear_has_trigger_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TraceConfig_TriggerConfig::clear_trigger_mode() {
  trigger_mode_ = 0;
  clear_has_trigger_mode();
}
inline ::perfetto::protos::TraceConfig_TriggerConfig_TriggerMode TraceConfig_TriggerConfig::trigger_mode() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.TriggerConfig.trigger_mode)
  return static_cast< ::perfetto::protos::TraceConfig_TriggerConfig_TriggerMode >(trigger_mode_);
}
inline void TraceConfig_TriggerConfig::set_trigger_mode(::perfetto::protos::TraceConfig_TriggerConfig_TriggerMode value) {
  assert(::perfetto::protos::TraceConfig_TriggerConfig_TriggerMode_IsValid(value));
  set_has_trigger_mode();
  trigger_mode_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.TriggerConfig.trigger_mode)
}

// repeated .perfetto.protos.TraceConfig.TriggerConfig.Trigger triggers = 2;
inline int TraceConfig_TriggerConfig::triggers_size() const {
  return triggers_.size();
}
inline void TraceConfig_TriggerConfig::clear_triggers() {
  triggers_.Clear();
}
inline const ::perfetto::protos::TraceConfig_TriggerConfig_Trigger& TraceConfig_TriggerConfig::triggers(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.TriggerConfig.triggers)
  return triggers_.Get(index);
}
inline ::perfetto::protos::TraceConfig_TriggerConfig_Trigger* TraceConfig_TriggerConfig::mutable_triggers(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.TriggerConfig.triggers)
  return triggers_.Mutable(index);
}
inline ::perfetto::protos::TraceConfig_TriggerConfig_Trigger* TraceConfig_TriggerConfig::add_triggers() {
  // @@protoc_insertion_point(field_add:perfetto.protos.TraceConfig.TriggerConfig.triggers)
  return triggers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_TriggerConfig_Trigger >*
TraceConfig_TriggerConfig::mutable_triggers() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.TraceConfig.TriggerConfig.triggers)
  return &triggers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_TriggerConfig_Trigger >&
TraceConfig_TriggerConfig::triggers() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.TraceConfig.TriggerConfig.triggers)
  return triggers_;
}

// optional uint32 trigger_timeout_ms = 3;
inline bool TraceConfig_TriggerConfig::has_trigger_timeout_ms() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TraceConfig_TriggerConfig::set_has_trigger_timeout_ms() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TraceConfig_TriggerConfig::clear_has_trigger_timeout_ms() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TraceConfig_TriggerConfig::clear_trigger_timeout_ms() {
  trigger_timeout_ms_ = 0u;
  clear_has_trigger_timeout_ms();
}
inline ::google::protobuf::uint32 TraceConfig_TriggerConfig::trigger_timeout_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.TriggerConfig.trigger_timeout_ms)
  return trigger_timeout_ms_;
}
inline void TraceConfig_TriggerConfig::set_trigger_timeout_ms(::google::protobuf::uint32 value) {
  set_has_trigger_timeout_ms();
  trigger_timeout_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.TriggerConfig.trigger_timeout_ms)
}

// -------------------------------------------------------------------

// TraceConfig_IncrementalStateConfig

// optional uint32 clear_period_ms = 1;
inline bool TraceConfig_IncrementalStateConfig::has_clear_period_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TraceConfig_IncrementalStateConfig::set_has_clear_period_ms() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TraceConfig_IncrementalStateConfig::clear_has_clear_period_ms() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TraceConfig_IncrementalStateConfig::clear_clear_period_ms() {
  clear_period_ms_ = 0u;
  clear_has_clear_period_ms();
}
inline ::google::protobuf::uint32 TraceConfig_IncrementalStateConfig::clear_period_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.IncrementalStateConfig.clear_period_ms)
  return clear_period_ms_;
}
inline void TraceConfig_IncrementalStateConfig::set_clear_period_ms(::google::protobuf::uint32 value) {
  set_has_clear_period_ms();
  clear_period_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.IncrementalStateConfig.clear_period_ms)
}

// -------------------------------------------------------------------

// TraceConfig_IncidentReportConfig

// optional string destination_package = 1;
inline bool TraceConfig_IncidentReportConfig::has_destination_package() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TraceConfig_IncidentReportConfig::set_has_destination_package() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TraceConfig_IncidentReportConfig::clear_has_destination_package() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TraceConfig_IncidentReportConfig::clear_destination_package() {
  destination_package_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_destination_package();
}
inline const ::std::string& TraceConfig_IncidentReportConfig::destination_package() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.IncidentReportConfig.destination_package)
  return destination_package_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TraceConfig_IncidentReportConfig::set_destination_package(const ::std::string& value) {
  set_has_destination_package();
  destination_package_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.IncidentReportConfig.destination_package)
}
inline void TraceConfig_IncidentReportConfig::set_destination_package(const char* value) {
  set_has_destination_package();
  destination_package_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.TraceConfig.IncidentReportConfig.destination_package)
}
inline void TraceConfig_IncidentReportConfig::set_destination_package(const char* value, size_t size) {
  set_has_destination_package();
  destination_package_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.TraceConfig.IncidentReportConfig.destination_package)
}
inline ::std::string* TraceConfig_IncidentReportConfig::mutable_destination_package() {
  set_has_destination_package();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.IncidentReportConfig.destination_package)
  return destination_package_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TraceConfig_IncidentReportConfig::release_destination_package() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.IncidentReportConfig.destination_package)
  clear_has_destination_package();
  return destination_package_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TraceConfig_IncidentReportConfig::set_allocated_destination_package(::std::string* destination_package) {
  if (destination_package != NULL) {
    set_has_destination_package();
  } else {
    clear_has_destination_package();
  }
  destination_package_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), destination_package);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.IncidentReportConfig.destination_package)
}

// optional string destination_class = 2;
inline bool TraceConfig_IncidentReportConfig::has_destination_class() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TraceConfig_IncidentReportConfig::set_has_destination_class() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TraceConfig_IncidentReportConfig::clear_has_destination_class() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TraceConfig_IncidentReportConfig::clear_destination_class() {
  destination_class_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_destination_class();
}
inline const ::std::string& TraceConfig_IncidentReportConfig::destination_class() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.IncidentReportConfig.destination_class)
  return destination_class_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TraceConfig_IncidentReportConfig::set_destination_class(const ::std::string& value) {
  set_has_destination_class();
  destination_class_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.IncidentReportConfig.destination_class)
}
inline void TraceConfig_IncidentReportConfig::set_destination_class(const char* value) {
  set_has_destination_class();
  destination_class_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.TraceConfig.IncidentReportConfig.destination_class)
}
inline void TraceConfig_IncidentReportConfig::set_destination_class(const char* value, size_t size) {
  set_has_destination_class();
  destination_class_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.TraceConfig.IncidentReportConfig.destination_class)
}
inline ::std::string* TraceConfig_IncidentReportConfig::mutable_destination_class() {
  set_has_destination_class();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.IncidentReportConfig.destination_class)
  return destination_class_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TraceConfig_IncidentReportConfig::release_destination_class() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.IncidentReportConfig.destination_class)
  clear_has_destination_class();
  return destination_class_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TraceConfig_IncidentReportConfig::set_allocated_destination_class(::std::string* destination_class) {
  if (destination_class != NULL) {
    set_has_destination_class();
  } else {
    clear_has_destination_class();
  }
  destination_class_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), destination_class);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.IncidentReportConfig.destination_class)
}

// optional int32 privacy_level = 3;
inline bool TraceConfig_IncidentReportConfig::has_privacy_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TraceConfig_IncidentReportConfig::set_has_privacy_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TraceConfig_IncidentReportConfig::clear_has_privacy_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TraceConfig_IncidentReportConfig::clear_privacy_level() {
  privacy_level_ = 0;
  clear_has_privacy_level();
}
inline ::google::protobuf::int32 TraceConfig_IncidentReportConfig::privacy_level() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.IncidentReportConfig.privacy_level)
  return privacy_level_;
}
inline void TraceConfig_IncidentReportConfig::set_privacy_level(::google::protobuf::int32 value) {
  set_has_privacy_level();
  privacy_level_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.IncidentReportConfig.privacy_level)
}

// optional bool skip_dropbox = 4;
inline bool TraceConfig_IncidentReportConfig::has_skip_dropbox() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TraceConfig_IncidentReportConfig::set_has_skip_dropbox() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TraceConfig_IncidentReportConfig::clear_has_skip_dropbox() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TraceConfig_IncidentReportConfig::clear_skip_dropbox() {
  skip_dropbox_ = false;
  clear_has_skip_dropbox();
}
inline bool TraceConfig_IncidentReportConfig::skip_dropbox() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.IncidentReportConfig.skip_dropbox)
  return skip_dropbox_;
}
inline void TraceConfig_IncidentReportConfig::set_skip_dropbox(bool value) {
  set_has_skip_dropbox();
  skip_dropbox_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.IncidentReportConfig.skip_dropbox)
}

// -------------------------------------------------------------------

// TraceConfig

// repeated .perfetto.protos.TraceConfig.BufferConfig buffers = 1;
inline int TraceConfig::buffers_size() const {
  return buffers_.size();
}
inline void TraceConfig::clear_buffers() {
  buffers_.Clear();
}
inline const ::perfetto::protos::TraceConfig_BufferConfig& TraceConfig::buffers(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.buffers)
  return buffers_.Get(index);
}
inline ::perfetto::protos::TraceConfig_BufferConfig* TraceConfig::mutable_buffers(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.buffers)
  return buffers_.Mutable(index);
}
inline ::perfetto::protos::TraceConfig_BufferConfig* TraceConfig::add_buffers() {
  // @@protoc_insertion_point(field_add:perfetto.protos.TraceConfig.buffers)
  return buffers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_BufferConfig >*
TraceConfig::mutable_buffers() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.TraceConfig.buffers)
  return &buffers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_BufferConfig >&
TraceConfig::buffers() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.TraceConfig.buffers)
  return buffers_;
}

// repeated .perfetto.protos.TraceConfig.DataSource data_sources = 2;
inline int TraceConfig::data_sources_size() const {
  return data_sources_.size();
}
inline void TraceConfig::clear_data_sources() {
  data_sources_.Clear();
}
inline const ::perfetto::protos::TraceConfig_DataSource& TraceConfig::data_sources(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.data_sources)
  return data_sources_.Get(index);
}
inline ::perfetto::protos::TraceConfig_DataSource* TraceConfig::mutable_data_sources(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.data_sources)
  return data_sources_.Mutable(index);
}
inline ::perfetto::protos::TraceConfig_DataSource* TraceConfig::add_data_sources() {
  // @@protoc_insertion_point(field_add:perfetto.protos.TraceConfig.data_sources)
  return data_sources_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_DataSource >*
TraceConfig::mutable_data_sources() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.TraceConfig.data_sources)
  return &data_sources_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_DataSource >&
TraceConfig::data_sources() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.TraceConfig.data_sources)
  return data_sources_;
}

// optional .perfetto.protos.TraceConfig.BuiltinDataSource builtin_data_sources = 20;
inline bool TraceConfig::has_builtin_data_sources() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TraceConfig::set_has_builtin_data_sources() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TraceConfig::clear_has_builtin_data_sources() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TraceConfig::clear_builtin_data_sources() {
  if (builtin_data_sources_ != NULL) builtin_data_sources_->::perfetto::protos::TraceConfig_BuiltinDataSource::Clear();
  clear_has_builtin_data_sources();
}
inline const ::perfetto::protos::TraceConfig_BuiltinDataSource& TraceConfig::builtin_data_sources() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.builtin_data_sources)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return builtin_data_sources_ != NULL ? *builtin_data_sources_ : *default_instance().builtin_data_sources_;
#else
  return builtin_data_sources_ != NULL ? *builtin_data_sources_ : *default_instance_->builtin_data_sources_;
#endif
}
inline ::perfetto::protos::TraceConfig_BuiltinDataSource* TraceConfig::mutable_builtin_data_sources() {
  set_has_builtin_data_sources();
  if (builtin_data_sources_ == NULL) {
    builtin_data_sources_ = new ::perfetto::protos::TraceConfig_BuiltinDataSource;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.builtin_data_sources)
  return builtin_data_sources_;
}
inline ::perfetto::protos::TraceConfig_BuiltinDataSource* TraceConfig::release_builtin_data_sources() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.builtin_data_sources)
  clear_has_builtin_data_sources();
  ::perfetto::protos::TraceConfig_BuiltinDataSource* temp = builtin_data_sources_;
  builtin_data_sources_ = NULL;
  return temp;
}
inline void TraceConfig::set_allocated_builtin_data_sources(::perfetto::protos::TraceConfig_BuiltinDataSource* builtin_data_sources) {
  delete builtin_data_sources_;
  builtin_data_sources_ = builtin_data_sources;
  if (builtin_data_sources) {
    set_has_builtin_data_sources();
  } else {
    clear_has_builtin_data_sources();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.builtin_data_sources)
}

// optional uint32 duration_ms = 3;
inline bool TraceConfig::has_duration_ms() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TraceConfig::set_has_duration_ms() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TraceConfig::clear_has_duration_ms() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TraceConfig::clear_duration_ms() {
  duration_ms_ = 0u;
  clear_has_duration_ms();
}
inline ::google::protobuf::uint32 TraceConfig::duration_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.duration_ms)
  return duration_ms_;
}
inline void TraceConfig::set_duration_ms(::google::protobuf::uint32 value) {
  set_has_duration_ms();
  duration_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.duration_ms)
}

// optional bool enable_extra_guardrails = 4;
inline bool TraceConfig::has_enable_extra_guardrails() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TraceConfig::set_has_enable_extra_guardrails() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TraceConfig::clear_has_enable_extra_guardrails() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TraceConfig::clear_enable_extra_guardrails() {
  enable_extra_guardrails_ = false;
  clear_has_enable_extra_guardrails();
}
inline bool TraceConfig::enable_extra_guardrails() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.enable_extra_guardrails)
  return enable_extra_guardrails_;
}
inline void TraceConfig::set_enable_extra_guardrails(bool value) {
  set_has_enable_extra_guardrails();
  enable_extra_guardrails_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.enable_extra_guardrails)
}

// optional .perfetto.protos.TraceConfig.LockdownModeOperation lockdown_mode = 5;
inline bool TraceConfig::has_lockdown_mode() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TraceConfig::set_has_lockdown_mode() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TraceConfig::clear_has_lockdown_mode() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TraceConfig::clear_lockdown_mode() {
  lockdown_mode_ = 0;
  clear_has_lockdown_mode();
}
inline ::perfetto::protos::TraceConfig_LockdownModeOperation TraceConfig::lockdown_mode() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.lockdown_mode)
  return static_cast< ::perfetto::protos::TraceConfig_LockdownModeOperation >(lockdown_mode_);
}
inline void TraceConfig::set_lockdown_mode(::perfetto::protos::TraceConfig_LockdownModeOperation value) {
  assert(::perfetto::protos::TraceConfig_LockdownModeOperation_IsValid(value));
  set_has_lockdown_mode();
  lockdown_mode_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.lockdown_mode)
}

// repeated .perfetto.protos.TraceConfig.ProducerConfig producers = 6;
inline int TraceConfig::producers_size() const {
  return producers_.size();
}
inline void TraceConfig::clear_producers() {
  producers_.Clear();
}
inline const ::perfetto::protos::TraceConfig_ProducerConfig& TraceConfig::producers(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.producers)
  return producers_.Get(index);
}
inline ::perfetto::protos::TraceConfig_ProducerConfig* TraceConfig::mutable_producers(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.producers)
  return producers_.Mutable(index);
}
inline ::perfetto::protos::TraceConfig_ProducerConfig* TraceConfig::add_producers() {
  // @@protoc_insertion_point(field_add:perfetto.protos.TraceConfig.producers)
  return producers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_ProducerConfig >*
TraceConfig::mutable_producers() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.TraceConfig.producers)
  return &producers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_ProducerConfig >&
TraceConfig::producers() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.TraceConfig.producers)
  return producers_;
}

// optional .perfetto.protos.TraceConfig.StatsdMetadata statsd_metadata = 7;
inline bool TraceConfig::has_statsd_metadata() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TraceConfig::set_has_statsd_metadata() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TraceConfig::clear_has_statsd_metadata() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TraceConfig::clear_statsd_metadata() {
  if (statsd_metadata_ != NULL) statsd_metadata_->::perfetto::protos::TraceConfig_StatsdMetadata::Clear();
  clear_has_statsd_metadata();
}
inline const ::perfetto::protos::TraceConfig_StatsdMetadata& TraceConfig::statsd_metadata() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.statsd_metadata)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return statsd_metadata_ != NULL ? *statsd_metadata_ : *default_instance().statsd_metadata_;
#else
  return statsd_metadata_ != NULL ? *statsd_metadata_ : *default_instance_->statsd_metadata_;
#endif
}
inline ::perfetto::protos::TraceConfig_StatsdMetadata* TraceConfig::mutable_statsd_metadata() {
  set_has_statsd_metadata();
  if (statsd_metadata_ == NULL) {
    statsd_metadata_ = new ::perfetto::protos::TraceConfig_StatsdMetadata;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.statsd_metadata)
  return statsd_metadata_;
}
inline ::perfetto::protos::TraceConfig_StatsdMetadata* TraceConfig::release_statsd_metadata() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.statsd_metadata)
  clear_has_statsd_metadata();
  ::perfetto::protos::TraceConfig_StatsdMetadata* temp = statsd_metadata_;
  statsd_metadata_ = NULL;
  return temp;
}
inline void TraceConfig::set_allocated_statsd_metadata(::perfetto::protos::TraceConfig_StatsdMetadata* statsd_metadata) {
  delete statsd_metadata_;
  statsd_metadata_ = statsd_metadata;
  if (statsd_metadata) {
    set_has_statsd_metadata();
  } else {
    clear_has_statsd_metadata();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.statsd_metadata)
}

// optional bool write_into_file = 8;
inline bool TraceConfig::has_write_into_file() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TraceConfig::set_has_write_into_file() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TraceConfig::clear_has_write_into_file() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TraceConfig::clear_write_into_file() {
  write_into_file_ = false;
  clear_has_write_into_file();
}
inline bool TraceConfig::write_into_file() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.write_into_file)
  return write_into_file_;
}
inline void TraceConfig::set_write_into_file(bool value) {
  set_has_write_into_file();
  write_into_file_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.write_into_file)
}

// optional uint32 file_write_period_ms = 9;
inline bool TraceConfig::has_file_write_period_ms() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TraceConfig::set_has_file_write_period_ms() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TraceConfig::clear_has_file_write_period_ms() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TraceConfig::clear_file_write_period_ms() {
  file_write_period_ms_ = 0u;
  clear_has_file_write_period_ms();
}
inline ::google::protobuf::uint32 TraceConfig::file_write_period_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.file_write_period_ms)
  return file_write_period_ms_;
}
inline void TraceConfig::set_file_write_period_ms(::google::protobuf::uint32 value) {
  set_has_file_write_period_ms();
  file_write_period_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.file_write_period_ms)
}

// optional uint64 max_file_size_bytes = 10;
inline bool TraceConfig::has_max_file_size_bytes() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TraceConfig::set_has_max_file_size_bytes() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TraceConfig::clear_has_max_file_size_bytes() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TraceConfig::clear_max_file_size_bytes() {
  max_file_size_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_max_file_size_bytes();
}
inline ::google::protobuf::uint64 TraceConfig::max_file_size_bytes() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.max_file_size_bytes)
  return max_file_size_bytes_;
}
inline void TraceConfig::set_max_file_size_bytes(::google::protobuf::uint64 value) {
  set_has_max_file_size_bytes();
  max_file_size_bytes_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.max_file_size_bytes)
}

// optional .perfetto.protos.TraceConfig.GuardrailOverrides guardrail_overrides = 11;
inline bool TraceConfig::has_guardrail_overrides() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TraceConfig::set_has_guardrail_overrides() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TraceConfig::clear_has_guardrail_overrides() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TraceConfig::clear_guardrail_overrides() {
  if (guardrail_overrides_ != NULL) guardrail_overrides_->::perfetto::protos::TraceConfig_GuardrailOverrides::Clear();
  clear_has_guardrail_overrides();
}
inline const ::perfetto::protos::TraceConfig_GuardrailOverrides& TraceConfig::guardrail_overrides() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.guardrail_overrides)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return guardrail_overrides_ != NULL ? *guardrail_overrides_ : *default_instance().guardrail_overrides_;
#else
  return guardrail_overrides_ != NULL ? *guardrail_overrides_ : *default_instance_->guardrail_overrides_;
#endif
}
inline ::perfetto::protos::TraceConfig_GuardrailOverrides* TraceConfig::mutable_guardrail_overrides() {
  set_has_guardrail_overrides();
  if (guardrail_overrides_ == NULL) {
    guardrail_overrides_ = new ::perfetto::protos::TraceConfig_GuardrailOverrides;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.guardrail_overrides)
  return guardrail_overrides_;
}
inline ::perfetto::protos::TraceConfig_GuardrailOverrides* TraceConfig::release_guardrail_overrides() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.guardrail_overrides)
  clear_has_guardrail_overrides();
  ::perfetto::protos::TraceConfig_GuardrailOverrides* temp = guardrail_overrides_;
  guardrail_overrides_ = NULL;
  return temp;
}
inline void TraceConfig::set_allocated_guardrail_overrides(::perfetto::protos::TraceConfig_GuardrailOverrides* guardrail_overrides) {
  delete guardrail_overrides_;
  guardrail_overrides_ = guardrail_overrides;
  if (guardrail_overrides) {
    set_has_guardrail_overrides();
  } else {
    clear_has_guardrail_overrides();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.guardrail_overrides)
}

// optional bool deferred_start = 12;
inline bool TraceConfig::has_deferred_start() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TraceConfig::set_has_deferred_start() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TraceConfig::clear_has_deferred_start() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TraceConfig::clear_deferred_start() {
  deferred_start_ = false;
  clear_has_deferred_start();
}
inline bool TraceConfig::deferred_start() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.deferred_start)
  return deferred_start_;
}
inline void TraceConfig::set_deferred_start(bool value) {
  set_has_deferred_start();
  deferred_start_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.deferred_start)
}

// optional uint32 flush_period_ms = 13;
inline bool TraceConfig::has_flush_period_ms() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TraceConfig::set_has_flush_period_ms() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TraceConfig::clear_has_flush_period_ms() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TraceConfig::clear_flush_period_ms() {
  flush_period_ms_ = 0u;
  clear_has_flush_period_ms();
}
inline ::google::protobuf::uint32 TraceConfig::flush_period_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.flush_period_ms)
  return flush_period_ms_;
}
inline void TraceConfig::set_flush_period_ms(::google::protobuf::uint32 value) {
  set_has_flush_period_ms();
  flush_period_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.flush_period_ms)
}

// optional uint32 flush_timeout_ms = 14;
inline bool TraceConfig::has_flush_timeout_ms() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TraceConfig::set_has_flush_timeout_ms() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TraceConfig::clear_has_flush_timeout_ms() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TraceConfig::clear_flush_timeout_ms() {
  flush_timeout_ms_ = 0u;
  clear_has_flush_timeout_ms();
}
inline ::google::protobuf::uint32 TraceConfig::flush_timeout_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.flush_timeout_ms)
  return flush_timeout_ms_;
}
inline void TraceConfig::set_flush_timeout_ms(::google::protobuf::uint32 value) {
  set_has_flush_timeout_ms();
  flush_timeout_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.flush_timeout_ms)
}

// optional uint32 data_source_stop_timeout_ms = 23;
inline bool TraceConfig::has_data_source_stop_timeout_ms() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TraceConfig::set_has_data_source_stop_timeout_ms() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TraceConfig::clear_has_data_source_stop_timeout_ms() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TraceConfig::clear_data_source_stop_timeout_ms() {
  data_source_stop_timeout_ms_ = 0u;
  clear_has_data_source_stop_timeout_ms();
}
inline ::google::protobuf::uint32 TraceConfig::data_source_stop_timeout_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.data_source_stop_timeout_ms)
  return data_source_stop_timeout_ms_;
}
inline void TraceConfig::set_data_source_stop_timeout_ms(::google::protobuf::uint32 value) {
  set_has_data_source_stop_timeout_ms();
  data_source_stop_timeout_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.data_source_stop_timeout_ms)
}

// optional bool notify_traceur = 16;
inline bool TraceConfig::has_notify_traceur() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TraceConfig::set_has_notify_traceur() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TraceConfig::clear_has_notify_traceur() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TraceConfig::clear_notify_traceur() {
  notify_traceur_ = false;
  clear_has_notify_traceur();
}
inline bool TraceConfig::notify_traceur() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.notify_traceur)
  return notify_traceur_;
}
inline void TraceConfig::set_notify_traceur(bool value) {
  set_has_notify_traceur();
  notify_traceur_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.notify_traceur)
}

// optional .perfetto.protos.TraceConfig.TriggerConfig trigger_config = 17;
inline bool TraceConfig::has_trigger_config() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TraceConfig::set_has_trigger_config() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TraceConfig::clear_has_trigger_config() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TraceConfig::clear_trigger_config() {
  if (trigger_config_ != NULL) trigger_config_->::perfetto::protos::TraceConfig_TriggerConfig::Clear();
  clear_has_trigger_config();
}
inline const ::perfetto::protos::TraceConfig_TriggerConfig& TraceConfig::trigger_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.trigger_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return trigger_config_ != NULL ? *trigger_config_ : *default_instance().trigger_config_;
#else
  return trigger_config_ != NULL ? *trigger_config_ : *default_instance_->trigger_config_;
#endif
}
inline ::perfetto::protos::TraceConfig_TriggerConfig* TraceConfig::mutable_trigger_config() {
  set_has_trigger_config();
  if (trigger_config_ == NULL) {
    trigger_config_ = new ::perfetto::protos::TraceConfig_TriggerConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.trigger_config)
  return trigger_config_;
}
inline ::perfetto::protos::TraceConfig_TriggerConfig* TraceConfig::release_trigger_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.trigger_config)
  clear_has_trigger_config();
  ::perfetto::protos::TraceConfig_TriggerConfig* temp = trigger_config_;
  trigger_config_ = NULL;
  return temp;
}
inline void TraceConfig::set_allocated_trigger_config(::perfetto::protos::TraceConfig_TriggerConfig* trigger_config) {
  delete trigger_config_;
  trigger_config_ = trigger_config;
  if (trigger_config) {
    set_has_trigger_config();
  } else {
    clear_has_trigger_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.trigger_config)
}

// repeated string activate_triggers = 18;
inline int TraceConfig::activate_triggers_size() const {
  return activate_triggers_.size();
}
inline void TraceConfig::clear_activate_triggers() {
  activate_triggers_.Clear();
}
inline const ::std::string& TraceConfig::activate_triggers(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.activate_triggers)
  return activate_triggers_.Get(index);
}
inline ::std::string* TraceConfig::mutable_activate_triggers(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.activate_triggers)
  return activate_triggers_.Mutable(index);
}
inline void TraceConfig::set_activate_triggers(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.activate_triggers)
  activate_triggers_.Mutable(index)->assign(value);
}
inline void TraceConfig::set_activate_triggers(int index, const char* value) {
  activate_triggers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.TraceConfig.activate_triggers)
}
inline void TraceConfig::set_activate_triggers(int index, const char* value, size_t size) {
  activate_triggers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.TraceConfig.activate_triggers)
}
inline ::std::string* TraceConfig::add_activate_triggers() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.TraceConfig.activate_triggers)
  return activate_triggers_.Add();
}
inline void TraceConfig::add_activate_triggers(const ::std::string& value) {
  activate_triggers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.TraceConfig.activate_triggers)
}
inline void TraceConfig::add_activate_triggers(const char* value) {
  activate_triggers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.TraceConfig.activate_triggers)
}
inline void TraceConfig::add_activate_triggers(const char* value, size_t size) {
  activate_triggers_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.TraceConfig.activate_triggers)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TraceConfig::activate_triggers() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.TraceConfig.activate_triggers)
  return activate_triggers_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TraceConfig::mutable_activate_triggers() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.TraceConfig.activate_triggers)
  return &activate_triggers_;
}

// optional .perfetto.protos.TraceConfig.IncrementalStateConfig incremental_state_config = 21;
inline bool TraceConfig::has_incremental_state_config() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void TraceConfig::set_has_incremental_state_config() {
  _has_bits_[0] |= 0x00080000u;
}
inline void TraceConfig::clear_has_incremental_state_config() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void TraceConfig::clear_incremental_state_config() {
  if (incremental_state_config_ != NULL) incremental_state_config_->::perfetto::protos::TraceConfig_IncrementalStateConfig::Clear();
  clear_has_incremental_state_config();
}
inline const ::perfetto::protos::TraceConfig_IncrementalStateConfig& TraceConfig::incremental_state_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.incremental_state_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return incremental_state_config_ != NULL ? *incremental_state_config_ : *default_instance().incremental_state_config_;
#else
  return incremental_state_config_ != NULL ? *incremental_state_config_ : *default_instance_->incremental_state_config_;
#endif
}
inline ::perfetto::protos::TraceConfig_IncrementalStateConfig* TraceConfig::mutable_incremental_state_config() {
  set_has_incremental_state_config();
  if (incremental_state_config_ == NULL) {
    incremental_state_config_ = new ::perfetto::protos::TraceConfig_IncrementalStateConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.incremental_state_config)
  return incremental_state_config_;
}
inline ::perfetto::protos::TraceConfig_IncrementalStateConfig* TraceConfig::release_incremental_state_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.incremental_state_config)
  clear_has_incremental_state_config();
  ::perfetto::protos::TraceConfig_IncrementalStateConfig* temp = incremental_state_config_;
  incremental_state_config_ = NULL;
  return temp;
}
inline void TraceConfig::set_allocated_incremental_state_config(::perfetto::protos::TraceConfig_IncrementalStateConfig* incremental_state_config) {
  delete incremental_state_config_;
  incremental_state_config_ = incremental_state_config;
  if (incremental_state_config) {
    set_has_incremental_state_config();
  } else {
    clear_has_incremental_state_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.incremental_state_config)
}

// optional bool allow_user_build_tracing = 19;
inline bool TraceConfig::has_allow_user_build_tracing() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void TraceConfig::set_has_allow_user_build_tracing() {
  _has_bits_[0] |= 0x00100000u;
}
inline void TraceConfig::clear_has_allow_user_build_tracing() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void TraceConfig::clear_allow_user_build_tracing() {
  allow_user_build_tracing_ = false;
  clear_has_allow_user_build_tracing();
}
inline bool TraceConfig::allow_user_build_tracing() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.allow_user_build_tracing)
  return allow_user_build_tracing_;
}
inline void TraceConfig::set_allow_user_build_tracing(bool value) {
  set_has_allow_user_build_tracing();
  allow_user_build_tracing_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.allow_user_build_tracing)
}

// optional string unique_session_name = 22;
inline bool TraceConfig::has_unique_session_name() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void TraceConfig::set_has_unique_session_name() {
  _has_bits_[0] |= 0x00200000u;
}
inline void TraceConfig::clear_has_unique_session_name() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void TraceConfig::clear_unique_session_name() {
  unique_session_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_unique_session_name();
}
inline const ::std::string& TraceConfig::unique_session_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.unique_session_name)
  return unique_session_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TraceConfig::set_unique_session_name(const ::std::string& value) {
  set_has_unique_session_name();
  unique_session_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.unique_session_name)
}
inline void TraceConfig::set_unique_session_name(const char* value) {
  set_has_unique_session_name();
  unique_session_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.TraceConfig.unique_session_name)
}
inline void TraceConfig::set_unique_session_name(const char* value, size_t size) {
  set_has_unique_session_name();
  unique_session_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.TraceConfig.unique_session_name)
}
inline ::std::string* TraceConfig::mutable_unique_session_name() {
  set_has_unique_session_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.unique_session_name)
  return unique_session_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TraceConfig::release_unique_session_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.unique_session_name)
  clear_has_unique_session_name();
  return unique_session_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TraceConfig::set_allocated_unique_session_name(::std::string* unique_session_name) {
  if (unique_session_name != NULL) {
    set_has_unique_session_name();
  } else {
    clear_has_unique_session_name();
  }
  unique_session_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), unique_session_name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.unique_session_name)
}

// optional .perfetto.protos.TraceConfig.CompressionType compression_type = 24;
inline bool TraceConfig::has_compression_type() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void TraceConfig::set_has_compression_type() {
  _has_bits_[0] |= 0x00400000u;
}
inline void TraceConfig::clear_has_compression_type() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void TraceConfig::clear_compression_type() {
  compression_type_ = 0;
  clear_has_compression_type();
}
inline ::perfetto::protos::TraceConfig_CompressionType TraceConfig::compression_type() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.compression_type)
  return static_cast< ::perfetto::protos::TraceConfig_CompressionType >(compression_type_);
}
inline void TraceConfig::set_compression_type(::perfetto::protos::TraceConfig_CompressionType value) {
  assert(::perfetto::protos::TraceConfig_CompressionType_IsValid(value));
  set_has_compression_type();
  compression_type_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.compression_type)
}

// optional .perfetto.protos.TraceConfig.IncidentReportConfig incident_report_config = 25;
inline bool TraceConfig::has_incident_report_config() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void TraceConfig::set_has_incident_report_config() {
  _has_bits_[0] |= 0x00800000u;
}
inline void TraceConfig::clear_has_incident_report_config() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void TraceConfig::clear_incident_report_config() {
  if (incident_report_config_ != NULL) incident_report_config_->::perfetto::protos::TraceConfig_IncidentReportConfig::Clear();
  clear_has_incident_report_config();
}
inline const ::perfetto::protos::TraceConfig_IncidentReportConfig& TraceConfig::incident_report_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.incident_report_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return incident_report_config_ != NULL ? *incident_report_config_ : *default_instance().incident_report_config_;
#else
  return incident_report_config_ != NULL ? *incident_report_config_ : *default_instance_->incident_report_config_;
#endif
}
inline ::perfetto::protos::TraceConfig_IncidentReportConfig* TraceConfig::mutable_incident_report_config() {
  set_has_incident_report_config();
  if (incident_report_config_ == NULL) {
    incident_report_config_ = new ::perfetto::protos::TraceConfig_IncidentReportConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.incident_report_config)
  return incident_report_config_;
}
inline ::perfetto::protos::TraceConfig_IncidentReportConfig* TraceConfig::release_incident_report_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.incident_report_config)
  clear_has_incident_report_config();
  ::perfetto::protos::TraceConfig_IncidentReportConfig* temp = incident_report_config_;
  incident_report_config_ = NULL;
  return temp;
}
inline void TraceConfig::set_allocated_incident_report_config(::perfetto::protos::TraceConfig_IncidentReportConfig* incident_report_config) {
  delete incident_report_config_;
  incident_report_config_ = incident_report_config;
  if (incident_report_config) {
    set_has_incident_report_config();
  } else {
    clear_has_incident_report_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.incident_report_config)
}

// optional bytes trace_uuid = 26;
inline bool TraceConfig::has_trace_uuid() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void TraceConfig::set_has_trace_uuid() {
  _has_bits_[0] |= 0x01000000u;
}
inline void TraceConfig::clear_has_trace_uuid() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void TraceConfig::clear_trace_uuid() {
  trace_uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_trace_uuid();
}
inline const ::std::string& TraceConfig::trace_uuid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.trace_uuid)
  return trace_uuid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TraceConfig::set_trace_uuid(const ::std::string& value) {
  set_has_trace_uuid();
  trace_uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.trace_uuid)
}
inline void TraceConfig::set_trace_uuid(const char* value) {
  set_has_trace_uuid();
  trace_uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.TraceConfig.trace_uuid)
}
inline void TraceConfig::set_trace_uuid(const void* value, size_t size) {
  set_has_trace_uuid();
  trace_uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.TraceConfig.trace_uuid)
}
inline ::std::string* TraceConfig::mutable_trace_uuid() {
  set_has_trace_uuid();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.trace_uuid)
  return trace_uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TraceConfig::release_trace_uuid() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.trace_uuid)
  clear_has_trace_uuid();
  return trace_uuid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TraceConfig::set_allocated_trace_uuid(::std::string* trace_uuid) {
  if (trace_uuid != NULL) {
    set_has_trace_uuid();
  } else {
    clear_has_trace_uuid();
  }
  trace_uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), trace_uuid);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.trace_uuid)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::perfetto::protos::TraceConfig_BufferConfig_FillPolicy> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::perfetto::protos::TraceConfig_TriggerConfig_TriggerMode> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::perfetto::protos::TraceConfig_LockdownModeOperation> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::perfetto::protos::TraceConfig_CompressionType> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2fconfig_2ftrace_5fconfig_2eproto__INCLUDED
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/ipc/consumer_port.proto

#ifndef PROTOBUF_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// gen_amalgamated expanded: #include "protos/perfetto/common/observable_events.pb.h"
// gen_amalgamated expanded: #include "protos/perfetto/common/tracing_service_state.pb.h"
// gen_amalgamated expanded: #include "protos/perfetto/common/trace_stats.pb.h"
// gen_amalgamated expanded: #include "protos/perfetto/config/trace_config.pb.h"
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();

class AttachRequest;
class AttachResponse;
class ChangeTraceConfigRequest;
class ChangeTraceConfigResponse;
class DetachRequest;
class DetachResponse;
class DisableTracingRequest;
class DisableTracingResponse;
class EnableTracingRequest;
class EnableTracingResponse;
class FlushRequest;
class FlushResponse;
class FreeBuffersRequest;
class FreeBuffersResponse;
class GetTraceStatsRequest;
class GetTraceStatsResponse;
class ObserveEventsRequest;
class ObserveEventsResponse;
class QueryServiceStateRequest;
class QueryServiceStateResponse;
class ReadBuffersRequest;
class ReadBuffersResponse;
class ReadBuffersResponse_Slice;
class StartTracingRequest;
class StartTracingResponse;

// ===================================================================

class EnableTracingRequest : public ::google::protobuf::MessageLite {
 public:
  EnableTracingRequest();
  virtual ~EnableTracingRequest();

  EnableTracingRequest(const EnableTracingRequest& from);

  inline EnableTracingRequest& operator=(const EnableTracingRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const EnableTracingRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EnableTracingRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EnableTracingRequest* other);

  // implements Message ----------------------------------------------

  inline EnableTracingRequest* New() const { return New(NULL); }

  EnableTracingRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EnableTracingRequest& from);
  void MergeFrom(const EnableTracingRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EnableTracingRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .perfetto.protos.TraceConfig trace_config = 1;
  bool has_trace_config() const;
  void clear_trace_config();
  static const int kTraceConfigFieldNumber = 1;
  const ::perfetto::protos::TraceConfig& trace_config() const;
  ::perfetto::protos::TraceConfig* mutable_trace_config();
  ::perfetto::protos::TraceConfig* release_trace_config();
  void set_allocated_trace_config(::perfetto::protos::TraceConfig* trace_config);

  // optional bool attach_notification_only = 2;
  bool has_attach_notification_only() const;
  void clear_attach_notification_only();
  static const int kAttachNotificationOnlyFieldNumber = 2;
  bool attach_notification_only() const;
  void set_attach_notification_only(bool value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.EnableTracingRequest)
 private:
  inline void set_has_trace_config();
  inline void clear_has_trace_config();
  inline void set_has_attach_notification_only();
  inline void clear_has_attach_notification_only();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::perfetto::protos::TraceConfig* trace_config_;
  bool attach_notification_only_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static EnableTracingRequest* default_instance_;
};
// -------------------------------------------------------------------

class EnableTracingResponse : public ::google::protobuf::MessageLite {
 public:
  EnableTracingResponse();
  virtual ~EnableTracingResponse();

  EnableTracingResponse(const EnableTracingResponse& from);

  inline EnableTracingResponse& operator=(const EnableTracingResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const EnableTracingResponse& default_instance();

  enum StateCase {
    kDisabled = 1,
    STATE_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EnableTracingResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EnableTracingResponse* other);

  // implements Message ----------------------------------------------

  inline EnableTracingResponse* New() const { return New(NULL); }

  EnableTracingResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EnableTracingResponse& from);
  void MergeFrom(const EnableTracingResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EnableTracingResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool disabled = 1;
  bool has_disabled() const;
  void clear_disabled();
  static const int kDisabledFieldNumber = 1;
  bool disabled() const;
  void set_disabled(bool value);

  StateCase state_case() const;
  // @@protoc_insertion_point(class_scope:perfetto.protos.EnableTracingResponse)
 private:
  inline void set_has_disabled();

  inline bool has_state() const;
  void clear_state();
  inline void clear_has_state();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union StateUnion {
    StateUnion() {}
    bool disabled_;
  } state_;
  ::google::protobuf::uint32 _oneof_case_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static EnableTracingResponse* default_instance_;
};
// -------------------------------------------------------------------

class StartTracingRequest : public ::google::protobuf::MessageLite {
 public:
  StartTracingRequest();
  virtual ~StartTracingRequest();

  StartTracingRequest(const StartTracingRequest& from);

  inline StartTracingRequest& operator=(const StartTracingRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const StartTracingRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StartTracingRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StartTracingRequest* other);

  // implements Message ----------------------------------------------

  inline StartTracingRequest* New() const { return New(NULL); }

  StartTracingRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StartTracingRequest& from);
  void MergeFrom(const StartTracingRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StartTracingRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.StartTracingRequest)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static StartTracingRequest* default_instance_;
};
// -------------------------------------------------------------------

class StartTracingResponse : public ::google::protobuf::MessageLite {
 public:
  StartTracingResponse();
  virtual ~StartTracingResponse();

  StartTracingResponse(const StartTracingResponse& from);

  inline StartTracingResponse& operator=(const StartTracingResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const StartTracingResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StartTracingResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StartTracingResponse* other);

  // implements Message ----------------------------------------------

  inline StartTracingResponse* New() const { return New(NULL); }

  StartTracingResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StartTracingResponse& from);
  void MergeFrom(const StartTracingResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StartTracingResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.StartTracingResponse)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static StartTracingResponse* default_instance_;
};
// -------------------------------------------------------------------

class ChangeTraceConfigRequest : public ::google::protobuf::MessageLite {
 public:
  ChangeTraceConfigRequest();
  virtual ~ChangeTraceConfigRequest();

  ChangeTraceConfigRequest(const ChangeTraceConfigRequest& from);

  inline ChangeTraceConfigRequest& operator=(const ChangeTraceConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ChangeTraceConfigRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ChangeTraceConfigRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ChangeTraceConfigRequest* other);

  // implements Message ----------------------------------------------

  inline ChangeTraceConfigRequest* New() const { return New(NULL); }

  ChangeTraceConfigRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChangeTraceConfigRequest& from);
  void MergeFrom(const ChangeTraceConfigRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChangeTraceConfigRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .perfetto.protos.TraceConfig trace_config = 1;
  bool has_trace_config() const;
  void clear_trace_config();
  static const int kTraceConfigFieldNumber = 1;
  const ::perfetto::protos::TraceConfig& trace_config() const;
  ::perfetto::protos::TraceConfig* mutable_trace_config();
  ::perfetto::protos::TraceConfig* release_trace_config();
  void set_allocated_trace_config(::perfetto::protos::TraceConfig* trace_config);

  // @@protoc_insertion_point(class_scope:perfetto.protos.ChangeTraceConfigRequest)
 private:
  inline void set_has_trace_config();
  inline void clear_has_trace_config();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::perfetto::protos::TraceConfig* trace_config_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static ChangeTraceConfigRequest* default_instance_;
};
// -------------------------------------------------------------------

class ChangeTraceConfigResponse : public ::google::protobuf::MessageLite {
 public:
  ChangeTraceConfigResponse();
  virtual ~ChangeTraceConfigResponse();

  ChangeTraceConfigResponse(const ChangeTraceConfigResponse& from);

  inline ChangeTraceConfigResponse& operator=(const ChangeTraceConfigResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ChangeTraceConfigResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ChangeTraceConfigResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ChangeTraceConfigResponse* other);

  // implements Message ----------------------------------------------

  inline ChangeTraceConfigResponse* New() const { return New(NULL); }

  ChangeTraceConfigResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChangeTraceConfigResponse& from);
  void MergeFrom(const ChangeTraceConfigResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChangeTraceConfigResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.ChangeTraceConfigResponse)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static ChangeTraceConfigResponse* default_instance_;
};
// -------------------------------------------------------------------

class DisableTracingRequest : public ::google::protobuf::MessageLite {
 public:
  DisableTracingRequest();
  virtual ~DisableTracingRequest();

  DisableTracingRequest(const DisableTracingRequest& from);

  inline DisableTracingRequest& operator=(const DisableTracingRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const DisableTracingRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DisableTracingRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DisableTracingRequest* other);

  // implements Message ----------------------------------------------

  inline DisableTracingRequest* New() const { return New(NULL); }

  DisableTracingRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DisableTracingRequest& from);
  void MergeFrom(const DisableTracingRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DisableTracingRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.DisableTracingRequest)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static DisableTracingRequest* default_instance_;
};
// -------------------------------------------------------------------

class DisableTracingResponse : public ::google::protobuf::MessageLite {
 public:
  DisableTracingResponse();
  virtual ~DisableTracingResponse();

  DisableTracingResponse(const DisableTracingResponse& from);

  inline DisableTracingResponse& operator=(const DisableTracingResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const DisableTracingResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DisableTracingResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DisableTracingResponse* other);

  // implements Message ----------------------------------------------

  inline DisableTracingResponse* New() const { return New(NULL); }

  DisableTracingResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DisableTracingResponse& from);
  void MergeFrom(const DisableTracingResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DisableTracingResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.DisableTracingResponse)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static DisableTracingResponse* default_instance_;
};
// -------------------------------------------------------------------

class ReadBuffersRequest : public ::google::protobuf::MessageLite {
 public:
  ReadBuffersRequest();
  virtual ~ReadBuffersRequest();

  ReadBuffersRequest(const ReadBuffersRequest& from);

  inline ReadBuffersRequest& operator=(const ReadBuffersRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ReadBuffersRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReadBuffersRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReadBuffersRequest* other);

  // implements Message ----------------------------------------------

  inline ReadBuffersRequest* New() const { return New(NULL); }

  ReadBuffersRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReadBuffersRequest& from);
  void MergeFrom(const ReadBuffersRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReadBuffersRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.ReadBuffersRequest)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static ReadBuffersRequest* default_instance_;
};
// -------------------------------------------------------------------

class ReadBuffersResponse_Slice : public ::google::protobuf::MessageLite {
 public:
  ReadBuffersResponse_Slice();
  virtual ~ReadBuffersResponse_Slice();

  ReadBuffersResponse_Slice(const ReadBuffersResponse_Slice& from);

  inline ReadBuffersResponse_Slice& operator=(const ReadBuffersResponse_Slice& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ReadBuffersResponse_Slice& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReadBuffersResponse_Slice* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReadBuffersResponse_Slice* other);

  // implements Message ----------------------------------------------

  inline ReadBuffersResponse_Slice* New() const { return New(NULL); }

  ReadBuffersResponse_Slice* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReadBuffersResponse_Slice& from);
  void MergeFrom(const ReadBuffersResponse_Slice& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReadBuffersResponse_Slice* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes data = 1;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 1;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // optional bool last_slice_for_packet = 2;
  bool has_last_slice_for_packet() const;
  void clear_last_slice_for_packet();
  static const int kLastSliceForPacketFieldNumber = 2;
  bool last_slice_for_packet() const;
  void set_last_slice_for_packet(bool value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.ReadBuffersResponse.Slice)
 private:
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_last_slice_for_packet();
  inline void clear_has_last_slice_for_packet();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  bool last_slice_for_packet_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static ReadBuffersResponse_Slice* default_instance_;
};
// -------------------------------------------------------------------

class ReadBuffersResponse : public ::google::protobuf::MessageLite {
 public:
  ReadBuffersResponse();
  virtual ~ReadBuffersResponse();

  ReadBuffersResponse(const ReadBuffersResponse& from);

  inline ReadBuffersResponse& operator=(const ReadBuffersResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ReadBuffersResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReadBuffersResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReadBuffersResponse* other);

  // implements Message ----------------------------------------------

  inline ReadBuffersResponse* New() const { return New(NULL); }

  ReadBuffersResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReadBuffersResponse& from);
  void MergeFrom(const ReadBuffersResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReadBuffersResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ReadBuffersResponse_Slice Slice;

  // accessors -------------------------------------------------------

  // repeated .perfetto.protos.ReadBuffersResponse.Slice slices = 2;
  int slices_size() const;
  void clear_slices();
  static const int kSlicesFieldNumber = 2;
  const ::perfetto::protos::ReadBuffersResponse_Slice& slices(int index) const;
  ::perfetto::protos::ReadBuffersResponse_Slice* mutable_slices(int index);
  ::perfetto::protos::ReadBuffersResponse_Slice* add_slices();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::ReadBuffersResponse_Slice >*
      mutable_slices();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::ReadBuffersResponse_Slice >&
      slices() const;

  // @@protoc_insertion_point(class_scope:perfetto.protos.ReadBuffersResponse)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::ReadBuffersResponse_Slice > slices_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static ReadBuffersResponse* default_instance_;
};
// -------------------------------------------------------------------

class FreeBuffersRequest : public ::google::protobuf::MessageLite {
 public:
  FreeBuffersRequest();
  virtual ~FreeBuffersRequest();

  FreeBuffersRequest(const FreeBuffersRequest& from);

  inline FreeBuffersRequest& operator=(const FreeBuffersRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const FreeBuffersRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FreeBuffersRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FreeBuffersRequest* other);

  // implements Message ----------------------------------------------

  inline FreeBuffersRequest* New() const { return New(NULL); }

  FreeBuffersRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FreeBuffersRequest& from);
  void MergeFrom(const FreeBuffersRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FreeBuffersRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 buffer_ids = 1;
  int buffer_ids_size() const;
  void clear_buffer_ids();
  static const int kBufferIdsFieldNumber = 1;
  ::google::protobuf::uint32 buffer_ids(int index) const;
  void set_buffer_ids(int index, ::google::protobuf::uint32 value);
  void add_buffer_ids(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      buffer_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_buffer_ids();

  // @@protoc_insertion_point(class_scope:perfetto.protos.FreeBuffersRequest)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > buffer_ids_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static FreeBuffersRequest* default_instance_;
};
// -------------------------------------------------------------------

class FreeBuffersResponse : public ::google::protobuf::MessageLite {
 public:
  FreeBuffersResponse();
  virtual ~FreeBuffersResponse();

  FreeBuffersResponse(const FreeBuffersResponse& from);

  inline FreeBuffersResponse& operator=(const FreeBuffersResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const FreeBuffersResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FreeBuffersResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FreeBuffersResponse* other);

  // implements Message ----------------------------------------------

  inline FreeBuffersResponse* New() const { return New(NULL); }

  FreeBuffersResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FreeBuffersResponse& from);
  void MergeFrom(const FreeBuffersResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FreeBuffersResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.FreeBuffersResponse)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static FreeBuffersResponse* default_instance_;
};
// -------------------------------------------------------------------

class FlushRequest : public ::google::protobuf::MessageLite {
 public:
  FlushRequest();
  virtual ~FlushRequest();

  FlushRequest(const FlushRequest& from);

  inline FlushRequest& operator=(const FlushRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const FlushRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FlushRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FlushRequest* other);

  // implements Message ----------------------------------------------

  inline FlushRequest* New() const { return New(NULL); }

  FlushRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FlushRequest& from);
  void MergeFrom(const FlushRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FlushRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 timeout_ms = 1;
  bool has_timeout_ms() const;
  void clear_timeout_ms();
  static const int kTimeoutMsFieldNumber = 1;
  ::google::protobuf::uint32 timeout_ms() const;
  void set_timeout_ms(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.FlushRequest)
 private:
  inline void set_has_timeout_ms();
  inline void clear_has_timeout_ms();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 timeout_ms_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static FlushRequest* default_instance_;
};
// -------------------------------------------------------------------

class FlushResponse : public ::google::protobuf::MessageLite {
 public:
  FlushResponse();
  virtual ~FlushResponse();

  FlushResponse(const FlushResponse& from);

  inline FlushResponse& operator=(const FlushResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const FlushResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FlushResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FlushResponse* other);

  // implements Message ----------------------------------------------

  inline FlushResponse* New() const { return New(NULL); }

  FlushResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FlushResponse& from);
  void MergeFrom(const FlushResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FlushResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.FlushResponse)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static FlushResponse* default_instance_;
};
// -------------------------------------------------------------------

class DetachRequest : public ::google::protobuf::MessageLite {
 public:
  DetachRequest();
  virtual ~DetachRequest();

  DetachRequest(const DetachRequest& from);

  inline DetachRequest& operator=(const DetachRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const DetachRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DetachRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DetachRequest* other);

  // implements Message ----------------------------------------------

  inline DetachRequest* New() const { return New(NULL); }

  DetachRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DetachRequest& from);
  void MergeFrom(const DetachRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DetachRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:perfetto.protos.DetachRequest)
 private:
  inline void set_has_key();
  inline void clear_has_key();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static DetachRequest* default_instance_;
};
// -------------------------------------------------------------------

class DetachResponse : public ::google::protobuf::MessageLite {
 public:
  DetachResponse();
  virtual ~DetachResponse();

  DetachResponse(const DetachResponse& from);

  inline DetachResponse& operator=(const DetachResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const DetachResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DetachResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DetachResponse* other);

  // implements Message ----------------------------------------------

  inline DetachResponse* New() const { return New(NULL); }

  DetachResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DetachResponse& from);
  void MergeFrom(const DetachResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DetachResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.DetachResponse)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static DetachResponse* default_instance_;
};
// -------------------------------------------------------------------

class AttachRequest : public ::google::protobuf::MessageLite {
 public:
  AttachRequest();
  virtual ~AttachRequest();

  AttachRequest(const AttachRequest& from);

  inline AttachRequest& operator=(const AttachRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const AttachRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AttachRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AttachRequest* other);

  // implements Message ----------------------------------------------

  inline AttachRequest* New() const { return New(NULL); }

  AttachRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AttachRequest& from);
  void MergeFrom(const AttachRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AttachRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:perfetto.protos.AttachRequest)
 private:
  inline void set_has_key();
  inline void clear_has_key();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static AttachRequest* default_instance_;
};
// -------------------------------------------------------------------

class AttachResponse : public ::google::protobuf::MessageLite {
 public:
  AttachResponse();
  virtual ~AttachResponse();

  AttachResponse(const AttachResponse& from);

  inline AttachResponse& operator=(const AttachResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const AttachResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AttachResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AttachResponse* other);

  // implements Message ----------------------------------------------

  inline AttachResponse* New() const { return New(NULL); }

  AttachResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AttachResponse& from);
  void MergeFrom(const AttachResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AttachResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .perfetto.protos.TraceConfig trace_config = 1;
  bool has_trace_config() const;
  void clear_trace_config();
  static const int kTraceConfigFieldNumber = 1;
  const ::perfetto::protos::TraceConfig& trace_config() const;
  ::perfetto::protos::TraceConfig* mutable_trace_config();
  ::perfetto::protos::TraceConfig* release_trace_config();
  void set_allocated_trace_config(::perfetto::protos::TraceConfig* trace_config);

  // @@protoc_insertion_point(class_scope:perfetto.protos.AttachResponse)
 private:
  inline void set_has_trace_config();
  inline void clear_has_trace_config();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::perfetto::protos::TraceConfig* trace_config_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static AttachResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetTraceStatsRequest : public ::google::protobuf::MessageLite {
 public:
  GetTraceStatsRequest();
  virtual ~GetTraceStatsRequest();

  GetTraceStatsRequest(const GetTraceStatsRequest& from);

  inline GetTraceStatsRequest& operator=(const GetTraceStatsRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const GetTraceStatsRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetTraceStatsRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetTraceStatsRequest* other);

  // implements Message ----------------------------------------------

  inline GetTraceStatsRequest* New() const { return New(NULL); }

  GetTraceStatsRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetTraceStatsRequest& from);
  void MergeFrom(const GetTraceStatsRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetTraceStatsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.GetTraceStatsRequest)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static GetTraceStatsRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetTraceStatsResponse : public ::google::protobuf::MessageLite {
 public:
  GetTraceStatsResponse();
  virtual ~GetTraceStatsResponse();

  GetTraceStatsResponse(const GetTraceStatsResponse& from);

  inline GetTraceStatsResponse& operator=(const GetTraceStatsResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const GetTraceStatsResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetTraceStatsResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetTraceStatsResponse* other);

  // implements Message ----------------------------------------------

  inline GetTraceStatsResponse* New() const { return New(NULL); }

  GetTraceStatsResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetTraceStatsResponse& from);
  void MergeFrom(const GetTraceStatsResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetTraceStatsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .perfetto.protos.TraceStats trace_stats = 1;
  bool has_trace_stats() const;
  void clear_trace_stats();
  static const int kTraceStatsFieldNumber = 1;
  const ::perfetto::protos::TraceStats& trace_stats() const;
  ::perfetto::protos::TraceStats* mutable_trace_stats();
  ::perfetto::protos::TraceStats* release_trace_stats();
  void set_allocated_trace_stats(::perfetto::protos::TraceStats* trace_stats);

  // @@protoc_insertion_point(class_scope:perfetto.protos.GetTraceStatsResponse)
 private:
  inline void set_has_trace_stats();
  inline void clear_has_trace_stats();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::perfetto::protos::TraceStats* trace_stats_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static GetTraceStatsResponse* default_instance_;
};
// -------------------------------------------------------------------

class ObserveEventsRequest : public ::google::protobuf::MessageLite {
 public:
  ObserveEventsRequest();
  virtual ~ObserveEventsRequest();

  ObserveEventsRequest(const ObserveEventsRequest& from);

  inline ObserveEventsRequest& operator=(const ObserveEventsRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ObserveEventsRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ObserveEventsRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ObserveEventsRequest* other);

  // implements Message ----------------------------------------------

  inline ObserveEventsRequest* New() const { return New(NULL); }

  ObserveEventsRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ObserveEventsRequest& from);
  void MergeFrom(const ObserveEventsRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ObserveEventsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .perfetto.protos.ObservableEvents.Type events_to_observe = 1;
  int events_to_observe_size() const;
  void clear_events_to_observe();
  static const int kEventsToObserveFieldNumber = 1;
  ::perfetto::protos::ObservableEvents_Type events_to_observe(int index) const;
  void set_events_to_observe(int index, ::perfetto::protos::ObservableEvents_Type value);
  void add_events_to_observe(::perfetto::protos::ObservableEvents_Type value);
  const ::google::protobuf::RepeatedField<int>& events_to_observe() const;
  ::google::protobuf::RepeatedField<int>* mutable_events_to_observe();

  // @@protoc_insertion_point(class_scope:perfetto.protos.ObserveEventsRequest)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField<int> events_to_observe_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static ObserveEventsRequest* default_instance_;
};
// -------------------------------------------------------------------

class ObserveEventsResponse : public ::google::protobuf::MessageLite {
 public:
  ObserveEventsResponse();
  virtual ~ObserveEventsResponse();

  ObserveEventsResponse(const ObserveEventsResponse& from);

  inline ObserveEventsResponse& operator=(const ObserveEventsResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ObserveEventsResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ObserveEventsResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ObserveEventsResponse* other);

  // implements Message ----------------------------------------------

  inline ObserveEventsResponse* New() const { return New(NULL); }

  ObserveEventsResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ObserveEventsResponse& from);
  void MergeFrom(const ObserveEventsResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ObserveEventsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .perfetto.protos.ObservableEvents events = 1;
  bool has_events() const;
  void clear_events();
  static const int kEventsFieldNumber = 1;
  const ::perfetto::protos::ObservableEvents& events() const;
  ::perfetto::protos::ObservableEvents* mutable_events();
  ::perfetto::protos::ObservableEvents* release_events();
  void set_allocated_events(::perfetto::protos::ObservableEvents* events);

  // @@protoc_insertion_point(class_scope:perfetto.protos.ObserveEventsResponse)
 private:
  inline void set_has_events();
  inline void clear_has_events();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::perfetto::protos::ObservableEvents* events_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static ObserveEventsResponse* default_instance_;
};
// -------------------------------------------------------------------

class QueryServiceStateRequest : public ::google::protobuf::MessageLite {
 public:
  QueryServiceStateRequest();
  virtual ~QueryServiceStateRequest();

  QueryServiceStateRequest(const QueryServiceStateRequest& from);

  inline QueryServiceStateRequest& operator=(const QueryServiceStateRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const QueryServiceStateRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const QueryServiceStateRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(QueryServiceStateRequest* other);

  // implements Message ----------------------------------------------

  inline QueryServiceStateRequest* New() const { return New(NULL); }

  QueryServiceStateRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const QueryServiceStateRequest& from);
  void MergeFrom(const QueryServiceStateRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(QueryServiceStateRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.QueryServiceStateRequest)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static QueryServiceStateRequest* default_instance_;
};
// -------------------------------------------------------------------

class QueryServiceStateResponse : public ::google::protobuf::MessageLite {
 public:
  QueryServiceStateResponse();
  virtual ~QueryServiceStateResponse();

  QueryServiceStateResponse(const QueryServiceStateResponse& from);

  inline QueryServiceStateResponse& operator=(const QueryServiceStateResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const QueryServiceStateResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const QueryServiceStateResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(QueryServiceStateResponse* other);

  // implements Message ----------------------------------------------

  inline QueryServiceStateResponse* New() const { return New(NULL); }

  QueryServiceStateResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const QueryServiceStateResponse& from);
  void MergeFrom(const QueryServiceStateResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(QueryServiceStateResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .perfetto.protos.TracingServiceState service_state = 1;
  bool has_service_state() const;
  void clear_service_state();
  static const int kServiceStateFieldNumber = 1;
  const ::perfetto::protos::TracingServiceState& service_state() const;
  ::perfetto::protos::TracingServiceState* mutable_service_state();
  ::perfetto::protos::TracingServiceState* release_service_state();
  void set_allocated_service_state(::perfetto::protos::TracingServiceState* service_state);

  // @@protoc_insertion_point(class_scope:perfetto.protos.QueryServiceStateResponse)
 private:
  inline void set_has_service_state();
  inline void clear_has_service_state();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::perfetto::protos::TracingServiceState* service_state_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static QueryServiceStateResponse* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// EnableTracingRequest

// optional .perfetto.protos.TraceConfig trace_config = 1;
inline bool EnableTracingRequest::has_trace_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnableTracingRequest::set_has_trace_config() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnableTracingRequest::clear_has_trace_config() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnableTracingRequest::clear_trace_config() {
  if (trace_config_ != NULL) trace_config_->::perfetto::protos::TraceConfig::Clear();
  clear_has_trace_config();
}
inline const ::perfetto::protos::TraceConfig& EnableTracingRequest::trace_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.EnableTracingRequest.trace_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return trace_config_ != NULL ? *trace_config_ : *default_instance().trace_config_;
#else
  return trace_config_ != NULL ? *trace_config_ : *default_instance_->trace_config_;
#endif
}
inline ::perfetto::protos::TraceConfig* EnableTracingRequest::mutable_trace_config() {
  set_has_trace_config();
  if (trace_config_ == NULL) {
    trace_config_ = new ::perfetto::protos::TraceConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.EnableTracingRequest.trace_config)
  return trace_config_;
}
inline ::perfetto::protos::TraceConfig* EnableTracingRequest::release_trace_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.EnableTracingRequest.trace_config)
  clear_has_trace_config();
  ::perfetto::protos::TraceConfig* temp = trace_config_;
  trace_config_ = NULL;
  return temp;
}
inline void EnableTracingRequest::set_allocated_trace_config(::perfetto::protos::TraceConfig* trace_config) {
  delete trace_config_;
  trace_config_ = trace_config;
  if (trace_config) {
    set_has_trace_config();
  } else {
    clear_has_trace_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.EnableTracingRequest.trace_config)
}

// optional bool attach_notification_only = 2;
inline bool EnableTracingRequest::has_attach_notification_only() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnableTracingRequest::set_has_attach_notification_only() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnableTracingRequest::clear_has_attach_notification_only() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnableTracingRequest::clear_attach_notification_only() {
  attach_notification_only_ = false;
  clear_has_attach_notification_only();
}
inline bool EnableTracingRequest::attach_notification_only() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.EnableTracingRequest.attach_notification_only)
  return attach_notification_only_;
}
inline void EnableTracingRequest::set_attach_notification_only(bool value) {
  set_has_attach_notification_only();
  attach_notification_only_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.EnableTracingRequest.attach_notification_only)
}

// -------------------------------------------------------------------

// EnableTracingResponse

// optional bool disabled = 1;
inline bool EnableTracingResponse::has_disabled() const {
  return state_case() == kDisabled;
}
inline void EnableTracingResponse::set_has_disabled() {
  _oneof_case_[0] = kDisabled;
}
inline void EnableTracingResponse::clear_disabled() {
  if (has_disabled()) {
    state_.disabled_ = false;
    clear_has_state();
  }
}
inline bool EnableTracingResponse::disabled() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.EnableTracingResponse.disabled)
  if (has_disabled()) {
    return state_.disabled_;
  }
  return false;
}
inline void EnableTracingResponse::set_disabled(bool value) {
  if (!has_disabled()) {
    clear_state();
    set_has_disabled();
  }
  state_.disabled_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.EnableTracingResponse.disabled)
}

inline bool EnableTracingResponse::has_state() const {
  return state_case() != STATE_NOT_SET;
}
inline void EnableTracingResponse::clear_has_state() {
  _oneof_case_[0] = STATE_NOT_SET;
}
inline EnableTracingResponse::StateCase EnableTracingResponse::state_case() const {
  return EnableTracingResponse::StateCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// StartTracingRequest

// -------------------------------------------------------------------

// StartTracingResponse

// -------------------------------------------------------------------

// ChangeTraceConfigRequest

// optional .perfetto.protos.TraceConfig trace_config = 1;
inline bool ChangeTraceConfigRequest::has_trace_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangeTraceConfigRequest::set_has_trace_config() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangeTraceConfigRequest::clear_has_trace_config() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangeTraceConfigRequest::clear_trace_config() {
  if (trace_config_ != NULL) trace_config_->::perfetto::protos::TraceConfig::Clear();
  clear_has_trace_config();
}
inline const ::perfetto::protos::TraceConfig& ChangeTraceConfigRequest::trace_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ChangeTraceConfigRequest.trace_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return trace_config_ != NULL ? *trace_config_ : *default_instance().trace_config_;
#else
  return trace_config_ != NULL ? *trace_config_ : *default_instance_->trace_config_;
#endif
}
inline ::perfetto::protos::TraceConfig* ChangeTraceConfigRequest::mutable_trace_config() {
  set_has_trace_config();
  if (trace_config_ == NULL) {
    trace_config_ = new ::perfetto::protos::TraceConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.ChangeTraceConfigRequest.trace_config)
  return trace_config_;
}
inline ::perfetto::protos::TraceConfig* ChangeTraceConfigRequest::release_trace_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.ChangeTraceConfigRequest.trace_config)
  clear_has_trace_config();
  ::perfetto::protos::TraceConfig* temp = trace_config_;
  trace_config_ = NULL;
  return temp;
}
inline void ChangeTraceConfigRequest::set_allocated_trace_config(::perfetto::protos::TraceConfig* trace_config) {
  delete trace_config_;
  trace_config_ = trace_config;
  if (trace_config) {
    set_has_trace_config();
  } else {
    clear_has_trace_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.ChangeTraceConfigRequest.trace_config)
}

// -------------------------------------------------------------------

// ChangeTraceConfigResponse

// -------------------------------------------------------------------

// DisableTracingRequest

// -------------------------------------------------------------------

// DisableTracingResponse

// -------------------------------------------------------------------

// ReadBuffersRequest

// -------------------------------------------------------------------

// ReadBuffersResponse_Slice

// optional bytes data = 1;
inline bool ReadBuffersResponse_Slice::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReadBuffersResponse_Slice::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReadBuffersResponse_Slice::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReadBuffersResponse_Slice::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
inline const ::std::string& ReadBuffersResponse_Slice::data() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ReadBuffersResponse.Slice.data)
  return data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReadBuffersResponse_Slice::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.ReadBuffersResponse.Slice.data)
}
inline void ReadBuffersResponse_Slice::set_data(const char* value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.ReadBuffersResponse.Slice.data)
}
inline void ReadBuffersResponse_Slice::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.ReadBuffersResponse.Slice.data)
}
inline ::std::string* ReadBuffersResponse_Slice::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.ReadBuffersResponse.Slice.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReadBuffersResponse_Slice::release_data() {
  // @@protoc_insertion_point(field_release:perfetto.protos.ReadBuffersResponse.Slice.data)
  clear_has_data();
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReadBuffersResponse_Slice::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.ReadBuffersResponse.Slice.data)
}

// optional bool last_slice_for_packet = 2;
inline bool ReadBuffersResponse_Slice::has_last_slice_for_packet() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReadBuffersResponse_Slice::set_has_last_slice_for_packet() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReadBuffersResponse_Slice::clear_has_last_slice_for_packet() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReadBuffersResponse_Slice::clear_last_slice_for_packet() {
  last_slice_for_packet_ = false;
  clear_has_last_slice_for_packet();
}
inline bool ReadBuffersResponse_Slice::last_slice_for_packet() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ReadBuffersResponse.Slice.last_slice_for_packet)
  return last_slice_for_packet_;
}
inline void ReadBuffersResponse_Slice::set_last_slice_for_packet(bool value) {
  set_has_last_slice_for_packet();
  last_slice_for_packet_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.ReadBuffersResponse.Slice.last_slice_for_packet)
}

// -------------------------------------------------------------------

// ReadBuffersResponse

// repeated .perfetto.protos.ReadBuffersResponse.Slice slices = 2;
inline int ReadBuffersResponse::slices_size() const {
  return slices_.size();
}
inline void ReadBuffersResponse::clear_slices() {
  slices_.Clear();
}
inline const ::perfetto::protos::ReadBuffersResponse_Slice& ReadBuffersResponse::slices(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ReadBuffersResponse.slices)
  return slices_.Get(index);
}
inline ::perfetto::protos::ReadBuffersResponse_Slice* ReadBuffersResponse::mutable_slices(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.ReadBuffersResponse.slices)
  return slices_.Mutable(index);
}
inline ::perfetto::protos::ReadBuffersResponse_Slice* ReadBuffersResponse::add_slices() {
  // @@protoc_insertion_point(field_add:perfetto.protos.ReadBuffersResponse.slices)
  return slices_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::ReadBuffersResponse_Slice >*
ReadBuffersResponse::mutable_slices() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.ReadBuffersResponse.slices)
  return &slices_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::ReadBuffersResponse_Slice >&
ReadBuffersResponse::slices() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.ReadBuffersResponse.slices)
  return slices_;
}

// -------------------------------------------------------------------

// FreeBuffersRequest

// repeated uint32 buffer_ids = 1;
inline int FreeBuffersRequest::buffer_ids_size() const {
  return buffer_ids_.size();
}
inline void FreeBuffersRequest::clear_buffer_ids() {
  buffer_ids_.Clear();
}
inline ::google::protobuf::uint32 FreeBuffersRequest::buffer_ids(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FreeBuffersRequest.buffer_ids)
  return buffer_ids_.Get(index);
}
inline void FreeBuffersRequest::set_buffer_ids(int index, ::google::protobuf::uint32 value) {
  buffer_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.FreeBuffersRequest.buffer_ids)
}
inline void FreeBuffersRequest::add_buffer_ids(::google::protobuf::uint32 value) {
  buffer_ids_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.FreeBuffersRequest.buffer_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
FreeBuffersRequest::buffer_ids() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.FreeBuffersRequest.buffer_ids)
  return buffer_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
FreeBuffersRequest::mutable_buffer_ids() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.FreeBuffersRequest.buffer_ids)
  return &buffer_ids_;
}

// -------------------------------------------------------------------

// FreeBuffersResponse

// -------------------------------------------------------------------

// FlushRequest

// optional uint32 timeout_ms = 1;
inline bool FlushRequest::has_timeout_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FlushRequest::set_has_timeout_ms() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FlushRequest::clear_has_timeout_ms() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FlushRequest::clear_timeout_ms() {
  timeout_ms_ = 0u;
  clear_has_timeout_ms();
}
inline ::google::protobuf::uint32 FlushRequest::timeout_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FlushRequest.timeout_ms)
  return timeout_ms_;
}
inline void FlushRequest::set_timeout_ms(::google::protobuf::uint32 value) {
  set_has_timeout_ms();
  timeout_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.FlushRequest.timeout_ms)
}

// -------------------------------------------------------------------

// FlushResponse

// -------------------------------------------------------------------

// DetachRequest

// optional string key = 1;
inline bool DetachRequest::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DetachRequest::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DetachRequest::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DetachRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& DetachRequest::key() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DetachRequest.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DetachRequest::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.DetachRequest.key)
}
inline void DetachRequest::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.DetachRequest.key)
}
inline void DetachRequest::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.DetachRequest.key)
}
inline ::std::string* DetachRequest::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DetachRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DetachRequest::release_key() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DetachRequest.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DetachRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DetachRequest.key)
}

// -------------------------------------------------------------------

// DetachResponse

// -------------------------------------------------------------------

// AttachRequest

// optional string key = 1;
inline bool AttachRequest::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AttachRequest::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AttachRequest::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AttachRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& AttachRequest::key() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AttachRequest.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AttachRequest::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.AttachRequest.key)
}
inline void AttachRequest::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.AttachRequest.key)
}
inline void AttachRequest::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.AttachRequest.key)
}
inline ::std::string* AttachRequest::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.AttachRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AttachRequest::release_key() {
  // @@protoc_insertion_point(field_release:perfetto.protos.AttachRequest.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AttachRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.AttachRequest.key)
}

// -------------------------------------------------------------------

// AttachResponse

// optional .perfetto.protos.TraceConfig trace_config = 1;
inline bool AttachResponse::has_trace_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AttachResponse::set_has_trace_config() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AttachResponse::clear_has_trace_config() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AttachResponse::clear_trace_config() {
  if (trace_config_ != NULL) trace_config_->::perfetto::protos::TraceConfig::Clear();
  clear_has_trace_config();
}
inline const ::perfetto::protos::TraceConfig& AttachResponse::trace_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AttachResponse.trace_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return trace_config_ != NULL ? *trace_config_ : *default_instance().trace_config_;
#else
  return trace_config_ != NULL ? *trace_config_ : *default_instance_->trace_config_;
#endif
}
inline ::perfetto::protos::TraceConfig* AttachResponse::mutable_trace_config() {
  set_has_trace_config();
  if (trace_config_ == NULL) {
    trace_config_ = new ::perfetto::protos::TraceConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.AttachResponse.trace_config)
  return trace_config_;
}
inline ::perfetto::protos::TraceConfig* AttachResponse::release_trace_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.AttachResponse.trace_config)
  clear_has_trace_config();
  ::perfetto::protos::TraceConfig* temp = trace_config_;
  trace_config_ = NULL;
  return temp;
}
inline void AttachResponse::set_allocated_trace_config(::perfetto::protos::TraceConfig* trace_config) {
  delete trace_config_;
  trace_config_ = trace_config;
  if (trace_config) {
    set_has_trace_config();
  } else {
    clear_has_trace_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.AttachResponse.trace_config)
}

// -------------------------------------------------------------------

// GetTraceStatsRequest

// -------------------------------------------------------------------

// GetTraceStatsResponse

// optional .perfetto.protos.TraceStats trace_stats = 1;
inline bool GetTraceStatsResponse::has_trace_stats() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetTraceStatsResponse::set_has_trace_stats() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetTraceStatsResponse::clear_has_trace_stats() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetTraceStatsResponse::clear_trace_stats() {
  if (trace_stats_ != NULL) trace_stats_->::perfetto::protos::TraceStats::Clear();
  clear_has_trace_stats();
}
inline const ::perfetto::protos::TraceStats& GetTraceStatsResponse::trace_stats() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetTraceStatsResponse.trace_stats)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return trace_stats_ != NULL ? *trace_stats_ : *default_instance().trace_stats_;
#else
  return trace_stats_ != NULL ? *trace_stats_ : *default_instance_->trace_stats_;
#endif
}
inline ::perfetto::protos::TraceStats* GetTraceStatsResponse::mutable_trace_stats() {
  set_has_trace_stats();
  if (trace_stats_ == NULL) {
    trace_stats_ = new ::perfetto::protos::TraceStats;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GetTraceStatsResponse.trace_stats)
  return trace_stats_;
}
inline ::perfetto::protos::TraceStats* GetTraceStatsResponse::release_trace_stats() {
  // @@protoc_insertion_point(field_release:perfetto.protos.GetTraceStatsResponse.trace_stats)
  clear_has_trace_stats();
  ::perfetto::protos::TraceStats* temp = trace_stats_;
  trace_stats_ = NULL;
  return temp;
}
inline void GetTraceStatsResponse::set_allocated_trace_stats(::perfetto::protos::TraceStats* trace_stats) {
  delete trace_stats_;
  trace_stats_ = trace_stats;
  if (trace_stats) {
    set_has_trace_stats();
  } else {
    clear_has_trace_stats();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.GetTraceStatsResponse.trace_stats)
}

// -------------------------------------------------------------------

// ObserveEventsRequest

// repeated .perfetto.protos.ObservableEvents.Type events_to_observe = 1;
inline int ObserveEventsRequest::events_to_observe_size() const {
  return events_to_observe_.size();
}
inline void ObserveEventsRequest::clear_events_to_observe() {
  events_to_observe_.Clear();
}
inline ::perfetto::protos::ObservableEvents_Type ObserveEventsRequest::events_to_observe(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ObserveEventsRequest.events_to_observe)
  return static_cast< ::perfetto::protos::ObservableEvents_Type >(events_to_observe_.Get(index));
}
inline void ObserveEventsRequest::set_events_to_observe(int index, ::perfetto::protos::ObservableEvents_Type value) {
  assert(::perfetto::protos::ObservableEvents_Type_IsValid(value));
  events_to_observe_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.ObserveEventsRequest.events_to_observe)
}
inline void ObserveEventsRequest::add_events_to_observe(::perfetto::protos::ObservableEvents_Type value) {
  assert(::perfetto::protos::ObservableEvents_Type_IsValid(value));
  events_to_observe_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.ObserveEventsRequest.events_to_observe)
}
inline const ::google::protobuf::RepeatedField<int>&
ObserveEventsRequest::events_to_observe() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.ObserveEventsRequest.events_to_observe)
  return events_to_observe_;
}
inline ::google::protobuf::RepeatedField<int>*
ObserveEventsRequest::mutable_events_to_observe() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.ObserveEventsRequest.events_to_observe)
  return &events_to_observe_;
}

// -------------------------------------------------------------------

// ObserveEventsResponse

// optional .perfetto.protos.ObservableEvents events = 1;
inline bool ObserveEventsResponse::has_events() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObserveEventsResponse::set_has_events() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ObserveEventsResponse::clear_has_events() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ObserveEventsResponse::clear_events() {
  if (events_ != NULL) events_->::perfetto::protos::ObservableEvents::Clear();
  clear_has_events();
}
inline const ::perfetto::protos::ObservableEvents& ObserveEventsResponse::events() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ObserveEventsResponse.events)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return events_ != NULL ? *events_ : *default_instance().events_;
#else
  return events_ != NULL ? *events_ : *default_instance_->events_;
#endif
}
inline ::perfetto::protos::ObservableEvents* ObserveEventsResponse::mutable_events() {
  set_has_events();
  if (events_ == NULL) {
    events_ = new ::perfetto::protos::ObservableEvents;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.ObserveEventsResponse.events)
  return events_;
}
inline ::perfetto::protos::ObservableEvents* ObserveEventsResponse::release_events() {
  // @@protoc_insertion_point(field_release:perfetto.protos.ObserveEventsResponse.events)
  clear_has_events();
  ::perfetto::protos::ObservableEvents* temp = events_;
  events_ = NULL;
  return temp;
}
inline void ObserveEventsResponse::set_allocated_events(::perfetto::protos::ObservableEvents* events) {
  delete events_;
  events_ = events;
  if (events) {
    set_has_events();
  } else {
    clear_has_events();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.ObserveEventsResponse.events)
}

// -------------------------------------------------------------------

// QueryServiceStateRequest

// -------------------------------------------------------------------

// QueryServiceStateResponse

// optional .perfetto.protos.TracingServiceState service_state = 1;
inline bool QueryServiceStateResponse::has_service_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryServiceStateResponse::set_has_service_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryServiceStateResponse::clear_has_service_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryServiceStateResponse::clear_service_state() {
  if (service_state_ != NULL) service_state_->::perfetto::protos::TracingServiceState::Clear();
  clear_has_service_state();
}
inline const ::perfetto::protos::TracingServiceState& QueryServiceStateResponse::service_state() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.QueryServiceStateResponse.service_state)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return service_state_ != NULL ? *service_state_ : *default_instance().service_state_;
#else
  return service_state_ != NULL ? *service_state_ : *default_instance_->service_state_;
#endif
}
inline ::perfetto::protos::TracingServiceState* QueryServiceStateResponse::mutable_service_state() {
  set_has_service_state();
  if (service_state_ == NULL) {
    service_state_ = new ::perfetto::protos::TracingServiceState;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.QueryServiceStateResponse.service_state)
  return service_state_;
}
inline ::perfetto::protos::TracingServiceState* QueryServiceStateResponse::release_service_state() {
  // @@protoc_insertion_point(field_release:perfetto.protos.QueryServiceStateResponse.service_state)
  clear_has_service_state();
  ::perfetto::protos::TracingServiceState* temp = service_state_;
  service_state_ = NULL;
  return temp;
}
inline void QueryServiceStateResponse::set_allocated_service_state(::perfetto::protos::TracingServiceState* service_state) {
  delete service_state_;
  service_state_ = service_state;
  if (service_state) {
    set_has_service_state();
  } else {
    clear_has_service_state();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.QueryServiceStateResponse.service_state)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto__INCLUDED
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/ipc/consumer_port.ipc.h
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/ipc/consumer_port.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/ipc/consumer_port.proto

#ifndef PROTOBUF_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// gen_amalgamated expanded: #include "protos/perfetto/common/observable_events.pb.h"
// gen_amalgamated expanded: #include "protos/perfetto/common/tracing_service_state.pb.h"
// gen_amalgamated expanded: #include "protos/perfetto/common/trace_stats.pb.h"
// gen_amalgamated expanded: #include "protos/perfetto/config/trace_config.pb.h"
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();

class AttachRequest;
class AttachResponse;
class ChangeTraceConfigRequest;
class ChangeTraceConfigResponse;
class DetachRequest;
class DetachResponse;
class DisableTracingRequest;
class DisableTracingResponse;
class EnableTracingRequest;
class EnableTracingResponse;
class FlushRequest;
class FlushResponse;
class FreeBuffersRequest;
class FreeBuffersResponse;
class GetTraceStatsRequest;
class GetTraceStatsResponse;
class ObserveEventsRequest;
class ObserveEventsResponse;
class QueryServiceStateRequest;
class QueryServiceStateResponse;
class ReadBuffersRequest;
class ReadBuffersResponse;
class ReadBuffersResponse_Slice;
class StartTracingRequest;
class StartTracingResponse;

// ===================================================================

class EnableTracingRequest : public ::google::protobuf::MessageLite {
 public:
  EnableTracingRequest();
  virtual ~EnableTracingRequest();

  EnableTracingRequest(const EnableTracingRequest& from);

  inline EnableTracingRequest& operator=(const EnableTracingRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const EnableTracingRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EnableTracingRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EnableTracingRequest* other);

  // implements Message ----------------------------------------------

  inline EnableTracingRequest* New() const { return New(NULL); }

  EnableTracingRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EnableTracingRequest& from);
  void MergeFrom(const EnableTracingRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EnableTracingRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .perfetto.protos.TraceConfig trace_config = 1;
  bool has_trace_config() const;
  void clear_trace_config();
  static const int kTraceConfigFieldNumber = 1;
  const ::perfetto::protos::TraceConfig& trace_config() const;
  ::perfetto::protos::TraceConfig* mutable_trace_config();
  ::perfetto::protos::TraceConfig* release_trace_config();
  void set_allocated_trace_config(::perfetto::protos::TraceConfig* trace_config);

  // optional bool attach_notification_only = 2;
  bool has_attach_notification_only() const;
  void clear_attach_notification_only();
  static const int kAttachNotificationOnlyFieldNumber = 2;
  bool attach_notification_only() const;
  void set_attach_notification_only(bool value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.EnableTracingRequest)
 private:
  inline void set_has_trace_config();
  inline void clear_has_trace_config();
  inline void set_has_attach_notification_only();
  inline void clear_has_attach_notification_only();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::perfetto::protos::TraceConfig* trace_config_;
  bool attach_notification_only_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static EnableTracingRequest* default_instance_;
};
// -------------------------------------------------------------------

class EnableTracingResponse : public ::google::protobuf::MessageLite {
 public:
  EnableTracingResponse();
  virtual ~EnableTracingResponse();

  EnableTracingResponse(const EnableTracingResponse& from);

  inline EnableTracingResponse& operator=(const EnableTracingResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const EnableTracingResponse& default_instance();

  enum StateCase {
    kDisabled = 1,
    STATE_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EnableTracingResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EnableTracingResponse* other);

  // implements Message ----------------------------------------------

  inline EnableTracingResponse* New() const { return New(NULL); }

  EnableTracingResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EnableTracingResponse& from);
  void MergeFrom(const EnableTracingResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EnableTracingResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool disabled = 1;
  bool has_disabled() const;
  void clear_disabled();
  static const int kDisabledFieldNumber = 1;
  bool disabled() const;
  void set_disabled(bool value);

  StateCase state_case() const;
  // @@protoc_insertion_point(class_scope:perfetto.protos.EnableTracingResponse)
 private:
  inline void set_has_disabled();

  inline bool has_state() const;
  void clear_state();
  inline void clear_has_state();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union StateUnion {
    StateUnion() {}
    bool disabled_;
  } state_;
  ::google::protobuf::uint32 _oneof_case_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static EnableTracingResponse* default_instance_;
};
// -------------------------------------------------------------------

class StartTracingRequest : public ::google::protobuf::MessageLite {
 public:
  StartTracingRequest();
  virtual ~StartTracingRequest();

  StartTracingRequest(const StartTracingRequest& from);

  inline StartTracingRequest& operator=(const StartTracingRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const StartTracingRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StartTracingRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StartTracingRequest* other);

  // implements Message ----------------------------------------------

  inline StartTracingRequest* New() const { return New(NULL); }

  StartTracingRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StartTracingRequest& from);
  void MergeFrom(const StartTracingRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StartTracingRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.StartTracingRequest)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static StartTracingRequest* default_instance_;
};
// -------------------------------------------------------------------

class StartTracingResponse : public ::google::protobuf::MessageLite {
 public:
  StartTracingResponse();
  virtual ~StartTracingResponse();

  StartTracingResponse(const StartTracingResponse& from);

  inline StartTracingResponse& operator=(const StartTracingResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const StartTracingResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StartTracingResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StartTracingResponse* other);

  // implements Message ----------------------------------------------

  inline StartTracingResponse* New() const { return New(NULL); }

  StartTracingResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StartTracingResponse& from);
  void MergeFrom(const StartTracingResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StartTracingResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.StartTracingResponse)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static StartTracingResponse* default_instance_;
};
// -------------------------------------------------------------------

class ChangeTraceConfigRequest : public ::google::protobuf::MessageLite {
 public:
  ChangeTraceConfigRequest();
  virtual ~ChangeTraceConfigRequest();

  ChangeTraceConfigRequest(const ChangeTraceConfigRequest& from);

  inline ChangeTraceConfigRequest& operator=(const ChangeTraceConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ChangeTraceConfigRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ChangeTraceConfigRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ChangeTraceConfigRequest* other);

  // implements Message ----------------------------------------------

  inline ChangeTraceConfigRequest* New() const { return New(NULL); }

  ChangeTraceConfigRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChangeTraceConfigRequest& from);
  void MergeFrom(const ChangeTraceConfigRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChangeTraceConfigRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .perfetto.protos.TraceConfig trace_config = 1;
  bool has_trace_config() const;
  void clear_trace_config();
  static const int kTraceConfigFieldNumber = 1;
  const ::perfetto::protos::TraceConfig& trace_config() const;
  ::perfetto::protos::TraceConfig* mutable_trace_config();
  ::perfetto::protos::TraceConfig* release_trace_config();
  void set_allocated_trace_config(::perfetto::protos::TraceConfig* trace_config);

  // @@protoc_insertion_point(class_scope:perfetto.protos.ChangeTraceConfigRequest)
 private:
  inline void set_has_trace_config();
  inline void clear_has_trace_config();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::perfetto::protos::TraceConfig* trace_config_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static ChangeTraceConfigRequest* default_instance_;
};
// -------------------------------------------------------------------

class ChangeTraceConfigResponse : public ::google::protobuf::MessageLite {
 public:
  ChangeTraceConfigResponse();
  virtual ~ChangeTraceConfigResponse();

  ChangeTraceConfigResponse(const ChangeTraceConfigResponse& from);

  inline ChangeTraceConfigResponse& operator=(const ChangeTraceConfigResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ChangeTraceConfigResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ChangeTraceConfigResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ChangeTraceConfigResponse* other);

  // implements Message ----------------------------------------------

  inline ChangeTraceConfigResponse* New() const { return New(NULL); }

  ChangeTraceConfigResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChangeTraceConfigResponse& from);
  void MergeFrom(const ChangeTraceConfigResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChangeTraceConfigResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.ChangeTraceConfigResponse)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static ChangeTraceConfigResponse* default_instance_;
};
// -------------------------------------------------------------------

class DisableTracingRequest : public ::google::protobuf::MessageLite {
 public:
  DisableTracingRequest();
  virtual ~DisableTracingRequest();

  DisableTracingRequest(const DisableTracingRequest& from);

  inline DisableTracingRequest& operator=(const DisableTracingRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const DisableTracingRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DisableTracingRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DisableTracingRequest* other);

  // implements Message ----------------------------------------------

  inline DisableTracingRequest* New() const { return New(NULL); }

  DisableTracingRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DisableTracingRequest& from);
  void MergeFrom(const DisableTracingRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DisableTracingRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.DisableTracingRequest)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static DisableTracingRequest* default_instance_;
};
// -------------------------------------------------------------------

class DisableTracingResponse : public ::google::protobuf::MessageLite {
 public:
  DisableTracingResponse();
  virtual ~DisableTracingResponse();

  DisableTracingResponse(const DisableTracingResponse& from);

  inline DisableTracingResponse& operator=(const DisableTracingResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const DisableTracingResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DisableTracingResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DisableTracingResponse* other);

  // implements Message ----------------------------------------------

  inline DisableTracingResponse* New() const { return New(NULL); }

  DisableTracingResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DisableTracingResponse& from);
  void MergeFrom(const DisableTracingResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DisableTracingResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.DisableTracingResponse)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static DisableTracingResponse* default_instance_;
};
// -------------------------------------------------------------------

class ReadBuffersRequest : public ::google::protobuf::MessageLite {
 public:
  ReadBuffersRequest();
  virtual ~ReadBuffersRequest();

  ReadBuffersRequest(const ReadBuffersRequest& from);

  inline ReadBuffersRequest& operator=(const ReadBuffersRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ReadBuffersRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReadBuffersRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReadBuffersRequest* other);

  // implements Message ----------------------------------------------

  inline ReadBuffersRequest* New() const { return New(NULL); }

  ReadBuffersRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReadBuffersRequest& from);
  void MergeFrom(const ReadBuffersRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReadBuffersRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.ReadBuffersRequest)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static ReadBuffersRequest* default_instance_;
};
// -------------------------------------------------------------------

class ReadBuffersResponse_Slice : public ::google::protobuf::MessageLite {
 public:
  ReadBuffersResponse_Slice();
  virtual ~ReadBuffersResponse_Slice();

  ReadBuffersResponse_Slice(const ReadBuffersResponse_Slice& from);

  inline ReadBuffersResponse_Slice& operator=(const ReadBuffersResponse_Slice& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ReadBuffersResponse_Slice& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReadBuffersResponse_Slice* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReadBuffersResponse_Slice* other);

  // implements Message ----------------------------------------------

  inline ReadBuffersResponse_Slice* New() const { return New(NULL); }

  ReadBuffersResponse_Slice* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReadBuffersResponse_Slice& from);
  void MergeFrom(const ReadBuffersResponse_Slice& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReadBuffersResponse_Slice* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes data = 1;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 1;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // optional bool last_slice_for_packet = 2;
  bool has_last_slice_for_packet() const;
  void clear_last_slice_for_packet();
  static const int kLastSliceForPacketFieldNumber = 2;
  bool last_slice_for_packet() const;
  void set_last_slice_for_packet(bool value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.ReadBuffersResponse.Slice)
 private:
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_last_slice_for_packet();
  inline void clear_has_last_slice_for_packet();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  bool last_slice_for_packet_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static ReadBuffersResponse_Slice* default_instance_;
};
// -------------------------------------------------------------------

class ReadBuffersResponse : public ::google::protobuf::MessageLite {
 public:
  ReadBuffersResponse();
  virtual ~ReadBuffersResponse();

  ReadBuffersResponse(const ReadBuffersResponse& from);

  inline ReadBuffersResponse& operator=(const ReadBuffersResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ReadBuffersResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReadBuffersResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReadBuffersResponse* other);

  // implements Message ----------------------------------------------

  inline ReadBuffersResponse* New() const { return New(NULL); }

  ReadBuffersResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReadBuffersResponse& from);
  void MergeFrom(const ReadBuffersResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReadBuffersResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ReadBuffersResponse_Slice Slice;

  // accessors -------------------------------------------------------

  // repeated .perfetto.protos.ReadBuffersResponse.Slice slices = 2;
  int slices_size() const;
  void clear_slices();
  static const int kSlicesFieldNumber = 2;
  const ::perfetto::protos::ReadBuffersResponse_Slice& slices(int index) const;
  ::perfetto::protos::ReadBuffersResponse_Slice* mutable_slices(int index);
  ::perfetto::protos::ReadBuffersResponse_Slice* add_slices();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::ReadBuffersResponse_Slice >*
      mutable_slices();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::ReadBuffersResponse_Slice >&
      slices() const;

  // @@protoc_insertion_point(class_scope:perfetto.protos.ReadBuffersResponse)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::ReadBuffersResponse_Slice > slices_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static ReadBuffersResponse* default_instance_;
};
// -------------------------------------------------------------------

class FreeBuffersRequest : public ::google::protobuf::MessageLite {
 public:
  FreeBuffersRequest();
  virtual ~FreeBuffersRequest();

  FreeBuffersRequest(const FreeBuffersRequest& from);

  inline FreeBuffersRequest& operator=(const FreeBuffersRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const FreeBuffersRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FreeBuffersRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FreeBuffersRequest* other);

  // implements Message ----------------------------------------------

  inline FreeBuffersRequest* New() const { return New(NULL); }

  FreeBuffersRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FreeBuffersRequest& from);
  void MergeFrom(const FreeBuffersRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FreeBuffersRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 buffer_ids = 1;
  int buffer_ids_size() const;
  void clear_buffer_ids();
  static const int kBufferIdsFieldNumber = 1;
  ::google::protobuf::uint32 buffer_ids(int index) const;
  void set_buffer_ids(int index, ::google::protobuf::uint32 value);
  void add_buffer_ids(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      buffer_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_buffer_ids();

  // @@protoc_insertion_point(class_scope:perfetto.protos.FreeBuffersRequest)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > buffer_ids_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static FreeBuffersRequest* default_instance_;
};
// -------------------------------------------------------------------

class FreeBuffersResponse : public ::google::protobuf::MessageLite {
 public:
  FreeBuffersResponse();
  virtual ~FreeBuffersResponse();

  FreeBuffersResponse(const FreeBuffersResponse& from);

  inline FreeBuffersResponse& operator=(const FreeBuffersResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const FreeBuffersResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FreeBuffersResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FreeBuffersResponse* other);

  // implements Message ----------------------------------------------

  inline FreeBuffersResponse* New() const { return New(NULL); }

  FreeBuffersResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FreeBuffersResponse& from);
  void MergeFrom(const FreeBuffersResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FreeBuffersResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.FreeBuffersResponse)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static FreeBuffersResponse* default_instance_;
};
// -------------------------------------------------------------------

class FlushRequest : public ::google::protobuf::MessageLite {
 public:
  FlushRequest();
  virtual ~FlushRequest();

  FlushRequest(const FlushRequest& from);

  inline FlushRequest& operator=(const FlushRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const FlushRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FlushRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FlushRequest* other);

  // implements Message ----------------------------------------------

  inline FlushRequest* New() const { return New(NULL); }

  FlushRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FlushRequest& from);
  void MergeFrom(const FlushRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FlushRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 timeout_ms = 1;
  bool has_timeout_ms() const;
  void clear_timeout_ms();
  static const int kTimeoutMsFieldNumber = 1;
  ::google::protobuf::uint32 timeout_ms() const;
  void set_timeout_ms(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.FlushRequest)
 private:
  inline void set_has_timeout_ms();
  inline void clear_has_timeout_ms();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 timeout_ms_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static FlushRequest* default_instance_;
};
// -------------------------------------------------------------------

class FlushResponse : public ::google::protobuf::MessageLite {
 public:
  FlushResponse();
  virtual ~FlushResponse();

  FlushResponse(const FlushResponse& from);

  inline FlushResponse& operator=(const FlushResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const FlushResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FlushResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FlushResponse* other);

  // implements Message ----------------------------------------------

  inline FlushResponse* New() const { return New(NULL); }

  FlushResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FlushResponse& from);
  void MergeFrom(const FlushResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FlushResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.FlushResponse)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static FlushResponse* default_instance_;
};
// -------------------------------------------------------------------

class DetachRequest : public ::google::protobuf::MessageLite {
 public:
  DetachRequest();
  virtual ~DetachRequest();

  DetachRequest(const DetachRequest& from);

  inline DetachRequest& operator=(const DetachRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const DetachRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DetachRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DetachRequest* other);

  // implements Message ----------------------------------------------

  inline DetachRequest* New() const { return New(NULL); }

  DetachRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DetachRequest& from);
  void MergeFrom(const DetachRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DetachRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:perfetto.protos.DetachRequest)
 private:
  inline void set_has_key();
  inline void clear_has_key();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static DetachRequest* default_instance_;
};
// -------------------------------------------------------------------

class DetachResponse : public ::google::protobuf::MessageLite {
 public:
  DetachResponse();
  virtual ~DetachResponse();

  DetachResponse(const DetachResponse& from);

  inline DetachResponse& operator=(const DetachResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const DetachResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DetachResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DetachResponse* other);

  // implements Message ----------------------------------------------

  inline DetachResponse* New() const { return New(NULL); }

  DetachResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DetachResponse& from);
  void MergeFrom(const DetachResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DetachResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.DetachResponse)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static DetachResponse* default_instance_;
};
// -------------------------------------------------------------------

class AttachRequest : public ::google::protobuf::MessageLite {
 public:
  AttachRequest();
  virtual ~AttachRequest();

  AttachRequest(const AttachRequest& from);

  inline AttachRequest& operator=(const AttachRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const AttachRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AttachRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AttachRequest* other);

  // implements Message ----------------------------------------------

  inline AttachRequest* New() const { return New(NULL); }

  AttachRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AttachRequest& from);
  void MergeFrom(const AttachRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AttachRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:perfetto.protos.AttachRequest)
 private:
  inline void set_has_key();
  inline void clear_has_key();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static AttachRequest* default_instance_;
};
// -------------------------------------------------------------------

class AttachResponse : public ::google::protobuf::MessageLite {
 public:
  AttachResponse();
  virtual ~AttachResponse();

  AttachResponse(const AttachResponse& from);

  inline AttachResponse& operator=(const AttachResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const AttachResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AttachResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AttachResponse* other);

  // implements Message ----------------------------------------------

  inline AttachResponse* New() const { return New(NULL); }

  AttachResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AttachResponse& from);
  void MergeFrom(const AttachResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AttachResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .perfetto.protos.TraceConfig trace_config = 1;
  bool has_trace_config() const;
  void clear_trace_config();
  static const int kTraceConfigFieldNumber = 1;
  const ::perfetto::protos::TraceConfig& trace_config() const;
  ::perfetto::protos::TraceConfig* mutable_trace_config();
  ::perfetto::protos::TraceConfig* release_trace_config();
  void set_allocated_trace_config(::perfetto::protos::TraceConfig* trace_config);

  // @@protoc_insertion_point(class_scope:perfetto.protos.AttachResponse)
 private:
  inline void set_has_trace_config();
  inline void clear_has_trace_config();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::perfetto::protos::TraceConfig* trace_config_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static AttachResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetTraceStatsRequest : public ::google::protobuf::MessageLite {
 public:
  GetTraceStatsRequest();
  virtual ~GetTraceStatsRequest();

  GetTraceStatsRequest(const GetTraceStatsRequest& from);

  inline GetTraceStatsRequest& operator=(const GetTraceStatsRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const GetTraceStatsRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetTraceStatsRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetTraceStatsRequest* other);

  // implements Message ----------------------------------------------

  inline GetTraceStatsRequest* New() const { return New(NULL); }

  GetTraceStatsRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetTraceStatsRequest& from);
  void MergeFrom(const GetTraceStatsRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetTraceStatsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.GetTraceStatsRequest)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static GetTraceStatsRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetTraceStatsResponse : public ::google::protobuf::MessageLite {
 public:
  GetTraceStatsResponse();
  virtual ~GetTraceStatsResponse();

  GetTraceStatsResponse(const GetTraceStatsResponse& from);

  inline GetTraceStatsResponse& operator=(const GetTraceStatsResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const GetTraceStatsResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetTraceStatsResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetTraceStatsResponse* other);

  // implements Message ----------------------------------------------

  inline GetTraceStatsResponse* New() const { return New(NULL); }

  GetTraceStatsResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetTraceStatsResponse& from);
  void MergeFrom(const GetTraceStatsResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetTraceStatsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .perfetto.protos.TraceStats trace_stats = 1;
  bool has_trace_stats() const;
  void clear_trace_stats();
  static const int kTraceStatsFieldNumber = 1;
  const ::perfetto::protos::TraceStats& trace_stats() const;
  ::perfetto::protos::TraceStats* mutable_trace_stats();
  ::perfetto::protos::TraceStats* release_trace_stats();
  void set_allocated_trace_stats(::perfetto::protos::TraceStats* trace_stats);

  // @@protoc_insertion_point(class_scope:perfetto.protos.GetTraceStatsResponse)
 private:
  inline void set_has_trace_stats();
  inline void clear_has_trace_stats();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::perfetto::protos::TraceStats* trace_stats_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static GetTraceStatsResponse* default_instance_;
};
// -------------------------------------------------------------------

class ObserveEventsRequest : public ::google::protobuf::MessageLite {
 public:
  ObserveEventsRequest();
  virtual ~ObserveEventsRequest();

  ObserveEventsRequest(const ObserveEventsRequest& from);

  inline ObserveEventsRequest& operator=(const ObserveEventsRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ObserveEventsRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ObserveEventsRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ObserveEventsRequest* other);

  // implements Message ----------------------------------------------

  inline ObserveEventsRequest* New() const { return New(NULL); }

  ObserveEventsRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ObserveEventsRequest& from);
  void MergeFrom(const ObserveEventsRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ObserveEventsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .perfetto.protos.ObservableEvents.Type events_to_observe = 1;
  int events_to_observe_size() const;
  void clear_events_to_observe();
  static const int kEventsToObserveFieldNumber = 1;
  ::perfetto::protos::ObservableEvents_Type events_to_observe(int index) const;
  void set_events_to_observe(int index, ::perfetto::protos::ObservableEvents_Type value);
  void add_events_to_observe(::perfetto::protos::ObservableEvents_Type value);
  const ::google::protobuf::RepeatedField<int>& events_to_observe() const;
  ::google::protobuf::RepeatedField<int>* mutable_events_to_observe();

  // @@protoc_insertion_point(class_scope:perfetto.protos.ObserveEventsRequest)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField<int> events_to_observe_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static ObserveEventsRequest* default_instance_;
};
// -------------------------------------------------------------------

class ObserveEventsResponse : public ::google::protobuf::MessageLite {
 public:
  ObserveEventsResponse();
  virtual ~ObserveEventsResponse();

  ObserveEventsResponse(const ObserveEventsResponse& from);

  inline ObserveEventsResponse& operator=(const ObserveEventsResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ObserveEventsResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ObserveEventsResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ObserveEventsResponse* other);

  // implements Message ----------------------------------------------

  inline ObserveEventsResponse* New() const { return New(NULL); }

  ObserveEventsResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ObserveEventsResponse& from);
  void MergeFrom(const ObserveEventsResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ObserveEventsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .perfetto.protos.ObservableEvents events = 1;
  bool has_events() const;
  void clear_events();
  static const int kEventsFieldNumber = 1;
  const ::perfetto::protos::ObservableEvents& events() const;
  ::perfetto::protos::ObservableEvents* mutable_events();
  ::perfetto::protos::ObservableEvents* release_events();
  void set_allocated_events(::perfetto::protos::ObservableEvents* events);

  // @@protoc_insertion_point(class_scope:perfetto.protos.ObserveEventsResponse)
 private:
  inline void set_has_events();
  inline void clear_has_events();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::perfetto::protos::ObservableEvents* events_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static ObserveEventsResponse* default_instance_;
};
// -------------------------------------------------------------------

class QueryServiceStateRequest : public ::google::protobuf::MessageLite {
 public:
  QueryServiceStateRequest();
  virtual ~QueryServiceStateRequest();

  QueryServiceStateRequest(const QueryServiceStateRequest& from);

  inline QueryServiceStateRequest& operator=(const QueryServiceStateRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const QueryServiceStateRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const QueryServiceStateRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(QueryServiceStateRequest* other);

  // implements Message ----------------------------------------------

  inline QueryServiceStateRequest* New() const { return New(NULL); }

  QueryServiceStateRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const QueryServiceStateRequest& from);
  void MergeFrom(const QueryServiceStateRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(QueryServiceStateRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.QueryServiceStateRequest)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static QueryServiceStateRequest* default_instance_;
};
// -------------------------------------------------------------------

class QueryServiceStateResponse : public ::google::protobuf::MessageLite {
 public:
  QueryServiceStateResponse();
  virtual ~QueryServiceStateResponse();

  QueryServiceStateResponse(const QueryServiceStateResponse& from);

  inline QueryServiceStateResponse& operator=(const QueryServiceStateResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const QueryServiceStateResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const QueryServiceStateResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(QueryServiceStateResponse* other);

  // implements Message ----------------------------------------------

  inline QueryServiceStateResponse* New() const { return New(NULL); }

  QueryServiceStateResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const QueryServiceStateResponse& from);
  void MergeFrom(const QueryServiceStateResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(QueryServiceStateResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .perfetto.protos.TracingServiceState service_state = 1;
  bool has_service_state() const;
  void clear_service_state();
  static const int kServiceStateFieldNumber = 1;
  const ::perfetto::protos::TracingServiceState& service_state() const;
  ::perfetto::protos::TracingServiceState* mutable_service_state();
  ::perfetto::protos::TracingServiceState* release_service_state();
  void set_allocated_service_state(::perfetto::protos::TracingServiceState* service_state);

  // @@protoc_insertion_point(class_scope:perfetto.protos.QueryServiceStateResponse)
 private:
  inline void set_has_service_state();
  inline void clear_has_service_state();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::perfetto::protos::TracingServiceState* service_state_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static QueryServiceStateResponse* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// EnableTracingRequest

// optional .perfetto.protos.TraceConfig trace_config = 1;
inline bool EnableTracingRequest::has_trace_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnableTracingRequest::set_has_trace_config() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnableTracingRequest::clear_has_trace_config() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnableTracingRequest::clear_trace_config() {
  if (trace_config_ != NULL) trace_config_->::perfetto::protos::TraceConfig::Clear();
  clear_has_trace_config();
}
inline const ::perfetto::protos::TraceConfig& EnableTracingRequest::trace_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.EnableTracingRequest.trace_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return trace_config_ != NULL ? *trace_config_ : *default_instance().trace_config_;
#else
  return trace_config_ != NULL ? *trace_config_ : *default_instance_->trace_config_;
#endif
}
inline ::perfetto::protos::TraceConfig* EnableTracingRequest::mutable_trace_config() {
  set_has_trace_config();
  if (trace_config_ == NULL) {
    trace_config_ = new ::perfetto::protos::TraceConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.EnableTracingRequest.trace_config)
  return trace_config_;
}
inline ::perfetto::protos::TraceConfig* EnableTracingRequest::release_trace_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.EnableTracingRequest.trace_config)
  clear_has_trace_config();
  ::perfetto::protos::TraceConfig* temp = trace_config_;
  trace_config_ = NULL;
  return temp;
}
inline void EnableTracingRequest::set_allocated_trace_config(::perfetto::protos::TraceConfig* trace_config) {
  delete trace_config_;
  trace_config_ = trace_config;
  if (trace_config) {
    set_has_trace_config();
  } else {
    clear_has_trace_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.EnableTracingRequest.trace_config)
}

// optional bool attach_notification_only = 2;
inline bool EnableTracingRequest::has_attach_notification_only() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnableTracingRequest::set_has_attach_notification_only() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnableTracingRequest::clear_has_attach_notification_only() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnableTracingRequest::clear_attach_notification_only() {
  attach_notification_only_ = false;
  clear_has_attach_notification_only();
}
inline bool EnableTracingRequest::attach_notification_only() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.EnableTracingRequest.attach_notification_only)
  return attach_notification_only_;
}
inline void EnableTracingRequest::set_attach_notification_only(bool value) {
  set_has_attach_notification_only();
  attach_notification_only_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.EnableTracingRequest.attach_notification_only)
}

// -------------------------------------------------------------------

// EnableTracingResponse

// optional bool disabled = 1;
inline bool EnableTracingResponse::has_disabled() const {
  return state_case() == kDisabled;
}
inline void EnableTracingResponse::set_has_disabled() {
  _oneof_case_[0] = kDisabled;
}
inline void EnableTracingResponse::clear_disabled() {
  if (has_disabled()) {
    state_.disabled_ = false;
    clear_has_state();
  }
}
inline bool EnableTracingResponse::disabled() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.EnableTracingResponse.disabled)
  if (has_disabled()) {
    return state_.disabled_;
  }
  return false;
}
inline void EnableTracingResponse::set_disabled(bool value) {
  if (!has_disabled()) {
    clear_state();
    set_has_disabled();
  }
  state_.disabled_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.EnableTracingResponse.disabled)
}

inline bool EnableTracingResponse::has_state() const {
  return state_case() != STATE_NOT_SET;
}
inline void EnableTracingResponse::clear_has_state() {
  _oneof_case_[0] = STATE_NOT_SET;
}
inline EnableTracingResponse::StateCase EnableTracingResponse::state_case() const {
  return EnableTracingResponse::StateCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// StartTracingRequest

// -------------------------------------------------------------------

// StartTracingResponse

// -------------------------------------------------------------------

// ChangeTraceConfigRequest

// optional .perfetto.protos.TraceConfig trace_config = 1;
inline bool ChangeTraceConfigRequest::has_trace_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangeTraceConfigRequest::set_has_trace_config() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangeTraceConfigRequest::clear_has_trace_config() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangeTraceConfigRequest::clear_trace_config() {
  if (trace_config_ != NULL) trace_config_->::perfetto::protos::TraceConfig::Clear();
  clear_has_trace_config();
}
inline const ::perfetto::protos::TraceConfig& ChangeTraceConfigRequest::trace_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ChangeTraceConfigRequest.trace_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return trace_config_ != NULL ? *trace_config_ : *default_instance().trace_config_;
#else
  return trace_config_ != NULL ? *trace_config_ : *default_instance_->trace_config_;
#endif
}
inline ::perfetto::protos::TraceConfig* ChangeTraceConfigRequest::mutable_trace_config() {
  set_has_trace_config();
  if (trace_config_ == NULL) {
    trace_config_ = new ::perfetto::protos::TraceConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.ChangeTraceConfigRequest.trace_config)
  return trace_config_;
}
inline ::perfetto::protos::TraceConfig* ChangeTraceConfigRequest::release_trace_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.ChangeTraceConfigRequest.trace_config)
  clear_has_trace_config();
  ::perfetto::protos::TraceConfig* temp = trace_config_;
  trace_config_ = NULL;
  return temp;
}
inline void ChangeTraceConfigRequest::set_allocated_trace_config(::perfetto::protos::TraceConfig* trace_config) {
  delete trace_config_;
  trace_config_ = trace_config;
  if (trace_config) {
    set_has_trace_config();
  } else {
    clear_has_trace_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.ChangeTraceConfigRequest.trace_config)
}

// -------------------------------------------------------------------

// ChangeTraceConfigResponse

// -------------------------------------------------------------------

// DisableTracingRequest

// -------------------------------------------------------------------

// DisableTracingResponse

// -------------------------------------------------------------------

// ReadBuffersRequest

// -------------------------------------------------------------------

// ReadBuffersResponse_Slice

// optional bytes data = 1;
inline bool ReadBuffersResponse_Slice::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReadBuffersResponse_Slice::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReadBuffersResponse_Slice::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReadBuffersResponse_Slice::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
inline const ::std::string& ReadBuffersResponse_Slice::data() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ReadBuffersResponse.Slice.data)
  return data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReadBuffersResponse_Slice::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.ReadBuffersResponse.Slice.data)
}
inline void ReadBuffersResponse_Slice::set_data(const char* value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.ReadBuffersResponse.Slice.data)
}
inline void ReadBuffersResponse_Slice::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.ReadBuffersResponse.Slice.data)
}
inline ::std::string* ReadBuffersResponse_Slice::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.ReadBuffersResponse.Slice.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReadBuffersResponse_Slice::release_data() {
  // @@protoc_insertion_point(field_release:perfetto.protos.ReadBuffersResponse.Slice.data)
  clear_has_data();
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReadBuffersResponse_Slice::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.ReadBuffersResponse.Slice.data)
}

// optional bool last_slice_for_packet = 2;
inline bool ReadBuffersResponse_Slice::has_last_slice_for_packet() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReadBuffersResponse_Slice::set_has_last_slice_for_packet() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReadBuffersResponse_Slice::clear_has_last_slice_for_packet() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReadBuffersResponse_Slice::clear_last_slice_for_packet() {
  last_slice_for_packet_ = false;
  clear_has_last_slice_for_packet();
}
inline bool ReadBuffersResponse_Slice::last_slice_for_packet() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ReadBuffersResponse.Slice.last_slice_for_packet)
  return last_slice_for_packet_;
}
inline void ReadBuffersResponse_Slice::set_last_slice_for_packet(bool value) {
  set_has_last_slice_for_packet();
  last_slice_for_packet_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.ReadBuffersResponse.Slice.last_slice_for_packet)
}

// -------------------------------------------------------------------

// ReadBuffersResponse

// repeated .perfetto.protos.ReadBuffersResponse.Slice slices = 2;
inline int ReadBuffersResponse::slices_size() const {
  return slices_.size();
}
inline void ReadBuffersResponse::clear_slices() {
  slices_.Clear();
}
inline const ::perfetto::protos::ReadBuffersResponse_Slice& ReadBuffersResponse::slices(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ReadBuffersResponse.slices)
  return slices_.Get(index);
}
inline ::perfetto::protos::ReadBuffersResponse_Slice* ReadBuffersResponse::mutable_slices(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.ReadBuffersResponse.slices)
  return slices_.Mutable(index);
}
inline ::perfetto::protos::ReadBuffersResponse_Slice* ReadBuffersResponse::add_slices() {
  // @@protoc_insertion_point(field_add:perfetto.protos.ReadBuffersResponse.slices)
  return slices_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::ReadBuffersResponse_Slice >*
ReadBuffersResponse::mutable_slices() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.ReadBuffersResponse.slices)
  return &slices_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::ReadBuffersResponse_Slice >&
ReadBuffersResponse::slices() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.ReadBuffersResponse.slices)
  return slices_;
}

// -------------------------------------------------------------------

// FreeBuffersRequest

// repeated uint32 buffer_ids = 1;
inline int FreeBuffersRequest::buffer_ids_size() const {
  return buffer_ids_.size();
}
inline void FreeBuffersRequest::clear_buffer_ids() {
  buffer_ids_.Clear();
}
inline ::google::protobuf::uint32 FreeBuffersRequest::buffer_ids(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FreeBuffersRequest.buffer_ids)
  return buffer_ids_.Get(index);
}
inline void FreeBuffersRequest::set_buffer_ids(int index, ::google::protobuf::uint32 value) {
  buffer_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.FreeBuffersRequest.buffer_ids)
}
inline void FreeBuffersRequest::add_buffer_ids(::google::protobuf::uint32 value) {
  buffer_ids_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.FreeBuffersRequest.buffer_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
FreeBuffersRequest::buffer_ids() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.FreeBuffersRequest.buffer_ids)
  return buffer_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
FreeBuffersRequest::mutable_buffer_ids() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.FreeBuffersRequest.buffer_ids)
  return &buffer_ids_;
}

// -------------------------------------------------------------------

// FreeBuffersResponse

// -------------------------------------------------------------------

// FlushRequest

// optional uint32 timeout_ms = 1;
inline bool FlushRequest::has_timeout_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FlushRequest::set_has_timeout_ms() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FlushRequest::clear_has_timeout_ms() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FlushRequest::clear_timeout_ms() {
  timeout_ms_ = 0u;
  clear_has_timeout_ms();
}
inline ::google::protobuf::uint32 FlushRequest::timeout_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FlushRequest.timeout_ms)
  return timeout_ms_;
}
inline void FlushRequest::set_timeout_ms(::google::protobuf::uint32 value) {
  set_has_timeout_ms();
  timeout_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.FlushRequest.timeout_ms)
}

// -------------------------------------------------------------------

// FlushResponse

// -------------------------------------------------------------------

// DetachRequest

// optional string key = 1;
inline bool DetachRequest::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DetachRequest::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DetachRequest::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DetachRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& DetachRequest::key() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DetachRequest.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DetachRequest::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.DetachRequest.key)
}
inline void DetachRequest::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.DetachRequest.key)
}
inline void DetachRequest::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.DetachRequest.key)
}
inline ::std::string* DetachRequest::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DetachRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DetachRequest::release_key() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DetachRequest.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DetachRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DetachRequest.key)
}

// -------------------------------------------------------------------

// DetachResponse

// -------------------------------------------------------------------

// AttachRequest

// optional string key = 1;
inline bool AttachRequest::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AttachRequest::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AttachRequest::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AttachRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& AttachRequest::key() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AttachRequest.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AttachRequest::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.AttachRequest.key)
}
inline void AttachRequest::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.AttachRequest.key)
}
inline void AttachRequest::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.AttachRequest.key)
}
inline ::std::string* AttachRequest::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.AttachRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AttachRequest::release_key() {
  // @@protoc_insertion_point(field_release:perfetto.protos.AttachRequest.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AttachRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.AttachRequest.key)
}

// -------------------------------------------------------------------

// AttachResponse

// optional .perfetto.protos.TraceConfig trace_config = 1;
inline bool AttachResponse::has_trace_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AttachResponse::set_has_trace_config() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AttachResponse::clear_has_trace_config() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AttachResponse::clear_trace_config() {
  if (trace_config_ != NULL) trace_config_->::perfetto::protos::TraceConfig::Clear();
  clear_has_trace_config();
}
inline const ::perfetto::protos::TraceConfig& AttachResponse::trace_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AttachResponse.trace_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return trace_config_ != NULL ? *trace_config_ : *default_instance().trace_config_;
#else
  return trace_config_ != NULL ? *trace_config_ : *default_instance_->trace_config_;
#endif
}
inline ::perfetto::protos::TraceConfig* AttachResponse::mutable_trace_config() {
  set_has_trace_config();
  if (trace_config_ == NULL) {
    trace_config_ = new ::perfetto::protos::TraceConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.AttachResponse.trace_config)
  return trace_config_;
}
inline ::perfetto::protos::TraceConfig* AttachResponse::release_trace_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.AttachResponse.trace_config)
  clear_has_trace_config();
  ::perfetto::protos::TraceConfig* temp = trace_config_;
  trace_config_ = NULL;
  return temp;
}
inline void AttachResponse::set_allocated_trace_config(::perfetto::protos::TraceConfig* trace_config) {
  delete trace_config_;
  trace_config_ = trace_config;
  if (trace_config) {
    set_has_trace_config();
  } else {
    clear_has_trace_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.AttachResponse.trace_config)
}

// -------------------------------------------------------------------

// GetTraceStatsRequest

// -------------------------------------------------------------------

// GetTraceStatsResponse

// optional .perfetto.protos.TraceStats trace_stats = 1;
inline bool GetTraceStatsResponse::has_trace_stats() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetTraceStatsResponse::set_has_trace_stats() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetTraceStatsResponse::clear_has_trace_stats() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetTraceStatsResponse::clear_trace_stats() {
  if (trace_stats_ != NULL) trace_stats_->::perfetto::protos::TraceStats::Clear();
  clear_has_trace_stats();
}
inline const ::perfetto::protos::TraceStats& GetTraceStatsResponse::trace_stats() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetTraceStatsResponse.trace_stats)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return trace_stats_ != NULL ? *trace_stats_ : *default_instance().trace_stats_;
#else
  return trace_stats_ != NULL ? *trace_stats_ : *default_instance_->trace_stats_;
#endif
}
inline ::perfetto::protos::TraceStats* GetTraceStatsResponse::mutable_trace_stats() {
  set_has_trace_stats();
  if (trace_stats_ == NULL) {
    trace_stats_ = new ::perfetto::protos::TraceStats;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GetTraceStatsResponse.trace_stats)
  return trace_stats_;
}
inline ::perfetto::protos::TraceStats* GetTraceStatsResponse::release_trace_stats() {
  // @@protoc_insertion_point(field_release:perfetto.protos.GetTraceStatsResponse.trace_stats)
  clear_has_trace_stats();
  ::perfetto::protos::TraceStats* temp = trace_stats_;
  trace_stats_ = NULL;
  return temp;
}
inline void GetTraceStatsResponse::set_allocated_trace_stats(::perfetto::protos::TraceStats* trace_stats) {
  delete trace_stats_;
  trace_stats_ = trace_stats;
  if (trace_stats) {
    set_has_trace_stats();
  } else {
    clear_has_trace_stats();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.GetTraceStatsResponse.trace_stats)
}

// -------------------------------------------------------------------

// ObserveEventsRequest

// repeated .perfetto.protos.ObservableEvents.Type events_to_observe = 1;
inline int ObserveEventsRequest::events_to_observe_size() const {
  return events_to_observe_.size();
}
inline void ObserveEventsRequest::clear_events_to_observe() {
  events_to_observe_.Clear();
}
inline ::perfetto::protos::ObservableEvents_Type ObserveEventsRequest::events_to_observe(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ObserveEventsRequest.events_to_observe)
  return static_cast< ::perfetto::protos::ObservableEvents_Type >(events_to_observe_.Get(index));
}
inline void ObserveEventsRequest::set_events_to_observe(int index, ::perfetto::protos::ObservableEvents_Type value) {
  assert(::perfetto::protos::ObservableEvents_Type_IsValid(value));
  events_to_observe_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.ObserveEventsRequest.events_to_observe)
}
inline void ObserveEventsRequest::add_events_to_observe(::perfetto::protos::ObservableEvents_Type value) {
  assert(::perfetto::protos::ObservableEvents_Type_IsValid(value));
  events_to_observe_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.ObserveEventsRequest.events_to_observe)
}
inline const ::google::protobuf::RepeatedField<int>&
ObserveEventsRequest::events_to_observe() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.ObserveEventsRequest.events_to_observe)
  return events_to_observe_;
}
inline ::google::protobuf::RepeatedField<int>*
ObserveEventsRequest::mutable_events_to_observe() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.ObserveEventsRequest.events_to_observe)
  return &events_to_observe_;
}

// -------------------------------------------------------------------

// ObserveEventsResponse

// optional .perfetto.protos.ObservableEvents events = 1;
inline bool ObserveEventsResponse::has_events() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObserveEventsResponse::set_has_events() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ObserveEventsResponse::clear_has_events() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ObserveEventsResponse::clear_events() {
  if (events_ != NULL) events_->::perfetto::protos::ObservableEvents::Clear();
  clear_has_events();
}
inline const ::perfetto::protos::ObservableEvents& ObserveEventsResponse::events() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ObserveEventsResponse.events)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return events_ != NULL ? *events_ : *default_instance().events_;
#else
  return events_ != NULL ? *events_ : *default_instance_->events_;
#endif
}
inline ::perfetto::protos::ObservableEvents* ObserveEventsResponse::mutable_events() {
  set_has_events();
  if (events_ == NULL) {
    events_ = new ::perfetto::protos::ObservableEvents;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.ObserveEventsResponse.events)
  return events_;
}
inline ::perfetto::protos::ObservableEvents* ObserveEventsResponse::release_events() {
  // @@protoc_insertion_point(field_release:perfetto.protos.ObserveEventsResponse.events)
  clear_has_events();
  ::perfetto::protos::ObservableEvents* temp = events_;
  events_ = NULL;
  return temp;
}
inline void ObserveEventsResponse::set_allocated_events(::perfetto::protos::ObservableEvents* events) {
  delete events_;
  events_ = events;
  if (events) {
    set_has_events();
  } else {
    clear_has_events();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.ObserveEventsResponse.events)
}

// -------------------------------------------------------------------

// QueryServiceStateRequest

// -------------------------------------------------------------------

// QueryServiceStateResponse

// optional .perfetto.protos.TracingServiceState service_state = 1;
inline bool QueryServiceStateResponse::has_service_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryServiceStateResponse::set_has_service_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryServiceStateResponse::clear_has_service_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryServiceStateResponse::clear_service_state() {
  if (service_state_ != NULL) service_state_->::perfetto::protos::TracingServiceState::Clear();
  clear_has_service_state();
}
inline const ::perfetto::protos::TracingServiceState& QueryServiceStateResponse::service_state() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.QueryServiceStateResponse.service_state)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return service_state_ != NULL ? *service_state_ : *default_instance().service_state_;
#else
  return service_state_ != NULL ? *service_state_ : *default_instance_->service_state_;
#endif
}
inline ::perfetto::protos::TracingServiceState* QueryServiceStateResponse::mutable_service_state() {
  set_has_service_state();
  if (service_state_ == NULL) {
    service_state_ = new ::perfetto::protos::TracingServiceState;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.QueryServiceStateResponse.service_state)
  return service_state_;
}
inline ::perfetto::protos::TracingServiceState* QueryServiceStateResponse::release_service_state() {
  // @@protoc_insertion_point(field_release:perfetto.protos.QueryServiceStateResponse.service_state)
  clear_has_service_state();
  ::perfetto::protos::TracingServiceState* temp = service_state_;
  service_state_ = NULL;
  return temp;
}
inline void QueryServiceStateResponse::set_allocated_service_state(::perfetto::protos::TracingServiceState* service_state) {
  delete service_state_;
  service_state_ = service_state;
  if (service_state) {
    set_has_service_state();
  } else {
    clear_has_service_state();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.QueryServiceStateResponse.service_state)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2fipc_2fconsumer_5fport_2eproto__INCLUDED
// gen_amalgamated begin header: include/perfetto/ext/ipc/deferred.h
// gen_amalgamated begin header: include/perfetto/ext/ipc/async_result.h
// gen_amalgamated begin header: include/perfetto/ext/ipc/basic_types.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_IPC_BASIC_TYPES_H_
#define INCLUDE_PERFETTO_EXT_IPC_BASIC_TYPES_H_

#include <stddef.h>
#include <stdint.h>
#include <sys/types.h>

#include <google/protobuf/message_lite.h>

namespace perfetto {
namespace ipc {

using ProtoMessage = ::google::protobuf::MessageLite;
using ServiceID = uint32_t;
using MethodID = uint32_t;
using ClientID = uint64_t;
using RequestID = uint64_t;

// This determines the maximum size allowed for an IPC message. Trying to send
// or receive a larger message will hit DCHECK(s) and auto-disconnect.
constexpr size_t kIPCBufferSize = 128 * 1024;

constexpr uid_t kInvalidUid = static_cast<uid_t>(-1);
constexpr pid_t kInvalidPid = static_cast<pid_t>(-1);

}  // namespace ipc
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_IPC_BASIC_TYPES_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_IPC_ASYNC_RESULT_H_
#define INCLUDE_PERFETTO_EXT_IPC_ASYNC_RESULT_H_

#include <memory>
#include <type_traits>
#include <utility>

// gen_amalgamated expanded: #include "perfetto/ext/ipc/basic_types.h"

namespace perfetto {
namespace ipc {

// Wraps the result of an asynchronous invocation. This is the equivalent of a
// std::pair<unique_ptr<T>, bool> with syntactic sugar. It is used as callback
// argument by Deferred<T>. T is a ProtoMessage subclass (i.e. generated .pb.h).
template <typename T>
class AsyncResult {
 public:
  static AsyncResult Create() {
    return AsyncResult(std::unique_ptr<T>(new T()));
  }

  AsyncResult(std::unique_ptr<T> msg = nullptr,
              bool has_more = false,
              int fd = -1)
      : msg_(std::move(msg)), has_more_(has_more), fd_(fd) {
    static_assert(std::is_base_of<ProtoMessage, T>::value, "T->ProtoMessage");
  }
  AsyncResult(AsyncResult&&) noexcept = default;
  AsyncResult& operator=(AsyncResult&&) = default;

  bool success() const { return !!msg_; }
  explicit operator bool() const { return success(); }

  bool has_more() const { return has_more_; }
  void set_has_more(bool has_more) { has_more_ = has_more; }

  void set_msg(std::unique_ptr<T> msg) { msg_ = std::move(msg); }
  T* release_msg() { return msg_.release(); }
  T* operator->() { return msg_.get(); }
  T& operator*() { return *msg_; }

  void set_fd(int fd) { fd_ = fd; }
  int fd() const { return fd_; }

 private:
  std::unique_ptr<T> msg_;
  bool has_more_ = false;

  // Optional. Only for messages that convey a file descriptor, for sharing
  // memory across processes.
  int fd_ = -1;
};

}  // namespace ipc
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_IPC_ASYNC_RESULT_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_IPC_DEFERRED_H_
#define INCLUDE_PERFETTO_EXT_IPC_DEFERRED_H_

#include <functional>
#include <memory>
#include <utility>

// gen_amalgamated expanded: #include "perfetto/ext/ipc/async_result.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/basic_types.h"

namespace perfetto {
namespace ipc {

// This class is a wrapper for a callback handling async results.
// The problem this is solving is the following: For each result argument of the
// methods generated from the .proto file:
// - The client wants to see something on which it can Bind() a callback, which
//   is invoked asynchronously once reply is received from the host.
// - The host wants to expose something to user code that implements the IPC
//   methods to allow them to provide an asynchronous reply back to the client.
//   Eventually even more than once, for the case streaming replies.
//
// In both cases we want to make sure that callbacks don't get lost along the
// way. To address this, this class will automatically reject the callbacks
// if they are not resolved at destructor time (or the object is std::move()'d).
//
// The client is supposed to use this class as follows:
//   class GreeterProxy {
//      void SayHello(const HelloRequest&, Deferred<HelloReply> reply)
//   }
//  ...
//  Deferred<HelloReply> reply;
//  reply.Bind([] (AsyncResult<HelloReply> reply) {
//    std::cout << reply.success() ? reply->message : "failure";
//  });
//  host_proxy_instance.SayHello(req, std::move(reply));
//
// The host instead is supposed to use this as follows:
//   class GreeterImpl : public Greeter {
//     void SayHello(const HelloRequest& req, Deferred<HelloReply> reply) {
//        AsyncResult<HelloReply> reply = AsyncResult<HelloReply>::Create();
//        reply->set_greeting("Hello " + req.name)
//        reply.Resolve(std::move(reply));
//     }
//   }
// Or for more complex cases, the deferred object can be std::move()'d outside
// and the reply can continue asynchronously later.

template <typename T>
class Deferred;

class DeferredBase {
 public:
  explicit DeferredBase(
      std::function<void(AsyncResult<ProtoMessage>)> callback = nullptr);

  template <typename T>
  explicit DeferredBase(Deferred<T> other)
      : callback_(std::move(other.callback_)) {}

  ~DeferredBase();
  DeferredBase(DeferredBase&&) noexcept;
  DeferredBase& operator=(DeferredBase&&);
  void Bind(std::function<void(AsyncResult<ProtoMessage>)> callback);
  bool IsBound() const;
  void Resolve(AsyncResult<ProtoMessage>);
  void Reject();

 protected:
  template <typename T>
  friend class Deferred;
  void Move(DeferredBase&);

  std::function<void(AsyncResult<ProtoMessage>)> callback_;
};

template <typename T>  // T : ProtoMessage subclass
class Deferred : public DeferredBase {
 public:
  explicit Deferred(std::function<void(AsyncResult<T>)> callback = nullptr) {
    Bind(std::move(callback));
  }

  // This move constructor (and the similar one in DeferredBase) is meant to be
  // called only by the autogenerated code. The caller has to guarantee that the
  // moved-from and moved-to types match. The behavior is otherwise undefined.
  explicit Deferred(DeferredBase&& other) {
    callback_ = std::move(other.callback_);
    other.callback_ = nullptr;
  }

  void Bind(std::function<void(AsyncResult<T>)> callback) {
    if (!callback)
      return;

    // Here we need a callback adapter to downcast the callback to a generic
    // callback that takes an AsyncResult<ProtoMessage>, so that it can be
    // stored in the base class |callback_|.
    auto callback_adapter = [callback](
                                AsyncResult<ProtoMessage> async_result_base) {
      // Upcast the async_result from <ProtoMessage> -> <T : ProtoMessage>.
      static_assert(std::is_base_of<ProtoMessage, T>::value, "T:ProtoMessage");
      AsyncResult<T> async_result(
          std::unique_ptr<T>(static_cast<T*>(async_result_base.release_msg())),
          async_result_base.has_more(), async_result_base.fd());
      callback(std::move(async_result));
    };
    DeferredBase::Bind(callback_adapter);
  }

  // If no more messages are expected, |callback_| is released.
  void Resolve(AsyncResult<T> async_result) {
    // Convert the |async_result| to the generic base one (T -> ProtoMessage).
    AsyncResult<ProtoMessage> async_result_base(
        std::unique_ptr<ProtoMessage>(async_result.release_msg()),
        async_result.has_more(), async_result.fd());
    DeferredBase::Resolve(std::move(async_result_base));
  }
};

}  // namespace ipc
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_IPC_DEFERRED_H_
// gen_amalgamated begin header: include/perfetto/ext/ipc/service.h
// gen_amalgamated begin header: include/perfetto/ext/base/scoped_file.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_BASE_SCOPED_FILE_H_
#define INCLUDE_PERFETTO_EXT_BASE_SCOPED_FILE_H_

// gen_amalgamated expanded: #include "perfetto/base/build_config.h"

#include <fcntl.h>
#include <stdio.h>

#if PERFETTO_BUILDFLAG(PERFETTO_OS_WIN) && \
    !PERFETTO_BUILDFLAG(PERFETTO_COMPILER_GCC)
#include <corecrt_io.h>
typedef int mode_t;
#else
#include <dirent.h>
#include <unistd.h>
#endif

#include <string>

// gen_amalgamated expanded: #include "perfetto/base/logging.h"

namespace perfetto {
namespace base {

constexpr mode_t kInvalidMode = static_cast<mode_t>(-1);

// RAII classes for auto-releasing fds and dirs.
template <typename T,
          int (*CloseFunction)(T),
          T InvalidValue,
          bool CheckClose = true>
class ScopedResource {
 public:
  explicit ScopedResource(T t = InvalidValue) : t_(t) {}
  ScopedResource(ScopedResource&& other) noexcept {
    t_ = other.t_;
    other.t_ = InvalidValue;
  }
  ScopedResource& operator=(ScopedResource&& other) {
    reset(other.t_);
    other.t_ = InvalidValue;
    return *this;
  }
  T get() const { return t_; }
  T operator*() const { return t_; }
  explicit operator bool() const { return t_ != InvalidValue; }
  void reset(T r = InvalidValue) {
    if (t_ != InvalidValue) {
      int res = CloseFunction(t_);
      if (CheckClose)
        PERFETTO_CHECK(res == 0);
    }
    t_ = r;
  }
  T release() {
    T t = t_;
    t_ = InvalidValue;
    return t;
  }
  ~ScopedResource() { reset(InvalidValue); }

 private:
  ScopedResource(const ScopedResource&) = delete;
  ScopedResource& operator=(const ScopedResource&) = delete;

  T t_;
};

using ScopedFile = ScopedResource<int, close, -1>;
inline static ScopedFile OpenFile(const std::string& path,
                                  int flags,
                                  mode_t mode = kInvalidMode) {
  PERFETTO_DCHECK((flags & O_CREAT) == 0 || mode != kInvalidMode);
#if PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)
  ScopedFile fd(open(path.c_str(), flags, mode));
#else
  // Always open a ScopedFile with O_CLOEXEC so we can safely fork and exec.
  ScopedFile fd(open(path.c_str(), flags | O_CLOEXEC, mode));
#endif
  return fd;
}
#if !PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)
using ScopedDir = ScopedResource<DIR*, closedir, nullptr>;
#endif

using ScopedFstream = ScopedResource<FILE*, fclose, nullptr>;

}  // namespace base
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_BASE_SCOPED_FILE_H_
// gen_amalgamated begin header: include/perfetto/ext/ipc/client_info.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_IPC_CLIENT_INFO_H_
#define INCLUDE_PERFETTO_EXT_IPC_CLIENT_INFO_H_

#include <unistd.h>

// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/basic_types.h"

namespace perfetto {
namespace ipc {

// Passed to Service(s) to identify remote clients.
class ClientInfo {
 public:
  ClientInfo() = default;
  ClientInfo(ClientID client_id, uid_t uid)
      : client_id_(client_id), uid_(uid) {}

  bool operator==(const ClientInfo& other) const {
    return (client_id_ == other.client_id_ && uid_ == other.uid_);
  }
  bool operator!=(const ClientInfo& other) const { return !(*this == other); }

  // For map<> and other sorted containers.
  bool operator<(const ClientInfo& other) const {
    PERFETTO_DCHECK(client_id_ != other.client_id_ || *this == other);
    return client_id_ < other.client_id_;
  }

  bool is_valid() const { return client_id_ != 0; }

  // A monotonic counter.
  ClientID client_id() const { return client_id_; }

  // Posix User ID. Comes from the kernel, can be trusted.
  uid_t uid() const { return uid_; }

 private:
  ClientID client_id_ = 0;
  uid_t uid_ = kInvalidUid;
};

}  // namespace ipc
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_IPC_CLIENT_INFO_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_IPC_SERVICE_H_
#define INCLUDE_PERFETTO_EXT_IPC_SERVICE_H_

// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/scoped_file.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/client_info.h"

namespace perfetto {
namespace ipc {

class ServiceDescriptor;

// The base class for all the autogenerated host-side service interfaces.
class Service {
 public:
  virtual ~Service();

  // Overridden by the auto-generated class. Provides the list of methods and
  // the protobuf (de)serialization functions for their arguments.
  virtual const ServiceDescriptor& GetDescriptor() = 0;

  // Invoked when a remote client disconnects. Use client_info() to obtain
  // details about the client that disconnected.
  virtual void OnClientDisconnected() {}

  // Returns the ClientInfo for the current IPC request. Returns an invalid
  // ClientInfo if called outside the scope of an IPC method.
  const ClientInfo& client_info() {
    PERFETTO_DCHECK(client_info_.is_valid());
    return client_info_;
  }

  base::ScopedFile TakeReceivedFD() {
    if (received_fd_)
      return std::move(*received_fd_);
    return base::ScopedFile();
  }

 private:
  friend class HostImpl;
  ClientInfo client_info_;
  // This is a pointer because the received fd needs to remain owned by the
  // ClientConnection, as we will provide it to all method invocations
  // for that client until one of them calls Service::TakeReceivedFD.
  //
  // Different clients might have sent different FDs so this cannot be owned
  // here.
  //
  // Note that this means that there can always only be one outstanding
  // invocation per client that supplies an FD and the client needs to
  // wait for this one to return before calling another one.
  base::ScopedFile* received_fd_;
};

}  // namespace ipc
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_IPC_SERVICE_H_
// gen_amalgamated begin header: include/perfetto/ext/ipc/service_descriptor.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_IPC_SERVICE_DESCRIPTOR_H_
#define INCLUDE_PERFETTO_EXT_IPC_SERVICE_DESCRIPTOR_H_

#include <functional>
#include <string>
#include <utility>
#include <vector>

// gen_amalgamated expanded: #include "perfetto/ext/ipc/basic_types.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/deferred.h"

namespace perfetto {
namespace ipc {

class Service;

// This is a pure data structure which holds factory methods and strings for the
// services and their methods that get generated in the .h/.cc files.
// Each autogenerated class has a GetDescriptor() method that returns one
// instance of these and allows both client and hosts to map service and method
// names to IDs and provide function pointers to the protobuf decoder fuctions.
class ServiceDescriptor {
 public:
  struct Method {
    const char* name;

    // DecoderFunc is pointer to a function that takes a string in input
    // containing protobuf encoded data and returns a decoded protobuf message.
    using DecoderFunc = std::unique_ptr<ProtoMessage> (*)(const std::string&);

    // Function pointer to decode the request argument of the method.
    DecoderFunc request_proto_decoder;

    // Function pointer to decoded the reply argument of the method.
    DecoderFunc reply_proto_decoder;

    // Function pointer that dispatches the generic request to the corresponding
    // method implementation.
    using InvokerFunc = void (*)(Service*,
                                 const ProtoMessage& /* request_args */,
                                 DeferredBase /* deferred_reply */);
    InvokerFunc invoker;
  };

  const char* service_name = nullptr;

  // Note that methods order is not stable. Client and Host might have different
  // method indexes, depending on their versions. The Client can't just rely
  // on the indexes and has to keep a [string -> remote index] translation map.
  std::vector<Method> methods;
};

}  // namespace ipc
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_IPC_SERVICE_DESCRIPTOR_H_
// gen_amalgamated begin header: include/perfetto/ext/ipc/service_proxy.h
// gen_amalgamated begin header: include/perfetto/ext/base/weak_ptr.h
// gen_amalgamated begin header: include/perfetto/ext/base/thread_checker.h
// gen_amalgamated begin header: include/perfetto/ext/base/utils.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_BASE_UTILS_H_
#define INCLUDE_PERFETTO_EXT_BASE_UTILS_H_

// gen_amalgamated expanded: #include "perfetto/base/build_config.h"
// gen_amalgamated expanded: #include "perfetto/base/compiler.h"

#include <errno.h>
#include <stddef.h>
#include <stdlib.h>
#if !PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)
#include <sys/types.h>
#endif

#define PERFETTO_EINTR(x)                                   \
  ({                                                        \
    decltype(x) eintr_wrapper_result;                       \
    do {                                                    \
      eintr_wrapper_result = (x);                           \
    } while (eintr_wrapper_result == -1 && errno == EINTR); \
    eintr_wrapper_result;                                   \
  })

#if PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)
// TODO(brucedawson) - create a ::perfetto::base::IOSize to replace this.
#if defined(_WIN64)
using ssize_t = __int64;
#else
using ssize_t = long;
#endif
#endif

namespace perfetto {
namespace base {

#if !PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)
constexpr uid_t kInvalidUid = static_cast<uid_t>(-1);
constexpr pid_t kInvalidPid = static_cast<pid_t>(-1);
#endif

constexpr size_t kPageSize = 4096;
constexpr size_t kMaxCpus = 128;

template <typename T>
constexpr size_t ArraySize(const T& array) {
  return sizeof(array) / sizeof(array[0]);
}

// Function object which invokes 'free' on its parameter, which must be
// a pointer. Can be used to store malloc-allocated pointers in std::unique_ptr:
//
// std::unique_ptr<int, base::FreeDeleter> foo_ptr(
//     static_cast<int*>(malloc(sizeof(int))));
struct FreeDeleter {
  inline void operator()(void* ptr) const { free(ptr); }
};

template <typename T>
constexpr T AssumeLittleEndian(T value) {
  static_assert(__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__,
                "Unimplemented on big-endian archs");
  return value;
}

// Round up |size| to a multiple of |alignment| (must be a power of two).
template <size_t alignment>
constexpr size_t AlignUp(size_t size) {
  static_assert((alignment & (alignment - 1)) == 0, "alignment must be a pow2");
  return (size + alignment - 1) & ~(alignment - 1);
}

inline bool IsAgain(int err) {
  return err == EAGAIN || err == EWOULDBLOCK;
}

}  // namespace base
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_BASE_UTILS_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_BASE_THREAD_CHECKER_H_
#define INCLUDE_PERFETTO_EXT_BASE_THREAD_CHECKER_H_

// gen_amalgamated expanded: #include "perfetto/base/build_config.h"

#if !PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)
#include <pthread.h>
#endif
#include <atomic>

// gen_amalgamated expanded: #include "perfetto/base/export.h"
// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/utils.h"

namespace perfetto {
namespace base {

#if PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)
using ThreadID = unsigned long;
#else
using ThreadID = pthread_t;
#endif

class PERFETTO_EXPORT ThreadChecker {
 public:
  ThreadChecker();
  ~ThreadChecker();
  ThreadChecker(const ThreadChecker&);
  ThreadChecker& operator=(const ThreadChecker&);
  bool CalledOnValidThread() const PERFETTO_WARN_UNUSED_RESULT;
  void DetachFromThread();

 private:
  mutable std::atomic<ThreadID> thread_id_;
};

#if PERFETTO_DCHECK_IS_ON() && !PERFETTO_BUILDFLAG(PERFETTO_CHROMIUM_BUILD)
// TODO(primiano) Use Chromium's thread checker in Chromium.
#define PERFETTO_THREAD_CHECKER(name) base::ThreadChecker name;
#define PERFETTO_DCHECK_THREAD(name) \
  PERFETTO_DCHECK((name).CalledOnValidThread())
#define PERFETTO_DETACH_FROM_THREAD(name) (name).DetachFromThread()
#else
#define PERFETTO_THREAD_CHECKER(name)
#define PERFETTO_DCHECK_THREAD(name)
#define PERFETTO_DETACH_FROM_THREAD(name)
#endif  // PERFETTO_DCHECK_IS_ON()

}  // namespace base
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_BASE_THREAD_CHECKER_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_BASE_WEAK_PTR_H_
#define INCLUDE_PERFETTO_EXT_BASE_WEAK_PTR_H_

// gen_amalgamated expanded: #include "perfetto/ext/base/thread_checker.h"

#include <memory>

namespace perfetto {
namespace base {

// A simple WeakPtr for single-threaded cases.
// Generally keep the WeakPtrFactory as last fields in classes: it makes the
// WeakPtr(s) invalidate as first thing in the class dtor.
// Usage:
// class MyClass {
//  MyClass() : weak_factory_(this) {}
//  WeakPtr<MyClass> GetWeakPtr() { return weak_factory_.GetWeakPtr(); }
//
// private:
//  WeakPtrFactory<MyClass> weak_factory_;
// }
//
// int main() {
//  std::unique_ptr<MyClass> foo(new MyClass);
//  auto wptr = foo.GetWeakPtr();
//  ASSERT_TRUE(wptr);
//  ASSERT_EQ(foo.get(), wptr->get());
//  foo.reset();
//  ASSERT_FALSE(wptr);
//  ASSERT_EQ(nullptr, wptr->get());
// }

template <typename T>
class WeakPtrFactory;  // Forward declaration, defined below.

template <typename T>
class WeakPtr {
 public:
  WeakPtr() {}
  WeakPtr(const WeakPtr&) = default;
  WeakPtr& operator=(const WeakPtr&) = default;
  WeakPtr(WeakPtr&&) = default;
  WeakPtr& operator=(WeakPtr&&) = default;

  T* get() const {
    PERFETTO_DCHECK_THREAD(thread_checker);
    return handle_ ? *handle_.get() : nullptr;
  }
  T* operator->() const { return get(); }
  T& operator*() const { return *get(); }

  explicit operator bool() const { return !!get(); }

 private:
  friend class WeakPtrFactory<T>;
  explicit WeakPtr(const std::shared_ptr<T*>& handle) : handle_(handle) {}

  std::shared_ptr<T*> handle_;
  PERFETTO_THREAD_CHECKER(thread_checker)
};

template <typename T>
class WeakPtrFactory {
 public:
  explicit WeakPtrFactory(T* owner)
      : weak_ptr_(std::shared_ptr<T*>(new T* {owner})) {
    PERFETTO_DCHECK_THREAD(thread_checker);
  }

  ~WeakPtrFactory() {
    PERFETTO_DCHECK_THREAD(thread_checker);
    *(weak_ptr_.handle_.get()) = nullptr;
  }

  // Can be safely called on any thread, since it simply copies |weak_ptr_|.
  // Note that any accesses to the returned pointer need to be made on the
  // thread that created the factory.
  WeakPtr<T> GetWeakPtr() const { return weak_ptr_; }

 private:
  WeakPtrFactory(const WeakPtrFactory&) = delete;
  WeakPtrFactory& operator=(const WeakPtrFactory&) = delete;

  WeakPtr<T> weak_ptr_;
  PERFETTO_THREAD_CHECKER(thread_checker)
};

}  // namespace base
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_BASE_WEAK_PTR_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_IPC_SERVICE_PROXY_H_
#define INCLUDE_PERFETTO_EXT_IPC_SERVICE_PROXY_H_

// gen_amalgamated expanded: #include "perfetto/ext/ipc/basic_types.h"

#include <assert.h>

#include <functional>
#include <map>
#include <memory>
#include <string>

// gen_amalgamated expanded: #include "perfetto/ext/base/weak_ptr.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/deferred.h"

namespace perfetto {
namespace ipc {

class Client;
class ServiceDescriptor;

// The base class for the client-side autogenerated stubs that forward method
// invocations to the host. All the methods of this class are meant to be called
// only by the autogenerated code.
class ServiceProxy {
 public:
  class EventListener {
   public:
    virtual ~EventListener();

    // Called once after Client::BindService() if the ServiceProxy has been
    // successfully bound to the host. It is possible to start sending IPC
    // requests soon after this.
    virtual void OnConnect() {}

    // Called if the connection fails to be established or drops after having
    // been established.
    virtual void OnDisconnect() {}
  };

  // Guarantees that no callback will happen after this object has been
  // destroyed. The caller has to guarantee that the |event_listener| stays
  // alive at least as long as the ServiceProxy instance.
  explicit ServiceProxy(EventListener*);
  virtual ~ServiceProxy();

  void InitializeBinding(base::WeakPtr<Client>,
                         ServiceID,
                         std::map<std::string, MethodID>);

  // Called by the IPC methods in the autogenerated classes.
  void BeginInvoke(const std::string& method_name,
                   const ProtoMessage& request,
                   DeferredBase reply,
                   int fd = -1);

  // Called by ClientImpl.
  // |reply_args| == nullptr means request failure.
  void EndInvoke(RequestID,
                 std::unique_ptr<ProtoMessage> reply_arg,
                 bool has_more);

  // Called by ClientImpl.
  void OnConnect(bool success);
  void OnDisconnect();
  bool connected() const { return service_id_ != 0; }

  base::WeakPtr<ServiceProxy> GetWeakPtr() const;

  // Implemented by the autogenerated class.
  virtual const ServiceDescriptor& GetDescriptor() = 0;

 private:
  base::WeakPtr<Client> client_;
  ServiceID service_id_ = 0;
  std::map<std::string, MethodID> remote_method_ids_;
  std::map<RequestID, DeferredBase> pending_callbacks_;
  EventListener* const event_listener_;
  base::WeakPtrFactory<ServiceProxy> weak_ptr_factory_;  // Keep last.
};

}  // namespace ipc
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_IPC_SERVICE_PROXY_H_
// DO NOT EDIT. Autogenerated by Perfetto IPC
#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_IPC_CONSUMER_PORT_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_IPC_CONSUMER_PORT_PROTO_H_

// gen_amalgamated expanded: #include "protos/perfetto/ipc/consumer_port.pb.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/deferred.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/service.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/service_descriptor.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/service_proxy.h"


namespace perfetto {
namespace protos {

class ConsumerPort : public ::perfetto::ipc::Service {
 private:
  static ::perfetto::ipc::ServiceDescriptor* NewDescriptor();

 public:
  ~ConsumerPort() override;

  static const ::perfetto::ipc::ServiceDescriptor& GetDescriptorStatic();

  // Service implementation.
  const ::perfetto::ipc::ServiceDescriptor& GetDescriptor() override;

  // Methods from the .proto file
  using DeferredEnableTracingResponse = ::perfetto::ipc::Deferred<EnableTracingResponse>;
  virtual void EnableTracing(const EnableTracingRequest&, DeferredEnableTracingResponse) = 0;

  using DeferredDisableTracingResponse = ::perfetto::ipc::Deferred<DisableTracingResponse>;
  virtual void DisableTracing(const DisableTracingRequest&, DeferredDisableTracingResponse) = 0;

  using DeferredReadBuffersResponse = ::perfetto::ipc::Deferred<ReadBuffersResponse>;
  virtual void ReadBuffers(const ReadBuffersRequest&, DeferredReadBuffersResponse) = 0;

  using DeferredFreeBuffersResponse = ::perfetto::ipc::Deferred<FreeBuffersResponse>;
  virtual void FreeBuffers(const FreeBuffersRequest&, DeferredFreeBuffersResponse) = 0;

  using DeferredFlushResponse = ::perfetto::ipc::Deferred<FlushResponse>;
  virtual void Flush(const FlushRequest&, DeferredFlushResponse) = 0;

  using DeferredStartTracingResponse = ::perfetto::ipc::Deferred<StartTracingResponse>;
  virtual void StartTracing(const StartTracingRequest&, DeferredStartTracingResponse) = 0;

  using DeferredChangeTraceConfigResponse = ::perfetto::ipc::Deferred<ChangeTraceConfigResponse>;
  virtual void ChangeTraceConfig(const ChangeTraceConfigRequest&, DeferredChangeTraceConfigResponse) = 0;

  using DeferredDetachResponse = ::perfetto::ipc::Deferred<DetachResponse>;
  virtual void Detach(const DetachRequest&, DeferredDetachResponse) = 0;

  using DeferredAttachResponse = ::perfetto::ipc::Deferred<AttachResponse>;
  virtual void Attach(const AttachRequest&, DeferredAttachResponse) = 0;

  using DeferredGetTraceStatsResponse = ::perfetto::ipc::Deferred<GetTraceStatsResponse>;
  virtual void GetTraceStats(const GetTraceStatsRequest&, DeferredGetTraceStatsResponse) = 0;

  using DeferredObserveEventsResponse = ::perfetto::ipc::Deferred<ObserveEventsResponse>;
  virtual void ObserveEvents(const ObserveEventsRequest&, DeferredObserveEventsResponse) = 0;

  using DeferredQueryServiceStateResponse = ::perfetto::ipc::Deferred<QueryServiceStateResponse>;
  virtual void QueryServiceState(const QueryServiceStateRequest&, DeferredQueryServiceStateResponse) = 0;

};


class ConsumerPortProxy : public ::perfetto::ipc::ServiceProxy {
 public:
   explicit ConsumerPortProxy(::perfetto::ipc::ServiceProxy::EventListener*);
   ~ConsumerPortProxy() override;

  // ServiceProxy implementation.
  const ::perfetto::ipc::ServiceDescriptor& GetDescriptor() override;

  // Methods from the .proto file
  using DeferredEnableTracingResponse = ::perfetto::ipc::Deferred<EnableTracingResponse>;
  void EnableTracing(const EnableTracingRequest&, DeferredEnableTracingResponse, int fd = -1);

  using DeferredDisableTracingResponse = ::perfetto::ipc::Deferred<DisableTracingResponse>;
  void DisableTracing(const DisableTracingRequest&, DeferredDisableTracingResponse, int fd = -1);

  using DeferredReadBuffersResponse = ::perfetto::ipc::Deferred<ReadBuffersResponse>;
  void ReadBuffers(const ReadBuffersRequest&, DeferredReadBuffersResponse, int fd = -1);

  using DeferredFreeBuffersResponse = ::perfetto::ipc::Deferred<FreeBuffersResponse>;
  void FreeBuffers(const FreeBuffersRequest&, DeferredFreeBuffersResponse, int fd = -1);

  using DeferredFlushResponse = ::perfetto::ipc::Deferred<FlushResponse>;
  void Flush(const FlushRequest&, DeferredFlushResponse, int fd = -1);

  using DeferredStartTracingResponse = ::perfetto::ipc::Deferred<StartTracingResponse>;
  void StartTracing(const StartTracingRequest&, DeferredStartTracingResponse, int fd = -1);

  using DeferredChangeTraceConfigResponse = ::perfetto::ipc::Deferred<ChangeTraceConfigResponse>;
  void ChangeTraceConfig(const ChangeTraceConfigRequest&, DeferredChangeTraceConfigResponse, int fd = -1);

  using DeferredDetachResponse = ::perfetto::ipc::Deferred<DetachResponse>;
  void Detach(const DetachRequest&, DeferredDetachResponse, int fd = -1);

  using DeferredAttachResponse = ::perfetto::ipc::Deferred<AttachResponse>;
  void Attach(const AttachRequest&, DeferredAttachResponse, int fd = -1);

  using DeferredGetTraceStatsResponse = ::perfetto::ipc::Deferred<GetTraceStatsResponse>;
  void GetTraceStats(const GetTraceStatsRequest&, DeferredGetTraceStatsResponse, int fd = -1);

  using DeferredObserveEventsResponse = ::perfetto::ipc::Deferred<ObserveEventsResponse>;
  void ObserveEvents(const ObserveEventsRequest&, DeferredObserveEventsResponse, int fd = -1);

  using DeferredQueryServiceStateResponse = ::perfetto::ipc::Deferred<QueryServiceStateResponse>;
  void QueryServiceState(const QueryServiceStateRequest&, DeferredQueryServiceStateResponse, int fd = -1);

};

}  // namespace protos
}  // namespace perfetto

#endif  // PERFETTO_PROTOS_PROTOS_PERFETTO_IPC_CONSUMER_PORT_PROTO_H_
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/ipc/producer_port.pb.h
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/common/commit_data_request.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/common/commit_data_request.proto

#ifndef PROTOBUF_protos_2fperfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();

class CommitDataRequest;
class CommitDataRequest_ChunkToPatch;
class CommitDataRequest_ChunkToPatch_Patch;
class CommitDataRequest_ChunksToMove;

// ===================================================================

class CommitDataRequest_ChunksToMove : public ::google::protobuf::MessageLite {
 public:
  CommitDataRequest_ChunksToMove();
  virtual ~CommitDataRequest_ChunksToMove();

  CommitDataRequest_ChunksToMove(const CommitDataRequest_ChunksToMove& from);

  inline CommitDataRequest_ChunksToMove& operator=(const CommitDataRequest_ChunksToMove& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const CommitDataRequest_ChunksToMove& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommitDataRequest_ChunksToMove* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommitDataRequest_ChunksToMove* other);

  // implements Message ----------------------------------------------

  inline CommitDataRequest_ChunksToMove* New() const { return New(NULL); }

  CommitDataRequest_ChunksToMove* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommitDataRequest_ChunksToMove& from);
  void MergeFrom(const CommitDataRequest_ChunksToMove& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommitDataRequest_ChunksToMove* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 page = 1;
  bool has_page() const;
  void clear_page();
  static const int kPageFieldNumber = 1;
  ::google::protobuf::uint32 page() const;
  void set_page(::google::protobuf::uint32 value);

  // optional uint32 chunk = 2;
  bool has_chunk() const;
  void clear_chunk();
  static const int kChunkFieldNumber = 2;
  ::google::protobuf::uint32 chunk() const;
  void set_chunk(::google::protobuf::uint32 value);

  // optional uint32 target_buffer = 3;
  bool has_target_buffer() const;
  void clear_target_buffer();
  static const int kTargetBufferFieldNumber = 3;
  ::google::protobuf::uint32 target_buffer() const;
  void set_target_buffer(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.CommitDataRequest.ChunksToMove)
 private:
  inline void set_has_page();
  inline void clear_has_page();
  inline void set_has_chunk();
  inline void clear_has_chunk();
  inline void set_has_target_buffer();
  inline void clear_has_target_buffer();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 page_;
  ::google::protobuf::uint32 chunk_;
  ::google::protobuf::uint32 target_buffer_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();

  void InitAsDefaultInstance();
  static CommitDataRequest_ChunksToMove* default_instance_;
};
// -------------------------------------------------------------------

class CommitDataRequest_ChunkToPatch_Patch : public ::google::protobuf::MessageLite {
 public:
  CommitDataRequest_ChunkToPatch_Patch();
  virtual ~CommitDataRequest_ChunkToPatch_Patch();

  CommitDataRequest_ChunkToPatch_Patch(const CommitDataRequest_ChunkToPatch_Patch& from);

  inline CommitDataRequest_ChunkToPatch_Patch& operator=(const CommitDataRequest_ChunkToPatch_Patch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const CommitDataRequest_ChunkToPatch_Patch& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommitDataRequest_ChunkToPatch_Patch* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommitDataRequest_ChunkToPatch_Patch* other);

  // implements Message ----------------------------------------------

  inline CommitDataRequest_ChunkToPatch_Patch* New() const { return New(NULL); }

  CommitDataRequest_ChunkToPatch_Patch* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommitDataRequest_ChunkToPatch_Patch& from);
  void MergeFrom(const CommitDataRequest_ChunkToPatch_Patch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommitDataRequest_ChunkToPatch_Patch* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 offset = 1;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 1;
  ::google::protobuf::uint32 offset() const;
  void set_offset(::google::protobuf::uint32 value);

  // optional bytes data = 2;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:perfetto.protos.CommitDataRequest.ChunkToPatch.Patch)
 private:
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::uint32 offset_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();

  void InitAsDefaultInstance();
  static CommitDataRequest_ChunkToPatch_Patch* default_instance_;
};
// -------------------------------------------------------------------

class CommitDataRequest_ChunkToPatch : public ::google::protobuf::MessageLite {
 public:
  CommitDataRequest_ChunkToPatch();
  virtual ~CommitDataRequest_ChunkToPatch();

  CommitDataRequest_ChunkToPatch(const CommitDataRequest_ChunkToPatch& from);

  inline CommitDataRequest_ChunkToPatch& operator=(const CommitDataRequest_ChunkToPatch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const CommitDataRequest_ChunkToPatch& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommitDataRequest_ChunkToPatch* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommitDataRequest_ChunkToPatch* other);

  // implements Message ----------------------------------------------

  inline CommitDataRequest_ChunkToPatch* New() const { return New(NULL); }

  CommitDataRequest_ChunkToPatch* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommitDataRequest_ChunkToPatch& from);
  void MergeFrom(const CommitDataRequest_ChunkToPatch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommitDataRequest_ChunkToPatch* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CommitDataRequest_ChunkToPatch_Patch Patch;

  // accessors -------------------------------------------------------

  // optional uint32 target_buffer = 1;
  bool has_target_buffer() const;
  void clear_target_buffer();
  static const int kTargetBufferFieldNumber = 1;
  ::google::protobuf::uint32 target_buffer() const;
  void set_target_buffer(::google::protobuf::uint32 value);

  // optional uint32 writer_id = 2;
  bool has_writer_id() const;
  void clear_writer_id();
  static const int kWriterIdFieldNumber = 2;
  ::google::protobuf::uint32 writer_id() const;
  void set_writer_id(::google::protobuf::uint32 value);

  // optional uint32 chunk_id = 3;
  bool has_chunk_id() const;
  void clear_chunk_id();
  static const int kChunkIdFieldNumber = 3;
  ::google::protobuf::uint32 chunk_id() const;
  void set_chunk_id(::google::protobuf::uint32 value);

  // repeated .perfetto.protos.CommitDataRequest.ChunkToPatch.Patch patches = 4;
  int patches_size() const;
  void clear_patches();
  static const int kPatchesFieldNumber = 4;
  const ::perfetto::protos::CommitDataRequest_ChunkToPatch_Patch& patches(int index) const;
  ::perfetto::protos::CommitDataRequest_ChunkToPatch_Patch* mutable_patches(int index);
  ::perfetto::protos::CommitDataRequest_ChunkToPatch_Patch* add_patches();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::CommitDataRequest_ChunkToPatch_Patch >*
      mutable_patches();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::CommitDataRequest_ChunkToPatch_Patch >&
      patches() const;

  // optional bool has_more_patches = 5;
  bool has_has_more_patches() const;
  void clear_has_more_patches();
  static const int kHasMorePatchesFieldNumber = 5;
  bool has_more_patches() const;
  void set_has_more_patches(bool value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.CommitDataRequest.ChunkToPatch)
 private:
  inline void set_has_target_buffer();
  inline void clear_has_target_buffer();
  inline void set_has_writer_id();
  inline void clear_has_writer_id();
  inline void set_has_chunk_id();
  inline void clear_has_chunk_id();
  inline void set_has_has_more_patches();
  inline void clear_has_has_more_patches();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 target_buffer_;
  ::google::protobuf::uint32 writer_id_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::CommitDataRequest_ChunkToPatch_Patch > patches_;
  ::google::protobuf::uint32 chunk_id_;
  bool has_more_patches_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();

  void InitAsDefaultInstance();
  static CommitDataRequest_ChunkToPatch* default_instance_;
};
// -------------------------------------------------------------------

class CommitDataRequest : public ::google::protobuf::MessageLite {
 public:
  CommitDataRequest();
  virtual ~CommitDataRequest();

  CommitDataRequest(const CommitDataRequest& from);

  inline CommitDataRequest& operator=(const CommitDataRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const CommitDataRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommitDataRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommitDataRequest* other);

  // implements Message ----------------------------------------------

  inline CommitDataRequest* New() const { return New(NULL); }

  CommitDataRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommitDataRequest& from);
  void MergeFrom(const CommitDataRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommitDataRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CommitDataRequest_ChunksToMove ChunksToMove;
  typedef CommitDataRequest_ChunkToPatch ChunkToPatch;

  // accessors -------------------------------------------------------

  // repeated .perfetto.protos.CommitDataRequest.ChunksToMove chunks_to_move = 1;
  int chunks_to_move_size() const;
  void clear_chunks_to_move();
  static const int kChunksToMoveFieldNumber = 1;
  const ::perfetto::protos::CommitDataRequest_ChunksToMove& chunks_to_move(int index) const;
  ::perfetto::protos::CommitDataRequest_ChunksToMove* mutable_chunks_to_move(int index);
  ::perfetto::protos::CommitDataRequest_ChunksToMove* add_chunks_to_move();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::CommitDataRequest_ChunksToMove >*
      mutable_chunks_to_move();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::CommitDataRequest_ChunksToMove >&
      chunks_to_move() const;

  // repeated .perfetto.protos.CommitDataRequest.ChunkToPatch chunks_to_patch = 2;
  int chunks_to_patch_size() const;
  void clear_chunks_to_patch();
  static const int kChunksToPatchFieldNumber = 2;
  const ::perfetto::protos::CommitDataRequest_ChunkToPatch& chunks_to_patch(int index) const;
  ::perfetto::protos::CommitDataRequest_ChunkToPatch* mutable_chunks_to_patch(int index);
  ::perfetto::protos::CommitDataRequest_ChunkToPatch* add_chunks_to_patch();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::CommitDataRequest_ChunkToPatch >*
      mutable_chunks_to_patch();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::CommitDataRequest_ChunkToPatch >&
      chunks_to_patch() const;

  // optional uint64 flush_request_id = 3;
  bool has_flush_request_id() const;
  void clear_flush_request_id();
  static const int kFlushRequestIdFieldNumber = 3;
  ::google::protobuf::uint64 flush_request_id() const;
  void set_flush_request_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.CommitDataRequest)
 private:
  inline void set_has_flush_request_id();
  inline void clear_has_flush_request_id();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::CommitDataRequest_ChunksToMove > chunks_to_move_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::CommitDataRequest_ChunkToPatch > chunks_to_patch_;
  ::google::protobuf::uint64 flush_request_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();

  void InitAsDefaultInstance();
  static CommitDataRequest* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// CommitDataRequest_ChunksToMove

// optional uint32 page = 1;
inline bool CommitDataRequest_ChunksToMove::has_page() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommitDataRequest_ChunksToMove::set_has_page() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommitDataRequest_ChunksToMove::clear_has_page() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommitDataRequest_ChunksToMove::clear_page() {
  page_ = 0u;
  clear_has_page();
}
inline ::google::protobuf::uint32 CommitDataRequest_ChunksToMove::page() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.CommitDataRequest.ChunksToMove.page)
  return page_;
}
inline void CommitDataRequest_ChunksToMove::set_page(::google::protobuf::uint32 value) {
  set_has_page();
  page_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.CommitDataRequest.ChunksToMove.page)
}

// optional uint32 chunk = 2;
inline bool CommitDataRequest_ChunksToMove::has_chunk() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommitDataRequest_ChunksToMove::set_has_chunk() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommitDataRequest_ChunksToMove::clear_has_chunk() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommitDataRequest_ChunksToMove::clear_chunk() {
  chunk_ = 0u;
  clear_has_chunk();
}
inline ::google::protobuf::uint32 CommitDataRequest_ChunksToMove::chunk() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.CommitDataRequest.ChunksToMove.chunk)
  return chunk_;
}
inline void CommitDataRequest_ChunksToMove::set_chunk(::google::protobuf::uint32 value) {
  set_has_chunk();
  chunk_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.CommitDataRequest.ChunksToMove.chunk)
}

// optional uint32 target_buffer = 3;
inline bool CommitDataRequest_ChunksToMove::has_target_buffer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommitDataRequest_ChunksToMove::set_has_target_buffer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommitDataRequest_ChunksToMove::clear_has_target_buffer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommitDataRequest_ChunksToMove::clear_target_buffer() {
  target_buffer_ = 0u;
  clear_has_target_buffer();
}
inline ::google::protobuf::uint32 CommitDataRequest_ChunksToMove::target_buffer() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.CommitDataRequest.ChunksToMove.target_buffer)
  return target_buffer_;
}
inline void CommitDataRequest_ChunksToMove::set_target_buffer(::google::protobuf::uint32 value) {
  set_has_target_buffer();
  target_buffer_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.CommitDataRequest.ChunksToMove.target_buffer)
}

// -------------------------------------------------------------------

// CommitDataRequest_ChunkToPatch_Patch

// optional uint32 offset = 1;
inline bool CommitDataRequest_ChunkToPatch_Patch::has_offset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommitDataRequest_ChunkToPatch_Patch::set_has_offset() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommitDataRequest_ChunkToPatch_Patch::clear_has_offset() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommitDataRequest_ChunkToPatch_Patch::clear_offset() {
  offset_ = 0u;
  clear_has_offset();
}
inline ::google::protobuf::uint32 CommitDataRequest_ChunkToPatch_Patch::offset() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.CommitDataRequest.ChunkToPatch.Patch.offset)
  return offset_;
}
inline void CommitDataRequest_ChunkToPatch_Patch::set_offset(::google::protobuf::uint32 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.CommitDataRequest.ChunkToPatch.Patch.offset)
}

// optional bytes data = 2;
inline bool CommitDataRequest_ChunkToPatch_Patch::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommitDataRequest_ChunkToPatch_Patch::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommitDataRequest_ChunkToPatch_Patch::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommitDataRequest_ChunkToPatch_Patch::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
inline const ::std::string& CommitDataRequest_ChunkToPatch_Patch::data() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.CommitDataRequest.ChunkToPatch.Patch.data)
  return data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CommitDataRequest_ChunkToPatch_Patch::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.CommitDataRequest.ChunkToPatch.Patch.data)
}
inline void CommitDataRequest_ChunkToPatch_Patch::set_data(const char* value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.CommitDataRequest.ChunkToPatch.Patch.data)
}
inline void CommitDataRequest_ChunkToPatch_Patch::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.CommitDataRequest.ChunkToPatch.Patch.data)
}
inline ::std::string* CommitDataRequest_ChunkToPatch_Patch::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.CommitDataRequest.ChunkToPatch.Patch.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CommitDataRequest_ChunkToPatch_Patch::release_data() {
  // @@protoc_insertion_point(field_release:perfetto.protos.CommitDataRequest.ChunkToPatch.Patch.data)
  clear_has_data();
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CommitDataRequest_ChunkToPatch_Patch::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.CommitDataRequest.ChunkToPatch.Patch.data)
}

// -------------------------------------------------------------------

// CommitDataRequest_ChunkToPatch

// optional uint32 target_buffer = 1;
inline bool CommitDataRequest_ChunkToPatch::has_target_buffer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommitDataRequest_ChunkToPatch::set_has_target_buffer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommitDataRequest_ChunkToPatch::clear_has_target_buffer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommitDataRequest_ChunkToPatch::clear_target_buffer() {
  target_buffer_ = 0u;
  clear_has_target_buffer();
}
inline ::google::protobuf::uint32 CommitDataRequest_ChunkToPatch::target_buffer() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.CommitDataRequest.ChunkToPatch.target_buffer)
  return target_buffer_;
}
inline void CommitDataRequest_ChunkToPatch::set_target_buffer(::google::protobuf::uint32 value) {
  set_has_target_buffer();
  target_buffer_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.CommitDataRequest.ChunkToPatch.target_buffer)
}

// optional uint32 writer_id = 2;
inline bool CommitDataRequest_ChunkToPatch::has_writer_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommitDataRequest_ChunkToPatch::set_has_writer_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommitDataRequest_ChunkToPatch::clear_has_writer_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommitDataRequest_ChunkToPatch::clear_writer_id() {
  writer_id_ = 0u;
  clear_has_writer_id();
}
inline ::google::protobuf::uint32 CommitDataRequest_ChunkToPatch::writer_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.CommitDataRequest.ChunkToPatch.writer_id)
  return writer_id_;
}
inline void CommitDataRequest_ChunkToPatch::set_writer_id(::google::protobuf::uint32 value) {
  set_has_writer_id();
  writer_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.CommitDataRequest.ChunkToPatch.writer_id)
}

// optional uint32 chunk_id = 3;
inline bool CommitDataRequest_ChunkToPatch::has_chunk_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommitDataRequest_ChunkToPatch::set_has_chunk_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommitDataRequest_ChunkToPatch::clear_has_chunk_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommitDataRequest_ChunkToPatch::clear_chunk_id() {
  chunk_id_ = 0u;
  clear_has_chunk_id();
}
inline ::google::protobuf::uint32 CommitDataRequest_ChunkToPatch::chunk_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.CommitDataRequest.ChunkToPatch.chunk_id)
  return chunk_id_;
}
inline void CommitDataRequest_ChunkToPatch::set_chunk_id(::google::protobuf::uint32 value) {
  set_has_chunk_id();
  chunk_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.CommitDataRequest.ChunkToPatch.chunk_id)
}

// repeated .perfetto.protos.CommitDataRequest.ChunkToPatch.Patch patches = 4;
inline int CommitDataRequest_ChunkToPatch::patches_size() const {
  return patches_.size();
}
inline void CommitDataRequest_ChunkToPatch::clear_patches() {
  patches_.Clear();
}
inline const ::perfetto::protos::CommitDataRequest_ChunkToPatch_Patch& CommitDataRequest_ChunkToPatch::patches(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.CommitDataRequest.ChunkToPatch.patches)
  return patches_.Get(index);
}
inline ::perfetto::protos::CommitDataRequest_ChunkToPatch_Patch* CommitDataRequest_ChunkToPatch::mutable_patches(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.CommitDataRequest.ChunkToPatch.patches)
  return patches_.Mutable(index);
}
inline ::perfetto::protos::CommitDataRequest_ChunkToPatch_Patch* CommitDataRequest_ChunkToPatch::add_patches() {
  // @@protoc_insertion_point(field_add:perfetto.protos.CommitDataRequest.ChunkToPatch.patches)
  return patches_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::CommitDataRequest_ChunkToPatch_Patch >*
CommitDataRequest_ChunkToPatch::mutable_patches() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.CommitDataRequest.ChunkToPatch.patches)
  return &patches_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::CommitDataRequest_ChunkToPatch_Patch >&
CommitDataRequest_ChunkToPatch::patches() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.CommitDataRequest.ChunkToPatch.patches)
  return patches_;
}

// optional bool has_more_patches = 5;
inline bool CommitDataRequest_ChunkToPatch::has_has_more_patches() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommitDataRequest_ChunkToPatch::set_has_has_more_patches() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommitDataRequest_ChunkToPatch::clear_has_has_more_patches() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommitDataRequest_ChunkToPatch::clear_has_more_patches() {
  has_more_patches_ = false;
  clear_has_has_more_patches();
}
inline bool CommitDataRequest_ChunkToPatch::has_more_patches() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.CommitDataRequest.ChunkToPatch.has_more_patches)
  return has_more_patches_;
}
inline void CommitDataRequest_ChunkToPatch::set_has_more_patches(bool value) {
  set_has_has_more_patches();
  has_more_patches_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.CommitDataRequest.ChunkToPatch.has_more_patches)
}

// -------------------------------------------------------------------

// CommitDataRequest

// repeated .perfetto.protos.CommitDataRequest.ChunksToMove chunks_to_move = 1;
inline int CommitDataRequest::chunks_to_move_size() const {
  return chunks_to_move_.size();
}
inline void CommitDataRequest::clear_chunks_to_move() {
  chunks_to_move_.Clear();
}
inline const ::perfetto::protos::CommitDataRequest_ChunksToMove& CommitDataRequest::chunks_to_move(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.CommitDataRequest.chunks_to_move)
  return chunks_to_move_.Get(index);
}
inline ::perfetto::protos::CommitDataRequest_ChunksToMove* CommitDataRequest::mutable_chunks_to_move(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.CommitDataRequest.chunks_to_move)
  return chunks_to_move_.Mutable(index);
}
inline ::perfetto::protos::CommitDataRequest_ChunksToMove* CommitDataRequest::add_chunks_to_move() {
  // @@protoc_insertion_point(field_add:perfetto.protos.CommitDataRequest.chunks_to_move)
  return chunks_to_move_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::CommitDataRequest_ChunksToMove >*
CommitDataRequest::mutable_chunks_to_move() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.CommitDataRequest.chunks_to_move)
  return &chunks_to_move_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::CommitDataRequest_ChunksToMove >&
CommitDataRequest::chunks_to_move() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.CommitDataRequest.chunks_to_move)
  return chunks_to_move_;
}

// repeated .perfetto.protos.CommitDataRequest.ChunkToPatch chunks_to_patch = 2;
inline int CommitDataRequest::chunks_to_patch_size() const {
  return chunks_to_patch_.size();
}
inline void CommitDataRequest::clear_chunks_to_patch() {
  chunks_to_patch_.Clear();
}
inline const ::perfetto::protos::CommitDataRequest_ChunkToPatch& CommitDataRequest::chunks_to_patch(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.CommitDataRequest.chunks_to_patch)
  return chunks_to_patch_.Get(index);
}
inline ::perfetto::protos::CommitDataRequest_ChunkToPatch* CommitDataRequest::mutable_chunks_to_patch(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.CommitDataRequest.chunks_to_patch)
  return chunks_to_patch_.Mutable(index);
}
inline ::perfetto::protos::CommitDataRequest_ChunkToPatch* CommitDataRequest::add_chunks_to_patch() {
  // @@protoc_insertion_point(field_add:perfetto.protos.CommitDataRequest.chunks_to_patch)
  return chunks_to_patch_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::CommitDataRequest_ChunkToPatch >*
CommitDataRequest::mutable_chunks_to_patch() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.CommitDataRequest.chunks_to_patch)
  return &chunks_to_patch_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::CommitDataRequest_ChunkToPatch >&
CommitDataRequest::chunks_to_patch() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.CommitDataRequest.chunks_to_patch)
  return chunks_to_patch_;
}

// optional uint64 flush_request_id = 3;
inline bool CommitDataRequest::has_flush_request_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommitDataRequest::set_has_flush_request_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommitDataRequest::clear_has_flush_request_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommitDataRequest::clear_flush_request_id() {
  flush_request_id_ = GOOGLE_ULONGLONG(0);
  clear_has_flush_request_id();
}
inline ::google::protobuf::uint64 CommitDataRequest::flush_request_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.CommitDataRequest.flush_request_id)
  return flush_request_id_;
}
inline void CommitDataRequest::set_flush_request_id(::google::protobuf::uint64 value) {
  set_has_flush_request_id();
  flush_request_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.CommitDataRequest.flush_request_id)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto__INCLUDED
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/ipc/producer_port.proto

#ifndef PROTOBUF_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
// gen_amalgamated expanded: #include "protos/perfetto/common/commit_data_request.pb.h"
// gen_amalgamated expanded: #include "protos/perfetto/config/data_source_config.pb.h"
// gen_amalgamated expanded: #include "protos/perfetto/common/data_source_descriptor.pb.h"
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();

class ActivateTriggersRequest;
class ActivateTriggersResponse;
class CommitDataResponse;
class GetAsyncCommandRequest;
class GetAsyncCommandResponse;
class GetAsyncCommandResponse_ClearIncrementalState;
class GetAsyncCommandResponse_Flush;
class GetAsyncCommandResponse_SetupDataSource;
class GetAsyncCommandResponse_SetupTracing;
class GetAsyncCommandResponse_StartDataSource;
class GetAsyncCommandResponse_StopDataSource;
class InitializeConnectionRequest;
class InitializeConnectionResponse;
class NotifyDataSourceStartedRequest;
class NotifyDataSourceStartedResponse;
class NotifyDataSourceStoppedRequest;
class NotifyDataSourceStoppedResponse;
class RegisterDataSourceRequest;
class RegisterDataSourceResponse;
class RegisterTraceWriterRequest;
class RegisterTraceWriterResponse;
class UnregisterDataSourceRequest;
class UnregisterDataSourceResponse;
class UnregisterTraceWriterRequest;
class UnregisterTraceWriterResponse;

enum InitializeConnectionRequest_ProducerSMBScrapingMode {
  InitializeConnectionRequest_ProducerSMBScrapingMode_SMB_SCRAPING_UNSPECIFIED = 0,
  InitializeConnectionRequest_ProducerSMBScrapingMode_SMB_SCRAPING_ENABLED = 1,
  InitializeConnectionRequest_ProducerSMBScrapingMode_SMB_SCRAPING_DISABLED = 2
};
bool InitializeConnectionRequest_ProducerSMBScrapingMode_IsValid(int value);
const InitializeConnectionRequest_ProducerSMBScrapingMode InitializeConnectionRequest_ProducerSMBScrapingMode_ProducerSMBScrapingMode_MIN = InitializeConnectionRequest_ProducerSMBScrapingMode_SMB_SCRAPING_UNSPECIFIED;
const InitializeConnectionRequest_ProducerSMBScrapingMode InitializeConnectionRequest_ProducerSMBScrapingMode_ProducerSMBScrapingMode_MAX = InitializeConnectionRequest_ProducerSMBScrapingMode_SMB_SCRAPING_DISABLED;
const int InitializeConnectionRequest_ProducerSMBScrapingMode_ProducerSMBScrapingMode_ARRAYSIZE = InitializeConnectionRequest_ProducerSMBScrapingMode_ProducerSMBScrapingMode_MAX + 1;

enum InitializeConnectionRequest_ProducerBuildFlags {
  InitializeConnectionRequest_ProducerBuildFlags_BUILD_FLAGS_UNSPECIFIED = 0,
  InitializeConnectionRequest_ProducerBuildFlags_BUILD_FLAGS_DCHECKS_ON = 1,
  InitializeConnectionRequest_ProducerBuildFlags_BUILD_FLAGS_DCHECKS_OFF = 2
};
bool InitializeConnectionRequest_ProducerBuildFlags_IsValid(int value);
const InitializeConnectionRequest_ProducerBuildFlags InitializeConnectionRequest_ProducerBuildFlags_ProducerBuildFlags_MIN = InitializeConnectionRequest_ProducerBuildFlags_BUILD_FLAGS_UNSPECIFIED;
const InitializeConnectionRequest_ProducerBuildFlags InitializeConnectionRequest_ProducerBuildFlags_ProducerBuildFlags_MAX = InitializeConnectionRequest_ProducerBuildFlags_BUILD_FLAGS_DCHECKS_OFF;
const int InitializeConnectionRequest_ProducerBuildFlags_ProducerBuildFlags_ARRAYSIZE = InitializeConnectionRequest_ProducerBuildFlags_ProducerBuildFlags_MAX + 1;

// ===================================================================

class InitializeConnectionRequest : public ::google::protobuf::MessageLite {
 public:
  InitializeConnectionRequest();
  virtual ~InitializeConnectionRequest();

  InitializeConnectionRequest(const InitializeConnectionRequest& from);

  inline InitializeConnectionRequest& operator=(const InitializeConnectionRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const InitializeConnectionRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const InitializeConnectionRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(InitializeConnectionRequest* other);

  // implements Message ----------------------------------------------

  inline InitializeConnectionRequest* New() const { return New(NULL); }

  InitializeConnectionRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const InitializeConnectionRequest& from);
  void MergeFrom(const InitializeConnectionRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InitializeConnectionRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef InitializeConnectionRequest_ProducerSMBScrapingMode ProducerSMBScrapingMode;
  static const ProducerSMBScrapingMode SMB_SCRAPING_UNSPECIFIED =
    InitializeConnectionRequest_ProducerSMBScrapingMode_SMB_SCRAPING_UNSPECIFIED;
  static const ProducerSMBScrapingMode SMB_SCRAPING_ENABLED =
    InitializeConnectionRequest_ProducerSMBScrapingMode_SMB_SCRAPING_ENABLED;
  static const ProducerSMBScrapingMode SMB_SCRAPING_DISABLED =
    InitializeConnectionRequest_ProducerSMBScrapingMode_SMB_SCRAPING_DISABLED;
  static inline bool ProducerSMBScrapingMode_IsValid(int value) {
    return InitializeConnectionRequest_ProducerSMBScrapingMode_IsValid(value);
  }
  static const ProducerSMBScrapingMode ProducerSMBScrapingMode_MIN =
    InitializeConnectionRequest_ProducerSMBScrapingMode_ProducerSMBScrapingMode_MIN;
  static const ProducerSMBScrapingMode ProducerSMBScrapingMode_MAX =
    InitializeConnectionRequest_ProducerSMBScrapingMode_ProducerSMBScrapingMode_MAX;
  static const int ProducerSMBScrapingMode_ARRAYSIZE =
    InitializeConnectionRequest_ProducerSMBScrapingMode_ProducerSMBScrapingMode_ARRAYSIZE;

  typedef InitializeConnectionRequest_ProducerBuildFlags ProducerBuildFlags;
  static const ProducerBuildFlags BUILD_FLAGS_UNSPECIFIED =
    InitializeConnectionRequest_ProducerBuildFlags_BUILD_FLAGS_UNSPECIFIED;
  static const ProducerBuildFlags BUILD_FLAGS_DCHECKS_ON =
    InitializeConnectionRequest_ProducerBuildFlags_BUILD_FLAGS_DCHECKS_ON;
  static const ProducerBuildFlags BUILD_FLAGS_DCHECKS_OFF =
    InitializeConnectionRequest_ProducerBuildFlags_BUILD_FLAGS_DCHECKS_OFF;
  static inline bool ProducerBuildFlags_IsValid(int value) {
    return InitializeConnectionRequest_ProducerBuildFlags_IsValid(value);
  }
  static const ProducerBuildFlags ProducerBuildFlags_MIN =
    InitializeConnectionRequest_ProducerBuildFlags_ProducerBuildFlags_MIN;
  static const ProducerBuildFlags ProducerBuildFlags_MAX =
    InitializeConnectionRequest_ProducerBuildFlags_ProducerBuildFlags_MAX;
  static const int ProducerBuildFlags_ARRAYSIZE =
    InitializeConnectionRequest_ProducerBuildFlags_ProducerBuildFlags_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional uint32 shared_memory_page_size_hint_bytes = 1;
  bool has_shared_memory_page_size_hint_bytes() const;
  void clear_shared_memory_page_size_hint_bytes();
  static const int kSharedMemoryPageSizeHintBytesFieldNumber = 1;
  ::google::protobuf::uint32 shared_memory_page_size_hint_bytes() const;
  void set_shared_memory_page_size_hint_bytes(::google::protobuf::uint32 value);

  // optional uint32 shared_memory_size_hint_bytes = 2;
  bool has_shared_memory_size_hint_bytes() const;
  void clear_shared_memory_size_hint_bytes();
  static const int kSharedMemorySizeHintBytesFieldNumber = 2;
  ::google::protobuf::uint32 shared_memory_size_hint_bytes() const;
  void set_shared_memory_size_hint_bytes(::google::protobuf::uint32 value);

  // optional string producer_name = 3;
  bool has_producer_name() const;
  void clear_producer_name();
  static const int kProducerNameFieldNumber = 3;
  const ::std::string& producer_name() const;
  void set_producer_name(const ::std::string& value);
  void set_producer_name(const char* value);
  void set_producer_name(const char* value, size_t size);
  ::std::string* mutable_producer_name();
  ::std::string* release_producer_name();
  void set_allocated_producer_name(::std::string* producer_name);

  // optional .perfetto.protos.InitializeConnectionRequest.ProducerSMBScrapingMode smb_scraping_mode = 4;
  bool has_smb_scraping_mode() const;
  void clear_smb_scraping_mode();
  static const int kSmbScrapingModeFieldNumber = 4;
  ::perfetto::protos::InitializeConnectionRequest_ProducerSMBScrapingMode smb_scraping_mode() const;
  void set_smb_scraping_mode(::perfetto::protos::InitializeConnectionRequest_ProducerSMBScrapingMode value);

  // optional .perfetto.protos.InitializeConnectionRequest.ProducerBuildFlags build_flags = 5;
  bool has_build_flags() const;
  void clear_build_flags();
  static const int kBuildFlagsFieldNumber = 5;
  ::perfetto::protos::InitializeConnectionRequest_ProducerBuildFlags build_flags() const;
  void set_build_flags(::perfetto::protos::InitializeConnectionRequest_ProducerBuildFlags value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.InitializeConnectionRequest)
 private:
  inline void set_has_shared_memory_page_size_hint_bytes();
  inline void clear_has_shared_memory_page_size_hint_bytes();
  inline void set_has_shared_memory_size_hint_bytes();
  inline void clear_has_shared_memory_size_hint_bytes();
  inline void set_has_producer_name();
  inline void clear_has_producer_name();
  inline void set_has_smb_scraping_mode();
  inline void clear_has_smb_scraping_mode();
  inline void set_has_build_flags();
  inline void clear_has_build_flags();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 shared_memory_page_size_hint_bytes_;
  ::google::protobuf::uint32 shared_memory_size_hint_bytes_;
  ::google::protobuf::internal::ArenaStringPtr producer_name_;
  int smb_scraping_mode_;
  int build_flags_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static InitializeConnectionRequest* default_instance_;
};
// -------------------------------------------------------------------

class InitializeConnectionResponse : public ::google::protobuf::MessageLite {
 public:
  InitializeConnectionResponse();
  virtual ~InitializeConnectionResponse();

  InitializeConnectionResponse(const InitializeConnectionResponse& from);

  inline InitializeConnectionResponse& operator=(const InitializeConnectionResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const InitializeConnectionResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const InitializeConnectionResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(InitializeConnectionResponse* other);

  // implements Message ----------------------------------------------

  inline InitializeConnectionResponse* New() const { return New(NULL); }

  InitializeConnectionResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const InitializeConnectionResponse& from);
  void MergeFrom(const InitializeConnectionResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InitializeConnectionResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.InitializeConnectionResponse)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static InitializeConnectionResponse* default_instance_;
};
// -------------------------------------------------------------------

class RegisterDataSourceRequest : public ::google::protobuf::MessageLite {
 public:
  RegisterDataSourceRequest();
  virtual ~RegisterDataSourceRequest();

  RegisterDataSourceRequest(const RegisterDataSourceRequest& from);

  inline RegisterDataSourceRequest& operator=(const RegisterDataSourceRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const RegisterDataSourceRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RegisterDataSourceRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RegisterDataSourceRequest* other);

  // implements Message ----------------------------------------------

  inline RegisterDataSourceRequest* New() const { return New(NULL); }

  RegisterDataSourceRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RegisterDataSourceRequest& from);
  void MergeFrom(const RegisterDataSourceRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RegisterDataSourceRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .perfetto.protos.DataSourceDescriptor data_source_descriptor = 1;
  bool has_data_source_descriptor() const;
  void clear_data_source_descriptor();
  static const int kDataSourceDescriptorFieldNumber = 1;
  const ::perfetto::protos::DataSourceDescriptor& data_source_descriptor() const;
  ::perfetto::protos::DataSourceDescriptor* mutable_data_source_descriptor();
  ::perfetto::protos::DataSourceDescriptor* release_data_source_descriptor();
  void set_allocated_data_source_descriptor(::perfetto::protos::DataSourceDescriptor* data_source_descriptor);

  // @@protoc_insertion_point(class_scope:perfetto.protos.RegisterDataSourceRequest)
 private:
  inline void set_has_data_source_descriptor();
  inline void clear_has_data_source_descriptor();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::perfetto::protos::DataSourceDescriptor* data_source_descriptor_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static RegisterDataSourceRequest* default_instance_;
};
// -------------------------------------------------------------------

class RegisterDataSourceResponse : public ::google::protobuf::MessageLite {
 public:
  RegisterDataSourceResponse();
  virtual ~RegisterDataSourceResponse();

  RegisterDataSourceResponse(const RegisterDataSourceResponse& from);

  inline RegisterDataSourceResponse& operator=(const RegisterDataSourceResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const RegisterDataSourceResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RegisterDataSourceResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RegisterDataSourceResponse* other);

  // implements Message ----------------------------------------------

  inline RegisterDataSourceResponse* New() const { return New(NULL); }

  RegisterDataSourceResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RegisterDataSourceResponse& from);
  void MergeFrom(const RegisterDataSourceResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RegisterDataSourceResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string error = 1;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // @@protoc_insertion_point(class_scope:perfetto.protos.RegisterDataSourceResponse)
 private:
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static RegisterDataSourceResponse* default_instance_;
};
// -------------------------------------------------------------------

class UnregisterDataSourceRequest : public ::google::protobuf::MessageLite {
 public:
  UnregisterDataSourceRequest();
  virtual ~UnregisterDataSourceRequest();

  UnregisterDataSourceRequest(const UnregisterDataSourceRequest& from);

  inline UnregisterDataSourceRequest& operator=(const UnregisterDataSourceRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const UnregisterDataSourceRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UnregisterDataSourceRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UnregisterDataSourceRequest* other);

  // implements Message ----------------------------------------------

  inline UnregisterDataSourceRequest* New() const { return New(NULL); }

  UnregisterDataSourceRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UnregisterDataSourceRequest& from);
  void MergeFrom(const UnregisterDataSourceRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UnregisterDataSourceRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string data_source_name = 1;
  bool has_data_source_name() const;
  void clear_data_source_name();
  static const int kDataSourceNameFieldNumber = 1;
  const ::std::string& data_source_name() const;
  void set_data_source_name(const ::std::string& value);
  void set_data_source_name(const char* value);
  void set_data_source_name(const char* value, size_t size);
  ::std::string* mutable_data_source_name();
  ::std::string* release_data_source_name();
  void set_allocated_data_source_name(::std::string* data_source_name);

  // @@protoc_insertion_point(class_scope:perfetto.protos.UnregisterDataSourceRequest)
 private:
  inline void set_has_data_source_name();
  inline void clear_has_data_source_name();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_source_name_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static UnregisterDataSourceRequest* default_instance_;
};
// -------------------------------------------------------------------

class UnregisterDataSourceResponse : public ::google::protobuf::MessageLite {
 public:
  UnregisterDataSourceResponse();
  virtual ~UnregisterDataSourceResponse();

  UnregisterDataSourceResponse(const UnregisterDataSourceResponse& from);

  inline UnregisterDataSourceResponse& operator=(const UnregisterDataSourceResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const UnregisterDataSourceResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UnregisterDataSourceResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UnregisterDataSourceResponse* other);

  // implements Message ----------------------------------------------

  inline UnregisterDataSourceResponse* New() const { return New(NULL); }

  UnregisterDataSourceResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UnregisterDataSourceResponse& from);
  void MergeFrom(const UnregisterDataSourceResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UnregisterDataSourceResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.UnregisterDataSourceResponse)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static UnregisterDataSourceResponse* default_instance_;
};
// -------------------------------------------------------------------

class RegisterTraceWriterRequest : public ::google::protobuf::MessageLite {
 public:
  RegisterTraceWriterRequest();
  virtual ~RegisterTraceWriterRequest();

  RegisterTraceWriterRequest(const RegisterTraceWriterRequest& from);

  inline RegisterTraceWriterRequest& operator=(const RegisterTraceWriterRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const RegisterTraceWriterRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RegisterTraceWriterRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RegisterTraceWriterRequest* other);

  // implements Message ----------------------------------------------

  inline RegisterTraceWriterRequest* New() const { return New(NULL); }

  RegisterTraceWriterRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RegisterTraceWriterRequest& from);
  void MergeFrom(const RegisterTraceWriterRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RegisterTraceWriterRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 trace_writer_id = 1;
  bool has_trace_writer_id() const;
  void clear_trace_writer_id();
  static const int kTraceWriterIdFieldNumber = 1;
  ::google::protobuf::uint32 trace_writer_id() const;
  void set_trace_writer_id(::google::protobuf::uint32 value);

  // optional uint32 target_buffer = 2;
  bool has_target_buffer() const;
  void clear_target_buffer();
  static const int kTargetBufferFieldNumber = 2;
  ::google::protobuf::uint32 target_buffer() const;
  void set_target_buffer(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.RegisterTraceWriterRequest)
 private:
  inline void set_has_trace_writer_id();
  inline void clear_has_trace_writer_id();
  inline void set_has_target_buffer();
  inline void clear_has_target_buffer();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 trace_writer_id_;
  ::google::protobuf::uint32 target_buffer_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static RegisterTraceWriterRequest* default_instance_;
};
// -------------------------------------------------------------------

class RegisterTraceWriterResponse : public ::google::protobuf::MessageLite {
 public:
  RegisterTraceWriterResponse();
  virtual ~RegisterTraceWriterResponse();

  RegisterTraceWriterResponse(const RegisterTraceWriterResponse& from);

  inline RegisterTraceWriterResponse& operator=(const RegisterTraceWriterResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const RegisterTraceWriterResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RegisterTraceWriterResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RegisterTraceWriterResponse* other);

  // implements Message ----------------------------------------------

  inline RegisterTraceWriterResponse* New() const { return New(NULL); }

  RegisterTraceWriterResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RegisterTraceWriterResponse& from);
  void MergeFrom(const RegisterTraceWriterResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RegisterTraceWriterResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.RegisterTraceWriterResponse)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static RegisterTraceWriterResponse* default_instance_;
};
// -------------------------------------------------------------------

class UnregisterTraceWriterRequest : public ::google::protobuf::MessageLite {
 public:
  UnregisterTraceWriterRequest();
  virtual ~UnregisterTraceWriterRequest();

  UnregisterTraceWriterRequest(const UnregisterTraceWriterRequest& from);

  inline UnregisterTraceWriterRequest& operator=(const UnregisterTraceWriterRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const UnregisterTraceWriterRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UnregisterTraceWriterRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UnregisterTraceWriterRequest* other);

  // implements Message ----------------------------------------------

  inline UnregisterTraceWriterRequest* New() const { return New(NULL); }

  UnregisterTraceWriterRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UnregisterTraceWriterRequest& from);
  void MergeFrom(const UnregisterTraceWriterRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UnregisterTraceWriterRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 trace_writer_id = 1;
  bool has_trace_writer_id() const;
  void clear_trace_writer_id();
  static const int kTraceWriterIdFieldNumber = 1;
  ::google::protobuf::uint32 trace_writer_id() const;
  void set_trace_writer_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.UnregisterTraceWriterRequest)
 private:
  inline void set_has_trace_writer_id();
  inline void clear_has_trace_writer_id();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 trace_writer_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static UnregisterTraceWriterRequest* default_instance_;
};
// -------------------------------------------------------------------

class UnregisterTraceWriterResponse : public ::google::protobuf::MessageLite {
 public:
  UnregisterTraceWriterResponse();
  virtual ~UnregisterTraceWriterResponse();

  UnregisterTraceWriterResponse(const UnregisterTraceWriterResponse& from);

  inline UnregisterTraceWriterResponse& operator=(const UnregisterTraceWriterResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const UnregisterTraceWriterResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UnregisterTraceWriterResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UnregisterTraceWriterResponse* other);

  // implements Message ----------------------------------------------

  inline UnregisterTraceWriterResponse* New() const { return New(NULL); }

  UnregisterTraceWriterResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UnregisterTraceWriterResponse& from);
  void MergeFrom(const UnregisterTraceWriterResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UnregisterTraceWriterResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.UnregisterTraceWriterResponse)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static UnregisterTraceWriterResponse* default_instance_;
};
// -------------------------------------------------------------------

class CommitDataResponse : public ::google::protobuf::MessageLite {
 public:
  CommitDataResponse();
  virtual ~CommitDataResponse();

  CommitDataResponse(const CommitDataResponse& from);

  inline CommitDataResponse& operator=(const CommitDataResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const CommitDataResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommitDataResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommitDataResponse* other);

  // implements Message ----------------------------------------------

  inline CommitDataResponse* New() const { return New(NULL); }

  CommitDataResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommitDataResponse& from);
  void MergeFrom(const CommitDataResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommitDataResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.CommitDataResponse)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static CommitDataResponse* default_instance_;
};
// -------------------------------------------------------------------

class NotifyDataSourceStartedRequest : public ::google::protobuf::MessageLite {
 public:
  NotifyDataSourceStartedRequest();
  virtual ~NotifyDataSourceStartedRequest();

  NotifyDataSourceStartedRequest(const NotifyDataSourceStartedRequest& from);

  inline NotifyDataSourceStartedRequest& operator=(const NotifyDataSourceStartedRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const NotifyDataSourceStartedRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotifyDataSourceStartedRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotifyDataSourceStartedRequest* other);

  // implements Message ----------------------------------------------

  inline NotifyDataSourceStartedRequest* New() const { return New(NULL); }

  NotifyDataSourceStartedRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotifyDataSourceStartedRequest& from);
  void MergeFrom(const NotifyDataSourceStartedRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NotifyDataSourceStartedRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 data_source_id = 1;
  bool has_data_source_id() const;
  void clear_data_source_id();
  static const int kDataSourceIdFieldNumber = 1;
  ::google::protobuf::uint64 data_source_id() const;
  void set_data_source_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.NotifyDataSourceStartedRequest)
 private:
  inline void set_has_data_source_id();
  inline void clear_has_data_source_id();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 data_source_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static NotifyDataSourceStartedRequest* default_instance_;
};
// -------------------------------------------------------------------

class NotifyDataSourceStartedResponse : public ::google::protobuf::MessageLite {
 public:
  NotifyDataSourceStartedResponse();
  virtual ~NotifyDataSourceStartedResponse();

  NotifyDataSourceStartedResponse(const NotifyDataSourceStartedResponse& from);

  inline NotifyDataSourceStartedResponse& operator=(const NotifyDataSourceStartedResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const NotifyDataSourceStartedResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotifyDataSourceStartedResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotifyDataSourceStartedResponse* other);

  // implements Message ----------------------------------------------

  inline NotifyDataSourceStartedResponse* New() const { return New(NULL); }

  NotifyDataSourceStartedResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotifyDataSourceStartedResponse& from);
  void MergeFrom(const NotifyDataSourceStartedResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NotifyDataSourceStartedResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.NotifyDataSourceStartedResponse)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static NotifyDataSourceStartedResponse* default_instance_;
};
// -------------------------------------------------------------------

class NotifyDataSourceStoppedRequest : public ::google::protobuf::MessageLite {
 public:
  NotifyDataSourceStoppedRequest();
  virtual ~NotifyDataSourceStoppedRequest();

  NotifyDataSourceStoppedRequest(const NotifyDataSourceStoppedRequest& from);

  inline NotifyDataSourceStoppedRequest& operator=(const NotifyDataSourceStoppedRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const NotifyDataSourceStoppedRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotifyDataSourceStoppedRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotifyDataSourceStoppedRequest* other);

  // implements Message ----------------------------------------------

  inline NotifyDataSourceStoppedRequest* New() const { return New(NULL); }

  NotifyDataSourceStoppedRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotifyDataSourceStoppedRequest& from);
  void MergeFrom(const NotifyDataSourceStoppedRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NotifyDataSourceStoppedRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 data_source_id = 1;
  bool has_data_source_id() const;
  void clear_data_source_id();
  static const int kDataSourceIdFieldNumber = 1;
  ::google::protobuf::uint64 data_source_id() const;
  void set_data_source_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.NotifyDataSourceStoppedRequest)
 private:
  inline void set_has_data_source_id();
  inline void clear_has_data_source_id();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 data_source_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static NotifyDataSourceStoppedRequest* default_instance_;
};
// -------------------------------------------------------------------

class NotifyDataSourceStoppedResponse : public ::google::protobuf::MessageLite {
 public:
  NotifyDataSourceStoppedResponse();
  virtual ~NotifyDataSourceStoppedResponse();

  NotifyDataSourceStoppedResponse(const NotifyDataSourceStoppedResponse& from);

  inline NotifyDataSourceStoppedResponse& operator=(const NotifyDataSourceStoppedResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const NotifyDataSourceStoppedResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotifyDataSourceStoppedResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotifyDataSourceStoppedResponse* other);

  // implements Message ----------------------------------------------

  inline NotifyDataSourceStoppedResponse* New() const { return New(NULL); }

  NotifyDataSourceStoppedResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotifyDataSourceStoppedResponse& from);
  void MergeFrom(const NotifyDataSourceStoppedResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NotifyDataSourceStoppedResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.NotifyDataSourceStoppedResponse)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static NotifyDataSourceStoppedResponse* default_instance_;
};
// -------------------------------------------------------------------

class ActivateTriggersRequest : public ::google::protobuf::MessageLite {
 public:
  ActivateTriggersRequest();
  virtual ~ActivateTriggersRequest();

  ActivateTriggersRequest(const ActivateTriggersRequest& from);

  inline ActivateTriggersRequest& operator=(const ActivateTriggersRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ActivateTriggersRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ActivateTriggersRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ActivateTriggersRequest* other);

  // implements Message ----------------------------------------------

  inline ActivateTriggersRequest* New() const { return New(NULL); }

  ActivateTriggersRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ActivateTriggersRequest& from);
  void MergeFrom(const ActivateTriggersRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActivateTriggersRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string trigger_names = 1;
  int trigger_names_size() const;
  void clear_trigger_names();
  static const int kTriggerNamesFieldNumber = 1;
  const ::std::string& trigger_names(int index) const;
  ::std::string* mutable_trigger_names(int index);
  void set_trigger_names(int index, const ::std::string& value);
  void set_trigger_names(int index, const char* value);
  void set_trigger_names(int index, const char* value, size_t size);
  ::std::string* add_trigger_names();
  void add_trigger_names(const ::std::string& value);
  void add_trigger_names(const char* value);
  void add_trigger_names(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& trigger_names() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_trigger_names();

  // @@protoc_insertion_point(class_scope:perfetto.protos.ActivateTriggersRequest)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> trigger_names_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static ActivateTriggersRequest* default_instance_;
};
// -------------------------------------------------------------------

class ActivateTriggersResponse : public ::google::protobuf::MessageLite {
 public:
  ActivateTriggersResponse();
  virtual ~ActivateTriggersResponse();

  ActivateTriggersResponse(const ActivateTriggersResponse& from);

  inline ActivateTriggersResponse& operator=(const ActivateTriggersResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ActivateTriggersResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ActivateTriggersResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ActivateTriggersResponse* other);

  // implements Message ----------------------------------------------

  inline ActivateTriggersResponse* New() const { return New(NULL); }

  ActivateTriggersResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ActivateTriggersResponse& from);
  void MergeFrom(const ActivateTriggersResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActivateTriggersResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.ActivateTriggersResponse)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static ActivateTriggersResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetAsyncCommandRequest : public ::google::protobuf::MessageLite {
 public:
  GetAsyncCommandRequest();
  virtual ~GetAsyncCommandRequest();

  GetAsyncCommandRequest(const GetAsyncCommandRequest& from);

  inline GetAsyncCommandRequest& operator=(const GetAsyncCommandRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const GetAsyncCommandRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetAsyncCommandRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetAsyncCommandRequest* other);

  // implements Message ----------------------------------------------

  inline GetAsyncCommandRequest* New() const { return New(NULL); }

  GetAsyncCommandRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetAsyncCommandRequest& from);
  void MergeFrom(const GetAsyncCommandRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetAsyncCommandRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.GetAsyncCommandRequest)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static GetAsyncCommandRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetAsyncCommandResponse_SetupDataSource : public ::google::protobuf::MessageLite {
 public:
  GetAsyncCommandResponse_SetupDataSource();
  virtual ~GetAsyncCommandResponse_SetupDataSource();

  GetAsyncCommandResponse_SetupDataSource(const GetAsyncCommandResponse_SetupDataSource& from);

  inline GetAsyncCommandResponse_SetupDataSource& operator=(const GetAsyncCommandResponse_SetupDataSource& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const GetAsyncCommandResponse_SetupDataSource& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetAsyncCommandResponse_SetupDataSource* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetAsyncCommandResponse_SetupDataSource* other);

  // implements Message ----------------------------------------------

  inline GetAsyncCommandResponse_SetupDataSource* New() const { return New(NULL); }

  GetAsyncCommandResponse_SetupDataSource* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetAsyncCommandResponse_SetupDataSource& from);
  void MergeFrom(const GetAsyncCommandResponse_SetupDataSource& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetAsyncCommandResponse_SetupDataSource* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 new_instance_id = 1;
  bool has_new_instance_id() const;
  void clear_new_instance_id();
  static const int kNewInstanceIdFieldNumber = 1;
  ::google::protobuf::uint64 new_instance_id() const;
  void set_new_instance_id(::google::protobuf::uint64 value);

  // optional .perfetto.protos.DataSourceConfig config = 2;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 2;
  const ::perfetto::protos::DataSourceConfig& config() const;
  ::perfetto::protos::DataSourceConfig* mutable_config();
  ::perfetto::protos::DataSourceConfig* release_config();
  void set_allocated_config(::perfetto::protos::DataSourceConfig* config);

  // @@protoc_insertion_point(class_scope:perfetto.protos.GetAsyncCommandResponse.SetupDataSource)
 private:
  inline void set_has_new_instance_id();
  inline void clear_has_new_instance_id();
  inline void set_has_config();
  inline void clear_has_config();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 new_instance_id_;
  ::perfetto::protos::DataSourceConfig* config_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static GetAsyncCommandResponse_SetupDataSource* default_instance_;
};
// -------------------------------------------------------------------

class GetAsyncCommandResponse_StartDataSource : public ::google::protobuf::MessageLite {
 public:
  GetAsyncCommandResponse_StartDataSource();
  virtual ~GetAsyncCommandResponse_StartDataSource();

  GetAsyncCommandResponse_StartDataSource(const GetAsyncCommandResponse_StartDataSource& from);

  inline GetAsyncCommandResponse_StartDataSource& operator=(const GetAsyncCommandResponse_StartDataSource& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const GetAsyncCommandResponse_StartDataSource& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetAsyncCommandResponse_StartDataSource* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetAsyncCommandResponse_StartDataSource* other);

  // implements Message ----------------------------------------------

  inline GetAsyncCommandResponse_StartDataSource* New() const { return New(NULL); }

  GetAsyncCommandResponse_StartDataSource* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetAsyncCommandResponse_StartDataSource& from);
  void MergeFrom(const GetAsyncCommandResponse_StartDataSource& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetAsyncCommandResponse_StartDataSource* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 new_instance_id = 1;
  bool has_new_instance_id() const;
  void clear_new_instance_id();
  static const int kNewInstanceIdFieldNumber = 1;
  ::google::protobuf::uint64 new_instance_id() const;
  void set_new_instance_id(::google::protobuf::uint64 value);

  // optional .perfetto.protos.DataSourceConfig config = 2;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 2;
  const ::perfetto::protos::DataSourceConfig& config() const;
  ::perfetto::protos::DataSourceConfig* mutable_config();
  ::perfetto::protos::DataSourceConfig* release_config();
  void set_allocated_config(::perfetto::protos::DataSourceConfig* config);

  // @@protoc_insertion_point(class_scope:perfetto.protos.GetAsyncCommandResponse.StartDataSource)
 private:
  inline void set_has_new_instance_id();
  inline void clear_has_new_instance_id();
  inline void set_has_config();
  inline void clear_has_config();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 new_instance_id_;
  ::perfetto::protos::DataSourceConfig* config_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static GetAsyncCommandResponse_StartDataSource* default_instance_;
};
// -------------------------------------------------------------------

class GetAsyncCommandResponse_StopDataSource : public ::google::protobuf::MessageLite {
 public:
  GetAsyncCommandResponse_StopDataSource();
  virtual ~GetAsyncCommandResponse_StopDataSource();

  GetAsyncCommandResponse_StopDataSource(const GetAsyncCommandResponse_StopDataSource& from);

  inline GetAsyncCommandResponse_StopDataSource& operator=(const GetAsyncCommandResponse_StopDataSource& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const GetAsyncCommandResponse_StopDataSource& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetAsyncCommandResponse_StopDataSource* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetAsyncCommandResponse_StopDataSource* other);

  // implements Message ----------------------------------------------

  inline GetAsyncCommandResponse_StopDataSource* New() const { return New(NULL); }

  GetAsyncCommandResponse_StopDataSource* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetAsyncCommandResponse_StopDataSource& from);
  void MergeFrom(const GetAsyncCommandResponse_StopDataSource& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetAsyncCommandResponse_StopDataSource* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 instance_id = 1;
  bool has_instance_id() const;
  void clear_instance_id();
  static const int kInstanceIdFieldNumber = 1;
  ::google::protobuf::uint64 instance_id() const;
  void set_instance_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.GetAsyncCommandResponse.StopDataSource)
 private:
  inline void set_has_instance_id();
  inline void clear_has_instance_id();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 instance_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static GetAsyncCommandResponse_StopDataSource* default_instance_;
};
// -------------------------------------------------------------------

class GetAsyncCommandResponse_SetupTracing : public ::google::protobuf::MessageLite {
 public:
  GetAsyncCommandResponse_SetupTracing();
  virtual ~GetAsyncCommandResponse_SetupTracing();

  GetAsyncCommandResponse_SetupTracing(const GetAsyncCommandResponse_SetupTracing& from);

  inline GetAsyncCommandResponse_SetupTracing& operator=(const GetAsyncCommandResponse_SetupTracing& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const GetAsyncCommandResponse_SetupTracing& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetAsyncCommandResponse_SetupTracing* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetAsyncCommandResponse_SetupTracing* other);

  // implements Message ----------------------------------------------

  inline GetAsyncCommandResponse_SetupTracing* New() const { return New(NULL); }

  GetAsyncCommandResponse_SetupTracing* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetAsyncCommandResponse_SetupTracing& from);
  void MergeFrom(const GetAsyncCommandResponse_SetupTracing& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetAsyncCommandResponse_SetupTracing* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 shared_buffer_page_size_kb = 1;
  bool has_shared_buffer_page_size_kb() const;
  void clear_shared_buffer_page_size_kb();
  static const int kSharedBufferPageSizeKbFieldNumber = 1;
  ::google::protobuf::uint32 shared_buffer_page_size_kb() const;
  void set_shared_buffer_page_size_kb(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.GetAsyncCommandResponse.SetupTracing)
 private:
  inline void set_has_shared_buffer_page_size_kb();
  inline void clear_has_shared_buffer_page_size_kb();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 shared_buffer_page_size_kb_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static GetAsyncCommandResponse_SetupTracing* default_instance_;
};
// -------------------------------------------------------------------

class GetAsyncCommandResponse_Flush : public ::google::protobuf::MessageLite {
 public:
  GetAsyncCommandResponse_Flush();
  virtual ~GetAsyncCommandResponse_Flush();

  GetAsyncCommandResponse_Flush(const GetAsyncCommandResponse_Flush& from);

  inline GetAsyncCommandResponse_Flush& operator=(const GetAsyncCommandResponse_Flush& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const GetAsyncCommandResponse_Flush& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetAsyncCommandResponse_Flush* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetAsyncCommandResponse_Flush* other);

  // implements Message ----------------------------------------------

  inline GetAsyncCommandResponse_Flush* New() const { return New(NULL); }

  GetAsyncCommandResponse_Flush* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetAsyncCommandResponse_Flush& from);
  void MergeFrom(const GetAsyncCommandResponse_Flush& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetAsyncCommandResponse_Flush* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 data_source_ids = 1;
  int data_source_ids_size() const;
  void clear_data_source_ids();
  static const int kDataSourceIdsFieldNumber = 1;
  ::google::protobuf::uint64 data_source_ids(int index) const;
  void set_data_source_ids(int index, ::google::protobuf::uint64 value);
  void add_data_source_ids(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      data_source_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_data_source_ids();

  // optional uint64 request_id = 2;
  bool has_request_id() const;
  void clear_request_id();
  static const int kRequestIdFieldNumber = 2;
  ::google::protobuf::uint64 request_id() const;
  void set_request_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.GetAsyncCommandResponse.Flush)
 private:
  inline void set_has_request_id();
  inline void clear_has_request_id();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > data_source_ids_;
  ::google::protobuf::uint64 request_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static GetAsyncCommandResponse_Flush* default_instance_;
};
// -------------------------------------------------------------------

class GetAsyncCommandResponse_ClearIncrementalState : public ::google::protobuf::MessageLite {
 public:
  GetAsyncCommandResponse_ClearIncrementalState();
  virtual ~GetAsyncCommandResponse_ClearIncrementalState();

  GetAsyncCommandResponse_ClearIncrementalState(const GetAsyncCommandResponse_ClearIncrementalState& from);

  inline GetAsyncCommandResponse_ClearIncrementalState& operator=(const GetAsyncCommandResponse_ClearIncrementalState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const GetAsyncCommandResponse_ClearIncrementalState& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetAsyncCommandResponse_ClearIncrementalState* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetAsyncCommandResponse_ClearIncrementalState* other);

  // implements Message ----------------------------------------------

  inline GetAsyncCommandResponse_ClearIncrementalState* New() const { return New(NULL); }

  GetAsyncCommandResponse_ClearIncrementalState* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetAsyncCommandResponse_ClearIncrementalState& from);
  void MergeFrom(const GetAsyncCommandResponse_ClearIncrementalState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetAsyncCommandResponse_ClearIncrementalState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 data_source_ids = 1;
  int data_source_ids_size() const;
  void clear_data_source_ids();
  static const int kDataSourceIdsFieldNumber = 1;
  ::google::protobuf::uint64 data_source_ids(int index) const;
  void set_data_source_ids(int index, ::google::protobuf::uint64 value);
  void add_data_source_ids(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      data_source_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_data_source_ids();

  // @@protoc_insertion_point(class_scope:perfetto.protos.GetAsyncCommandResponse.ClearIncrementalState)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > data_source_ids_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static GetAsyncCommandResponse_ClearIncrementalState* default_instance_;
};
// -------------------------------------------------------------------

class GetAsyncCommandResponse : public ::google::protobuf::MessageLite {
 public:
  GetAsyncCommandResponse();
  virtual ~GetAsyncCommandResponse();

  GetAsyncCommandResponse(const GetAsyncCommandResponse& from);

  inline GetAsyncCommandResponse& operator=(const GetAsyncCommandResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const GetAsyncCommandResponse& default_instance();

  enum CmdCase {
    kSetupTracing = 3,
    kSetupDataSource = 6,
    kStartDataSource = 1,
    kStopDataSource = 2,
    kFlush = 5,
    kClearIncrementalState = 7,
    CMD_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetAsyncCommandResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetAsyncCommandResponse* other);

  // implements Message ----------------------------------------------

  inline GetAsyncCommandResponse* New() const { return New(NULL); }

  GetAsyncCommandResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetAsyncCommandResponse& from);
  void MergeFrom(const GetAsyncCommandResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetAsyncCommandResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef GetAsyncCommandResponse_SetupDataSource SetupDataSource;
  typedef GetAsyncCommandResponse_StartDataSource StartDataSource;
  typedef GetAsyncCommandResponse_StopDataSource StopDataSource;
  typedef GetAsyncCommandResponse_SetupTracing SetupTracing;
  typedef GetAsyncCommandResponse_Flush Flush;
  typedef GetAsyncCommandResponse_ClearIncrementalState ClearIncrementalState;

  // accessors -------------------------------------------------------

  // optional .perfetto.protos.GetAsyncCommandResponse.SetupTracing setup_tracing = 3;
  bool has_setup_tracing() const;
  void clear_setup_tracing();
  static const int kSetupTracingFieldNumber = 3;
  const ::perfetto::protos::GetAsyncCommandResponse_SetupTracing& setup_tracing() const;
  ::perfetto::protos::GetAsyncCommandResponse_SetupTracing* mutable_setup_tracing();
  ::perfetto::protos::GetAsyncCommandResponse_SetupTracing* release_setup_tracing();
  void set_allocated_setup_tracing(::perfetto::protos::GetAsyncCommandResponse_SetupTracing* setup_tracing);

  // optional .perfetto.protos.GetAsyncCommandResponse.SetupDataSource setup_data_source = 6;
  bool has_setup_data_source() const;
  void clear_setup_data_source();
  static const int kSetupDataSourceFieldNumber = 6;
  const ::perfetto::protos::GetAsyncCommandResponse_SetupDataSource& setup_data_source() const;
  ::perfetto::protos::GetAsyncCommandResponse_SetupDataSource* mutable_setup_data_source();
  ::perfetto::protos::GetAsyncCommandResponse_SetupDataSource* release_setup_data_source();
  void set_allocated_setup_data_source(::perfetto::protos::GetAsyncCommandResponse_SetupDataSource* setup_data_source);

  // optional .perfetto.protos.GetAsyncCommandResponse.StartDataSource start_data_source = 1;
  bool has_start_data_source() const;
  void clear_start_data_source();
  static const int kStartDataSourceFieldNumber = 1;
  const ::perfetto::protos::GetAsyncCommandResponse_StartDataSource& start_data_source() const;
  ::perfetto::protos::GetAsyncCommandResponse_StartDataSource* mutable_start_data_source();
  ::perfetto::protos::GetAsyncCommandResponse_StartDataSource* release_start_data_source();
  void set_allocated_start_data_source(::perfetto::protos::GetAsyncCommandResponse_StartDataSource* start_data_source);

  // optional .perfetto.protos.GetAsyncCommandResponse.StopDataSource stop_data_source = 2;
  bool has_stop_data_source() const;
  void clear_stop_data_source();
  static const int kStopDataSourceFieldNumber = 2;
  const ::perfetto::protos::GetAsyncCommandResponse_StopDataSource& stop_data_source() const;
  ::perfetto::protos::GetAsyncCommandResponse_StopDataSource* mutable_stop_data_source();
  ::perfetto::protos::GetAsyncCommandResponse_StopDataSource* release_stop_data_source();
  void set_allocated_stop_data_source(::perfetto::protos::GetAsyncCommandResponse_StopDataSource* stop_data_source);

  // optional .perfetto.protos.GetAsyncCommandResponse.Flush flush = 5;
  bool has_flush() const;
  void clear_flush();
  static const int kFlushFieldNumber = 5;
  const ::perfetto::protos::GetAsyncCommandResponse_Flush& flush() const;
  ::perfetto::protos::GetAsyncCommandResponse_Flush* mutable_flush();
  ::perfetto::protos::GetAsyncCommandResponse_Flush* release_flush();
  void set_allocated_flush(::perfetto::protos::GetAsyncCommandResponse_Flush* flush);

  // optional .perfetto.protos.GetAsyncCommandResponse.ClearIncrementalState clear_incremental_state = 7;
  bool has_clear_incremental_state() const;
  void clear_clear_incremental_state();
  static const int kClearIncrementalStateFieldNumber = 7;
  const ::perfetto::protos::GetAsyncCommandResponse_ClearIncrementalState& clear_incremental_state() const;
  ::perfetto::protos::GetAsyncCommandResponse_ClearIncrementalState* mutable_clear_incremental_state();
  ::perfetto::protos::GetAsyncCommandResponse_ClearIncrementalState* release_clear_incremental_state();
  void set_allocated_clear_incremental_state(::perfetto::protos::GetAsyncCommandResponse_ClearIncrementalState* clear_incremental_state);

  CmdCase cmd_case() const;
  // @@protoc_insertion_point(class_scope:perfetto.protos.GetAsyncCommandResponse)
 private:
  inline void set_has_setup_tracing();
  inline void set_has_setup_data_source();
  inline void set_has_start_data_source();
  inline void set_has_stop_data_source();
  inline void set_has_flush();
  inline void set_has_clear_incremental_state();

  inline bool has_cmd() const;
  void clear_cmd();
  inline void clear_has_cmd();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union CmdUnion {
    CmdUnion() {}
    ::perfetto::protos::GetAsyncCommandResponse_SetupTracing* setup_tracing_;
    ::perfetto::protos::GetAsyncCommandResponse_SetupDataSource* setup_data_source_;
    ::perfetto::protos::GetAsyncCommandResponse_StartDataSource* start_data_source_;
    ::perfetto::protos::GetAsyncCommandResponse_StopDataSource* stop_data_source_;
    ::perfetto::protos::GetAsyncCommandResponse_Flush* flush_;
    ::perfetto::protos::GetAsyncCommandResponse_ClearIncrementalState* clear_incremental_state_;
  } cmd_;
  ::google::protobuf::uint32 _oneof_case_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static GetAsyncCommandResponse* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// InitializeConnectionRequest

// optional uint32 shared_memory_page_size_hint_bytes = 1;
inline bool InitializeConnectionRequest::has_shared_memory_page_size_hint_bytes() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InitializeConnectionRequest::set_has_shared_memory_page_size_hint_bytes() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InitializeConnectionRequest::clear_has_shared_memory_page_size_hint_bytes() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InitializeConnectionRequest::clear_shared_memory_page_size_hint_bytes() {
  shared_memory_page_size_hint_bytes_ = 0u;
  clear_has_shared_memory_page_size_hint_bytes();
}
inline ::google::protobuf::uint32 InitializeConnectionRequest::shared_memory_page_size_hint_bytes() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InitializeConnectionRequest.shared_memory_page_size_hint_bytes)
  return shared_memory_page_size_hint_bytes_;
}
inline void InitializeConnectionRequest::set_shared_memory_page_size_hint_bytes(::google::protobuf::uint32 value) {
  set_has_shared_memory_page_size_hint_bytes();
  shared_memory_page_size_hint_bytes_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.InitializeConnectionRequest.shared_memory_page_size_hint_bytes)
}

// optional uint32 shared_memory_size_hint_bytes = 2;
inline bool InitializeConnectionRequest::has_shared_memory_size_hint_bytes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InitializeConnectionRequest::set_has_shared_memory_size_hint_bytes() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InitializeConnectionRequest::clear_has_shared_memory_size_hint_bytes() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InitializeConnectionRequest::clear_shared_memory_size_hint_bytes() {
  shared_memory_size_hint_bytes_ = 0u;
  clear_has_shared_memory_size_hint_bytes();
}
inline ::google::protobuf::uint32 InitializeConnectionRequest::shared_memory_size_hint_bytes() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InitializeConnectionRequest.shared_memory_size_hint_bytes)
  return shared_memory_size_hint_bytes_;
}
inline void InitializeConnectionRequest::set_shared_memory_size_hint_bytes(::google::protobuf::uint32 value) {
  set_has_shared_memory_size_hint_bytes();
  shared_memory_size_hint_bytes_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.InitializeConnectionRequest.shared_memory_size_hint_bytes)
}

// optional string producer_name = 3;
inline bool InitializeConnectionRequest::has_producer_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InitializeConnectionRequest::set_has_producer_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InitializeConnectionRequest::clear_has_producer_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InitializeConnectionRequest::clear_producer_name() {
  producer_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_producer_name();
}
inline const ::std::string& InitializeConnectionRequest::producer_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InitializeConnectionRequest.producer_name)
  return producer_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InitializeConnectionRequest::set_producer_name(const ::std::string& value) {
  set_has_producer_name();
  producer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.InitializeConnectionRequest.producer_name)
}
inline void InitializeConnectionRequest::set_producer_name(const char* value) {
  set_has_producer_name();
  producer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.InitializeConnectionRequest.producer_name)
}
inline void InitializeConnectionRequest::set_producer_name(const char* value, size_t size) {
  set_has_producer_name();
  producer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.InitializeConnectionRequest.producer_name)
}
inline ::std::string* InitializeConnectionRequest::mutable_producer_name() {
  set_has_producer_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.InitializeConnectionRequest.producer_name)
  return producer_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InitializeConnectionRequest::release_producer_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.InitializeConnectionRequest.producer_name)
  clear_has_producer_name();
  return producer_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InitializeConnectionRequest::set_allocated_producer_name(::std::string* producer_name) {
  if (producer_name != NULL) {
    set_has_producer_name();
  } else {
    clear_has_producer_name();
  }
  producer_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), producer_name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.InitializeConnectionRequest.producer_name)
}

// optional .perfetto.protos.InitializeConnectionRequest.ProducerSMBScrapingMode smb_scraping_mode = 4;
inline bool InitializeConnectionRequest::has_smb_scraping_mode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InitializeConnectionRequest::set_has_smb_scraping_mode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InitializeConnectionRequest::clear_has_smb_scraping_mode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InitializeConnectionRequest::clear_smb_scraping_mode() {
  smb_scraping_mode_ = 0;
  clear_has_smb_scraping_mode();
}
inline ::perfetto::protos::InitializeConnectionRequest_ProducerSMBScrapingMode InitializeConnectionRequest::smb_scraping_mode() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InitializeConnectionRequest.smb_scraping_mode)
  return static_cast< ::perfetto::protos::InitializeConnectionRequest_ProducerSMBScrapingMode >(smb_scraping_mode_);
}
inline void InitializeConnectionRequest::set_smb_scraping_mode(::perfetto::protos::InitializeConnectionRequest_ProducerSMBScrapingMode value) {
  assert(::perfetto::protos::InitializeConnectionRequest_ProducerSMBScrapingMode_IsValid(value));
  set_has_smb_scraping_mode();
  smb_scraping_mode_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.InitializeConnectionRequest.smb_scraping_mode)
}

// optional .perfetto.protos.InitializeConnectionRequest.ProducerBuildFlags build_flags = 5;
inline bool InitializeConnectionRequest::has_build_flags() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InitializeConnectionRequest::set_has_build_flags() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InitializeConnectionRequest::clear_has_build_flags() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InitializeConnectionRequest::clear_build_flags() {
  build_flags_ = 0;
  clear_has_build_flags();
}
inline ::perfetto::protos::InitializeConnectionRequest_ProducerBuildFlags InitializeConnectionRequest::build_flags() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InitializeConnectionRequest.build_flags)
  return static_cast< ::perfetto::protos::InitializeConnectionRequest_ProducerBuildFlags >(build_flags_);
}
inline void InitializeConnectionRequest::set_build_flags(::perfetto::protos::InitializeConnectionRequest_ProducerBuildFlags value) {
  assert(::perfetto::protos::InitializeConnectionRequest_ProducerBuildFlags_IsValid(value));
  set_has_build_flags();
  build_flags_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.InitializeConnectionRequest.build_flags)
}

// -------------------------------------------------------------------

// InitializeConnectionResponse

// -------------------------------------------------------------------

// RegisterDataSourceRequest

// optional .perfetto.protos.DataSourceDescriptor data_source_descriptor = 1;
inline bool RegisterDataSourceRequest::has_data_source_descriptor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterDataSourceRequest::set_has_data_source_descriptor() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterDataSourceRequest::clear_has_data_source_descriptor() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterDataSourceRequest::clear_data_source_descriptor() {
  if (data_source_descriptor_ != NULL) data_source_descriptor_->::perfetto::protos::DataSourceDescriptor::Clear();
  clear_has_data_source_descriptor();
}
inline const ::perfetto::protos::DataSourceDescriptor& RegisterDataSourceRequest::data_source_descriptor() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.RegisterDataSourceRequest.data_source_descriptor)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return data_source_descriptor_ != NULL ? *data_source_descriptor_ : *default_instance().data_source_descriptor_;
#else
  return data_source_descriptor_ != NULL ? *data_source_descriptor_ : *default_instance_->data_source_descriptor_;
#endif
}
inline ::perfetto::protos::DataSourceDescriptor* RegisterDataSourceRequest::mutable_data_source_descriptor() {
  set_has_data_source_descriptor();
  if (data_source_descriptor_ == NULL) {
    data_source_descriptor_ = new ::perfetto::protos::DataSourceDescriptor;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.RegisterDataSourceRequest.data_source_descriptor)
  return data_source_descriptor_;
}
inline ::perfetto::protos::DataSourceDescriptor* RegisterDataSourceRequest::release_data_source_descriptor() {
  // @@protoc_insertion_point(field_release:perfetto.protos.RegisterDataSourceRequest.data_source_descriptor)
  clear_has_data_source_descriptor();
  ::perfetto::protos::DataSourceDescriptor* temp = data_source_descriptor_;
  data_source_descriptor_ = NULL;
  return temp;
}
inline void RegisterDataSourceRequest::set_allocated_data_source_descriptor(::perfetto::protos::DataSourceDescriptor* data_source_descriptor) {
  delete data_source_descriptor_;
  data_source_descriptor_ = data_source_descriptor;
  if (data_source_descriptor) {
    set_has_data_source_descriptor();
  } else {
    clear_has_data_source_descriptor();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.RegisterDataSourceRequest.data_source_descriptor)
}

// -------------------------------------------------------------------

// RegisterDataSourceResponse

// optional string error = 1;
inline bool RegisterDataSourceResponse::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterDataSourceResponse::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterDataSourceResponse::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterDataSourceResponse::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error();
}
inline const ::std::string& RegisterDataSourceResponse::error() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.RegisterDataSourceResponse.error)
  return error_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterDataSourceResponse::set_error(const ::std::string& value) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.RegisterDataSourceResponse.error)
}
inline void RegisterDataSourceResponse::set_error(const char* value) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.RegisterDataSourceResponse.error)
}
inline void RegisterDataSourceResponse::set_error(const char* value, size_t size) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.RegisterDataSourceResponse.error)
}
inline ::std::string* RegisterDataSourceResponse::mutable_error() {
  set_has_error();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.RegisterDataSourceResponse.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegisterDataSourceResponse::release_error() {
  // @@protoc_insertion_point(field_release:perfetto.protos.RegisterDataSourceResponse.error)
  clear_has_error();
  return error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterDataSourceResponse::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    set_has_error();
  } else {
    clear_has_error();
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.RegisterDataSourceResponse.error)
}

// -------------------------------------------------------------------

// UnregisterDataSourceRequest

// optional string data_source_name = 1;
inline bool UnregisterDataSourceRequest::has_data_source_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnregisterDataSourceRequest::set_has_data_source_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnregisterDataSourceRequest::clear_has_data_source_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnregisterDataSourceRequest::clear_data_source_name() {
  data_source_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data_source_name();
}
inline const ::std::string& UnregisterDataSourceRequest::data_source_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.UnregisterDataSourceRequest.data_source_name)
  return data_source_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UnregisterDataSourceRequest::set_data_source_name(const ::std::string& value) {
  set_has_data_source_name();
  data_source_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.UnregisterDataSourceRequest.data_source_name)
}
inline void UnregisterDataSourceRequest::set_data_source_name(const char* value) {
  set_has_data_source_name();
  data_source_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.UnregisterDataSourceRequest.data_source_name)
}
inline void UnregisterDataSourceRequest::set_data_source_name(const char* value, size_t size) {
  set_has_data_source_name();
  data_source_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.UnregisterDataSourceRequest.data_source_name)
}
inline ::std::string* UnregisterDataSourceRequest::mutable_data_source_name() {
  set_has_data_source_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.UnregisterDataSourceRequest.data_source_name)
  return data_source_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UnregisterDataSourceRequest::release_data_source_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.UnregisterDataSourceRequest.data_source_name)
  clear_has_data_source_name();
  return data_source_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UnregisterDataSourceRequest::set_allocated_data_source_name(::std::string* data_source_name) {
  if (data_source_name != NULL) {
    set_has_data_source_name();
  } else {
    clear_has_data_source_name();
  }
  data_source_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data_source_name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.UnregisterDataSourceRequest.data_source_name)
}

// -------------------------------------------------------------------

// UnregisterDataSourceResponse

// -------------------------------------------------------------------

// RegisterTraceWriterRequest

// optional uint32 trace_writer_id = 1;
inline bool RegisterTraceWriterRequest::has_trace_writer_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterTraceWriterRequest::set_has_trace_writer_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterTraceWriterRequest::clear_has_trace_writer_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterTraceWriterRequest::clear_trace_writer_id() {
  trace_writer_id_ = 0u;
  clear_has_trace_writer_id();
}
inline ::google::protobuf::uint32 RegisterTraceWriterRequest::trace_writer_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.RegisterTraceWriterRequest.trace_writer_id)
  return trace_writer_id_;
}
inline void RegisterTraceWriterRequest::set_trace_writer_id(::google::protobuf::uint32 value) {
  set_has_trace_writer_id();
  trace_writer_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.RegisterTraceWriterRequest.trace_writer_id)
}

// optional uint32 target_buffer = 2;
inline bool RegisterTraceWriterRequest::has_target_buffer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegisterTraceWriterRequest::set_has_target_buffer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegisterTraceWriterRequest::clear_has_target_buffer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegisterTraceWriterRequest::clear_target_buffer() {
  target_buffer_ = 0u;
  clear_has_target_buffer();
}
inline ::google::protobuf::uint32 RegisterTraceWriterRequest::target_buffer() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.RegisterTraceWriterRequest.target_buffer)
  return target_buffer_;
}
inline void RegisterTraceWriterRequest::set_target_buffer(::google::protobuf::uint32 value) {
  set_has_target_buffer();
  target_buffer_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.RegisterTraceWriterRequest.target_buffer)
}

// -------------------------------------------------------------------

// RegisterTraceWriterResponse

// -------------------------------------------------------------------

// UnregisterTraceWriterRequest

// optional uint32 trace_writer_id = 1;
inline bool UnregisterTraceWriterRequest::has_trace_writer_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnregisterTraceWriterRequest::set_has_trace_writer_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnregisterTraceWriterRequest::clear_has_trace_writer_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnregisterTraceWriterRequest::clear_trace_writer_id() {
  trace_writer_id_ = 0u;
  clear_has_trace_writer_id();
}
inline ::google::protobuf::uint32 UnregisterTraceWriterRequest::trace_writer_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.UnregisterTraceWriterRequest.trace_writer_id)
  return trace_writer_id_;
}
inline void UnregisterTraceWriterRequest::set_trace_writer_id(::google::protobuf::uint32 value) {
  set_has_trace_writer_id();
  trace_writer_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.UnregisterTraceWriterRequest.trace_writer_id)
}

// -------------------------------------------------------------------

// UnregisterTraceWriterResponse

// -------------------------------------------------------------------

// CommitDataResponse

// -------------------------------------------------------------------

// NotifyDataSourceStartedRequest

// optional uint64 data_source_id = 1;
inline bool NotifyDataSourceStartedRequest::has_data_source_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NotifyDataSourceStartedRequest::set_has_data_source_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NotifyDataSourceStartedRequest::clear_has_data_source_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NotifyDataSourceStartedRequest::clear_data_source_id() {
  data_source_id_ = GOOGLE_ULONGLONG(0);
  clear_has_data_source_id();
}
inline ::google::protobuf::uint64 NotifyDataSourceStartedRequest::data_source_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.NotifyDataSourceStartedRequest.data_source_id)
  return data_source_id_;
}
inline void NotifyDataSourceStartedRequest::set_data_source_id(::google::protobuf::uint64 value) {
  set_has_data_source_id();
  data_source_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.NotifyDataSourceStartedRequest.data_source_id)
}

// -------------------------------------------------------------------

// NotifyDataSourceStartedResponse

// -------------------------------------------------------------------

// NotifyDataSourceStoppedRequest

// optional uint64 data_source_id = 1;
inline bool NotifyDataSourceStoppedRequest::has_data_source_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NotifyDataSourceStoppedRequest::set_has_data_source_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NotifyDataSourceStoppedRequest::clear_has_data_source_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NotifyDataSourceStoppedRequest::clear_data_source_id() {
  data_source_id_ = GOOGLE_ULONGLONG(0);
  clear_has_data_source_id();
}
inline ::google::protobuf::uint64 NotifyDataSourceStoppedRequest::data_source_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.NotifyDataSourceStoppedRequest.data_source_id)
  return data_source_id_;
}
inline void NotifyDataSourceStoppedRequest::set_data_source_id(::google::protobuf::uint64 value) {
  set_has_data_source_id();
  data_source_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.NotifyDataSourceStoppedRequest.data_source_id)
}

// -------------------------------------------------------------------

// NotifyDataSourceStoppedResponse

// -------------------------------------------------------------------

// ActivateTriggersRequest

// repeated string trigger_names = 1;
inline int ActivateTriggersRequest::trigger_names_size() const {
  return trigger_names_.size();
}
inline void ActivateTriggersRequest::clear_trigger_names() {
  trigger_names_.Clear();
}
inline const ::std::string& ActivateTriggersRequest::trigger_names(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ActivateTriggersRequest.trigger_names)
  return trigger_names_.Get(index);
}
inline ::std::string* ActivateTriggersRequest::mutable_trigger_names(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.ActivateTriggersRequest.trigger_names)
  return trigger_names_.Mutable(index);
}
inline void ActivateTriggersRequest::set_trigger_names(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.ActivateTriggersRequest.trigger_names)
  trigger_names_.Mutable(index)->assign(value);
}
inline void ActivateTriggersRequest::set_trigger_names(int index, const char* value) {
  trigger_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.ActivateTriggersRequest.trigger_names)
}
inline void ActivateTriggersRequest::set_trigger_names(int index, const char* value, size_t size) {
  trigger_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.ActivateTriggersRequest.trigger_names)
}
inline ::std::string* ActivateTriggersRequest::add_trigger_names() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.ActivateTriggersRequest.trigger_names)
  return trigger_names_.Add();
}
inline void ActivateTriggersRequest::add_trigger_names(const ::std::string& value) {
  trigger_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.ActivateTriggersRequest.trigger_names)
}
inline void ActivateTriggersRequest::add_trigger_names(const char* value) {
  trigger_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.ActivateTriggersRequest.trigger_names)
}
inline void ActivateTriggersRequest::add_trigger_names(const char* value, size_t size) {
  trigger_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.ActivateTriggersRequest.trigger_names)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ActivateTriggersRequest::trigger_names() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.ActivateTriggersRequest.trigger_names)
  return trigger_names_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ActivateTriggersRequest::mutable_trigger_names() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.ActivateTriggersRequest.trigger_names)
  return &trigger_names_;
}

// -------------------------------------------------------------------

// ActivateTriggersResponse

// -------------------------------------------------------------------

// GetAsyncCommandRequest

// -------------------------------------------------------------------

// GetAsyncCommandResponse_SetupDataSource

// optional uint64 new_instance_id = 1;
inline bool GetAsyncCommandResponse_SetupDataSource::has_new_instance_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetAsyncCommandResponse_SetupDataSource::set_has_new_instance_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetAsyncCommandResponse_SetupDataSource::clear_has_new_instance_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetAsyncCommandResponse_SetupDataSource::clear_new_instance_id() {
  new_instance_id_ = GOOGLE_ULONGLONG(0);
  clear_has_new_instance_id();
}
inline ::google::protobuf::uint64 GetAsyncCommandResponse_SetupDataSource::new_instance_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.SetupDataSource.new_instance_id)
  return new_instance_id_;
}
inline void GetAsyncCommandResponse_SetupDataSource::set_new_instance_id(::google::protobuf::uint64 value) {
  set_has_new_instance_id();
  new_instance_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.GetAsyncCommandResponse.SetupDataSource.new_instance_id)
}

// optional .perfetto.protos.DataSourceConfig config = 2;
inline bool GetAsyncCommandResponse_SetupDataSource::has_config() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetAsyncCommandResponse_SetupDataSource::set_has_config() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetAsyncCommandResponse_SetupDataSource::clear_has_config() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetAsyncCommandResponse_SetupDataSource::clear_config() {
  if (config_ != NULL) config_->::perfetto::protos::DataSourceConfig::Clear();
  clear_has_config();
}
inline const ::perfetto::protos::DataSourceConfig& GetAsyncCommandResponse_SetupDataSource::config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.SetupDataSource.config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return config_ != NULL ? *config_ : *default_instance().config_;
#else
  return config_ != NULL ? *config_ : *default_instance_->config_;
#endif
}
inline ::perfetto::protos::DataSourceConfig* GetAsyncCommandResponse_SetupDataSource::mutable_config() {
  set_has_config();
  if (config_ == NULL) {
    config_ = new ::perfetto::protos::DataSourceConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GetAsyncCommandResponse.SetupDataSource.config)
  return config_;
}
inline ::perfetto::protos::DataSourceConfig* GetAsyncCommandResponse_SetupDataSource::release_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.GetAsyncCommandResponse.SetupDataSource.config)
  clear_has_config();
  ::perfetto::protos::DataSourceConfig* temp = config_;
  config_ = NULL;
  return temp;
}
inline void GetAsyncCommandResponse_SetupDataSource::set_allocated_config(::perfetto::protos::DataSourceConfig* config) {
  delete config_;
  config_ = config;
  if (config) {
    set_has_config();
  } else {
    clear_has_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.GetAsyncCommandResponse.SetupDataSource.config)
}

// -------------------------------------------------------------------

// GetAsyncCommandResponse_StartDataSource

// optional uint64 new_instance_id = 1;
inline bool GetAsyncCommandResponse_StartDataSource::has_new_instance_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetAsyncCommandResponse_StartDataSource::set_has_new_instance_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetAsyncCommandResponse_StartDataSource::clear_has_new_instance_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetAsyncCommandResponse_StartDataSource::clear_new_instance_id() {
  new_instance_id_ = GOOGLE_ULONGLONG(0);
  clear_has_new_instance_id();
}
inline ::google::protobuf::uint64 GetAsyncCommandResponse_StartDataSource::new_instance_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.StartDataSource.new_instance_id)
  return new_instance_id_;
}
inline void GetAsyncCommandResponse_StartDataSource::set_new_instance_id(::google::protobuf::uint64 value) {
  set_has_new_instance_id();
  new_instance_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.GetAsyncCommandResponse.StartDataSource.new_instance_id)
}

// optional .perfetto.protos.DataSourceConfig config = 2;
inline bool GetAsyncCommandResponse_StartDataSource::has_config() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetAsyncCommandResponse_StartDataSource::set_has_config() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetAsyncCommandResponse_StartDataSource::clear_has_config() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetAsyncCommandResponse_StartDataSource::clear_config() {
  if (config_ != NULL) config_->::perfetto::protos::DataSourceConfig::Clear();
  clear_has_config();
}
inline const ::perfetto::protos::DataSourceConfig& GetAsyncCommandResponse_StartDataSource::config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.StartDataSource.config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return config_ != NULL ? *config_ : *default_instance().config_;
#else
  return config_ != NULL ? *config_ : *default_instance_->config_;
#endif
}
inline ::perfetto::protos::DataSourceConfig* GetAsyncCommandResponse_StartDataSource::mutable_config() {
  set_has_config();
  if (config_ == NULL) {
    config_ = new ::perfetto::protos::DataSourceConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GetAsyncCommandResponse.StartDataSource.config)
  return config_;
}
inline ::perfetto::protos::DataSourceConfig* GetAsyncCommandResponse_StartDataSource::release_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.GetAsyncCommandResponse.StartDataSource.config)
  clear_has_config();
  ::perfetto::protos::DataSourceConfig* temp = config_;
  config_ = NULL;
  return temp;
}
inline void GetAsyncCommandResponse_StartDataSource::set_allocated_config(::perfetto::protos::DataSourceConfig* config) {
  delete config_;
  config_ = config;
  if (config) {
    set_has_config();
  } else {
    clear_has_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.GetAsyncCommandResponse.StartDataSource.config)
}

// -------------------------------------------------------------------

// GetAsyncCommandResponse_StopDataSource

// optional uint64 instance_id = 1;
inline bool GetAsyncCommandResponse_StopDataSource::has_instance_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetAsyncCommandResponse_StopDataSource::set_has_instance_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetAsyncCommandResponse_StopDataSource::clear_has_instance_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetAsyncCommandResponse_StopDataSource::clear_instance_id() {
  instance_id_ = GOOGLE_ULONGLONG(0);
  clear_has_instance_id();
}
inline ::google::protobuf::uint64 GetAsyncCommandResponse_StopDataSource::instance_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.StopDataSource.instance_id)
  return instance_id_;
}
inline void GetAsyncCommandResponse_StopDataSource::set_instance_id(::google::protobuf::uint64 value) {
  set_has_instance_id();
  instance_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.GetAsyncCommandResponse.StopDataSource.instance_id)
}

// -------------------------------------------------------------------

// GetAsyncCommandResponse_SetupTracing

// optional uint32 shared_buffer_page_size_kb = 1;
inline bool GetAsyncCommandResponse_SetupTracing::has_shared_buffer_page_size_kb() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetAsyncCommandResponse_SetupTracing::set_has_shared_buffer_page_size_kb() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetAsyncCommandResponse_SetupTracing::clear_has_shared_buffer_page_size_kb() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetAsyncCommandResponse_SetupTracing::clear_shared_buffer_page_size_kb() {
  shared_buffer_page_size_kb_ = 0u;
  clear_has_shared_buffer_page_size_kb();
}
inline ::google::protobuf::uint32 GetAsyncCommandResponse_SetupTracing::shared_buffer_page_size_kb() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.SetupTracing.shared_buffer_page_size_kb)
  return shared_buffer_page_size_kb_;
}
inline void GetAsyncCommandResponse_SetupTracing::set_shared_buffer_page_size_kb(::google::protobuf::uint32 value) {
  set_has_shared_buffer_page_size_kb();
  shared_buffer_page_size_kb_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.GetAsyncCommandResponse.SetupTracing.shared_buffer_page_size_kb)
}

// -------------------------------------------------------------------

// GetAsyncCommandResponse_Flush

// repeated uint64 data_source_ids = 1;
inline int GetAsyncCommandResponse_Flush::data_source_ids_size() const {
  return data_source_ids_.size();
}
inline void GetAsyncCommandResponse_Flush::clear_data_source_ids() {
  data_source_ids_.Clear();
}
inline ::google::protobuf::uint64 GetAsyncCommandResponse_Flush::data_source_ids(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.Flush.data_source_ids)
  return data_source_ids_.Get(index);
}
inline void GetAsyncCommandResponse_Flush::set_data_source_ids(int index, ::google::protobuf::uint64 value) {
  data_source_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.GetAsyncCommandResponse.Flush.data_source_ids)
}
inline void GetAsyncCommandResponse_Flush::add_data_source_ids(::google::protobuf::uint64 value) {
  data_source_ids_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.GetAsyncCommandResponse.Flush.data_source_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
GetAsyncCommandResponse_Flush::data_source_ids() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.GetAsyncCommandResponse.Flush.data_source_ids)
  return data_source_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
GetAsyncCommandResponse_Flush::mutable_data_source_ids() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.GetAsyncCommandResponse.Flush.data_source_ids)
  return &data_source_ids_;
}

// optional uint64 request_id = 2;
inline bool GetAsyncCommandResponse_Flush::has_request_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetAsyncCommandResponse_Flush::set_has_request_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetAsyncCommandResponse_Flush::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetAsyncCommandResponse_Flush::clear_request_id() {
  request_id_ = GOOGLE_ULONGLONG(0);
  clear_has_request_id();
}
inline ::google::protobuf::uint64 GetAsyncCommandResponse_Flush::request_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.Flush.request_id)
  return request_id_;
}
inline void GetAsyncCommandResponse_Flush::set_request_id(::google::protobuf::uint64 value) {
  set_has_request_id();
  request_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.GetAsyncCommandResponse.Flush.request_id)
}

// -------------------------------------------------------------------

// GetAsyncCommandResponse_ClearIncrementalState

// repeated uint64 data_source_ids = 1;
inline int GetAsyncCommandResponse_ClearIncrementalState::data_source_ids_size() const {
  return data_source_ids_.size();
}
inline void GetAsyncCommandResponse_ClearIncrementalState::clear_data_source_ids() {
  data_source_ids_.Clear();
}
inline ::google::protobuf::uint64 GetAsyncCommandResponse_ClearIncrementalState::data_source_ids(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.ClearIncrementalState.data_source_ids)
  return data_source_ids_.Get(index);
}
inline void GetAsyncCommandResponse_ClearIncrementalState::set_data_source_ids(int index, ::google::protobuf::uint64 value) {
  data_source_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.GetAsyncCommandResponse.ClearIncrementalState.data_source_ids)
}
inline void GetAsyncCommandResponse_ClearIncrementalState::add_data_source_ids(::google::protobuf::uint64 value) {
  data_source_ids_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.GetAsyncCommandResponse.ClearIncrementalState.data_source_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
GetAsyncCommandResponse_ClearIncrementalState::data_source_ids() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.GetAsyncCommandResponse.ClearIncrementalState.data_source_ids)
  return data_source_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
GetAsyncCommandResponse_ClearIncrementalState::mutable_data_source_ids() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.GetAsyncCommandResponse.ClearIncrementalState.data_source_ids)
  return &data_source_ids_;
}

// -------------------------------------------------------------------

// GetAsyncCommandResponse

// optional .perfetto.protos.GetAsyncCommandResponse.SetupTracing setup_tracing = 3;
inline bool GetAsyncCommandResponse::has_setup_tracing() const {
  return cmd_case() == kSetupTracing;
}
inline void GetAsyncCommandResponse::set_has_setup_tracing() {
  _oneof_case_[0] = kSetupTracing;
}
inline void GetAsyncCommandResponse::clear_setup_tracing() {
  if (has_setup_tracing()) {
    delete cmd_.setup_tracing_;
    clear_has_cmd();
  }
}
inline  const ::perfetto::protos::GetAsyncCommandResponse_SetupTracing& GetAsyncCommandResponse::setup_tracing() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.setup_tracing)
  return has_setup_tracing()
      ? *cmd_.setup_tracing_
      : ::perfetto::protos::GetAsyncCommandResponse_SetupTracing::default_instance();
}
inline ::perfetto::protos::GetAsyncCommandResponse_SetupTracing* GetAsyncCommandResponse::mutable_setup_tracing() {
  if (!has_setup_tracing()) {
    clear_cmd();
    set_has_setup_tracing();
    cmd_.setup_tracing_ = new ::perfetto::protos::GetAsyncCommandResponse_SetupTracing;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GetAsyncCommandResponse.setup_tracing)
  return cmd_.setup_tracing_;
}
inline ::perfetto::protos::GetAsyncCommandResponse_SetupTracing* GetAsyncCommandResponse::release_setup_tracing() {
  // @@protoc_insertion_point(field_release:perfetto.protos.GetAsyncCommandResponse.setup_tracing)
  if (has_setup_tracing()) {
    clear_has_cmd();
    ::perfetto::protos::GetAsyncCommandResponse_SetupTracing* temp = cmd_.setup_tracing_;
    cmd_.setup_tracing_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GetAsyncCommandResponse::set_allocated_setup_tracing(::perfetto::protos::GetAsyncCommandResponse_SetupTracing* setup_tracing) {
  clear_cmd();
  if (setup_tracing) {
    set_has_setup_tracing();
    cmd_.setup_tracing_ = setup_tracing;
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.GetAsyncCommandResponse.setup_tracing)
}

// optional .perfetto.protos.GetAsyncCommandResponse.SetupDataSource setup_data_source = 6;
inline bool GetAsyncCommandResponse::has_setup_data_source() const {
  return cmd_case() == kSetupDataSource;
}
inline void GetAsyncCommandResponse::set_has_setup_data_source() {
  _oneof_case_[0] = kSetupDataSource;
}
inline void GetAsyncCommandResponse::clear_setup_data_source() {
  if (has_setup_data_source()) {
    delete cmd_.setup_data_source_;
    clear_has_cmd();
  }
}
inline  const ::perfetto::protos::GetAsyncCommandResponse_SetupDataSource& GetAsyncCommandResponse::setup_data_source() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.setup_data_source)
  return has_setup_data_source()
      ? *cmd_.setup_data_source_
      : ::perfetto::protos::GetAsyncCommandResponse_SetupDataSource::default_instance();
}
inline ::perfetto::protos::GetAsyncCommandResponse_SetupDataSource* GetAsyncCommandResponse::mutable_setup_data_source() {
  if (!has_setup_data_source()) {
    clear_cmd();
    set_has_setup_data_source();
    cmd_.setup_data_source_ = new ::perfetto::protos::GetAsyncCommandResponse_SetupDataSource;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GetAsyncCommandResponse.setup_data_source)
  return cmd_.setup_data_source_;
}
inline ::perfetto::protos::GetAsyncCommandResponse_SetupDataSource* GetAsyncCommandResponse::release_setup_data_source() {
  // @@protoc_insertion_point(field_release:perfetto.protos.GetAsyncCommandResponse.setup_data_source)
  if (has_setup_data_source()) {
    clear_has_cmd();
    ::perfetto::protos::GetAsyncCommandResponse_SetupDataSource* temp = cmd_.setup_data_source_;
    cmd_.setup_data_source_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GetAsyncCommandResponse::set_allocated_setup_data_source(::perfetto::protos::GetAsyncCommandResponse_SetupDataSource* setup_data_source) {
  clear_cmd();
  if (setup_data_source) {
    set_has_setup_data_source();
    cmd_.setup_data_source_ = setup_data_source;
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.GetAsyncCommandResponse.setup_data_source)
}

// optional .perfetto.protos.GetAsyncCommandResponse.StartDataSource start_data_source = 1;
inline bool GetAsyncCommandResponse::has_start_data_source() const {
  return cmd_case() == kStartDataSource;
}
inline void GetAsyncCommandResponse::set_has_start_data_source() {
  _oneof_case_[0] = kStartDataSource;
}
inline void GetAsyncCommandResponse::clear_start_data_source() {
  if (has_start_data_source()) {
    delete cmd_.start_data_source_;
    clear_has_cmd();
  }
}
inline  const ::perfetto::protos::GetAsyncCommandResponse_StartDataSource& GetAsyncCommandResponse::start_data_source() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.start_data_source)
  return has_start_data_source()
      ? *cmd_.start_data_source_
      : ::perfetto::protos::GetAsyncCommandResponse_StartDataSource::default_instance();
}
inline ::perfetto::protos::GetAsyncCommandResponse_StartDataSource* GetAsyncCommandResponse::mutable_start_data_source() {
  if (!has_start_data_source()) {
    clear_cmd();
    set_has_start_data_source();
    cmd_.start_data_source_ = new ::perfetto::protos::GetAsyncCommandResponse_StartDataSource;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GetAsyncCommandResponse.start_data_source)
  return cmd_.start_data_source_;
}
inline ::perfetto::protos::GetAsyncCommandResponse_StartDataSource* GetAsyncCommandResponse::release_start_data_source() {
  // @@protoc_insertion_point(field_release:perfetto.protos.GetAsyncCommandResponse.start_data_source)
  if (has_start_data_source()) {
    clear_has_cmd();
    ::perfetto::protos::GetAsyncCommandResponse_StartDataSource* temp = cmd_.start_data_source_;
    cmd_.start_data_source_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GetAsyncCommandResponse::set_allocated_start_data_source(::perfetto::protos::GetAsyncCommandResponse_StartDataSource* start_data_source) {
  clear_cmd();
  if (start_data_source) {
    set_has_start_data_source();
    cmd_.start_data_source_ = start_data_source;
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.GetAsyncCommandResponse.start_data_source)
}

// optional .perfetto.protos.GetAsyncCommandResponse.StopDataSource stop_data_source = 2;
inline bool GetAsyncCommandResponse::has_stop_data_source() const {
  return cmd_case() == kStopDataSource;
}
inline void GetAsyncCommandResponse::set_has_stop_data_source() {
  _oneof_case_[0] = kStopDataSource;
}
inline void GetAsyncCommandResponse::clear_stop_data_source() {
  if (has_stop_data_source()) {
    delete cmd_.stop_data_source_;
    clear_has_cmd();
  }
}
inline  const ::perfetto::protos::GetAsyncCommandResponse_StopDataSource& GetAsyncCommandResponse::stop_data_source() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.stop_data_source)
  return has_stop_data_source()
      ? *cmd_.stop_data_source_
      : ::perfetto::protos::GetAsyncCommandResponse_StopDataSource::default_instance();
}
inline ::perfetto::protos::GetAsyncCommandResponse_StopDataSource* GetAsyncCommandResponse::mutable_stop_data_source() {
  if (!has_stop_data_source()) {
    clear_cmd();
    set_has_stop_data_source();
    cmd_.stop_data_source_ = new ::perfetto::protos::GetAsyncCommandResponse_StopDataSource;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GetAsyncCommandResponse.stop_data_source)
  return cmd_.stop_data_source_;
}
inline ::perfetto::protos::GetAsyncCommandResponse_StopDataSource* GetAsyncCommandResponse::release_stop_data_source() {
  // @@protoc_insertion_point(field_release:perfetto.protos.GetAsyncCommandResponse.stop_data_source)
  if (has_stop_data_source()) {
    clear_has_cmd();
    ::perfetto::protos::GetAsyncCommandResponse_StopDataSource* temp = cmd_.stop_data_source_;
    cmd_.stop_data_source_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GetAsyncCommandResponse::set_allocated_stop_data_source(::perfetto::protos::GetAsyncCommandResponse_StopDataSource* stop_data_source) {
  clear_cmd();
  if (stop_data_source) {
    set_has_stop_data_source();
    cmd_.stop_data_source_ = stop_data_source;
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.GetAsyncCommandResponse.stop_data_source)
}

// optional .perfetto.protos.GetAsyncCommandResponse.Flush flush = 5;
inline bool GetAsyncCommandResponse::has_flush() const {
  return cmd_case() == kFlush;
}
inline void GetAsyncCommandResponse::set_has_flush() {
  _oneof_case_[0] = kFlush;
}
inline void GetAsyncCommandResponse::clear_flush() {
  if (has_flush()) {
    delete cmd_.flush_;
    clear_has_cmd();
  }
}
inline  const ::perfetto::protos::GetAsyncCommandResponse_Flush& GetAsyncCommandResponse::flush() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.flush)
  return has_flush()
      ? *cmd_.flush_
      : ::perfetto::protos::GetAsyncCommandResponse_Flush::default_instance();
}
inline ::perfetto::protos::GetAsyncCommandResponse_Flush* GetAsyncCommandResponse::mutable_flush() {
  if (!has_flush()) {
    clear_cmd();
    set_has_flush();
    cmd_.flush_ = new ::perfetto::protos::GetAsyncCommandResponse_Flush;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GetAsyncCommandResponse.flush)
  return cmd_.flush_;
}
inline ::perfetto::protos::GetAsyncCommandResponse_Flush* GetAsyncCommandResponse::release_flush() {
  // @@protoc_insertion_point(field_release:perfetto.protos.GetAsyncCommandResponse.flush)
  if (has_flush()) {
    clear_has_cmd();
    ::perfetto::protos::GetAsyncCommandResponse_Flush* temp = cmd_.flush_;
    cmd_.flush_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GetAsyncCommandResponse::set_allocated_flush(::perfetto::protos::GetAsyncCommandResponse_Flush* flush) {
  clear_cmd();
  if (flush) {
    set_has_flush();
    cmd_.flush_ = flush;
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.GetAsyncCommandResponse.flush)
}

// optional .perfetto.protos.GetAsyncCommandResponse.ClearIncrementalState clear_incremental_state = 7;
inline bool GetAsyncCommandResponse::has_clear_incremental_state() const {
  return cmd_case() == kClearIncrementalState;
}
inline void GetAsyncCommandResponse::set_has_clear_incremental_state() {
  _oneof_case_[0] = kClearIncrementalState;
}
inline void GetAsyncCommandResponse::clear_clear_incremental_state() {
  if (has_clear_incremental_state()) {
    delete cmd_.clear_incremental_state_;
    clear_has_cmd();
  }
}
inline  const ::perfetto::protos::GetAsyncCommandResponse_ClearIncrementalState& GetAsyncCommandResponse::clear_incremental_state() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.clear_incremental_state)
  return has_clear_incremental_state()
      ? *cmd_.clear_incremental_state_
      : ::perfetto::protos::GetAsyncCommandResponse_ClearIncrementalState::default_instance();
}
inline ::perfetto::protos::GetAsyncCommandResponse_ClearIncrementalState* GetAsyncCommandResponse::mutable_clear_incremental_state() {
  if (!has_clear_incremental_state()) {
    clear_cmd();
    set_has_clear_incremental_state();
    cmd_.clear_incremental_state_ = new ::perfetto::protos::GetAsyncCommandResponse_ClearIncrementalState;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GetAsyncCommandResponse.clear_incremental_state)
  return cmd_.clear_incremental_state_;
}
inline ::perfetto::protos::GetAsyncCommandResponse_ClearIncrementalState* GetAsyncCommandResponse::release_clear_incremental_state() {
  // @@protoc_insertion_point(field_release:perfetto.protos.GetAsyncCommandResponse.clear_incremental_state)
  if (has_clear_incremental_state()) {
    clear_has_cmd();
    ::perfetto::protos::GetAsyncCommandResponse_ClearIncrementalState* temp = cmd_.clear_incremental_state_;
    cmd_.clear_incremental_state_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GetAsyncCommandResponse::set_allocated_clear_incremental_state(::perfetto::protos::GetAsyncCommandResponse_ClearIncrementalState* clear_incremental_state) {
  clear_cmd();
  if (clear_incremental_state) {
    set_has_clear_incremental_state();
    cmd_.clear_incremental_state_ = clear_incremental_state;
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.GetAsyncCommandResponse.clear_incremental_state)
}

inline bool GetAsyncCommandResponse::has_cmd() const {
  return cmd_case() != CMD_NOT_SET;
}
inline void GetAsyncCommandResponse::clear_has_cmd() {
  _oneof_case_[0] = CMD_NOT_SET;
}
inline GetAsyncCommandResponse::CmdCase GetAsyncCommandResponse::cmd_case() const {
  return GetAsyncCommandResponse::CmdCase(_oneof_case_[0]);
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::perfetto::protos::InitializeConnectionRequest_ProducerSMBScrapingMode> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::perfetto::protos::InitializeConnectionRequest_ProducerBuildFlags> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto__INCLUDED
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/ipc/producer_port.ipc.h
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/ipc/producer_port.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/ipc/producer_port.proto

#ifndef PROTOBUF_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
// gen_amalgamated expanded: #include "protos/perfetto/common/commit_data_request.pb.h"
// gen_amalgamated expanded: #include "protos/perfetto/config/data_source_config.pb.h"
// gen_amalgamated expanded: #include "protos/perfetto/common/data_source_descriptor.pb.h"
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();

class ActivateTriggersRequest;
class ActivateTriggersResponse;
class CommitDataResponse;
class GetAsyncCommandRequest;
class GetAsyncCommandResponse;
class GetAsyncCommandResponse_ClearIncrementalState;
class GetAsyncCommandResponse_Flush;
class GetAsyncCommandResponse_SetupDataSource;
class GetAsyncCommandResponse_SetupTracing;
class GetAsyncCommandResponse_StartDataSource;
class GetAsyncCommandResponse_StopDataSource;
class InitializeConnectionRequest;
class InitializeConnectionResponse;
class NotifyDataSourceStartedRequest;
class NotifyDataSourceStartedResponse;
class NotifyDataSourceStoppedRequest;
class NotifyDataSourceStoppedResponse;
class RegisterDataSourceRequest;
class RegisterDataSourceResponse;
class RegisterTraceWriterRequest;
class RegisterTraceWriterResponse;
class UnregisterDataSourceRequest;
class UnregisterDataSourceResponse;
class UnregisterTraceWriterRequest;
class UnregisterTraceWriterResponse;

enum InitializeConnectionRequest_ProducerSMBScrapingMode {
  InitializeConnectionRequest_ProducerSMBScrapingMode_SMB_SCRAPING_UNSPECIFIED = 0,
  InitializeConnectionRequest_ProducerSMBScrapingMode_SMB_SCRAPING_ENABLED = 1,
  InitializeConnectionRequest_ProducerSMBScrapingMode_SMB_SCRAPING_DISABLED = 2
};
bool InitializeConnectionRequest_ProducerSMBScrapingMode_IsValid(int value);
const InitializeConnectionRequest_ProducerSMBScrapingMode InitializeConnectionRequest_ProducerSMBScrapingMode_ProducerSMBScrapingMode_MIN = InitializeConnectionRequest_ProducerSMBScrapingMode_SMB_SCRAPING_UNSPECIFIED;
const InitializeConnectionRequest_ProducerSMBScrapingMode InitializeConnectionRequest_ProducerSMBScrapingMode_ProducerSMBScrapingMode_MAX = InitializeConnectionRequest_ProducerSMBScrapingMode_SMB_SCRAPING_DISABLED;
const int InitializeConnectionRequest_ProducerSMBScrapingMode_ProducerSMBScrapingMode_ARRAYSIZE = InitializeConnectionRequest_ProducerSMBScrapingMode_ProducerSMBScrapingMode_MAX + 1;

enum InitializeConnectionRequest_ProducerBuildFlags {
  InitializeConnectionRequest_ProducerBuildFlags_BUILD_FLAGS_UNSPECIFIED = 0,
  InitializeConnectionRequest_ProducerBuildFlags_BUILD_FLAGS_DCHECKS_ON = 1,
  InitializeConnectionRequest_ProducerBuildFlags_BUILD_FLAGS_DCHECKS_OFF = 2
};
bool InitializeConnectionRequest_ProducerBuildFlags_IsValid(int value);
const InitializeConnectionRequest_ProducerBuildFlags InitializeConnectionRequest_ProducerBuildFlags_ProducerBuildFlags_MIN = InitializeConnectionRequest_ProducerBuildFlags_BUILD_FLAGS_UNSPECIFIED;
const InitializeConnectionRequest_ProducerBuildFlags InitializeConnectionRequest_ProducerBuildFlags_ProducerBuildFlags_MAX = InitializeConnectionRequest_ProducerBuildFlags_BUILD_FLAGS_DCHECKS_OFF;
const int InitializeConnectionRequest_ProducerBuildFlags_ProducerBuildFlags_ARRAYSIZE = InitializeConnectionRequest_ProducerBuildFlags_ProducerBuildFlags_MAX + 1;

// ===================================================================

class InitializeConnectionRequest : public ::google::protobuf::MessageLite {
 public:
  InitializeConnectionRequest();
  virtual ~InitializeConnectionRequest();

  InitializeConnectionRequest(const InitializeConnectionRequest& from);

  inline InitializeConnectionRequest& operator=(const InitializeConnectionRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const InitializeConnectionRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const InitializeConnectionRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(InitializeConnectionRequest* other);

  // implements Message ----------------------------------------------

  inline InitializeConnectionRequest* New() const { return New(NULL); }

  InitializeConnectionRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const InitializeConnectionRequest& from);
  void MergeFrom(const InitializeConnectionRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InitializeConnectionRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef InitializeConnectionRequest_ProducerSMBScrapingMode ProducerSMBScrapingMode;
  static const ProducerSMBScrapingMode SMB_SCRAPING_UNSPECIFIED =
    InitializeConnectionRequest_ProducerSMBScrapingMode_SMB_SCRAPING_UNSPECIFIED;
  static const ProducerSMBScrapingMode SMB_SCRAPING_ENABLED =
    InitializeConnectionRequest_ProducerSMBScrapingMode_SMB_SCRAPING_ENABLED;
  static const ProducerSMBScrapingMode SMB_SCRAPING_DISABLED =
    InitializeConnectionRequest_ProducerSMBScrapingMode_SMB_SCRAPING_DISABLED;
  static inline bool ProducerSMBScrapingMode_IsValid(int value) {
    return InitializeConnectionRequest_ProducerSMBScrapingMode_IsValid(value);
  }
  static const ProducerSMBScrapingMode ProducerSMBScrapingMode_MIN =
    InitializeConnectionRequest_ProducerSMBScrapingMode_ProducerSMBScrapingMode_MIN;
  static const ProducerSMBScrapingMode ProducerSMBScrapingMode_MAX =
    InitializeConnectionRequest_ProducerSMBScrapingMode_ProducerSMBScrapingMode_MAX;
  static const int ProducerSMBScrapingMode_ARRAYSIZE =
    InitializeConnectionRequest_ProducerSMBScrapingMode_ProducerSMBScrapingMode_ARRAYSIZE;

  typedef InitializeConnectionRequest_ProducerBuildFlags ProducerBuildFlags;
  static const ProducerBuildFlags BUILD_FLAGS_UNSPECIFIED =
    InitializeConnectionRequest_ProducerBuildFlags_BUILD_FLAGS_UNSPECIFIED;
  static const ProducerBuildFlags BUILD_FLAGS_DCHECKS_ON =
    InitializeConnectionRequest_ProducerBuildFlags_BUILD_FLAGS_DCHECKS_ON;
  static const ProducerBuildFlags BUILD_FLAGS_DCHECKS_OFF =
    InitializeConnectionRequest_ProducerBuildFlags_BUILD_FLAGS_DCHECKS_OFF;
  static inline bool ProducerBuildFlags_IsValid(int value) {
    return InitializeConnectionRequest_ProducerBuildFlags_IsValid(value);
  }
  static const ProducerBuildFlags ProducerBuildFlags_MIN =
    InitializeConnectionRequest_ProducerBuildFlags_ProducerBuildFlags_MIN;
  static const ProducerBuildFlags ProducerBuildFlags_MAX =
    InitializeConnectionRequest_ProducerBuildFlags_ProducerBuildFlags_MAX;
  static const int ProducerBuildFlags_ARRAYSIZE =
    InitializeConnectionRequest_ProducerBuildFlags_ProducerBuildFlags_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional uint32 shared_memory_page_size_hint_bytes = 1;
  bool has_shared_memory_page_size_hint_bytes() const;
  void clear_shared_memory_page_size_hint_bytes();
  static const int kSharedMemoryPageSizeHintBytesFieldNumber = 1;
  ::google::protobuf::uint32 shared_memory_page_size_hint_bytes() const;
  void set_shared_memory_page_size_hint_bytes(::google::protobuf::uint32 value);

  // optional uint32 shared_memory_size_hint_bytes = 2;
  bool has_shared_memory_size_hint_bytes() const;
  void clear_shared_memory_size_hint_bytes();
  static const int kSharedMemorySizeHintBytesFieldNumber = 2;
  ::google::protobuf::uint32 shared_memory_size_hint_bytes() const;
  void set_shared_memory_size_hint_bytes(::google::protobuf::uint32 value);

  // optional string producer_name = 3;
  bool has_producer_name() const;
  void clear_producer_name();
  static const int kProducerNameFieldNumber = 3;
  const ::std::string& producer_name() const;
  void set_producer_name(const ::std::string& value);
  void set_producer_name(const char* value);
  void set_producer_name(const char* value, size_t size);
  ::std::string* mutable_producer_name();
  ::std::string* release_producer_name();
  void set_allocated_producer_name(::std::string* producer_name);

  // optional .perfetto.protos.InitializeConnectionRequest.ProducerSMBScrapingMode smb_scraping_mode = 4;
  bool has_smb_scraping_mode() const;
  void clear_smb_scraping_mode();
  static const int kSmbScrapingModeFieldNumber = 4;
  ::perfetto::protos::InitializeConnectionRequest_ProducerSMBScrapingMode smb_scraping_mode() const;
  void set_smb_scraping_mode(::perfetto::protos::InitializeConnectionRequest_ProducerSMBScrapingMode value);

  // optional .perfetto.protos.InitializeConnectionRequest.ProducerBuildFlags build_flags = 5;
  bool has_build_flags() const;
  void clear_build_flags();
  static const int kBuildFlagsFieldNumber = 5;
  ::perfetto::protos::InitializeConnectionRequest_ProducerBuildFlags build_flags() const;
  void set_build_flags(::perfetto::protos::InitializeConnectionRequest_ProducerBuildFlags value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.InitializeConnectionRequest)
 private:
  inline void set_has_shared_memory_page_size_hint_bytes();
  inline void clear_has_shared_memory_page_size_hint_bytes();
  inline void set_has_shared_memory_size_hint_bytes();
  inline void clear_has_shared_memory_size_hint_bytes();
  inline void set_has_producer_name();
  inline void clear_has_producer_name();
  inline void set_has_smb_scraping_mode();
  inline void clear_has_smb_scraping_mode();
  inline void set_has_build_flags();
  inline void clear_has_build_flags();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 shared_memory_page_size_hint_bytes_;
  ::google::protobuf::uint32 shared_memory_size_hint_bytes_;
  ::google::protobuf::internal::ArenaStringPtr producer_name_;
  int smb_scraping_mode_;
  int build_flags_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static InitializeConnectionRequest* default_instance_;
};
// -------------------------------------------------------------------

class InitializeConnectionResponse : public ::google::protobuf::MessageLite {
 public:
  InitializeConnectionResponse();
  virtual ~InitializeConnectionResponse();

  InitializeConnectionResponse(const InitializeConnectionResponse& from);

  inline InitializeConnectionResponse& operator=(const InitializeConnectionResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const InitializeConnectionResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const InitializeConnectionResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(InitializeConnectionResponse* other);

  // implements Message ----------------------------------------------

  inline InitializeConnectionResponse* New() const { return New(NULL); }

  InitializeConnectionResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const InitializeConnectionResponse& from);
  void MergeFrom(const InitializeConnectionResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InitializeConnectionResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.InitializeConnectionResponse)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static InitializeConnectionResponse* default_instance_;
};
// -------------------------------------------------------------------

class RegisterDataSourceRequest : public ::google::protobuf::MessageLite {
 public:
  RegisterDataSourceRequest();
  virtual ~RegisterDataSourceRequest();

  RegisterDataSourceRequest(const RegisterDataSourceRequest& from);

  inline RegisterDataSourceRequest& operator=(const RegisterDataSourceRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const RegisterDataSourceRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RegisterDataSourceRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RegisterDataSourceRequest* other);

  // implements Message ----------------------------------------------

  inline RegisterDataSourceRequest* New() const { return New(NULL); }

  RegisterDataSourceRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RegisterDataSourceRequest& from);
  void MergeFrom(const RegisterDataSourceRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RegisterDataSourceRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .perfetto.protos.DataSourceDescriptor data_source_descriptor = 1;
  bool has_data_source_descriptor() const;
  void clear_data_source_descriptor();
  static const int kDataSourceDescriptorFieldNumber = 1;
  const ::perfetto::protos::DataSourceDescriptor& data_source_descriptor() const;
  ::perfetto::protos::DataSourceDescriptor* mutable_data_source_descriptor();
  ::perfetto::protos::DataSourceDescriptor* release_data_source_descriptor();
  void set_allocated_data_source_descriptor(::perfetto::protos::DataSourceDescriptor* data_source_descriptor);

  // @@protoc_insertion_point(class_scope:perfetto.protos.RegisterDataSourceRequest)
 private:
  inline void set_has_data_source_descriptor();
  inline void clear_has_data_source_descriptor();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::perfetto::protos::DataSourceDescriptor* data_source_descriptor_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static RegisterDataSourceRequest* default_instance_;
};
// -------------------------------------------------------------------

class RegisterDataSourceResponse : public ::google::protobuf::MessageLite {
 public:
  RegisterDataSourceResponse();
  virtual ~RegisterDataSourceResponse();

  RegisterDataSourceResponse(const RegisterDataSourceResponse& from);

  inline RegisterDataSourceResponse& operator=(const RegisterDataSourceResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const RegisterDataSourceResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RegisterDataSourceResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RegisterDataSourceResponse* other);

  // implements Message ----------------------------------------------

  inline RegisterDataSourceResponse* New() const { return New(NULL); }

  RegisterDataSourceResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RegisterDataSourceResponse& from);
  void MergeFrom(const RegisterDataSourceResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RegisterDataSourceResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string error = 1;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // @@protoc_insertion_point(class_scope:perfetto.protos.RegisterDataSourceResponse)
 private:
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static RegisterDataSourceResponse* default_instance_;
};
// -------------------------------------------------------------------

class UnregisterDataSourceRequest : public ::google::protobuf::MessageLite {
 public:
  UnregisterDataSourceRequest();
  virtual ~UnregisterDataSourceRequest();

  UnregisterDataSourceRequest(const UnregisterDataSourceRequest& from);

  inline UnregisterDataSourceRequest& operator=(const UnregisterDataSourceRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const UnregisterDataSourceRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UnregisterDataSourceRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UnregisterDataSourceRequest* other);

  // implements Message ----------------------------------------------

  inline UnregisterDataSourceRequest* New() const { return New(NULL); }

  UnregisterDataSourceRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UnregisterDataSourceRequest& from);
  void MergeFrom(const UnregisterDataSourceRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UnregisterDataSourceRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string data_source_name = 1;
  bool has_data_source_name() const;
  void clear_data_source_name();
  static const int kDataSourceNameFieldNumber = 1;
  const ::std::string& data_source_name() const;
  void set_data_source_name(const ::std::string& value);
  void set_data_source_name(const char* value);
  void set_data_source_name(const char* value, size_t size);
  ::std::string* mutable_data_source_name();
  ::std::string* release_data_source_name();
  void set_allocated_data_source_name(::std::string* data_source_name);

  // @@protoc_insertion_point(class_scope:perfetto.protos.UnregisterDataSourceRequest)
 private:
  inline void set_has_data_source_name();
  inline void clear_has_data_source_name();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_source_name_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static UnregisterDataSourceRequest* default_instance_;
};
// -------------------------------------------------------------------

class UnregisterDataSourceResponse : public ::google::protobuf::MessageLite {
 public:
  UnregisterDataSourceResponse();
  virtual ~UnregisterDataSourceResponse();

  UnregisterDataSourceResponse(const UnregisterDataSourceResponse& from);

  inline UnregisterDataSourceResponse& operator=(const UnregisterDataSourceResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const UnregisterDataSourceResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UnregisterDataSourceResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UnregisterDataSourceResponse* other);

  // implements Message ----------------------------------------------

  inline UnregisterDataSourceResponse* New() const { return New(NULL); }

  UnregisterDataSourceResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UnregisterDataSourceResponse& from);
  void MergeFrom(const UnregisterDataSourceResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UnregisterDataSourceResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.UnregisterDataSourceResponse)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static UnregisterDataSourceResponse* default_instance_;
};
// -------------------------------------------------------------------

class RegisterTraceWriterRequest : public ::google::protobuf::MessageLite {
 public:
  RegisterTraceWriterRequest();
  virtual ~RegisterTraceWriterRequest();

  RegisterTraceWriterRequest(const RegisterTraceWriterRequest& from);

  inline RegisterTraceWriterRequest& operator=(const RegisterTraceWriterRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const RegisterTraceWriterRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RegisterTraceWriterRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RegisterTraceWriterRequest* other);

  // implements Message ----------------------------------------------

  inline RegisterTraceWriterRequest* New() const { return New(NULL); }

  RegisterTraceWriterRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RegisterTraceWriterRequest& from);
  void MergeFrom(const RegisterTraceWriterRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RegisterTraceWriterRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 trace_writer_id = 1;
  bool has_trace_writer_id() const;
  void clear_trace_writer_id();
  static const int kTraceWriterIdFieldNumber = 1;
  ::google::protobuf::uint32 trace_writer_id() const;
  void set_trace_writer_id(::google::protobuf::uint32 value);

  // optional uint32 target_buffer = 2;
  bool has_target_buffer() const;
  void clear_target_buffer();
  static const int kTargetBufferFieldNumber = 2;
  ::google::protobuf::uint32 target_buffer() const;
  void set_target_buffer(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.RegisterTraceWriterRequest)
 private:
  inline void set_has_trace_writer_id();
  inline void clear_has_trace_writer_id();
  inline void set_has_target_buffer();
  inline void clear_has_target_buffer();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 trace_writer_id_;
  ::google::protobuf::uint32 target_buffer_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static RegisterTraceWriterRequest* default_instance_;
};
// -------------------------------------------------------------------

class RegisterTraceWriterResponse : public ::google::protobuf::MessageLite {
 public:
  RegisterTraceWriterResponse();
  virtual ~RegisterTraceWriterResponse();

  RegisterTraceWriterResponse(const RegisterTraceWriterResponse& from);

  inline RegisterTraceWriterResponse& operator=(const RegisterTraceWriterResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const RegisterTraceWriterResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RegisterTraceWriterResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RegisterTraceWriterResponse* other);

  // implements Message ----------------------------------------------

  inline RegisterTraceWriterResponse* New() const { return New(NULL); }

  RegisterTraceWriterResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RegisterTraceWriterResponse& from);
  void MergeFrom(const RegisterTraceWriterResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RegisterTraceWriterResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.RegisterTraceWriterResponse)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static RegisterTraceWriterResponse* default_instance_;
};
// -------------------------------------------------------------------

class UnregisterTraceWriterRequest : public ::google::protobuf::MessageLite {
 public:
  UnregisterTraceWriterRequest();
  virtual ~UnregisterTraceWriterRequest();

  UnregisterTraceWriterRequest(const UnregisterTraceWriterRequest& from);

  inline UnregisterTraceWriterRequest& operator=(const UnregisterTraceWriterRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const UnregisterTraceWriterRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UnregisterTraceWriterRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UnregisterTraceWriterRequest* other);

  // implements Message ----------------------------------------------

  inline UnregisterTraceWriterRequest* New() const { return New(NULL); }

  UnregisterTraceWriterRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UnregisterTraceWriterRequest& from);
  void MergeFrom(const UnregisterTraceWriterRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UnregisterTraceWriterRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 trace_writer_id = 1;
  bool has_trace_writer_id() const;
  void clear_trace_writer_id();
  static const int kTraceWriterIdFieldNumber = 1;
  ::google::protobuf::uint32 trace_writer_id() const;
  void set_trace_writer_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.UnregisterTraceWriterRequest)
 private:
  inline void set_has_trace_writer_id();
  inline void clear_has_trace_writer_id();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 trace_writer_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static UnregisterTraceWriterRequest* default_instance_;
};
// -------------------------------------------------------------------

class UnregisterTraceWriterResponse : public ::google::protobuf::MessageLite {
 public:
  UnregisterTraceWriterResponse();
  virtual ~UnregisterTraceWriterResponse();

  UnregisterTraceWriterResponse(const UnregisterTraceWriterResponse& from);

  inline UnregisterTraceWriterResponse& operator=(const UnregisterTraceWriterResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const UnregisterTraceWriterResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UnregisterTraceWriterResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UnregisterTraceWriterResponse* other);

  // implements Message ----------------------------------------------

  inline UnregisterTraceWriterResponse* New() const { return New(NULL); }

  UnregisterTraceWriterResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UnregisterTraceWriterResponse& from);
  void MergeFrom(const UnregisterTraceWriterResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UnregisterTraceWriterResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.UnregisterTraceWriterResponse)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static UnregisterTraceWriterResponse* default_instance_;
};
// -------------------------------------------------------------------

class CommitDataResponse : public ::google::protobuf::MessageLite {
 public:
  CommitDataResponse();
  virtual ~CommitDataResponse();

  CommitDataResponse(const CommitDataResponse& from);

  inline CommitDataResponse& operator=(const CommitDataResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const CommitDataResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommitDataResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommitDataResponse* other);

  // implements Message ----------------------------------------------

  inline CommitDataResponse* New() const { return New(NULL); }

  CommitDataResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommitDataResponse& from);
  void MergeFrom(const CommitDataResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommitDataResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.CommitDataResponse)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static CommitDataResponse* default_instance_;
};
// -------------------------------------------------------------------

class NotifyDataSourceStartedRequest : public ::google::protobuf::MessageLite {
 public:
  NotifyDataSourceStartedRequest();
  virtual ~NotifyDataSourceStartedRequest();

  NotifyDataSourceStartedRequest(const NotifyDataSourceStartedRequest& from);

  inline NotifyDataSourceStartedRequest& operator=(const NotifyDataSourceStartedRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const NotifyDataSourceStartedRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotifyDataSourceStartedRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotifyDataSourceStartedRequest* other);

  // implements Message ----------------------------------------------

  inline NotifyDataSourceStartedRequest* New() const { return New(NULL); }

  NotifyDataSourceStartedRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotifyDataSourceStartedRequest& from);
  void MergeFrom(const NotifyDataSourceStartedRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NotifyDataSourceStartedRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 data_source_id = 1;
  bool has_data_source_id() const;
  void clear_data_source_id();
  static const int kDataSourceIdFieldNumber = 1;
  ::google::protobuf::uint64 data_source_id() const;
  void set_data_source_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.NotifyDataSourceStartedRequest)
 private:
  inline void set_has_data_source_id();
  inline void clear_has_data_source_id();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 data_source_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static NotifyDataSourceStartedRequest* default_instance_;
};
// -------------------------------------------------------------------

class NotifyDataSourceStartedResponse : public ::google::protobuf::MessageLite {
 public:
  NotifyDataSourceStartedResponse();
  virtual ~NotifyDataSourceStartedResponse();

  NotifyDataSourceStartedResponse(const NotifyDataSourceStartedResponse& from);

  inline NotifyDataSourceStartedResponse& operator=(const NotifyDataSourceStartedResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const NotifyDataSourceStartedResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotifyDataSourceStartedResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotifyDataSourceStartedResponse* other);

  // implements Message ----------------------------------------------

  inline NotifyDataSourceStartedResponse* New() const { return New(NULL); }

  NotifyDataSourceStartedResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotifyDataSourceStartedResponse& from);
  void MergeFrom(const NotifyDataSourceStartedResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NotifyDataSourceStartedResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.NotifyDataSourceStartedResponse)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static NotifyDataSourceStartedResponse* default_instance_;
};
// -------------------------------------------------------------------

class NotifyDataSourceStoppedRequest : public ::google::protobuf::MessageLite {
 public:
  NotifyDataSourceStoppedRequest();
  virtual ~NotifyDataSourceStoppedRequest();

  NotifyDataSourceStoppedRequest(const NotifyDataSourceStoppedRequest& from);

  inline NotifyDataSourceStoppedRequest& operator=(const NotifyDataSourceStoppedRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const NotifyDataSourceStoppedRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotifyDataSourceStoppedRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotifyDataSourceStoppedRequest* other);

  // implements Message ----------------------------------------------

  inline NotifyDataSourceStoppedRequest* New() const { return New(NULL); }

  NotifyDataSourceStoppedRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotifyDataSourceStoppedRequest& from);
  void MergeFrom(const NotifyDataSourceStoppedRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NotifyDataSourceStoppedRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 data_source_id = 1;
  bool has_data_source_id() const;
  void clear_data_source_id();
  static const int kDataSourceIdFieldNumber = 1;
  ::google::protobuf::uint64 data_source_id() const;
  void set_data_source_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.NotifyDataSourceStoppedRequest)
 private:
  inline void set_has_data_source_id();
  inline void clear_has_data_source_id();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 data_source_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static NotifyDataSourceStoppedRequest* default_instance_;
};
// -------------------------------------------------------------------

class NotifyDataSourceStoppedResponse : public ::google::protobuf::MessageLite {
 public:
  NotifyDataSourceStoppedResponse();
  virtual ~NotifyDataSourceStoppedResponse();

  NotifyDataSourceStoppedResponse(const NotifyDataSourceStoppedResponse& from);

  inline NotifyDataSourceStoppedResponse& operator=(const NotifyDataSourceStoppedResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const NotifyDataSourceStoppedResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotifyDataSourceStoppedResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotifyDataSourceStoppedResponse* other);

  // implements Message ----------------------------------------------

  inline NotifyDataSourceStoppedResponse* New() const { return New(NULL); }

  NotifyDataSourceStoppedResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotifyDataSourceStoppedResponse& from);
  void MergeFrom(const NotifyDataSourceStoppedResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NotifyDataSourceStoppedResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.NotifyDataSourceStoppedResponse)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static NotifyDataSourceStoppedResponse* default_instance_;
};
// -------------------------------------------------------------------

class ActivateTriggersRequest : public ::google::protobuf::MessageLite {
 public:
  ActivateTriggersRequest();
  virtual ~ActivateTriggersRequest();

  ActivateTriggersRequest(const ActivateTriggersRequest& from);

  inline ActivateTriggersRequest& operator=(const ActivateTriggersRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ActivateTriggersRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ActivateTriggersRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ActivateTriggersRequest* other);

  // implements Message ----------------------------------------------

  inline ActivateTriggersRequest* New() const { return New(NULL); }

  ActivateTriggersRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ActivateTriggersRequest& from);
  void MergeFrom(const ActivateTriggersRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActivateTriggersRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string trigger_names = 1;
  int trigger_names_size() const;
  void clear_trigger_names();
  static const int kTriggerNamesFieldNumber = 1;
  const ::std::string& trigger_names(int index) const;
  ::std::string* mutable_trigger_names(int index);
  void set_trigger_names(int index, const ::std::string& value);
  void set_trigger_names(int index, const char* value);
  void set_trigger_names(int index, const char* value, size_t size);
  ::std::string* add_trigger_names();
  void add_trigger_names(const ::std::string& value);
  void add_trigger_names(const char* value);
  void add_trigger_names(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& trigger_names() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_trigger_names();

  // @@protoc_insertion_point(class_scope:perfetto.protos.ActivateTriggersRequest)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> trigger_names_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static ActivateTriggersRequest* default_instance_;
};
// -------------------------------------------------------------------

class ActivateTriggersResponse : public ::google::protobuf::MessageLite {
 public:
  ActivateTriggersResponse();
  virtual ~ActivateTriggersResponse();

  ActivateTriggersResponse(const ActivateTriggersResponse& from);

  inline ActivateTriggersResponse& operator=(const ActivateTriggersResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ActivateTriggersResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ActivateTriggersResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ActivateTriggersResponse* other);

  // implements Message ----------------------------------------------

  inline ActivateTriggersResponse* New() const { return New(NULL); }

  ActivateTriggersResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ActivateTriggersResponse& from);
  void MergeFrom(const ActivateTriggersResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActivateTriggersResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.ActivateTriggersResponse)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static ActivateTriggersResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetAsyncCommandRequest : public ::google::protobuf::MessageLite {
 public:
  GetAsyncCommandRequest();
  virtual ~GetAsyncCommandRequest();

  GetAsyncCommandRequest(const GetAsyncCommandRequest& from);

  inline GetAsyncCommandRequest& operator=(const GetAsyncCommandRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const GetAsyncCommandRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetAsyncCommandRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetAsyncCommandRequest* other);

  // implements Message ----------------------------------------------

  inline GetAsyncCommandRequest* New() const { return New(NULL); }

  GetAsyncCommandRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetAsyncCommandRequest& from);
  void MergeFrom(const GetAsyncCommandRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetAsyncCommandRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.GetAsyncCommandRequest)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static GetAsyncCommandRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetAsyncCommandResponse_SetupDataSource : public ::google::protobuf::MessageLite {
 public:
  GetAsyncCommandResponse_SetupDataSource();
  virtual ~GetAsyncCommandResponse_SetupDataSource();

  GetAsyncCommandResponse_SetupDataSource(const GetAsyncCommandResponse_SetupDataSource& from);

  inline GetAsyncCommandResponse_SetupDataSource& operator=(const GetAsyncCommandResponse_SetupDataSource& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const GetAsyncCommandResponse_SetupDataSource& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetAsyncCommandResponse_SetupDataSource* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetAsyncCommandResponse_SetupDataSource* other);

  // implements Message ----------------------------------------------

  inline GetAsyncCommandResponse_SetupDataSource* New() const { return New(NULL); }

  GetAsyncCommandResponse_SetupDataSource* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetAsyncCommandResponse_SetupDataSource& from);
  void MergeFrom(const GetAsyncCommandResponse_SetupDataSource& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetAsyncCommandResponse_SetupDataSource* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 new_instance_id = 1;
  bool has_new_instance_id() const;
  void clear_new_instance_id();
  static const int kNewInstanceIdFieldNumber = 1;
  ::google::protobuf::uint64 new_instance_id() const;
  void set_new_instance_id(::google::protobuf::uint64 value);

  // optional .perfetto.protos.DataSourceConfig config = 2;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 2;
  const ::perfetto::protos::DataSourceConfig& config() const;
  ::perfetto::protos::DataSourceConfig* mutable_config();
  ::perfetto::protos::DataSourceConfig* release_config();
  void set_allocated_config(::perfetto::protos::DataSourceConfig* config);

  // @@protoc_insertion_point(class_scope:perfetto.protos.GetAsyncCommandResponse.SetupDataSource)
 private:
  inline void set_has_new_instance_id();
  inline void clear_has_new_instance_id();
  inline void set_has_config();
  inline void clear_has_config();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 new_instance_id_;
  ::perfetto::protos::DataSourceConfig* config_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static GetAsyncCommandResponse_SetupDataSource* default_instance_;
};
// -------------------------------------------------------------------

class GetAsyncCommandResponse_StartDataSource : public ::google::protobuf::MessageLite {
 public:
  GetAsyncCommandResponse_StartDataSource();
  virtual ~GetAsyncCommandResponse_StartDataSource();

  GetAsyncCommandResponse_StartDataSource(const GetAsyncCommandResponse_StartDataSource& from);

  inline GetAsyncCommandResponse_StartDataSource& operator=(const GetAsyncCommandResponse_StartDataSource& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const GetAsyncCommandResponse_StartDataSource& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetAsyncCommandResponse_StartDataSource* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetAsyncCommandResponse_StartDataSource* other);

  // implements Message ----------------------------------------------

  inline GetAsyncCommandResponse_StartDataSource* New() const { return New(NULL); }

  GetAsyncCommandResponse_StartDataSource* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetAsyncCommandResponse_StartDataSource& from);
  void MergeFrom(const GetAsyncCommandResponse_StartDataSource& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetAsyncCommandResponse_StartDataSource* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 new_instance_id = 1;
  bool has_new_instance_id() const;
  void clear_new_instance_id();
  static const int kNewInstanceIdFieldNumber = 1;
  ::google::protobuf::uint64 new_instance_id() const;
  void set_new_instance_id(::google::protobuf::uint64 value);

  // optional .perfetto.protos.DataSourceConfig config = 2;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 2;
  const ::perfetto::protos::DataSourceConfig& config() const;
  ::perfetto::protos::DataSourceConfig* mutable_config();
  ::perfetto::protos::DataSourceConfig* release_config();
  void set_allocated_config(::perfetto::protos::DataSourceConfig* config);

  // @@protoc_insertion_point(class_scope:perfetto.protos.GetAsyncCommandResponse.StartDataSource)
 private:
  inline void set_has_new_instance_id();
  inline void clear_has_new_instance_id();
  inline void set_has_config();
  inline void clear_has_config();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 new_instance_id_;
  ::perfetto::protos::DataSourceConfig* config_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static GetAsyncCommandResponse_StartDataSource* default_instance_;
};
// -------------------------------------------------------------------

class GetAsyncCommandResponse_StopDataSource : public ::google::protobuf::MessageLite {
 public:
  GetAsyncCommandResponse_StopDataSource();
  virtual ~GetAsyncCommandResponse_StopDataSource();

  GetAsyncCommandResponse_StopDataSource(const GetAsyncCommandResponse_StopDataSource& from);

  inline GetAsyncCommandResponse_StopDataSource& operator=(const GetAsyncCommandResponse_StopDataSource& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const GetAsyncCommandResponse_StopDataSource& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetAsyncCommandResponse_StopDataSource* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetAsyncCommandResponse_StopDataSource* other);

  // implements Message ----------------------------------------------

  inline GetAsyncCommandResponse_StopDataSource* New() const { return New(NULL); }

  GetAsyncCommandResponse_StopDataSource* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetAsyncCommandResponse_StopDataSource& from);
  void MergeFrom(const GetAsyncCommandResponse_StopDataSource& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetAsyncCommandResponse_StopDataSource* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 instance_id = 1;
  bool has_instance_id() const;
  void clear_instance_id();
  static const int kInstanceIdFieldNumber = 1;
  ::google::protobuf::uint64 instance_id() const;
  void set_instance_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.GetAsyncCommandResponse.StopDataSource)
 private:
  inline void set_has_instance_id();
  inline void clear_has_instance_id();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 instance_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static GetAsyncCommandResponse_StopDataSource* default_instance_;
};
// -------------------------------------------------------------------

class GetAsyncCommandResponse_SetupTracing : public ::google::protobuf::MessageLite {
 public:
  GetAsyncCommandResponse_SetupTracing();
  virtual ~GetAsyncCommandResponse_SetupTracing();

  GetAsyncCommandResponse_SetupTracing(const GetAsyncCommandResponse_SetupTracing& from);

  inline GetAsyncCommandResponse_SetupTracing& operator=(const GetAsyncCommandResponse_SetupTracing& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const GetAsyncCommandResponse_SetupTracing& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetAsyncCommandResponse_SetupTracing* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetAsyncCommandResponse_SetupTracing* other);

  // implements Message ----------------------------------------------

  inline GetAsyncCommandResponse_SetupTracing* New() const { return New(NULL); }

  GetAsyncCommandResponse_SetupTracing* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetAsyncCommandResponse_SetupTracing& from);
  void MergeFrom(const GetAsyncCommandResponse_SetupTracing& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetAsyncCommandResponse_SetupTracing* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 shared_buffer_page_size_kb = 1;
  bool has_shared_buffer_page_size_kb() const;
  void clear_shared_buffer_page_size_kb();
  static const int kSharedBufferPageSizeKbFieldNumber = 1;
  ::google::protobuf::uint32 shared_buffer_page_size_kb() const;
  void set_shared_buffer_page_size_kb(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.GetAsyncCommandResponse.SetupTracing)
 private:
  inline void set_has_shared_buffer_page_size_kb();
  inline void clear_has_shared_buffer_page_size_kb();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 shared_buffer_page_size_kb_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static GetAsyncCommandResponse_SetupTracing* default_instance_;
};
// -------------------------------------------------------------------

class GetAsyncCommandResponse_Flush : public ::google::protobuf::MessageLite {
 public:
  GetAsyncCommandResponse_Flush();
  virtual ~GetAsyncCommandResponse_Flush();

  GetAsyncCommandResponse_Flush(const GetAsyncCommandResponse_Flush& from);

  inline GetAsyncCommandResponse_Flush& operator=(const GetAsyncCommandResponse_Flush& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const GetAsyncCommandResponse_Flush& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetAsyncCommandResponse_Flush* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetAsyncCommandResponse_Flush* other);

  // implements Message ----------------------------------------------

  inline GetAsyncCommandResponse_Flush* New() const { return New(NULL); }

  GetAsyncCommandResponse_Flush* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetAsyncCommandResponse_Flush& from);
  void MergeFrom(const GetAsyncCommandResponse_Flush& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetAsyncCommandResponse_Flush* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 data_source_ids = 1;
  int data_source_ids_size() const;
  void clear_data_source_ids();
  static const int kDataSourceIdsFieldNumber = 1;
  ::google::protobuf::uint64 data_source_ids(int index) const;
  void set_data_source_ids(int index, ::google::protobuf::uint64 value);
  void add_data_source_ids(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      data_source_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_data_source_ids();

  // optional uint64 request_id = 2;
  bool has_request_id() const;
  void clear_request_id();
  static const int kRequestIdFieldNumber = 2;
  ::google::protobuf::uint64 request_id() const;
  void set_request_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.GetAsyncCommandResponse.Flush)
 private:
  inline void set_has_request_id();
  inline void clear_has_request_id();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > data_source_ids_;
  ::google::protobuf::uint64 request_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static GetAsyncCommandResponse_Flush* default_instance_;
};
// -------------------------------------------------------------------

class GetAsyncCommandResponse_ClearIncrementalState : public ::google::protobuf::MessageLite {
 public:
  GetAsyncCommandResponse_ClearIncrementalState();
  virtual ~GetAsyncCommandResponse_ClearIncrementalState();

  GetAsyncCommandResponse_ClearIncrementalState(const GetAsyncCommandResponse_ClearIncrementalState& from);

  inline GetAsyncCommandResponse_ClearIncrementalState& operator=(const GetAsyncCommandResponse_ClearIncrementalState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const GetAsyncCommandResponse_ClearIncrementalState& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetAsyncCommandResponse_ClearIncrementalState* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetAsyncCommandResponse_ClearIncrementalState* other);

  // implements Message ----------------------------------------------

  inline GetAsyncCommandResponse_ClearIncrementalState* New() const { return New(NULL); }

  GetAsyncCommandResponse_ClearIncrementalState* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetAsyncCommandResponse_ClearIncrementalState& from);
  void MergeFrom(const GetAsyncCommandResponse_ClearIncrementalState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetAsyncCommandResponse_ClearIncrementalState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 data_source_ids = 1;
  int data_source_ids_size() const;
  void clear_data_source_ids();
  static const int kDataSourceIdsFieldNumber = 1;
  ::google::protobuf::uint64 data_source_ids(int index) const;
  void set_data_source_ids(int index, ::google::protobuf::uint64 value);
  void add_data_source_ids(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      data_source_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_data_source_ids();

  // @@protoc_insertion_point(class_scope:perfetto.protos.GetAsyncCommandResponse.ClearIncrementalState)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > data_source_ids_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static GetAsyncCommandResponse_ClearIncrementalState* default_instance_;
};
// -------------------------------------------------------------------

class GetAsyncCommandResponse : public ::google::protobuf::MessageLite {
 public:
  GetAsyncCommandResponse();
  virtual ~GetAsyncCommandResponse();

  GetAsyncCommandResponse(const GetAsyncCommandResponse& from);

  inline GetAsyncCommandResponse& operator=(const GetAsyncCommandResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const GetAsyncCommandResponse& default_instance();

  enum CmdCase {
    kSetupTracing = 3,
    kSetupDataSource = 6,
    kStartDataSource = 1,
    kStopDataSource = 2,
    kFlush = 5,
    kClearIncrementalState = 7,
    CMD_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetAsyncCommandResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetAsyncCommandResponse* other);

  // implements Message ----------------------------------------------

  inline GetAsyncCommandResponse* New() const { return New(NULL); }

  GetAsyncCommandResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetAsyncCommandResponse& from);
  void MergeFrom(const GetAsyncCommandResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetAsyncCommandResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef GetAsyncCommandResponse_SetupDataSource SetupDataSource;
  typedef GetAsyncCommandResponse_StartDataSource StartDataSource;
  typedef GetAsyncCommandResponse_StopDataSource StopDataSource;
  typedef GetAsyncCommandResponse_SetupTracing SetupTracing;
  typedef GetAsyncCommandResponse_Flush Flush;
  typedef GetAsyncCommandResponse_ClearIncrementalState ClearIncrementalState;

  // accessors -------------------------------------------------------

  // optional .perfetto.protos.GetAsyncCommandResponse.SetupTracing setup_tracing = 3;
  bool has_setup_tracing() const;
  void clear_setup_tracing();
  static const int kSetupTracingFieldNumber = 3;
  const ::perfetto::protos::GetAsyncCommandResponse_SetupTracing& setup_tracing() const;
  ::perfetto::protos::GetAsyncCommandResponse_SetupTracing* mutable_setup_tracing();
  ::perfetto::protos::GetAsyncCommandResponse_SetupTracing* release_setup_tracing();
  void set_allocated_setup_tracing(::perfetto::protos::GetAsyncCommandResponse_SetupTracing* setup_tracing);

  // optional .perfetto.protos.GetAsyncCommandResponse.SetupDataSource setup_data_source = 6;
  bool has_setup_data_source() const;
  void clear_setup_data_source();
  static const int kSetupDataSourceFieldNumber = 6;
  const ::perfetto::protos::GetAsyncCommandResponse_SetupDataSource& setup_data_source() const;
  ::perfetto::protos::GetAsyncCommandResponse_SetupDataSource* mutable_setup_data_source();
  ::perfetto::protos::GetAsyncCommandResponse_SetupDataSource* release_setup_data_source();
  void set_allocated_setup_data_source(::perfetto::protos::GetAsyncCommandResponse_SetupDataSource* setup_data_source);

  // optional .perfetto.protos.GetAsyncCommandResponse.StartDataSource start_data_source = 1;
  bool has_start_data_source() const;
  void clear_start_data_source();
  static const int kStartDataSourceFieldNumber = 1;
  const ::perfetto::protos::GetAsyncCommandResponse_StartDataSource& start_data_source() const;
  ::perfetto::protos::GetAsyncCommandResponse_StartDataSource* mutable_start_data_source();
  ::perfetto::protos::GetAsyncCommandResponse_StartDataSource* release_start_data_source();
  void set_allocated_start_data_source(::perfetto::protos::GetAsyncCommandResponse_StartDataSource* start_data_source);

  // optional .perfetto.protos.GetAsyncCommandResponse.StopDataSource stop_data_source = 2;
  bool has_stop_data_source() const;
  void clear_stop_data_source();
  static const int kStopDataSourceFieldNumber = 2;
  const ::perfetto::protos::GetAsyncCommandResponse_StopDataSource& stop_data_source() const;
  ::perfetto::protos::GetAsyncCommandResponse_StopDataSource* mutable_stop_data_source();
  ::perfetto::protos::GetAsyncCommandResponse_StopDataSource* release_stop_data_source();
  void set_allocated_stop_data_source(::perfetto::protos::GetAsyncCommandResponse_StopDataSource* stop_data_source);

  // optional .perfetto.protos.GetAsyncCommandResponse.Flush flush = 5;
  bool has_flush() const;
  void clear_flush();
  static const int kFlushFieldNumber = 5;
  const ::perfetto::protos::GetAsyncCommandResponse_Flush& flush() const;
  ::perfetto::protos::GetAsyncCommandResponse_Flush* mutable_flush();
  ::perfetto::protos::GetAsyncCommandResponse_Flush* release_flush();
  void set_allocated_flush(::perfetto::protos::GetAsyncCommandResponse_Flush* flush);

  // optional .perfetto.protos.GetAsyncCommandResponse.ClearIncrementalState clear_incremental_state = 7;
  bool has_clear_incremental_state() const;
  void clear_clear_incremental_state();
  static const int kClearIncrementalStateFieldNumber = 7;
  const ::perfetto::protos::GetAsyncCommandResponse_ClearIncrementalState& clear_incremental_state() const;
  ::perfetto::protos::GetAsyncCommandResponse_ClearIncrementalState* mutable_clear_incremental_state();
  ::perfetto::protos::GetAsyncCommandResponse_ClearIncrementalState* release_clear_incremental_state();
  void set_allocated_clear_incremental_state(::perfetto::protos::GetAsyncCommandResponse_ClearIncrementalState* clear_incremental_state);

  CmdCase cmd_case() const;
  // @@protoc_insertion_point(class_scope:perfetto.protos.GetAsyncCommandResponse)
 private:
  inline void set_has_setup_tracing();
  inline void set_has_setup_data_source();
  inline void set_has_start_data_source();
  inline void set_has_stop_data_source();
  inline void set_has_flush();
  inline void set_has_clear_incremental_state();

  inline bool has_cmd() const;
  void clear_cmd();
  inline void clear_has_cmd();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union CmdUnion {
    CmdUnion() {}
    ::perfetto::protos::GetAsyncCommandResponse_SetupTracing* setup_tracing_;
    ::perfetto::protos::GetAsyncCommandResponse_SetupDataSource* setup_data_source_;
    ::perfetto::protos::GetAsyncCommandResponse_StartDataSource* start_data_source_;
    ::perfetto::protos::GetAsyncCommandResponse_StopDataSource* stop_data_source_;
    ::perfetto::protos::GetAsyncCommandResponse_Flush* flush_;
    ::perfetto::protos::GetAsyncCommandResponse_ClearIncrementalState* clear_incremental_state_;
  } cmd_;
  ::google::protobuf::uint32 _oneof_case_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static GetAsyncCommandResponse* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// InitializeConnectionRequest

// optional uint32 shared_memory_page_size_hint_bytes = 1;
inline bool InitializeConnectionRequest::has_shared_memory_page_size_hint_bytes() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InitializeConnectionRequest::set_has_shared_memory_page_size_hint_bytes() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InitializeConnectionRequest::clear_has_shared_memory_page_size_hint_bytes() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InitializeConnectionRequest::clear_shared_memory_page_size_hint_bytes() {
  shared_memory_page_size_hint_bytes_ = 0u;
  clear_has_shared_memory_page_size_hint_bytes();
}
inline ::google::protobuf::uint32 InitializeConnectionRequest::shared_memory_page_size_hint_bytes() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InitializeConnectionRequest.shared_memory_page_size_hint_bytes)
  return shared_memory_page_size_hint_bytes_;
}
inline void InitializeConnectionRequest::set_shared_memory_page_size_hint_bytes(::google::protobuf::uint32 value) {
  set_has_shared_memory_page_size_hint_bytes();
  shared_memory_page_size_hint_bytes_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.InitializeConnectionRequest.shared_memory_page_size_hint_bytes)
}

// optional uint32 shared_memory_size_hint_bytes = 2;
inline bool InitializeConnectionRequest::has_shared_memory_size_hint_bytes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InitializeConnectionRequest::set_has_shared_memory_size_hint_bytes() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InitializeConnectionRequest::clear_has_shared_memory_size_hint_bytes() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InitializeConnectionRequest::clear_shared_memory_size_hint_bytes() {
  shared_memory_size_hint_bytes_ = 0u;
  clear_has_shared_memory_size_hint_bytes();
}
inline ::google::protobuf::uint32 InitializeConnectionRequest::shared_memory_size_hint_bytes() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InitializeConnectionRequest.shared_memory_size_hint_bytes)
  return shared_memory_size_hint_bytes_;
}
inline void InitializeConnectionRequest::set_shared_memory_size_hint_bytes(::google::protobuf::uint32 value) {
  set_has_shared_memory_size_hint_bytes();
  shared_memory_size_hint_bytes_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.InitializeConnectionRequest.shared_memory_size_hint_bytes)
}

// optional string producer_name = 3;
inline bool InitializeConnectionRequest::has_producer_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InitializeConnectionRequest::set_has_producer_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InitializeConnectionRequest::clear_has_producer_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InitializeConnectionRequest::clear_producer_name() {
  producer_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_producer_name();
}
inline const ::std::string& InitializeConnectionRequest::producer_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InitializeConnectionRequest.producer_name)
  return producer_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InitializeConnectionRequest::set_producer_name(const ::std::string& value) {
  set_has_producer_name();
  producer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.InitializeConnectionRequest.producer_name)
}
inline void InitializeConnectionRequest::set_producer_name(const char* value) {
  set_has_producer_name();
  producer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.InitializeConnectionRequest.producer_name)
}
inline void InitializeConnectionRequest::set_producer_name(const char* value, size_t size) {
  set_has_producer_name();
  producer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.InitializeConnectionRequest.producer_name)
}
inline ::std::string* InitializeConnectionRequest::mutable_producer_name() {
  set_has_producer_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.InitializeConnectionRequest.producer_name)
  return producer_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InitializeConnectionRequest::release_producer_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.InitializeConnectionRequest.producer_name)
  clear_has_producer_name();
  return producer_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InitializeConnectionRequest::set_allocated_producer_name(::std::string* producer_name) {
  if (producer_name != NULL) {
    set_has_producer_name();
  } else {
    clear_has_producer_name();
  }
  producer_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), producer_name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.InitializeConnectionRequest.producer_name)
}

// optional .perfetto.protos.InitializeConnectionRequest.ProducerSMBScrapingMode smb_scraping_mode = 4;
inline bool InitializeConnectionRequest::has_smb_scraping_mode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InitializeConnectionRequest::set_has_smb_scraping_mode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InitializeConnectionRequest::clear_has_smb_scraping_mode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InitializeConnectionRequest::clear_smb_scraping_mode() {
  smb_scraping_mode_ = 0;
  clear_has_smb_scraping_mode();
}
inline ::perfetto::protos::InitializeConnectionRequest_ProducerSMBScrapingMode InitializeConnectionRequest::smb_scraping_mode() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InitializeConnectionRequest.smb_scraping_mode)
  return static_cast< ::perfetto::protos::InitializeConnectionRequest_ProducerSMBScrapingMode >(smb_scraping_mode_);
}
inline void InitializeConnectionRequest::set_smb_scraping_mode(::perfetto::protos::InitializeConnectionRequest_ProducerSMBScrapingMode value) {
  assert(::perfetto::protos::InitializeConnectionRequest_ProducerSMBScrapingMode_IsValid(value));
  set_has_smb_scraping_mode();
  smb_scraping_mode_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.InitializeConnectionRequest.smb_scraping_mode)
}

// optional .perfetto.protos.InitializeConnectionRequest.ProducerBuildFlags build_flags = 5;
inline bool InitializeConnectionRequest::has_build_flags() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InitializeConnectionRequest::set_has_build_flags() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InitializeConnectionRequest::clear_has_build_flags() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InitializeConnectionRequest::clear_build_flags() {
  build_flags_ = 0;
  clear_has_build_flags();
}
inline ::perfetto::protos::InitializeConnectionRequest_ProducerBuildFlags InitializeConnectionRequest::build_flags() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InitializeConnectionRequest.build_flags)
  return static_cast< ::perfetto::protos::InitializeConnectionRequest_ProducerBuildFlags >(build_flags_);
}
inline void InitializeConnectionRequest::set_build_flags(::perfetto::protos::InitializeConnectionRequest_ProducerBuildFlags value) {
  assert(::perfetto::protos::InitializeConnectionRequest_ProducerBuildFlags_IsValid(value));
  set_has_build_flags();
  build_flags_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.InitializeConnectionRequest.build_flags)
}

// -------------------------------------------------------------------

// InitializeConnectionResponse

// -------------------------------------------------------------------

// RegisterDataSourceRequest

// optional .perfetto.protos.DataSourceDescriptor data_source_descriptor = 1;
inline bool RegisterDataSourceRequest::has_data_source_descriptor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterDataSourceRequest::set_has_data_source_descriptor() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterDataSourceRequest::clear_has_data_source_descriptor() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterDataSourceRequest::clear_data_source_descriptor() {
  if (data_source_descriptor_ != NULL) data_source_descriptor_->::perfetto::protos::DataSourceDescriptor::Clear();
  clear_has_data_source_descriptor();
}
inline const ::perfetto::protos::DataSourceDescriptor& RegisterDataSourceRequest::data_source_descriptor() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.RegisterDataSourceRequest.data_source_descriptor)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return data_source_descriptor_ != NULL ? *data_source_descriptor_ : *default_instance().data_source_descriptor_;
#else
  return data_source_descriptor_ != NULL ? *data_source_descriptor_ : *default_instance_->data_source_descriptor_;
#endif
}
inline ::perfetto::protos::DataSourceDescriptor* RegisterDataSourceRequest::mutable_data_source_descriptor() {
  set_has_data_source_descriptor();
  if (data_source_descriptor_ == NULL) {
    data_source_descriptor_ = new ::perfetto::protos::DataSourceDescriptor;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.RegisterDataSourceRequest.data_source_descriptor)
  return data_source_descriptor_;
}
inline ::perfetto::protos::DataSourceDescriptor* RegisterDataSourceRequest::release_data_source_descriptor() {
  // @@protoc_insertion_point(field_release:perfetto.protos.RegisterDataSourceRequest.data_source_descriptor)
  clear_has_data_source_descriptor();
  ::perfetto::protos::DataSourceDescriptor* temp = data_source_descriptor_;
  data_source_descriptor_ = NULL;
  return temp;
}
inline void RegisterDataSourceRequest::set_allocated_data_source_descriptor(::perfetto::protos::DataSourceDescriptor* data_source_descriptor) {
  delete data_source_descriptor_;
  data_source_descriptor_ = data_source_descriptor;
  if (data_source_descriptor) {
    set_has_data_source_descriptor();
  } else {
    clear_has_data_source_descriptor();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.RegisterDataSourceRequest.data_source_descriptor)
}

// -------------------------------------------------------------------

// RegisterDataSourceResponse

// optional string error = 1;
inline bool RegisterDataSourceResponse::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterDataSourceResponse::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterDataSourceResponse::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterDataSourceResponse::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error();
}
inline const ::std::string& RegisterDataSourceResponse::error() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.RegisterDataSourceResponse.error)
  return error_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterDataSourceResponse::set_error(const ::std::string& value) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.RegisterDataSourceResponse.error)
}
inline void RegisterDataSourceResponse::set_error(const char* value) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.RegisterDataSourceResponse.error)
}
inline void RegisterDataSourceResponse::set_error(const char* value, size_t size) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.RegisterDataSourceResponse.error)
}
inline ::std::string* RegisterDataSourceResponse::mutable_error() {
  set_has_error();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.RegisterDataSourceResponse.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegisterDataSourceResponse::release_error() {
  // @@protoc_insertion_point(field_release:perfetto.protos.RegisterDataSourceResponse.error)
  clear_has_error();
  return error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterDataSourceResponse::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    set_has_error();
  } else {
    clear_has_error();
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.RegisterDataSourceResponse.error)
}

// -------------------------------------------------------------------

// UnregisterDataSourceRequest

// optional string data_source_name = 1;
inline bool UnregisterDataSourceRequest::has_data_source_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnregisterDataSourceRequest::set_has_data_source_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnregisterDataSourceRequest::clear_has_data_source_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnregisterDataSourceRequest::clear_data_source_name() {
  data_source_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data_source_name();
}
inline const ::std::string& UnregisterDataSourceRequest::data_source_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.UnregisterDataSourceRequest.data_source_name)
  return data_source_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UnregisterDataSourceRequest::set_data_source_name(const ::std::string& value) {
  set_has_data_source_name();
  data_source_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.UnregisterDataSourceRequest.data_source_name)
}
inline void UnregisterDataSourceRequest::set_data_source_name(const char* value) {
  set_has_data_source_name();
  data_source_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.UnregisterDataSourceRequest.data_source_name)
}
inline void UnregisterDataSourceRequest::set_data_source_name(const char* value, size_t size) {
  set_has_data_source_name();
  data_source_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.UnregisterDataSourceRequest.data_source_name)
}
inline ::std::string* UnregisterDataSourceRequest::mutable_data_source_name() {
  set_has_data_source_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.UnregisterDataSourceRequest.data_source_name)
  return data_source_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UnregisterDataSourceRequest::release_data_source_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.UnregisterDataSourceRequest.data_source_name)
  clear_has_data_source_name();
  return data_source_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UnregisterDataSourceRequest::set_allocated_data_source_name(::std::string* data_source_name) {
  if (data_source_name != NULL) {
    set_has_data_source_name();
  } else {
    clear_has_data_source_name();
  }
  data_source_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data_source_name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.UnregisterDataSourceRequest.data_source_name)
}

// -------------------------------------------------------------------

// UnregisterDataSourceResponse

// -------------------------------------------------------------------

// RegisterTraceWriterRequest

// optional uint32 trace_writer_id = 1;
inline bool RegisterTraceWriterRequest::has_trace_writer_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterTraceWriterRequest::set_has_trace_writer_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterTraceWriterRequest::clear_has_trace_writer_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterTraceWriterRequest::clear_trace_writer_id() {
  trace_writer_id_ = 0u;
  clear_has_trace_writer_id();
}
inline ::google::protobuf::uint32 RegisterTraceWriterRequest::trace_writer_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.RegisterTraceWriterRequest.trace_writer_id)
  return trace_writer_id_;
}
inline void RegisterTraceWriterRequest::set_trace_writer_id(::google::protobuf::uint32 value) {
  set_has_trace_writer_id();
  trace_writer_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.RegisterTraceWriterRequest.trace_writer_id)
}

// optional uint32 target_buffer = 2;
inline bool RegisterTraceWriterRequest::has_target_buffer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegisterTraceWriterRequest::set_has_target_buffer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegisterTraceWriterRequest::clear_has_target_buffer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegisterTraceWriterRequest::clear_target_buffer() {
  target_buffer_ = 0u;
  clear_has_target_buffer();
}
inline ::google::protobuf::uint32 RegisterTraceWriterRequest::target_buffer() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.RegisterTraceWriterRequest.target_buffer)
  return target_buffer_;
}
inline void RegisterTraceWriterRequest::set_target_buffer(::google::protobuf::uint32 value) {
  set_has_target_buffer();
  target_buffer_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.RegisterTraceWriterRequest.target_buffer)
}

// -------------------------------------------------------------------

// RegisterTraceWriterResponse

// -------------------------------------------------------------------

// UnregisterTraceWriterRequest

// optional uint32 trace_writer_id = 1;
inline bool UnregisterTraceWriterRequest::has_trace_writer_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnregisterTraceWriterRequest::set_has_trace_writer_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnregisterTraceWriterRequest::clear_has_trace_writer_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnregisterTraceWriterRequest::clear_trace_writer_id() {
  trace_writer_id_ = 0u;
  clear_has_trace_writer_id();
}
inline ::google::protobuf::uint32 UnregisterTraceWriterRequest::trace_writer_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.UnregisterTraceWriterRequest.trace_writer_id)
  return trace_writer_id_;
}
inline void UnregisterTraceWriterRequest::set_trace_writer_id(::google::protobuf::uint32 value) {
  set_has_trace_writer_id();
  trace_writer_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.UnregisterTraceWriterRequest.trace_writer_id)
}

// -------------------------------------------------------------------

// UnregisterTraceWriterResponse

// -------------------------------------------------------------------

// CommitDataResponse

// -------------------------------------------------------------------

// NotifyDataSourceStartedRequest

// optional uint64 data_source_id = 1;
inline bool NotifyDataSourceStartedRequest::has_data_source_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NotifyDataSourceStartedRequest::set_has_data_source_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NotifyDataSourceStartedRequest::clear_has_data_source_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NotifyDataSourceStartedRequest::clear_data_source_id() {
  data_source_id_ = GOOGLE_ULONGLONG(0);
  clear_has_data_source_id();
}
inline ::google::protobuf::uint64 NotifyDataSourceStartedRequest::data_source_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.NotifyDataSourceStartedRequest.data_source_id)
  return data_source_id_;
}
inline void NotifyDataSourceStartedRequest::set_data_source_id(::google::protobuf::uint64 value) {
  set_has_data_source_id();
  data_source_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.NotifyDataSourceStartedRequest.data_source_id)
}

// -------------------------------------------------------------------

// NotifyDataSourceStartedResponse

// -------------------------------------------------------------------

// NotifyDataSourceStoppedRequest

// optional uint64 data_source_id = 1;
inline bool NotifyDataSourceStoppedRequest::has_data_source_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NotifyDataSourceStoppedRequest::set_has_data_source_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NotifyDataSourceStoppedRequest::clear_has_data_source_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NotifyDataSourceStoppedRequest::clear_data_source_id() {
  data_source_id_ = GOOGLE_ULONGLONG(0);
  clear_has_data_source_id();
}
inline ::google::protobuf::uint64 NotifyDataSourceStoppedRequest::data_source_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.NotifyDataSourceStoppedRequest.data_source_id)
  return data_source_id_;
}
inline void NotifyDataSourceStoppedRequest::set_data_source_id(::google::protobuf::uint64 value) {
  set_has_data_source_id();
  data_source_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.NotifyDataSourceStoppedRequest.data_source_id)
}

// -------------------------------------------------------------------

// NotifyDataSourceStoppedResponse

// -------------------------------------------------------------------

// ActivateTriggersRequest

// repeated string trigger_names = 1;
inline int ActivateTriggersRequest::trigger_names_size() const {
  return trigger_names_.size();
}
inline void ActivateTriggersRequest::clear_trigger_names() {
  trigger_names_.Clear();
}
inline const ::std::string& ActivateTriggersRequest::trigger_names(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ActivateTriggersRequest.trigger_names)
  return trigger_names_.Get(index);
}
inline ::std::string* ActivateTriggersRequest::mutable_trigger_names(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.ActivateTriggersRequest.trigger_names)
  return trigger_names_.Mutable(index);
}
inline void ActivateTriggersRequest::set_trigger_names(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.ActivateTriggersRequest.trigger_names)
  trigger_names_.Mutable(index)->assign(value);
}
inline void ActivateTriggersRequest::set_trigger_names(int index, const char* value) {
  trigger_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.ActivateTriggersRequest.trigger_names)
}
inline void ActivateTriggersRequest::set_trigger_names(int index, const char* value, size_t size) {
  trigger_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.ActivateTriggersRequest.trigger_names)
}
inline ::std::string* ActivateTriggersRequest::add_trigger_names() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.ActivateTriggersRequest.trigger_names)
  return trigger_names_.Add();
}
inline void ActivateTriggersRequest::add_trigger_names(const ::std::string& value) {
  trigger_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.ActivateTriggersRequest.trigger_names)
}
inline void ActivateTriggersRequest::add_trigger_names(const char* value) {
  trigger_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.ActivateTriggersRequest.trigger_names)
}
inline void ActivateTriggersRequest::add_trigger_names(const char* value, size_t size) {
  trigger_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.ActivateTriggersRequest.trigger_names)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ActivateTriggersRequest::trigger_names() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.ActivateTriggersRequest.trigger_names)
  return trigger_names_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ActivateTriggersRequest::mutable_trigger_names() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.ActivateTriggersRequest.trigger_names)
  return &trigger_names_;
}

// -------------------------------------------------------------------

// ActivateTriggersResponse

// -------------------------------------------------------------------

// GetAsyncCommandRequest

// -------------------------------------------------------------------

// GetAsyncCommandResponse_SetupDataSource

// optional uint64 new_instance_id = 1;
inline bool GetAsyncCommandResponse_SetupDataSource::has_new_instance_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetAsyncCommandResponse_SetupDataSource::set_has_new_instance_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetAsyncCommandResponse_SetupDataSource::clear_has_new_instance_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetAsyncCommandResponse_SetupDataSource::clear_new_instance_id() {
  new_instance_id_ = GOOGLE_ULONGLONG(0);
  clear_has_new_instance_id();
}
inline ::google::protobuf::uint64 GetAsyncCommandResponse_SetupDataSource::new_instance_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.SetupDataSource.new_instance_id)
  return new_instance_id_;
}
inline void GetAsyncCommandResponse_SetupDataSource::set_new_instance_id(::google::protobuf::uint64 value) {
  set_has_new_instance_id();
  new_instance_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.GetAsyncCommandResponse.SetupDataSource.new_instance_id)
}

// optional .perfetto.protos.DataSourceConfig config = 2;
inline bool GetAsyncCommandResponse_SetupDataSource::has_config() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetAsyncCommandResponse_SetupDataSource::set_has_config() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetAsyncCommandResponse_SetupDataSource::clear_has_config() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetAsyncCommandResponse_SetupDataSource::clear_config() {
  if (config_ != NULL) config_->::perfetto::protos::DataSourceConfig::Clear();
  clear_has_config();
}
inline const ::perfetto::protos::DataSourceConfig& GetAsyncCommandResponse_SetupDataSource::config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.SetupDataSource.config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return config_ != NULL ? *config_ : *default_instance().config_;
#else
  return config_ != NULL ? *config_ : *default_instance_->config_;
#endif
}
inline ::perfetto::protos::DataSourceConfig* GetAsyncCommandResponse_SetupDataSource::mutable_config() {
  set_has_config();
  if (config_ == NULL) {
    config_ = new ::perfetto::protos::DataSourceConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GetAsyncCommandResponse.SetupDataSource.config)
  return config_;
}
inline ::perfetto::protos::DataSourceConfig* GetAsyncCommandResponse_SetupDataSource::release_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.GetAsyncCommandResponse.SetupDataSource.config)
  clear_has_config();
  ::perfetto::protos::DataSourceConfig* temp = config_;
  config_ = NULL;
  return temp;
}
inline void GetAsyncCommandResponse_SetupDataSource::set_allocated_config(::perfetto::protos::DataSourceConfig* config) {
  delete config_;
  config_ = config;
  if (config) {
    set_has_config();
  } else {
    clear_has_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.GetAsyncCommandResponse.SetupDataSource.config)
}

// -------------------------------------------------------------------

// GetAsyncCommandResponse_StartDataSource

// optional uint64 new_instance_id = 1;
inline bool GetAsyncCommandResponse_StartDataSource::has_new_instance_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetAsyncCommandResponse_StartDataSource::set_has_new_instance_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetAsyncCommandResponse_StartDataSource::clear_has_new_instance_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetAsyncCommandResponse_StartDataSource::clear_new_instance_id() {
  new_instance_id_ = GOOGLE_ULONGLONG(0);
  clear_has_new_instance_id();
}
inline ::google::protobuf::uint64 GetAsyncCommandResponse_StartDataSource::new_instance_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.StartDataSource.new_instance_id)
  return new_instance_id_;
}
inline void GetAsyncCommandResponse_StartDataSource::set_new_instance_id(::google::protobuf::uint64 value) {
  set_has_new_instance_id();
  new_instance_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.GetAsyncCommandResponse.StartDataSource.new_instance_id)
}

// optional .perfetto.protos.DataSourceConfig config = 2;
inline bool GetAsyncCommandResponse_StartDataSource::has_config() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetAsyncCommandResponse_StartDataSource::set_has_config() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetAsyncCommandResponse_StartDataSource::clear_has_config() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetAsyncCommandResponse_StartDataSource::clear_config() {
  if (config_ != NULL) config_->::perfetto::protos::DataSourceConfig::Clear();
  clear_has_config();
}
inline const ::perfetto::protos::DataSourceConfig& GetAsyncCommandResponse_StartDataSource::config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.StartDataSource.config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return config_ != NULL ? *config_ : *default_instance().config_;
#else
  return config_ != NULL ? *config_ : *default_instance_->config_;
#endif
}
inline ::perfetto::protos::DataSourceConfig* GetAsyncCommandResponse_StartDataSource::mutable_config() {
  set_has_config();
  if (config_ == NULL) {
    config_ = new ::perfetto::protos::DataSourceConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GetAsyncCommandResponse.StartDataSource.config)
  return config_;
}
inline ::perfetto::protos::DataSourceConfig* GetAsyncCommandResponse_StartDataSource::release_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.GetAsyncCommandResponse.StartDataSource.config)
  clear_has_config();
  ::perfetto::protos::DataSourceConfig* temp = config_;
  config_ = NULL;
  return temp;
}
inline void GetAsyncCommandResponse_StartDataSource::set_allocated_config(::perfetto::protos::DataSourceConfig* config) {
  delete config_;
  config_ = config;
  if (config) {
    set_has_config();
  } else {
    clear_has_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.GetAsyncCommandResponse.StartDataSource.config)
}

// -------------------------------------------------------------------

// GetAsyncCommandResponse_StopDataSource

// optional uint64 instance_id = 1;
inline bool GetAsyncCommandResponse_StopDataSource::has_instance_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetAsyncCommandResponse_StopDataSource::set_has_instance_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetAsyncCommandResponse_StopDataSource::clear_has_instance_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetAsyncCommandResponse_StopDataSource::clear_instance_id() {
  instance_id_ = GOOGLE_ULONGLONG(0);
  clear_has_instance_id();
}
inline ::google::protobuf::uint64 GetAsyncCommandResponse_StopDataSource::instance_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.StopDataSource.instance_id)
  return instance_id_;
}
inline void GetAsyncCommandResponse_StopDataSource::set_instance_id(::google::protobuf::uint64 value) {
  set_has_instance_id();
  instance_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.GetAsyncCommandResponse.StopDataSource.instance_id)
}

// -------------------------------------------------------------------

// GetAsyncCommandResponse_SetupTracing

// optional uint32 shared_buffer_page_size_kb = 1;
inline bool GetAsyncCommandResponse_SetupTracing::has_shared_buffer_page_size_kb() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetAsyncCommandResponse_SetupTracing::set_has_shared_buffer_page_size_kb() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetAsyncCommandResponse_SetupTracing::clear_has_shared_buffer_page_size_kb() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetAsyncCommandResponse_SetupTracing::clear_shared_buffer_page_size_kb() {
  shared_buffer_page_size_kb_ = 0u;
  clear_has_shared_buffer_page_size_kb();
}
inline ::google::protobuf::uint32 GetAsyncCommandResponse_SetupTracing::shared_buffer_page_size_kb() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.SetupTracing.shared_buffer_page_size_kb)
  return shared_buffer_page_size_kb_;
}
inline void GetAsyncCommandResponse_SetupTracing::set_shared_buffer_page_size_kb(::google::protobuf::uint32 value) {
  set_has_shared_buffer_page_size_kb();
  shared_buffer_page_size_kb_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.GetAsyncCommandResponse.SetupTracing.shared_buffer_page_size_kb)
}

// -------------------------------------------------------------------

// GetAsyncCommandResponse_Flush

// repeated uint64 data_source_ids = 1;
inline int GetAsyncCommandResponse_Flush::data_source_ids_size() const {
  return data_source_ids_.size();
}
inline void GetAsyncCommandResponse_Flush::clear_data_source_ids() {
  data_source_ids_.Clear();
}
inline ::google::protobuf::uint64 GetAsyncCommandResponse_Flush::data_source_ids(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.Flush.data_source_ids)
  return data_source_ids_.Get(index);
}
inline void GetAsyncCommandResponse_Flush::set_data_source_ids(int index, ::google::protobuf::uint64 value) {
  data_source_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.GetAsyncCommandResponse.Flush.data_source_ids)
}
inline void GetAsyncCommandResponse_Flush::add_data_source_ids(::google::protobuf::uint64 value) {
  data_source_ids_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.GetAsyncCommandResponse.Flush.data_source_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
GetAsyncCommandResponse_Flush::data_source_ids() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.GetAsyncCommandResponse.Flush.data_source_ids)
  return data_source_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
GetAsyncCommandResponse_Flush::mutable_data_source_ids() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.GetAsyncCommandResponse.Flush.data_source_ids)
  return &data_source_ids_;
}

// optional uint64 request_id = 2;
inline bool GetAsyncCommandResponse_Flush::has_request_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetAsyncCommandResponse_Flush::set_has_request_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetAsyncCommandResponse_Flush::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetAsyncCommandResponse_Flush::clear_request_id() {
  request_id_ = GOOGLE_ULONGLONG(0);
  clear_has_request_id();
}
inline ::google::protobuf::uint64 GetAsyncCommandResponse_Flush::request_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.Flush.request_id)
  return request_id_;
}
inline void GetAsyncCommandResponse_Flush::set_request_id(::google::protobuf::uint64 value) {
  set_has_request_id();
  request_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.GetAsyncCommandResponse.Flush.request_id)
}

// -------------------------------------------------------------------

// GetAsyncCommandResponse_ClearIncrementalState

// repeated uint64 data_source_ids = 1;
inline int GetAsyncCommandResponse_ClearIncrementalState::data_source_ids_size() const {
  return data_source_ids_.size();
}
inline void GetAsyncCommandResponse_ClearIncrementalState::clear_data_source_ids() {
  data_source_ids_.Clear();
}
inline ::google::protobuf::uint64 GetAsyncCommandResponse_ClearIncrementalState::data_source_ids(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.ClearIncrementalState.data_source_ids)
  return data_source_ids_.Get(index);
}
inline void GetAsyncCommandResponse_ClearIncrementalState::set_data_source_ids(int index, ::google::protobuf::uint64 value) {
  data_source_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.GetAsyncCommandResponse.ClearIncrementalState.data_source_ids)
}
inline void GetAsyncCommandResponse_ClearIncrementalState::add_data_source_ids(::google::protobuf::uint64 value) {
  data_source_ids_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.GetAsyncCommandResponse.ClearIncrementalState.data_source_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
GetAsyncCommandResponse_ClearIncrementalState::data_source_ids() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.GetAsyncCommandResponse.ClearIncrementalState.data_source_ids)
  return data_source_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
GetAsyncCommandResponse_ClearIncrementalState::mutable_data_source_ids() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.GetAsyncCommandResponse.ClearIncrementalState.data_source_ids)
  return &data_source_ids_;
}

// -------------------------------------------------------------------

// GetAsyncCommandResponse

// optional .perfetto.protos.GetAsyncCommandResponse.SetupTracing setup_tracing = 3;
inline bool GetAsyncCommandResponse::has_setup_tracing() const {
  return cmd_case() == kSetupTracing;
}
inline void GetAsyncCommandResponse::set_has_setup_tracing() {
  _oneof_case_[0] = kSetupTracing;
}
inline void GetAsyncCommandResponse::clear_setup_tracing() {
  if (has_setup_tracing()) {
    delete cmd_.setup_tracing_;
    clear_has_cmd();
  }
}
inline  const ::perfetto::protos::GetAsyncCommandResponse_SetupTracing& GetAsyncCommandResponse::setup_tracing() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.setup_tracing)
  return has_setup_tracing()
      ? *cmd_.setup_tracing_
      : ::perfetto::protos::GetAsyncCommandResponse_SetupTracing::default_instance();
}
inline ::perfetto::protos::GetAsyncCommandResponse_SetupTracing* GetAsyncCommandResponse::mutable_setup_tracing() {
  if (!has_setup_tracing()) {
    clear_cmd();
    set_has_setup_tracing();
    cmd_.setup_tracing_ = new ::perfetto::protos::GetAsyncCommandResponse_SetupTracing;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GetAsyncCommandResponse.setup_tracing)
  return cmd_.setup_tracing_;
}
inline ::perfetto::protos::GetAsyncCommandResponse_SetupTracing* GetAsyncCommandResponse::release_setup_tracing() {
  // @@protoc_insertion_point(field_release:perfetto.protos.GetAsyncCommandResponse.setup_tracing)
  if (has_setup_tracing()) {
    clear_has_cmd();
    ::perfetto::protos::GetAsyncCommandResponse_SetupTracing* temp = cmd_.setup_tracing_;
    cmd_.setup_tracing_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GetAsyncCommandResponse::set_allocated_setup_tracing(::perfetto::protos::GetAsyncCommandResponse_SetupTracing* setup_tracing) {
  clear_cmd();
  if (setup_tracing) {
    set_has_setup_tracing();
    cmd_.setup_tracing_ = setup_tracing;
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.GetAsyncCommandResponse.setup_tracing)
}

// optional .perfetto.protos.GetAsyncCommandResponse.SetupDataSource setup_data_source = 6;
inline bool GetAsyncCommandResponse::has_setup_data_source() const {
  return cmd_case() == kSetupDataSource;
}
inline void GetAsyncCommandResponse::set_has_setup_data_source() {
  _oneof_case_[0] = kSetupDataSource;
}
inline void GetAsyncCommandResponse::clear_setup_data_source() {
  if (has_setup_data_source()) {
    delete cmd_.setup_data_source_;
    clear_has_cmd();
  }
}
inline  const ::perfetto::protos::GetAsyncCommandResponse_SetupDataSource& GetAsyncCommandResponse::setup_data_source() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.setup_data_source)
  return has_setup_data_source()
      ? *cmd_.setup_data_source_
      : ::perfetto::protos::GetAsyncCommandResponse_SetupDataSource::default_instance();
}
inline ::perfetto::protos::GetAsyncCommandResponse_SetupDataSource* GetAsyncCommandResponse::mutable_setup_data_source() {
  if (!has_setup_data_source()) {
    clear_cmd();
    set_has_setup_data_source();
    cmd_.setup_data_source_ = new ::perfetto::protos::GetAsyncCommandResponse_SetupDataSource;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GetAsyncCommandResponse.setup_data_source)
  return cmd_.setup_data_source_;
}
inline ::perfetto::protos::GetAsyncCommandResponse_SetupDataSource* GetAsyncCommandResponse::release_setup_data_source() {
  // @@protoc_insertion_point(field_release:perfetto.protos.GetAsyncCommandResponse.setup_data_source)
  if (has_setup_data_source()) {
    clear_has_cmd();
    ::perfetto::protos::GetAsyncCommandResponse_SetupDataSource* temp = cmd_.setup_data_source_;
    cmd_.setup_data_source_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GetAsyncCommandResponse::set_allocated_setup_data_source(::perfetto::protos::GetAsyncCommandResponse_SetupDataSource* setup_data_source) {
  clear_cmd();
  if (setup_data_source) {
    set_has_setup_data_source();
    cmd_.setup_data_source_ = setup_data_source;
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.GetAsyncCommandResponse.setup_data_source)
}

// optional .perfetto.protos.GetAsyncCommandResponse.StartDataSource start_data_source = 1;
inline bool GetAsyncCommandResponse::has_start_data_source() const {
  return cmd_case() == kStartDataSource;
}
inline void GetAsyncCommandResponse::set_has_start_data_source() {
  _oneof_case_[0] = kStartDataSource;
}
inline void GetAsyncCommandResponse::clear_start_data_source() {
  if (has_start_data_source()) {
    delete cmd_.start_data_source_;
    clear_has_cmd();
  }
}
inline  const ::perfetto::protos::GetAsyncCommandResponse_StartDataSource& GetAsyncCommandResponse::start_data_source() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.start_data_source)
  return has_start_data_source()
      ? *cmd_.start_data_source_
      : ::perfetto::protos::GetAsyncCommandResponse_StartDataSource::default_instance();
}
inline ::perfetto::protos::GetAsyncCommandResponse_StartDataSource* GetAsyncCommandResponse::mutable_start_data_source() {
  if (!has_start_data_source()) {
    clear_cmd();
    set_has_start_data_source();
    cmd_.start_data_source_ = new ::perfetto::protos::GetAsyncCommandResponse_StartDataSource;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GetAsyncCommandResponse.start_data_source)
  return cmd_.start_data_source_;
}
inline ::perfetto::protos::GetAsyncCommandResponse_StartDataSource* GetAsyncCommandResponse::release_start_data_source() {
  // @@protoc_insertion_point(field_release:perfetto.protos.GetAsyncCommandResponse.start_data_source)
  if (has_start_data_source()) {
    clear_has_cmd();
    ::perfetto::protos::GetAsyncCommandResponse_StartDataSource* temp = cmd_.start_data_source_;
    cmd_.start_data_source_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GetAsyncCommandResponse::set_allocated_start_data_source(::perfetto::protos::GetAsyncCommandResponse_StartDataSource* start_data_source) {
  clear_cmd();
  if (start_data_source) {
    set_has_start_data_source();
    cmd_.start_data_source_ = start_data_source;
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.GetAsyncCommandResponse.start_data_source)
}

// optional .perfetto.protos.GetAsyncCommandResponse.StopDataSource stop_data_source = 2;
inline bool GetAsyncCommandResponse::has_stop_data_source() const {
  return cmd_case() == kStopDataSource;
}
inline void GetAsyncCommandResponse::set_has_stop_data_source() {
  _oneof_case_[0] = kStopDataSource;
}
inline void GetAsyncCommandResponse::clear_stop_data_source() {
  if (has_stop_data_source()) {
    delete cmd_.stop_data_source_;
    clear_has_cmd();
  }
}
inline  const ::perfetto::protos::GetAsyncCommandResponse_StopDataSource& GetAsyncCommandResponse::stop_data_source() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.stop_data_source)
  return has_stop_data_source()
      ? *cmd_.stop_data_source_
      : ::perfetto::protos::GetAsyncCommandResponse_StopDataSource::default_instance();
}
inline ::perfetto::protos::GetAsyncCommandResponse_StopDataSource* GetAsyncCommandResponse::mutable_stop_data_source() {
  if (!has_stop_data_source()) {
    clear_cmd();
    set_has_stop_data_source();
    cmd_.stop_data_source_ = new ::perfetto::protos::GetAsyncCommandResponse_StopDataSource;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GetAsyncCommandResponse.stop_data_source)
  return cmd_.stop_data_source_;
}
inline ::perfetto::protos::GetAsyncCommandResponse_StopDataSource* GetAsyncCommandResponse::release_stop_data_source() {
  // @@protoc_insertion_point(field_release:perfetto.protos.GetAsyncCommandResponse.stop_data_source)
  if (has_stop_data_source()) {
    clear_has_cmd();
    ::perfetto::protos::GetAsyncCommandResponse_StopDataSource* temp = cmd_.stop_data_source_;
    cmd_.stop_data_source_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GetAsyncCommandResponse::set_allocated_stop_data_source(::perfetto::protos::GetAsyncCommandResponse_StopDataSource* stop_data_source) {
  clear_cmd();
  if (stop_data_source) {
    set_has_stop_data_source();
    cmd_.stop_data_source_ = stop_data_source;
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.GetAsyncCommandResponse.stop_data_source)
}

// optional .perfetto.protos.GetAsyncCommandResponse.Flush flush = 5;
inline bool GetAsyncCommandResponse::has_flush() const {
  return cmd_case() == kFlush;
}
inline void GetAsyncCommandResponse::set_has_flush() {
  _oneof_case_[0] = kFlush;
}
inline void GetAsyncCommandResponse::clear_flush() {
  if (has_flush()) {
    delete cmd_.flush_;
    clear_has_cmd();
  }
}
inline  const ::perfetto::protos::GetAsyncCommandResponse_Flush& GetAsyncCommandResponse::flush() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.flush)
  return has_flush()
      ? *cmd_.flush_
      : ::perfetto::protos::GetAsyncCommandResponse_Flush::default_instance();
}
inline ::perfetto::protos::GetAsyncCommandResponse_Flush* GetAsyncCommandResponse::mutable_flush() {
  if (!has_flush()) {
    clear_cmd();
    set_has_flush();
    cmd_.flush_ = new ::perfetto::protos::GetAsyncCommandResponse_Flush;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GetAsyncCommandResponse.flush)
  return cmd_.flush_;
}
inline ::perfetto::protos::GetAsyncCommandResponse_Flush* GetAsyncCommandResponse::release_flush() {
  // @@protoc_insertion_point(field_release:perfetto.protos.GetAsyncCommandResponse.flush)
  if (has_flush()) {
    clear_has_cmd();
    ::perfetto::protos::GetAsyncCommandResponse_Flush* temp = cmd_.flush_;
    cmd_.flush_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GetAsyncCommandResponse::set_allocated_flush(::perfetto::protos::GetAsyncCommandResponse_Flush* flush) {
  clear_cmd();
  if (flush) {
    set_has_flush();
    cmd_.flush_ = flush;
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.GetAsyncCommandResponse.flush)
}

// optional .perfetto.protos.GetAsyncCommandResponse.ClearIncrementalState clear_incremental_state = 7;
inline bool GetAsyncCommandResponse::has_clear_incremental_state() const {
  return cmd_case() == kClearIncrementalState;
}
inline void GetAsyncCommandResponse::set_has_clear_incremental_state() {
  _oneof_case_[0] = kClearIncrementalState;
}
inline void GetAsyncCommandResponse::clear_clear_incremental_state() {
  if (has_clear_incremental_state()) {
    delete cmd_.clear_incremental_state_;
    clear_has_cmd();
  }
}
inline  const ::perfetto::protos::GetAsyncCommandResponse_ClearIncrementalState& GetAsyncCommandResponse::clear_incremental_state() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.clear_incremental_state)
  return has_clear_incremental_state()
      ? *cmd_.clear_incremental_state_
      : ::perfetto::protos::GetAsyncCommandResponse_ClearIncrementalState::default_instance();
}
inline ::perfetto::protos::GetAsyncCommandResponse_ClearIncrementalState* GetAsyncCommandResponse::mutable_clear_incremental_state() {
  if (!has_clear_incremental_state()) {
    clear_cmd();
    set_has_clear_incremental_state();
    cmd_.clear_incremental_state_ = new ::perfetto::protos::GetAsyncCommandResponse_ClearIncrementalState;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GetAsyncCommandResponse.clear_incremental_state)
  return cmd_.clear_incremental_state_;
}
inline ::perfetto::protos::GetAsyncCommandResponse_ClearIncrementalState* GetAsyncCommandResponse::release_clear_incremental_state() {
  // @@protoc_insertion_point(field_release:perfetto.protos.GetAsyncCommandResponse.clear_incremental_state)
  if (has_clear_incremental_state()) {
    clear_has_cmd();
    ::perfetto::protos::GetAsyncCommandResponse_ClearIncrementalState* temp = cmd_.clear_incremental_state_;
    cmd_.clear_incremental_state_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GetAsyncCommandResponse::set_allocated_clear_incremental_state(::perfetto::protos::GetAsyncCommandResponse_ClearIncrementalState* clear_incremental_state) {
  clear_cmd();
  if (clear_incremental_state) {
    set_has_clear_incremental_state();
    cmd_.clear_incremental_state_ = clear_incremental_state;
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.GetAsyncCommandResponse.clear_incremental_state)
}

inline bool GetAsyncCommandResponse::has_cmd() const {
  return cmd_case() != CMD_NOT_SET;
}
inline void GetAsyncCommandResponse::clear_has_cmd() {
  _oneof_case_[0] = CMD_NOT_SET;
}
inline GetAsyncCommandResponse::CmdCase GetAsyncCommandResponse::cmd_case() const {
  return GetAsyncCommandResponse::CmdCase(_oneof_case_[0]);
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::perfetto::protos::InitializeConnectionRequest_ProducerSMBScrapingMode> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::perfetto::protos::InitializeConnectionRequest_ProducerBuildFlags> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2fipc_2fproducer_5fport_2eproto__INCLUDED
// DO NOT EDIT. Autogenerated by Perfetto IPC
#ifndef PERFETTO_PROTOS_PROTOS_PERFETTO_IPC_PRODUCER_PORT_PROTO_H_
#define PERFETTO_PROTOS_PROTOS_PERFETTO_IPC_PRODUCER_PORT_PROTO_H_

// gen_amalgamated expanded: #include "protos/perfetto/ipc/producer_port.pb.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/deferred.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/service.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/service_descriptor.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/service_proxy.h"


namespace perfetto {
namespace protos {

class ProducerPort : public ::perfetto::ipc::Service {
 private:
  static ::perfetto::ipc::ServiceDescriptor* NewDescriptor();

 public:
  ~ProducerPort() override;

  static const ::perfetto::ipc::ServiceDescriptor& GetDescriptorStatic();

  // Service implementation.
  const ::perfetto::ipc::ServiceDescriptor& GetDescriptor() override;

  // Methods from the .proto file
  using DeferredInitializeConnectionResponse = ::perfetto::ipc::Deferred<InitializeConnectionResponse>;
  virtual void InitializeConnection(const InitializeConnectionRequest&, DeferredInitializeConnectionResponse) = 0;

  using DeferredRegisterDataSourceResponse = ::perfetto::ipc::Deferred<RegisterDataSourceResponse>;
  virtual void RegisterDataSource(const RegisterDataSourceRequest&, DeferredRegisterDataSourceResponse) = 0;

  using DeferredUnregisterDataSourceResponse = ::perfetto::ipc::Deferred<UnregisterDataSourceResponse>;
  virtual void UnregisterDataSource(const UnregisterDataSourceRequest&, DeferredUnregisterDataSourceResponse) = 0;

  using DeferredCommitDataResponse = ::perfetto::ipc::Deferred<CommitDataResponse>;
  virtual void CommitData(const CommitDataRequest&, DeferredCommitDataResponse) = 0;

  using DeferredGetAsyncCommandResponse = ::perfetto::ipc::Deferred<GetAsyncCommandResponse>;
  virtual void GetAsyncCommand(const GetAsyncCommandRequest&, DeferredGetAsyncCommandResponse) = 0;

  using DeferredRegisterTraceWriterResponse = ::perfetto::ipc::Deferred<RegisterTraceWriterResponse>;
  virtual void RegisterTraceWriter(const RegisterTraceWriterRequest&, DeferredRegisterTraceWriterResponse) = 0;

  using DeferredUnregisterTraceWriterResponse = ::perfetto::ipc::Deferred<UnregisterTraceWriterResponse>;
  virtual void UnregisterTraceWriter(const UnregisterTraceWriterRequest&, DeferredUnregisterTraceWriterResponse) = 0;

  using DeferredNotifyDataSourceStartedResponse = ::perfetto::ipc::Deferred<NotifyDataSourceStartedResponse>;
  virtual void NotifyDataSourceStarted(const NotifyDataSourceStartedRequest&, DeferredNotifyDataSourceStartedResponse) = 0;

  using DeferredNotifyDataSourceStoppedResponse = ::perfetto::ipc::Deferred<NotifyDataSourceStoppedResponse>;
  virtual void NotifyDataSourceStopped(const NotifyDataSourceStoppedRequest&, DeferredNotifyDataSourceStoppedResponse) = 0;

  using DeferredActivateTriggersResponse = ::perfetto::ipc::Deferred<ActivateTriggersResponse>;
  virtual void ActivateTriggers(const ActivateTriggersRequest&, DeferredActivateTriggersResponse) = 0;

};


class ProducerPortProxy : public ::perfetto::ipc::ServiceProxy {
 public:
   explicit ProducerPortProxy(::perfetto::ipc::ServiceProxy::EventListener*);
   ~ProducerPortProxy() override;

  // ServiceProxy implementation.
  const ::perfetto::ipc::ServiceDescriptor& GetDescriptor() override;

  // Methods from the .proto file
  using DeferredInitializeConnectionResponse = ::perfetto::ipc::Deferred<InitializeConnectionResponse>;
  void InitializeConnection(const InitializeConnectionRequest&, DeferredInitializeConnectionResponse, int fd = -1);

  using DeferredRegisterDataSourceResponse = ::perfetto::ipc::Deferred<RegisterDataSourceResponse>;
  void RegisterDataSource(const RegisterDataSourceRequest&, DeferredRegisterDataSourceResponse, int fd = -1);

  using DeferredUnregisterDataSourceResponse = ::perfetto::ipc::Deferred<UnregisterDataSourceResponse>;
  void UnregisterDataSource(const UnregisterDataSourceRequest&, DeferredUnregisterDataSourceResponse, int fd = -1);

  using DeferredCommitDataResponse = ::perfetto::ipc::Deferred<CommitDataResponse>;
  void CommitData(const CommitDataRequest&, DeferredCommitDataResponse, int fd = -1);

  using DeferredGetAsyncCommandResponse = ::perfetto::ipc::Deferred<GetAsyncCommandResponse>;
  void GetAsyncCommand(const GetAsyncCommandRequest&, DeferredGetAsyncCommandResponse, int fd = -1);

  using DeferredRegisterTraceWriterResponse = ::perfetto::ipc::Deferred<RegisterTraceWriterResponse>;
  void RegisterTraceWriter(const RegisterTraceWriterRequest&, DeferredRegisterTraceWriterResponse, int fd = -1);

  using DeferredUnregisterTraceWriterResponse = ::perfetto::ipc::Deferred<UnregisterTraceWriterResponse>;
  void UnregisterTraceWriter(const UnregisterTraceWriterRequest&, DeferredUnregisterTraceWriterResponse, int fd = -1);

  using DeferredNotifyDataSourceStartedResponse = ::perfetto::ipc::Deferred<NotifyDataSourceStartedResponse>;
  void NotifyDataSourceStarted(const NotifyDataSourceStartedRequest&, DeferredNotifyDataSourceStartedResponse, int fd = -1);

  using DeferredNotifyDataSourceStoppedResponse = ::perfetto::ipc::Deferred<NotifyDataSourceStoppedResponse>;
  void NotifyDataSourceStopped(const NotifyDataSourceStoppedRequest&, DeferredNotifyDataSourceStoppedResponse, int fd = -1);

  using DeferredActivateTriggersResponse = ::perfetto::ipc::Deferred<ActivateTriggersResponse>;
  void ActivateTriggers(const ActivateTriggersRequest&, DeferredActivateTriggersResponse, int fd = -1);

};

}  // namespace protos
}  // namespace perfetto

#endif  // PERFETTO_PROTOS_PROTOS_PERFETTO_IPC_PRODUCER_PORT_PROTO_H_
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/clock_snapshot.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/trace/clock_snapshot.proto

#ifndef PROTOBUF_protos_2fperfetto_2ftrace_2fclock_5fsnapshot_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2ftrace_2fclock_5fsnapshot_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2ftrace_2fclock_5fsnapshot_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2ftrace_2fclock_5fsnapshot_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2ftrace_2fclock_5fsnapshot_2eproto();

class ClockSnapshot;
class ClockSnapshot_Clock;

enum ClockSnapshot_Clock_BuiltinClocks {
  ClockSnapshot_Clock_BuiltinClocks_UNKNOWN = 0,
  ClockSnapshot_Clock_BuiltinClocks_REALTIME = 1,
  ClockSnapshot_Clock_BuiltinClocks_REALTIME_COARSE = 2,
  ClockSnapshot_Clock_BuiltinClocks_MONOTONIC = 3,
  ClockSnapshot_Clock_BuiltinClocks_MONOTONIC_COARSE = 4,
  ClockSnapshot_Clock_BuiltinClocks_MONOTONIC_RAW = 5,
  ClockSnapshot_Clock_BuiltinClocks_BOOTTIME = 6,
  ClockSnapshot_Clock_BuiltinClocks_PROCESS_CPUTIME = 7,
  ClockSnapshot_Clock_BuiltinClocks_THREAD_CPUTIME = 8,
  ClockSnapshot_Clock_BuiltinClocks_BUILTIN_CLOCK_MAX_ID = 63
};
bool ClockSnapshot_Clock_BuiltinClocks_IsValid(int value);
const ClockSnapshot_Clock_BuiltinClocks ClockSnapshot_Clock_BuiltinClocks_BuiltinClocks_MIN = ClockSnapshot_Clock_BuiltinClocks_UNKNOWN;
const ClockSnapshot_Clock_BuiltinClocks ClockSnapshot_Clock_BuiltinClocks_BuiltinClocks_MAX = ClockSnapshot_Clock_BuiltinClocks_BUILTIN_CLOCK_MAX_ID;
const int ClockSnapshot_Clock_BuiltinClocks_BuiltinClocks_ARRAYSIZE = ClockSnapshot_Clock_BuiltinClocks_BuiltinClocks_MAX + 1;

// ===================================================================

class ClockSnapshot_Clock : public ::google::protobuf::MessageLite {
 public:
  ClockSnapshot_Clock();
  virtual ~ClockSnapshot_Clock();

  ClockSnapshot_Clock(const ClockSnapshot_Clock& from);

  inline ClockSnapshot_Clock& operator=(const ClockSnapshot_Clock& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ClockSnapshot_Clock& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClockSnapshot_Clock* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClockSnapshot_Clock* other);

  // implements Message ----------------------------------------------

  inline ClockSnapshot_Clock* New() const { return New(NULL); }

  ClockSnapshot_Clock* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClockSnapshot_Clock& from);
  void MergeFrom(const ClockSnapshot_Clock& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClockSnapshot_Clock* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ClockSnapshot_Clock_BuiltinClocks BuiltinClocks;
  static const BuiltinClocks UNKNOWN =
    ClockSnapshot_Clock_BuiltinClocks_UNKNOWN;
  static const BuiltinClocks REALTIME =
    ClockSnapshot_Clock_BuiltinClocks_REALTIME;
  static const BuiltinClocks REALTIME_COARSE =
    ClockSnapshot_Clock_BuiltinClocks_REALTIME_COARSE;
  static const BuiltinClocks MONOTONIC =
    ClockSnapshot_Clock_BuiltinClocks_MONOTONIC;
  static const BuiltinClocks MONOTONIC_COARSE =
    ClockSnapshot_Clock_BuiltinClocks_MONOTONIC_COARSE;
  static const BuiltinClocks MONOTONIC_RAW =
    ClockSnapshot_Clock_BuiltinClocks_MONOTONIC_RAW;
  static const BuiltinClocks BOOTTIME =
    ClockSnapshot_Clock_BuiltinClocks_BOOTTIME;
  static const BuiltinClocks PROCESS_CPUTIME =
    ClockSnapshot_Clock_BuiltinClocks_PROCESS_CPUTIME;
  static const BuiltinClocks THREAD_CPUTIME =
    ClockSnapshot_Clock_BuiltinClocks_THREAD_CPUTIME;
  static const BuiltinClocks BUILTIN_CLOCK_MAX_ID =
    ClockSnapshot_Clock_BuiltinClocks_BUILTIN_CLOCK_MAX_ID;
  static inline bool BuiltinClocks_IsValid(int value) {
    return ClockSnapshot_Clock_BuiltinClocks_IsValid(value);
  }
  static const BuiltinClocks BuiltinClocks_MIN =
    ClockSnapshot_Clock_BuiltinClocks_BuiltinClocks_MIN;
  static const BuiltinClocks BuiltinClocks_MAX =
    ClockSnapshot_Clock_BuiltinClocks_BuiltinClocks_MAX;
  static const int BuiltinClocks_ARRAYSIZE =
    ClockSnapshot_Clock_BuiltinClocks_BuiltinClocks_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional uint32 clock_id = 1;
  bool has_clock_id() const;
  void clear_clock_id();
  static const int kClockIdFieldNumber = 1;
  ::google::protobuf::uint32 clock_id() const;
  void set_clock_id(::google::protobuf::uint32 value);

  // optional uint64 timestamp = 2;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.ClockSnapshot.Clock)
 private:
  inline void set_has_clock_id();
  inline void clear_has_clock_id();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 timestamp_;
  ::google::protobuf::uint32 clock_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2ftrace_2fclock_5fsnapshot_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2ftrace_2fclock_5fsnapshot_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2ftrace_2fclock_5fsnapshot_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2ftrace_2fclock_5fsnapshot_2eproto();

  void InitAsDefaultInstance();
  static ClockSnapshot_Clock* default_instance_;
};
// -------------------------------------------------------------------

class ClockSnapshot : public ::google::protobuf::MessageLite {
 public:
  ClockSnapshot();
  virtual ~ClockSnapshot();

  ClockSnapshot(const ClockSnapshot& from);

  inline ClockSnapshot& operator=(const ClockSnapshot& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ClockSnapshot& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClockSnapshot* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClockSnapshot* other);

  // implements Message ----------------------------------------------

  inline ClockSnapshot* New() const { return New(NULL); }

  ClockSnapshot* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClockSnapshot& from);
  void MergeFrom(const ClockSnapshot& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClockSnapshot* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ClockSnapshot_Clock Clock;

  // accessors -------------------------------------------------------

  // repeated .perfetto.protos.ClockSnapshot.Clock clocks = 1;
  int clocks_size() const;
  void clear_clocks();
  static const int kClocksFieldNumber = 1;
  const ::perfetto::protos::ClockSnapshot_Clock& clocks(int index) const;
  ::perfetto::protos::ClockSnapshot_Clock* mutable_clocks(int index);
  ::perfetto::protos::ClockSnapshot_Clock* add_clocks();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::ClockSnapshot_Clock >*
      mutable_clocks();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::ClockSnapshot_Clock >&
      clocks() const;

  // @@protoc_insertion_point(class_scope:perfetto.protos.ClockSnapshot)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::ClockSnapshot_Clock > clocks_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2ftrace_2fclock_5fsnapshot_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2ftrace_2fclock_5fsnapshot_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2ftrace_2fclock_5fsnapshot_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2ftrace_2fclock_5fsnapshot_2eproto();

  void InitAsDefaultInstance();
  static ClockSnapshot* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// ClockSnapshot_Clock

// optional uint32 clock_id = 1;
inline bool ClockSnapshot_Clock::has_clock_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClockSnapshot_Clock::set_has_clock_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClockSnapshot_Clock::clear_has_clock_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClockSnapshot_Clock::clear_clock_id() {
  clock_id_ = 0u;
  clear_has_clock_id();
}
inline ::google::protobuf::uint32 ClockSnapshot_Clock::clock_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ClockSnapshot.Clock.clock_id)
  return clock_id_;
}
inline void ClockSnapshot_Clock::set_clock_id(::google::protobuf::uint32 value) {
  set_has_clock_id();
  clock_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.ClockSnapshot.Clock.clock_id)
}

// optional uint64 timestamp = 2;
inline bool ClockSnapshot_Clock::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClockSnapshot_Clock::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClockSnapshot_Clock::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClockSnapshot_Clock::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 ClockSnapshot_Clock::timestamp() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ClockSnapshot.Clock.timestamp)
  return timestamp_;
}
inline void ClockSnapshot_Clock::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.ClockSnapshot.Clock.timestamp)
}

// -------------------------------------------------------------------

// ClockSnapshot

// repeated .perfetto.protos.ClockSnapshot.Clock clocks = 1;
inline int ClockSnapshot::clocks_size() const {
  return clocks_.size();
}
inline void ClockSnapshot::clear_clocks() {
  clocks_.Clear();
}
inline const ::perfetto::protos::ClockSnapshot_Clock& ClockSnapshot::clocks(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ClockSnapshot.clocks)
  return clocks_.Get(index);
}
inline ::perfetto::protos::ClockSnapshot_Clock* ClockSnapshot::mutable_clocks(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.ClockSnapshot.clocks)
  return clocks_.Mutable(index);
}
inline ::perfetto::protos::ClockSnapshot_Clock* ClockSnapshot::add_clocks() {
  // @@protoc_insertion_point(field_add:perfetto.protos.ClockSnapshot.clocks)
  return clocks_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::ClockSnapshot_Clock >*
ClockSnapshot::mutable_clocks() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.ClockSnapshot.clocks)
  return &clocks_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::ClockSnapshot_Clock >&
ClockSnapshot::clocks() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.ClockSnapshot.clocks)
  return clocks_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::perfetto::protos::ClockSnapshot_Clock_BuiltinClocks> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2ftrace_2fclock_5fsnapshot_2eproto__INCLUDED
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/trigger.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/trace/trigger.proto

#ifndef PROTOBUF_protos_2fperfetto_2ftrace_2ftrigger_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2ftrace_2ftrigger_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2ftrace_2ftrigger_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2ftrace_2ftrigger_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2ftrace_2ftrigger_2eproto();

class Trigger;

// ===================================================================

class Trigger : public ::google::protobuf::MessageLite {
 public:
  Trigger();
  virtual ~Trigger();

  Trigger(const Trigger& from);

  inline Trigger& operator=(const Trigger& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Trigger& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Trigger* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Trigger* other);

  // implements Message ----------------------------------------------

  inline Trigger* New() const { return New(NULL); }

  Trigger* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Trigger& from);
  void MergeFrom(const Trigger& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Trigger* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string trigger_name = 1;
  bool has_trigger_name() const;
  void clear_trigger_name();
  static const int kTriggerNameFieldNumber = 1;
  const ::std::string& trigger_name() const;
  void set_trigger_name(const ::std::string& value);
  void set_trigger_name(const char* value);
  void set_trigger_name(const char* value, size_t size);
  ::std::string* mutable_trigger_name();
  ::std::string* release_trigger_name();
  void set_allocated_trigger_name(::std::string* trigger_name);

  // optional string producer_name = 2;
  bool has_producer_name() const;
  void clear_producer_name();
  static const int kProducerNameFieldNumber = 2;
  const ::std::string& producer_name() const;
  void set_producer_name(const ::std::string& value);
  void set_producer_name(const char* value);
  void set_producer_name(const char* value, size_t size);
  ::std::string* mutable_producer_name();
  ::std::string* release_producer_name();
  void set_allocated_producer_name(::std::string* producer_name);

  // optional int32 trusted_producer_uid = 3;
  bool has_trusted_producer_uid() const;
  void clear_trusted_producer_uid();
  static const int kTrustedProducerUidFieldNumber = 3;
  ::google::protobuf::int32 trusted_producer_uid() const;
  void set_trusted_producer_uid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.Trigger)
 private:
  inline void set_has_trigger_name();
  inline void clear_has_trigger_name();
  inline void set_has_producer_name();
  inline void clear_has_producer_name();
  inline void set_has_trusted_producer_uid();
  inline void clear_has_trusted_producer_uid();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr trigger_name_;
  ::google::protobuf::internal::ArenaStringPtr producer_name_;
  ::google::protobuf::int32 trusted_producer_uid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2ftrace_2ftrigger_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2ftrace_2ftrigger_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2ftrace_2ftrigger_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2ftrace_2ftrigger_2eproto();

  void InitAsDefaultInstance();
  static Trigger* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Trigger

// optional string trigger_name = 1;
inline bool Trigger::has_trigger_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Trigger::set_has_trigger_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Trigger::clear_has_trigger_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Trigger::clear_trigger_name() {
  trigger_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_trigger_name();
}
inline const ::std::string& Trigger::trigger_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.Trigger.trigger_name)
  return trigger_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Trigger::set_trigger_name(const ::std::string& value) {
  set_has_trigger_name();
  trigger_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.Trigger.trigger_name)
}
inline void Trigger::set_trigger_name(const char* value) {
  set_has_trigger_name();
  trigger_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.Trigger.trigger_name)
}
inline void Trigger::set_trigger_name(const char* value, size_t size) {
  set_has_trigger_name();
  trigger_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.Trigger.trigger_name)
}
inline ::std::string* Trigger::mutable_trigger_name() {
  set_has_trigger_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.Trigger.trigger_name)
  return trigger_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Trigger::release_trigger_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.Trigger.trigger_name)
  clear_has_trigger_name();
  return trigger_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Trigger::set_allocated_trigger_name(::std::string* trigger_name) {
  if (trigger_name != NULL) {
    set_has_trigger_name();
  } else {
    clear_has_trigger_name();
  }
  trigger_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), trigger_name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.Trigger.trigger_name)
}

// optional string producer_name = 2;
inline bool Trigger::has_producer_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Trigger::set_has_producer_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Trigger::clear_has_producer_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Trigger::clear_producer_name() {
  producer_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_producer_name();
}
inline const ::std::string& Trigger::producer_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.Trigger.producer_name)
  return producer_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Trigger::set_producer_name(const ::std::string& value) {
  set_has_producer_name();
  producer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.Trigger.producer_name)
}
inline void Trigger::set_producer_name(const char* value) {
  set_has_producer_name();
  producer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.Trigger.producer_name)
}
inline void Trigger::set_producer_name(const char* value, size_t size) {
  set_has_producer_name();
  producer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.Trigger.producer_name)
}
inline ::std::string* Trigger::mutable_producer_name() {
  set_has_producer_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.Trigger.producer_name)
  return producer_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Trigger::release_producer_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.Trigger.producer_name)
  clear_has_producer_name();
  return producer_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Trigger::set_allocated_producer_name(::std::string* producer_name) {
  if (producer_name != NULL) {
    set_has_producer_name();
  } else {
    clear_has_producer_name();
  }
  producer_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), producer_name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.Trigger.producer_name)
}

// optional int32 trusted_producer_uid = 3;
inline bool Trigger::has_trusted_producer_uid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Trigger::set_has_trusted_producer_uid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Trigger::clear_has_trusted_producer_uid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Trigger::clear_trusted_producer_uid() {
  trusted_producer_uid_ = 0;
  clear_has_trusted_producer_uid();
}
inline ::google::protobuf::int32 Trigger::trusted_producer_uid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.Trigger.trusted_producer_uid)
  return trusted_producer_uid_;
}
inline void Trigger::set_trusted_producer_uid(::google::protobuf::int32 value) {
  set_has_trusted_producer_uid();
  trusted_producer_uid_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.Trigger.trusted_producer_uid)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2ftrace_2ftrigger_2eproto__INCLUDED
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/system_info.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/trace/system_info.proto

#ifndef PROTOBUF_protos_2fperfetto_2ftrace_2fsystem_5finfo_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2ftrace_2fsystem_5finfo_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2ftrace_2fsystem_5finfo_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2ftrace_2fsystem_5finfo_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2ftrace_2fsystem_5finfo_2eproto();

class SystemInfo;
class Utsname;

// ===================================================================

class Utsname : public ::google::protobuf::MessageLite {
 public:
  Utsname();
  virtual ~Utsname();

  Utsname(const Utsname& from);

  inline Utsname& operator=(const Utsname& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Utsname& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Utsname* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Utsname* other);

  // implements Message ----------------------------------------------

  inline Utsname* New() const { return New(NULL); }

  Utsname* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Utsname& from);
  void MergeFrom(const Utsname& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Utsname* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string sysname = 1;
  bool has_sysname() const;
  void clear_sysname();
  static const int kSysnameFieldNumber = 1;
  const ::std::string& sysname() const;
  void set_sysname(const ::std::string& value);
  void set_sysname(const char* value);
  void set_sysname(const char* value, size_t size);
  ::std::string* mutable_sysname();
  ::std::string* release_sysname();
  void set_allocated_sysname(::std::string* sysname);

  // optional string version = 2;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // optional string release = 3;
  bool has_release() const;
  void clear_release();
  static const int kReleaseFieldNumber = 3;
  const ::std::string& release() const;
  void set_release(const ::std::string& value);
  void set_release(const char* value);
  void set_release(const char* value, size_t size);
  ::std::string* mutable_release();
  ::std::string* release_release();
  void set_allocated_release(::std::string* release);

  // optional string machine = 4;
  bool has_machine() const;
  void clear_machine();
  static const int kMachineFieldNumber = 4;
  const ::std::string& machine() const;
  void set_machine(const ::std::string& value);
  void set_machine(const char* value);
  void set_machine(const char* value, size_t size);
  ::std::string* mutable_machine();
  ::std::string* release_machine();
  void set_allocated_machine(::std::string* machine);

  // @@protoc_insertion_point(class_scope:perfetto.protos.Utsname)
 private:
  inline void set_has_sysname();
  inline void clear_has_sysname();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_release();
  inline void clear_has_release();
  inline void set_has_machine();
  inline void clear_has_machine();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr sysname_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr release_;
  ::google::protobuf::internal::ArenaStringPtr machine_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2ftrace_2fsystem_5finfo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2ftrace_2fsystem_5finfo_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2ftrace_2fsystem_5finfo_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2ftrace_2fsystem_5finfo_2eproto();

  void InitAsDefaultInstance();
  static Utsname* default_instance_;
};
// -------------------------------------------------------------------

class SystemInfo : public ::google::protobuf::MessageLite {
 public:
  SystemInfo();
  virtual ~SystemInfo();

  SystemInfo(const SystemInfo& from);

  inline SystemInfo& operator=(const SystemInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const SystemInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SystemInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SystemInfo* other);

  // implements Message ----------------------------------------------

  inline SystemInfo* New() const { return New(NULL); }

  SystemInfo* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SystemInfo& from);
  void MergeFrom(const SystemInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SystemInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .perfetto.protos.Utsname utsname = 1;
  bool has_utsname() const;
  void clear_utsname();
  static const int kUtsnameFieldNumber = 1;
  const ::perfetto::protos::Utsname& utsname() const;
  ::perfetto::protos::Utsname* mutable_utsname();
  ::perfetto::protos::Utsname* release_utsname();
  void set_allocated_utsname(::perfetto::protos::Utsname* utsname);

  // @@protoc_insertion_point(class_scope:perfetto.protos.SystemInfo)
 private:
  inline void set_has_utsname();
  inline void clear_has_utsname();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::perfetto::protos::Utsname* utsname_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2ftrace_2fsystem_5finfo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2ftrace_2fsystem_5finfo_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2ftrace_2fsystem_5finfo_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2ftrace_2fsystem_5finfo_2eproto();

  void InitAsDefaultInstance();
  static SystemInfo* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Utsname

// optional string sysname = 1;
inline bool Utsname::has_sysname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Utsname::set_has_sysname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Utsname::clear_has_sysname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Utsname::clear_sysname() {
  sysname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sysname();
}
inline const ::std::string& Utsname::sysname() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.Utsname.sysname)
  return sysname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Utsname::set_sysname(const ::std::string& value) {
  set_has_sysname();
  sysname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.Utsname.sysname)
}
inline void Utsname::set_sysname(const char* value) {
  set_has_sysname();
  sysname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.Utsname.sysname)
}
inline void Utsname::set_sysname(const char* value, size_t size) {
  set_has_sysname();
  sysname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.Utsname.sysname)
}
inline ::std::string* Utsname::mutable_sysname() {
  set_has_sysname();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.Utsname.sysname)
  return sysname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Utsname::release_sysname() {
  // @@protoc_insertion_point(field_release:perfetto.protos.Utsname.sysname)
  clear_has_sysname();
  return sysname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Utsname::set_allocated_sysname(::std::string* sysname) {
  if (sysname != NULL) {
    set_has_sysname();
  } else {
    clear_has_sysname();
  }
  sysname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sysname);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.Utsname.sysname)
}

// optional string version = 2;
inline bool Utsname::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Utsname::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Utsname::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Utsname::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_version();
}
inline const ::std::string& Utsname::version() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.Utsname.version)
  return version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Utsname::set_version(const ::std::string& value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.Utsname.version)
}
inline void Utsname::set_version(const char* value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.Utsname.version)
}
inline void Utsname::set_version(const char* value, size_t size) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.Utsname.version)
}
inline ::std::string* Utsname::mutable_version() {
  set_has_version();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.Utsname.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Utsname::release_version() {
  // @@protoc_insertion_point(field_release:perfetto.protos.Utsname.version)
  clear_has_version();
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Utsname::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.Utsname.version)
}

// optional string release = 3;
inline bool Utsname::has_release() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Utsname::set_has_release() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Utsname::clear_has_release() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Utsname::clear_release() {
  release_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_release();
}
inline const ::std::string& Utsname::release() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.Utsname.release)
  return release_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Utsname::set_release(const ::std::string& value) {
  set_has_release();
  release_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.Utsname.release)
}
inline void Utsname::set_release(const char* value) {
  set_has_release();
  release_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.Utsname.release)
}
inline void Utsname::set_release(const char* value, size_t size) {
  set_has_release();
  release_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.Utsname.release)
}
inline ::std::string* Utsname::mutable_release() {
  set_has_release();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.Utsname.release)
  return release_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Utsname::release_release() {
  // @@protoc_insertion_point(field_release:perfetto.protos.Utsname.release)
  clear_has_release();
  return release_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Utsname::set_allocated_release(::std::string* release) {
  if (release != NULL) {
    set_has_release();
  } else {
    clear_has_release();
  }
  release_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), release);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.Utsname.release)
}

// optional string machine = 4;
inline bool Utsname::has_machine() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Utsname::set_has_machine() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Utsname::clear_has_machine() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Utsname::clear_machine() {
  machine_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_machine();
}
inline const ::std::string& Utsname::machine() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.Utsname.machine)
  return machine_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Utsname::set_machine(const ::std::string& value) {
  set_has_machine();
  machine_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.Utsname.machine)
}
inline void Utsname::set_machine(const char* value) {
  set_has_machine();
  machine_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.Utsname.machine)
}
inline void Utsname::set_machine(const char* value, size_t size) {
  set_has_machine();
  machine_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.Utsname.machine)
}
inline ::std::string* Utsname::mutable_machine() {
  set_has_machine();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.Utsname.machine)
  return machine_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Utsname::release_machine() {
  // @@protoc_insertion_point(field_release:perfetto.protos.Utsname.machine)
  clear_has_machine();
  return machine_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Utsname::set_allocated_machine(::std::string* machine) {
  if (machine != NULL) {
    set_has_machine();
  } else {
    clear_has_machine();
  }
  machine_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), machine);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.Utsname.machine)
}

// -------------------------------------------------------------------

// SystemInfo

// optional .perfetto.protos.Utsname utsname = 1;
inline bool SystemInfo::has_utsname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SystemInfo::set_has_utsname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SystemInfo::clear_has_utsname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SystemInfo::clear_utsname() {
  if (utsname_ != NULL) utsname_->::perfetto::protos::Utsname::Clear();
  clear_has_utsname();
}
inline const ::perfetto::protos::Utsname& SystemInfo::utsname() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SystemInfo.utsname)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return utsname_ != NULL ? *utsname_ : *default_instance().utsname_;
#else
  return utsname_ != NULL ? *utsname_ : *default_instance_->utsname_;
#endif
}
inline ::perfetto::protos::Utsname* SystemInfo::mutable_utsname() {
  set_has_utsname();
  if (utsname_ == NULL) {
    utsname_ = new ::perfetto::protos::Utsname;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.SystemInfo.utsname)
  return utsname_;
}
inline ::perfetto::protos::Utsname* SystemInfo::release_utsname() {
  // @@protoc_insertion_point(field_release:perfetto.protos.SystemInfo.utsname)
  clear_has_utsname();
  ::perfetto::protos::Utsname* temp = utsname_;
  utsname_ = NULL;
  return temp;
}
inline void SystemInfo::set_allocated_utsname(::perfetto::protos::Utsname* utsname) {
  delete utsname_;
  utsname_ = utsname;
  if (utsname) {
    set_has_utsname();
  } else {
    clear_has_utsname();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.SystemInfo.utsname)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2ftrace_2fsystem_5finfo_2eproto__INCLUDED
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/trusted_packet.pb.h
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/clock_snapshot.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/trace/clock_snapshot.proto

#ifndef PROTOBUF_protos_2fperfetto_2ftrace_2fclock_5fsnapshot_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2ftrace_2fclock_5fsnapshot_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2ftrace_2fclock_5fsnapshot_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2ftrace_2fclock_5fsnapshot_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2ftrace_2fclock_5fsnapshot_2eproto();

class ClockSnapshot;
class ClockSnapshot_Clock;

enum ClockSnapshot_Clock_BuiltinClocks {
  ClockSnapshot_Clock_BuiltinClocks_UNKNOWN = 0,
  ClockSnapshot_Clock_BuiltinClocks_REALTIME = 1,
  ClockSnapshot_Clock_BuiltinClocks_REALTIME_COARSE = 2,
  ClockSnapshot_Clock_BuiltinClocks_MONOTONIC = 3,
  ClockSnapshot_Clock_BuiltinClocks_MONOTONIC_COARSE = 4,
  ClockSnapshot_Clock_BuiltinClocks_MONOTONIC_RAW = 5,
  ClockSnapshot_Clock_BuiltinClocks_BOOTTIME = 6,
  ClockSnapshot_Clock_BuiltinClocks_PROCESS_CPUTIME = 7,
  ClockSnapshot_Clock_BuiltinClocks_THREAD_CPUTIME = 8,
  ClockSnapshot_Clock_BuiltinClocks_BUILTIN_CLOCK_MAX_ID = 63
};
bool ClockSnapshot_Clock_BuiltinClocks_IsValid(int value);
const ClockSnapshot_Clock_BuiltinClocks ClockSnapshot_Clock_BuiltinClocks_BuiltinClocks_MIN = ClockSnapshot_Clock_BuiltinClocks_UNKNOWN;
const ClockSnapshot_Clock_BuiltinClocks ClockSnapshot_Clock_BuiltinClocks_BuiltinClocks_MAX = ClockSnapshot_Clock_BuiltinClocks_BUILTIN_CLOCK_MAX_ID;
const int ClockSnapshot_Clock_BuiltinClocks_BuiltinClocks_ARRAYSIZE = ClockSnapshot_Clock_BuiltinClocks_BuiltinClocks_MAX + 1;

// ===================================================================

class ClockSnapshot_Clock : public ::google::protobuf::MessageLite {
 public:
  ClockSnapshot_Clock();
  virtual ~ClockSnapshot_Clock();

  ClockSnapshot_Clock(const ClockSnapshot_Clock& from);

  inline ClockSnapshot_Clock& operator=(const ClockSnapshot_Clock& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ClockSnapshot_Clock& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClockSnapshot_Clock* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClockSnapshot_Clock* other);

  // implements Message ----------------------------------------------

  inline ClockSnapshot_Clock* New() const { return New(NULL); }

  ClockSnapshot_Clock* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClockSnapshot_Clock& from);
  void MergeFrom(const ClockSnapshot_Clock& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClockSnapshot_Clock* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ClockSnapshot_Clock_BuiltinClocks BuiltinClocks;
  static const BuiltinClocks UNKNOWN =
    ClockSnapshot_Clock_BuiltinClocks_UNKNOWN;
  static const BuiltinClocks REALTIME =
    ClockSnapshot_Clock_BuiltinClocks_REALTIME;
  static const BuiltinClocks REALTIME_COARSE =
    ClockSnapshot_Clock_BuiltinClocks_REALTIME_COARSE;
  static const BuiltinClocks MONOTONIC =
    ClockSnapshot_Clock_BuiltinClocks_MONOTONIC;
  static const BuiltinClocks MONOTONIC_COARSE =
    ClockSnapshot_Clock_BuiltinClocks_MONOTONIC_COARSE;
  static const BuiltinClocks MONOTONIC_RAW =
    ClockSnapshot_Clock_BuiltinClocks_MONOTONIC_RAW;
  static const BuiltinClocks BOOTTIME =
    ClockSnapshot_Clock_BuiltinClocks_BOOTTIME;
  static const BuiltinClocks PROCESS_CPUTIME =
    ClockSnapshot_Clock_BuiltinClocks_PROCESS_CPUTIME;
  static const BuiltinClocks THREAD_CPUTIME =
    ClockSnapshot_Clock_BuiltinClocks_THREAD_CPUTIME;
  static const BuiltinClocks BUILTIN_CLOCK_MAX_ID =
    ClockSnapshot_Clock_BuiltinClocks_BUILTIN_CLOCK_MAX_ID;
  static inline bool BuiltinClocks_IsValid(int value) {
    return ClockSnapshot_Clock_BuiltinClocks_IsValid(value);
  }
  static const BuiltinClocks BuiltinClocks_MIN =
    ClockSnapshot_Clock_BuiltinClocks_BuiltinClocks_MIN;
  static const BuiltinClocks BuiltinClocks_MAX =
    ClockSnapshot_Clock_BuiltinClocks_BuiltinClocks_MAX;
  static const int BuiltinClocks_ARRAYSIZE =
    ClockSnapshot_Clock_BuiltinClocks_BuiltinClocks_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional uint32 clock_id = 1;
  bool has_clock_id() const;
  void clear_clock_id();
  static const int kClockIdFieldNumber = 1;
  ::google::protobuf::uint32 clock_id() const;
  void set_clock_id(::google::protobuf::uint32 value);

  // optional uint64 timestamp = 2;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.ClockSnapshot.Clock)
 private:
  inline void set_has_clock_id();
  inline void clear_has_clock_id();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 timestamp_;
  ::google::protobuf::uint32 clock_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2ftrace_2fclock_5fsnapshot_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2ftrace_2fclock_5fsnapshot_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2ftrace_2fclock_5fsnapshot_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2ftrace_2fclock_5fsnapshot_2eproto();

  void InitAsDefaultInstance();
  static ClockSnapshot_Clock* default_instance_;
};
// -------------------------------------------------------------------

class ClockSnapshot : public ::google::protobuf::MessageLite {
 public:
  ClockSnapshot();
  virtual ~ClockSnapshot();

  ClockSnapshot(const ClockSnapshot& from);

  inline ClockSnapshot& operator=(const ClockSnapshot& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ClockSnapshot& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClockSnapshot* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClockSnapshot* other);

  // implements Message ----------------------------------------------

  inline ClockSnapshot* New() const { return New(NULL); }

  ClockSnapshot* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClockSnapshot& from);
  void MergeFrom(const ClockSnapshot& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClockSnapshot* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ClockSnapshot_Clock Clock;

  // accessors -------------------------------------------------------

  // repeated .perfetto.protos.ClockSnapshot.Clock clocks = 1;
  int clocks_size() const;
  void clear_clocks();
  static const int kClocksFieldNumber = 1;
  const ::perfetto::protos::ClockSnapshot_Clock& clocks(int index) const;
  ::perfetto::protos::ClockSnapshot_Clock* mutable_clocks(int index);
  ::perfetto::protos::ClockSnapshot_Clock* add_clocks();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::ClockSnapshot_Clock >*
      mutable_clocks();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::ClockSnapshot_Clock >&
      clocks() const;

  // @@protoc_insertion_point(class_scope:perfetto.protos.ClockSnapshot)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::ClockSnapshot_Clock > clocks_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2ftrace_2fclock_5fsnapshot_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2ftrace_2fclock_5fsnapshot_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2ftrace_2fclock_5fsnapshot_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2ftrace_2fclock_5fsnapshot_2eproto();

  void InitAsDefaultInstance();
  static ClockSnapshot* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// ClockSnapshot_Clock

// optional uint32 clock_id = 1;
inline bool ClockSnapshot_Clock::has_clock_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClockSnapshot_Clock::set_has_clock_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClockSnapshot_Clock::clear_has_clock_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClockSnapshot_Clock::clear_clock_id() {
  clock_id_ = 0u;
  clear_has_clock_id();
}
inline ::google::protobuf::uint32 ClockSnapshot_Clock::clock_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ClockSnapshot.Clock.clock_id)
  return clock_id_;
}
inline void ClockSnapshot_Clock::set_clock_id(::google::protobuf::uint32 value) {
  set_has_clock_id();
  clock_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.ClockSnapshot.Clock.clock_id)
}

// optional uint64 timestamp = 2;
inline bool ClockSnapshot_Clock::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClockSnapshot_Clock::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClockSnapshot_Clock::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClockSnapshot_Clock::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 ClockSnapshot_Clock::timestamp() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ClockSnapshot.Clock.timestamp)
  return timestamp_;
}
inline void ClockSnapshot_Clock::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.ClockSnapshot.Clock.timestamp)
}

// -------------------------------------------------------------------

// ClockSnapshot

// repeated .perfetto.protos.ClockSnapshot.Clock clocks = 1;
inline int ClockSnapshot::clocks_size() const {
  return clocks_.size();
}
inline void ClockSnapshot::clear_clocks() {
  clocks_.Clear();
}
inline const ::perfetto::protos::ClockSnapshot_Clock& ClockSnapshot::clocks(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ClockSnapshot.clocks)
  return clocks_.Get(index);
}
inline ::perfetto::protos::ClockSnapshot_Clock* ClockSnapshot::mutable_clocks(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.ClockSnapshot.clocks)
  return clocks_.Mutable(index);
}
inline ::perfetto::protos::ClockSnapshot_Clock* ClockSnapshot::add_clocks() {
  // @@protoc_insertion_point(field_add:perfetto.protos.ClockSnapshot.clocks)
  return clocks_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::ClockSnapshot_Clock >*
ClockSnapshot::mutable_clocks() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.ClockSnapshot.clocks)
  return &clocks_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::ClockSnapshot_Clock >&
ClockSnapshot::clocks() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.ClockSnapshot.clocks)
  return clocks_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::perfetto::protos::ClockSnapshot_Clock_BuiltinClocks> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2ftrace_2fclock_5fsnapshot_2eproto__INCLUDED
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/system_info.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/trace/system_info.proto

#ifndef PROTOBUF_protos_2fperfetto_2ftrace_2fsystem_5finfo_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2ftrace_2fsystem_5finfo_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2ftrace_2fsystem_5finfo_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2ftrace_2fsystem_5finfo_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2ftrace_2fsystem_5finfo_2eproto();

class SystemInfo;
class Utsname;

// ===================================================================

class Utsname : public ::google::protobuf::MessageLite {
 public:
  Utsname();
  virtual ~Utsname();

  Utsname(const Utsname& from);

  inline Utsname& operator=(const Utsname& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Utsname& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Utsname* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Utsname* other);

  // implements Message ----------------------------------------------

  inline Utsname* New() const { return New(NULL); }

  Utsname* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Utsname& from);
  void MergeFrom(const Utsname& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Utsname* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string sysname = 1;
  bool has_sysname() const;
  void clear_sysname();
  static const int kSysnameFieldNumber = 1;
  const ::std::string& sysname() const;
  void set_sysname(const ::std::string& value);
  void set_sysname(const char* value);
  void set_sysname(const char* value, size_t size);
  ::std::string* mutable_sysname();
  ::std::string* release_sysname();
  void set_allocated_sysname(::std::string* sysname);

  // optional string version = 2;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // optional string release = 3;
  bool has_release() const;
  void clear_release();
  static const int kReleaseFieldNumber = 3;
  const ::std::string& release() const;
  void set_release(const ::std::string& value);
  void set_release(const char* value);
  void set_release(const char* value, size_t size);
  ::std::string* mutable_release();
  ::std::string* release_release();
  void set_allocated_release(::std::string* release);

  // optional string machine = 4;
  bool has_machine() const;
  void clear_machine();
  static const int kMachineFieldNumber = 4;
  const ::std::string& machine() const;
  void set_machine(const ::std::string& value);
  void set_machine(const char* value);
  void set_machine(const char* value, size_t size);
  ::std::string* mutable_machine();
  ::std::string* release_machine();
  void set_allocated_machine(::std::string* machine);

  // @@protoc_insertion_point(class_scope:perfetto.protos.Utsname)
 private:
  inline void set_has_sysname();
  inline void clear_has_sysname();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_release();
  inline void clear_has_release();
  inline void set_has_machine();
  inline void clear_has_machine();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr sysname_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr release_;
  ::google::protobuf::internal::ArenaStringPtr machine_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2ftrace_2fsystem_5finfo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2ftrace_2fsystem_5finfo_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2ftrace_2fsystem_5finfo_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2ftrace_2fsystem_5finfo_2eproto();

  void InitAsDefaultInstance();
  static Utsname* default_instance_;
};
// -------------------------------------------------------------------

class SystemInfo : public ::google::protobuf::MessageLite {
 public:
  SystemInfo();
  virtual ~SystemInfo();

  SystemInfo(const SystemInfo& from);

  inline SystemInfo& operator=(const SystemInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const SystemInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SystemInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SystemInfo* other);

  // implements Message ----------------------------------------------

  inline SystemInfo* New() const { return New(NULL); }

  SystemInfo* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SystemInfo& from);
  void MergeFrom(const SystemInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SystemInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .perfetto.protos.Utsname utsname = 1;
  bool has_utsname() const;
  void clear_utsname();
  static const int kUtsnameFieldNumber = 1;
  const ::perfetto::protos::Utsname& utsname() const;
  ::perfetto::protos::Utsname* mutable_utsname();
  ::perfetto::protos::Utsname* release_utsname();
  void set_allocated_utsname(::perfetto::protos::Utsname* utsname);

  // @@protoc_insertion_point(class_scope:perfetto.protos.SystemInfo)
 private:
  inline void set_has_utsname();
  inline void clear_has_utsname();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::perfetto::protos::Utsname* utsname_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2ftrace_2fsystem_5finfo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2ftrace_2fsystem_5finfo_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2ftrace_2fsystem_5finfo_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2ftrace_2fsystem_5finfo_2eproto();

  void InitAsDefaultInstance();
  static SystemInfo* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Utsname

// optional string sysname = 1;
inline bool Utsname::has_sysname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Utsname::set_has_sysname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Utsname::clear_has_sysname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Utsname::clear_sysname() {
  sysname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sysname();
}
inline const ::std::string& Utsname::sysname() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.Utsname.sysname)
  return sysname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Utsname::set_sysname(const ::std::string& value) {
  set_has_sysname();
  sysname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.Utsname.sysname)
}
inline void Utsname::set_sysname(const char* value) {
  set_has_sysname();
  sysname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.Utsname.sysname)
}
inline void Utsname::set_sysname(const char* value, size_t size) {
  set_has_sysname();
  sysname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.Utsname.sysname)
}
inline ::std::string* Utsname::mutable_sysname() {
  set_has_sysname();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.Utsname.sysname)
  return sysname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Utsname::release_sysname() {
  // @@protoc_insertion_point(field_release:perfetto.protos.Utsname.sysname)
  clear_has_sysname();
  return sysname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Utsname::set_allocated_sysname(::std::string* sysname) {
  if (sysname != NULL) {
    set_has_sysname();
  } else {
    clear_has_sysname();
  }
  sysname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sysname);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.Utsname.sysname)
}

// optional string version = 2;
inline bool Utsname::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Utsname::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Utsname::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Utsname::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_version();
}
inline const ::std::string& Utsname::version() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.Utsname.version)
  return version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Utsname::set_version(const ::std::string& value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.Utsname.version)
}
inline void Utsname::set_version(const char* value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.Utsname.version)
}
inline void Utsname::set_version(const char* value, size_t size) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.Utsname.version)
}
inline ::std::string* Utsname::mutable_version() {
  set_has_version();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.Utsname.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Utsname::release_version() {
  // @@protoc_insertion_point(field_release:perfetto.protos.Utsname.version)
  clear_has_version();
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Utsname::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.Utsname.version)
}

// optional string release = 3;
inline bool Utsname::has_release() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Utsname::set_has_release() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Utsname::clear_has_release() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Utsname::clear_release() {
  release_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_release();
}
inline const ::std::string& Utsname::release() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.Utsname.release)
  return release_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Utsname::set_release(const ::std::string& value) {
  set_has_release();
  release_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.Utsname.release)
}
inline void Utsname::set_release(const char* value) {
  set_has_release();
  release_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.Utsname.release)
}
inline void Utsname::set_release(const char* value, size_t size) {
  set_has_release();
  release_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.Utsname.release)
}
inline ::std::string* Utsname::mutable_release() {
  set_has_release();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.Utsname.release)
  return release_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Utsname::release_release() {
  // @@protoc_insertion_point(field_release:perfetto.protos.Utsname.release)
  clear_has_release();
  return release_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Utsname::set_allocated_release(::std::string* release) {
  if (release != NULL) {
    set_has_release();
  } else {
    clear_has_release();
  }
  release_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), release);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.Utsname.release)
}

// optional string machine = 4;
inline bool Utsname::has_machine() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Utsname::set_has_machine() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Utsname::clear_has_machine() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Utsname::clear_machine() {
  machine_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_machine();
}
inline const ::std::string& Utsname::machine() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.Utsname.machine)
  return machine_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Utsname::set_machine(const ::std::string& value) {
  set_has_machine();
  machine_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.Utsname.machine)
}
inline void Utsname::set_machine(const char* value) {
  set_has_machine();
  machine_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.Utsname.machine)
}
inline void Utsname::set_machine(const char* value, size_t size) {
  set_has_machine();
  machine_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.Utsname.machine)
}
inline ::std::string* Utsname::mutable_machine() {
  set_has_machine();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.Utsname.machine)
  return machine_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Utsname::release_machine() {
  // @@protoc_insertion_point(field_release:perfetto.protos.Utsname.machine)
  clear_has_machine();
  return machine_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Utsname::set_allocated_machine(::std::string* machine) {
  if (machine != NULL) {
    set_has_machine();
  } else {
    clear_has_machine();
  }
  machine_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), machine);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.Utsname.machine)
}

// -------------------------------------------------------------------

// SystemInfo

// optional .perfetto.protos.Utsname utsname = 1;
inline bool SystemInfo::has_utsname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SystemInfo::set_has_utsname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SystemInfo::clear_has_utsname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SystemInfo::clear_utsname() {
  if (utsname_ != NULL) utsname_->::perfetto::protos::Utsname::Clear();
  clear_has_utsname();
}
inline const ::perfetto::protos::Utsname& SystemInfo::utsname() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SystemInfo.utsname)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return utsname_ != NULL ? *utsname_ : *default_instance().utsname_;
#else
  return utsname_ != NULL ? *utsname_ : *default_instance_->utsname_;
#endif
}
inline ::perfetto::protos::Utsname* SystemInfo::mutable_utsname() {
  set_has_utsname();
  if (utsname_ == NULL) {
    utsname_ = new ::perfetto::protos::Utsname;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.SystemInfo.utsname)
  return utsname_;
}
inline ::perfetto::protos::Utsname* SystemInfo::release_utsname() {
  // @@protoc_insertion_point(field_release:perfetto.protos.SystemInfo.utsname)
  clear_has_utsname();
  ::perfetto::protos::Utsname* temp = utsname_;
  utsname_ = NULL;
  return temp;
}
inline void SystemInfo::set_allocated_utsname(::perfetto::protos::Utsname* utsname) {
  delete utsname_;
  utsname_ = utsname;
  if (utsname) {
    set_has_utsname();
  } else {
    clear_has_utsname();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.SystemInfo.utsname)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2ftrace_2fsystem_5finfo_2eproto__INCLUDED
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/trigger.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/trace/trigger.proto

#ifndef PROTOBUF_protos_2fperfetto_2ftrace_2ftrigger_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2ftrace_2ftrigger_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2ftrace_2ftrigger_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2ftrace_2ftrigger_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2ftrace_2ftrigger_2eproto();

class Trigger;

// ===================================================================

class Trigger : public ::google::protobuf::MessageLite {
 public:
  Trigger();
  virtual ~Trigger();

  Trigger(const Trigger& from);

  inline Trigger& operator=(const Trigger& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Trigger& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Trigger* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Trigger* other);

  // implements Message ----------------------------------------------

  inline Trigger* New() const { return New(NULL); }

  Trigger* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Trigger& from);
  void MergeFrom(const Trigger& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Trigger* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string trigger_name = 1;
  bool has_trigger_name() const;
  void clear_trigger_name();
  static const int kTriggerNameFieldNumber = 1;
  const ::std::string& trigger_name() const;
  void set_trigger_name(const ::std::string& value);
  void set_trigger_name(const char* value);
  void set_trigger_name(const char* value, size_t size);
  ::std::string* mutable_trigger_name();
  ::std::string* release_trigger_name();
  void set_allocated_trigger_name(::std::string* trigger_name);

  // optional string producer_name = 2;
  bool has_producer_name() const;
  void clear_producer_name();
  static const int kProducerNameFieldNumber = 2;
  const ::std::string& producer_name() const;
  void set_producer_name(const ::std::string& value);
  void set_producer_name(const char* value);
  void set_producer_name(const char* value, size_t size);
  ::std::string* mutable_producer_name();
  ::std::string* release_producer_name();
  void set_allocated_producer_name(::std::string* producer_name);

  // optional int32 trusted_producer_uid = 3;
  bool has_trusted_producer_uid() const;
  void clear_trusted_producer_uid();
  static const int kTrustedProducerUidFieldNumber = 3;
  ::google::protobuf::int32 trusted_producer_uid() const;
  void set_trusted_producer_uid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.Trigger)
 private:
  inline void set_has_trigger_name();
  inline void clear_has_trigger_name();
  inline void set_has_producer_name();
  inline void clear_has_producer_name();
  inline void set_has_trusted_producer_uid();
  inline void clear_has_trusted_producer_uid();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr trigger_name_;
  ::google::protobuf::internal::ArenaStringPtr producer_name_;
  ::google::protobuf::int32 trusted_producer_uid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2ftrace_2ftrigger_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2ftrace_2ftrigger_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2ftrace_2ftrigger_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2ftrace_2ftrigger_2eproto();

  void InitAsDefaultInstance();
  static Trigger* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Trigger

// optional string trigger_name = 1;
inline bool Trigger::has_trigger_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Trigger::set_has_trigger_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Trigger::clear_has_trigger_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Trigger::clear_trigger_name() {
  trigger_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_trigger_name();
}
inline const ::std::string& Trigger::trigger_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.Trigger.trigger_name)
  return trigger_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Trigger::set_trigger_name(const ::std::string& value) {
  set_has_trigger_name();
  trigger_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.Trigger.trigger_name)
}
inline void Trigger::set_trigger_name(const char* value) {
  set_has_trigger_name();
  trigger_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.Trigger.trigger_name)
}
inline void Trigger::set_trigger_name(const char* value, size_t size) {
  set_has_trigger_name();
  trigger_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.Trigger.trigger_name)
}
inline ::std::string* Trigger::mutable_trigger_name() {
  set_has_trigger_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.Trigger.trigger_name)
  return trigger_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Trigger::release_trigger_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.Trigger.trigger_name)
  clear_has_trigger_name();
  return trigger_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Trigger::set_allocated_trigger_name(::std::string* trigger_name) {
  if (trigger_name != NULL) {
    set_has_trigger_name();
  } else {
    clear_has_trigger_name();
  }
  trigger_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), trigger_name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.Trigger.trigger_name)
}

// optional string producer_name = 2;
inline bool Trigger::has_producer_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Trigger::set_has_producer_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Trigger::clear_has_producer_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Trigger::clear_producer_name() {
  producer_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_producer_name();
}
inline const ::std::string& Trigger::producer_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.Trigger.producer_name)
  return producer_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Trigger::set_producer_name(const ::std::string& value) {
  set_has_producer_name();
  producer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.Trigger.producer_name)
}
inline void Trigger::set_producer_name(const char* value) {
  set_has_producer_name();
  producer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.Trigger.producer_name)
}
inline void Trigger::set_producer_name(const char* value, size_t size) {
  set_has_producer_name();
  producer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.Trigger.producer_name)
}
inline ::std::string* Trigger::mutable_producer_name() {
  set_has_producer_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.Trigger.producer_name)
  return producer_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Trigger::release_producer_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.Trigger.producer_name)
  clear_has_producer_name();
  return producer_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Trigger::set_allocated_producer_name(::std::string* producer_name) {
  if (producer_name != NULL) {
    set_has_producer_name();
  } else {
    clear_has_producer_name();
  }
  producer_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), producer_name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.Trigger.producer_name)
}

// optional int32 trusted_producer_uid = 3;
inline bool Trigger::has_trusted_producer_uid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Trigger::set_has_trusted_producer_uid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Trigger::clear_has_trusted_producer_uid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Trigger::clear_trusted_producer_uid() {
  trusted_producer_uid_ = 0;
  clear_has_trusted_producer_uid();
}
inline ::google::protobuf::int32 Trigger::trusted_producer_uid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.Trigger.trusted_producer_uid)
  return trusted_producer_uid_;
}
inline void Trigger::set_trusted_producer_uid(::google::protobuf::int32 value) {
  set_has_trusted_producer_uid();
  trusted_producer_uid_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.Trigger.trusted_producer_uid)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2ftrace_2ftrigger_2eproto__INCLUDED
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/perfetto/trace/trusted_packet.proto

#ifndef PROTOBUF_protos_2fperfetto_2ftrace_2ftrusted_5fpacket_2eproto__INCLUDED
#define PROTOBUF_protos_2fperfetto_2ftrace_2ftrusted_5fpacket_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// gen_amalgamated expanded: #include "protos/perfetto/common/trace_stats.pb.h"
// gen_amalgamated expanded: #include "protos/perfetto/config/trace_config.pb.h"
// gen_amalgamated expanded: #include "protos/perfetto/trace/clock_snapshot.pb.h"
// gen_amalgamated expanded: #include "protos/perfetto/trace/system_info.pb.h"
// gen_amalgamated expanded: #include "protos/perfetto/trace/trigger.pb.h"
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protos_2fperfetto_2ftrace_2ftrusted_5fpacket_2eproto();
void protobuf_AssignDesc_protos_2fperfetto_2ftrace_2ftrusted_5fpacket_2eproto();
void protobuf_ShutdownFile_protos_2fperfetto_2ftrace_2ftrusted_5fpacket_2eproto();

class TrustedPacket;

// ===================================================================

class TrustedPacket : public ::google::protobuf::MessageLite {
 public:
  TrustedPacket();
  virtual ~TrustedPacket();

  TrustedPacket(const TrustedPacket& from);

  inline TrustedPacket& operator=(const TrustedPacket& from) {
    CopyFrom(from);
    return *this;
  }

  static const TrustedPacket& default_instance();

  enum OptionalTrustedUidCase {
    kTrustedUid = 3,
    OPTIONAL_TRUSTED_UID_NOT_SET = 0,
  };

  enum OptionalTrustedPacketSequenceIdCase {
    kTrustedPacketSequenceId = 10,
    OPTIONAL_TRUSTED_PACKET_SEQUENCE_ID_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TrustedPacket* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TrustedPacket* other);

  // implements Message ----------------------------------------------

  inline TrustedPacket* New() const { return New(NULL); }

  TrustedPacket* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TrustedPacket& from);
  void MergeFrom(const TrustedPacket& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TrustedPacket* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 trusted_uid = 3;
  private:
  bool has_trusted_uid() const;
  public:
  void clear_trusted_uid();
  static const int kTrustedUidFieldNumber = 3;
  ::google::protobuf::int32 trusted_uid() const;
  void set_trusted_uid(::google::protobuf::int32 value);

  // optional uint32 trusted_packet_sequence_id = 10;
  private:
  bool has_trusted_packet_sequence_id() const;
  public:
  void clear_trusted_packet_sequence_id();
  static const int kTrustedPacketSequenceIdFieldNumber = 10;
  ::google::protobuf::uint32 trusted_packet_sequence_id() const;
  void set_trusted_packet_sequence_id(::google::protobuf::uint32 value);

  // optional .perfetto.protos.ClockSnapshot clock_snapshot = 6;
  bool has_clock_snapshot() const;
  void clear_clock_snapshot();
  static const int kClockSnapshotFieldNumber = 6;
  const ::perfetto::protos::ClockSnapshot& clock_snapshot() const;
  ::perfetto::protos::ClockSnapshot* mutable_clock_snapshot();
  ::perfetto::protos::ClockSnapshot* release_clock_snapshot();
  void set_allocated_clock_snapshot(::perfetto::protos::ClockSnapshot* clock_snapshot);

  // optional uint64 timestamp = 8;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 8;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // optional .perfetto.protos.TraceConfig trace_config = 33;
  bool has_trace_config() const;
  void clear_trace_config();
  static const int kTraceConfigFieldNumber = 33;
  const ::perfetto::protos::TraceConfig& trace_config() const;
  ::perfetto::protos::TraceConfig* mutable_trace_config();
  ::perfetto::protos::TraceConfig* release_trace_config();
  void set_allocated_trace_config(::perfetto::protos::TraceConfig* trace_config);

  // optional .perfetto.protos.TraceStats trace_stats = 35;
  bool has_trace_stats() const;
  void clear_trace_stats();
  static const int kTraceStatsFieldNumber = 35;
  const ::perfetto::protos::TraceStats& trace_stats() const;
  ::perfetto::protos::TraceStats* mutable_trace_stats();
  ::perfetto::protos::TraceStats* release_trace_stats();
  void set_allocated_trace_stats(::perfetto::protos::TraceStats* trace_stats);

  // optional bytes synchronization_marker = 36;
  void clear_synchronization_marker();
  static const int kSynchronizationMarkerFieldNumber = 36;
  const ::std::string& synchronization_marker() const;
  void set_synchronization_marker(const ::std::string& value);
  void set_synchronization_marker(const char* value);
  void set_synchronization_marker(const void* value, size_t size);
  ::std::string* mutable_synchronization_marker();
  ::std::string* release_synchronization_marker();
  void set_allocated_synchronization_marker(::std::string* synchronization_marker);

  // optional bool previous_packet_dropped = 42;
  void clear_previous_packet_dropped();
  static const int kPreviousPacketDroppedFieldNumber = 42;
  bool previous_packet_dropped() const;
  void set_previous_packet_dropped(bool value);

  // optional .perfetto.protos.SystemInfo system_info = 45;
  bool has_system_info() const;
  void clear_system_info();
  static const int kSystemInfoFieldNumber = 45;
  const ::perfetto::protos::SystemInfo& system_info() const;
  ::perfetto::protos::SystemInfo* mutable_system_info();
  ::perfetto::protos::SystemInfo* release_system_info();
  void set_allocated_system_info(::perfetto::protos::SystemInfo* system_info);

  // optional .perfetto.protos.Trigger trigger = 46;
  bool has_trigger() const;
  void clear_trigger();
  static const int kTriggerFieldNumber = 46;
  const ::perfetto::protos::Trigger& trigger() const;
  ::perfetto::protos::Trigger* mutable_trigger();
  ::perfetto::protos::Trigger* release_trigger();
  void set_allocated_trigger(::perfetto::protos::Trigger* trigger);

  OptionalTrustedUidCase optional_trusted_uid_case() const;
  OptionalTrustedPacketSequenceIdCase optional_trusted_packet_sequence_id_case() const;
  // @@protoc_insertion_point(class_scope:perfetto.protos.TrustedPacket)
 private:
  inline void set_has_trusted_uid();
  inline void set_has_trusted_packet_sequence_id();

  inline bool has_optional_trusted_uid() const;
  void clear_optional_trusted_uid();
  inline void clear_has_optional_trusted_uid();

  inline bool has_optional_trusted_packet_sequence_id() const;
  void clear_optional_trusted_packet_sequence_id();
  inline void clear_has_optional_trusted_packet_sequence_id();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  bool _is_default_instance_;
  ::perfetto::protos::ClockSnapshot* clock_snapshot_;
  ::google::protobuf::uint64 timestamp_;
  ::perfetto::protos::TraceConfig* trace_config_;
  ::perfetto::protos::TraceStats* trace_stats_;
  ::google::protobuf::internal::ArenaStringPtr synchronization_marker_;
  ::perfetto::protos::SystemInfo* system_info_;
  ::perfetto::protos::Trigger* trigger_;
  bool previous_packet_dropped_;
  union OptionalTrustedUidUnion {
    OptionalTrustedUidUnion() {}
    ::google::protobuf::int32 trusted_uid_;
  } optional_trusted_uid_;
  union OptionalTrustedPacketSequenceIdUnion {
    OptionalTrustedPacketSequenceIdUnion() {}
    ::google::protobuf::uint32 trusted_packet_sequence_id_;
  } optional_trusted_packet_sequence_id_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[2];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protos_2fperfetto_2ftrace_2ftrusted_5fpacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protos_2fperfetto_2ftrace_2ftrusted_5fpacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_protos_2fperfetto_2ftrace_2ftrusted_5fpacket_2eproto();
  friend void protobuf_ShutdownFile_protos_2fperfetto_2ftrace_2ftrusted_5fpacket_2eproto();

  void InitAsDefaultInstance();
  static TrustedPacket* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// TrustedPacket

// optional int32 trusted_uid = 3;
inline bool TrustedPacket::has_trusted_uid() const {
  return optional_trusted_uid_case() == kTrustedUid;
}
inline void TrustedPacket::set_has_trusted_uid() {
  _oneof_case_[0] = kTrustedUid;
}
inline void TrustedPacket::clear_trusted_uid() {
  if (has_trusted_uid()) {
    optional_trusted_uid_.trusted_uid_ = 0;
    clear_has_optional_trusted_uid();
  }
}
inline ::google::protobuf::int32 TrustedPacket::trusted_uid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TrustedPacket.trusted_uid)
  if (has_trusted_uid()) {
    return optional_trusted_uid_.trusted_uid_;
  }
  return 0;
}
inline void TrustedPacket::set_trusted_uid(::google::protobuf::int32 value) {
  if (!has_trusted_uid()) {
    clear_optional_trusted_uid();
    set_has_trusted_uid();
  }
  optional_trusted_uid_.trusted_uid_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TrustedPacket.trusted_uid)
}

// optional uint32 trusted_packet_sequence_id = 10;
inline bool TrustedPacket::has_trusted_packet_sequence_id() const {
  return optional_trusted_packet_sequence_id_case() == kTrustedPacketSequenceId;
}
inline void TrustedPacket::set_has_trusted_packet_sequence_id() {
  _oneof_case_[1] = kTrustedPacketSequenceId;
}
inline void TrustedPacket::clear_trusted_packet_sequence_id() {
  if (has_trusted_packet_sequence_id()) {
    optional_trusted_packet_sequence_id_.trusted_packet_sequence_id_ = 0u;
    clear_has_optional_trusted_packet_sequence_id();
  }
}
inline ::google::protobuf::uint32 TrustedPacket::trusted_packet_sequence_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TrustedPacket.trusted_packet_sequence_id)
  if (has_trusted_packet_sequence_id()) {
    return optional_trusted_packet_sequence_id_.trusted_packet_sequence_id_;
  }
  return 0u;
}
inline void TrustedPacket::set_trusted_packet_sequence_id(::google::protobuf::uint32 value) {
  if (!has_trusted_packet_sequence_id()) {
    clear_optional_trusted_packet_sequence_id();
    set_has_trusted_packet_sequence_id();
  }
  optional_trusted_packet_sequence_id_.trusted_packet_sequence_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TrustedPacket.trusted_packet_sequence_id)
}

// optional .perfetto.protos.ClockSnapshot clock_snapshot = 6;
inline bool TrustedPacket::has_clock_snapshot() const {
  return !_is_default_instance_ && clock_snapshot_ != NULL;
}
inline void TrustedPacket::clear_clock_snapshot() {
  if (GetArenaNoVirtual() == NULL && clock_snapshot_ != NULL) delete clock_snapshot_;
  clock_snapshot_ = NULL;
}
inline const ::perfetto::protos::ClockSnapshot& TrustedPacket::clock_snapshot() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TrustedPacket.clock_snapshot)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return clock_snapshot_ != NULL ? *clock_snapshot_ : *default_instance().clock_snapshot_;
#else
  return clock_snapshot_ != NULL ? *clock_snapshot_ : *default_instance_->clock_snapshot_;
#endif
}
inline ::perfetto::protos::ClockSnapshot* TrustedPacket::mutable_clock_snapshot() {
  
  if (clock_snapshot_ == NULL) {
    clock_snapshot_ = new ::perfetto::protos::ClockSnapshot;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TrustedPacket.clock_snapshot)
  return clock_snapshot_;
}
inline ::perfetto::protos::ClockSnapshot* TrustedPacket::release_clock_snapshot() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TrustedPacket.clock_snapshot)
  
  ::perfetto::protos::ClockSnapshot* temp = clock_snapshot_;
  clock_snapshot_ = NULL;
  return temp;
}
inline void TrustedPacket::set_allocated_clock_snapshot(::perfetto::protos::ClockSnapshot* clock_snapshot) {
  delete clock_snapshot_;
  clock_snapshot_ = clock_snapshot;
  if (clock_snapshot) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TrustedPacket.clock_snapshot)
}

// optional uint64 timestamp = 8;
inline void TrustedPacket::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 TrustedPacket::timestamp() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TrustedPacket.timestamp)
  return timestamp_;
}
inline void TrustedPacket::set_timestamp(::google::protobuf::uint64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TrustedPacket.timestamp)
}

// optional .perfetto.protos.TraceConfig trace_config = 33;
inline bool TrustedPacket::has_trace_config() const {
  return !_is_default_instance_ && trace_config_ != NULL;
}
inline void TrustedPacket::clear_trace_config() {
  if (GetArenaNoVirtual() == NULL && trace_config_ != NULL) delete trace_config_;
  trace_config_ = NULL;
}
inline const ::perfetto::protos::TraceConfig& TrustedPacket::trace_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TrustedPacket.trace_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return trace_config_ != NULL ? *trace_config_ : *default_instance().trace_config_;
#else
  return trace_config_ != NULL ? *trace_config_ : *default_instance_->trace_config_;
#endif
}
inline ::perfetto::protos::TraceConfig* TrustedPacket::mutable_trace_config() {
  
  if (trace_config_ == NULL) {
    trace_config_ = new ::perfetto::protos::TraceConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TrustedPacket.trace_config)
  return trace_config_;
}
inline ::perfetto::protos::TraceConfig* TrustedPacket::release_trace_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TrustedPacket.trace_config)
  
  ::perfetto::protos::TraceConfig* temp = trace_config_;
  trace_config_ = NULL;
  return temp;
}
inline void TrustedPacket::set_allocated_trace_config(::perfetto::protos::TraceConfig* trace_config) {
  delete trace_config_;
  trace_config_ = trace_config;
  if (trace_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TrustedPacket.trace_config)
}

// optional .perfetto.protos.TraceStats trace_stats = 35;
inline bool TrustedPacket::has_trace_stats() const {
  return !_is_default_instance_ && trace_stats_ != NULL;
}
inline void TrustedPacket::clear_trace_stats() {
  if (GetArenaNoVirtual() == NULL && trace_stats_ != NULL) delete trace_stats_;
  trace_stats_ = NULL;
}
inline const ::perfetto::protos::TraceStats& TrustedPacket::trace_stats() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TrustedPacket.trace_stats)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return trace_stats_ != NULL ? *trace_stats_ : *default_instance().trace_stats_;
#else
  return trace_stats_ != NULL ? *trace_stats_ : *default_instance_->trace_stats_;
#endif
}
inline ::perfetto::protos::TraceStats* TrustedPacket::mutable_trace_stats() {
  
  if (trace_stats_ == NULL) {
    trace_stats_ = new ::perfetto::protos::TraceStats;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TrustedPacket.trace_stats)
  return trace_stats_;
}
inline ::perfetto::protos::TraceStats* TrustedPacket::release_trace_stats() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TrustedPacket.trace_stats)
  
  ::perfetto::protos::TraceStats* temp = trace_stats_;
  trace_stats_ = NULL;
  return temp;
}
inline void TrustedPacket::set_allocated_trace_stats(::perfetto::protos::TraceStats* trace_stats) {
  delete trace_stats_;
  trace_stats_ = trace_stats;
  if (trace_stats) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TrustedPacket.trace_stats)
}

// optional bytes synchronization_marker = 36;
inline void TrustedPacket::clear_synchronization_marker() {
  synchronization_marker_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TrustedPacket::synchronization_marker() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TrustedPacket.synchronization_marker)
  return synchronization_marker_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TrustedPacket::set_synchronization_marker(const ::std::string& value) {
  
  synchronization_marker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.TrustedPacket.synchronization_marker)
}
inline void TrustedPacket::set_synchronization_marker(const char* value) {
  
  synchronization_marker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.TrustedPacket.synchronization_marker)
}
inline void TrustedPacket::set_synchronization_marker(const void* value, size_t size) {
  
  synchronization_marker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.TrustedPacket.synchronization_marker)
}
inline ::std::string* TrustedPacket::mutable_synchronization_marker() {
  
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TrustedPacket.synchronization_marker)
  return synchronization_marker_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TrustedPacket::release_synchronization_marker() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TrustedPacket.synchronization_marker)
  
  return synchronization_marker_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TrustedPacket::set_allocated_synchronization_marker(::std::string* synchronization_marker) {
  if (synchronization_marker != NULL) {
    
  } else {
    
  }
  synchronization_marker_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), synchronization_marker);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TrustedPacket.synchronization_marker)
}

// optional bool previous_packet_dropped = 42;
inline void TrustedPacket::clear_previous_packet_dropped() {
  previous_packet_dropped_ = false;
}
inline bool TrustedPacket::previous_packet_dropped() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TrustedPacket.previous_packet_dropped)
  return previous_packet_dropped_;
}
inline void TrustedPacket::set_previous_packet_dropped(bool value) {
  
  previous_packet_dropped_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TrustedPacket.previous_packet_dropped)
}

// optional .perfetto.protos.SystemInfo system_info = 45;
inline bool TrustedPacket::has_system_info() const {
  return !_is_default_instance_ && system_info_ != NULL;
}
inline void TrustedPacket::clear_system_info() {
  if (GetArenaNoVirtual() == NULL && system_info_ != NULL) delete system_info_;
  system_info_ = NULL;
}
inline const ::perfetto::protos::SystemInfo& TrustedPacket::system_info() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TrustedPacket.system_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return system_info_ != NULL ? *system_info_ : *default_instance().system_info_;
#else
  return system_info_ != NULL ? *system_info_ : *default_instance_->system_info_;
#endif
}
inline ::perfetto::protos::SystemInfo* TrustedPacket::mutable_system_info() {
  
  if (system_info_ == NULL) {
    system_info_ = new ::perfetto::protos::SystemInfo;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TrustedPacket.system_info)
  return system_info_;
}
inline ::perfetto::protos::SystemInfo* TrustedPacket::release_system_info() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TrustedPacket.system_info)
  
  ::perfetto::protos::SystemInfo* temp = system_info_;
  system_info_ = NULL;
  return temp;
}
inline void TrustedPacket::set_allocated_system_info(::perfetto::protos::SystemInfo* system_info) {
  delete system_info_;
  system_info_ = system_info;
  if (system_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TrustedPacket.system_info)
}

// optional .perfetto.protos.Trigger trigger = 46;
inline bool TrustedPacket::has_trigger() const {
  return !_is_default_instance_ && trigger_ != NULL;
}
inline void TrustedPacket::clear_trigger() {
  if (GetArenaNoVirtual() == NULL && trigger_ != NULL) delete trigger_;
  trigger_ = NULL;
}
inline const ::perfetto::protos::Trigger& TrustedPacket::trigger() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TrustedPacket.trigger)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return trigger_ != NULL ? *trigger_ : *default_instance().trigger_;
#else
  return trigger_ != NULL ? *trigger_ : *default_instance_->trigger_;
#endif
}
inline ::perfetto::protos::Trigger* TrustedPacket::mutable_trigger() {
  
  if (trigger_ == NULL) {
    trigger_ = new ::perfetto::protos::Trigger;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TrustedPacket.trigger)
  return trigger_;
}
inline ::perfetto::protos::Trigger* TrustedPacket::release_trigger() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TrustedPacket.trigger)
  
  ::perfetto::protos::Trigger* temp = trigger_;
  trigger_ = NULL;
  return temp;
}
inline void TrustedPacket::set_allocated_trigger(::perfetto::protos::Trigger* trigger) {
  delete trigger_;
  trigger_ = trigger;
  if (trigger) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TrustedPacket.trigger)
}

inline bool TrustedPacket::has_optional_trusted_uid() const {
  return optional_trusted_uid_case() != OPTIONAL_TRUSTED_UID_NOT_SET;
}
inline void TrustedPacket::clear_has_optional_trusted_uid() {
  _oneof_case_[0] = OPTIONAL_TRUSTED_UID_NOT_SET;
}
inline bool TrustedPacket::has_optional_trusted_packet_sequence_id() const {
  return optional_trusted_packet_sequence_id_case() != OPTIONAL_TRUSTED_PACKET_SEQUENCE_ID_NOT_SET;
}
inline void TrustedPacket::clear_has_optional_trusted_packet_sequence_id() {
  _oneof_case_[1] = OPTIONAL_TRUSTED_PACKET_SEQUENCE_ID_NOT_SET;
}
inline TrustedPacket::OptionalTrustedUidCase TrustedPacket::optional_trusted_uid_case() const {
  return TrustedPacket::OptionalTrustedUidCase(_oneof_case_[0]);
}
inline TrustedPacket::OptionalTrustedPacketSequenceIdCase TrustedPacket::optional_trusted_packet_sequence_id_case() const {
  return TrustedPacket::OptionalTrustedPacketSequenceIdCase(_oneof_case_[1]);
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protos_2fperfetto_2ftrace_2ftrusted_5fpacket_2eproto__INCLUDED
// gen_amalgamated begin header: include/perfetto/protozero/contiguous_memory_range.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_PROTOZERO_CONTIGUOUS_MEMORY_RANGE_H_
#define INCLUDE_PERFETTO_PROTOZERO_CONTIGUOUS_MEMORY_RANGE_H_

#include <assert.h>
#include <stddef.h>
#include <stdint.h>

namespace protozero {

// Keep this struct trivially constructible (no ctors, no default initializers).
struct ContiguousMemoryRange {
  uint8_t* begin;
  uint8_t* end;  // STL style: one byte past the end of the buffer.

  inline bool is_valid() const { return begin != nullptr; }
  inline void reset() { begin = nullptr; }
  inline size_t size() { return static_cast<size_t>(end - begin); }
};

}  // namespace protozero

#endif  // INCLUDE_PERFETTO_PROTOZERO_CONTIGUOUS_MEMORY_RANGE_H_
// gen_amalgamated begin header: include/perfetto/protozero/field.h
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_PROTOZERO_FIELD_H_
#define INCLUDE_PERFETTO_PROTOZERO_FIELD_H_

#include <stdint.h>

#include <string>

// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/protozero/contiguous_memory_range.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace protozero {

struct ConstBytes {
  const uint8_t* data;
  size_t size;
};

struct ConstChars {
  // Allow implicit conversion to perfetto's base::StringView without depending
  // on perfetto/base or viceversa.
  static constexpr bool kConvertibleToStringView = true;
  std::string ToStdString() const { return std::string(data, size); }

  const char* data;
  size_t size;
};

// A protobuf field decoded by the protozero proto decoders. It exposes
// convenience accessors with minimal debug checks.
// This class is used both by the iterator-based ProtoDecoder and by the
// one-shot TypedProtoDecoder.
// If the field is not valid the accessors consistently return zero-integers or
// null strings.
class Field {
 public:
  inline bool valid() const { return id_ != 0; }
  inline uint16_t id() const { return id_; }
  explicit inline operator bool() const { return valid(); }

  inline proto_utils::ProtoWireType type() const {
    auto res = static_cast<proto_utils::ProtoWireType>(type_);
    PERFETTO_DCHECK(res == proto_utils::ProtoWireType::kVarInt ||
                    res == proto_utils::ProtoWireType::kLengthDelimited ||
                    res == proto_utils::ProtoWireType::kFixed32 ||
                    res == proto_utils::ProtoWireType::kFixed64);
    return res;
  }

  inline bool as_bool() const {
    PERFETTO_DCHECK(!valid() || type() == proto_utils::ProtoWireType::kVarInt);
    return static_cast<bool>(int_value_);
  }

  inline uint32_t as_uint32() const {
    PERFETTO_DCHECK(!valid() || type() == proto_utils::ProtoWireType::kVarInt ||
                    type() == proto_utils::ProtoWireType::kFixed32);
    return static_cast<uint32_t>(int_value_);
  }

  inline int32_t as_int32() const {
    PERFETTO_DCHECK(!valid() || type() == proto_utils::ProtoWireType::kVarInt ||
                    type() == proto_utils::ProtoWireType::kFixed32);
    return static_cast<int32_t>(int_value_);
  }

  inline uint64_t as_uint64() const {
    PERFETTO_DCHECK(!valid() || type() == proto_utils::ProtoWireType::kVarInt ||
                    type() == proto_utils::ProtoWireType::kFixed32 ||
                    type() == proto_utils::ProtoWireType::kFixed64);
    return int_value_;
  }

  inline int64_t as_int64() const {
    PERFETTO_DCHECK(!valid() || type() == proto_utils::ProtoWireType::kVarInt ||
                    type() == proto_utils::ProtoWireType::kFixed32 ||
                    type() == proto_utils::ProtoWireType::kFixed64);
    return static_cast<int64_t>(int_value_);
  }

  inline float as_float() const {
    PERFETTO_DCHECK(!valid() || type() == proto_utils::ProtoWireType::kFixed32);
    float res;
    uint32_t value32 = static_cast<uint32_t>(int_value_);
    memcpy(&res, &value32, sizeof(res));
    return res;
  }

  inline double as_double() const {
    PERFETTO_DCHECK(!valid() || type() == proto_utils::ProtoWireType::kFixed64);
    double res;
    memcpy(&res, &int_value_, sizeof(res));
    return res;
  }

  inline ConstChars as_string() const {
    PERFETTO_DCHECK(!valid() ||
                    type() == proto_utils::ProtoWireType::kLengthDelimited);
    return ConstChars{reinterpret_cast<const char*>(data()), size_};
  }

  inline std::string as_std_string() const { return as_string().ToStdString(); }

  inline ConstBytes as_bytes() const {
    PERFETTO_DCHECK(!valid() ||
                    type() == proto_utils::ProtoWireType::kLengthDelimited);
    return ConstBytes{data(), size_};
  }

  inline const uint8_t* data() const {
    PERFETTO_DCHECK(!valid() ||
                    type() == proto_utils::ProtoWireType::kLengthDelimited);
    return reinterpret_cast<const uint8_t*>(int_value_);
  }

  inline size_t size() const {
    PERFETTO_DCHECK(!valid() ||
                    type() == proto_utils::ProtoWireType::kLengthDelimited);
    return size_;
  }

  inline uint64_t raw_int_value() const { return int_value_; }

  inline void initialize(uint16_t id,
                         uint8_t type,
                         uint64_t int_value,
                         uint32_t size) {
    id_ = id;
    type_ = type;
    int_value_ = int_value;
    size_ = size;
  }

 private:
  // Fields are deliberately not initialized to keep the class trivially
  // constructible. It makes a large perf difference for ProtoDecoder.

  uint64_t int_value_;  // In kLengthDelimited this contains the data() addr.
  uint32_t size_;       // Only valid when when type == kLengthDelimited.
  uint16_t id_;         // Proto field ordinal.
  uint8_t type_;        // proto_utils::ProtoWireType.
};

// The Field struct is used in a lot of perf-sensitive contexts.
static_assert(sizeof(Field) == 16, "Field struct too big");

}  // namespace protozero

#endif  // INCLUDE_PERFETTO_PROTOZERO_FIELD_H_
// gen_amalgamated begin header: include/perfetto/protozero/message.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_PROTOZERO_MESSAGE_H_
#define INCLUDE_PERFETTO_PROTOZERO_MESSAGE_H_

#include <assert.h>
#include <stdint.h>
#include <string.h>

#include <type_traits>

// gen_amalgamated expanded: #include "perfetto/base/export.h"
// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/protozero/contiguous_memory_range.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"
// gen_amalgamated expanded: #include "perfetto/protozero/scattered_stream_writer.h"

namespace perfetto {
namespace shm_fuzz {
class FakeProducer;
}  // namespace shm_fuzz
}  // namespace perfetto

namespace protozero {

class MessageHandleBase;

// Base class extended by the proto C++ stubs generated by the ProtoZero
// compiler. This class provides the minimal runtime required to support
// append-only operations and is designed for performance. None of the methods
// require any dynamic memory allocation.
class PERFETTO_EXPORT Message {
 public:
  friend class MessageHandleBase;

  // Adjust the |nested_messages_arena_| size when changing this, or the
  // static_assert in the .cc file will bark.
  static constexpr uint32_t kMaxNestingDepth = 10;

  // Ctor and Dtor of Message are never called, with the exeception
  // of root (non-nested) messages. Nested messages are allocated via placement
  // new in the |nested_messages_arena_| and implictly destroyed when the arena
  // of the root message goes away. This is fine as long as all the fields are
  // PODs, which is checked by the static_assert in the ctor (see the Reset()
  // method in the .cc file).
  Message() = default;

  // Clears up the state, allowing the message to be reused as a fresh one.
  void Reset(ScatteredStreamWriter*);

  // Commits all the changes to the buffer (backfills the size field of this and
  // all nested messages) and seals the message. Returns the size of the message
  // (and all nested sub-messages), without taking into account any chunking.
  // Finalize is idempotent and can be called several times w/o side effects.
  uint32_t Finalize();

  // Optional. If is_valid() == true, the corresponding memory region (its
  // length == proto_utils::kMessageLengthFieldSize) is backfilled with the size
  // of this message (minus |size_already_written| below). This is the mechanism
  // used by messages to backfill their corresponding size field in the parent
  // message.
  uint8_t* size_field() const { return size_field_; }
  void set_size_field(uint8_t* size_field) { size_field_ = size_field; }

  // This is to deal with case of backfilling the size of a root (non-nested)
  // message which is split into multiple chunks. Upon finalization only the
  // partial size that lies in the last chunk has to be backfilled.
  void inc_size_already_written(uint32_t sz) { size_already_written_ += sz; }

  Message* nested_message() { return nested_message_; }

  bool is_finalized() const { return finalized_; }

#if PERFETTO_DCHECK_IS_ON()
  void set_handle(MessageHandleBase* handle) { handle_ = handle; }
#endif

  // Proto types: uint64, uint32, int64, int32, bool, enum.
  template <typename T>
  void AppendVarInt(uint32_t field_id, T value) {
    if (nested_message_)
      EndNestedMessage();

    uint8_t buffer[proto_utils::kMaxSimpleFieldEncodedSize];
    uint8_t* pos = buffer;

    pos = proto_utils::WriteVarInt(proto_utils::MakeTagVarInt(field_id), pos);
    // WriteVarInt encodes signed values in two's complement form.
    pos = proto_utils::WriteVarInt(value, pos);
    WriteToStream(buffer, pos);
  }

  // Proto types: sint64, sint32.
  template <typename T>
  void AppendSignedVarInt(uint32_t field_id, T value) {
    AppendVarInt(field_id, proto_utils::ZigZagEncode(value));
  }

  // Proto types: bool, enum (small).
  // Faster version of AppendVarInt for tiny numbers.
  void AppendTinyVarInt(uint32_t field_id, int32_t value) {
    PERFETTO_DCHECK(0 <= value && value < 0x80);
    if (nested_message_)
      EndNestedMessage();

    uint8_t buffer[proto_utils::kMaxSimpleFieldEncodedSize];
    uint8_t* pos = buffer;
    // MakeTagVarInt gets super optimized here for constexpr.
    pos = proto_utils::WriteVarInt(proto_utils::MakeTagVarInt(field_id), pos);
    *pos++ = static_cast<uint8_t>(value);
    WriteToStream(buffer, pos);
  }

  // Proto types: fixed64, sfixed64, fixed32, sfixed32, double, float.
  template <typename T>
  void AppendFixed(uint32_t field_id, T value) {
    if (nested_message_)
      EndNestedMessage();

    uint8_t buffer[proto_utils::kMaxSimpleFieldEncodedSize];
    uint8_t* pos = buffer;

    pos = proto_utils::WriteVarInt(proto_utils::MakeTagFixed<T>(field_id), pos);
    memcpy(pos, &value, sizeof(T));
    pos += sizeof(T);
    // TODO: Optimize memcpy performance, see http://crbug.com/624311 .
    WriteToStream(buffer, pos);
  }

  void AppendString(uint32_t field_id, const char* str);
  void AppendBytes(uint32_t field_id, const void* value, size_t size);

  // Append raw bytes for a field, using the supplied |ranges| to
  // copy from |num_ranges| individual buffers.
  size_t AppendScatteredBytes(uint32_t field_id,
                              ContiguousMemoryRange* ranges,
                              size_t num_ranges);

  // Begins a nested message, using the static storage provided by the parent
  // class (see comment in |nested_messages_arena_|). The nested message ends
  // either when Finalize() is called or when any other Append* method is called
  // in the parent class.
  // The template argument T is supposed to be a stub class auto generated from
  // a .proto, hence a subclass of Message.
  template <class T>
  T* BeginNestedMessage(uint32_t field_id) {
    // This is to prevent subclasses (which should be autogenerated, though), to
    // introduce extra state fields (which wouldn't be initialized by Reset()).
    static_assert(std::is_base_of<Message, T>::value,
                  "T must be a subclass of Message");
    static_assert(sizeof(T) == sizeof(Message),
                  "Message subclasses cannot introduce extra state.");
    T* message = reinterpret_cast<T*>(nested_messages_arena_);
    BeginNestedMessageInternal(field_id, message);
    return message;
  }

  ScatteredStreamWriter* stream_writer_for_testing() { return stream_writer_; }

 private:
  Message(const Message&) = delete;
  Message& operator=(const Message&) = delete;

  void BeginNestedMessageInternal(uint32_t field_id, Message*);

  // Called by Finalize and Append* methods.
  void EndNestedMessage();

  void WriteToStream(const uint8_t* src_begin, const uint8_t* src_end) {
    PERFETTO_DCHECK(!finalized_);
    PERFETTO_DCHECK(src_begin <= src_end);
    const uint32_t size = static_cast<uint32_t>(src_end - src_begin);
    stream_writer_->WriteBytes(src_begin, size);
    size_ += size;
  }

  // Only POD fields are allowed. This class's dtor is never called.
  // See the comment on the static_assert in the corresponding .cc file.

  // The stream writer interface used for the serialization.
  ScatteredStreamWriter* stream_writer_;

  uint8_t* size_field_;

  // Keeps track of the size of the current message.
  uint32_t size_;

  // See comment for inc_size_already_written().
  uint32_t size_already_written_;

  // When true, no more changes to the message are allowed. This is to DCHECK
  // attempts of writing to a message which has been Finalize()-d.
  bool finalized_;

  // Used to detect attemps to create messages with a nesting level >
  // kMaxNestingDepth. |nesting_depth_| == 0 for root (non-nested) messages.
  uint8_t nesting_depth_;

#if PERFETTO_DCHECK_IS_ON()
  // Current generation of message. Incremented on Reset.
  // Used to detect stale handles.
  uint32_t generation_;

  MessageHandleBase* handle_;
#endif

  // Pointer to the last child message created through BeginNestedMessage(), if
  // any, nullptr otherwise. There is no need to keep track of more than one
  // message per nesting level as the proto-zero API contract mandates that
  // nested fields can be filled only in a stacked fashion. In other words,
  // nested messages are finalized and sealed when any other field is set in the
  // parent message (or the parent message itself is finalized) and cannot be
  // accessed anymore afterwards.
  // TODO(primiano): optimization: I think that nested_message_, when non-null.
  // will always be @ (this) + offsetof(nested_messages_arena_).
  Message* nested_message_;

  // The root message owns the storage for all its nested messages, up to a max
  // of kMaxNestingDepth levels (see the .cc file). Note that the boundaries of
  // the arena are meaningful only for the root message.
  // Unfortunately we cannot put the sizeof() math here because we cannot sizeof
  // the current class in a header. However the .cc file has a static_assert
  // that guarantees that (see the Reset() method in the .cc file).
  alignas(sizeof(void*)) uint8_t nested_messages_arena_[512];

  // DO NOT add any fields below |nested_messages_arena_|. The memory layout of
  // nested messages would overflow the storage allocated by the root message.
};

}  // namespace protozero

#endif  // INCLUDE_PERFETTO_PROTOZERO_MESSAGE_H_
// gen_amalgamated begin header: include/perfetto/protozero/message_handle.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_PROTOZERO_MESSAGE_HANDLE_H_
#define INCLUDE_PERFETTO_PROTOZERO_MESSAGE_HANDLE_H_

#include <functional>

// gen_amalgamated expanded: #include "perfetto/base/export.h"
// gen_amalgamated expanded: #include "perfetto/protozero/message.h"

namespace protozero {

class Message;

// MessageHandle allows to decouple the lifetime of a proto message
// from the underlying storage. It gives the following guarantees:
// - The underlying message is finalized (if still alive) if the handle goes
//   out of scope.
// - In Debug / DCHECK_ALWAYS_ON builds, the handle becomes null once the
//   message is finalized. This is to enforce the append-only API. For instance
//   when adding two repeated messages, the addition of the 2nd one forces
//   the finalization of the first.
// Think about this as a WeakPtr<Message> which calls
// Message::Finalize() when going out of scope.

class PERFETTO_EXPORT MessageHandleBase {
 public:
  class FinalizationListener {
   public:
    virtual ~FinalizationListener();
    virtual void OnMessageFinalized(Message* message) = 0;
  };

  ~MessageHandleBase();

  // Move-only type.
  MessageHandleBase(MessageHandleBase&&) noexcept;
  MessageHandleBase& operator=(MessageHandleBase&&);
  explicit operator bool() const {
#if PERFETTO_DCHECK_IS_ON()
    PERFETTO_DCHECK(!message_ || generation_ == message_->generation_);
#endif
    return !!message_;
  }

  void set_finalization_listener(FinalizationListener* listener) {
    listener_ = listener;
  }

 protected:
  explicit MessageHandleBase(Message* = nullptr);
  Message* operator->() const {
#if PERFETTO_DCHECK_IS_ON()
    PERFETTO_DCHECK(!message_ || generation_ == message_->generation_);
#endif
    return message_;
  }
  Message& operator*() const { return *(operator->()); }

 private:
  friend class Message;
  MessageHandleBase(const MessageHandleBase&) = delete;
  MessageHandleBase& operator=(const MessageHandleBase&) = delete;

  void reset_message() {
    // This is called by Message::Finalize().
    PERFETTO_DCHECK(message_->is_finalized());
    message_ = nullptr;
    listener_ = nullptr;
  }

  void Move(MessageHandleBase&&);

  void FinalizeMessage() {
    // |message_| and |listener_| may be cleared by reset_message() during
    // Message::Finalize().
    auto* listener = listener_;
    auto* message = message_;
    message->Finalize();
    if (listener)
      listener->OnMessageFinalized(message);
  }

  Message* message_;
  FinalizationListener* listener_ = nullptr;
#if PERFETTO_DCHECK_IS_ON()
  uint32_t generation_;
#endif
};

template <typename T>
class MessageHandle : public MessageHandleBase {
 public:
  MessageHandle() : MessageHandle(nullptr) {}
  explicit MessageHandle(T* message) : MessageHandleBase(message) {}

  T& operator*() const {
    return static_cast<T&>(MessageHandleBase::operator*());
  }

  T* operator->() const {
    return static_cast<T*>(MessageHandleBase::operator->());
  }
};

}  // namespace protozero

#endif  // INCLUDE_PERFETTO_PROTOZERO_MESSAGE_HANDLE_H_
// gen_amalgamated begin header: include/perfetto/protozero/packed_repeated_fields.h
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_PROTOZERO_PACKED_REPEATED_FIELDS_H_
#define INCLUDE_PERFETTO_PROTOZERO_PACKED_REPEATED_FIELDS_H_

#include <stdint.h>

#include <array>

// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace protozero {

// This file contains classes used when encoding packed repeated fields.
// To encode such a field, the caller is first expected to accumulate all of the
// values in one of the following types (depending on the wire type of the
// individual elements), defined below:
// * protozero::PackedVarIntBuffer
// * protozero::PackedFixedSizeBuffer</*element_type=*/ uint32_t>
// Then that buffer is passed to the protozero-generated setters as an argument.
// After calling the setter, the buffer can be destroyed.
//
// The buffer classes by themselves do not own the raw memory used to hold the
// accumulated values, so they need to be instantiated via a subclass that
// implements the storage. This file provides one such type, StackAllocated, for
// buffering the values using the stack.
//
// An example of encoding a packed field:
//   protozero::HeapBuffered<protozero::Message> msg;
//   // stack buffer holding up to 128 varints
//   protozero::StackAllocated<protozero::PackedVarIntBuffer, 128> buf;
//   buf.Append(42);
//   buf.Append(-1);
//   msg->set_fieldname(buf);
//   msg.SerializeAsString();
class PackedVarIntBuffer {
 public:
  // worst case encoded size per varint
  using StorageElementType = std::array<uint8_t, 10>;

  template <typename T>
  void Append(T value) {
    PERFETTO_CHECK(++element_size_ <= element_capacity_);
    write_ptr_ = proto_utils::WriteVarInt(value, write_ptr_);
  }

  const uint8_t* data() const { return storage_begin_; }

  size_t size() const {
    return static_cast<size_t>(write_ptr_ - storage_begin_);
  }

 protected:
  PackedVarIntBuffer(StorageElementType* storage, size_t storage_capacity)
      : storage_begin_(reinterpret_cast<uint8_t*>(storage)),
        write_ptr_(reinterpret_cast<uint8_t*>(storage)),
        element_capacity_(storage_capacity) {}

 private:
  // Storage will consist of an array of StorageElementType, but we treat it as
  // a contiguous uint8_t buffer. Note that the varints will not be aligned with
  // StorageElementType boundaries.
  uint8_t* const storage_begin_;
  uint8_t* write_ptr_;

  size_t element_size_ = 0;
  const size_t element_capacity_;
};

template <typename ElementType>
class PackedFixedSizeBuffer {
 public:
  // The template type parameter is the same as the storage type, so one
  // of the type names is used in all places for consistency.
  using StorageElementType = ElementType;

  void Append(StorageElementType value) {
    PERFETTO_CHECK(write_ptr_ < storage_end_);
    *(write_ptr_++) = value;
  }

  const uint8_t* data() const {
    return reinterpret_cast<const uint8_t*>(storage_begin_);
  }

  size_t size() const {
    return static_cast<size_t>(reinterpret_cast<uint8_t*>(write_ptr_) -
                               reinterpret_cast<uint8_t*>(storage_begin_));
  }

 protected:
  PackedFixedSizeBuffer(StorageElementType* storage,
                        size_t max_storage_elements)
      : storage_begin_(storage),
        storage_end_(storage + max_storage_elements),
        write_ptr_(storage) {
    static_assert(
        sizeof(StorageElementType) == 4 || sizeof(StorageElementType) == 8,
        "invalid type width");
  }

 private:
  StorageElementType* const storage_begin_;
  StorageElementType* const storage_end_;
  StorageElementType* write_ptr_;
};

template <typename PackedBuffer, size_t MaxNumElements>
class StackAllocated : public PackedBuffer {
 public:
  StackAllocated() : PackedBuffer(storage_, MaxNumElements) {}

 private:
  typename PackedBuffer::StorageElementType storage_[MaxNumElements];
};

}  // namespace protozero

#endif  // INCLUDE_PERFETTO_PROTOZERO_PACKED_REPEATED_FIELDS_H_
// gen_amalgamated begin header: include/perfetto/protozero/proto_decoder.h
/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_PROTOZERO_PROTO_DECODER_H_
#define INCLUDE_PERFETTO_PROTOZERO_PROTO_DECODER_H_

#include <stdint.h>
#include <array>
#include <memory>
#include <vector>

// gen_amalgamated expanded: #include "perfetto/base/compiler.h"
// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/protozero/field.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace protozero {

// A generic protobuf decoder. Doesn't require any knowledge about the proto
// schema. It tokenizes fields, retrieves their ID and type and exposes
// accessors to retrieve its values.
// It does NOT recurse in nested submessages, instead it just computes their
// boundaries, recursion is left to the caller.
// This class is designed to be used in perf-sensitive contexts. It does not
// allocate and does not perform any proto semantic checks (e.g. repeated /
// required / optional). It's supposedly safe wrt out-of-bounds memory accesses
// (see proto_decoder_fuzzer.cc).
// This class serves also as a building block for TypedProtoDecoder, used when
// the schema is known at compile time.
class ProtoDecoder {
 public:
  // Creates a ProtoDecoder using the given |buffer| with size |length| bytes.
  inline ProtoDecoder(const uint8_t* buffer, size_t length)
      : begin_(buffer), end_(buffer + length), read_ptr_(buffer) {}

  // Reads the next field from the buffer and advances the read cursor. If a
  // full field cannot be read, the returned Field will be invalid (i.e.
  // field.valid() == false).
  Field ReadField();

  // Finds the first field with the given id. Doesn't affect the read cursor.
  Field FindField(uint32_t field_id);

  // Resets the read cursor to the start of the buffer.
  inline void Reset() { read_ptr_ = begin_; }

  // Resets the read cursor to the given position (must be within the buffer).
  inline void Reset(const uint8_t* pos) {
    PERFETTO_DCHECK(pos >= begin_ && pos < end_);
    read_ptr_ = pos;
  }

  // Returns the position of read cursor, relative to the start of the buffer.
  inline size_t read_offset() const {
    return static_cast<size_t>(read_ptr_ - begin_);
  }

  inline size_t bytes_left() const {
    PERFETTO_DCHECK(read_ptr_ <= end_);
    return static_cast<size_t>(end_ - read_ptr_);
  }

  const uint8_t* begin() const { return begin_; }
  const uint8_t* end() const { return end_; }

 protected:
  const uint8_t* const begin_;
  const uint8_t* const end_;
  const uint8_t* read_ptr_ = nullptr;
};

// An iterator-like class used to iterate through repeated fields. Used by
// TypedProtoDecoder. The iteration sequence is a bit counter-intuitive due to
// the fact that fields_[field_id] holds the *last* value of the field, not the
// first, but the remaining storage holds repeated fields in FIFO order.
// Assume that we push the 10,11,12 into a repeated field with ID=1.
//
// Decoder memory layout:  [  fields storage  ] [ repeated fields storage ]
// 1st iteration:           10
// 2nd iteration:           11                   10
// 3rd iteration:           12                   10 11
//
// We start the iteration @ fields_[num_fields], which is the start of the
// repeated fields storage, proceed until the end and lastly jump @ fields_[id].
class RepeatedFieldIterator {
 public:
  RepeatedFieldIterator(uint32_t field_id,
                        const Field* begin,
                        const Field* end,
                        const Field* last)
      : field_id_(field_id), iter_(begin), end_(end), last_(last) {
    FindNextMatchingId();
  }

  inline const Field* operator->() const { return &*iter_; }
  inline const Field& operator*() const { return *iter_; }
  inline explicit operator bool() const { return iter_ != end_; }

  RepeatedFieldIterator& operator++() {
    PERFETTO_DCHECK(iter_ != end_);
    if (iter_ == last_) {
      iter_ = end_;
      return *this;
    }
    ++iter_;
    FindNextMatchingId();
    return *this;
  }

  RepeatedFieldIterator operator++(int) {
    PERFETTO_DCHECK(iter_ != end_);
    RepeatedFieldIterator it(*this);
    ++(*this);
    return it;
  }

 private:
  inline void FindNextMatchingId() {
    PERFETTO_DCHECK(iter_ != last_);
    for (; iter_ != end_; ++iter_) {
      if (iter_->id() == field_id_)
        return;
    }
    iter_ = last_->valid() ? last_ : end_;
  }

  uint32_t field_id_;

  // Initially points to the beginning of the repeated field storage, then is
  // incremented as we call operator++().
  const Field* iter_;

  // Always points to fields_[size_], i.e. past the end of the storage.
  const Field* end_;

  // Always points to fields_[field_id].
  const Field* last_;
};

// As RepeatedFieldIterator, but allows iterating over a packed repeated field
// (which will be initially stored as a single length-delimited field).
// See |GetPackedRepeatedField| for details.
//
// Assumes little endianness, and that the input buffers are well formed -
// containing an exact multiple of encoded elements.
template <proto_utils::ProtoWireType wire_type, typename CppType>
class PackedRepeatedFieldIterator {
 public:
  PackedRepeatedFieldIterator(const uint8_t* data_begin,
                              size_t size,
                              bool* parse_error_ptr)
      : data_end_(data_begin ? data_begin + size : nullptr),
        read_ptr_(data_begin),
        parse_error_(parse_error_ptr) {
    using proto_utils::ProtoWireType;
    static_assert(wire_type == ProtoWireType::kVarInt ||
                      wire_type == ProtoWireType::kFixed32 ||
                      wire_type == ProtoWireType::kFixed64,
                  "invalid type");

    PERFETTO_DCHECK(parse_error_ptr);

    // Either the field is unset (and there are no data pointer), or the field
    // is set with a zero length payload. Mark the iterator as invalid in both
    // cases.
    if (size == 0) {
      curr_value_valid_ = false;
      return;
    }

    if ((wire_type == ProtoWireType::kFixed32 && (size % 4) != 0) ||
        (wire_type == ProtoWireType::kFixed64 && (size % 8) != 0)) {
      *parse_error_ = true;
      curr_value_valid_ = false;
      return;
    }

    ++(*this);
  }

  inline const CppType operator*() const { return curr_value_; }
  inline explicit operator bool() const { return curr_value_valid_; }

  PackedRepeatedFieldIterator& operator++() {
    using proto_utils::ProtoWireType;

    if (PERFETTO_UNLIKELY(!curr_value_valid_))
      return *this;

    if (PERFETTO_UNLIKELY(read_ptr_ == data_end_)) {
      curr_value_valid_ = false;
      return *this;
    }

    if (wire_type == ProtoWireType::kVarInt) {
      uint64_t new_value = 0;
      const uint8_t* new_pos =
          proto_utils::ParseVarInt(read_ptr_, data_end_, &new_value);

      if (PERFETTO_UNLIKELY(new_pos == read_ptr_)) {
        // Failed to decode the varint (probably incomplete buffer).
        *parse_error_ = true;
        curr_value_valid_ = false;
      } else {
        read_ptr_ = new_pos;
        curr_value_ = static_cast<CppType>(new_value);
      }
    } else {  // kFixed32 or kFixed64
      constexpr size_t kStep = wire_type == ProtoWireType::kFixed32 ? 4 : 8;

      // NB: the raw buffer is not guaranteed to be aligned, so neither are
      // these copies.
      memcpy(&curr_value_, read_ptr_, sizeof(CppType));
      read_ptr_ += kStep;
    }

    return *this;
  }

  PackedRepeatedFieldIterator operator++(int) {
    PackedRepeatedFieldIterator it(*this);
    ++(*this);
    return it;
  }

 private:
  // Might be null if the backing proto field isn't set.
  const uint8_t* const data_end_;

  // The iterator looks ahead by an element, so |curr_value| holds the value
  // to be returned when the caller dereferences the iterator, and |read_ptr_|
  // points at the start of the next element to be decoded.
  // |read_ptr_| might be null if the backing proto field isn't set.
  const uint8_t* read_ptr_;
  CppType curr_value_ = 0;

  // Set to false once we've exhausted the iterator, or encountered an error.
  bool curr_value_valid_ = true;

  // Where to set parsing errors, supplied by the caller.
  bool* const parse_error_;
};

// This decoder loads all fields upfront, without recursing in nested messages.
// It is used as a base class for typed decoders generated by the pbzero plugin.
// The split between TypedProtoDecoderBase and TypedProtoDecoder<> is to have
// unique definition of functions like ParseAllFields() and ExpandHeapStorage().
// The storage (either on-stack or on-heap) for this class is organized as
// follows:
// |-------------------------- fields_ ----------------------|
// [ field 0 (invalid) ] [ fields 1 .. N ] [ repeated fields ]
//                                        ^                  ^
//                                        num_fields_        size_
class TypedProtoDecoderBase : public ProtoDecoder {
 public:
  // If the field |id| is known at compile time, prefer the templated
  // specialization at<kFieldNumber>().
  inline const Field& Get(uint32_t id) const {
    return PERFETTO_LIKELY(id < num_fields_) ? fields_[id] : fields_[0];
  }

  // Returns an object that allows to iterate over all instances of a repeated
  // field given its id. Example usage:
  //   for (auto it = decoder.GetRepeated(N); it; ++it) { ... }
  inline RepeatedFieldIterator GetRepeated(uint32_t field_id) const {
    return RepeatedFieldIterator(field_id, &fields_[num_fields_],
                                 &fields_[size_], &fields_[field_id]);
  }

  // Returns an objects that allows to iterate over all entries of a packed
  // repeated field given its id and type. The |wire_type| is necessary for
  // decoding the packed field, the |cpp_type| is for convenience & stronger
  // typing.
  //
  // The caller must also supply a pointer to a bool that is set to true if the
  // packed buffer is found to be malformed while iterating (so you need to
  // exhaust the iterator if you want to check the full extent of the buffer).
  //
  // Note that unlike standard protobuf parsers, protozero does not allow
  // treating of packed repeated fields as non-packed and vice-versa (therefore
  // not making the packed option forwards and backwards compatible). So
  // the caller needs to use the right accessor for correct results.
  template <proto_utils::ProtoWireType wire_type, typename cpp_type>
  inline PackedRepeatedFieldIterator<wire_type, cpp_type> GetPackedRepeated(
      uint32_t field_id,
      bool* parse_error_location) const {
    const Field& field = Get(field_id);
    if (field.valid()) {
      return PackedRepeatedFieldIterator<wire_type, cpp_type>(
          field.data(), field.size(), parse_error_location);
    } else {
      return PackedRepeatedFieldIterator<wire_type, cpp_type>(
          nullptr, 0, parse_error_location);
    }
  }

 protected:
  TypedProtoDecoderBase(Field* storage,
                        uint32_t num_fields,
                        uint32_t capacity,
                        const uint8_t* buffer,
                        size_t length)
      : ProtoDecoder(buffer, length),
        fields_(storage),
        num_fields_(num_fields),
        size_(num_fields),
        capacity_(capacity) {
    // The reason why Field needs to be trivially de/constructible is to avoid
    // implicit initializers on all the ~1000 entries. We need it to initialize
    // only on the first |max_field_id| fields, the remaining capacity doesn't
    // require initialization.
    static_assert(PERFETTO_IS_TRIVIALLY_CONSTRUCTIBLE(Field) &&
                      std::is_trivially_destructible<Field>::value &&
                      std::is_trivial<Field>::value,
                  "Field must be a trivial aggregate type");
    memset(fields_, 0, sizeof(Field) * num_fields_);
  }

  void ParseAllFields();

  // Called when the default on-stack storage is exhausted and new repeated
  // fields need to be pushed.
  void ExpandHeapStorage();

  // Used only in presence of a large number of repeated fields, when the
  // default on-stack storage is exhausted.
  std::unique_ptr<Field[]> heap_storage_;

  // Points to the storage, either on-stack (default, provided by the template
  // specialization) or |heap_storage_| after ExpandHeapStorage() is called, in
  // case of a large number of repeated fields.
  Field* fields_;

  // Number of fields without accounting repeated storage. This is equal to
  // MAX_FIELD_ID + 1 (to account for the invalid 0th field).
  // This value is always <= size_ (and hence <= capacity);
  uint32_t num_fields_;

  // Number of active |fields_| entries. This is initially equal to the highest
  // number of fields for the message (num_fields_ == MAX_FIELD_ID + 1) and can
  // grow up to |capacity_| in the case of repeated fields.
  uint32_t size_;

  // Initially equal to kFieldsCapacity of the TypedProtoDecoder
  // specialization. Can grow when falling back on heap-based storage, in which
  // case it represents the size (#fields with each entry of a repeated field
  // counted individually) of the |heap_storage_| array.
  uint32_t capacity_;
};

// Template class instantiated by the auto-generated decoder classes declared in
// xxx.pbzero.h files.
template <int MAX_FIELD_ID, bool HAS_NONPACKED_REPEATED_FIELDS>
class TypedProtoDecoder : public TypedProtoDecoderBase {
 public:
  TypedProtoDecoder(const uint8_t* buffer, size_t length)
      : TypedProtoDecoderBase(on_stack_storage_,
                              /*num_fields=*/MAX_FIELD_ID + 1,
                              kCapacity,
                              buffer,
                              length) {
    static_assert(MAX_FIELD_ID <= kMaxDecoderFieldId, "Field ordinal too high");
    TypedProtoDecoderBase::ParseAllFields();
  }

  template <uint32_t FIELD_ID>
  inline const Field& at() const {
    static_assert(FIELD_ID <= MAX_FIELD_ID, "FIELD_ID > MAX_FIELD_ID");
    return fields_[FIELD_ID];
  }

  TypedProtoDecoder(TypedProtoDecoder&& other) noexcept
      : TypedProtoDecoderBase(std::move(other)) {
    // If the moved-from decoder was using on-stack storage, we need to update
    // our pointer to point to this decoder's on-stack storage.
    if (fields_ == other.on_stack_storage_) {
      fields_ = on_stack_storage_;
      memcpy(on_stack_storage_, other.on_stack_storage_,
             sizeof(on_stack_storage_));
    }
  }

 private:
  // In the case of non-repeated fields, this constant defines the highest field
  // id we are able to decode. This is to limit the on-stack storage.
  // In the case of repeated fields, this constant defines the max number of
  // repeated fields that we'll be able to store before falling back on the
  // heap. Keep this value in sync with the one in protozero_generator.cc.
  static constexpr size_t kMaxDecoderFieldId = 999;

  // If we the message has no repeated fields we need at most N Field entries
  // in the on-stack storage, where N is the highest field id.
  // Otherwise we need some room to store repeated fields.
  static constexpr size_t kCapacity =
      1 + (HAS_NONPACKED_REPEATED_FIELDS ? kMaxDecoderFieldId : MAX_FIELD_ID);

  Field on_stack_storage_[kCapacity];
};

}  // namespace protozero

#endif  // INCLUDE_PERFETTO_PROTOZERO_PROTO_DECODER_H_
// gen_amalgamated begin header: include/perfetto/protozero/proto_utils.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_PROTOZERO_PROTO_UTILS_H_
#define INCLUDE_PERFETTO_PROTOZERO_PROTO_UTILS_H_

#include <inttypes.h>
#include <stddef.h>

#include <type_traits>

// gen_amalgamated expanded: #include "perfetto/base/logging.h"

namespace protozero {
namespace proto_utils {

// See https://developers.google.com/protocol-buffers/docs/encoding wire types.
// This is a type encoded into the proto that provides just enough info to
// find the length of the following value.
enum class ProtoWireType : uint32_t {
  kVarInt = 0,
  kFixed64 = 1,
  kLengthDelimited = 2,
  kFixed32 = 5,
};

// This is the type defined in the proto for each field. This information
// is used to decide the translation strategy when writing the trace.
enum class ProtoSchemaType {
  kUnknown = 0,
  kDouble,
  kFloat,
  kInt64,
  kUint64,
  kInt32,
  kFixed64,
  kFixed32,
  kBool,
  kString,
  kGroup,  // Deprecated (proto2 only)
  kMessage,
  kBytes,
  kUint32,
  kEnum,
  kSfixed32,
  kSfixed64,
  kSint32,
  kSint64,
};

inline const char* ProtoSchemaToString(ProtoSchemaType v) {
  switch (v) {
    case ProtoSchemaType::kUnknown:
      return "unknown";
    case ProtoSchemaType::kDouble:
      return "double";
    case ProtoSchemaType::kFloat:
      return "float";
    case ProtoSchemaType::kInt64:
      return "int64";
    case ProtoSchemaType::kUint64:
      return "uint64";
    case ProtoSchemaType::kInt32:
      return "int32";
    case ProtoSchemaType::kFixed64:
      return "fixed64";
    case ProtoSchemaType::kFixed32:
      return "fixed32";
    case ProtoSchemaType::kBool:
      return "bool";
    case ProtoSchemaType::kString:
      return "string";
    case ProtoSchemaType::kGroup:
      return "group";
    case ProtoSchemaType::kMessage:
      return "message";
    case ProtoSchemaType::kBytes:
      return "bytes";
    case ProtoSchemaType::kUint32:
      return "uint32";
    case ProtoSchemaType::kEnum:
      return "enum";
    case ProtoSchemaType::kSfixed32:
      return "sfixed32";
    case ProtoSchemaType::kSfixed64:
      return "sfixed64";
    case ProtoSchemaType::kSint32:
      return "sint32";
    case ProtoSchemaType::kSint64:
      return "sint64";
  }
  // For gcc:
  PERFETTO_DCHECK(false);
  return "";
}

// Maximum message size supported: 256 MiB (4 x 7-bit due to varint encoding).
constexpr size_t kMessageLengthFieldSize = 4;
constexpr size_t kMaxMessageLength = (1u << (kMessageLengthFieldSize * 7)) - 1;

// Field tag is encoded as 32-bit varint (5 bytes at most).
// Largest value of simple (not length-delimited) field is 64-bit varint
// (10 bytes at most). 15 bytes buffer is enough to store a simple field.
constexpr size_t kMaxTagEncodedSize = 5;
constexpr size_t kMaxSimpleFieldEncodedSize = kMaxTagEncodedSize + 10;

// Proto types: (int|uint|sint)(32|64), bool, enum.
constexpr uint32_t MakeTagVarInt(uint32_t field_id) {
  return (field_id << 3) | static_cast<uint32_t>(ProtoWireType::kVarInt);
}

// Proto types: fixed64, sfixed64, fixed32, sfixed32, double, float.
template <typename T>
constexpr uint32_t MakeTagFixed(uint32_t field_id) {
  static_assert(sizeof(T) == 8 || sizeof(T) == 4, "Value must be 4 or 8 bytes");
  return (field_id << 3) |
         static_cast<uint32_t>((sizeof(T) == 8 ? ProtoWireType::kFixed64
                                               : ProtoWireType::kFixed32));
}

// Proto types: string, bytes, embedded messages.
constexpr uint32_t MakeTagLengthDelimited(uint32_t field_id) {
  return (field_id << 3) |
         static_cast<uint32_t>(ProtoWireType::kLengthDelimited);
}

// Proto types: sint64, sint32.
template <typename T>
inline typename std::make_unsigned<T>::type ZigZagEncode(T value) {
  return static_cast<typename std::make_unsigned<T>::type>(
      (value << 1) ^ (value >> (sizeof(T) * 8 - 1)));
}

template <typename T>
inline uint8_t* WriteVarInt(T value, uint8_t* target) {
  // If value is <= 0 we must first sign extend to int64_t (see [1]).
  // Finally we always cast to an unsigned value to to avoid arithmetic
  // (sign expanding) shifts in the while loop.
  // [1]: "If you use int32 or int64 as the type for a negative number, the
  // resulting varint is always ten bytes long".
  // - developers.google.com/protocol-buffers/docs/encoding
  // So for each input type we do the following casts:
  // uintX_t -> uintX_t -> uintX_t
  // int8_t  -> int64_t -> uint64_t
  // int16_t -> int64_t -> uint64_t
  // int32_t -> int64_t -> uint64_t
  // int64_t -> int64_t -> uint64_t
  using MaybeExtendedType =
      typename std::conditional<std::is_unsigned<T>::value, T, int64_t>::type;
  using UnsignedType = typename std::make_unsigned<MaybeExtendedType>::type;

  MaybeExtendedType extended_value = static_cast<MaybeExtendedType>(value);
  UnsignedType unsigned_value = static_cast<UnsignedType>(extended_value);

  while (unsigned_value >= 0x80) {
    *target++ = static_cast<uint8_t>(unsigned_value) | 0x80;
    unsigned_value >>= 7;
  }
  *target = static_cast<uint8_t>(unsigned_value);
  return target + 1;
}

// Writes a fixed-size redundant encoding of the given |value|. This is
// used to backfill fixed-size reservations for the length field using a
// non-canonical varint encoding (e.g. \x81\x80\x80\x00 instead of \x01).
// See https://github.com/google/protobuf/issues/1530.
// In particular, this is used for nested messages. The size of a nested message
// is not known until all its field have been written. |kMessageLengthFieldSize|
// bytes are reserved to encode the size field and backfilled at the end.
inline void WriteRedundantVarInt(uint32_t value, uint8_t* buf) {
  for (size_t i = 0; i < kMessageLengthFieldSize; ++i) {
    const uint8_t msb = (i < kMessageLengthFieldSize - 1) ? 0x80 : 0;
    buf[i] = static_cast<uint8_t>(value) | msb;
    value >>= 7;
  }
}

template <uint32_t field_id>
void StaticAssertSingleBytePreamble() {
  static_assert(field_id < 16,
                "Proto field id too big to fit in a single byte preamble");
}

// Parses a VarInt from the encoded buffer [start, end). |end| is STL-style and
// points one byte past the end of buffer.
// The parsed int value is stored in the output arg |value|. Returns a pointer
// to the next unconsumed byte (so start < retval <= end) or |start| if the
// VarInt could not be fully parsed because there was not enough space in the
// buffer.
inline const uint8_t* ParseVarInt(const uint8_t* start,
                                  const uint8_t* end,
                                  uint64_t* value) {
  const uint8_t* pos = start;
  uint64_t shift = 0;
  *value = 0;
  do {
    if (PERFETTO_UNLIKELY(pos >= end)) {
      *value = 0;
      return start;
    }
    PERFETTO_DCHECK(shift < 64ull);
    *value |= static_cast<uint64_t>(*pos & 0x7f) << shift;
    shift += 7;
  } while (*pos++ & 0x80);
  return pos;
}

}  // namespace proto_utils
}  // namespace protozero

#endif  // INCLUDE_PERFETTO_PROTOZERO_PROTO_UTILS_H_
// gen_amalgamated begin header: include/perfetto/protozero/scattered_heap_buffer.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_PROTOZERO_SCATTERED_HEAP_BUFFER_H_
#define INCLUDE_PERFETTO_PROTOZERO_SCATTERED_HEAP_BUFFER_H_

#include <memory>
#include <string>
#include <vector>

// gen_amalgamated expanded: #include "perfetto/base/export.h"
// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/protozero/scattered_stream_writer.h"

namespace protozero {

class Message;

class PERFETTO_EXPORT ScatteredHeapBuffer
    : public protozero::ScatteredStreamWriter::Delegate {
 public:
  class PERFETTO_EXPORT Slice {
   public:
    explicit Slice(size_t size);
    Slice(Slice&& slice) noexcept;
    ~Slice();

    inline protozero::ContiguousMemoryRange GetTotalRange() const {
      return {buffer_.get(), buffer_.get() + size_};
    }

    inline protozero::ContiguousMemoryRange GetUsedRange() const {
      return {buffer_.get(), buffer_.get() + size_ - unused_bytes_};
    }

    uint8_t* start() const { return buffer_.get(); }
    size_t size() const { return size_; }
    size_t unused_bytes() const { return unused_bytes_; }
    void set_unused_bytes(size_t unused_bytes) {
      PERFETTO_DCHECK(unused_bytes_ <= size_);
      unused_bytes_ = unused_bytes;
    }

   private:
    std::unique_ptr<uint8_t[]> buffer_;
    const size_t size_;
    size_t unused_bytes_;
  };

  ScatteredHeapBuffer(size_t initial_slice_size_bytes = 128,
                      size_t maximum_slice_size_bytes = 128 * 1024);
  ~ScatteredHeapBuffer() override;

  // protozero::ScatteredStreamWriter::Delegate implementation.
  protozero::ContiguousMemoryRange GetNewBuffer() override;

  // Stitch all the slices into a single contiguous buffer.
  std::vector<uint8_t> StitchSlices();

  const std::vector<Slice>& slices() const { return slices_; }

  void set_writer(protozero::ScatteredStreamWriter* writer) {
    writer_ = writer;
  }

  // Update unused_bytes() of the current |Slice| based on the writer's state.
  void AdjustUsedSizeOfCurrentSlice();

  // Returns the total size the slices occupy in heap memory (including unused).
  size_t GetTotalSize();

 private:
  size_t next_slice_size_;
  const size_t maximum_slice_size_;
  protozero::ScatteredStreamWriter* writer_ = nullptr;
  std::vector<Slice> slices_;
};

// Helper function to create heap-based protozero messages in one line.
// Useful when manually serializing a protozero message (primarily in
// tests/utilities). So instead of the following:
//   protozero::MyMessage msg;
//   protozero::ScatteredHeapBuffer shb;
//   protozero::ScatteredStreamWriter writer(&shb);
//   shb.set_writer(&writer);
//   msg.Reset(&writer);
//   ...
// You can write:
//   protozero::HeapBuffered<protozero::MyMessage> msg;
//   msg->set_stuff(...);
//   msg.SerializeAsString();
template <typename T = ::protozero::Message>
class HeapBuffered {
 public:
  HeapBuffered() : HeapBuffered(4096, 4096) {}
  HeapBuffered(size_t initial_slice_size_bytes, size_t maximum_slice_size_bytes)
      : shb_(initial_slice_size_bytes, maximum_slice_size_bytes),
        writer_(&shb_) {
    shb_.set_writer(&writer_);
    msg_.Reset(&writer_);
  }

  // This can't be neither copied nor moved because Message hands out pointers
  // to itself when creating submessages.
  HeapBuffered(const HeapBuffered&) = delete;
  HeapBuffered& operator=(const HeapBuffered&) = delete;
  HeapBuffered(HeapBuffered&&) = delete;
  HeapBuffered& operator=(HeapBuffered&&) = delete;

  T* get() { return &msg_; }
  T* operator->() { return &msg_; }

  std::vector<uint8_t> SerializeAsArray() {
    msg_.Finalize();
    return shb_.StitchSlices();
  }

  std::string SerializeAsString() {
    auto vec = SerializeAsArray();
    return std::string(reinterpret_cast<const char*>(vec.data()), vec.size());
  }

 private:
  ScatteredHeapBuffer shb_;
  ScatteredStreamWriter writer_;
  T msg_;
};

}  // namespace protozero

#endif  // INCLUDE_PERFETTO_PROTOZERO_SCATTERED_HEAP_BUFFER_H_
// gen_amalgamated begin header: include/perfetto/protozero/scattered_stream_null_delegate.h
/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_PROTOZERO_SCATTERED_STREAM_NULL_DELEGATE_H_
#define INCLUDE_PERFETTO_PROTOZERO_SCATTERED_STREAM_NULL_DELEGATE_H_

#include <memory>
#include <vector>

// gen_amalgamated expanded: #include "perfetto/base/export.h"
// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/protozero/contiguous_memory_range.h"
// gen_amalgamated expanded: #include "perfetto/protozero/scattered_stream_writer.h"

namespace protozero {

class PERFETTO_EXPORT ScatteredStreamWriterNullDelegate
    : public ScatteredStreamWriter::Delegate {
 public:
  explicit ScatteredStreamWriterNullDelegate(size_t chunk_size);
  ~ScatteredStreamWriterNullDelegate() override;

  // protozero::ScatteredStreamWriter::Delegate implementation.
  ContiguousMemoryRange GetNewBuffer() override;

 private:
  const size_t chunk_size_;
  std::unique_ptr<uint8_t[]> chunk_;
};

}  // namespace protozero

#endif  // INCLUDE_PERFETTO_PROTOZERO_SCATTERED_STREAM_NULL_DELEGATE_H_
// gen_amalgamated begin header: include/perfetto/protozero/scattered_stream_writer.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_PROTOZERO_SCATTERED_STREAM_WRITER_H_
#define INCLUDE_PERFETTO_PROTOZERO_SCATTERED_STREAM_WRITER_H_

#include <assert.h>
#include <stddef.h>
#include <stdint.h>
#include <string.h>

// gen_amalgamated expanded: #include "perfetto/base/compiler.h"
// gen_amalgamated expanded: #include "perfetto/base/export.h"
// gen_amalgamated expanded: #include "perfetto/protozero/contiguous_memory_range.h"

namespace protozero {

// This class deals with the following problem: append-only proto messages want
// to write a stream of bytes, without caring about the implementation of the
// underlying buffer (which concretely will be either the trace ring buffer
// or a heap-allocated buffer). The main deal is: proto messages don't know in
// advance what their size will be.
// Due to the tracing buffer being split into fixed-size chunks, on some
// occasions, these writes need to be spread over two (or more) non-contiguous
// chunks of memory. Similarly, when the buffer is backed by the heap, we want
// to avoid realloc() calls, as they might cause a full copy of the contents
// of the buffer.
// The purpose of this class is to abstract away the non-contiguous write logic.
// This class knows how to deal with writes as long as they fall in the same
// ContiguousMemoryRange and defers the chunk-chaining logic to the Delegate.
class PERFETTO_EXPORT ScatteredStreamWriter {
 public:
  class PERFETTO_EXPORT Delegate {
   public:
    virtual ~Delegate();
    virtual ContiguousMemoryRange GetNewBuffer() = 0;
  };

  explicit ScatteredStreamWriter(Delegate* delegate);
  ~ScatteredStreamWriter();

  inline void WriteByte(uint8_t value) {
    if (write_ptr_ >= cur_range_.end)
      Extend();
    *write_ptr_++ = value;
  }

  // Assumes that the caller checked that there is enough headroom.
  // TODO(primiano): perf optimization, this is a tracing hot path. The
  // compiler can make strong optimization on memcpy if the size arg is a
  // constexpr. Make a templated variant of this for fixed-size writes.
  // TODO(primiano): restrict / noalias might also help.
  inline void WriteBytesUnsafe(const uint8_t* src, size_t size) {
    uint8_t* const end = write_ptr_ + size;
    assert(end <= cur_range_.end);
    memcpy(write_ptr_, src, size);
    write_ptr_ = end;
  }

  inline void WriteBytes(const uint8_t* src, size_t size) {
    uint8_t* const end = write_ptr_ + size;
    if (PERFETTO_LIKELY(end <= cur_range_.end))
      return WriteBytesUnsafe(src, size);
    WriteBytesSlowPath(src, size);
  }

  void WriteBytesSlowPath(const uint8_t* src, size_t size);

  // Reserves a fixed amount of bytes to be backfilled later. The reserved range
  // is guaranteed to be contiguous and not span across chunks. |size| has to be
  // <= than the size of a new buffer returned by the Delegate::GetNewBuffer().
  uint8_t* ReserveBytes(size_t size);

  // Fast (but unsafe) version of the above. The caller must have previously
  // checked that there are at least |size| contiguous bytes available.
  // Returns only the start pointer of the reservation.
  uint8_t* ReserveBytesUnsafe(size_t size) {
    uint8_t* begin = write_ptr_;
    write_ptr_ += size;
    assert(write_ptr_ <= cur_range_.end);
    return begin;
  }

  // Resets the buffer boundaries and the write pointer to the given |range|.
  // Subsequent WriteByte(s) will write into |range|.
  void Reset(ContiguousMemoryRange range);

  // Number of contiguous free bytes in |cur_range_| that can be written without
  // requesting a new buffer.
  size_t bytes_available() const {
    return static_cast<size_t>(cur_range_.end - write_ptr_);
  }

  uint8_t* write_ptr() const { return write_ptr_; }

  uint64_t written() const {
    return written_previously_ +
           static_cast<uint64_t>(write_ptr_ - cur_range_.begin);
  }

 private:
  ScatteredStreamWriter(const ScatteredStreamWriter&) = delete;
  ScatteredStreamWriter& operator=(const ScatteredStreamWriter&) = delete;

  void Extend();

  Delegate* const delegate_;
  ContiguousMemoryRange cur_range_;
  uint8_t* write_ptr_;
  uint64_t written_previously_ = 0;
};

}  // namespace protozero

#endif  // INCLUDE_PERFETTO_PROTOZERO_SCATTERED_STREAM_WRITER_H_

