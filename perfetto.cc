// Copyright (C) 2019 The Android Open Source Project
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// This file is automatically generated by gen_amalgamated. Do not edit.

#include "perfetto.h"
// gen_amalgamated begin source: src/base/file_utils.cc
// gen_amalgamated begin header: include/perfetto/base/build_config.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_BASE_BUILD_CONFIG_H_
#define INCLUDE_PERFETTO_BASE_BUILD_CONFIG_H_

// Allows to define build flags that give a compiler error if the header that
// defined the flag is not included, instead of silently ignoring the #if block.
#define PERFETTO_BUILDFLAG_CAT_INDIRECT(a, b) a##b
#define PERFETTO_BUILDFLAG_CAT(a, b) PERFETTO_BUILDFLAG_CAT_INDIRECT(a, b)
#define PERFETTO_BUILDFLAG(flag) \
  (PERFETTO_BUILDFLAG_CAT(PERFETTO_BUILDFLAG_DEFINE_, flag)())

#if defined(__ANDROID__)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_ANDROID() 1
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_MACOSX() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_LINUX() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WIN() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WASM() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_FUCHSIA() 0
#elif defined(__APPLE__)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_ANDROID() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_MACOSX() 1
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_LINUX() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WIN() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WASM() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_FUCHSIA() 0
#elif defined(__linux__)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_ANDROID() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_MACOSX() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_LINUX() 1
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WIN() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WASM() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_FUCHSIA() 0
#elif defined(_WIN32)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_ANDROID() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_MACOSX() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_LINUX() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WIN() 1
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WASM() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_FUCHSIA() 0
#elif defined(__EMSCRIPTEN__)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_ANDROID() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_MACOSX() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_LINUX() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WIN() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WASM() 1
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_FUCHSIA() 0
#elif defined(__Fuchsia__)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_ANDROID() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_MACOSX() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_LINUX() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WIN() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_WASM() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_OS_FUCHSIA() 1
#else
#error OS not supported (see build_config.h)
#endif

#if defined(__clang__)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_COMPILER_CLANG() 1
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_COMPILER_GCC() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_COMPILER_MSVC() 0
#elif defined(__GNUC__) // Careful: Clang also defines this!
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_COMPILER_CLANG() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_COMPILER_GCC() 1
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_COMPILER_MSVC() 0
#elif defined(_MSC_VER)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_COMPILER_CLANG() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_COMPILER_GCC() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_COMPILER_MSVC() 1
#else
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_COMPILER_CLANG() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_COMPILER_GCC() 0
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_COMPILER_MSVC() 0
#endif

#if defined(PERFETTO_BUILD_WITH_ANDROID)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_ANDROID_BUILD() 1
#else
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_ANDROID_BUILD() 0
#endif

#if defined(PERFETTO_BUILD_WITH_EMBEDDER)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_EMBEDDER_BUILD() 1
#else
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_EMBEDDER_BUILD() 0
#endif

#if defined(PERFETTO_BUILD_WITH_CHROMIUM)
#if !defined(PERFETTO_BUILD_WITH_EMBEDDER)
#error PERFETTO_BUILD_WITH_EMBEDDER must be defined when \
       PERFETTO_BUILD_WITH_CHROMIUM is defined
#endif
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_CHROMIUM_BUILD() 1
#else
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_CHROMIUM_BUILD() 0
#endif

#if !defined(PERFETTO_BUILD_WITH_EMBEDDER) && \
    !defined(PERFETTO_BUILD_WITH_ANDROID)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_STANDALONE_BUILD() 1
#else
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_STANDALONE_BUILD() 0
#endif

#if defined(PERFETTO_START_DAEMONS_FOR_TESTING)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_START_DAEMONS() 1
#else
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_START_DAEMONS() 0
#endif

#if defined(PERFETTO_BUILD_WITH_ANDROID_USERDEBUG)
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_ANDROID_USERDEBUG_BUILD() 1
#else
#define PERFETTO_BUILDFLAG_DEFINE_PERFETTO_ANDROID_USERDEBUG_BUILD() 0
#endif

#endif  // INCLUDE_PERFETTO_BASE_BUILD_CONFIG_H_
// gen_amalgamated begin header: include/perfetto/base/logging.h
// gen_amalgamated begin header: include/perfetto/base/compiler.h
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_BASE_COMPILER_H_
#define INCLUDE_PERFETTO_BASE_COMPILER_H_

#include <type_traits>

#define PERFETTO_LIKELY(_x) __builtin_expect(!!(_x), 1)
#define PERFETTO_UNLIKELY(_x) __builtin_expect(!!(_x), 0)

#if defined(__GNUC__) || defined(__clang__)
#define PERFETTO_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
#define PERFETTO_WARN_UNUSED_RESULT
#endif

#if defined(__clang__)
#define PERFETTO_ALWAYS_INLINE __attribute__((__always_inline__))
#else
// GCC is too pedantic and often fails with the error:
// "always_inline function might not be inlinable"
#define PERFETTO_ALWAYS_INLINE
#endif

// TODO(lalitm): is_trivially_constructible is currently not available
// in some environments we build in. Reenable when that environment supports
// this.
#if defined(__GLIBCXX__)
#define PERFETTO_IS_TRIVIALLY_CONSTRUCTIBLE(T) true
#else
#define PERFETTO_IS_TRIVIALLY_CONSTRUCTIBLE(T) \
  std::is_trivially_constructible<T>::value
#endif

// TODO(lalitm): is_trivially_copyable is currently not available
// in some environments we build in. Reenable when that environment supports
// this.
#if defined(__GLIBCXX__)
#define PERFETTO_IS_TRIVIALLY_COPYABLE(T) true
#else
#define PERFETTO_IS_TRIVIALLY_COPYABLE(T) std::is_trivially_copyable<T>::value
#endif

namespace perfetto {
namespace base {

template <typename... T>
inline void ignore_result(const T&...) {}

}  // namespace base
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_BASE_COMPILER_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_BASE_LOGGING_H_
#define INCLUDE_PERFETTO_BASE_LOGGING_H_

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>  // For strerror.

// gen_amalgamated expanded: #include "perfetto/base/build_config.h"
// gen_amalgamated expanded: #include "perfetto/base/compiler.h"

#if defined(NDEBUG) && !defined(DCHECK_ALWAYS_ON)
#define PERFETTO_DCHECK_IS_ON() 0
#else
#define PERFETTO_DCHECK_IS_ON() 1
#endif

#if !defined(PERFETTO_FORCE_DLOG)
#define PERFETTO_DLOG_IS_ON() PERFETTO_DCHECK_IS_ON()
#else
#define PERFETTO_DLOG_IS_ON() PERFETTO_FORCE_DLOG
#endif

#if defined(PERFETTO_ANDROID_ASYNC_SAFE_LOG)
#if !PERFETTO_BUILDFLAG(PERFETTO_OS_ANDROID) || \
    !PERFETTO_BUILDFLAG(PERFETTO_ANDROID_BUILD)
#error "Async-safe logging is limited to Android tree builds"
#endif
// For binaries which need a very lightweight logging implementation.
// Note that this header is incompatible with android/log.h.
#include <async_safe/log.h>
#elif PERFETTO_BUILDFLAG(PERFETTO_OS_ANDROID)
// Normal android logging.
#include <android/log.h>
#endif

#if !PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)
#include <unistd.h>
#endif

namespace perfetto {
namespace base {

// Constexpr functions to extract basename(__FILE__), e.g.: ../foo/f.c -> f.c .
constexpr const char* StrEnd(const char* s) {
  return *s ? StrEnd(s + 1) : s;
}

constexpr const char* BasenameRecursive(const char* s,
                                        const char* begin,
                                        const char* end) {
  return (*s == '/' && s < end)
             ? (s + 1)
             : ((s > begin) ? BasenameRecursive(s - 1, begin, end) : s);
}

constexpr const char* Basename(const char* str) {
  return BasenameRecursive(StrEnd(str), str, StrEnd(str));
}

#define PERFETTO_LOG_LINE__(x) #x
#define PERFETTO_LOG_LINE_(x) PERFETTO_LOG_LINE__(x)
#define PERFETTO_LOG_LINE PERFETTO_LOG_LINE_(__LINE__)

enum LogLev { kLogDebug = 0, kLogInfo, kLogImportant, kLogError };
#if PERFETTO_BUILDFLAG(PERFETTO_OS_WIN) || PERFETTO_BUILDFLAG(PERFETTO_OS_WASM)
// The escape sequences don't work in a Windows command prompt.
#define PERFETTO_XLOG_STDERR(level, fmt, ...)                              \
  fprintf(stderr, "%-24.24s " fmt "\n",                                    \
          ::perfetto::base::Basename(__FILE__ "(" PERFETTO_LOG_LINE "):"), \
          ##__VA_ARGS__)
#else
constexpr const char* kLogFmt[] = {"\x1b[2m", "\x1b[39m", "\x1b[32m\x1b[1m",
                                   "\x1b[31m"};

#define PERFETTO_XLOG_STDERR(level, fmt, ...)                         \
  fprintf(stderr, "\x1b[90m%-24.24s\x1b[0m %s" fmt "\x1b[0m\n",       \
          ::perfetto::base::Basename(__FILE__ ":" PERFETTO_LOG_LINE), \
          ::perfetto::base::kLogFmt[::perfetto::base::LogLev::level], \
          ##__VA_ARGS__)
#endif

#if PERFETTO_BUILDFLAG(PERFETTO_OS_ANDROID) && \
    defined(PERFETTO_ANDROID_ASYNC_SAFE_LOG)
#define PERFETTO_XLOG(level, fmt, ...)                                         \
  do {                                                                         \
    async_safe_format_log(                                                     \
        (ANDROID_LOG_DEBUG + ::perfetto::base::LogLev::level), "perfetto",     \
        "%s " fmt, ::perfetto::base::Basename(__FILE__ ":" PERFETTO_LOG_LINE), \
        ##__VA_ARGS__);                                                        \
  } while (0)
#elif PERFETTO_BUILDFLAG(PERFETTO_OS_ANDROID)
// Standard logging marco on Android - log to both stderr and logcat. When part
// of the Android tree, stderr points to /dev/null so logcat is the only way to
// get some logging.
#define PERFETTO_XLOG(level, fmt, ...)                                         \
  do {                                                                         \
    __android_log_print(                                                       \
        (ANDROID_LOG_DEBUG + ::perfetto::base::LogLev::level), "perfetto",     \
        "%s " fmt, ::perfetto::base::Basename(__FILE__ ":" PERFETTO_LOG_LINE), \
        ##__VA_ARGS__);                                                        \
    PERFETTO_XLOG_STDERR(level, fmt, ##__VA_ARGS__);                           \
  } while (0)
#else
#define PERFETTO_XLOG PERFETTO_XLOG_STDERR
#endif

#define PERFETTO_IMMEDIATE_CRASH() \
  do {                             \
    __builtin_trap();              \
    __builtin_unreachable();       \
  } while (0)

#define PERFETTO_LOG(fmt, ...) PERFETTO_XLOG(kLogInfo, fmt, ##__VA_ARGS__)
#define PERFETTO_ILOG(fmt, ...) PERFETTO_XLOG(kLogImportant, fmt, ##__VA_ARGS__)
#define PERFETTO_ELOG(fmt, ...) PERFETTO_XLOG(kLogError, fmt, ##__VA_ARGS__)
#define PERFETTO_FATAL(fmt, ...)       \
  do {                                 \
    PERFETTO_PLOG(fmt, ##__VA_ARGS__); \
    PERFETTO_IMMEDIATE_CRASH();        \
  } while (0)

#define PERFETTO_PLOG(x, ...) \
  PERFETTO_ELOG(x " (errno: %d, %s)", ##__VA_ARGS__, errno, strerror(errno))

#if PERFETTO_DLOG_IS_ON()

#define PERFETTO_DLOG(fmt, ...) PERFETTO_XLOG(kLogDebug, fmt, ##__VA_ARGS__)

#define PERFETTO_DPLOG(x, ...) \
  PERFETTO_DLOG(x " (errno: %d, %s)", ##__VA_ARGS__, errno, strerror(errno))

#else

#define PERFETTO_DLOG(...) ::perfetto::base::ignore_result(__VA_ARGS__)
#define PERFETTO_DPLOG(...) ::perfetto::base::ignore_result(__VA_ARGS__)

#endif  // PERFETTO_DLOG_IS_ON()

#if PERFETTO_DCHECK_IS_ON()

#define PERFETTO_DCHECK(x)                           \
  do {                                               \
    if (PERFETTO_UNLIKELY(!(x))) {                   \
      PERFETTO_PLOG("%s", "PERFETTO_CHECK(" #x ")"); \
      PERFETTO_IMMEDIATE_CRASH();                    \
    }                                                \
  } while (0)

#define PERFETTO_DFATAL(fmt, ...)      \
  do {                                 \
    PERFETTO_PLOG(fmt, ##__VA_ARGS__); \
    PERFETTO_IMMEDIATE_CRASH();        \
  } while (0)

#define PERFETTO_DFATAL_OR_ELOG(...) PERFETTO_DFATAL(__VA_ARGS__)

#else

#define PERFETTO_DCHECK(x) \
  do {                     \
  } while (false && (x))

#define PERFETTO_DFATAL(...) ::perfetto::base::ignore_result(__VA_ARGS__)
#define PERFETTO_DFATAL_OR_ELOG(...) PERFETTO_ELOG(__VA_ARGS__)

#endif  // PERFETTO_DCHECK_IS_ON()

#if PERFETTO_DCHECK_IS_ON()
#define PERFETTO_CHECK(x) PERFETTO_DCHECK(x)
#else
#define PERFETTO_CHECK(x)                            \
  do {                                               \
    if (PERFETTO_UNLIKELY(!(x))) {                   \
      PERFETTO_PLOG("%s", "PERFETTO_CHECK(" #x ")"); \
      PERFETTO_IMMEDIATE_CRASH();                    \
    }                                                \
  } while (0)

#endif  // PERFETTO_DCHECK_IS_ON()

}  // namespace base
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_BASE_LOGGING_H_
// gen_amalgamated begin header: include/perfetto/ext/base/file_utils.h
// gen_amalgamated begin header: include/perfetto/ext/base/utils.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_BASE_UTILS_H_
#define INCLUDE_PERFETTO_EXT_BASE_UTILS_H_

// gen_amalgamated expanded: #include "perfetto/base/build_config.h"
// gen_amalgamated expanded: #include "perfetto/base/compiler.h"

#include <errno.h>
#include <stddef.h>
#include <stdlib.h>
#if !PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)
#include <sys/types.h>
#endif

#define PERFETTO_EINTR(x)                                   \
  ({                                                        \
    decltype(x) eintr_wrapper_result;                       \
    do {                                                    \
      eintr_wrapper_result = (x);                           \
    } while (eintr_wrapper_result == -1 && errno == EINTR); \
    eintr_wrapper_result;                                   \
  })

#if PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)
// TODO(brucedawson) - create a ::perfetto::base::IOSize to replace this.
#if defined(_WIN64)
using ssize_t = __int64;
#else
using ssize_t = long;
#endif
#endif

namespace perfetto {
namespace base {

#if !PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)
constexpr uid_t kInvalidUid = static_cast<uid_t>(-1);
constexpr pid_t kInvalidPid = static_cast<pid_t>(-1);
#endif

constexpr size_t kPageSize = 4096;
constexpr size_t kMaxCpus = 128;

template <typename T>
constexpr size_t ArraySize(const T& array) {
  return sizeof(array) / sizeof(array[0]);
}

// Function object which invokes 'free' on its parameter, which must be
// a pointer. Can be used to store malloc-allocated pointers in std::unique_ptr:
//
// std::unique_ptr<int, base::FreeDeleter> foo_ptr(
//     static_cast<int*>(malloc(sizeof(int))));
struct FreeDeleter {
  inline void operator()(void* ptr) const { free(ptr); }
};

template <typename T>
constexpr T AssumeLittleEndian(T value) {
  static_assert(__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__,
                "Unimplemented on big-endian archs");
  return value;
}

// Round up |size| to a multiple of |alignment| (must be a power of two).
template <size_t alignment>
constexpr size_t AlignUp(size_t size) {
  static_assert((alignment & (alignment - 1)) == 0, "alignment must be a pow2");
  return (size + alignment - 1) & ~(alignment - 1);
}

inline bool IsAgain(int err) {
  return err == EAGAIN || err == EWOULDBLOCK;
}

}  // namespace base
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_BASE_UTILS_H_
/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_BASE_FILE_UTILS_H_
#define INCLUDE_PERFETTO_EXT_BASE_FILE_UTILS_H_

#include <stddef.h>

#include <string>

// gen_amalgamated expanded: #include "perfetto/ext/base/utils.h"

namespace perfetto {
namespace base {

bool ReadFileDescriptor(int fd, std::string* out);
bool ReadFileStream(FILE* f, std::string* out);
bool ReadFile(const std::string& path, std::string* out);

// Call write until all data is written or an error is detected.
//
// man 2 write:
//   If a write() is interrupted by a signal handler before any bytes are
//   written, then the call fails with the error EINTR; if it is
//   interrupted after at least one byte has been written, the call
//   succeeds, and returns the number of bytes written.
ssize_t WriteAll(int fd, const void* buf, size_t count);

bool FlushFile(int fd);

}  // namespace base
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_BASE_FILE_UTILS_H_
// gen_amalgamated begin header: include/perfetto/ext/base/scoped_file.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_BASE_SCOPED_FILE_H_
#define INCLUDE_PERFETTO_EXT_BASE_SCOPED_FILE_H_

// gen_amalgamated expanded: #include "perfetto/base/build_config.h"

#include <fcntl.h>
#include <stdio.h>

#if PERFETTO_BUILDFLAG(PERFETTO_OS_WIN) && \
    !PERFETTO_BUILDFLAG(PERFETTO_COMPILER_GCC)
#include <corecrt_io.h>
typedef int mode_t;
#else
#include <dirent.h>
#include <unistd.h>
#endif

#include <string>

// gen_amalgamated expanded: #include "perfetto/base/logging.h"

namespace perfetto {
namespace base {

constexpr mode_t kInvalidMode = static_cast<mode_t>(-1);

// RAII classes for auto-releasing fds and dirs.
template <typename T,
          int (*CloseFunction)(T),
          T InvalidValue,
          bool CheckClose = true>
class ScopedResource {
 public:
  explicit ScopedResource(T t = InvalidValue) : t_(t) {}
  ScopedResource(ScopedResource&& other) noexcept {
    t_ = other.t_;
    other.t_ = InvalidValue;
  }
  ScopedResource& operator=(ScopedResource&& other) {
    reset(other.t_);
    other.t_ = InvalidValue;
    return *this;
  }
  T get() const { return t_; }
  T operator*() const { return t_; }
  explicit operator bool() const { return t_ != InvalidValue; }
  void reset(T r = InvalidValue) {
    if (t_ != InvalidValue) {
      int res = CloseFunction(t_);
      if (CheckClose)
        PERFETTO_CHECK(res == 0);
    }
    t_ = r;
  }
  T release() {
    T t = t_;
    t_ = InvalidValue;
    return t;
  }
  ~ScopedResource() { reset(InvalidValue); }

 private:
  ScopedResource(const ScopedResource&) = delete;
  ScopedResource& operator=(const ScopedResource&) = delete;

  T t_;
};

using ScopedFile = ScopedResource<int, close, -1>;
inline static ScopedFile OpenFile(const std::string& path,
                                  int flags,
                                  mode_t mode = kInvalidMode) {
  PERFETTO_DCHECK((flags & O_CREAT) == 0 || mode != kInvalidMode);
#if PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)
  ScopedFile fd(open(path.c_str(), flags, mode));
#else
  // Always open a ScopedFile with O_CLOEXEC so we can safely fork and exec.
  ScopedFile fd(open(path.c_str(), flags | O_CLOEXEC, mode));
#endif
  return fd;
}
#if !PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)
using ScopedDir = ScopedResource<DIR*, closedir, nullptr>;
#endif

using ScopedFstream = ScopedResource<FILE*, fclose, nullptr>;

}  // namespace base
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_BASE_SCOPED_FILE_H_
/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <sys/stat.h>

// gen_amalgamated expanded: #include "perfetto/base/build_config.h"
// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/file_utils.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/scoped_file.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/utils.h"

#if !PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)
#include <unistd.h>
#else
#include <corecrt_io.h>
#include <io.h>
#endif

namespace perfetto {
namespace base {
namespace {
constexpr size_t kBufSize = 2048;
}

bool ReadFileDescriptor(int fd, std::string* out) {
  // Do not override existing data in string.
  size_t i = out->size();

  struct stat buf {};
  if (fstat(fd, &buf) != -1) {
    if (buf.st_size > 0)
      out->resize(i + static_cast<size_t>(buf.st_size));
  }

  ssize_t bytes_read;
  for (;;) {
    if (out->size() < i + kBufSize)
      out->resize(out->size() + kBufSize);

    bytes_read = PERFETTO_EINTR(read(fd, &((*out)[i]), kBufSize));
    if (bytes_read > 0) {
      i += static_cast<size_t>(bytes_read);
    } else {
      out->resize(i);
      return bytes_read == 0;
    }
  }
}

bool ReadFileStream(FILE* f, std::string* out) {
  return ReadFileDescriptor(fileno(f), out);
}

bool ReadFile(const std::string& path, std::string* out) {
  base::ScopedFile fd = base::OpenFile(path, O_RDONLY);
  if (!fd)
    return false;

  return ReadFileDescriptor(*fd, out);
}

ssize_t WriteAll(int fd, const void* buf, size_t count) {
  size_t written = 0;
  while (written < count) {
    ssize_t wr = PERFETTO_EINTR(
        write(fd, static_cast<const char*>(buf) + written, count - written));
    if (wr == 0)
      break;
    if (wr < 0)
      return wr;
    written += static_cast<size_t>(wr);
  }
  return static_cast<ssize_t>(written);
}

bool FlushFile(int fd) {
  PERFETTO_DCHECK(fd != 0);
#if PERFETTO_BUILDFLAG(PERFETTO_OS_LINUX) || \
    PERFETTO_BUILDFLAG(PERFETTO_OS_ANDROID)
  return !PERFETTO_EINTR(fdatasync(fd));
#elif PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)
  return !PERFETTO_EINTR(_commit(fd));
#else
  return !PERFETTO_EINTR(fsync(fd));
#endif
}

}  // namespace base
}  // namespace perfetto
// gen_amalgamated begin source: src/base/metatrace.cc
// gen_amalgamated begin header: include/perfetto/ext/base/metatrace.h
// gen_amalgamated begin header: include/perfetto/ext/base/metatrace_events.h
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_BASE_METATRACE_EVENTS_H_
#define INCLUDE_PERFETTO_EXT_BASE_METATRACE_EVENTS_H_

#include <stdint.h>

namespace perfetto {
namespace metatrace {

enum Tags : uint32_t {
  TAG_NONE = 0,
  TAG_ANY = uint32_t(-1),
  TAG_FTRACE = 1 << 0,
  TAG_PROC_POLLERS = 1 << 1,
};

// Compile time list of parsing and processing stats.
// The macros below generate matching enums and arrays of string literals.
// This is to avoid maintaining string maps manually.

// clang-format off

// DO NOT remove or reshuffle items in this list, only append. The ID of these
// events are an ABI, the trace processor relies on these to open old traces.
#define PERFETTO_METATRACE_EVENTS(F) \
  F(EVENT_ZERO_UNUSED),\
  F(FTRACE_CPU_READER_READ), \
  F(FTRACE_DRAIN_CPUS), \
  F(FTRACE_UNBLOCK_READERS), \
  F(FTRACE_CPU_READ_NONBLOCK), \
  F(FTRACE_CPU_READ_BLOCK), \
  F(FTRACE_CPU_SPLICE_NONBLOCK), \
  F(FTRACE_CPU_SPLICE_BLOCK), \
  F(FTRACE_CPU_WAIT_CMD), \
  F(FTRACE_CPU_RUN_CYCLE), \
  F(FTRACE_CPU_FLUSH), \
  F(FTRACE_CPU_DRAIN), \
  F(READ_SYS_STATS), \
  F(PS_WRITE_ALL_PROCESSES), \
  F(PS_ON_PIDS), \
  F(PS_ON_RENAME_PIDS), \
  F(PS_WRITE_ALL_PROCESS_STATS)

// Append only, see above.
#define PERFETTO_METATRACE_COUNTERS(F) \
  F(COUNTER_ZERO_UNUSED),\
  F(FTRACE_PAGES_DRAINED), \
  F(PS_PIDS_SCANNED)

// clang-format on

#define PERFETTO_METATRACE_IDENTITY(name) name
#define PERFETTO_METATRACE_TOSTRING(name) #name

enum Events : uint16_t {
  PERFETTO_METATRACE_EVENTS(PERFETTO_METATRACE_IDENTITY),
  EVENTS_MAX
};
constexpr char const* kEventNames[] = {
    PERFETTO_METATRACE_EVENTS(PERFETTO_METATRACE_TOSTRING)};

enum Counters : uint16_t {
  PERFETTO_METATRACE_COUNTERS(PERFETTO_METATRACE_IDENTITY),
  COUNTERS_MAX
};
constexpr char const* kCounterNames[] = {
    PERFETTO_METATRACE_COUNTERS(PERFETTO_METATRACE_TOSTRING)};

}  // namespace metatrace
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_BASE_METATRACE_EVENTS_H_
// gen_amalgamated begin header: include/perfetto/ext/base/thread_annotations.h
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_BASE_THREAD_ANNOTATIONS_H_
#define INCLUDE_PERFETTO_EXT_BASE_THREAD_ANNOTATIONS_H_

// gen_amalgamated expanded: #include "perfetto/base/build_config.h"

// Windows TSAN doesn't currently support these annotations.
#if defined(THREAD_SANITIZER) && !PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)
extern "C" {
void AnnotateBenignRaceSized(const char* file,
                             int line,
                             unsigned long address,
                             unsigned long size,
                             const char* description);
}

#define PERFETTO_ANNOTATE_BENIGN_RACE_SIZED(pointer, size, description)   \
  AnnotateBenignRaceSized(__FILE__, __LINE__,                             \
                          reinterpret_cast<unsigned long>(pointer), size, \
                          description);
#else  // defined(ADDRESS_SANITIZER)
#define PERFETTO_ANNOTATE_BENIGN_RACE_SIZED(pointer, size, description)
#endif  // defined(ADDRESS_SANITIZER)

#endif  // INCLUDE_PERFETTO_EXT_BASE_THREAD_ANNOTATIONS_H_
// gen_amalgamated begin header: include/perfetto/ext/base/thread_utils.h
/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_BASE_THREAD_UTILS_H_
#define INCLUDE_PERFETTO_EXT_BASE_THREAD_UTILS_H_

#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/base/build_config.h"

#if PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)
#include <Windows.h>
#include <processthreadsapi.h>
#elif PERFETTO_BUILDFLAG(PERFETTO_OS_FUCHSIA)
#include <zircon/process.h>
#include <zircon/types.h>
#else
#include <pthread.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <unistd.h>
#endif

namespace perfetto {
namespace base {

#if PERFETTO_BUILDFLAG(PERFETTO_OS_ANDROID)
using PlatformThreadID = pid_t;
inline PlatformThreadID GetThreadId() {
  return gettid();
}
#elif PERFETTO_BUILDFLAG(PERFETTO_OS_LINUX)
using PlatformThreadID = pid_t;
inline PlatformThreadID GetThreadId() {
  return static_cast<pid_t>(syscall(__NR_gettid));
}
#elif PERFETTO_BUILDFLAG(PERFETTO_OS_FUCHSIA)
using PlatformThreadID = zx_handle_t;
inline PlatformThreadID GetThreadId() {
  return static_cast<pid_t>(zx_thread_self());
}
#elif PERFETTO_BUILDFLAG(PERFETTO_OS_MACOSX)
using PlatformThreadID = uint64_t;
inline PlatformThreadID GetThreadId() {
  uint64_t tid;
  pthread_threadid_np(nullptr, &tid);
  return tid;
}
#elif PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)
using PlatformThreadID = uint64_t;
inline PlatformThreadID GetThreadId() {
  return static_cast<uint64_t>(GetCurrentThreadId());
}
#else  // Default to pthreads in case no OS is set.
using PlatformThreadID = pthread_t;
inline PlatformThreadID GetThreadId() {
  return pthread_self();
}
#endif

}  // namespace base
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_BASE_THREAD_UTILS_H_
// gen_amalgamated begin header: include/perfetto/ext/base/time.h
/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_BASE_TIME_H_
#define INCLUDE_PERFETTO_EXT_BASE_TIME_H_

#include <time.h>

#include <chrono>

// gen_amalgamated expanded: #include "perfetto/base/build_config.h"
// gen_amalgamated expanded: #include "perfetto/base/logging.h"

#if PERFETTO_BUILDFLAG(PERFETTO_OS_MACOSX)
#include <mach/mach_init.h>
#include <mach/mach_port.h>
#include <mach/mach_time.h>
#include <mach/thread_act.h>
#endif

#if PERFETTO_BUILDFLAG(PERFETTO_OS_WASM)
#include <emscripten/emscripten.h>
#endif

namespace perfetto {
namespace base {

using TimeSeconds = std::chrono::seconds;
using TimeMillis = std::chrono::milliseconds;
using TimeNanos = std::chrono::nanoseconds;

inline TimeNanos FromPosixTimespec(const struct timespec& ts) {
  return TimeNanos(ts.tv_sec * 1000000000LL + ts.tv_nsec);
}

void SleepMicroseconds(unsigned interval_us);

#if PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)

TimeNanos GetWallTimeNs();
TimeNanos GetThreadCPUTimeNs();

// TODO: Clock that counts time during suspend is not implemented on Windows.
inline TimeNanos GetBootTimeNs() {
  return GetWallTimeNs();
}

#elif PERFETTO_BUILDFLAG(PERFETTO_OS_MACOSX)

inline TimeNanos GetWallTimeNs() {
  auto init_time_factor = []() -> uint64_t {
    mach_timebase_info_data_t timebase_info;
    mach_timebase_info(&timebase_info);
    return timebase_info.numer / timebase_info.denom;
  };

  static uint64_t monotonic_timebase_factor = init_time_factor();
  return TimeNanos(mach_absolute_time() * monotonic_timebase_factor);
}

// TODO: Clock that counts time during suspend is not implemented on Mac.
inline TimeNanos GetBootTimeNs() {
  return GetWallTimeNs();
}

inline TimeNanos GetThreadCPUTimeNs() {
  mach_port_t this_thread = mach_thread_self();
  mach_msg_type_number_t count = THREAD_BASIC_INFO_COUNT;
  thread_basic_info_data_t info{};
  kern_return_t kr =
      thread_info(this_thread, THREAD_BASIC_INFO,
                  reinterpret_cast<thread_info_t>(&info), &count);
  mach_port_deallocate(mach_task_self(), this_thread);

  if (kr != KERN_SUCCESS) {
    PERFETTO_DFATAL("Failed to get CPU time.");
    return TimeNanos(0);
  }
  return TimeNanos(info.user_time.seconds * 1000000000LL +
                   info.user_time.microseconds * 1000LL +
                   info.system_time.seconds * 1000000000LL +
                   info.system_time.microseconds * 1000LL);
}

#elif PERFETTO_BUILDFLAG(PERFETTO_OS_WASM)

inline TimeNanos GetWallTimeNs() {
  return TimeNanos(static_cast<uint64_t>(emscripten_get_now()) * 1000000);
}

inline TimeNanos GetThreadCPUTimeNs() {
  return TimeNanos(0);
}

// TODO: Clock that counts time during suspend is not implemented on WASM.
inline TimeNanos GetBootTimeNs() {
  return GetWallTimeNs();
}

#else

constexpr clockid_t kWallTimeClockSource = CLOCK_MONOTONIC;

inline TimeNanos GetTimeInternalNs(clockid_t clk_id) {
  struct timespec ts = {};
  PERFETTO_CHECK(clock_gettime(clk_id, &ts) == 0);
  return FromPosixTimespec(ts);
}

// Return ns from boot. Conversely to GetWallTimeNs, this clock counts also time
// during suspend (when supported).
inline TimeNanos GetBootTimeNs() {
  // Determine if CLOCK_BOOTTIME is available on the first call.
  static const clockid_t kBootTimeClockSource = [] {
    struct timespec ts = {};
    int res = clock_gettime(CLOCK_BOOTTIME, &ts);
    return res == 0 ? CLOCK_BOOTTIME : kWallTimeClockSource;
  }();
  return GetTimeInternalNs(kBootTimeClockSource);
}

inline TimeNanos GetWallTimeNs() {
  return GetTimeInternalNs(kWallTimeClockSource);
}

inline TimeNanos GetThreadCPUTimeNs() {
  return GetTimeInternalNs(CLOCK_THREAD_CPUTIME_ID);
}

#endif

inline TimeMillis GetWallTimeMs() {
  return std::chrono::duration_cast<TimeMillis>(GetWallTimeNs());
}

inline TimeSeconds GetWallTimeS() {
  return std::chrono::duration_cast<TimeSeconds>(GetWallTimeNs());
}

inline struct timespec ToPosixTimespec(TimeMillis time) {
  struct timespec ts {};
  const long time_s = static_cast<long>(time.count() / 1000);
  ts.tv_sec = time_s;
  ts.tv_nsec = (static_cast<long>(time.count()) - time_s * 1000L) * 1000000L;
  return ts;
}

}  // namespace base
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_BASE_TIME_H_
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_BASE_METATRACE_H_
#define INCLUDE_PERFETTO_EXT_BASE_METATRACE_H_

#include <array>
#include <atomic>
#include <functional>
#include <string>

// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/metatrace_events.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/thread_annotations.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/thread_utils.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/time.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/utils.h"

// A facility to trace execution of the perfetto codebase itself.
// The meta-tracing framework is organized into three layers:
//
// 1. A static ring-buffer in base/ (this file) that supports concurrent writes
//    and a single reader.
//    The responsibility of this layer is to store events and counters as
//    efficiently as possible without re-entering any tracing code.
//    This is really a static-storage-based ring-buffer based on a POD array.
//    This layer does NOT deal with serializing the meta-trace buffer.
//    It posts a task when it's half full and expects something outside of
//    base/ to drain the ring-buffer and serialize it, eventually writing it
//    into the trace itself, before it gets 100% full.
//
// 2. A class in tracing/core which takes care of serializing the meta-trace
//    buffer into the trace using a TraceWriter. See metatrace_writer.h .
//
// 3. A data source in traced_probes that, when be enabled via the trace config,
//    injects metatrace events into the trace. See metatrace_data_source.h .
//
// The available events and tags are defined in metatrace_events.h .

namespace perfetto {

namespace base {
class TaskRunner;
}  // namespace base

namespace metatrace {

// Meta-tracing is organized in "tags" that can be selectively enabled. This is
// to enable meta-tracing only of one sub-system. This word has one "enabled"
// bit for each tag. 0 -> meta-tracing off.
extern std::atomic<uint32_t> g_enabled_tags;

// Time of the Enable() call. Used as a reference for keeping delta timestmaps
// in Record.
extern std::atomic<uint64_t> g_enabled_timestamp;

// Enables meta-tracing for one or more tags. Once enabled it will discard any
// futher Enable() calls and return false until disabled,
// |read_task| is a closure that will be called enqueued |task_runner| when the
// meta-tracing ring buffer is half full. The task is expected to read the ring
// buffer using RingBuffer::GetReadIterator() and serialize the contents onto a
// file or into the trace itself.
// Must be called on the |task_runner| passed.
// |task_runner| must have static lifetime.
bool Enable(std::function<void()> read_task, base::TaskRunner*, uint32_t tags);

// Disables meta-tracing.
// Must be called on the same |task_runner| as Enable().
void Disable();

inline uint64_t TraceTimeNowNs() {
  return static_cast<uint64_t>(base::GetBootTimeNs().count());
}

// Holds the data for a metatrace event or counter.
struct Record {
  static constexpr uint16_t kTypeMask = 0x8000;
  static constexpr uint16_t kTypeCounter = 0x8000;
  static constexpr uint16_t kTypeEvent = 0;

  uint64_t timestamp_ns() const {
    auto base_ns = g_enabled_timestamp.load(std::memory_order_relaxed);
    PERFETTO_DCHECK(base_ns);
    return base_ns + ((static_cast<uint64_t>(timestamp_ns_high) << 32) |
                      timestamp_ns_low);
  }

  void set_timestamp(uint64_t ts) {
    auto t_start = g_enabled_timestamp.load(std::memory_order_relaxed);
    uint64_t diff = ts - t_start;
    PERFETTO_DCHECK(diff < (1ull << 48));
    timestamp_ns_low = static_cast<uint32_t>(diff);
    timestamp_ns_high = static_cast<uint16_t>(diff >> 32);
  }

  // This field holds the type (counter vs event) in the MSB and event ID (as
  // defined in metatrace_events.h) in the lowest 15 bits. It is also used also
  // as a linearization point: this is always written after all the other
  // fields with a release-store. This is so the reader can determine whether it
  // can safely process the other event fields after a load-acquire.
  std::atomic<uint16_t> type_and_id;

  // Timestamp is stored as a 48-bits value diffed against g_enabled_timestamp.
  // This gives us 78 hours from Enabled().
  uint16_t timestamp_ns_high;
  uint32_t timestamp_ns_low;

  uint32_t thread_id;

  union {
    uint32_t duration_ns;   // If type == event.
    int32_t counter_value;  // If type == counter.
  };
};

// Hold the meta-tracing data into a statically allocated array.
// This class uses static storage (as opposite to being a singleton) to:
// - Have the guarantee of always valid storage, so that meta-tracing can be
//   safely used in any part of the codebase, including base/ itself.
// - Avoid barriers that thread-safe static locals would require.
class RingBuffer {
 public:
  static constexpr size_t kCapacity = 4096;  // 4096 * 16 bytes = 64K.

  // This iterator is not idempotent and will bump the read index in the buffer
  // at the end of the reads. There can be only one reader at any time.
  // Usage: for (auto it = RingBuffer::GetReadIterator(); it; ++it) { it->... }
  class ReadIterator {
   public:
    ReadIterator(ReadIterator&& other) {
      PERFETTO_DCHECK(other.valid_);
      cur_ = other.cur_;
      end_ = other.end_;
      valid_ = other.valid_;
      other.valid_ = false;
    }

    ~ReadIterator() {
      if (!valid_)
        return;
      PERFETTO_DCHECK(cur_ >= RingBuffer::rd_index_);
      PERFETTO_DCHECK(cur_ <= RingBuffer::wr_index_);
      RingBuffer::rd_index_.store(cur_, std::memory_order_release);
    }

    explicit operator bool() const { return cur_ < end_; }
    const Record* operator->() const { return RingBuffer::At(cur_); }
    const Record& operator*() const { return *operator->(); }

    // This is for ++it. it++ is deliberately not supported.
    ReadIterator& operator++() {
      PERFETTO_DCHECK(cur_ < end_);
      // Once a record has been read, mark it as free clearing its type_and_id,
      // so if we encounter it in another read iteration while being written
      // we know it's not fully written yet.
      // The memory_order_relaxed below is enough because:
      // - The reader is single-threaded and doesn't re-read the same records.
      // - Before starting a read batch, the reader has an acquire barrier on
      //   |rd_index_|.
      // - After terminating a read batch, the ~ReadIterator dtor updates the
      //   |rd_index_| with a release-store.
      // - Reader and writer are typically kCapacity/2 apart. So unless an
      //   overrun happens a writer won't reuse a newly released record any time
      //   soon. If an overrun happens, everything is busted regardless.
      At(cur_)->type_and_id.store(0, std::memory_order_relaxed);
      ++cur_;
      return *this;
    }

   private:
    friend class RingBuffer;
    ReadIterator(uint64_t begin, uint64_t end)
        : cur_(begin), end_(end), valid_(true) {}
    ReadIterator& operator=(const ReadIterator&) = delete;
    ReadIterator(const ReadIterator&) = delete;

    uint64_t cur_;
    uint64_t end_;
    bool valid_;
  };

  static Record* At(uint64_t index) {
    // Doesn't really have to be pow2, but if not the compiler will emit
    // arithmetic operations to compute the modulo instead of a bitwise AND.
    static_assert(!(kCapacity & (kCapacity - 1)), "kCapacity must be pow2");
    PERFETTO_DCHECK(index >= rd_index_);
    PERFETTO_DCHECK(index <= wr_index_);
    return &records_[index % kCapacity];
  }

  // Must be called on the same task runner passed to Enable()
  static ReadIterator GetReadIterator() {
    PERFETTO_DCHECK(RingBuffer::IsOnValidTaskRunner());
    return ReadIterator(rd_index_.load(std::memory_order_acquire),
                        wr_index_.load(std::memory_order_acquire));
  }

  static Record* AppendNewRecord();
  static void Reset();

  static bool has_overruns() {
    return has_overruns_.load(std::memory_order_acquire);
  }

  // Can temporarily return a value >= kCapacity but is eventually consistent.
  // This would happen in case of overruns until threads hit the --wr_index_
  // in AppendNewRecord().
  static uint64_t GetSizeForTesting() {
    auto wr_index = wr_index_.load(std::memory_order_relaxed);
    auto rd_index = rd_index_.load(std::memory_order_relaxed);
    PERFETTO_DCHECK(wr_index >= rd_index);
    return wr_index - rd_index;
  }

 private:
  friend class ReadIterator;

  // Returns true if the caller is on the task runner passed to Enable().
  // Used only for DCHECKs.
  static bool IsOnValidTaskRunner();

  static std::array<Record, kCapacity> records_;
  static std::atomic<bool> read_task_queued_;
  static std::atomic<uint64_t> wr_index_;
  static std::atomic<uint64_t> rd_index_;
  static std::atomic<bool> has_overruns_;
  static Record bankruptcy_record_;  // Used in case of overruns.
};

inline void TraceCounter(uint32_t tag, uint16_t id, int32_t value) {
  // memory_order_relaxed is okay because the storage has static lifetime.
  // It is safe to accidentally log an event soon after disabling.
  auto enabled_tags = g_enabled_tags.load(std::memory_order_relaxed);
  if (PERFETTO_LIKELY((enabled_tags & tag) == 0))
    return;
  Record* record = RingBuffer::AppendNewRecord();
  record->thread_id = static_cast<uint32_t>(base::GetThreadId());
  record->set_timestamp(TraceTimeNowNs());
  record->counter_value = value;
  record->type_and_id.store(Record::kTypeCounter | id,
                            std::memory_order_release);
}

class ScopedEvent {
 public:
  ScopedEvent(uint32_t tag, uint16_t event_id) {
    auto enabled_tags = g_enabled_tags.load(std::memory_order_relaxed);
    if (PERFETTO_LIKELY((enabled_tags & tag) == 0))
      return;
    event_id_ = event_id;
    record_ = RingBuffer::AppendNewRecord();
    record_->thread_id = static_cast<uint32_t>(base::GetThreadId());
    record_->set_timestamp(TraceTimeNowNs());
  }

  ~ScopedEvent() {
    if (PERFETTO_LIKELY(!record_))
      return;
    auto now = TraceTimeNowNs();
    record_->duration_ns = static_cast<uint32_t>(now - record_->timestamp_ns());
    record_->type_and_id.store(Record::kTypeEvent | event_id_,
                               std::memory_order_release);
  }

 private:
  Record* record_ = nullptr;
  uint16_t event_id_ = 0;
  ScopedEvent(const ScopedEvent&) = delete;
  ScopedEvent& operator=(const ScopedEvent&) = delete;
};

// Boilerplate to derive a unique variable name for the event.
#define PERFETTO_METATRACE_UID2(a, b) a##b
#define PERFETTO_METATRACE_UID(x) PERFETTO_METATRACE_UID2(metatrace_, x)

#define PERFETTO_METATRACE_SCOPED(TAG, ID)                                \
  ::perfetto::metatrace::ScopedEvent PERFETTO_METATRACE_UID(__COUNTER__)( \
      ::perfetto::metatrace::TAG, ::perfetto::metatrace::ID)

#define PERFETTO_METATRACE_COUNTER(TAG, ID, VALUE)                \
  ::perfetto::metatrace::TraceCounter(::perfetto::metatrace::TAG, \
                                      ::perfetto::metatrace::ID,  \
                                      static_cast<int32_t>(VALUE))

}  // namespace metatrace
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_BASE_METATRACE_H_
// gen_amalgamated begin header: include/perfetto/base/task_runner.h
// gen_amalgamated begin header: include/perfetto/base/export.h
/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_BASE_EXPORT_H_
#define INCLUDE_PERFETTO_BASE_EXPORT_H_

// gen_amalgamated expanded: #include "perfetto/base/build_config.h"

#if defined(PERFETTO_SHARED_LIBRARY)

#if PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)

#if defined(PERFETTO_IMPLEMENTATION)
#define PERFETTO_EXPORT __declspec(dllexport)
#else
#define PERFETTO_EXPORT __declspec(dllimport)
#endif

#else  // PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)

#if defined(PERFETTO_IMPLEMENTATION)
#define PERFETTO_EXPORT __attribute__((visibility("default")))
#else
#define PERFETTO_EXPORT
#endif

#endif  // PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)

#else  // defined(PERFETTO_SHARED_LIBRARY)

#define PERFETTO_EXPORT

#endif  // defined(PERFETTO_SHARED_LIBRARY)

#endif  // INCLUDE_PERFETTO_BASE_EXPORT_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_BASE_TASK_RUNNER_H_
#define INCLUDE_PERFETTO_BASE_TASK_RUNNER_H_

#include <functional>

// gen_amalgamated expanded: #include "perfetto/base/export.h"

namespace perfetto {
namespace base {

// A generic interface to allow the library clients to interleave the execution
// of the tracing internals in their runtime environment.
// The expectation is that all tasks, which are queued either via PostTask() or
// AddFileDescriptorWatch(), are executed on the same sequence (either on the
// same thread, or on a thread pool that gives sequencing guarantees).
//
// Tasks are never executed synchronously inside PostTask and there is a full
// memory barrier between tasks.
//
// All methods of this interface can be called from any thread.
class PERFETTO_EXPORT TaskRunner {
 public:
  virtual ~TaskRunner();

  // Schedule a task for immediate execution. Immediate tasks are always
  // executed in the order they are posted. Can be called from any thread.
  virtual void PostTask(std::function<void()>) = 0;

  // Schedule a task for execution after |delay_ms|. Note that there is no
  // strict ordering guarantee between immediate and delayed tasks. Can be
  // called from any thread.
  virtual void PostDelayedTask(std::function<void()>, uint32_t delay_ms) = 0;

  // Schedule a task to run when |fd| becomes readable. The same |fd| can only
  // be monitored by one function. Note that this function only needs to be
  // implemented on platforms where the built-in ipc framework is used. Can be
  // called from any thread.
  // TODO(skyostil): Refactor this out of the shared interface.
  virtual void AddFileDescriptorWatch(int fd, std::function<void()>) = 0;

  // Remove a previously scheduled watch for |fd|. If this is run on the target
  // thread of this TaskRunner, guarantees that the task registered to this fd
  // will not be executed after this function call. Can be called from any
  // thread.
  virtual void RemoveFileDescriptorWatch(int fd) = 0;

  // Checks if the current thread is the same thread where the TaskRunner's task
  // run. This allows single threaded task runners (like the ones used in
  // perfetto) to inform the caller that anything posted will run on the same
  // thread/sequence. This can allow some callers to skip PostTask and instead
  // directly execute the code. Can be called from any thread.
  virtual bool RunsTasksOnCurrentThread() const = 0;
};

}  // namespace base
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_BASE_TASK_RUNNER_H_
/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "perfetto/ext/base/metatrace.h"

// gen_amalgamated expanded: #include "perfetto/base/compiler.h"
// gen_amalgamated expanded: #include "perfetto/base/task_runner.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/file_utils.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/time.h"

namespace perfetto {
namespace metatrace {

std::atomic<uint32_t> g_enabled_tags{0};
std::atomic<uint64_t> g_enabled_timestamp{0};

// static members
constexpr size_t RingBuffer::kCapacity;
std::array<Record, RingBuffer::kCapacity> RingBuffer::records_;
std::atomic<bool> RingBuffer::read_task_queued_;
std::atomic<uint64_t> RingBuffer::wr_index_;
std::atomic<uint64_t> RingBuffer::rd_index_;
std::atomic<bool> RingBuffer::has_overruns_;
Record RingBuffer::bankruptcy_record_;

constexpr uint16_t Record::kTypeMask;
constexpr uint16_t Record::kTypeCounter;
constexpr uint16_t Record::kTypeEvent;

namespace {

// std::function<> is not trivially de/constructible. This struct wraps it in a
// heap-allocated struct to avoid static initializers.
struct Delegate {
  static Delegate* GetInstance() {
    static Delegate* instance = new Delegate();
    return instance;
  }

  base::TaskRunner* task_runner = nullptr;
  std::function<void()> read_task;
};

}  // namespace

bool Enable(std::function<void()> read_task,
            base::TaskRunner* task_runner,
            uint32_t tags) {
  PERFETTO_DCHECK(read_task);
  PERFETTO_DCHECK(task_runner->RunsTasksOnCurrentThread());
  if (g_enabled_tags.load(std::memory_order_acquire))
    return false;

  Delegate* dg = Delegate::GetInstance();
  dg->task_runner = task_runner;
  dg->read_task = std::move(read_task);
  RingBuffer::Reset();
  g_enabled_timestamp.store(TraceTimeNowNs(), std::memory_order_relaxed);
  g_enabled_tags.store(tags, std::memory_order_release);
  return true;
}

void Disable() {
  g_enabled_tags.store(0, std::memory_order_release);
  Delegate* dg = Delegate::GetInstance();
  PERFETTO_DCHECK(!dg->task_runner ||
                  dg->task_runner->RunsTasksOnCurrentThread());
  dg->task_runner = nullptr;
  dg->read_task = nullptr;
}

// static
void RingBuffer::Reset() {
  static_assert(PERFETTO_IS_TRIVIALLY_CONSTRUCTIBLE(Record) &&
                    std::is_trivially_destructible<Record>::value,
                "Record must be trivial");
  memset(&records_[0], 0, sizeof(records_));
  memset(&bankruptcy_record_, 0, sizeof(bankruptcy_record_));
  wr_index_ = 0;
  rd_index_ = 0;
  has_overruns_ = false;
  read_task_queued_ = false;
}

// static
Record* RingBuffer::AppendNewRecord() {
  auto wr_index = wr_index_.fetch_add(1, std::memory_order_acq_rel);

  // rd_index can only monotonically increase, we don't care if we read an
  // older value, we'll just hit the slow-path a bit earlier if it happens.
  auto rd_index = rd_index_.load(std::memory_order_relaxed);

  PERFETTO_DCHECK(wr_index >= rd_index);
  auto size = wr_index - rd_index;
  if (PERFETTO_LIKELY(size < kCapacity / 2))
    return At(wr_index);

  // Slow-path: Enqueue the read task and handle overruns.
  bool expected = false;
  if (RingBuffer::read_task_queued_.compare_exchange_strong(expected, true)) {
    Delegate* dg = Delegate::GetInstance();
    if (dg->task_runner) {
      dg->task_runner->PostTask([] {
        // Meta-tracing might have been disabled in the meantime.
        auto read_task = Delegate::GetInstance()->read_task;
        if (read_task)
          read_task();
        RingBuffer::read_task_queued_ = false;
      });
    }
  }

  if (PERFETTO_LIKELY(size < kCapacity))
    return At(wr_index);

  has_overruns_.store(true, std::memory_order_release);
  wr_index_.fetch_sub(1, std::memory_order_acq_rel);

  // In the case of overflows, threads will race writing on the same memory
  // location and TSan will rightly complain. This is fine though because nobody
  // will read the bankruptcy record and it's designed to contain garbage.
  PERFETTO_ANNOTATE_BENIGN_RACE_SIZED(&bankruptcy_record_, sizeof(Record),
                                      "nothing reads bankruptcy_record_")
  return &bankruptcy_record_;
}

// static
bool RingBuffer::IsOnValidTaskRunner() {
  auto* task_runner = Delegate::GetInstance()->task_runner;
  return task_runner && task_runner->RunsTasksOnCurrentThread();
}

}  // namespace metatrace
}  // namespace perfetto
// gen_amalgamated begin source: src/base/paged_memory.cc
// gen_amalgamated begin header: include/perfetto/ext/base/paged_memory.h
// gen_amalgamated begin header: include/perfetto/ext/base/container_annotations.h
/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_BASE_CONTAINER_ANNOTATIONS_H_
#define INCLUDE_PERFETTO_EXT_BASE_CONTAINER_ANNOTATIONS_H_

// gen_amalgamated expanded: #include "perfetto/base/build_config.h"

// Windows ASAN doesn't currently support these annotations.
#if defined(ADDRESS_SANITIZER) && !PERFETTO_BUILDFLAG(PERFETTO_OS_WIN) && \
    !defined(ADDRESS_SANITIZER_WITHOUT_INSTRUMENTATION)

#define ANNOTATE_NEW_BUFFER(buffer, capacity, new_size)                      \
  if (buffer) {                                                              \
    __sanitizer_annotate_contiguous_container(buffer, (buffer) + (capacity), \
                                              (buffer) + (capacity),         \
                                              (buffer) + (new_size));        \
  }
#define ANNOTATE_DELETE_BUFFER(buffer, capacity, old_size)                   \
  if (buffer) {                                                              \
    __sanitizer_annotate_contiguous_container(buffer, (buffer) + (capacity), \
                                              (buffer) + (old_size),         \
                                              (buffer) + (capacity));        \
  }
#define ANNOTATE_CHANGE_SIZE(buffer, capacity, old_size, new_size)           \
  if (buffer) {                                                              \
    __sanitizer_annotate_contiguous_container(buffer, (buffer) + (capacity), \
                                              (buffer) + (old_size),         \
                                              (buffer) + (new_size));        \
  }
#define ANNOTATE_CHANGE_CAPACITY(buffer, old_capacity, buffer_size, \
                                 new_capacity)                      \
  ANNOTATE_DELETE_BUFFER(buffer, old_capacity, buffer_size);        \
  ANNOTATE_NEW_BUFFER(buffer, new_capacity, buffer_size);
// Annotations require buffers to begin on an 8-byte boundary.
#else  // defined(ADDRESS_SANITIZER)
#define ANNOTATE_NEW_BUFFER(buffer, capacity, new_size)
#define ANNOTATE_DELETE_BUFFER(buffer, capacity, old_size)
#define ANNOTATE_CHANGE_SIZE(buffer, capacity, old_size, new_size)
#define ANNOTATE_CHANGE_CAPACITY(buffer, old_capacity, buffer_size, \
                                 new_capacity)
#endif  // defined(ADDRESS_SANITIZER)

#endif  // INCLUDE_PERFETTO_EXT_BASE_CONTAINER_ANNOTATIONS_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_BASE_PAGED_MEMORY_H_
#define INCLUDE_PERFETTO_EXT_BASE_PAGED_MEMORY_H_

#include <memory>

// gen_amalgamated expanded: #include "perfetto/base/build_config.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/container_annotations.h"

// We need to track the committed size on windows and when ASAN is enabled.
#if PERFETTO_BUILDFLAG(PERFETTO_OS_WIN) || defined(ADDRESS_SANITIZER)
#define TRACK_COMMITTED_SIZE() 1
#else
#define TRACK_COMMITTED_SIZE() 0
#endif

namespace perfetto {
namespace base {

class PagedMemory {
 public:
  // Initializes an invalid PagedMemory pointing to nullptr.
  PagedMemory();

  ~PagedMemory();

  PagedMemory(PagedMemory&& other) noexcept;
  PagedMemory& operator=(PagedMemory&& other);

  enum AllocationFlags {
    // By default, Allocate() crashes if the underlying mmap fails (e.g., if out
    // of virtual address space). When this flag is provided, an invalid
    // PagedMemory pointing to nullptr is returned in this case instead.
    kMayFail = 1 << 0,

    // By default, Allocate() commits the allocated memory immediately. When
    // this flag is provided, the memory virtual address space may only be
    // reserved and the user should call EnsureCommitted() before writing to
    // memory addresses.
    kDontCommit = 1 << 1,
  };

  // Allocates |size| bytes using mmap(MAP_ANONYMOUS). The returned memory is
  // guaranteed to be page-aligned and guaranteed to be zeroed. |size| must be a
  // multiple of 4KB (a page size). For |flags|, see the AllocationFlags enum
  // above.
  static PagedMemory Allocate(size_t size, int flags = 0);

  // Hint to the OS that the memory range is not needed and can be discarded.
  // The memory remains accessible and its contents may be retained, or they
  // may be zeroed. This function may be a NOP on some platforms. Returns true
  // if implemented.
  bool AdviseDontNeed(void* p, size_t size);

  // Ensures that at least the first |committed_size| bytes of the allocated
  // memory region are committed. The implementation may commit memory in larger
  // chunks above |committed_size|. Crashes if the memory couldn't be committed.
#if TRACK_COMMITTED_SIZE()
  void EnsureCommitted(size_t committed_size);
#else   // TRACK_COMMITTED_SIZE()
  void EnsureCommitted(size_t /*committed_size*/) {}
#endif  // TRACK_COMMITTED_SIZE()

  inline void* Get() const noexcept { return p_; }
  inline bool IsValid() const noexcept { return !!p_; }
  inline size_t size() const noexcept { return size_; }

 private:
  PagedMemory(char* p, size_t size);

  PagedMemory(const PagedMemory&) = delete;
  // Defaulted for implementation of move constructor + assignment.
  PagedMemory& operator=(const PagedMemory&) = default;

  char* p_ = nullptr;
  size_t size_ = 0;

#if TRACK_COMMITTED_SIZE()
  size_t committed_size_ = 0u;
#endif  // TRACK_COMMITTED_SIZE()
};

}  // namespace base
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_BASE_PAGED_MEMORY_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "perfetto/ext/base/paged_memory.h"

#include <algorithm>
#include <cmath>

#if PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)
#include <Windows.h>
#else  // PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)
#include <sys/mman.h>
#endif  // PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)

// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/container_annotations.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/utils.h"

namespace perfetto {
namespace base {

namespace {

constexpr size_t kGuardSize = kPageSize;

#if TRACK_COMMITTED_SIZE()
constexpr size_t kCommitChunkSize = kPageSize * 1024;  // 4mB
#endif                                                 // TRACK_COMMITTED_SIZE()

}  // namespace

// static
PagedMemory PagedMemory::Allocate(size_t size, int flags) {
  PERFETTO_DCHECK(size % kPageSize == 0);
  size_t outer_size = size + kGuardSize * 2;
#if PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)
  void* ptr = VirtualAlloc(nullptr, outer_size, MEM_RESERVE, PAGE_NOACCESS);
  if (!ptr && (flags & kMayFail))
    return PagedMemory();
  PERFETTO_CHECK(ptr);
  char* usable_region = reinterpret_cast<char*>(ptr) + kGuardSize;
#else   // PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)
  void* ptr = mmap(nullptr, outer_size, PROT_READ | PROT_WRITE,
                   MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  if (ptr == MAP_FAILED && (flags & kMayFail))
    return PagedMemory();
  PERFETTO_CHECK(ptr && ptr != MAP_FAILED);
  char* usable_region = reinterpret_cast<char*>(ptr) + kGuardSize;
  int res = mprotect(ptr, kGuardSize, PROT_NONE);
  res |= mprotect(usable_region + size, kGuardSize, PROT_NONE);
  PERFETTO_CHECK(res == 0);
#endif  // PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)

  auto memory = PagedMemory(usable_region, size);
#if TRACK_COMMITTED_SIZE()
  size_t initial_commit = size;
  if (flags & kDontCommit)
    initial_commit = std::min(initial_commit, kCommitChunkSize);
  memory.EnsureCommitted(initial_commit);
#endif  // TRACK_COMMITTED_SIZE()
  return memory;
}

PagedMemory::PagedMemory() {}

PagedMemory::PagedMemory(char* p, size_t size)
    : p_(p),
      size_(size){ANNOTATE_NEW_BUFFER(p_, size_, committed_size_)}

      PagedMemory::PagedMemory(PagedMemory && other) noexcept {
  *this = other;
  other.p_ = nullptr;
}

PagedMemory& PagedMemory::operator=(PagedMemory&& other) {
  *this = other;
  other.p_ = nullptr;
  return *this;
}

PagedMemory::~PagedMemory() {
  if (!p_)
    return;
  PERFETTO_CHECK(size_);
  char* start = p_ - kGuardSize;
#if PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)
  BOOL res = VirtualFree(start, 0, MEM_RELEASE);
  PERFETTO_CHECK(res != 0);
#else   // PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)
  const size_t outer_size = size_ + kGuardSize * 2;
  int res = munmap(start, outer_size);
  PERFETTO_CHECK(res == 0);
#endif  // PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)
  ANNOTATE_DELETE_BUFFER(p_, size_, committed_size_)
}

bool PagedMemory::AdviseDontNeed(void* p, size_t size) {
  PERFETTO_DCHECK(p_);
  PERFETTO_DCHECK(p >= p_);
  PERFETTO_DCHECK(static_cast<char*>(p) + size <= p_ + size_);
#if PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)
  // Discarding pages on Windows has more CPU cost than is justified for the
  // possible memory savings.
  return false;
#else   // PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)
  // http://man7.org/linux/man-pages/man2/madvise.2.html
  int res = madvise(p, size, MADV_DONTNEED);
  PERFETTO_DCHECK(res == 0);
  return true;
#endif  // PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)
}

#if TRACK_COMMITTED_SIZE()
void PagedMemory::EnsureCommitted(size_t committed_size) {
  PERFETTO_DCHECK(committed_size > 0u);
  PERFETTO_DCHECK(committed_size <= size_);
#if PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)
  if (committed_size_ >= committed_size)
    return;
  // Rounding up.
  size_t delta = committed_size - committed_size_;
  size_t num_additional_chunks =
      (delta + kCommitChunkSize - 1) / kCommitChunkSize;
  PERFETTO_DCHECK(num_additional_chunks * kCommitChunkSize >= delta);
  // Don't commit more than the total size.
  size_t commit_size = std::min(num_additional_chunks * kCommitChunkSize,
                                size_ - committed_size_);
  void* res = VirtualAlloc(p_ + committed_size_, commit_size, MEM_COMMIT,
                           PAGE_READWRITE);
  PERFETTO_CHECK(res);
  ANNOTATE_CHANGE_SIZE(p_, size_, committed_size_,
                       committed_size_ + commit_size)
  committed_size_ += commit_size;
#else   // PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)
  // mmap commits automatically as needed, so we only track here for ASAN.
  committed_size = std::max(committed_size_, committed_size);
  ANNOTATE_CHANGE_SIZE(p_, size_, committed_size_, committed_size)
  committed_size_ = committed_size;
#endif  // PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)
}
#endif  // TRACK_COMMITTED_SIZE()

}  // namespace base
}  // namespace perfetto
// gen_amalgamated begin source: src/base/string_splitter.cc
// gen_amalgamated begin header: include/perfetto/ext/base/string_splitter.h
/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_BASE_STRING_SPLITTER_H_
#define INCLUDE_PERFETTO_EXT_BASE_STRING_SPLITTER_H_

#include <string>

namespace perfetto {
namespace base {

// C++ version of strtok(). Splits a string without making copies or any heap
// allocations. Destructs the original string passed in input.
// Supports the special case of using \0 as a delimiter.
// The token returned in output are valid as long as the input string is valid.
class StringSplitter {
 public:
  // Can take ownership of the string if passed via std::move(), e.g.:
  // StringSplitter(std::move(str), '\n');
  StringSplitter(std::string, char delimiter);

  // Splits a C-string. The input string will be forcefully null-terminated (so
  // str[size - 1] should be == '\0' or the last char will be truncated).
  StringSplitter(char* str, size_t size, char delimiter);

  // Splits the current token from an outer StringSplitter instance. This is to
  // chain splitters as follows:
  // for (base::StringSplitter lines(x, '\n'); ss.Next();)
  //   for (base::StringSplitter words(&lines, ' '); words.Next();)
  StringSplitter(StringSplitter*, char delimiter);

  // Returns true if a token is found (in which case it will be stored in
  // cur_token()), false if no more tokens are found.
  bool Next();

  // Returns the current token iff last call to Next() returned true. In this
  // case it guarantees that the returned string is always null terminated.
  // In all other cases (before the 1st call to Next() and after Next() returns
  // false) returns nullptr.
  char* cur_token() { return cur_; }

  // Returns the length of the current token (excluding the null terminator).
  size_t cur_token_size() const { return cur_size_; }

 private:
  StringSplitter(const StringSplitter&) = delete;
  StringSplitter& operator=(const StringSplitter&) = delete;
  void Initialize(char* str, size_t size);

  std::string str_;
  char* cur_;
  size_t cur_size_;
  char* next_;
  char* end_;  // STL-style, points one past the last char.
  const char delimiter_;
};

}  // namespace base
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_BASE_STRING_SPLITTER_H_
/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "perfetto/ext/base/string_splitter.h"

#include <utility>

// gen_amalgamated expanded: #include "perfetto/base/logging.h"

namespace perfetto {
namespace base {

StringSplitter::StringSplitter(std::string str, char delimiter)
    : str_(std::move(str)), delimiter_(delimiter) {
  // It's legal to access str[str.size()] in C++11 (it always returns \0),
  // hence the +1 (which becomes just size() after the -1 in Initialize()).
  Initialize(&str_[0], str_.size() + 1);
}

StringSplitter::StringSplitter(char* str, size_t size, char delimiter)
    : delimiter_(delimiter) {
  Initialize(str, size);
}

StringSplitter::StringSplitter(StringSplitter* outer, char delimiter)
    : delimiter_(delimiter) {
  Initialize(outer->cur_token(), outer->cur_token_size() + 1);
}

void StringSplitter::Initialize(char* str, size_t size) {
  PERFETTO_DCHECK(!size || str);
  next_ = str;
  end_ = str + size;
  cur_ = nullptr;
  cur_size_ = 0;
  if (size)
    next_[size - 1] = '\0';
}

bool StringSplitter::Next() {
  for (; next_ < end_; next_++) {
    if (*next_ == delimiter_)
      continue;
    cur_ = next_;
    for (;; next_++) {
      if (*next_ == delimiter_) {
        cur_size_ = static_cast<size_t>(next_ - cur_);
        *(next_++) = '\0';
        break;
      }
      if (*next_ == '\0') {
        cur_size_ = static_cast<size_t>(next_ - cur_);
        next_ = end_;
        break;
      }
    }
    if (*cur_)
      return true;
    break;
  }
  cur_ = nullptr;
  cur_size_ = 0;
  return false;
}

}  // namespace base
}  // namespace perfetto
// gen_amalgamated begin source: src/base/string_utils.cc
// gen_amalgamated begin header: include/perfetto/ext/base/string_utils.h
/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_BASE_STRING_UTILS_H_
#define INCLUDE_PERFETTO_EXT_BASE_STRING_UTILS_H_

#include <string>
#include <vector>

namespace perfetto {
namespace base {

bool StartsWith(const std::string& str, const std::string& prefix);
bool EndsWith(const std::string& str, const std::string& suffix);
bool Contains(const std::string& haystack, const std::string& needle);
bool CaseInsensitiveEqual(const std::string& first, const std::string& second);
std::string Join(const std::vector<std::string>& parts,
                 const std::string& delim);
std::vector<std::string> SplitString(const std::string& text,
                                     const std::string& delimiter);

}  // namespace base
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_BASE_STRING_UTILS_H_
/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "perfetto/ext/base/string_utils.h"

#include <algorithm>

// gen_amalgamated expanded: #include "perfetto/base/logging.h"

namespace perfetto {
namespace base {

bool StartsWith(const std::string& str, const std::string& prefix) {
  return str.compare(0, prefix.length(), prefix) == 0;
}

bool EndsWith(const std::string& str, const std::string& suffix) {
  if (suffix.size() > str.size())
    return false;
  return str.compare(str.size() - suffix.size(), suffix.size(), suffix) == 0;
}

bool Contains(const std::string& haystack, const std::string& needle) {
  return haystack.find(needle) != std::string::npos;
}

bool CaseInsensitiveEqual(const std::string& first, const std::string& second) {
  return first.size() == second.size() &&
         std::equal(first.begin(), first.end(), second.begin(),
                    [](char a, char b) { return tolower(a) == tolower(b); });
}

std::string Join(const std::vector<std::string>& parts,
                 const std::string& delim) {
  std::string acc;
  for (size_t i = 0; i < parts.size(); ++i) {
    acc += parts[i];
    if (i + 1 != parts.size()) {
      acc += delim;
    }
  }
  return acc;
}

std::vector<std::string> SplitString(const std::string& text,
                                     const std::string& delimiter) {
  PERFETTO_CHECK(!delimiter.empty());

  std::vector<std::string> output;
  size_t start = 0;
  size_t next;
  for (;;) {
    next = std::min(text.find(delimiter, start), text.size());
    output.emplace_back(&text[start], next - start);
    start = next + delimiter.size();
    if (start >= text.size())
      break;
  }
  return output;
}

}  // namespace base
}  // namespace perfetto
// gen_amalgamated begin source: src/base/string_view.cc
// gen_amalgamated begin header: include/perfetto/ext/base/string_view.h
// gen_amalgamated begin header: include/perfetto/ext/base/hash.h
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_BASE_HASH_H_
#define INCLUDE_PERFETTO_EXT_BASE_HASH_H_

#include <stddef.h>
#include <stdint.h>
#include <type_traits>

namespace perfetto {
namespace base {

// A helper class which computes a 64-bit hash of the input data.
// The algorithm used is FNV-1a as it is fast and easy to implement and has
// relatively few collisions.
// WARNING: This hash function should not be used for any cryptographic purpose.
class Hash {
 public:
  // Creates an empty hash object
  Hash() {}

  // Hashes a numeric value.
  template <typename T,
            typename std::enable_if<std::is_arithmetic<T>::value>* = nullptr>
  void Update(T data) {
    Update(reinterpret_cast<const char*>(&data), sizeof(data));
  }

  // Hashes a byte array.
  void Update(const char* data, size_t size) {
    for (size_t i = 0; i < size; i++) {
      result_ ^= static_cast<uint8_t>(data[i]);
      result_ *= kFnv1a64Prime;
    }
  }

  uint64_t digest() { return result_; }

 private:
  static constexpr uint64_t kFnv1a64OffsetBasis = 0xcbf29ce484222325;
  static constexpr uint64_t kFnv1a64Prime = 0x100000001b3;

  uint64_t result_ = kFnv1a64OffsetBasis;
};

}  // namespace base
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_BASE_HASH_H_
/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_BASE_STRING_VIEW_H_
#define INCLUDE_PERFETTO_EXT_BASE_STRING_VIEW_H_

#include <string.h>

#include <algorithm>
#include <string>

// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/hash.h"

namespace perfetto {
namespace base {

// A string-like object that refers to a non-owned piece of memory.
// Strings are internally NOT null terminated.
class StringView {
 public:
  static constexpr size_t npos = static_cast<size_t>(-1);

  StringView() : data_(nullptr), size_(0) {}
  StringView(const StringView&) = default;
  StringView& operator=(const StringView&) = default;
  StringView(const char* data, size_t size) : data_(data), size_(size) {
    PERFETTO_DCHECK(data != nullptr);
  }

  // Allow implicit conversion from any class that has a |data| and |size| field
  // and has the kConvertibleToStringView trait (e.g., protozero::ConstChars).
  template <typename T, typename = std::enable_if<T::kConvertibleToStringView>>
  StringView(const T& x) : StringView(x.data, x.size) {
    PERFETTO_DCHECK(x.data != nullptr);
  }

  // Creates a StringView from a null-terminated C string.
  // Deliberately not "explicit".
  StringView(const char* cstr) : data_(cstr), size_(strlen(cstr)) {
    PERFETTO_DCHECK(cstr != nullptr);
  }

  // This instead has to be explicit, as creating a StringView out of a
  // std::string can be subtle.
  explicit StringView(const std::string& str)
      : data_(str.data()), size_(str.size()) {}

  bool empty() const { return size_ == 0; }
  size_t size() const { return size_; }
  const char* data() const { return data_; }
  const char* begin() const { return data_; }
  const char* end() const { return data_ + size_; }

  char at(size_t pos) const {
    PERFETTO_DCHECK(pos < size_);
    return data_[pos];
  }

  size_t find(char c) const {
    for (size_t i = 0; i < size_; ++i) {
      if (data_[i] == c)
        return i;
    }
    return npos;
  }

  size_t rfind(char c) const {
    for (size_t i = size_; i > 0; --i) {
      if (data_[i - 1] == c)
        return i - 1;
    }
    return npos;
  }

  StringView substr(size_t pos, size_t count = npos) const {
    if (pos >= size_)
      return StringView("", 0);
    size_t rcount = std::min(count, size_ - pos);
    return StringView(data_ + pos, rcount);
  }

  std::string ToStdString() const {
    return data_ == nullptr ? "" : std::string(data_, size_);
  }

  uint64_t Hash() const {
    base::Hash hasher;
    hasher.Update(data_, size_);
    return hasher.digest();
  }

 private:
  const char* data_ = nullptr;
  size_t size_ = 0;
};

inline bool operator==(const StringView& x, const StringView& y) {
  if (x.size() != y.size())
    return false;
  if (x.size() == 0)
    return true;
  return memcmp(x.data(), y.data(), x.size()) == 0;
}

inline bool operator!=(const StringView& x, const StringView& y) {
  return !(x == y);
}

inline bool operator<(const StringView& x, const StringView& y) {
  auto size = std::min(x.size(), y.size());
  if (size == 0)
    return x.size() < y.size();
  int result = memcmp(x.data(), y.data(), size);
  return result < 0 || (result == 0 && x.size() < y.size());
}

inline bool operator>=(const StringView& x, const StringView& y) {
  return !(x < y);
}

inline bool operator>(const StringView& x, const StringView& y) {
  return y < x;
}

inline bool operator<=(const StringView& x, const StringView& y) {
  return !(y < x);
}

}  // namespace base
}  // namespace perfetto

namespace std {

template <>
struct hash<::perfetto::base::StringView> {
  size_t operator()(const ::perfetto::base::StringView& sv) const {
    return static_cast<size_t>(sv.Hash());
  }
};

}  // namespace std

#endif  // INCLUDE_PERFETTO_EXT_BASE_STRING_VIEW_H_
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "perfetto/ext/base/string_view.h"

namespace perfetto {
namespace base {

// static
constexpr size_t StringView::npos;

}  // namespace base
}  // namespace perfetto
// gen_amalgamated begin source: src/base/thread_checker.cc
// gen_amalgamated begin header: include/perfetto/ext/base/thread_checker.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_BASE_THREAD_CHECKER_H_
#define INCLUDE_PERFETTO_EXT_BASE_THREAD_CHECKER_H_

// gen_amalgamated expanded: #include "perfetto/base/build_config.h"

#if !PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)
#include <pthread.h>
#endif
#include <atomic>

// gen_amalgamated expanded: #include "perfetto/base/export.h"
// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/utils.h"

namespace perfetto {
namespace base {

#if PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)
using ThreadID = unsigned long;
#else
using ThreadID = pthread_t;
#endif

class PERFETTO_EXPORT ThreadChecker {
 public:
  ThreadChecker();
  ~ThreadChecker();
  ThreadChecker(const ThreadChecker&);
  ThreadChecker& operator=(const ThreadChecker&);
  bool CalledOnValidThread() const PERFETTO_WARN_UNUSED_RESULT;
  void DetachFromThread();

 private:
  mutable std::atomic<ThreadID> thread_id_;
};

#if PERFETTO_DCHECK_IS_ON() && !defined(PERFETTO_BUILD_WITH_CHROMIUM)
// TODO(primiano) Use Chromium's thread checker in Chromium.
#define PERFETTO_THREAD_CHECKER(name) base::ThreadChecker name;
#define PERFETTO_DCHECK_THREAD(name) \
  PERFETTO_DCHECK((name).CalledOnValidThread())
#define PERFETTO_DETACH_FROM_THREAD(name) (name).DetachFromThread()
#else
#define PERFETTO_THREAD_CHECKER(name)
#define PERFETTO_DCHECK_THREAD(name)
#define PERFETTO_DETACH_FROM_THREAD(name)
#endif  // PERFETTO_DCHECK_IS_ON()

}  // namespace base
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_BASE_THREAD_CHECKER_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "perfetto/ext/base/thread_checker.h"

#if PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)
#include <Windows.h>
#endif

namespace perfetto {
namespace base {

namespace {
constexpr ThreadID kDetached{};

ThreadID CurrentThreadId() {
#if PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)
  return ::GetCurrentThreadId();
#else
  return pthread_self();
#endif
}
}  // namespace

ThreadChecker::ThreadChecker() {
  thread_id_.store(CurrentThreadId());
}

ThreadChecker::~ThreadChecker() = default;

ThreadChecker::ThreadChecker(const ThreadChecker& other) {
  thread_id_ = other.thread_id_.load();
}

ThreadChecker& ThreadChecker::operator=(const ThreadChecker& other) {
  thread_id_ = other.thread_id_.load();
  return *this;
}

bool ThreadChecker::CalledOnValidThread() const {
  auto self = CurrentThreadId();

  // Will re-attach if previously detached using DetachFromThread().
  auto prev_value = kDetached;
  if (thread_id_.compare_exchange_strong(prev_value, self))
    return true;
  return prev_value == self;
}

void ThreadChecker::DetachFromThread() {
  thread_id_.store(kDetached);
}

}  // namespace base
}  // namespace perfetto
// gen_amalgamated begin source: src/base/time.cc
/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "perfetto/ext/base/time.h"
// gen_amalgamated expanded: #include "perfetto/base/build_config.h"

#if PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)
#include <Windows.h>
#else
#include <unistd.h>
#endif

namespace perfetto {
namespace base {

#if PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)

TimeNanos GetWallTimeNs() {
  LARGE_INTEGER freq;
  ::QueryPerformanceFrequency(&freq);
  LARGE_INTEGER counter;
  ::QueryPerformanceCounter(&counter);
  double elapsed_nanoseconds = (1e9 * counter.QuadPart) / freq.QuadPart;
  return TimeNanos(static_cast<uint64_t>(elapsed_nanoseconds));
}

TimeNanos GetThreadCPUTimeNs() {
  FILETIME dummy, kernel_ftime, user_ftime;
  ::GetThreadTimes(GetCurrentThread(), &dummy, &dummy, &kernel_ftime,
                   &user_ftime);
  uint64_t kernel_time = kernel_ftime.dwHighDateTime * 0x100000000 +
                         kernel_ftime.dwLowDateTime;
  uint64_t user_time = user_ftime.dwHighDateTime * 0x100000000 +
                       user_ftime.dwLowDateTime;

  return TimeNanos((kernel_time + user_time) * 100);
}

void SleepMicroseconds(unsigned interval_us) {
  // The Windows Sleep function takes a millisecond count. Round up so that
  // short sleeps don't turn into a busy wait. Note that the sleep granularity
  // on Windows can dynamically vary from 1 ms to ~16 ms, so don't count on this
  // being a short sleep.
  ::Sleep(static_cast<DWORD>((interval_us + 999) / 1000));
}

#else  // PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)

void SleepMicroseconds(unsigned interval_us) {
  ::usleep(static_cast<useconds_t>(interval_us));
}

#endif  // PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)

}  // namespace base
}  // namespace perfetto
// gen_amalgamated begin source: src/base/virtual_destructors.cc
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "perfetto/base/task_runner.h"

// This translation unit contains the definitions for the destructor of pure
// virtual interfaces for the current build target. The alternative would be
// introducing a one-liner .cc file for each pure virtual interface, which is
// overkill. This is for compliance with -Wweak-vtables.

namespace perfetto {
namespace base {

TaskRunner::~TaskRunner() = default;

}  // namespace base
}  // namespace perfetto
// gen_amalgamated begin source: src/base/event.cc
// gen_amalgamated begin header: include/perfetto/ext/base/event.h
/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_BASE_EVENT_H_
#define INCLUDE_PERFETTO_EXT_BASE_EVENT_H_

// gen_amalgamated expanded: #include "perfetto/base/build_config.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/scoped_file.h"

#if PERFETTO_BUILDFLAG(PERFETTO_OS_LINUX) || \
    PERFETTO_BUILDFLAG(PERFETTO_OS_ANDROID)
#define PERFETTO_USE_EVENTFD() 1
#else
#define PERFETTO_USE_EVENTFD() 0
#endif

namespace perfetto {
namespace base {

// A waitable event that can be used with poll/select.
// This is really a wrapper around eventfd_create with a pipe-based fallback
// for other platforms where eventfd is not supported.
class Event {
 public:
  Event();
  ~Event();
  Event(Event&&) noexcept = default;
  Event& operator=(Event&&) = default;

  // The non-blocking file descriptor that can be polled to wait for the event.
  int fd() const { return fd_.get(); }

  // Can be called from any thread.
  void Notify();

  // Can be called from any thread. If more Notify() are queued a Clear() call
  // can clear all of them (up to 16 per call).
  void Clear();

 private:
  // The eventfd, when eventfd is supported, otherwise this is the read end of
  // the pipe for fallback mode.
  ScopedFile fd_;

#if !PERFETTO_USE_EVENTFD()
  // The write end of the wakeup pipe.
  ScopedFile write_fd_;
#endif
};

}  // namespace base
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_BASE_EVENT_H_
// gen_amalgamated begin header: include/perfetto/ext/base/pipe.h
/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_BASE_PIPE_H_
#define INCLUDE_PERFETTO_EXT_BASE_PIPE_H_

// gen_amalgamated expanded: #include "perfetto/ext/base/scoped_file.h"

namespace perfetto {
namespace base {

class Pipe {
 public:
  enum Flags {
    kBothBlock = 0,
    kBothNonBlock,
    kRdNonBlock,
    kWrNonBlock,
  };

  static Pipe Create(Flags = kBothBlock);

  Pipe();
  Pipe(Pipe&&) noexcept;
  Pipe& operator=(Pipe&&);

  ScopedFile rd;
  ScopedFile wr;
};

}  // namespace base
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_BASE_PIPE_H_
/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <stdint.h>
#include <unistd.h>

// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/event.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/pipe.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/utils.h"

#if PERFETTO_USE_EVENTFD()
#include <sys/eventfd.h>
#endif

namespace perfetto {
namespace base {

Event::Event() {
#if PERFETTO_USE_EVENTFD()
  fd_.reset(eventfd(/* start value */ 0, EFD_CLOEXEC | EFD_NONBLOCK));
  PERFETTO_CHECK(fd_);
#else
  // Make the pipe non-blocking so that we never block the waking thread (either
  // the main thread or another one) when scheduling a wake-up.
  Pipe pipe = Pipe::Create(Pipe::kBothNonBlock);
  fd_ = std::move(pipe.rd);
  write_fd_ = std::move(pipe.wr);
#endif  // !PERFETTO_USE_EVENTFD()
}

Event::~Event() = default;

void Event::Notify() {
  const uint64_t value = 1;

#if PERFETTO_USE_EVENTFD()
  ssize_t ret = write(fd_.get(), &value, sizeof(value));
#else
  ssize_t ret = write(write_fd_.get(), &value, sizeof(uint8_t));
#endif

  if (ret <= 0 && errno != EAGAIN) {
    PERFETTO_DFATAL("write()");
  }
}

void Event::Clear() {
#if PERFETTO_USE_EVENTFD()
  uint64_t value;
  ssize_t ret = read(fd_.get(), &value, sizeof(value));
#else
  // Drain the byte(s) written to the wake-up pipe. We can potentially read
  // more than one byte if several wake-ups have been scheduled.
  char buffer[16];
  ssize_t ret = read(fd_.get(), &buffer[0], sizeof(buffer));
#endif
  if (ret <= 0 && errno != EAGAIN)
    PERFETTO_DPLOG("read()");
}

}  // namespace base
}  // namespace perfetto
// gen_amalgamated begin source: src/base/pipe.cc
/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "perfetto/ext/base/pipe.h"

#include <sys/types.h>
#include <unistd.h>

// gen_amalgamated expanded: #include "perfetto/base/logging.h"

namespace perfetto {
namespace base {

Pipe::Pipe() = default;
Pipe::Pipe(Pipe&&) noexcept = default;
Pipe& Pipe::operator=(Pipe&&) = default;

Pipe Pipe::Create(Flags flags) {
  int fds[2];
  PERFETTO_CHECK(pipe(fds) == 0);
  Pipe p;
  p.rd.reset(fds[0]);
  p.wr.reset(fds[1]);

  PERFETTO_CHECK(fcntl(*p.rd, F_SETFD, FD_CLOEXEC) == 0);
  PERFETTO_CHECK(fcntl(*p.wr, F_SETFD, FD_CLOEXEC) == 0);

  if (flags == kBothNonBlock || flags == kRdNonBlock) {
    int cur_flags = fcntl(*p.rd, F_GETFL, 0);
    PERFETTO_CHECK(cur_flags >= 0);
    PERFETTO_CHECK(fcntl(*p.rd, F_SETFL, cur_flags | O_NONBLOCK) == 0);
  }

  if (flags == kBothNonBlock || flags == kWrNonBlock) {
    int cur_flags = fcntl(*p.wr, F_GETFL, 0);
    PERFETTO_CHECK(cur_flags >= 0);
    PERFETTO_CHECK(fcntl(*p.wr, F_SETFL, cur_flags | O_NONBLOCK) == 0);
  }
  return p;
}

}  // namespace base
}  // namespace perfetto
// gen_amalgamated begin source: src/base/temp_file.cc
// gen_amalgamated begin header: include/perfetto/ext/base/temp_file.h
/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_BASE_TEMP_FILE_H_
#define INCLUDE_PERFETTO_EXT_BASE_TEMP_FILE_H_

#include <string>

// gen_amalgamated expanded: #include "perfetto/ext/base/scoped_file.h"

namespace perfetto {
namespace base {

class TempFile {
 public:
  static TempFile CreateUnlinked();
  static TempFile Create();

  TempFile(TempFile&&) noexcept;
  TempFile& operator=(TempFile&&);
  ~TempFile();

  const std::string& path() const { return path_; }
  int fd() const { return *fd_; }
  int operator*() const { return *fd_; }

  // Unlinks the file from the filesystem but keeps the fd() open.
  // It is safe to call this multiple times.
  void Unlink();

  // Releases the underlying file descriptor. Will unlink the file from the
  // filesystem if it was created via CreateUnlinked().
  ScopedFile ReleaseFD();

 private:
  TempFile();
  TempFile(const TempFile&) = delete;
  TempFile& operator=(const TempFile&) = delete;

  ScopedFile fd_;
  std::string path_;
};

class TempDir {
 public:
  static TempDir Create();

  TempDir(TempDir&&) noexcept;
  TempDir& operator=(TempDir&&);
  ~TempDir();

  const std::string& path() const { return path_; }

 private:
  TempDir();
  TempDir(const TempDir&) = delete;
  TempDir& operator=(const TempDir&) = delete;

  std::string path_;
};

}  // namespace base
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_BASE_TEMP_FILE_H_
/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "perfetto/ext/base/temp_file.h"

#include <stdlib.h>
#include <unistd.h>

namespace perfetto {
namespace base {

namespace {
#if PERFETTO_BUILDFLAG(PERFETTO_OS_ANDROID)
constexpr char kSysTmpPath[] = "/data/local/tmp";
#else
constexpr char kSysTmpPath[] = "/tmp";
#endif
}  // namespace

// static
TempFile TempFile::Create() {
  TempFile temp_file;
  const char* tmpdir = getenv("TMPDIR");
  if (tmpdir) {
    temp_file.path_.assign(tmpdir);
  } else {
    temp_file.path_.assign(kSysTmpPath);
  }
  temp_file.path_.append("/perfetto-XXXXXXXX");
  temp_file.fd_.reset(mkstemp(&temp_file.path_[0]));
  PERFETTO_CHECK(temp_file.fd_);
  return temp_file;
}

// static
TempFile TempFile::CreateUnlinked() {
  TempFile temp_file = TempFile::Create();
  temp_file.Unlink();
  return temp_file;
}

TempFile::TempFile() = default;

TempFile::~TempFile() {
  Unlink();
}

ScopedFile TempFile::ReleaseFD() {
  Unlink();
  return std::move(fd_);
}

void TempFile::Unlink() {
  if (path_.empty())
    return;
  PERFETTO_CHECK(unlink(path_.c_str()) == 0);
  path_.clear();
}

TempFile::TempFile(TempFile&&) noexcept = default;
TempFile& TempFile::operator=(TempFile&&) = default;

// static
TempDir TempDir::Create() {
  TempDir temp_dir;
  temp_dir.path_.assign(kSysTmpPath);
  temp_dir.path_.append("/perfetto-XXXXXXXX");
  PERFETTO_CHECK(mkdtemp(&temp_dir.path_[0]));
  return temp_dir;
}

TempDir::TempDir() = default;

TempDir::~TempDir() {
  PERFETTO_CHECK(rmdir(path_.c_str()) == 0);
}

}  // namespace base
}  // namespace perfetto
// gen_amalgamated begin source: src/base/thread_task_runner.cc
// gen_amalgamated begin header: include/perfetto/ext/base/thread_task_runner.h
// gen_amalgamated begin header: include/perfetto/ext/base/unix_task_runner.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_BASE_UNIX_TASK_RUNNER_H_
#define INCLUDE_PERFETTO_EXT_BASE_UNIX_TASK_RUNNER_H_

// gen_amalgamated expanded: #include "perfetto/base/build_config.h"
// gen_amalgamated expanded: #include "perfetto/base/task_runner.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/event.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/scoped_file.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/thread_checker.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/thread_utils.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/time.h"

#include <poll.h>
#include <chrono>
#include <deque>
#include <map>
#include <mutex>
#include <vector>

namespace perfetto {
namespace base {

// Runs a task runner on the current thread.
//
// Implementation note: we currently assume (and enforce in debug builds) that
// Run() is called from the thread that constructed the UnixTaskRunner. This is
// not strictly necessary, and we could instead track the thread that invokes
// Run(). However, a related property that *might* be important to enforce is
// that the destructor runs on the task-running thread. Otherwise, if there are
// still-pending tasks at the time of destruction, we would destroy those
// outside of the task thread (which might be unexpected to the caller). On the
// other hand, the std::function task interface discourages use of any
// resource-owning tasks (as the callable needs to be copyable), so this might
// not be important in practice.
//
// TODO(rsavitski): consider adding a thread-check in the destructor, after
// auditing existing usages.
class UnixTaskRunner : public TaskRunner {
 public:
  UnixTaskRunner();
  ~UnixTaskRunner() override;

  // Start executing tasks. Doesn't return until Quit() is called. Run() may be
  // called multiple times on the same task runner.
  void Run();
  void Quit();

  // Checks whether there are any pending immediate tasks to run. Note that
  // delayed tasks don't count even if they are due to run.
  bool IsIdleForTesting();

  // TaskRunner implementation:
  void PostTask(std::function<void()>) override;
  void PostDelayedTask(std::function<void()>, uint32_t delay_ms) override;
  void AddFileDescriptorWatch(int fd, std::function<void()>) override;
  void RemoveFileDescriptorWatch(int fd) override;
  bool RunsTasksOnCurrentThread() const override;

  // Returns true if the task runner is quitting, or has quit and hasn't been
  // restarted since. Exposed primarily for ThreadTaskRunner, not necessary for
  // normal use of this class.
  bool QuitCalled();

 private:
  void WakeUp();

  void UpdateWatchTasksLocked();

  int GetDelayMsToNextTaskLocked() const;
  void RunImmediateAndDelayedTask();
  void PostFileDescriptorWatches();
  void RunFileDescriptorWatch(int fd);

  ThreadChecker thread_checker_;
  PlatformThreadID created_thread_id_ = GetThreadId();

  // On Linux, an eventfd(2) used to waking up the task runner when a new task
  // is posted. Otherwise the read end of a pipe used for the same purpose.
  Event event_;

  std::vector<struct pollfd> poll_fds_;

  // --- Begin lock-protected members ---

  std::mutex lock_;

  std::deque<std::function<void()>> immediate_tasks_;
  std::multimap<TimeMillis, std::function<void()>> delayed_tasks_;
  bool quit_ = false;

  struct WatchTask {
    std::function<void()> callback;
    size_t poll_fd_index;  // Index into |poll_fds_|.
  };

  std::map<int, WatchTask> watch_tasks_;
  bool watch_tasks_changed_ = false;

  // --- End lock-protected members ---
};

}  // namespace base
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_BASE_UNIX_TASK_RUNNER_H_
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_BASE_THREAD_TASK_RUNNER_H_
#define INCLUDE_PERFETTO_EXT_BASE_THREAD_TASK_RUNNER_H_

#include <functional>
#include <thread>

// gen_amalgamated expanded: #include "perfetto/ext/base/unix_task_runner.h"

namespace perfetto {
namespace base {

// A UnixTaskRunner backed by a dedicated task thread. Shuts down the runner and
// joins the thread upon destruction. Can be moved to transfer ownership.
//
// Guarantees that:
// * the UnixTaskRunner will be constructed and destructed on the task thread.
// * the task thread will live for the lifetime of the UnixTaskRunner.
//
class ThreadTaskRunner {
 public:
  static ThreadTaskRunner CreateAndStart() { return ThreadTaskRunner(); }

  ThreadTaskRunner(const ThreadTaskRunner&) = delete;
  ThreadTaskRunner& operator=(const ThreadTaskRunner&) = delete;

  ThreadTaskRunner(ThreadTaskRunner&&) noexcept;
  ThreadTaskRunner& operator=(ThreadTaskRunner&&);
  ~ThreadTaskRunner();

  // Returns a pointer to the UnixTaskRunner, which is valid for the lifetime of
  // this ThreadTaskRunner object (unless this object is moved-from, in which
  // case the pointer remains valid for the lifetime of the new owning
  // ThreadTaskRunner).
  //
  // Warning: do not call Quit() on the returned runner pointer, the termination
  // should be handled exclusively by this class' destructor.
  UnixTaskRunner* get() const { return task_runner_; }

 private:
  ThreadTaskRunner();
  void RunTaskThread(std::function<void(UnixTaskRunner*)> initializer);

  std::thread thread_;
  UnixTaskRunner* task_runner_ = nullptr;
};

}  // namespace base
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_BASE_THREAD_TASK_RUNNER_H_
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "perfetto/ext/base/thread_task_runner.h"

#include <condition_variable>
#include <functional>
#include <mutex>
#include <thread>

// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/unix_task_runner.h"

namespace perfetto {
namespace base {

ThreadTaskRunner::ThreadTaskRunner(ThreadTaskRunner&& other) noexcept
    : thread_(std::move(other.thread_)), task_runner_(other.task_runner_) {
  other.task_runner_ = nullptr;
}

ThreadTaskRunner& ThreadTaskRunner::operator=(ThreadTaskRunner&& other) {
  this->~ThreadTaskRunner();
  new (this) ThreadTaskRunner(std::move(other));
  return *this;
}

ThreadTaskRunner::~ThreadTaskRunner() {
  if (task_runner_) {
    PERFETTO_CHECK(!task_runner_->QuitCalled());
    task_runner_->Quit();

    PERFETTO_DCHECK(thread_.joinable());
  }
  if (thread_.joinable())
    thread_.join();
}

ThreadTaskRunner::ThreadTaskRunner() {
  std::mutex init_lock;
  std::condition_variable init_cv;

  std::function<void(UnixTaskRunner*)> initializer =
      [this, &init_lock, &init_cv](UnixTaskRunner* task_runner) {
        std::lock_guard<std::mutex> lock(init_lock);
        task_runner_ = task_runner;
        // Notify while still holding the lock, as init_cv ceases to exist as
        // soon as the main thread observes a non-null task_runner_, and it can
        // wake up spuriously (i.e. before the notify if we had unlocked before
        // notifying).
        init_cv.notify_one();
      };
  thread_ = std::thread(&ThreadTaskRunner::RunTaskThread, this,
                        std::move(initializer));

  std::unique_lock<std::mutex> lock(init_lock);
  init_cv.wait(lock, [this] { return !!task_runner_; });
}

void ThreadTaskRunner::RunTaskThread(
    std::function<void(UnixTaskRunner*)> initializer) {
  UnixTaskRunner task_runner;
  task_runner.PostTask(std::bind(std::move(initializer), &task_runner));
  task_runner.Run();
}

}  // namespace base
}  // namespace perfetto
// gen_amalgamated begin source: src/base/unix_task_runner.cc
// gen_amalgamated begin header: include/perfetto/ext/base/watchdog.h
// gen_amalgamated begin header: include/perfetto/ext/base/watchdog_posix.h
/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_BASE_WATCHDOG_POSIX_H_
#define INCLUDE_PERFETTO_EXT_BASE_WATCHDOG_POSIX_H_

// gen_amalgamated expanded: #include "perfetto/ext/base/thread_checker.h"

#include <atomic>
#include <condition_variable>
#include <mutex>
#include <thread>

namespace perfetto {
namespace base {

// Ensures that the calling program does not exceed certain hard limits on
// resource usage e.g. time, memory and CPU. If exceeded, the program is
// crashed.
class Watchdog {
 public:
  // Handle to the timer set to crash the program. If the handle is dropped,
  // the timer is removed so the program does not crash.
  class Timer {
   public:
    ~Timer();
    Timer(Timer&&) noexcept;

   private:
    friend class Watchdog;

    explicit Timer(uint32_t ms);
    Timer(const Timer&) = delete;
    Timer& operator=(const Timer&) = delete;

    timer_t timerid_ = nullptr;
  };
  virtual ~Watchdog();

  static Watchdog* GetInstance();

  // Sets a timer which will crash the program in |ms| milliseconds if the
  // returned handle is not destroyed before this point.
  Timer CreateFatalTimer(uint32_t ms);

  // Starts the watchdog thread which monitors the memory and CPU usage
  // of the program.
  void Start();

  // Sets a limit on the memory (defined as the RSS) used by the program
  // averaged over the last |window_ms| milliseconds. If |kb| is 0, any
  // existing limit is removed.
  // Note: |window_ms| has to be a multiple of |polling_interval_ms_|.
  void SetMemoryLimit(uint64_t bytes, uint32_t window_ms);

  // Sets a limit on the CPU usage used by the program averaged over the last
  // |window_ms| milliseconds. If |percentage| is 0, any existing limit is
  // removed.
  // Note: |window_ms| has to be a multiple of |polling_interval_ms_|.
  void SetCpuLimit(uint32_t percentage, uint32_t window_ms);

 protected:
  // Protected for testing.
  Watchdog(uint32_t polling_interval_ms);

 private:
  // Represents a ring buffer in which integer values can be stored.
  class WindowedInterval {
   public:
    // Pushes a new value into a ring buffer wrapping if necessary and returns
    // whether the ring buffer is full.
    bool Push(uint64_t sample);

    // Returns the mean of the values in the buffer.
    double Mean() const;

    // Clears the ring buffer while keeping the existing size.
    void Clear();

    // Resets the size of the buffer as well as clearing it.
    void Reset(size_t new_size);

    // Gets the oldest value inserted in the buffer. The buffer must be full
    // (i.e. Push returned true) before this method can be called.
    uint64_t OldestWhenFull() const {
      PERFETTO_CHECK(filled_);
      return buffer_[position_];
    }

    // Gets the newest value inserted in the buffer. The buffer must be full
    // (i.e. Push returned true) before this method can be called.
    uint64_t NewestWhenFull() const {
      PERFETTO_CHECK(filled_);
      return buffer_[(position_ + size_ - 1) % size_];
    }

    // Returns the size of the ring buffer.
    size_t size() const { return size_; }

   private:
    bool filled_ = false;
    size_t position_ = 0;
    size_t size_ = 0;
    std::unique_ptr<uint64_t[]> buffer_;
  };

  explicit Watchdog(const Watchdog&) = delete;
  Watchdog& operator=(const Watchdog&) = delete;

  // Main method for the watchdog thread.
  void ThreadMain();

  // Check each type of resource every |polling_interval_ms_| miillis.
  void CheckMemory(uint64_t rss_bytes);
  void CheckCpu(uint64_t cpu_time);

  // Computes the time interval spanned by a given ring buffer with respect
  // to |polling_interval_ms_|.
  uint32_t WindowTimeForRingBuffer(const WindowedInterval& window);

  const uint32_t polling_interval_ms_;
  std::atomic<bool> enabled_{false};
  std::thread thread_;
  std::condition_variable exit_signal_;

  // --- Begin lock-protected members ---

  std::mutex mutex_;

  uint64_t memory_limit_bytes_ = 0;
  WindowedInterval memory_window_bytes_;

  uint32_t cpu_limit_percentage_ = 0;
  WindowedInterval cpu_window_time_ticks_;

  // --- End lock-protected members ---
};

}  // namespace base
}  // namespace perfetto
#endif  // INCLUDE_PERFETTO_EXT_BASE_WATCHDOG_POSIX_H_
/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_BASE_WATCHDOG_H_
#define INCLUDE_PERFETTO_EXT_BASE_WATCHDOG_H_

#include <functional>

// gen_amalgamated expanded: #include "perfetto/base/build_config.h"

#if (PERFETTO_BUILDFLAG(PERFETTO_OS_LINUX) ||    \
     PERFETTO_BUILDFLAG(PERFETTO_OS_ANDROID)) && \
    !PERFETTO_BUILDFLAG(PERFETTO_EMBEDDER_BUILD)
// gen_amalgamated expanded: #include "perfetto/ext/base/watchdog_posix.h"
#else
// gen_amalgamated expanded: #include "perfetto/ext/base/watchdog_noop.h"
#endif

namespace perfetto {
namespace base {

inline void RunTaskWithWatchdogGuard(const std::function<void()>& task) {
  // Maximum time a single task can take in a TaskRunner before the
  // program suicides.
  constexpr int64_t kWatchdogMillis = 30000;  // 30s

  Watchdog::Timer handle =
      base::Watchdog::GetInstance()->CreateFatalTimer(kWatchdogMillis);
  task();
}

}  // namespace base
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_BASE_WATCHDOG_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "perfetto/ext/base/unix_task_runner.h"

// gen_amalgamated expanded: #include "perfetto/base/build_config.h"

#include <errno.h>
#include <stdlib.h>
#include <unistd.h>

#include <limits>

// gen_amalgamated expanded: #include "perfetto/ext/base/watchdog.h"

namespace perfetto {
namespace base {

UnixTaskRunner::UnixTaskRunner() {
  AddFileDescriptorWatch(event_.fd(), [] {
    // Not reached -- see PostFileDescriptorWatches().
    PERFETTO_DFATAL("Should be unreachable.");
  });
}

UnixTaskRunner::~UnixTaskRunner() = default;

void UnixTaskRunner::WakeUp() {
  event_.Notify();
}

void UnixTaskRunner::Run() {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  created_thread_id_ = GetThreadId();
  quit_ = false;
  for (;;) {
    int poll_timeout_ms;
    {
      std::lock_guard<std::mutex> lock(lock_);
      if (quit_)
        return;
      poll_timeout_ms = GetDelayMsToNextTaskLocked();
      UpdateWatchTasksLocked();
    }
    int ret = PERFETTO_EINTR(poll(
        &poll_fds_[0], static_cast<nfds_t>(poll_fds_.size()), poll_timeout_ms));
    PERFETTO_CHECK(ret >= 0);

    // To avoid starvation we always interleave all types of tasks -- immediate,
    // delayed and file descriptor watches.
    PostFileDescriptorWatches();
    RunImmediateAndDelayedTask();
  }
}

void UnixTaskRunner::Quit() {
  std::lock_guard<std::mutex> lock(lock_);
  quit_ = true;
  WakeUp();
}

bool UnixTaskRunner::QuitCalled() {
  std::lock_guard<std::mutex> lock(lock_);
  return quit_;
}

bool UnixTaskRunner::IsIdleForTesting() {
  std::lock_guard<std::mutex> lock(lock_);
  return immediate_tasks_.empty();
}

void UnixTaskRunner::UpdateWatchTasksLocked() {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  if (!watch_tasks_changed_)
    return;
  watch_tasks_changed_ = false;
  poll_fds_.clear();
  for (auto& it : watch_tasks_) {
    it.second.poll_fd_index = poll_fds_.size();
    poll_fds_.push_back({it.first, POLLIN | POLLHUP, 0});
  }
}

void UnixTaskRunner::RunImmediateAndDelayedTask() {
  // If locking overhead becomes an issue, add a separate work queue.
  std::function<void()> immediate_task;
  std::function<void()> delayed_task;
  TimeMillis now = GetWallTimeMs();
  {
    std::lock_guard<std::mutex> lock(lock_);
    if (!immediate_tasks_.empty()) {
      immediate_task = std::move(immediate_tasks_.front());
      immediate_tasks_.pop_front();
    }
    if (!delayed_tasks_.empty()) {
      auto it = delayed_tasks_.begin();
      if (now >= it->first) {
        delayed_task = std::move(it->second);
        delayed_tasks_.erase(it);
      }
    }
  }

  errno = 0;
  if (immediate_task)
    RunTaskWithWatchdogGuard(immediate_task);
  errno = 0;
  if (delayed_task)
    RunTaskWithWatchdogGuard(delayed_task);
}

void UnixTaskRunner::PostFileDescriptorWatches() {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  for (size_t i = 0; i < poll_fds_.size(); i++) {
    if (!(poll_fds_[i].revents & (POLLIN | POLLHUP)))
      continue;
    poll_fds_[i].revents = 0;

    // The wake-up event is handled inline to avoid an infinite recursion of
    // posted tasks.
    if (poll_fds_[i].fd == event_.fd()) {
      event_.Clear();
      continue;
    }

    // Binding to |this| is safe since we are the only object executing the
    // task.
    PostTask(std::bind(&UnixTaskRunner::RunFileDescriptorWatch, this,
                       poll_fds_[i].fd));

    // Make the fd negative while a posted task is pending. This makes poll(2)
    // ignore the fd.
    PERFETTO_DCHECK(poll_fds_[i].fd >= 0);
    poll_fds_[i].fd = -poll_fds_[i].fd;
  }
}

void UnixTaskRunner::RunFileDescriptorWatch(int fd) {
  std::function<void()> task;
  {
    std::lock_guard<std::mutex> lock(lock_);
    auto it = watch_tasks_.find(fd);
    if (it == watch_tasks_.end())
      return;
    // Make poll(2) pay attention to the fd again. Since another thread may have
    // updated this watch we need to refresh the set first.
    UpdateWatchTasksLocked();
    size_t fd_index = it->second.poll_fd_index;
    PERFETTO_DCHECK(fd_index < poll_fds_.size());
    PERFETTO_DCHECK(::abs(poll_fds_[fd_index].fd) == fd);
    poll_fds_[fd_index].fd = fd;
    task = it->second.callback;
  }
  errno = 0;
  RunTaskWithWatchdogGuard(task);
}

int UnixTaskRunner::GetDelayMsToNextTaskLocked() const {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  if (!immediate_tasks_.empty())
    return 0;
  if (!delayed_tasks_.empty()) {
    TimeMillis diff = delayed_tasks_.begin()->first - GetWallTimeMs();
    return std::max(0, static_cast<int>(diff.count()));
  }
  return -1;
}

void UnixTaskRunner::PostTask(std::function<void()> task) {
  bool was_empty;
  {
    std::lock_guard<std::mutex> lock(lock_);
    was_empty = immediate_tasks_.empty();
    immediate_tasks_.push_back(std::move(task));
  }
  if (was_empty)
    WakeUp();
}

void UnixTaskRunner::PostDelayedTask(std::function<void()> task,
                                     uint32_t delay_ms) {
  TimeMillis runtime = GetWallTimeMs() + TimeMillis(delay_ms);
  {
    std::lock_guard<std::mutex> lock(lock_);
    delayed_tasks_.insert(std::make_pair(runtime, std::move(task)));
  }
  WakeUp();
}

void UnixTaskRunner::AddFileDescriptorWatch(int fd,
                                            std::function<void()> task) {
  PERFETTO_DCHECK(fd >= 0);
  {
    std::lock_guard<std::mutex> lock(lock_);
    PERFETTO_DCHECK(!watch_tasks_.count(fd));
    watch_tasks_[fd] = {std::move(task), SIZE_MAX};
    watch_tasks_changed_ = true;
  }
  WakeUp();
}

void UnixTaskRunner::RemoveFileDescriptorWatch(int fd) {
  PERFETTO_DCHECK(fd >= 0);
  {
    std::lock_guard<std::mutex> lock(lock_);
    PERFETTO_DCHECK(watch_tasks_.count(fd));
    watch_tasks_.erase(fd);
    watch_tasks_changed_ = true;
  }
  // No need to schedule a wake-up for this.
}

bool UnixTaskRunner::RunsTasksOnCurrentThread() const {
  return GetThreadId() == created_thread_id_;
}

}  // namespace base
}  // namespace perfetto
// gen_amalgamated begin source: src/base/watchdog_posix.cc
/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "perfetto/base/build_config.h"

// Watchdog is currently not supported on Mac. This ifdef-based exclusion is
// here only for the Mac build in AOSP. The standalone and chromium builds
// exclude this file at the GN level. However, propagating the per-os exclusion
// through our GN -> BP build file translator is not worth the effort for a
// one-off case.
#if !PERFETTO_BUILDFLAG(PERFETTO_OS_MACOSX)

// gen_amalgamated expanded: #include "perfetto/ext/base/watchdog_posix.h"

#include <fcntl.h>
#include <inttypes.h>
#include <signal.h>
#include <stdint.h>

#include <fstream>
#include <thread>

// gen_amalgamated expanded: #include "perfetto/base/build_config.h"
// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/scoped_file.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/thread_utils.h"

#if PERFETTO_BUILDFLAG(PERFETTO_EMBEDDER_BUILD)
#error perfetto::base::Watchdog should not be used in Chromium or embedders
#endif

namespace perfetto {
namespace base {

namespace {

constexpr uint32_t kDefaultPollingInterval = 30 * 1000;

bool IsMultipleOf(uint32_t number, uint32_t divisor) {
  return number >= divisor && number % divisor == 0;
}

double MeanForArray(const uint64_t array[], size_t size) {
  uint64_t total = 0;
  for (size_t i = 0; i < size; i++) {
    total += array[i];
  }
  return total / size;
}

}  //  namespace

Watchdog::Watchdog(uint32_t polling_interval_ms)
    : polling_interval_ms_(polling_interval_ms) {}

Watchdog::~Watchdog() {
  if (!thread_.joinable()) {
    PERFETTO_DCHECK(!enabled_);
    return;
  }
  PERFETTO_DCHECK(enabled_);
  enabled_ = false;
  exit_signal_.notify_one();
  thread_.join();
}

Watchdog* Watchdog::GetInstance() {
  static Watchdog* watchdog = new Watchdog(kDefaultPollingInterval);
  return watchdog;
}

Watchdog::Timer Watchdog::CreateFatalTimer(uint32_t ms) {
  if (!enabled_.load(std::memory_order_relaxed))
    return Watchdog::Timer(0);

  return Watchdog::Timer(ms);
}

void Watchdog::Start() {
  std::lock_guard<std::mutex> guard(mutex_);
  if (thread_.joinable()) {
    PERFETTO_DCHECK(enabled_);
  } else {
    PERFETTO_DCHECK(!enabled_);

#if PERFETTO_BUILDFLAG(PERFETTO_OS_LINUX) || \
    PERFETTO_BUILDFLAG(PERFETTO_OS_ANDROID)
    // Kick the thread to start running but only on Android or Linux.
    enabled_ = true;
    thread_ = std::thread(&Watchdog::ThreadMain, this);
#endif
  }
}

void Watchdog::SetMemoryLimit(uint64_t bytes, uint32_t window_ms) {
  // Update the fields under the lock.
  std::lock_guard<std::mutex> guard(mutex_);

  PERFETTO_CHECK(IsMultipleOf(window_ms, polling_interval_ms_) || bytes == 0);

  size_t size = bytes == 0 ? 0 : window_ms / polling_interval_ms_ + 1;
  memory_window_bytes_.Reset(size);
  memory_limit_bytes_ = bytes;
}

void Watchdog::SetCpuLimit(uint32_t percentage, uint32_t window_ms) {
  std::lock_guard<std::mutex> guard(mutex_);

  PERFETTO_CHECK(percentage <= 100);
  PERFETTO_CHECK(IsMultipleOf(window_ms, polling_interval_ms_) ||
                 percentage == 0);

  size_t size = percentage == 0 ? 0 : window_ms / polling_interval_ms_ + 1;
  cpu_window_time_ticks_.Reset(size);
  cpu_limit_percentage_ = percentage;
}

void Watchdog::ThreadMain() {
  base::ScopedFile stat_fd(base::OpenFile("/proc/self/stat", O_RDONLY));
  if (!stat_fd) {
    PERFETTO_ELOG("Failed to open stat file to enforce resource limits.");
    return;
  }

  std::unique_lock<std::mutex> guard(mutex_);
  for (;;) {
    exit_signal_.wait_for(guard,
                          std::chrono::milliseconds(polling_interval_ms_));
    if (!enabled_)
      return;

    lseek(stat_fd.get(), 0, SEEK_SET);

    char c[512];
    if (read(stat_fd.get(), c, sizeof(c)) < 0) {
      PERFETTO_ELOG("Failed to read stat file to enforce resource limits.");
      return;
    }
    c[sizeof(c) - 1] = '\0';

    unsigned long int utime = 0l;
    unsigned long int stime = 0l;
    long int rss_pages = -1l;
    PERFETTO_CHECK(
        sscanf(c,
               "%*d %*s %*c %*d %*d %*d %*d %*d %*u %*u %*u %*u %*u %lu"
               "%lu %*d %*d %*d %*d %*d %*d %*u %*u %ld",
               &utime, &stime, &rss_pages) == 3);

    uint64_t cpu_time = utime + stime;
    uint64_t rss_bytes = static_cast<uint64_t>(rss_pages) * base::kPageSize;

    CheckMemory(rss_bytes);
    CheckCpu(cpu_time);
  }
}

void Watchdog::CheckMemory(uint64_t rss_bytes) {
  if (memory_limit_bytes_ == 0)
    return;

  // Add the current stat value to the ring buffer and check that the mean
  // remains under our threshold.
  if (memory_window_bytes_.Push(rss_bytes)) {
    if (memory_window_bytes_.Mean() > memory_limit_bytes_) {
      PERFETTO_ELOG(
          "Memory watchdog trigger. Memory window of %f bytes is above the "
          "%" PRIu64 " bytes limit.",
          memory_window_bytes_.Mean(), memory_limit_bytes_);
      kill(getpid(), SIGABRT);
    }
  }
}

void Watchdog::CheckCpu(uint64_t cpu_time) {
  if (cpu_limit_percentage_ == 0)
    return;

  // Add the cpu time to the ring buffer.
  if (cpu_window_time_ticks_.Push(cpu_time)) {
    // Compute the percentage over the whole window and check that it remains
    // under the threshold.
    uint64_t difference_ticks = cpu_window_time_ticks_.NewestWhenFull() -
                                cpu_window_time_ticks_.OldestWhenFull();
    double window_interval_ticks =
        (static_cast<double>(WindowTimeForRingBuffer(cpu_window_time_ticks_)) /
         1000.0) *
        sysconf(_SC_CLK_TCK);
    double percentage = static_cast<double>(difference_ticks) /
                        static_cast<double>(window_interval_ticks) * 100;
    if (percentage > cpu_limit_percentage_) {
      PERFETTO_ELOG("CPU watchdog trigger. %f%% CPU use is above the %" PRIu32
                    "%% CPU limit.",
                    percentage, cpu_limit_percentage_);
      kill(getpid(), SIGABRT);
    }
  }
}

uint32_t Watchdog::WindowTimeForRingBuffer(const WindowedInterval& window) {
  return static_cast<uint32_t>(window.size() - 1) * polling_interval_ms_;
}

bool Watchdog::WindowedInterval::Push(uint64_t sample) {
  // Add the sample to the current position in the ring buffer.
  buffer_[position_] = sample;

  // Update the position with next one circularily.
  position_ = (position_ + 1) % size_;

  // Set the filled flag the first time we wrap.
  filled_ = filled_ || position_ == 0;
  return filled_;
}

double Watchdog::WindowedInterval::Mean() const {
  return MeanForArray(buffer_.get(), size_);
}

void Watchdog::WindowedInterval::Clear() {
  position_ = 0;
  buffer_.reset(new uint64_t[size_]());
}

void Watchdog::WindowedInterval::Reset(size_t new_size) {
  position_ = 0;
  size_ = new_size;
  buffer_.reset(new_size == 0 ? nullptr : new uint64_t[new_size]());
}

Watchdog::Timer::Timer(uint32_t ms) {
  if (!ms)
    return;  // No-op timer created when the watchdog is disabled.

  struct sigevent sev = {};
  sev.sigev_notify = SIGEV_THREAD_ID;
  sev._sigev_un._tid = base::GetThreadId();
  sev.sigev_signo = SIGABRT;
  PERFETTO_CHECK(timer_create(CLOCK_MONOTONIC, &sev, &timerid_) != -1);
  struct itimerspec its = {};
  its.it_value.tv_sec = ms / 1000;
  its.it_value.tv_nsec = 1000000L * (ms % 1000);
  PERFETTO_CHECK(timer_settime(timerid_, 0, &its, nullptr) != -1);
}

Watchdog::Timer::~Timer() {
  if (timerid_ != nullptr) {
    timer_delete(timerid_);
  }
}

Watchdog::Timer::Timer(Timer&& other) noexcept {
  timerid_ = other.timerid_;
  other.timerid_ = nullptr;
}

}  // namespace base
}  // namespace perfetto

#endif  // PERFETTO_OS_MACOSX
// gen_amalgamated begin source: src/tracing/trace_writer_base.cc
// gen_amalgamated begin header: include/perfetto/tracing/trace_writer_base.h
// gen_amalgamated begin header: include/perfetto/protozero/message_handle.h
// gen_amalgamated begin header: include/perfetto/protozero/message.h
// gen_amalgamated begin header: include/perfetto/protozero/contiguous_memory_range.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_PROTOZERO_CONTIGUOUS_MEMORY_RANGE_H_
#define INCLUDE_PERFETTO_PROTOZERO_CONTIGUOUS_MEMORY_RANGE_H_

#include <assert.h>
#include <stddef.h>
#include <stdint.h>

namespace protozero {

// Keep this struct trivially constructible (no ctors, no default initializers).
struct ContiguousMemoryRange {
  uint8_t* begin;
  uint8_t* end;  // STL style: one byte past the end of the buffer.

  inline bool is_valid() const { return begin != nullptr; }
  inline void reset() { begin = nullptr; }
  inline size_t size() { return static_cast<size_t>(end - begin); }
};

}  // namespace protozero

#endif  // INCLUDE_PERFETTO_PROTOZERO_CONTIGUOUS_MEMORY_RANGE_H_
// gen_amalgamated begin header: include/perfetto/protozero/proto_utils.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_PROTOZERO_PROTO_UTILS_H_
#define INCLUDE_PERFETTO_PROTOZERO_PROTO_UTILS_H_

#include <inttypes.h>
#include <stddef.h>

#include <type_traits>

// gen_amalgamated expanded: #include "perfetto/base/logging.h"

namespace protozero {
namespace proto_utils {

// See https://developers.google.com/protocol-buffers/docs/encoding wire types.
// This is a type encoded into the proto that provides just enough info to
// find the length of the following value.
enum class ProtoWireType : uint32_t {
  kVarInt = 0,
  kFixed64 = 1,
  kLengthDelimited = 2,
  kFixed32 = 5,
};

// This is the type defined in the proto for each field. This information
// is used to decide the translation strategy when writing the trace.
enum class ProtoSchemaType {
  kUnknown = 0,
  kDouble,
  kFloat,
  kInt64,
  kUint64,
  kInt32,
  kFixed64,
  kFixed32,
  kBool,
  kString,
  kGroup,  // Deprecated (proto2 only)
  kMessage,
  kBytes,
  kUint32,
  kEnum,
  kSfixed32,
  kSfixed64,
  kSint32,
  kSint64,
};

inline const char* ProtoSchemaToString(ProtoSchemaType v) {
  switch (v) {
    case ProtoSchemaType::kUnknown:
      return "unknown";
    case ProtoSchemaType::kDouble:
      return "double";
    case ProtoSchemaType::kFloat:
      return "float";
    case ProtoSchemaType::kInt64:
      return "int64";
    case ProtoSchemaType::kUint64:
      return "uint64";
    case ProtoSchemaType::kInt32:
      return "int32";
    case ProtoSchemaType::kFixed64:
      return "fixed64";
    case ProtoSchemaType::kFixed32:
      return "fixed32";
    case ProtoSchemaType::kBool:
      return "bool";
    case ProtoSchemaType::kString:
      return "string";
    case ProtoSchemaType::kGroup:
      return "group";
    case ProtoSchemaType::kMessage:
      return "message";
    case ProtoSchemaType::kBytes:
      return "bytes";
    case ProtoSchemaType::kUint32:
      return "uint32";
    case ProtoSchemaType::kEnum:
      return "enum";
    case ProtoSchemaType::kSfixed32:
      return "sfixed32";
    case ProtoSchemaType::kSfixed64:
      return "sfixed64";
    case ProtoSchemaType::kSint32:
      return "sint32";
    case ProtoSchemaType::kSint64:
      return "sint64";
  }
  // For gcc:
  PERFETTO_DCHECK(false);
  return "";
}

// Maximum message size supported: 256 MiB (4 x 7-bit due to varint encoding).
constexpr size_t kMessageLengthFieldSize = 4;
constexpr size_t kMaxMessageLength = (1u << (kMessageLengthFieldSize * 7)) - 1;

// Field tag is encoded as 32-bit varint (5 bytes at most).
// Largest value of simple (not length-delimited) field is 64-bit varint
// (10 bytes at most). 15 bytes buffer is enough to store a simple field.
constexpr size_t kMaxTagEncodedSize = 5;
constexpr size_t kMaxSimpleFieldEncodedSize = kMaxTagEncodedSize + 10;

// Proto types: (int|uint|sint)(32|64), bool, enum.
constexpr uint32_t MakeTagVarInt(uint32_t field_id) {
  return (field_id << 3) | static_cast<uint32_t>(ProtoWireType::kVarInt);
}

// Proto types: fixed64, sfixed64, fixed32, sfixed32, double, float.
template <typename T>
constexpr uint32_t MakeTagFixed(uint32_t field_id) {
  static_assert(sizeof(T) == 8 || sizeof(T) == 4, "Value must be 4 or 8 bytes");
  return (field_id << 3) |
         static_cast<uint32_t>((sizeof(T) == 8 ? ProtoWireType::kFixed64
                                               : ProtoWireType::kFixed32));
}

// Proto types: string, bytes, embedded messages.
constexpr uint32_t MakeTagLengthDelimited(uint32_t field_id) {
  return (field_id << 3) |
         static_cast<uint32_t>(ProtoWireType::kLengthDelimited);
}

// Proto types: sint64, sint32.
template <typename T>
inline typename std::make_unsigned<T>::type ZigZagEncode(T value) {
  return static_cast<typename std::make_unsigned<T>::type>(
      (value << 1) ^ (value >> (sizeof(T) * 8 - 1)));
}

template <typename T>
inline uint8_t* WriteVarInt(T value, uint8_t* target) {
  // If value is <= 0 we must first sign extend to int64_t (see [1]).
  // Finally we always cast to an unsigned value to to avoid arithmetic
  // (sign expanding) shifts in the while loop.
  // [1]: "If you use int32 or int64 as the type for a negative number, the
  // resulting varint is always ten bytes long".
  // - developers.google.com/protocol-buffers/docs/encoding
  // So for each input type we do the following casts:
  // uintX_t -> uintX_t -> uintX_t
  // int8_t  -> int64_t -> uint64_t
  // int16_t -> int64_t -> uint64_t
  // int32_t -> int64_t -> uint64_t
  // int64_t -> int64_t -> uint64_t
  using MaybeExtendedType =
      typename std::conditional<std::is_unsigned<T>::value, T, int64_t>::type;
  using UnsignedType = typename std::make_unsigned<MaybeExtendedType>::type;

  MaybeExtendedType extended_value = static_cast<MaybeExtendedType>(value);
  UnsignedType unsigned_value = static_cast<UnsignedType>(extended_value);

  while (unsigned_value >= 0x80) {
    *target++ = static_cast<uint8_t>(unsigned_value) | 0x80;
    unsigned_value >>= 7;
  }
  *target = static_cast<uint8_t>(unsigned_value);
  return target + 1;
}

// Writes a fixed-size redundant encoding of the given |value|. This is
// used to backfill fixed-size reservations for the length field using a
// non-canonical varint encoding (e.g. \x81\x80\x80\x00 instead of \x01).
// See https://github.com/google/protobuf/issues/1530.
// In particular, this is used for nested messages. The size of a nested message
// is not known until all its field have been written. |kMessageLengthFieldSize|
// bytes are reserved to encode the size field and backfilled at the end.
inline void WriteRedundantVarInt(uint32_t value, uint8_t* buf) {
  for (size_t i = 0; i < kMessageLengthFieldSize; ++i) {
    const uint8_t msb = (i < kMessageLengthFieldSize - 1) ? 0x80 : 0;
    buf[i] = static_cast<uint8_t>(value) | msb;
    value >>= 7;
  }
}

template <uint32_t field_id>
void StaticAssertSingleBytePreamble() {
  static_assert(field_id < 16,
                "Proto field id too big to fit in a single byte preamble");
}

// Parses a VarInt from the encoded buffer [start, end). |end| is STL-style and
// points one byte past the end of buffer.
// The parsed int value is stored in the output arg |value|. Returns a pointer
// to the next unconsumed byte (so start < retval <= end) or |start| if the
// VarInt could not be fully parsed because there was not enough space in the
// buffer.
inline const uint8_t* ParseVarInt(const uint8_t* start,
                                  const uint8_t* end,
                                  uint64_t* value) {
  const uint8_t* pos = start;
  uint64_t shift = 0;
  *value = 0;
  do {
    if (PERFETTO_UNLIKELY(pos >= end)) {
      *value = 0;
      return start;
    }
    PERFETTO_DCHECK(shift < 64ull);
    *value |= static_cast<uint64_t>(*pos & 0x7f) << shift;
    shift += 7;
  } while (*pos++ & 0x80);
  return pos;
}

}  // namespace proto_utils
}  // namespace protozero

#endif  // INCLUDE_PERFETTO_PROTOZERO_PROTO_UTILS_H_
// gen_amalgamated begin header: include/perfetto/protozero/scattered_stream_writer.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_PROTOZERO_SCATTERED_STREAM_WRITER_H_
#define INCLUDE_PERFETTO_PROTOZERO_SCATTERED_STREAM_WRITER_H_

#include <assert.h>
#include <stddef.h>
#include <stdint.h>
#include <string.h>

// gen_amalgamated expanded: #include "perfetto/base/compiler.h"
// gen_amalgamated expanded: #include "perfetto/base/export.h"
// gen_amalgamated expanded: #include "perfetto/protozero/contiguous_memory_range.h"

namespace protozero {

// This class deals with the following problem: append-only proto messages want
// to write a stream of bytes, without caring about the implementation of the
// underlying buffer (which concretely will be either the trace ring buffer
// or a heap-allocated buffer). The main deal is: proto messages don't know in
// advance what their size will be.
// Due to the tracing buffer being split into fixed-size chunks, on some
// occasions, these writes need to be spread over two (or more) non-contiguous
// chunks of memory. Similarly, when the buffer is backed by the heap, we want
// to avoid realloc() calls, as they might cause a full copy of the contents
// of the buffer.
// The purpose of this class is to abstract away the non-contiguous write logic.
// This class knows how to deal with writes as long as they fall in the same
// ContiguousMemoryRange and defers the chunk-chaining logic to the Delegate.
class PERFETTO_EXPORT ScatteredStreamWriter {
 public:
  class PERFETTO_EXPORT Delegate {
   public:
    virtual ~Delegate();
    virtual ContiguousMemoryRange GetNewBuffer() = 0;
  };

  explicit ScatteredStreamWriter(Delegate* delegate);
  ~ScatteredStreamWriter();

  inline void WriteByte(uint8_t value) {
    if (write_ptr_ >= cur_range_.end)
      Extend();
    *write_ptr_++ = value;
  }

  // Assumes that the caller checked that there is enough headroom.
  // TODO(primiano): perf optimization, this is a tracing hot path. The
  // compiler can make strong optimization on memcpy if the size arg is a
  // constexpr. Make a templated variant of this for fixed-size writes.
  // TODO(primiano): restrict / noalias might also help.
  inline void WriteBytesUnsafe(const uint8_t* src, size_t size) {
    uint8_t* const end = write_ptr_ + size;
    assert(end <= cur_range_.end);
    memcpy(write_ptr_, src, size);
    write_ptr_ = end;
  }

  inline void WriteBytes(const uint8_t* src, size_t size) {
    uint8_t* const end = write_ptr_ + size;
    if (PERFETTO_LIKELY(end <= cur_range_.end))
      return WriteBytesUnsafe(src, size);
    WriteBytesSlowPath(src, size);
  }

  void WriteBytesSlowPath(const uint8_t* src, size_t size);

  // Reserves a fixed amount of bytes to be backfilled later. The reserved range
  // is guaranteed to be contiguous and not span across chunks. |size| has to be
  // <= than the size of a new buffer returned by the Delegate::GetNewBuffer().
  uint8_t* ReserveBytes(size_t size);

  // Fast (but unsafe) version of the above. The caller must have previously
  // checked that there are at least |size| contiguous bytes available.
  // Returns only the start pointer of the reservation.
  uint8_t* ReserveBytesUnsafe(size_t size) {
    uint8_t* begin = write_ptr_;
    write_ptr_ += size;
    assert(write_ptr_ <= cur_range_.end);
    return begin;
  }

  // Resets the buffer boundaries and the write pointer to the given |range|.
  // Subsequent WriteByte(s) will write into |range|.
  void Reset(ContiguousMemoryRange range);

  // Number of contiguous free bytes in |cur_range_| that can be written without
  // requesting a new buffer.
  size_t bytes_available() const {
    return static_cast<size_t>(cur_range_.end - write_ptr_);
  }

  uint8_t* write_ptr() const { return write_ptr_; }

  uint64_t written() const {
    return written_previously_ +
           static_cast<uint64_t>(write_ptr_ - cur_range_.begin);
  }

 private:
  ScatteredStreamWriter(const ScatteredStreamWriter&) = delete;
  ScatteredStreamWriter& operator=(const ScatteredStreamWriter&) = delete;

  void Extend();

  Delegate* const delegate_;
  ContiguousMemoryRange cur_range_;
  uint8_t* write_ptr_;
  uint64_t written_previously_ = 0;
};

}  // namespace protozero

#endif  // INCLUDE_PERFETTO_PROTOZERO_SCATTERED_STREAM_WRITER_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_PROTOZERO_MESSAGE_H_
#define INCLUDE_PERFETTO_PROTOZERO_MESSAGE_H_

#include <assert.h>
#include <stdint.h>
#include <string.h>

#include <type_traits>

// gen_amalgamated expanded: #include "perfetto/base/export.h"
// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/protozero/contiguous_memory_range.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"
// gen_amalgamated expanded: #include "perfetto/protozero/scattered_stream_writer.h"

namespace perfetto {
namespace shm_fuzz {
class FakeProducer;
}  // namespace shm_fuzz
}  // namespace perfetto

namespace protozero {

class MessageHandleBase;

// Base class extended by the proto C++ stubs generated by the ProtoZero
// compiler. This class provides the minimal runtime required to support
// append-only operations and is designed for performance. None of the methods
// require any dynamic memory allocation.
class PERFETTO_EXPORT Message {
 public:
  friend class MessageHandleBase;
  // Grant end_to_end_shared_memory_fuzzer access in order to write raw
  // bytes into the buffer.
  friend class ::perfetto::shm_fuzz::FakeProducer;
  // Adjust the |nested_messages_arena_| size when changing this, or the
  // static_assert in the .cc file will bark.
  static constexpr uint32_t kMaxNestingDepth = 10;

  // Ctor and Dtor of Message are never called, with the exeception
  // of root (non-nested) messages. Nested messages are allocated via placement
  // new in the |nested_messages_arena_| and implictly destroyed when the arena
  // of the root message goes away. This is fine as long as all the fields are
  // PODs, which is checked by the static_assert in the ctor (see the Reset()
  // method in the .cc file).
  Message() = default;

  // Clears up the state, allowing the message to be reused as a fresh one.
  void Reset(ScatteredStreamWriter*);

  // Commits all the changes to the buffer (backfills the size field of this and
  // all nested messages) and seals the message. Returns the size of the message
  // (and all nested sub-messages), without taking into account any chunking.
  // Finalize is idempotent and can be called several times w/o side effects.
  uint32_t Finalize();

  // Optional. If is_valid() == true, the corresponding memory region (its
  // length == proto_utils::kMessageLengthFieldSize) is backfilled with the size
  // of this message (minus |size_already_written| below). This is the mechanism
  // used by messages to backfill their corresponding size field in the parent
  // message.
  uint8_t* size_field() const { return size_field_; }
  void set_size_field(uint8_t* size_field) { size_field_ = size_field; }

  // This is to deal with case of backfilling the size of a root (non-nested)
  // message which is split into multiple chunks. Upon finalization only the
  // partial size that lies in the last chunk has to be backfilled.
  void inc_size_already_written(uint32_t sz) { size_already_written_ += sz; }

  Message* nested_message() { return nested_message_; }

  bool is_finalized() const { return finalized_; }

#if PERFETTO_DCHECK_IS_ON()
  void set_handle(MessageHandleBase* handle) { handle_ = handle; }
#endif

  // Proto types: uint64, uint32, int64, int32, bool, enum.
  template <typename T>
  void AppendVarInt(uint32_t field_id, T value) {
    if (nested_message_)
      EndNestedMessage();

    uint8_t buffer[proto_utils::kMaxSimpleFieldEncodedSize];
    uint8_t* pos = buffer;

    pos = proto_utils::WriteVarInt(proto_utils::MakeTagVarInt(field_id), pos);
    // WriteVarInt encodes signed values in two's complement form.
    pos = proto_utils::WriteVarInt(value, pos);
    WriteToStream(buffer, pos);
  }

  // Proto types: sint64, sint32.
  template <typename T>
  void AppendSignedVarInt(uint32_t field_id, T value) {
    AppendVarInt(field_id, proto_utils::ZigZagEncode(value));
  }

  // Proto types: bool, enum (small).
  // Faster version of AppendVarInt for tiny numbers.
  void AppendTinyVarInt(uint32_t field_id, int32_t value) {
    PERFETTO_DCHECK(0 <= value && value < 0x80);
    if (nested_message_)
      EndNestedMessage();

    uint8_t buffer[proto_utils::kMaxSimpleFieldEncodedSize];
    uint8_t* pos = buffer;
    // MakeTagVarInt gets super optimized here for constexpr.
    pos = proto_utils::WriteVarInt(proto_utils::MakeTagVarInt(field_id), pos);
    *pos++ = static_cast<uint8_t>(value);
    WriteToStream(buffer, pos);
  }

  // Proto types: fixed64, sfixed64, fixed32, sfixed32, double, float.
  template <typename T>
  void AppendFixed(uint32_t field_id, T value) {
    if (nested_message_)
      EndNestedMessage();

    uint8_t buffer[proto_utils::kMaxSimpleFieldEncodedSize];
    uint8_t* pos = buffer;

    pos = proto_utils::WriteVarInt(proto_utils::MakeTagFixed<T>(field_id), pos);
    memcpy(pos, &value, sizeof(T));
    pos += sizeof(T);
    // TODO: Optimize memcpy performance, see http://crbug.com/624311 .
    WriteToStream(buffer, pos);
  }

  void AppendString(uint32_t field_id, const char* str);
  void AppendBytes(uint32_t field_id, const void* value, size_t size);

  // Append raw bytes for a field, using the supplied |ranges| to
  // copy from |num_ranges| individual buffers.
  size_t AppendScatteredBytes(uint32_t field_id,
                              ContiguousMemoryRange* ranges,
                              size_t num_ranges);

  // Begins a nested message, using the static storage provided by the parent
  // class (see comment in |nested_messages_arena_|). The nested message ends
  // either when Finalize() is called or when any other Append* method is called
  // in the parent class.
  // The template argument T is supposed to be a stub class auto generated from
  // a .proto, hence a subclass of Message.
  template <class T>
  T* BeginNestedMessage(uint32_t field_id) {
    // This is to prevent subclasses (which should be autogenerated, though), to
    // introduce extra state fields (which wouldn't be initialized by Reset()).
    static_assert(std::is_base_of<Message, T>::value,
                  "T must be a subclass of Message");
    static_assert(sizeof(T) == sizeof(Message),
                  "Message subclasses cannot introduce extra state.");
    T* message = reinterpret_cast<T*>(nested_messages_arena_);
    BeginNestedMessageInternal(field_id, message);
    return message;
  }

 private:
  Message(const Message&) = delete;
  Message& operator=(const Message&) = delete;

  void BeginNestedMessageInternal(uint32_t field_id, Message*);

  // Called by Finalize and Append* methods.
  void EndNestedMessage();

  void WriteToStream(const uint8_t* src_begin, const uint8_t* src_end) {
    PERFETTO_DCHECK(!finalized_);
    PERFETTO_DCHECK(src_begin <= src_end);
    const uint32_t size = static_cast<uint32_t>(src_end - src_begin);
    stream_writer_->WriteBytes(src_begin, size);
    size_ += size;
  }

  // Only POD fields are allowed. This class's dtor is never called.
  // See the comment on the static_assert in the corresponding .cc file.

  // The stream writer interface used for the serialization.
  ScatteredStreamWriter* stream_writer_;

  uint8_t* size_field_;

  // Keeps track of the size of the current message.
  uint32_t size_;

  // See comment for inc_size_already_written().
  uint32_t size_already_written_;

  // When true, no more changes to the message are allowed. This is to DCHECK
  // attempts of writing to a message which has been Finalize()-d.
  bool finalized_;

  // Used to detect attemps to create messages with a nesting level >
  // kMaxNestingDepth. |nesting_depth_| == 0 for root (non-nested) messages.
  uint8_t nesting_depth_;

#if PERFETTO_DCHECK_IS_ON()
  // Current generation of message. Incremented on Reset.
  // Used to detect stale handles.
  uint32_t generation_;

  MessageHandleBase* handle_;
#endif

  // Pointer to the last child message created through BeginNestedMessage(), if
  // any, nullptr otherwise. There is no need to keep track of more than one
  // message per nesting level as the proto-zero API contract mandates that
  // nested fields can be filled only in a stacked fashion. In other words,
  // nested messages are finalized and sealed when any other field is set in the
  // parent message (or the parent message itself is finalized) and cannot be
  // accessed anymore afterwards.
  // TODO(primiano): optimization: I think that nested_message_, when non-null.
  // will always be @ (this) + offsetof(nested_messages_arena_).
  Message* nested_message_;

  // The root message owns the storage for all its nested messages, up to a max
  // of kMaxNestingDepth levels (see the .cc file). Note that the boundaries of
  // the arena are meaningful only for the root message.
  // Unfortunately we cannot put the sizeof() math here because we cannot sizeof
  // the current class in a header. However the .cc file has a static_assert
  // that guarantees that (see the Reset() method in the .cc file).
  alignas(sizeof(void*)) uint8_t nested_messages_arena_[512];

  // DO NOT add any fields below |nested_messages_arena_|. The memory layout of
  // nested messages would overflow the storage allocated by the root message.
};

}  // namespace protozero

#endif  // INCLUDE_PERFETTO_PROTOZERO_MESSAGE_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_PROTOZERO_MESSAGE_HANDLE_H_
#define INCLUDE_PERFETTO_PROTOZERO_MESSAGE_HANDLE_H_

#include <functional>

// gen_amalgamated expanded: #include "perfetto/base/export.h"
// gen_amalgamated expanded: #include "perfetto/protozero/message.h"

namespace protozero {

class Message;

// MessageHandle allows to decouple the lifetime of a proto message
// from the underlying storage. It gives the following guarantees:
// - The underlying message is finalized (if still alive) if the handle goes
//   out of scope.
// - In Debug / DCHECK_ALWAYS_ON builds, the handle becomes null once the
//   message is finalized. This is to enforce the append-only API. For instance
//   when adding two repeated messages, the addition of the 2nd one forces
//   the finalization of the first.
// Think about this as a WeakPtr<Message> which calls
// Message::Finalize() when going out of scope.

class PERFETTO_EXPORT MessageHandleBase {
 public:
  class FinalizationListener {
   public:
    virtual ~FinalizationListener();
    virtual void OnMessageFinalized(Message* message) = 0;
  };

  ~MessageHandleBase();

  // Move-only type.
  MessageHandleBase(MessageHandleBase&&) noexcept;
  MessageHandleBase& operator=(MessageHandleBase&&);
  explicit operator bool() const {
#if PERFETTO_DCHECK_IS_ON()
    PERFETTO_DCHECK(!message_ || generation_ == message_->generation_);
#endif
    return !!message_;
  }

  void set_finalization_listener(FinalizationListener* listener) {
    listener_ = listener;
  }

 protected:
  explicit MessageHandleBase(Message* = nullptr);
  Message* operator->() const {
#if PERFETTO_DCHECK_IS_ON()
    PERFETTO_DCHECK(!message_ || generation_ == message_->generation_);
#endif
    return message_;
  }
  Message& operator*() const { return *(operator->()); }

 private:
  friend class Message;
  MessageHandleBase(const MessageHandleBase&) = delete;
  MessageHandleBase& operator=(const MessageHandleBase&) = delete;

  void reset_message() {
    // This is called by Message::Finalize().
    PERFETTO_DCHECK(message_->is_finalized());
    message_ = nullptr;
    listener_ = nullptr;
  }

  void Move(MessageHandleBase&&);

  void FinalizeMessage() {
    // |message_| and |listener_| may be cleared by reset_message() during
    // Message::Finalize().
    auto* listener = listener_;
    auto* message = message_;
    message->Finalize();
    if (listener)
      listener->OnMessageFinalized(message);
  }

  Message* message_;
  FinalizationListener* listener_ = nullptr;
#if PERFETTO_DCHECK_IS_ON()
  uint32_t generation_;
#endif
};

template <typename T>
class MessageHandle : public MessageHandleBase {
 public:
  MessageHandle() : MessageHandle(nullptr) {}
  explicit MessageHandle(T* message) : MessageHandleBase(message) {}

  T& operator*() const {
    return static_cast<T&>(MessageHandleBase::operator*());
  }

  T* operator->() const {
    return static_cast<T*>(MessageHandleBase::operator->());
  }
};

}  // namespace protozero

#endif  // INCLUDE_PERFETTO_PROTOZERO_MESSAGE_HANDLE_H_
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_TRACING_TRACE_WRITER_BASE_H_
#define INCLUDE_PERFETTO_TRACING_TRACE_WRITER_BASE_H_

// gen_amalgamated expanded: #include "perfetto/protozero/message_handle.h"

namespace perfetto {

namespace protos {
namespace pbzero {
class TracePacket;
}  // namespace pbzero
}  // namespace protos

// The bare-minimum subset of the TraceWriter interface that is exposed as a
// fully public API.
class TraceWriterBase {
 public:
  virtual ~TraceWriterBase();
  virtual protozero::MessageHandle<protos::pbzero::TracePacket>
  NewTracePacket() = 0;
};

}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_TRACING_TRACE_WRITER_BASE_H_
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "perfetto/tracing/trace_writer_base.h"

namespace perfetto {

// This destructor needs to be defined in a dedicated translation unit and
// cannot be merged together with the other ones in virtual_destructors.cc.
// This is because trace_writer_base.h/cc  is part of a separate target
// (src/public:common) that is linked also by other part of the codebase.

TraceWriterBase::~TraceWriterBase() = default;

}  // namespace perfetto
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/common/android_log_constants.pb.cc
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/common/android_log_constants.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/common/android_log_constants.proto

#ifndef PROTOBUF_perfetto_2fcommon_2fandroid_5flog_5fconstants_2eproto__INCLUDED
#define PROTOBUF_perfetto_2fcommon_2fandroid_5flog_5fconstants_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_perfetto_2fcommon_2fandroid_5flog_5fconstants_2eproto();
void protobuf_AssignDesc_perfetto_2fcommon_2fandroid_5flog_5fconstants_2eproto();
void protobuf_ShutdownFile_perfetto_2fcommon_2fandroid_5flog_5fconstants_2eproto();


enum AndroidLogId {
  LID_DEFAULT = 0,
  LID_RADIO = 1,
  LID_EVENTS = 2,
  LID_SYSTEM = 3,
  LID_CRASH = 4,
  LID_STATS = 5,
  LID_SECURITY = 6,
  LID_KERNEL = 7
};
bool AndroidLogId_IsValid(int value);
const AndroidLogId AndroidLogId_MIN = LID_DEFAULT;
const AndroidLogId AndroidLogId_MAX = LID_KERNEL;
const int AndroidLogId_ARRAYSIZE = AndroidLogId_MAX + 1;

enum AndroidLogPriority {
  PRIO_UNSPECIFIED = 0,
  PRIO_UNUSED = 1,
  PRIO_VERBOSE = 2,
  PRIO_DEBUG = 3,
  PRIO_INFO = 4,
  PRIO_WARN = 5,
  PRIO_ERROR = 6,
  PRIO_FATAL = 7
};
bool AndroidLogPriority_IsValid(int value);
const AndroidLogPriority AndroidLogPriority_MIN = PRIO_UNSPECIFIED;
const AndroidLogPriority AndroidLogPriority_MAX = PRIO_FATAL;
const int AndroidLogPriority_ARRAYSIZE = AndroidLogPriority_MAX + 1;

// ===================================================================


// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::perfetto::protos::AndroidLogId> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::perfetto::protos::AndroidLogPriority> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_perfetto_2fcommon_2fandroid_5flog_5fconstants_2eproto__INCLUDED
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/common/android_log_constants.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
// gen_amalgamated expanded: #include "perfetto/common/android_log_constants.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

void protobuf_ShutdownFile_perfetto_2fcommon_2fandroid_5flog_5fconstants_2eproto() {
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_perfetto_2fcommon_2fandroid_5flog_5fconstants_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_perfetto_2fcommon_2fandroid_5flog_5fconstants_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_perfetto_2fcommon_2fandroid_5flog_5fconstants_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_perfetto_2fcommon_2fandroid_5flog_5fconstants_2eproto_once_);
void protobuf_AddDesc_perfetto_2fcommon_2fandroid_5flog_5fconstants_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_perfetto_2fcommon_2fandroid_5flog_5fconstants_2eproto_once_,
                 &protobuf_AddDesc_perfetto_2fcommon_2fandroid_5flog_5fconstants_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_perfetto_2fcommon_2fandroid_5flog_5fconstants_2eproto {
  StaticDescriptorInitializer_perfetto_2fcommon_2fandroid_5flog_5fconstants_2eproto() {
    protobuf_AddDesc_perfetto_2fcommon_2fandroid_5flog_5fconstants_2eproto();
  }
} static_descriptor_initializer_perfetto_2fcommon_2fandroid_5flog_5fconstants_2eproto_;
#endif
bool AndroidLogId_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

bool AndroidLogPriority_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/common/commit_data_request.pb.cc
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/common/commit_data_request.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/common/commit_data_request.proto

#ifndef PROTOBUF_perfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto__INCLUDED
#define PROTOBUF_perfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_perfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();
void protobuf_AssignDesc_perfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();
void protobuf_ShutdownFile_perfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();

class CommitDataRequest;
class CommitDataRequest_ChunkToPatch;
class CommitDataRequest_ChunkToPatch_Patch;
class CommitDataRequest_ChunksToMove;

// ===================================================================

class CommitDataRequest_ChunksToMove : public ::google::protobuf::MessageLite {
 public:
  CommitDataRequest_ChunksToMove();
  virtual ~CommitDataRequest_ChunksToMove();

  CommitDataRequest_ChunksToMove(const CommitDataRequest_ChunksToMove& from);

  inline CommitDataRequest_ChunksToMove& operator=(const CommitDataRequest_ChunksToMove& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const CommitDataRequest_ChunksToMove& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommitDataRequest_ChunksToMove* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommitDataRequest_ChunksToMove* other);

  // implements Message ----------------------------------------------

  inline CommitDataRequest_ChunksToMove* New() const { return New(NULL); }

  CommitDataRequest_ChunksToMove* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommitDataRequest_ChunksToMove& from);
  void MergeFrom(const CommitDataRequest_ChunksToMove& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommitDataRequest_ChunksToMove* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 page = 1;
  bool has_page() const;
  void clear_page();
  static const int kPageFieldNumber = 1;
  ::google::protobuf::uint32 page() const;
  void set_page(::google::protobuf::uint32 value);

  // optional uint32 chunk = 2;
  bool has_chunk() const;
  void clear_chunk();
  static const int kChunkFieldNumber = 2;
  ::google::protobuf::uint32 chunk() const;
  void set_chunk(::google::protobuf::uint32 value);

  // optional uint32 target_buffer = 3;
  bool has_target_buffer() const;
  void clear_target_buffer();
  static const int kTargetBufferFieldNumber = 3;
  ::google::protobuf::uint32 target_buffer() const;
  void set_target_buffer(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.CommitDataRequest.ChunksToMove)
 private:
  inline void set_has_page();
  inline void clear_has_page();
  inline void set_has_chunk();
  inline void clear_has_chunk();
  inline void set_has_target_buffer();
  inline void clear_has_target_buffer();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 page_;
  ::google::protobuf::uint32 chunk_;
  ::google::protobuf::uint32 target_buffer_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();

  void InitAsDefaultInstance();
  static CommitDataRequest_ChunksToMove* default_instance_;
};
// -------------------------------------------------------------------

class CommitDataRequest_ChunkToPatch_Patch : public ::google::protobuf::MessageLite {
 public:
  CommitDataRequest_ChunkToPatch_Patch();
  virtual ~CommitDataRequest_ChunkToPatch_Patch();

  CommitDataRequest_ChunkToPatch_Patch(const CommitDataRequest_ChunkToPatch_Patch& from);

  inline CommitDataRequest_ChunkToPatch_Patch& operator=(const CommitDataRequest_ChunkToPatch_Patch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const CommitDataRequest_ChunkToPatch_Patch& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommitDataRequest_ChunkToPatch_Patch* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommitDataRequest_ChunkToPatch_Patch* other);

  // implements Message ----------------------------------------------

  inline CommitDataRequest_ChunkToPatch_Patch* New() const { return New(NULL); }

  CommitDataRequest_ChunkToPatch_Patch* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommitDataRequest_ChunkToPatch_Patch& from);
  void MergeFrom(const CommitDataRequest_ChunkToPatch_Patch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommitDataRequest_ChunkToPatch_Patch* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 offset = 1;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 1;
  ::google::protobuf::uint32 offset() const;
  void set_offset(::google::protobuf::uint32 value);

  // optional bytes data = 2;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:perfetto.protos.CommitDataRequest.ChunkToPatch.Patch)
 private:
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::uint32 offset_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();

  void InitAsDefaultInstance();
  static CommitDataRequest_ChunkToPatch_Patch* default_instance_;
};
// -------------------------------------------------------------------

class CommitDataRequest_ChunkToPatch : public ::google::protobuf::MessageLite {
 public:
  CommitDataRequest_ChunkToPatch();
  virtual ~CommitDataRequest_ChunkToPatch();

  CommitDataRequest_ChunkToPatch(const CommitDataRequest_ChunkToPatch& from);

  inline CommitDataRequest_ChunkToPatch& operator=(const CommitDataRequest_ChunkToPatch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const CommitDataRequest_ChunkToPatch& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommitDataRequest_ChunkToPatch* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommitDataRequest_ChunkToPatch* other);

  // implements Message ----------------------------------------------

  inline CommitDataRequest_ChunkToPatch* New() const { return New(NULL); }

  CommitDataRequest_ChunkToPatch* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommitDataRequest_ChunkToPatch& from);
  void MergeFrom(const CommitDataRequest_ChunkToPatch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommitDataRequest_ChunkToPatch* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CommitDataRequest_ChunkToPatch_Patch Patch;

  // accessors -------------------------------------------------------

  // optional uint32 target_buffer = 1;
  bool has_target_buffer() const;
  void clear_target_buffer();
  static const int kTargetBufferFieldNumber = 1;
  ::google::protobuf::uint32 target_buffer() const;
  void set_target_buffer(::google::protobuf::uint32 value);

  // optional uint32 writer_id = 2;
  bool has_writer_id() const;
  void clear_writer_id();
  static const int kWriterIdFieldNumber = 2;
  ::google::protobuf::uint32 writer_id() const;
  void set_writer_id(::google::protobuf::uint32 value);

  // optional uint32 chunk_id = 3;
  bool has_chunk_id() const;
  void clear_chunk_id();
  static const int kChunkIdFieldNumber = 3;
  ::google::protobuf::uint32 chunk_id() const;
  void set_chunk_id(::google::protobuf::uint32 value);

  // repeated .perfetto.protos.CommitDataRequest.ChunkToPatch.Patch patches = 4;
  int patches_size() const;
  void clear_patches();
  static const int kPatchesFieldNumber = 4;
  const ::perfetto::protos::CommitDataRequest_ChunkToPatch_Patch& patches(int index) const;
  ::perfetto::protos::CommitDataRequest_ChunkToPatch_Patch* mutable_patches(int index);
  ::perfetto::protos::CommitDataRequest_ChunkToPatch_Patch* add_patches();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::CommitDataRequest_ChunkToPatch_Patch >*
      mutable_patches();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::CommitDataRequest_ChunkToPatch_Patch >&
      patches() const;

  // optional bool has_more_patches = 5;
  bool has_has_more_patches() const;
  void clear_has_more_patches();
  static const int kHasMorePatchesFieldNumber = 5;
  bool has_more_patches() const;
  void set_has_more_patches(bool value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.CommitDataRequest.ChunkToPatch)
 private:
  inline void set_has_target_buffer();
  inline void clear_has_target_buffer();
  inline void set_has_writer_id();
  inline void clear_has_writer_id();
  inline void set_has_chunk_id();
  inline void clear_has_chunk_id();
  inline void set_has_has_more_patches();
  inline void clear_has_has_more_patches();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 target_buffer_;
  ::google::protobuf::uint32 writer_id_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::CommitDataRequest_ChunkToPatch_Patch > patches_;
  ::google::protobuf::uint32 chunk_id_;
  bool has_more_patches_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();

  void InitAsDefaultInstance();
  static CommitDataRequest_ChunkToPatch* default_instance_;
};
// -------------------------------------------------------------------

class CommitDataRequest : public ::google::protobuf::MessageLite {
 public:
  CommitDataRequest();
  virtual ~CommitDataRequest();

  CommitDataRequest(const CommitDataRequest& from);

  inline CommitDataRequest& operator=(const CommitDataRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const CommitDataRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommitDataRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommitDataRequest* other);

  // implements Message ----------------------------------------------

  inline CommitDataRequest* New() const { return New(NULL); }

  CommitDataRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommitDataRequest& from);
  void MergeFrom(const CommitDataRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommitDataRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CommitDataRequest_ChunksToMove ChunksToMove;
  typedef CommitDataRequest_ChunkToPatch ChunkToPatch;

  // accessors -------------------------------------------------------

  // repeated .perfetto.protos.CommitDataRequest.ChunksToMove chunks_to_move = 1;
  int chunks_to_move_size() const;
  void clear_chunks_to_move();
  static const int kChunksToMoveFieldNumber = 1;
  const ::perfetto::protos::CommitDataRequest_ChunksToMove& chunks_to_move(int index) const;
  ::perfetto::protos::CommitDataRequest_ChunksToMove* mutable_chunks_to_move(int index);
  ::perfetto::protos::CommitDataRequest_ChunksToMove* add_chunks_to_move();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::CommitDataRequest_ChunksToMove >*
      mutable_chunks_to_move();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::CommitDataRequest_ChunksToMove >&
      chunks_to_move() const;

  // repeated .perfetto.protos.CommitDataRequest.ChunkToPatch chunks_to_patch = 2;
  int chunks_to_patch_size() const;
  void clear_chunks_to_patch();
  static const int kChunksToPatchFieldNumber = 2;
  const ::perfetto::protos::CommitDataRequest_ChunkToPatch& chunks_to_patch(int index) const;
  ::perfetto::protos::CommitDataRequest_ChunkToPatch* mutable_chunks_to_patch(int index);
  ::perfetto::protos::CommitDataRequest_ChunkToPatch* add_chunks_to_patch();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::CommitDataRequest_ChunkToPatch >*
      mutable_chunks_to_patch();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::CommitDataRequest_ChunkToPatch >&
      chunks_to_patch() const;

  // optional uint64 flush_request_id = 3;
  bool has_flush_request_id() const;
  void clear_flush_request_id();
  static const int kFlushRequestIdFieldNumber = 3;
  ::google::protobuf::uint64 flush_request_id() const;
  void set_flush_request_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.CommitDataRequest)
 private:
  inline void set_has_flush_request_id();
  inline void clear_has_flush_request_id();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::CommitDataRequest_ChunksToMove > chunks_to_move_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::CommitDataRequest_ChunkToPatch > chunks_to_patch_;
  ::google::protobuf::uint64 flush_request_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();

  void InitAsDefaultInstance();
  static CommitDataRequest* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// CommitDataRequest_ChunksToMove

// optional uint32 page = 1;
inline bool CommitDataRequest_ChunksToMove::has_page() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommitDataRequest_ChunksToMove::set_has_page() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommitDataRequest_ChunksToMove::clear_has_page() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommitDataRequest_ChunksToMove::clear_page() {
  page_ = 0u;
  clear_has_page();
}
inline ::google::protobuf::uint32 CommitDataRequest_ChunksToMove::page() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.CommitDataRequest.ChunksToMove.page)
  return page_;
}
inline void CommitDataRequest_ChunksToMove::set_page(::google::protobuf::uint32 value) {
  set_has_page();
  page_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.CommitDataRequest.ChunksToMove.page)
}

// optional uint32 chunk = 2;
inline bool CommitDataRequest_ChunksToMove::has_chunk() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommitDataRequest_ChunksToMove::set_has_chunk() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommitDataRequest_ChunksToMove::clear_has_chunk() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommitDataRequest_ChunksToMove::clear_chunk() {
  chunk_ = 0u;
  clear_has_chunk();
}
inline ::google::protobuf::uint32 CommitDataRequest_ChunksToMove::chunk() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.CommitDataRequest.ChunksToMove.chunk)
  return chunk_;
}
inline void CommitDataRequest_ChunksToMove::set_chunk(::google::protobuf::uint32 value) {
  set_has_chunk();
  chunk_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.CommitDataRequest.ChunksToMove.chunk)
}

// optional uint32 target_buffer = 3;
inline bool CommitDataRequest_ChunksToMove::has_target_buffer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommitDataRequest_ChunksToMove::set_has_target_buffer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommitDataRequest_ChunksToMove::clear_has_target_buffer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommitDataRequest_ChunksToMove::clear_target_buffer() {
  target_buffer_ = 0u;
  clear_has_target_buffer();
}
inline ::google::protobuf::uint32 CommitDataRequest_ChunksToMove::target_buffer() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.CommitDataRequest.ChunksToMove.target_buffer)
  return target_buffer_;
}
inline void CommitDataRequest_ChunksToMove::set_target_buffer(::google::protobuf::uint32 value) {
  set_has_target_buffer();
  target_buffer_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.CommitDataRequest.ChunksToMove.target_buffer)
}

// -------------------------------------------------------------------

// CommitDataRequest_ChunkToPatch_Patch

// optional uint32 offset = 1;
inline bool CommitDataRequest_ChunkToPatch_Patch::has_offset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommitDataRequest_ChunkToPatch_Patch::set_has_offset() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommitDataRequest_ChunkToPatch_Patch::clear_has_offset() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommitDataRequest_ChunkToPatch_Patch::clear_offset() {
  offset_ = 0u;
  clear_has_offset();
}
inline ::google::protobuf::uint32 CommitDataRequest_ChunkToPatch_Patch::offset() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.CommitDataRequest.ChunkToPatch.Patch.offset)
  return offset_;
}
inline void CommitDataRequest_ChunkToPatch_Patch::set_offset(::google::protobuf::uint32 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.CommitDataRequest.ChunkToPatch.Patch.offset)
}

// optional bytes data = 2;
inline bool CommitDataRequest_ChunkToPatch_Patch::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommitDataRequest_ChunkToPatch_Patch::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommitDataRequest_ChunkToPatch_Patch::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommitDataRequest_ChunkToPatch_Patch::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
inline const ::std::string& CommitDataRequest_ChunkToPatch_Patch::data() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.CommitDataRequest.ChunkToPatch.Patch.data)
  return data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CommitDataRequest_ChunkToPatch_Patch::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.CommitDataRequest.ChunkToPatch.Patch.data)
}
inline void CommitDataRequest_ChunkToPatch_Patch::set_data(const char* value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.CommitDataRequest.ChunkToPatch.Patch.data)
}
inline void CommitDataRequest_ChunkToPatch_Patch::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.CommitDataRequest.ChunkToPatch.Patch.data)
}
inline ::std::string* CommitDataRequest_ChunkToPatch_Patch::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.CommitDataRequest.ChunkToPatch.Patch.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CommitDataRequest_ChunkToPatch_Patch::release_data() {
  // @@protoc_insertion_point(field_release:perfetto.protos.CommitDataRequest.ChunkToPatch.Patch.data)
  clear_has_data();
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CommitDataRequest_ChunkToPatch_Patch::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.CommitDataRequest.ChunkToPatch.Patch.data)
}

// -------------------------------------------------------------------

// CommitDataRequest_ChunkToPatch

// optional uint32 target_buffer = 1;
inline bool CommitDataRequest_ChunkToPatch::has_target_buffer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommitDataRequest_ChunkToPatch::set_has_target_buffer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommitDataRequest_ChunkToPatch::clear_has_target_buffer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommitDataRequest_ChunkToPatch::clear_target_buffer() {
  target_buffer_ = 0u;
  clear_has_target_buffer();
}
inline ::google::protobuf::uint32 CommitDataRequest_ChunkToPatch::target_buffer() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.CommitDataRequest.ChunkToPatch.target_buffer)
  return target_buffer_;
}
inline void CommitDataRequest_ChunkToPatch::set_target_buffer(::google::protobuf::uint32 value) {
  set_has_target_buffer();
  target_buffer_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.CommitDataRequest.ChunkToPatch.target_buffer)
}

// optional uint32 writer_id = 2;
inline bool CommitDataRequest_ChunkToPatch::has_writer_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommitDataRequest_ChunkToPatch::set_has_writer_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommitDataRequest_ChunkToPatch::clear_has_writer_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommitDataRequest_ChunkToPatch::clear_writer_id() {
  writer_id_ = 0u;
  clear_has_writer_id();
}
inline ::google::protobuf::uint32 CommitDataRequest_ChunkToPatch::writer_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.CommitDataRequest.ChunkToPatch.writer_id)
  return writer_id_;
}
inline void CommitDataRequest_ChunkToPatch::set_writer_id(::google::protobuf::uint32 value) {
  set_has_writer_id();
  writer_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.CommitDataRequest.ChunkToPatch.writer_id)
}

// optional uint32 chunk_id = 3;
inline bool CommitDataRequest_ChunkToPatch::has_chunk_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommitDataRequest_ChunkToPatch::set_has_chunk_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommitDataRequest_ChunkToPatch::clear_has_chunk_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommitDataRequest_ChunkToPatch::clear_chunk_id() {
  chunk_id_ = 0u;
  clear_has_chunk_id();
}
inline ::google::protobuf::uint32 CommitDataRequest_ChunkToPatch::chunk_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.CommitDataRequest.ChunkToPatch.chunk_id)
  return chunk_id_;
}
inline void CommitDataRequest_ChunkToPatch::set_chunk_id(::google::protobuf::uint32 value) {
  set_has_chunk_id();
  chunk_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.CommitDataRequest.ChunkToPatch.chunk_id)
}

// repeated .perfetto.protos.CommitDataRequest.ChunkToPatch.Patch patches = 4;
inline int CommitDataRequest_ChunkToPatch::patches_size() const {
  return patches_.size();
}
inline void CommitDataRequest_ChunkToPatch::clear_patches() {
  patches_.Clear();
}
inline const ::perfetto::protos::CommitDataRequest_ChunkToPatch_Patch& CommitDataRequest_ChunkToPatch::patches(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.CommitDataRequest.ChunkToPatch.patches)
  return patches_.Get(index);
}
inline ::perfetto::protos::CommitDataRequest_ChunkToPatch_Patch* CommitDataRequest_ChunkToPatch::mutable_patches(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.CommitDataRequest.ChunkToPatch.patches)
  return patches_.Mutable(index);
}
inline ::perfetto::protos::CommitDataRequest_ChunkToPatch_Patch* CommitDataRequest_ChunkToPatch::add_patches() {
  // @@protoc_insertion_point(field_add:perfetto.protos.CommitDataRequest.ChunkToPatch.patches)
  return patches_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::CommitDataRequest_ChunkToPatch_Patch >*
CommitDataRequest_ChunkToPatch::mutable_patches() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.CommitDataRequest.ChunkToPatch.patches)
  return &patches_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::CommitDataRequest_ChunkToPatch_Patch >&
CommitDataRequest_ChunkToPatch::patches() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.CommitDataRequest.ChunkToPatch.patches)
  return patches_;
}

// optional bool has_more_patches = 5;
inline bool CommitDataRequest_ChunkToPatch::has_has_more_patches() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommitDataRequest_ChunkToPatch::set_has_has_more_patches() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommitDataRequest_ChunkToPatch::clear_has_has_more_patches() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommitDataRequest_ChunkToPatch::clear_has_more_patches() {
  has_more_patches_ = false;
  clear_has_has_more_patches();
}
inline bool CommitDataRequest_ChunkToPatch::has_more_patches() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.CommitDataRequest.ChunkToPatch.has_more_patches)
  return has_more_patches_;
}
inline void CommitDataRequest_ChunkToPatch::set_has_more_patches(bool value) {
  set_has_has_more_patches();
  has_more_patches_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.CommitDataRequest.ChunkToPatch.has_more_patches)
}

// -------------------------------------------------------------------

// CommitDataRequest

// repeated .perfetto.protos.CommitDataRequest.ChunksToMove chunks_to_move = 1;
inline int CommitDataRequest::chunks_to_move_size() const {
  return chunks_to_move_.size();
}
inline void CommitDataRequest::clear_chunks_to_move() {
  chunks_to_move_.Clear();
}
inline const ::perfetto::protos::CommitDataRequest_ChunksToMove& CommitDataRequest::chunks_to_move(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.CommitDataRequest.chunks_to_move)
  return chunks_to_move_.Get(index);
}
inline ::perfetto::protos::CommitDataRequest_ChunksToMove* CommitDataRequest::mutable_chunks_to_move(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.CommitDataRequest.chunks_to_move)
  return chunks_to_move_.Mutable(index);
}
inline ::perfetto::protos::CommitDataRequest_ChunksToMove* CommitDataRequest::add_chunks_to_move() {
  // @@protoc_insertion_point(field_add:perfetto.protos.CommitDataRequest.chunks_to_move)
  return chunks_to_move_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::CommitDataRequest_ChunksToMove >*
CommitDataRequest::mutable_chunks_to_move() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.CommitDataRequest.chunks_to_move)
  return &chunks_to_move_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::CommitDataRequest_ChunksToMove >&
CommitDataRequest::chunks_to_move() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.CommitDataRequest.chunks_to_move)
  return chunks_to_move_;
}

// repeated .perfetto.protos.CommitDataRequest.ChunkToPatch chunks_to_patch = 2;
inline int CommitDataRequest::chunks_to_patch_size() const {
  return chunks_to_patch_.size();
}
inline void CommitDataRequest::clear_chunks_to_patch() {
  chunks_to_patch_.Clear();
}
inline const ::perfetto::protos::CommitDataRequest_ChunkToPatch& CommitDataRequest::chunks_to_patch(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.CommitDataRequest.chunks_to_patch)
  return chunks_to_patch_.Get(index);
}
inline ::perfetto::protos::CommitDataRequest_ChunkToPatch* CommitDataRequest::mutable_chunks_to_patch(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.CommitDataRequest.chunks_to_patch)
  return chunks_to_patch_.Mutable(index);
}
inline ::perfetto::protos::CommitDataRequest_ChunkToPatch* CommitDataRequest::add_chunks_to_patch() {
  // @@protoc_insertion_point(field_add:perfetto.protos.CommitDataRequest.chunks_to_patch)
  return chunks_to_patch_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::CommitDataRequest_ChunkToPatch >*
CommitDataRequest::mutable_chunks_to_patch() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.CommitDataRequest.chunks_to_patch)
  return &chunks_to_patch_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::CommitDataRequest_ChunkToPatch >&
CommitDataRequest::chunks_to_patch() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.CommitDataRequest.chunks_to_patch)
  return chunks_to_patch_;
}

// optional uint64 flush_request_id = 3;
inline bool CommitDataRequest::has_flush_request_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommitDataRequest::set_has_flush_request_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommitDataRequest::clear_has_flush_request_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommitDataRequest::clear_flush_request_id() {
  flush_request_id_ = GOOGLE_ULONGLONG(0);
  clear_has_flush_request_id();
}
inline ::google::protobuf::uint64 CommitDataRequest::flush_request_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.CommitDataRequest.flush_request_id)
  return flush_request_id_;
}
inline void CommitDataRequest::set_flush_request_id(::google::protobuf::uint64 value) {
  set_has_flush_request_id();
  flush_request_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.CommitDataRequest.flush_request_id)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_perfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto__INCLUDED
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/common/commit_data_request.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
// gen_amalgamated expanded: #include "perfetto/common/commit_data_request.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

void protobuf_ShutdownFile_perfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto() {
  delete CommitDataRequest::default_instance_;
  delete CommitDataRequest_ChunksToMove::default_instance_;
  delete CommitDataRequest_ChunkToPatch::default_instance_;
  delete CommitDataRequest_ChunkToPatch_Patch::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_perfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_perfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  CommitDataRequest::default_instance_ = new CommitDataRequest();
  CommitDataRequest_ChunksToMove::default_instance_ = new CommitDataRequest_ChunksToMove();
  CommitDataRequest_ChunkToPatch::default_instance_ = new CommitDataRequest_ChunkToPatch();
  CommitDataRequest_ChunkToPatch_Patch::default_instance_ = new CommitDataRequest_ChunkToPatch_Patch();
  CommitDataRequest::default_instance_->InitAsDefaultInstance();
  CommitDataRequest_ChunksToMove::default_instance_->InitAsDefaultInstance();
  CommitDataRequest_ChunkToPatch::default_instance_->InitAsDefaultInstance();
  CommitDataRequest_ChunkToPatch_Patch::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_perfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_perfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto_once_);
void protobuf_AddDesc_perfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_perfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto_once_,
                 &protobuf_AddDesc_perfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_perfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto {
  StaticDescriptorInitializer_perfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto() {
    protobuf_AddDesc_perfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();
  }
} static_descriptor_initializer_perfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto_;
#endif

namespace {

static void commit_data_request_pb_MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
static void commit_data_request_pb_MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

static ::std::string* MutableUnknownFieldsForCommitDataRequest(
    CommitDataRequest* ptr) {
  return ptr->mutable_unknown_fields();
}

static ::std::string* MutableUnknownFieldsForCommitDataRequest_ChunksToMove(
    CommitDataRequest_ChunksToMove* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CommitDataRequest_ChunksToMove::kPageFieldNumber;
const int CommitDataRequest_ChunksToMove::kChunkFieldNumber;
const int CommitDataRequest_ChunksToMove::kTargetBufferFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CommitDataRequest_ChunksToMove::CommitDataRequest_ChunksToMove()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.CommitDataRequest.ChunksToMove)
}

void CommitDataRequest_ChunksToMove::InitAsDefaultInstance() {
}

CommitDataRequest_ChunksToMove::CommitDataRequest_ChunksToMove(const CommitDataRequest_ChunksToMove& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.CommitDataRequest.ChunksToMove)
}

void CommitDataRequest_ChunksToMove::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  page_ = 0u;
  chunk_ = 0u;
  target_buffer_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CommitDataRequest_ChunksToMove::~CommitDataRequest_ChunksToMove() {
  // @@protoc_insertion_point(destructor:perfetto.protos.CommitDataRequest.ChunksToMove)
  SharedDtor();
}

void CommitDataRequest_ChunksToMove::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CommitDataRequest_ChunksToMove::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CommitDataRequest_ChunksToMove& CommitDataRequest_ChunksToMove::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();
#endif
  return *default_instance_;
}

CommitDataRequest_ChunksToMove* CommitDataRequest_ChunksToMove::default_instance_ = NULL;

CommitDataRequest_ChunksToMove* CommitDataRequest_ChunksToMove::New(::google::protobuf::Arena* arena) const {
  CommitDataRequest_ChunksToMove* n = new CommitDataRequest_ChunksToMove;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CommitDataRequest_ChunksToMove::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.CommitDataRequest.ChunksToMove)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(CommitDataRequest_ChunksToMove, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<CommitDataRequest_ChunksToMove*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(page_, target_buffer_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool CommitDataRequest_ChunksToMove::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForCommitDataRequest_ChunksToMove, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.CommitDataRequest.ChunksToMove)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 page = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &page_)));
          set_has_page();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_chunk;
        break;
      }

      // optional uint32 chunk = 2;
      case 2: {
        if (tag == 16) {
         parse_chunk:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &chunk_)));
          set_has_chunk();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_target_buffer;
        break;
      }

      // optional uint32 target_buffer = 3;
      case 3: {
        if (tag == 24) {
         parse_target_buffer:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &target_buffer_)));
          set_has_target_buffer();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.CommitDataRequest.ChunksToMove)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.CommitDataRequest.ChunksToMove)
  return false;
#undef DO_
}

void CommitDataRequest_ChunksToMove::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.CommitDataRequest.ChunksToMove)
  // optional uint32 page = 1;
  if (has_page()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->page(), output);
  }

  // optional uint32 chunk = 2;
  if (has_chunk()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->chunk(), output);
  }

  // optional uint32 target_buffer = 3;
  if (has_target_buffer()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->target_buffer(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.CommitDataRequest.ChunksToMove)
}

int CommitDataRequest_ChunksToMove::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.CommitDataRequest.ChunksToMove)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 7u) {
    // optional uint32 page = 1;
    if (has_page()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->page());
    }

    // optional uint32 chunk = 2;
    if (has_chunk()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->chunk());
    }

    // optional uint32 target_buffer = 3;
    if (has_target_buffer()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->target_buffer());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CommitDataRequest_ChunksToMove::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CommitDataRequest_ChunksToMove*>(&from));
}

void CommitDataRequest_ChunksToMove::MergeFrom(const CommitDataRequest_ChunksToMove& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.CommitDataRequest.ChunksToMove)
  if (GOOGLE_PREDICT_FALSE(&from == this)) commit_data_request_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_page()) {
      set_page(from.page());
    }
    if (from.has_chunk()) {
      set_chunk(from.chunk());
    }
    if (from.has_target_buffer()) {
      set_target_buffer(from.target_buffer());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void CommitDataRequest_ChunksToMove::CopyFrom(const CommitDataRequest_ChunksToMove& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.CommitDataRequest.ChunksToMove)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommitDataRequest_ChunksToMove::IsInitialized() const {

  return true;
}

void CommitDataRequest_ChunksToMove::Swap(CommitDataRequest_ChunksToMove* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CommitDataRequest_ChunksToMove::InternalSwap(CommitDataRequest_ChunksToMove* other) {
  std::swap(page_, other->page_);
  std::swap(chunk_, other->chunk_);
  std::swap(target_buffer_, other->target_buffer_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string CommitDataRequest_ChunksToMove::GetTypeName() const {
  return "perfetto.protos.CommitDataRequest.ChunksToMove";
}


// -------------------------------------------------------------------

static ::std::string* MutableUnknownFieldsForCommitDataRequest_ChunkToPatch(
    CommitDataRequest_ChunkToPatch* ptr) {
  return ptr->mutable_unknown_fields();
}

static ::std::string* MutableUnknownFieldsForCommitDataRequest_ChunkToPatch_Patch(
    CommitDataRequest_ChunkToPatch_Patch* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CommitDataRequest_ChunkToPatch_Patch::kOffsetFieldNumber;
const int CommitDataRequest_ChunkToPatch_Patch::kDataFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CommitDataRequest_ChunkToPatch_Patch::CommitDataRequest_ChunkToPatch_Patch()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.CommitDataRequest.ChunkToPatch.Patch)
}

void CommitDataRequest_ChunkToPatch_Patch::InitAsDefaultInstance() {
}

CommitDataRequest_ChunkToPatch_Patch::CommitDataRequest_ChunkToPatch_Patch(const CommitDataRequest_ChunkToPatch_Patch& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.CommitDataRequest.ChunkToPatch.Patch)
}

void CommitDataRequest_ChunkToPatch_Patch::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  offset_ = 0u;
  data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CommitDataRequest_ChunkToPatch_Patch::~CommitDataRequest_ChunkToPatch_Patch() {
  // @@protoc_insertion_point(destructor:perfetto.protos.CommitDataRequest.ChunkToPatch.Patch)
  SharedDtor();
}

void CommitDataRequest_ChunkToPatch_Patch::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CommitDataRequest_ChunkToPatch_Patch::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CommitDataRequest_ChunkToPatch_Patch& CommitDataRequest_ChunkToPatch_Patch::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();
#endif
  return *default_instance_;
}

CommitDataRequest_ChunkToPatch_Patch* CommitDataRequest_ChunkToPatch_Patch::default_instance_ = NULL;

CommitDataRequest_ChunkToPatch_Patch* CommitDataRequest_ChunkToPatch_Patch::New(::google::protobuf::Arena* arena) const {
  CommitDataRequest_ChunkToPatch_Patch* n = new CommitDataRequest_ChunkToPatch_Patch;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CommitDataRequest_ChunkToPatch_Patch::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.CommitDataRequest.ChunkToPatch.Patch)
  if (_has_bits_[0 / 32] & 3u) {
    offset_ = 0u;
    if (has_data()) {
      data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool CommitDataRequest_ChunkToPatch_Patch::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForCommitDataRequest_ChunkToPatch_Patch, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.CommitDataRequest.ChunkToPatch.Patch)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 offset = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &offset_)));
          set_has_offset();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_data;
        break;
      }

      // optional bytes data = 2;
      case 2: {
        if (tag == 18) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.CommitDataRequest.ChunkToPatch.Patch)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.CommitDataRequest.ChunkToPatch.Patch)
  return false;
#undef DO_
}

void CommitDataRequest_ChunkToPatch_Patch::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.CommitDataRequest.ChunkToPatch.Patch)
  // optional uint32 offset = 1;
  if (has_offset()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->offset(), output);
  }

  // optional bytes data = 2;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.CommitDataRequest.ChunkToPatch.Patch)
}

int CommitDataRequest_ChunkToPatch_Patch::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.CommitDataRequest.ChunkToPatch.Patch)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional uint32 offset = 1;
    if (has_offset()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->offset());
    }

    // optional bytes data = 2;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CommitDataRequest_ChunkToPatch_Patch::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CommitDataRequest_ChunkToPatch_Patch*>(&from));
}

void CommitDataRequest_ChunkToPatch_Patch::MergeFrom(const CommitDataRequest_ChunkToPatch_Patch& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.CommitDataRequest.ChunkToPatch.Patch)
  if (GOOGLE_PREDICT_FALSE(&from == this)) commit_data_request_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_offset()) {
      set_offset(from.offset());
    }
    if (from.has_data()) {
      set_has_data();
      data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.data_);
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void CommitDataRequest_ChunkToPatch_Patch::CopyFrom(const CommitDataRequest_ChunkToPatch_Patch& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.CommitDataRequest.ChunkToPatch.Patch)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommitDataRequest_ChunkToPatch_Patch::IsInitialized() const {

  return true;
}

void CommitDataRequest_ChunkToPatch_Patch::Swap(CommitDataRequest_ChunkToPatch_Patch* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CommitDataRequest_ChunkToPatch_Patch::InternalSwap(CommitDataRequest_ChunkToPatch_Patch* other) {
  std::swap(offset_, other->offset_);
  data_.Swap(&other->data_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string CommitDataRequest_ChunkToPatch_Patch::GetTypeName() const {
  return "perfetto.protos.CommitDataRequest.ChunkToPatch.Patch";
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CommitDataRequest_ChunkToPatch::kTargetBufferFieldNumber;
const int CommitDataRequest_ChunkToPatch::kWriterIdFieldNumber;
const int CommitDataRequest_ChunkToPatch::kChunkIdFieldNumber;
const int CommitDataRequest_ChunkToPatch::kPatchesFieldNumber;
const int CommitDataRequest_ChunkToPatch::kHasMorePatchesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CommitDataRequest_ChunkToPatch::CommitDataRequest_ChunkToPatch()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.CommitDataRequest.ChunkToPatch)
}

void CommitDataRequest_ChunkToPatch::InitAsDefaultInstance() {
}

CommitDataRequest_ChunkToPatch::CommitDataRequest_ChunkToPatch(const CommitDataRequest_ChunkToPatch& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.CommitDataRequest.ChunkToPatch)
}

void CommitDataRequest_ChunkToPatch::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  target_buffer_ = 0u;
  writer_id_ = 0u;
  chunk_id_ = 0u;
  has_more_patches_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CommitDataRequest_ChunkToPatch::~CommitDataRequest_ChunkToPatch() {
  // @@protoc_insertion_point(destructor:perfetto.protos.CommitDataRequest.ChunkToPatch)
  SharedDtor();
}

void CommitDataRequest_ChunkToPatch::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CommitDataRequest_ChunkToPatch::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CommitDataRequest_ChunkToPatch& CommitDataRequest_ChunkToPatch::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();
#endif
  return *default_instance_;
}

CommitDataRequest_ChunkToPatch* CommitDataRequest_ChunkToPatch::default_instance_ = NULL;

CommitDataRequest_ChunkToPatch* CommitDataRequest_ChunkToPatch::New(::google::protobuf::Arena* arena) const {
  CommitDataRequest_ChunkToPatch* n = new CommitDataRequest_ChunkToPatch;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CommitDataRequest_ChunkToPatch::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.CommitDataRequest.ChunkToPatch)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(CommitDataRequest_ChunkToPatch, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<CommitDataRequest_ChunkToPatch*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(target_buffer_, writer_id_);
  ZR_(chunk_id_, has_more_patches_);

#undef ZR_HELPER_
#undef ZR_

  patches_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool CommitDataRequest_ChunkToPatch::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForCommitDataRequest_ChunkToPatch, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.CommitDataRequest.ChunkToPatch)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 target_buffer = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &target_buffer_)));
          set_has_target_buffer();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_writer_id;
        break;
      }

      // optional uint32 writer_id = 2;
      case 2: {
        if (tag == 16) {
         parse_writer_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &writer_id_)));
          set_has_writer_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_chunk_id;
        break;
      }

      // optional uint32 chunk_id = 3;
      case 3: {
        if (tag == 24) {
         parse_chunk_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &chunk_id_)));
          set_has_chunk_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_patches;
        break;
      }

      // repeated .perfetto.protos.CommitDataRequest.ChunkToPatch.Patch patches = 4;
      case 4: {
        if (tag == 34) {
         parse_patches:
          DO_(input->IncrementRecursionDepth());
         parse_loop_patches:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_patches()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_loop_patches;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(40)) goto parse_has_more_patches;
        break;
      }

      // optional bool has_more_patches = 5;
      case 5: {
        if (tag == 40) {
         parse_has_more_patches:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_more_patches_)));
          set_has_has_more_patches();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.CommitDataRequest.ChunkToPatch)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.CommitDataRequest.ChunkToPatch)
  return false;
#undef DO_
}

void CommitDataRequest_ChunkToPatch::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.CommitDataRequest.ChunkToPatch)
  // optional uint32 target_buffer = 1;
  if (has_target_buffer()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->target_buffer(), output);
  }

  // optional uint32 writer_id = 2;
  if (has_writer_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->writer_id(), output);
  }

  // optional uint32 chunk_id = 3;
  if (has_chunk_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->chunk_id(), output);
  }

  // repeated .perfetto.protos.CommitDataRequest.ChunkToPatch.Patch patches = 4;
  for (unsigned int i = 0, n = this->patches_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->patches(i), output);
  }

  // optional bool has_more_patches = 5;
  if (has_has_more_patches()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->has_more_patches(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.CommitDataRequest.ChunkToPatch)
}

int CommitDataRequest_ChunkToPatch::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.CommitDataRequest.ChunkToPatch)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 23u) {
    // optional uint32 target_buffer = 1;
    if (has_target_buffer()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->target_buffer());
    }

    // optional uint32 writer_id = 2;
    if (has_writer_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->writer_id());
    }

    // optional uint32 chunk_id = 3;
    if (has_chunk_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->chunk_id());
    }

    // optional bool has_more_patches = 5;
    if (has_has_more_patches()) {
      total_size += 1 + 1;
    }

  }
  // repeated .perfetto.protos.CommitDataRequest.ChunkToPatch.Patch patches = 4;
  total_size += 1 * this->patches_size();
  for (int i = 0; i < this->patches_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->patches(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CommitDataRequest_ChunkToPatch::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CommitDataRequest_ChunkToPatch*>(&from));
}

void CommitDataRequest_ChunkToPatch::MergeFrom(const CommitDataRequest_ChunkToPatch& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.CommitDataRequest.ChunkToPatch)
  if (GOOGLE_PREDICT_FALSE(&from == this)) commit_data_request_pb_MergeFromFail(__LINE__);
  patches_.MergeFrom(from.patches_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_target_buffer()) {
      set_target_buffer(from.target_buffer());
    }
    if (from.has_writer_id()) {
      set_writer_id(from.writer_id());
    }
    if (from.has_chunk_id()) {
      set_chunk_id(from.chunk_id());
    }
    if (from.has_has_more_patches()) {
      set_has_more_patches(from.has_more_patches());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void CommitDataRequest_ChunkToPatch::CopyFrom(const CommitDataRequest_ChunkToPatch& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.CommitDataRequest.ChunkToPatch)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommitDataRequest_ChunkToPatch::IsInitialized() const {

  return true;
}

void CommitDataRequest_ChunkToPatch::Swap(CommitDataRequest_ChunkToPatch* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CommitDataRequest_ChunkToPatch::InternalSwap(CommitDataRequest_ChunkToPatch* other) {
  std::swap(target_buffer_, other->target_buffer_);
  std::swap(writer_id_, other->writer_id_);
  std::swap(chunk_id_, other->chunk_id_);
  patches_.UnsafeArenaSwap(&other->patches_);
  std::swap(has_more_patches_, other->has_more_patches_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string CommitDataRequest_ChunkToPatch::GetTypeName() const {
  return "perfetto.protos.CommitDataRequest.ChunkToPatch";
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CommitDataRequest::kChunksToMoveFieldNumber;
const int CommitDataRequest::kChunksToPatchFieldNumber;
const int CommitDataRequest::kFlushRequestIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CommitDataRequest::CommitDataRequest()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.CommitDataRequest)
}

void CommitDataRequest::InitAsDefaultInstance() {
}

CommitDataRequest::CommitDataRequest(const CommitDataRequest& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.CommitDataRequest)
}

void CommitDataRequest::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  flush_request_id_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CommitDataRequest::~CommitDataRequest() {
  // @@protoc_insertion_point(destructor:perfetto.protos.CommitDataRequest)
  SharedDtor();
}

void CommitDataRequest::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CommitDataRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CommitDataRequest& CommitDataRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();
#endif
  return *default_instance_;
}

CommitDataRequest* CommitDataRequest::default_instance_ = NULL;

CommitDataRequest* CommitDataRequest::New(::google::protobuf::Arena* arena) const {
  CommitDataRequest* n = new CommitDataRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CommitDataRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.CommitDataRequest)
  flush_request_id_ = GOOGLE_ULONGLONG(0);
  chunks_to_move_.Clear();
  chunks_to_patch_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool CommitDataRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForCommitDataRequest, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.CommitDataRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .perfetto.protos.CommitDataRequest.ChunksToMove chunks_to_move = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_chunks_to_move:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_chunks_to_move()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_chunks_to_move;
        if (input->ExpectTag(18)) goto parse_loop_chunks_to_patch;
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // repeated .perfetto.protos.CommitDataRequest.ChunkToPatch chunks_to_patch = 2;
      case 2: {
        if (tag == 18) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_chunks_to_patch:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_chunks_to_patch()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_chunks_to_patch;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(24)) goto parse_flush_request_id;
        break;
      }

      // optional uint64 flush_request_id = 3;
      case 3: {
        if (tag == 24) {
         parse_flush_request_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &flush_request_id_)));
          set_has_flush_request_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.CommitDataRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.CommitDataRequest)
  return false;
#undef DO_
}

void CommitDataRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.CommitDataRequest)
  // repeated .perfetto.protos.CommitDataRequest.ChunksToMove chunks_to_move = 1;
  for (unsigned int i = 0, n = this->chunks_to_move_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->chunks_to_move(i), output);
  }

  // repeated .perfetto.protos.CommitDataRequest.ChunkToPatch chunks_to_patch = 2;
  for (unsigned int i = 0, n = this->chunks_to_patch_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->chunks_to_patch(i), output);
  }

  // optional uint64 flush_request_id = 3;
  if (has_flush_request_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->flush_request_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.CommitDataRequest)
}

int CommitDataRequest::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.CommitDataRequest)
  int total_size = 0;

  // optional uint64 flush_request_id = 3;
  if (has_flush_request_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->flush_request_id());
  }

  // repeated .perfetto.protos.CommitDataRequest.ChunksToMove chunks_to_move = 1;
  total_size += 1 * this->chunks_to_move_size();
  for (int i = 0; i < this->chunks_to_move_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->chunks_to_move(i));
  }

  // repeated .perfetto.protos.CommitDataRequest.ChunkToPatch chunks_to_patch = 2;
  total_size += 1 * this->chunks_to_patch_size();
  for (int i = 0; i < this->chunks_to_patch_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->chunks_to_patch(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CommitDataRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CommitDataRequest*>(&from));
}

void CommitDataRequest::MergeFrom(const CommitDataRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.CommitDataRequest)
  if (GOOGLE_PREDICT_FALSE(&from == this)) commit_data_request_pb_MergeFromFail(__LINE__);
  chunks_to_move_.MergeFrom(from.chunks_to_move_);
  chunks_to_patch_.MergeFrom(from.chunks_to_patch_);
  if (from._has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    if (from.has_flush_request_id()) {
      set_flush_request_id(from.flush_request_id());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void CommitDataRequest::CopyFrom(const CommitDataRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.CommitDataRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommitDataRequest::IsInitialized() const {

  return true;
}

void CommitDataRequest::Swap(CommitDataRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CommitDataRequest::InternalSwap(CommitDataRequest* other) {
  chunks_to_move_.UnsafeArenaSwap(&other->chunks_to_move_);
  chunks_to_patch_.UnsafeArenaSwap(&other->chunks_to_patch_);
  std::swap(flush_request_id_, other->flush_request_id_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string CommitDataRequest::GetTypeName() const {
  return "perfetto.protos.CommitDataRequest";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CommitDataRequest_ChunksToMove

// optional uint32 page = 1;
bool CommitDataRequest_ChunksToMove::has_page() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CommitDataRequest_ChunksToMove::set_has_page() {
  _has_bits_[0] |= 0x00000001u;
}
void CommitDataRequest_ChunksToMove::clear_has_page() {
  _has_bits_[0] &= ~0x00000001u;
}
void CommitDataRequest_ChunksToMove::clear_page() {
  page_ = 0u;
  clear_has_page();
}
 ::google::protobuf::uint32 CommitDataRequest_ChunksToMove::page() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.CommitDataRequest.ChunksToMove.page)
  return page_;
}
 void CommitDataRequest_ChunksToMove::set_page(::google::protobuf::uint32 value) {
  set_has_page();
  page_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.CommitDataRequest.ChunksToMove.page)
}

// optional uint32 chunk = 2;
bool CommitDataRequest_ChunksToMove::has_chunk() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void CommitDataRequest_ChunksToMove::set_has_chunk() {
  _has_bits_[0] |= 0x00000002u;
}
void CommitDataRequest_ChunksToMove::clear_has_chunk() {
  _has_bits_[0] &= ~0x00000002u;
}
void CommitDataRequest_ChunksToMove::clear_chunk() {
  chunk_ = 0u;
  clear_has_chunk();
}
 ::google::protobuf::uint32 CommitDataRequest_ChunksToMove::chunk() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.CommitDataRequest.ChunksToMove.chunk)
  return chunk_;
}
 void CommitDataRequest_ChunksToMove::set_chunk(::google::protobuf::uint32 value) {
  set_has_chunk();
  chunk_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.CommitDataRequest.ChunksToMove.chunk)
}

// optional uint32 target_buffer = 3;
bool CommitDataRequest_ChunksToMove::has_target_buffer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void CommitDataRequest_ChunksToMove::set_has_target_buffer() {
  _has_bits_[0] |= 0x00000004u;
}
void CommitDataRequest_ChunksToMove::clear_has_target_buffer() {
  _has_bits_[0] &= ~0x00000004u;
}
void CommitDataRequest_ChunksToMove::clear_target_buffer() {
  target_buffer_ = 0u;
  clear_has_target_buffer();
}
 ::google::protobuf::uint32 CommitDataRequest_ChunksToMove::target_buffer() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.CommitDataRequest.ChunksToMove.target_buffer)
  return target_buffer_;
}
 void CommitDataRequest_ChunksToMove::set_target_buffer(::google::protobuf::uint32 value) {
  set_has_target_buffer();
  target_buffer_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.CommitDataRequest.ChunksToMove.target_buffer)
}

// -------------------------------------------------------------------

// CommitDataRequest_ChunkToPatch_Patch

// optional uint32 offset = 1;
bool CommitDataRequest_ChunkToPatch_Patch::has_offset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CommitDataRequest_ChunkToPatch_Patch::set_has_offset() {
  _has_bits_[0] |= 0x00000001u;
}
void CommitDataRequest_ChunkToPatch_Patch::clear_has_offset() {
  _has_bits_[0] &= ~0x00000001u;
}
void CommitDataRequest_ChunkToPatch_Patch::clear_offset() {
  offset_ = 0u;
  clear_has_offset();
}
 ::google::protobuf::uint32 CommitDataRequest_ChunkToPatch_Patch::offset() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.CommitDataRequest.ChunkToPatch.Patch.offset)
  return offset_;
}
 void CommitDataRequest_ChunkToPatch_Patch::set_offset(::google::protobuf::uint32 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.CommitDataRequest.ChunkToPatch.Patch.offset)
}

// optional bytes data = 2;
bool CommitDataRequest_ChunkToPatch_Patch::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void CommitDataRequest_ChunkToPatch_Patch::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
void CommitDataRequest_ChunkToPatch_Patch::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
void CommitDataRequest_ChunkToPatch_Patch::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
 const ::std::string& CommitDataRequest_ChunkToPatch_Patch::data() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.CommitDataRequest.ChunkToPatch.Patch.data)
  return data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void CommitDataRequest_ChunkToPatch_Patch::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.CommitDataRequest.ChunkToPatch.Patch.data)
}
 void CommitDataRequest_ChunkToPatch_Patch::set_data(const char* value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.CommitDataRequest.ChunkToPatch.Patch.data)
}
 void CommitDataRequest_ChunkToPatch_Patch::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.CommitDataRequest.ChunkToPatch.Patch.data)
}
 ::std::string* CommitDataRequest_ChunkToPatch_Patch::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.CommitDataRequest.ChunkToPatch.Patch.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* CommitDataRequest_ChunkToPatch_Patch::release_data() {
  // @@protoc_insertion_point(field_release:perfetto.protos.CommitDataRequest.ChunkToPatch.Patch.data)
  clear_has_data();
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void CommitDataRequest_ChunkToPatch_Patch::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.CommitDataRequest.ChunkToPatch.Patch.data)
}

// -------------------------------------------------------------------

// CommitDataRequest_ChunkToPatch

// optional uint32 target_buffer = 1;
bool CommitDataRequest_ChunkToPatch::has_target_buffer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CommitDataRequest_ChunkToPatch::set_has_target_buffer() {
  _has_bits_[0] |= 0x00000001u;
}
void CommitDataRequest_ChunkToPatch::clear_has_target_buffer() {
  _has_bits_[0] &= ~0x00000001u;
}
void CommitDataRequest_ChunkToPatch::clear_target_buffer() {
  target_buffer_ = 0u;
  clear_has_target_buffer();
}
 ::google::protobuf::uint32 CommitDataRequest_ChunkToPatch::target_buffer() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.CommitDataRequest.ChunkToPatch.target_buffer)
  return target_buffer_;
}
 void CommitDataRequest_ChunkToPatch::set_target_buffer(::google::protobuf::uint32 value) {
  set_has_target_buffer();
  target_buffer_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.CommitDataRequest.ChunkToPatch.target_buffer)
}

// optional uint32 writer_id = 2;
bool CommitDataRequest_ChunkToPatch::has_writer_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void CommitDataRequest_ChunkToPatch::set_has_writer_id() {
  _has_bits_[0] |= 0x00000002u;
}
void CommitDataRequest_ChunkToPatch::clear_has_writer_id() {
  _has_bits_[0] &= ~0x00000002u;
}
void CommitDataRequest_ChunkToPatch::clear_writer_id() {
  writer_id_ = 0u;
  clear_has_writer_id();
}
 ::google::protobuf::uint32 CommitDataRequest_ChunkToPatch::writer_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.CommitDataRequest.ChunkToPatch.writer_id)
  return writer_id_;
}
 void CommitDataRequest_ChunkToPatch::set_writer_id(::google::protobuf::uint32 value) {
  set_has_writer_id();
  writer_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.CommitDataRequest.ChunkToPatch.writer_id)
}

// optional uint32 chunk_id = 3;
bool CommitDataRequest_ChunkToPatch::has_chunk_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void CommitDataRequest_ChunkToPatch::set_has_chunk_id() {
  _has_bits_[0] |= 0x00000004u;
}
void CommitDataRequest_ChunkToPatch::clear_has_chunk_id() {
  _has_bits_[0] &= ~0x00000004u;
}
void CommitDataRequest_ChunkToPatch::clear_chunk_id() {
  chunk_id_ = 0u;
  clear_has_chunk_id();
}
 ::google::protobuf::uint32 CommitDataRequest_ChunkToPatch::chunk_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.CommitDataRequest.ChunkToPatch.chunk_id)
  return chunk_id_;
}
 void CommitDataRequest_ChunkToPatch::set_chunk_id(::google::protobuf::uint32 value) {
  set_has_chunk_id();
  chunk_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.CommitDataRequest.ChunkToPatch.chunk_id)
}

// repeated .perfetto.protos.CommitDataRequest.ChunkToPatch.Patch patches = 4;
int CommitDataRequest_ChunkToPatch::patches_size() const {
  return patches_.size();
}
void CommitDataRequest_ChunkToPatch::clear_patches() {
  patches_.Clear();
}
const ::perfetto::protos::CommitDataRequest_ChunkToPatch_Patch& CommitDataRequest_ChunkToPatch::patches(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.CommitDataRequest.ChunkToPatch.patches)
  return patches_.Get(index);
}
::perfetto::protos::CommitDataRequest_ChunkToPatch_Patch* CommitDataRequest_ChunkToPatch::mutable_patches(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.CommitDataRequest.ChunkToPatch.patches)
  return patches_.Mutable(index);
}
::perfetto::protos::CommitDataRequest_ChunkToPatch_Patch* CommitDataRequest_ChunkToPatch::add_patches() {
  // @@protoc_insertion_point(field_add:perfetto.protos.CommitDataRequest.ChunkToPatch.patches)
  return patches_.Add();
}
::google::protobuf::RepeatedPtrField< ::perfetto::protos::CommitDataRequest_ChunkToPatch_Patch >*
CommitDataRequest_ChunkToPatch::mutable_patches() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.CommitDataRequest.ChunkToPatch.patches)
  return &patches_;
}
const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::CommitDataRequest_ChunkToPatch_Patch >&
CommitDataRequest_ChunkToPatch::patches() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.CommitDataRequest.ChunkToPatch.patches)
  return patches_;
}

// optional bool has_more_patches = 5;
bool CommitDataRequest_ChunkToPatch::has_has_more_patches() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void CommitDataRequest_ChunkToPatch::set_has_has_more_patches() {
  _has_bits_[0] |= 0x00000010u;
}
void CommitDataRequest_ChunkToPatch::clear_has_has_more_patches() {
  _has_bits_[0] &= ~0x00000010u;
}
void CommitDataRequest_ChunkToPatch::clear_has_more_patches() {
  has_more_patches_ = false;
  clear_has_has_more_patches();
}
 bool CommitDataRequest_ChunkToPatch::has_more_patches() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.CommitDataRequest.ChunkToPatch.has_more_patches)
  return has_more_patches_;
}
 void CommitDataRequest_ChunkToPatch::set_has_more_patches(bool value) {
  set_has_has_more_patches();
  has_more_patches_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.CommitDataRequest.ChunkToPatch.has_more_patches)
}

// -------------------------------------------------------------------

// CommitDataRequest

// repeated .perfetto.protos.CommitDataRequest.ChunksToMove chunks_to_move = 1;
int CommitDataRequest::chunks_to_move_size() const {
  return chunks_to_move_.size();
}
void CommitDataRequest::clear_chunks_to_move() {
  chunks_to_move_.Clear();
}
const ::perfetto::protos::CommitDataRequest_ChunksToMove& CommitDataRequest::chunks_to_move(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.CommitDataRequest.chunks_to_move)
  return chunks_to_move_.Get(index);
}
::perfetto::protos::CommitDataRequest_ChunksToMove* CommitDataRequest::mutable_chunks_to_move(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.CommitDataRequest.chunks_to_move)
  return chunks_to_move_.Mutable(index);
}
::perfetto::protos::CommitDataRequest_ChunksToMove* CommitDataRequest::add_chunks_to_move() {
  // @@protoc_insertion_point(field_add:perfetto.protos.CommitDataRequest.chunks_to_move)
  return chunks_to_move_.Add();
}
::google::protobuf::RepeatedPtrField< ::perfetto::protos::CommitDataRequest_ChunksToMove >*
CommitDataRequest::mutable_chunks_to_move() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.CommitDataRequest.chunks_to_move)
  return &chunks_to_move_;
}
const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::CommitDataRequest_ChunksToMove >&
CommitDataRequest::chunks_to_move() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.CommitDataRequest.chunks_to_move)
  return chunks_to_move_;
}

// repeated .perfetto.protos.CommitDataRequest.ChunkToPatch chunks_to_patch = 2;
int CommitDataRequest::chunks_to_patch_size() const {
  return chunks_to_patch_.size();
}
void CommitDataRequest::clear_chunks_to_patch() {
  chunks_to_patch_.Clear();
}
const ::perfetto::protos::CommitDataRequest_ChunkToPatch& CommitDataRequest::chunks_to_patch(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.CommitDataRequest.chunks_to_patch)
  return chunks_to_patch_.Get(index);
}
::perfetto::protos::CommitDataRequest_ChunkToPatch* CommitDataRequest::mutable_chunks_to_patch(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.CommitDataRequest.chunks_to_patch)
  return chunks_to_patch_.Mutable(index);
}
::perfetto::protos::CommitDataRequest_ChunkToPatch* CommitDataRequest::add_chunks_to_patch() {
  // @@protoc_insertion_point(field_add:perfetto.protos.CommitDataRequest.chunks_to_patch)
  return chunks_to_patch_.Add();
}
::google::protobuf::RepeatedPtrField< ::perfetto::protos::CommitDataRequest_ChunkToPatch >*
CommitDataRequest::mutable_chunks_to_patch() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.CommitDataRequest.chunks_to_patch)
  return &chunks_to_patch_;
}
const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::CommitDataRequest_ChunkToPatch >&
CommitDataRequest::chunks_to_patch() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.CommitDataRequest.chunks_to_patch)
  return chunks_to_patch_;
}

// optional uint64 flush_request_id = 3;
bool CommitDataRequest::has_flush_request_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void CommitDataRequest::set_has_flush_request_id() {
  _has_bits_[0] |= 0x00000004u;
}
void CommitDataRequest::clear_has_flush_request_id() {
  _has_bits_[0] &= ~0x00000004u;
}
void CommitDataRequest::clear_flush_request_id() {
  flush_request_id_ = GOOGLE_ULONGLONG(0);
  clear_has_flush_request_id();
}
 ::google::protobuf::uint64 CommitDataRequest::flush_request_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.CommitDataRequest.flush_request_id)
  return flush_request_id_;
}
 void CommitDataRequest::set_flush_request_id(::google::protobuf::uint64 value) {
  set_has_flush_request_id();
  flush_request_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.CommitDataRequest.flush_request_id)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/common/data_source_descriptor.pb.cc
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/common/data_source_descriptor.pb.h
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/common/gpu_counter_descriptor.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/common/gpu_counter_descriptor.proto

#ifndef PROTOBUF_perfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto__INCLUDED
#define PROTOBUF_perfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_perfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto();
void protobuf_AssignDesc_perfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto();
void protobuf_ShutdownFile_perfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto();

class GpuCounterDescriptor;
class GpuCounterDescriptor_GpuCounterSpec;

// ===================================================================

class GpuCounterDescriptor_GpuCounterSpec : public ::google::protobuf::MessageLite {
 public:
  GpuCounterDescriptor_GpuCounterSpec();
  virtual ~GpuCounterDescriptor_GpuCounterSpec();

  GpuCounterDescriptor_GpuCounterSpec(const GpuCounterDescriptor_GpuCounterSpec& from);

  inline GpuCounterDescriptor_GpuCounterSpec& operator=(const GpuCounterDescriptor_GpuCounterSpec& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const GpuCounterDescriptor_GpuCounterSpec& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GpuCounterDescriptor_GpuCounterSpec* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GpuCounterDescriptor_GpuCounterSpec* other);

  // implements Message ----------------------------------------------

  inline GpuCounterDescriptor_GpuCounterSpec* New() const { return New(NULL); }

  GpuCounterDescriptor_GpuCounterSpec* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GpuCounterDescriptor_GpuCounterSpec& from);
  void MergeFrom(const GpuCounterDescriptor_GpuCounterSpec& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GpuCounterDescriptor_GpuCounterSpec* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 counter_id = 1;
  bool has_counter_id() const;
  void clear_counter_id();
  static const int kCounterIdFieldNumber = 1;
  ::google::protobuf::uint32 counter_id() const;
  void set_counter_id(::google::protobuf::uint32 value);

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string description = 3;
  bool has_description() const;
  void clear_description();
  static const int kDescriptionFieldNumber = 3;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // @@protoc_insertion_point(class_scope:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec)
 private:
  inline void set_has_counter_id();
  inline void clear_has_counter_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_description();
  inline void clear_has_description();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::uint32 counter_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto();

  void InitAsDefaultInstance();
  static GpuCounterDescriptor_GpuCounterSpec* default_instance_;
};
// -------------------------------------------------------------------

class GpuCounterDescriptor : public ::google::protobuf::MessageLite {
 public:
  GpuCounterDescriptor();
  virtual ~GpuCounterDescriptor();

  GpuCounterDescriptor(const GpuCounterDescriptor& from);

  inline GpuCounterDescriptor& operator=(const GpuCounterDescriptor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const GpuCounterDescriptor& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GpuCounterDescriptor* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GpuCounterDescriptor* other);

  // implements Message ----------------------------------------------

  inline GpuCounterDescriptor* New() const { return New(NULL); }

  GpuCounterDescriptor* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GpuCounterDescriptor& from);
  void MergeFrom(const GpuCounterDescriptor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GpuCounterDescriptor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef GpuCounterDescriptor_GpuCounterSpec GpuCounterSpec;

  // accessors -------------------------------------------------------

  // repeated .perfetto.protos.GpuCounterDescriptor.GpuCounterSpec specs = 1;
  int specs_size() const;
  void clear_specs();
  static const int kSpecsFieldNumber = 1;
  const ::perfetto::protos::GpuCounterDescriptor_GpuCounterSpec& specs(int index) const;
  ::perfetto::protos::GpuCounterDescriptor_GpuCounterSpec* mutable_specs(int index);
  ::perfetto::protos::GpuCounterDescriptor_GpuCounterSpec* add_specs();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::GpuCounterDescriptor_GpuCounterSpec >*
      mutable_specs();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::GpuCounterDescriptor_GpuCounterSpec >&
      specs() const;

  // @@protoc_insertion_point(class_scope:perfetto.protos.GpuCounterDescriptor)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::GpuCounterDescriptor_GpuCounterSpec > specs_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto();

  void InitAsDefaultInstance();
  static GpuCounterDescriptor* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// GpuCounterDescriptor_GpuCounterSpec

// optional uint32 counter_id = 1;
inline bool GpuCounterDescriptor_GpuCounterSpec::has_counter_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GpuCounterDescriptor_GpuCounterSpec::set_has_counter_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GpuCounterDescriptor_GpuCounterSpec::clear_has_counter_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GpuCounterDescriptor_GpuCounterSpec::clear_counter_id() {
  counter_id_ = 0u;
  clear_has_counter_id();
}
inline ::google::protobuf::uint32 GpuCounterDescriptor_GpuCounterSpec::counter_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.counter_id)
  return counter_id_;
}
inline void GpuCounterDescriptor_GpuCounterSpec::set_counter_id(::google::protobuf::uint32 value) {
  set_has_counter_id();
  counter_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.counter_id)
}

// optional string name = 2;
inline bool GpuCounterDescriptor_GpuCounterSpec::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GpuCounterDescriptor_GpuCounterSpec::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GpuCounterDescriptor_GpuCounterSpec::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GpuCounterDescriptor_GpuCounterSpec::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& GpuCounterDescriptor_GpuCounterSpec::name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GpuCounterDescriptor_GpuCounterSpec::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.name)
}
inline void GpuCounterDescriptor_GpuCounterSpec::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.name)
}
inline void GpuCounterDescriptor_GpuCounterSpec::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.name)
}
inline ::std::string* GpuCounterDescriptor_GpuCounterSpec::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GpuCounterDescriptor_GpuCounterSpec::release_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GpuCounterDescriptor_GpuCounterSpec::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.name)
}

// optional string description = 3;
inline bool GpuCounterDescriptor_GpuCounterSpec::has_description() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GpuCounterDescriptor_GpuCounterSpec::set_has_description() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GpuCounterDescriptor_GpuCounterSpec::clear_has_description() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GpuCounterDescriptor_GpuCounterSpec::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_description();
}
inline const ::std::string& GpuCounterDescriptor_GpuCounterSpec::description() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.description)
  return description_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GpuCounterDescriptor_GpuCounterSpec::set_description(const ::std::string& value) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.description)
}
inline void GpuCounterDescriptor_GpuCounterSpec::set_description(const char* value) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.description)
}
inline void GpuCounterDescriptor_GpuCounterSpec::set_description(const char* value, size_t size) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.description)
}
inline ::std::string* GpuCounterDescriptor_GpuCounterSpec::mutable_description() {
  set_has_description();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GpuCounterDescriptor_GpuCounterSpec::release_description() {
  // @@protoc_insertion_point(field_release:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.description)
  clear_has_description();
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GpuCounterDescriptor_GpuCounterSpec::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    set_has_description();
  } else {
    clear_has_description();
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.description)
}

// -------------------------------------------------------------------

// GpuCounterDescriptor

// repeated .perfetto.protos.GpuCounterDescriptor.GpuCounterSpec specs = 1;
inline int GpuCounterDescriptor::specs_size() const {
  return specs_.size();
}
inline void GpuCounterDescriptor::clear_specs() {
  specs_.Clear();
}
inline const ::perfetto::protos::GpuCounterDescriptor_GpuCounterSpec& GpuCounterDescriptor::specs(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterDescriptor.specs)
  return specs_.Get(index);
}
inline ::perfetto::protos::GpuCounterDescriptor_GpuCounterSpec* GpuCounterDescriptor::mutable_specs(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GpuCounterDescriptor.specs)
  return specs_.Mutable(index);
}
inline ::perfetto::protos::GpuCounterDescriptor_GpuCounterSpec* GpuCounterDescriptor::add_specs() {
  // @@protoc_insertion_point(field_add:perfetto.protos.GpuCounterDescriptor.specs)
  return specs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::GpuCounterDescriptor_GpuCounterSpec >*
GpuCounterDescriptor::mutable_specs() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.GpuCounterDescriptor.specs)
  return &specs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::GpuCounterDescriptor_GpuCounterSpec >&
GpuCounterDescriptor::specs() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.GpuCounterDescriptor.specs)
  return specs_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_perfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto__INCLUDED
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/common/data_source_descriptor.proto

#ifndef PROTOBUF_perfetto_2fcommon_2fdata_5fsource_5fdescriptor_2eproto__INCLUDED
#define PROTOBUF_perfetto_2fcommon_2fdata_5fsource_5fdescriptor_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// gen_amalgamated expanded: #include "perfetto/common/gpu_counter_descriptor.pb.h"
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_perfetto_2fcommon_2fdata_5fsource_5fdescriptor_2eproto();
void protobuf_AssignDesc_perfetto_2fcommon_2fdata_5fsource_5fdescriptor_2eproto();
void protobuf_ShutdownFile_perfetto_2fcommon_2fdata_5fsource_5fdescriptor_2eproto();

class DataSourceDescriptor;

// ===================================================================

class DataSourceDescriptor : public ::google::protobuf::MessageLite {
 public:
  DataSourceDescriptor();
  virtual ~DataSourceDescriptor();

  DataSourceDescriptor(const DataSourceDescriptor& from);

  inline DataSourceDescriptor& operator=(const DataSourceDescriptor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const DataSourceDescriptor& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DataSourceDescriptor* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DataSourceDescriptor* other);

  // implements Message ----------------------------------------------

  inline DataSourceDescriptor* New() const { return New(NULL); }

  DataSourceDescriptor* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DataSourceDescriptor& from);
  void MergeFrom(const DataSourceDescriptor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DataSourceDescriptor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional bool will_notify_on_stop = 2;
  bool has_will_notify_on_stop() const;
  void clear_will_notify_on_stop();
  static const int kWillNotifyOnStopFieldNumber = 2;
  bool will_notify_on_stop() const;
  void set_will_notify_on_stop(bool value);

  // optional bool will_notify_on_start = 3;
  bool has_will_notify_on_start() const;
  void clear_will_notify_on_start();
  static const int kWillNotifyOnStartFieldNumber = 3;
  bool will_notify_on_start() const;
  void set_will_notify_on_start(bool value);

  // optional bool handles_incremental_state_clear = 4;
  bool has_handles_incremental_state_clear() const;
  void clear_handles_incremental_state_clear();
  static const int kHandlesIncrementalStateClearFieldNumber = 4;
  bool handles_incremental_state_clear() const;
  void set_handles_incremental_state_clear(bool value);

  // optional .perfetto.protos.GpuCounterDescriptor gpu_counter_descriptor = 5 [lazy = true];
  bool has_gpu_counter_descriptor() const;
  void clear_gpu_counter_descriptor();
  static const int kGpuCounterDescriptorFieldNumber = 5;
  const ::perfetto::protos::GpuCounterDescriptor& gpu_counter_descriptor() const;
  ::perfetto::protos::GpuCounterDescriptor* mutable_gpu_counter_descriptor();
  ::perfetto::protos::GpuCounterDescriptor* release_gpu_counter_descriptor();
  void set_allocated_gpu_counter_descriptor(::perfetto::protos::GpuCounterDescriptor* gpu_counter_descriptor);

  // @@protoc_insertion_point(class_scope:perfetto.protos.DataSourceDescriptor)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_will_notify_on_stop();
  inline void clear_has_will_notify_on_stop();
  inline void set_has_will_notify_on_start();
  inline void clear_has_will_notify_on_start();
  inline void set_has_handles_incremental_state_clear();
  inline void clear_has_handles_incremental_state_clear();
  inline void set_has_gpu_counter_descriptor();
  inline void clear_has_gpu_counter_descriptor();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::perfetto::protos::GpuCounterDescriptor* gpu_counter_descriptor_;
  bool will_notify_on_stop_;
  bool will_notify_on_start_;
  bool handles_incremental_state_clear_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fcommon_2fdata_5fsource_5fdescriptor_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fcommon_2fdata_5fsource_5fdescriptor_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fcommon_2fdata_5fsource_5fdescriptor_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fcommon_2fdata_5fsource_5fdescriptor_2eproto();

  void InitAsDefaultInstance();
  static DataSourceDescriptor* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// DataSourceDescriptor

// optional string name = 1;
inline bool DataSourceDescriptor::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataSourceDescriptor::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataSourceDescriptor::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataSourceDescriptor::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& DataSourceDescriptor::name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceDescriptor.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DataSourceDescriptor::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.DataSourceDescriptor.name)
}
inline void DataSourceDescriptor::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.DataSourceDescriptor.name)
}
inline void DataSourceDescriptor::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.DataSourceDescriptor.name)
}
inline ::std::string* DataSourceDescriptor::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceDescriptor.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DataSourceDescriptor::release_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceDescriptor.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DataSourceDescriptor::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceDescriptor.name)
}

// optional bool will_notify_on_stop = 2;
inline bool DataSourceDescriptor::has_will_notify_on_stop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataSourceDescriptor::set_has_will_notify_on_stop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataSourceDescriptor::clear_has_will_notify_on_stop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataSourceDescriptor::clear_will_notify_on_stop() {
  will_notify_on_stop_ = false;
  clear_has_will_notify_on_stop();
}
inline bool DataSourceDescriptor::will_notify_on_stop() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceDescriptor.will_notify_on_stop)
  return will_notify_on_stop_;
}
inline void DataSourceDescriptor::set_will_notify_on_stop(bool value) {
  set_has_will_notify_on_stop();
  will_notify_on_stop_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.DataSourceDescriptor.will_notify_on_stop)
}

// optional bool will_notify_on_start = 3;
inline bool DataSourceDescriptor::has_will_notify_on_start() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DataSourceDescriptor::set_has_will_notify_on_start() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DataSourceDescriptor::clear_has_will_notify_on_start() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DataSourceDescriptor::clear_will_notify_on_start() {
  will_notify_on_start_ = false;
  clear_has_will_notify_on_start();
}
inline bool DataSourceDescriptor::will_notify_on_start() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceDescriptor.will_notify_on_start)
  return will_notify_on_start_;
}
inline void DataSourceDescriptor::set_will_notify_on_start(bool value) {
  set_has_will_notify_on_start();
  will_notify_on_start_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.DataSourceDescriptor.will_notify_on_start)
}

// optional bool handles_incremental_state_clear = 4;
inline bool DataSourceDescriptor::has_handles_incremental_state_clear() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DataSourceDescriptor::set_has_handles_incremental_state_clear() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DataSourceDescriptor::clear_has_handles_incremental_state_clear() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DataSourceDescriptor::clear_handles_incremental_state_clear() {
  handles_incremental_state_clear_ = false;
  clear_has_handles_incremental_state_clear();
}
inline bool DataSourceDescriptor::handles_incremental_state_clear() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceDescriptor.handles_incremental_state_clear)
  return handles_incremental_state_clear_;
}
inline void DataSourceDescriptor::set_handles_incremental_state_clear(bool value) {
  set_has_handles_incremental_state_clear();
  handles_incremental_state_clear_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.DataSourceDescriptor.handles_incremental_state_clear)
}

// optional .perfetto.protos.GpuCounterDescriptor gpu_counter_descriptor = 5 [lazy = true];
inline bool DataSourceDescriptor::has_gpu_counter_descriptor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DataSourceDescriptor::set_has_gpu_counter_descriptor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DataSourceDescriptor::clear_has_gpu_counter_descriptor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DataSourceDescriptor::clear_gpu_counter_descriptor() {
  if (gpu_counter_descriptor_ != NULL) gpu_counter_descriptor_->::perfetto::protos::GpuCounterDescriptor::Clear();
  clear_has_gpu_counter_descriptor();
}
inline const ::perfetto::protos::GpuCounterDescriptor& DataSourceDescriptor::gpu_counter_descriptor() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceDescriptor.gpu_counter_descriptor)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return gpu_counter_descriptor_ != NULL ? *gpu_counter_descriptor_ : *default_instance().gpu_counter_descriptor_;
#else
  return gpu_counter_descriptor_ != NULL ? *gpu_counter_descriptor_ : *default_instance_->gpu_counter_descriptor_;
#endif
}
inline ::perfetto::protos::GpuCounterDescriptor* DataSourceDescriptor::mutable_gpu_counter_descriptor() {
  set_has_gpu_counter_descriptor();
  if (gpu_counter_descriptor_ == NULL) {
    gpu_counter_descriptor_ = new ::perfetto::protos::GpuCounterDescriptor;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceDescriptor.gpu_counter_descriptor)
  return gpu_counter_descriptor_;
}
inline ::perfetto::protos::GpuCounterDescriptor* DataSourceDescriptor::release_gpu_counter_descriptor() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceDescriptor.gpu_counter_descriptor)
  clear_has_gpu_counter_descriptor();
  ::perfetto::protos::GpuCounterDescriptor* temp = gpu_counter_descriptor_;
  gpu_counter_descriptor_ = NULL;
  return temp;
}
inline void DataSourceDescriptor::set_allocated_gpu_counter_descriptor(::perfetto::protos::GpuCounterDescriptor* gpu_counter_descriptor) {
  delete gpu_counter_descriptor_;
  gpu_counter_descriptor_ = gpu_counter_descriptor;
  if (gpu_counter_descriptor) {
    set_has_gpu_counter_descriptor();
  } else {
    clear_has_gpu_counter_descriptor();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceDescriptor.gpu_counter_descriptor)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_perfetto_2fcommon_2fdata_5fsource_5fdescriptor_2eproto__INCLUDED
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/common/data_source_descriptor.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
// gen_amalgamated expanded: #include "perfetto/common/data_source_descriptor.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

void protobuf_ShutdownFile_perfetto_2fcommon_2fdata_5fsource_5fdescriptor_2eproto() {
  delete DataSourceDescriptor::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_perfetto_2fcommon_2fdata_5fsource_5fdescriptor_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_perfetto_2fcommon_2fdata_5fsource_5fdescriptor_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::perfetto::protos::protobuf_AddDesc_perfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto();
  DataSourceDescriptor::default_instance_ = new DataSourceDescriptor();
  DataSourceDescriptor::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_perfetto_2fcommon_2fdata_5fsource_5fdescriptor_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_perfetto_2fcommon_2fdata_5fsource_5fdescriptor_2eproto_once_);
void protobuf_AddDesc_perfetto_2fcommon_2fdata_5fsource_5fdescriptor_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_perfetto_2fcommon_2fdata_5fsource_5fdescriptor_2eproto_once_,
                 &protobuf_AddDesc_perfetto_2fcommon_2fdata_5fsource_5fdescriptor_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_perfetto_2fcommon_2fdata_5fsource_5fdescriptor_2eproto {
  StaticDescriptorInitializer_perfetto_2fcommon_2fdata_5fsource_5fdescriptor_2eproto() {
    protobuf_AddDesc_perfetto_2fcommon_2fdata_5fsource_5fdescriptor_2eproto();
  }
} static_descriptor_initializer_perfetto_2fcommon_2fdata_5fsource_5fdescriptor_2eproto_;
#endif

namespace {

static void data_source_descriptor_pb_MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
static void data_source_descriptor_pb_MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

static ::std::string* MutableUnknownFieldsForDataSourceDescriptor(
    DataSourceDescriptor* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DataSourceDescriptor::kNameFieldNumber;
const int DataSourceDescriptor::kWillNotifyOnStopFieldNumber;
const int DataSourceDescriptor::kWillNotifyOnStartFieldNumber;
const int DataSourceDescriptor::kHandlesIncrementalStateClearFieldNumber;
const int DataSourceDescriptor::kGpuCounterDescriptorFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DataSourceDescriptor::DataSourceDescriptor()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.DataSourceDescriptor)
}

void DataSourceDescriptor::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  gpu_counter_descriptor_ = const_cast< ::perfetto::protos::GpuCounterDescriptor*>(
      ::perfetto::protos::GpuCounterDescriptor::internal_default_instance());
#else
  gpu_counter_descriptor_ = const_cast< ::perfetto::protos::GpuCounterDescriptor*>(&::perfetto::protos::GpuCounterDescriptor::default_instance());
#endif
}

DataSourceDescriptor::DataSourceDescriptor(const DataSourceDescriptor& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.DataSourceDescriptor)
}

void DataSourceDescriptor::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  will_notify_on_stop_ = false;
  will_notify_on_start_ = false;
  handles_incremental_state_clear_ = false;
  gpu_counter_descriptor_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DataSourceDescriptor::~DataSourceDescriptor() {
  // @@protoc_insertion_point(destructor:perfetto.protos.DataSourceDescriptor)
  SharedDtor();
}

void DataSourceDescriptor::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete gpu_counter_descriptor_;
  }
}

void DataSourceDescriptor::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DataSourceDescriptor& DataSourceDescriptor::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fcommon_2fdata_5fsource_5fdescriptor_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fcommon_2fdata_5fsource_5fdescriptor_2eproto();
#endif
  return *default_instance_;
}

DataSourceDescriptor* DataSourceDescriptor::default_instance_ = NULL;

DataSourceDescriptor* DataSourceDescriptor::New(::google::protobuf::Arena* arena) const {
  DataSourceDescriptor* n = new DataSourceDescriptor;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DataSourceDescriptor::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.DataSourceDescriptor)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(DataSourceDescriptor, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<DataSourceDescriptor*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 31u) {
    ZR_(will_notify_on_stop_, handles_incremental_state_clear_);
    if (has_name()) {
      name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_gpu_counter_descriptor()) {
      if (gpu_counter_descriptor_ != NULL) gpu_counter_descriptor_->::perfetto::protos::GpuCounterDescriptor::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool DataSourceDescriptor::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForDataSourceDescriptor, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.DataSourceDescriptor)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_will_notify_on_stop;
        break;
      }

      // optional bool will_notify_on_stop = 2;
      case 2: {
        if (tag == 16) {
         parse_will_notify_on_stop:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &will_notify_on_stop_)));
          set_has_will_notify_on_stop();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_will_notify_on_start;
        break;
      }

      // optional bool will_notify_on_start = 3;
      case 3: {
        if (tag == 24) {
         parse_will_notify_on_start:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &will_notify_on_start_)));
          set_has_will_notify_on_start();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_handles_incremental_state_clear;
        break;
      }

      // optional bool handles_incremental_state_clear = 4;
      case 4: {
        if (tag == 32) {
         parse_handles_incremental_state_clear:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &handles_incremental_state_clear_)));
          set_has_handles_incremental_state_clear();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_gpu_counter_descriptor;
        break;
      }

      // optional .perfetto.protos.GpuCounterDescriptor gpu_counter_descriptor = 5 [lazy = true];
      case 5: {
        if (tag == 42) {
         parse_gpu_counter_descriptor:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_gpu_counter_descriptor()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.DataSourceDescriptor)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.DataSourceDescriptor)
  return false;
#undef DO_
}

void DataSourceDescriptor::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.DataSourceDescriptor)
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional bool will_notify_on_stop = 2;
  if (has_will_notify_on_stop()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->will_notify_on_stop(), output);
  }

  // optional bool will_notify_on_start = 3;
  if (has_will_notify_on_start()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->will_notify_on_start(), output);
  }

  // optional bool handles_incremental_state_clear = 4;
  if (has_handles_incremental_state_clear()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->handles_incremental_state_clear(), output);
  }

  // optional .perfetto.protos.GpuCounterDescriptor gpu_counter_descriptor = 5 [lazy = true];
  if (has_gpu_counter_descriptor()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, *this->gpu_counter_descriptor_, output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.DataSourceDescriptor)
}

int DataSourceDescriptor::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.DataSourceDescriptor)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 31u) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional bool will_notify_on_stop = 2;
    if (has_will_notify_on_stop()) {
      total_size += 1 + 1;
    }

    // optional bool will_notify_on_start = 3;
    if (has_will_notify_on_start()) {
      total_size += 1 + 1;
    }

    // optional bool handles_incremental_state_clear = 4;
    if (has_handles_incremental_state_clear()) {
      total_size += 1 + 1;
    }

    // optional .perfetto.protos.GpuCounterDescriptor gpu_counter_descriptor = 5 [lazy = true];
    if (has_gpu_counter_descriptor()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->gpu_counter_descriptor_);
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DataSourceDescriptor::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DataSourceDescriptor*>(&from));
}

void DataSourceDescriptor::MergeFrom(const DataSourceDescriptor& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.DataSourceDescriptor)
  if (GOOGLE_PREDICT_FALSE(&from == this)) data_source_descriptor_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (from.has_will_notify_on_stop()) {
      set_will_notify_on_stop(from.will_notify_on_stop());
    }
    if (from.has_will_notify_on_start()) {
      set_will_notify_on_start(from.will_notify_on_start());
    }
    if (from.has_handles_incremental_state_clear()) {
      set_handles_incremental_state_clear(from.handles_incremental_state_clear());
    }
    if (from.has_gpu_counter_descriptor()) {
      mutable_gpu_counter_descriptor()->::perfetto::protos::GpuCounterDescriptor::MergeFrom(from.gpu_counter_descriptor());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void DataSourceDescriptor::CopyFrom(const DataSourceDescriptor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.DataSourceDescriptor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataSourceDescriptor::IsInitialized() const {

  return true;
}

void DataSourceDescriptor::Swap(DataSourceDescriptor* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DataSourceDescriptor::InternalSwap(DataSourceDescriptor* other) {
  name_.Swap(&other->name_);
  std::swap(will_notify_on_stop_, other->will_notify_on_stop_);
  std::swap(will_notify_on_start_, other->will_notify_on_start_);
  std::swap(handles_incremental_state_clear_, other->handles_incremental_state_clear_);
  std::swap(gpu_counter_descriptor_, other->gpu_counter_descriptor_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string DataSourceDescriptor::GetTypeName() const {
  return "perfetto.protos.DataSourceDescriptor";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DataSourceDescriptor

// optional string name = 1;
bool DataSourceDescriptor::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void DataSourceDescriptor::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
void DataSourceDescriptor::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void DataSourceDescriptor::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
 const ::std::string& DataSourceDescriptor::name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceDescriptor.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DataSourceDescriptor::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.DataSourceDescriptor.name)
}
 void DataSourceDescriptor::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.DataSourceDescriptor.name)
}
 void DataSourceDescriptor::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.DataSourceDescriptor.name)
}
 ::std::string* DataSourceDescriptor::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceDescriptor.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* DataSourceDescriptor::release_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceDescriptor.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DataSourceDescriptor::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceDescriptor.name)
}

// optional bool will_notify_on_stop = 2;
bool DataSourceDescriptor::has_will_notify_on_stop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void DataSourceDescriptor::set_has_will_notify_on_stop() {
  _has_bits_[0] |= 0x00000002u;
}
void DataSourceDescriptor::clear_has_will_notify_on_stop() {
  _has_bits_[0] &= ~0x00000002u;
}
void DataSourceDescriptor::clear_will_notify_on_stop() {
  will_notify_on_stop_ = false;
  clear_has_will_notify_on_stop();
}
 bool DataSourceDescriptor::will_notify_on_stop() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceDescriptor.will_notify_on_stop)
  return will_notify_on_stop_;
}
 void DataSourceDescriptor::set_will_notify_on_stop(bool value) {
  set_has_will_notify_on_stop();
  will_notify_on_stop_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.DataSourceDescriptor.will_notify_on_stop)
}

// optional bool will_notify_on_start = 3;
bool DataSourceDescriptor::has_will_notify_on_start() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void DataSourceDescriptor::set_has_will_notify_on_start() {
  _has_bits_[0] |= 0x00000004u;
}
void DataSourceDescriptor::clear_has_will_notify_on_start() {
  _has_bits_[0] &= ~0x00000004u;
}
void DataSourceDescriptor::clear_will_notify_on_start() {
  will_notify_on_start_ = false;
  clear_has_will_notify_on_start();
}
 bool DataSourceDescriptor::will_notify_on_start() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceDescriptor.will_notify_on_start)
  return will_notify_on_start_;
}
 void DataSourceDescriptor::set_will_notify_on_start(bool value) {
  set_has_will_notify_on_start();
  will_notify_on_start_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.DataSourceDescriptor.will_notify_on_start)
}

// optional bool handles_incremental_state_clear = 4;
bool DataSourceDescriptor::has_handles_incremental_state_clear() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void DataSourceDescriptor::set_has_handles_incremental_state_clear() {
  _has_bits_[0] |= 0x00000008u;
}
void DataSourceDescriptor::clear_has_handles_incremental_state_clear() {
  _has_bits_[0] &= ~0x00000008u;
}
void DataSourceDescriptor::clear_handles_incremental_state_clear() {
  handles_incremental_state_clear_ = false;
  clear_has_handles_incremental_state_clear();
}
 bool DataSourceDescriptor::handles_incremental_state_clear() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceDescriptor.handles_incremental_state_clear)
  return handles_incremental_state_clear_;
}
 void DataSourceDescriptor::set_handles_incremental_state_clear(bool value) {
  set_has_handles_incremental_state_clear();
  handles_incremental_state_clear_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.DataSourceDescriptor.handles_incremental_state_clear)
}

// optional .perfetto.protos.GpuCounterDescriptor gpu_counter_descriptor = 5 [lazy = true];
bool DataSourceDescriptor::has_gpu_counter_descriptor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void DataSourceDescriptor::set_has_gpu_counter_descriptor() {
  _has_bits_[0] |= 0x00000010u;
}
void DataSourceDescriptor::clear_has_gpu_counter_descriptor() {
  _has_bits_[0] &= ~0x00000010u;
}
void DataSourceDescriptor::clear_gpu_counter_descriptor() {
  if (gpu_counter_descriptor_ != NULL) gpu_counter_descriptor_->::perfetto::protos::GpuCounterDescriptor::Clear();
  clear_has_gpu_counter_descriptor();
}
const ::perfetto::protos::GpuCounterDescriptor& DataSourceDescriptor::gpu_counter_descriptor() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceDescriptor.gpu_counter_descriptor)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return gpu_counter_descriptor_ != NULL ? *gpu_counter_descriptor_ : *default_instance().gpu_counter_descriptor_;
#else
  return gpu_counter_descriptor_ != NULL ? *gpu_counter_descriptor_ : *default_instance_->gpu_counter_descriptor_;
#endif
}
::perfetto::protos::GpuCounterDescriptor* DataSourceDescriptor::mutable_gpu_counter_descriptor() {
  set_has_gpu_counter_descriptor();
  if (gpu_counter_descriptor_ == NULL) {
    gpu_counter_descriptor_ = new ::perfetto::protos::GpuCounterDescriptor;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceDescriptor.gpu_counter_descriptor)
  return gpu_counter_descriptor_;
}
::perfetto::protos::GpuCounterDescriptor* DataSourceDescriptor::release_gpu_counter_descriptor() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceDescriptor.gpu_counter_descriptor)
  clear_has_gpu_counter_descriptor();
  ::perfetto::protos::GpuCounterDescriptor* temp = gpu_counter_descriptor_;
  gpu_counter_descriptor_ = NULL;
  return temp;
}
void DataSourceDescriptor::set_allocated_gpu_counter_descriptor(::perfetto::protos::GpuCounterDescriptor* gpu_counter_descriptor) {
  delete gpu_counter_descriptor_;
  gpu_counter_descriptor_ = gpu_counter_descriptor;
  if (gpu_counter_descriptor) {
    set_has_gpu_counter_descriptor();
  } else {
    clear_has_gpu_counter_descriptor();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceDescriptor.gpu_counter_descriptor)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/common/descriptor.pb.cc
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/common/descriptor.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/common/descriptor.proto

#ifndef PROTOBUF_perfetto_2fcommon_2fdescriptor_2eproto__INCLUDED
#define PROTOBUF_perfetto_2fcommon_2fdescriptor_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_perfetto_2fcommon_2fdescriptor_2eproto();
void protobuf_AssignDesc_perfetto_2fcommon_2fdescriptor_2eproto();
void protobuf_ShutdownFile_perfetto_2fcommon_2fdescriptor_2eproto();

class DescriptorProto;
class DescriptorProto_ReservedRange;
class EnumDescriptorProto;
class EnumValueDescriptorProto;
class FieldDescriptorProto;
class FileDescriptorProto;
class FileDescriptorSet;
class OneofDescriptorProto;
class OneofOptions;

enum FieldDescriptorProto_Type {
  FieldDescriptorProto_Type_TYPE_DOUBLE = 1,
  FieldDescriptorProto_Type_TYPE_FLOAT = 2,
  FieldDescriptorProto_Type_TYPE_INT64 = 3,
  FieldDescriptorProto_Type_TYPE_UINT64 = 4,
  FieldDescriptorProto_Type_TYPE_INT32 = 5,
  FieldDescriptorProto_Type_TYPE_FIXED64 = 6,
  FieldDescriptorProto_Type_TYPE_FIXED32 = 7,
  FieldDescriptorProto_Type_TYPE_BOOL = 8,
  FieldDescriptorProto_Type_TYPE_STRING = 9,
  FieldDescriptorProto_Type_TYPE_GROUP = 10,
  FieldDescriptorProto_Type_TYPE_MESSAGE = 11,
  FieldDescriptorProto_Type_TYPE_BYTES = 12,
  FieldDescriptorProto_Type_TYPE_UINT32 = 13,
  FieldDescriptorProto_Type_TYPE_ENUM = 14,
  FieldDescriptorProto_Type_TYPE_SFIXED32 = 15,
  FieldDescriptorProto_Type_TYPE_SFIXED64 = 16,
  FieldDescriptorProto_Type_TYPE_SINT32 = 17,
  FieldDescriptorProto_Type_TYPE_SINT64 = 18
};
bool FieldDescriptorProto_Type_IsValid(int value);
const FieldDescriptorProto_Type FieldDescriptorProto_Type_Type_MIN = FieldDescriptorProto_Type_TYPE_DOUBLE;
const FieldDescriptorProto_Type FieldDescriptorProto_Type_Type_MAX = FieldDescriptorProto_Type_TYPE_SINT64;
const int FieldDescriptorProto_Type_Type_ARRAYSIZE = FieldDescriptorProto_Type_Type_MAX + 1;

enum FieldDescriptorProto_Label {
  FieldDescriptorProto_Label_LABEL_OPTIONAL = 1,
  FieldDescriptorProto_Label_LABEL_REQUIRED = 2,
  FieldDescriptorProto_Label_LABEL_REPEATED = 3
};
bool FieldDescriptorProto_Label_IsValid(int value);
const FieldDescriptorProto_Label FieldDescriptorProto_Label_Label_MIN = FieldDescriptorProto_Label_LABEL_OPTIONAL;
const FieldDescriptorProto_Label FieldDescriptorProto_Label_Label_MAX = FieldDescriptorProto_Label_LABEL_REPEATED;
const int FieldDescriptorProto_Label_Label_ARRAYSIZE = FieldDescriptorProto_Label_Label_MAX + 1;

// ===================================================================

class FileDescriptorSet : public ::google::protobuf::MessageLite {
 public:
  FileDescriptorSet();
  virtual ~FileDescriptorSet();

  FileDescriptorSet(const FileDescriptorSet& from);

  inline FileDescriptorSet& operator=(const FileDescriptorSet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const FileDescriptorSet& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FileDescriptorSet* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FileDescriptorSet* other);

  // implements Message ----------------------------------------------

  inline FileDescriptorSet* New() const { return New(NULL); }

  FileDescriptorSet* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FileDescriptorSet& from);
  void MergeFrom(const FileDescriptorSet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FileDescriptorSet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .perfetto.protos.FileDescriptorProto file = 1;
  int file_size() const;
  void clear_file();
  static const int kFileFieldNumber = 1;
  const ::perfetto::protos::FileDescriptorProto& file(int index) const;
  ::perfetto::protos::FileDescriptorProto* mutable_file(int index);
  ::perfetto::protos::FileDescriptorProto* add_file();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::FileDescriptorProto >*
      mutable_file();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::FileDescriptorProto >&
      file() const;

  // @@protoc_insertion_point(class_scope:perfetto.protos.FileDescriptorSet)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::FileDescriptorProto > file_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fcommon_2fdescriptor_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fcommon_2fdescriptor_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fcommon_2fdescriptor_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fcommon_2fdescriptor_2eproto();

  void InitAsDefaultInstance();
  static FileDescriptorSet* default_instance_;
};
// -------------------------------------------------------------------

class FileDescriptorProto : public ::google::protobuf::MessageLite {
 public:
  FileDescriptorProto();
  virtual ~FileDescriptorProto();

  FileDescriptorProto(const FileDescriptorProto& from);

  inline FileDescriptorProto& operator=(const FileDescriptorProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const FileDescriptorProto& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FileDescriptorProto* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FileDescriptorProto* other);

  // implements Message ----------------------------------------------

  inline FileDescriptorProto* New() const { return New(NULL); }

  FileDescriptorProto* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FileDescriptorProto& from);
  void MergeFrom(const FileDescriptorProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FileDescriptorProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string package = 2;
  bool has_package() const;
  void clear_package();
  static const int kPackageFieldNumber = 2;
  const ::std::string& package() const;
  void set_package(const ::std::string& value);
  void set_package(const char* value);
  void set_package(const char* value, size_t size);
  ::std::string* mutable_package();
  ::std::string* release_package();
  void set_allocated_package(::std::string* package);

  // repeated string dependency = 3;
  int dependency_size() const;
  void clear_dependency();
  static const int kDependencyFieldNumber = 3;
  const ::std::string& dependency(int index) const;
  ::std::string* mutable_dependency(int index);
  void set_dependency(int index, const ::std::string& value);
  void set_dependency(int index, const char* value);
  void set_dependency(int index, const char* value, size_t size);
  ::std::string* add_dependency();
  void add_dependency(const ::std::string& value);
  void add_dependency(const char* value);
  void add_dependency(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& dependency() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_dependency();

  // repeated int32 public_dependency = 10;
  int public_dependency_size() const;
  void clear_public_dependency();
  static const int kPublicDependencyFieldNumber = 10;
  ::google::protobuf::int32 public_dependency(int index) const;
  void set_public_dependency(int index, ::google::protobuf::int32 value);
  void add_public_dependency(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      public_dependency() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_public_dependency();

  // repeated int32 weak_dependency = 11;
  int weak_dependency_size() const;
  void clear_weak_dependency();
  static const int kWeakDependencyFieldNumber = 11;
  ::google::protobuf::int32 weak_dependency(int index) const;
  void set_weak_dependency(int index, ::google::protobuf::int32 value);
  void add_weak_dependency(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      weak_dependency() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_weak_dependency();

  // repeated .perfetto.protos.DescriptorProto message_type = 4;
  int message_type_size() const;
  void clear_message_type();
  static const int kMessageTypeFieldNumber = 4;
  const ::perfetto::protos::DescriptorProto& message_type(int index) const;
  ::perfetto::protos::DescriptorProto* mutable_message_type(int index);
  ::perfetto::protos::DescriptorProto* add_message_type();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::DescriptorProto >*
      mutable_message_type();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::DescriptorProto >&
      message_type() const;

  // repeated .perfetto.protos.EnumDescriptorProto enum_type = 5;
  int enum_type_size() const;
  void clear_enum_type();
  static const int kEnumTypeFieldNumber = 5;
  const ::perfetto::protos::EnumDescriptorProto& enum_type(int index) const;
  ::perfetto::protos::EnumDescriptorProto* mutable_enum_type(int index);
  ::perfetto::protos::EnumDescriptorProto* add_enum_type();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::EnumDescriptorProto >*
      mutable_enum_type();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::EnumDescriptorProto >&
      enum_type() const;

  // repeated .perfetto.protos.FieldDescriptorProto extension = 7;
  int extension_size() const;
  void clear_extension();
  static const int kExtensionFieldNumber = 7;
  const ::perfetto::protos::FieldDescriptorProto& extension(int index) const;
  ::perfetto::protos::FieldDescriptorProto* mutable_extension(int index);
  ::perfetto::protos::FieldDescriptorProto* add_extension();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::FieldDescriptorProto >*
      mutable_extension();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::FieldDescriptorProto >&
      extension() const;

  // @@protoc_insertion_point(class_scope:perfetto.protos.FileDescriptorProto)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_package();
  inline void clear_has_package();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr package_;
  ::google::protobuf::RepeatedPtrField< ::std::string> dependency_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > public_dependency_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > weak_dependency_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::DescriptorProto > message_type_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::EnumDescriptorProto > enum_type_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::FieldDescriptorProto > extension_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fcommon_2fdescriptor_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fcommon_2fdescriptor_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fcommon_2fdescriptor_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fcommon_2fdescriptor_2eproto();

  void InitAsDefaultInstance();
  static FileDescriptorProto* default_instance_;
};
// -------------------------------------------------------------------

class DescriptorProto_ReservedRange : public ::google::protobuf::MessageLite {
 public:
  DescriptorProto_ReservedRange();
  virtual ~DescriptorProto_ReservedRange();

  DescriptorProto_ReservedRange(const DescriptorProto_ReservedRange& from);

  inline DescriptorProto_ReservedRange& operator=(const DescriptorProto_ReservedRange& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const DescriptorProto_ReservedRange& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DescriptorProto_ReservedRange* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DescriptorProto_ReservedRange* other);

  // implements Message ----------------------------------------------

  inline DescriptorProto_ReservedRange* New() const { return New(NULL); }

  DescriptorProto_ReservedRange* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DescriptorProto_ReservedRange& from);
  void MergeFrom(const DescriptorProto_ReservedRange& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DescriptorProto_ReservedRange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 start = 1;
  bool has_start() const;
  void clear_start();
  static const int kStartFieldNumber = 1;
  ::google::protobuf::int32 start() const;
  void set_start(::google::protobuf::int32 value);

  // optional int32 end = 2;
  bool has_end() const;
  void clear_end();
  static const int kEndFieldNumber = 2;
  ::google::protobuf::int32 end() const;
  void set_end(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.DescriptorProto.ReservedRange)
 private:
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_end();
  inline void clear_has_end();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 start_;
  ::google::protobuf::int32 end_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fcommon_2fdescriptor_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fcommon_2fdescriptor_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fcommon_2fdescriptor_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fcommon_2fdescriptor_2eproto();

  void InitAsDefaultInstance();
  static DescriptorProto_ReservedRange* default_instance_;
};
// -------------------------------------------------------------------

class DescriptorProto : public ::google::protobuf::MessageLite {
 public:
  DescriptorProto();
  virtual ~DescriptorProto();

  DescriptorProto(const DescriptorProto& from);

  inline DescriptorProto& operator=(const DescriptorProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const DescriptorProto& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DescriptorProto* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DescriptorProto* other);

  // implements Message ----------------------------------------------

  inline DescriptorProto* New() const { return New(NULL); }

  DescriptorProto* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DescriptorProto& from);
  void MergeFrom(const DescriptorProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DescriptorProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef DescriptorProto_ReservedRange ReservedRange;

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // repeated .perfetto.protos.FieldDescriptorProto field = 2;
  int field_size() const;
  void clear_field();
  static const int kFieldFieldNumber = 2;
  const ::perfetto::protos::FieldDescriptorProto& field(int index) const;
  ::perfetto::protos::FieldDescriptorProto* mutable_field(int index);
  ::perfetto::protos::FieldDescriptorProto* add_field();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::FieldDescriptorProto >*
      mutable_field();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::FieldDescriptorProto >&
      field() const;

  // repeated .perfetto.protos.FieldDescriptorProto extension = 6;
  int extension_size() const;
  void clear_extension();
  static const int kExtensionFieldNumber = 6;
  const ::perfetto::protos::FieldDescriptorProto& extension(int index) const;
  ::perfetto::protos::FieldDescriptorProto* mutable_extension(int index);
  ::perfetto::protos::FieldDescriptorProto* add_extension();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::FieldDescriptorProto >*
      mutable_extension();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::FieldDescriptorProto >&
      extension() const;

  // repeated .perfetto.protos.DescriptorProto nested_type = 3;
  int nested_type_size() const;
  void clear_nested_type();
  static const int kNestedTypeFieldNumber = 3;
  const ::perfetto::protos::DescriptorProto& nested_type(int index) const;
  ::perfetto::protos::DescriptorProto* mutable_nested_type(int index);
  ::perfetto::protos::DescriptorProto* add_nested_type();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::DescriptorProto >*
      mutable_nested_type();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::DescriptorProto >&
      nested_type() const;

  // repeated .perfetto.protos.EnumDescriptorProto enum_type = 4;
  int enum_type_size() const;
  void clear_enum_type();
  static const int kEnumTypeFieldNumber = 4;
  const ::perfetto::protos::EnumDescriptorProto& enum_type(int index) const;
  ::perfetto::protos::EnumDescriptorProto* mutable_enum_type(int index);
  ::perfetto::protos::EnumDescriptorProto* add_enum_type();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::EnumDescriptorProto >*
      mutable_enum_type();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::EnumDescriptorProto >&
      enum_type() const;

  // repeated .perfetto.protos.OneofDescriptorProto oneof_decl = 8;
  int oneof_decl_size() const;
  void clear_oneof_decl();
  static const int kOneofDeclFieldNumber = 8;
  const ::perfetto::protos::OneofDescriptorProto& oneof_decl(int index) const;
  ::perfetto::protos::OneofDescriptorProto* mutable_oneof_decl(int index);
  ::perfetto::protos::OneofDescriptorProto* add_oneof_decl();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::OneofDescriptorProto >*
      mutable_oneof_decl();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::OneofDescriptorProto >&
      oneof_decl() const;

  // repeated .perfetto.protos.DescriptorProto.ReservedRange reserved_range = 9;
  int reserved_range_size() const;
  void clear_reserved_range();
  static const int kReservedRangeFieldNumber = 9;
  const ::perfetto::protos::DescriptorProto_ReservedRange& reserved_range(int index) const;
  ::perfetto::protos::DescriptorProto_ReservedRange* mutable_reserved_range(int index);
  ::perfetto::protos::DescriptorProto_ReservedRange* add_reserved_range();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::DescriptorProto_ReservedRange >*
      mutable_reserved_range();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::DescriptorProto_ReservedRange >&
      reserved_range() const;

  // repeated string reserved_name = 10;
  int reserved_name_size() const;
  void clear_reserved_name();
  static const int kReservedNameFieldNumber = 10;
  const ::std::string& reserved_name(int index) const;
  ::std::string* mutable_reserved_name(int index);
  void set_reserved_name(int index, const ::std::string& value);
  void set_reserved_name(int index, const char* value);
  void set_reserved_name(int index, const char* value, size_t size);
  ::std::string* add_reserved_name();
  void add_reserved_name(const ::std::string& value);
  void add_reserved_name(const char* value);
  void add_reserved_name(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& reserved_name() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_reserved_name();

  // @@protoc_insertion_point(class_scope:perfetto.protos.DescriptorProto)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::FieldDescriptorProto > field_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::FieldDescriptorProto > extension_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::DescriptorProto > nested_type_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::EnumDescriptorProto > enum_type_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::OneofDescriptorProto > oneof_decl_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::DescriptorProto_ReservedRange > reserved_range_;
  ::google::protobuf::RepeatedPtrField< ::std::string> reserved_name_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fcommon_2fdescriptor_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fcommon_2fdescriptor_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fcommon_2fdescriptor_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fcommon_2fdescriptor_2eproto();

  void InitAsDefaultInstance();
  static DescriptorProto* default_instance_;
};
// -------------------------------------------------------------------

class FieldDescriptorProto : public ::google::protobuf::MessageLite {
 public:
  FieldDescriptorProto();
  virtual ~FieldDescriptorProto();

  FieldDescriptorProto(const FieldDescriptorProto& from);

  inline FieldDescriptorProto& operator=(const FieldDescriptorProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const FieldDescriptorProto& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FieldDescriptorProto* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FieldDescriptorProto* other);

  // implements Message ----------------------------------------------

  inline FieldDescriptorProto* New() const { return New(NULL); }

  FieldDescriptorProto* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FieldDescriptorProto& from);
  void MergeFrom(const FieldDescriptorProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FieldDescriptorProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef FieldDescriptorProto_Type Type;
  static const Type TYPE_DOUBLE =
    FieldDescriptorProto_Type_TYPE_DOUBLE;
  static const Type TYPE_FLOAT =
    FieldDescriptorProto_Type_TYPE_FLOAT;
  static const Type TYPE_INT64 =
    FieldDescriptorProto_Type_TYPE_INT64;
  static const Type TYPE_UINT64 =
    FieldDescriptorProto_Type_TYPE_UINT64;
  static const Type TYPE_INT32 =
    FieldDescriptorProto_Type_TYPE_INT32;
  static const Type TYPE_FIXED64 =
    FieldDescriptorProto_Type_TYPE_FIXED64;
  static const Type TYPE_FIXED32 =
    FieldDescriptorProto_Type_TYPE_FIXED32;
  static const Type TYPE_BOOL =
    FieldDescriptorProto_Type_TYPE_BOOL;
  static const Type TYPE_STRING =
    FieldDescriptorProto_Type_TYPE_STRING;
  static const Type TYPE_GROUP =
    FieldDescriptorProto_Type_TYPE_GROUP;
  static const Type TYPE_MESSAGE =
    FieldDescriptorProto_Type_TYPE_MESSAGE;
  static const Type TYPE_BYTES =
    FieldDescriptorProto_Type_TYPE_BYTES;
  static const Type TYPE_UINT32 =
    FieldDescriptorProto_Type_TYPE_UINT32;
  static const Type TYPE_ENUM =
    FieldDescriptorProto_Type_TYPE_ENUM;
  static const Type TYPE_SFIXED32 =
    FieldDescriptorProto_Type_TYPE_SFIXED32;
  static const Type TYPE_SFIXED64 =
    FieldDescriptorProto_Type_TYPE_SFIXED64;
  static const Type TYPE_SINT32 =
    FieldDescriptorProto_Type_TYPE_SINT32;
  static const Type TYPE_SINT64 =
    FieldDescriptorProto_Type_TYPE_SINT64;
  static inline bool Type_IsValid(int value) {
    return FieldDescriptorProto_Type_IsValid(value);
  }
  static const Type Type_MIN =
    FieldDescriptorProto_Type_Type_MIN;
  static const Type Type_MAX =
    FieldDescriptorProto_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    FieldDescriptorProto_Type_Type_ARRAYSIZE;

  typedef FieldDescriptorProto_Label Label;
  static const Label LABEL_OPTIONAL =
    FieldDescriptorProto_Label_LABEL_OPTIONAL;
  static const Label LABEL_REQUIRED =
    FieldDescriptorProto_Label_LABEL_REQUIRED;
  static const Label LABEL_REPEATED =
    FieldDescriptorProto_Label_LABEL_REPEATED;
  static inline bool Label_IsValid(int value) {
    return FieldDescriptorProto_Label_IsValid(value);
  }
  static const Label Label_MIN =
    FieldDescriptorProto_Label_Label_MIN;
  static const Label Label_MAX =
    FieldDescriptorProto_Label_Label_MAX;
  static const int Label_ARRAYSIZE =
    FieldDescriptorProto_Label_Label_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional int32 number = 3;
  bool has_number() const;
  void clear_number();
  static const int kNumberFieldNumber = 3;
  ::google::protobuf::int32 number() const;
  void set_number(::google::protobuf::int32 value);

  // optional .perfetto.protos.FieldDescriptorProto.Label label = 4;
  bool has_label() const;
  void clear_label();
  static const int kLabelFieldNumber = 4;
  ::perfetto::protos::FieldDescriptorProto_Label label() const;
  void set_label(::perfetto::protos::FieldDescriptorProto_Label value);

  // optional .perfetto.protos.FieldDescriptorProto.Type type = 5;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 5;
  ::perfetto::protos::FieldDescriptorProto_Type type() const;
  void set_type(::perfetto::protos::FieldDescriptorProto_Type value);

  // optional string type_name = 6;
  bool has_type_name() const;
  void clear_type_name();
  static const int kTypeNameFieldNumber = 6;
  const ::std::string& type_name() const;
  void set_type_name(const ::std::string& value);
  void set_type_name(const char* value);
  void set_type_name(const char* value, size_t size);
  ::std::string* mutable_type_name();
  ::std::string* release_type_name();
  void set_allocated_type_name(::std::string* type_name);

  // optional string extendee = 2;
  bool has_extendee() const;
  void clear_extendee();
  static const int kExtendeeFieldNumber = 2;
  const ::std::string& extendee() const;
  void set_extendee(const ::std::string& value);
  void set_extendee(const char* value);
  void set_extendee(const char* value, size_t size);
  ::std::string* mutable_extendee();
  ::std::string* release_extendee();
  void set_allocated_extendee(::std::string* extendee);

  // optional string default_value = 7;
  bool has_default_value() const;
  void clear_default_value();
  static const int kDefaultValueFieldNumber = 7;
  const ::std::string& default_value() const;
  void set_default_value(const ::std::string& value);
  void set_default_value(const char* value);
  void set_default_value(const char* value, size_t size);
  ::std::string* mutable_default_value();
  ::std::string* release_default_value();
  void set_allocated_default_value(::std::string* default_value);

  // optional int32 oneof_index = 9;
  bool has_oneof_index() const;
  void clear_oneof_index();
  static const int kOneofIndexFieldNumber = 9;
  ::google::protobuf::int32 oneof_index() const;
  void set_oneof_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.FieldDescriptorProto)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_number();
  inline void clear_has_number();
  inline void set_has_label();
  inline void clear_has_label();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_type_name();
  inline void clear_has_type_name();
  inline void set_has_extendee();
  inline void clear_has_extendee();
  inline void set_has_default_value();
  inline void clear_has_default_value();
  inline void set_has_oneof_index();
  inline void clear_has_oneof_index();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int32 number_;
  int label_;
  ::google::protobuf::internal::ArenaStringPtr type_name_;
  ::google::protobuf::internal::ArenaStringPtr extendee_;
  int type_;
  ::google::protobuf::int32 oneof_index_;
  ::google::protobuf::internal::ArenaStringPtr default_value_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fcommon_2fdescriptor_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fcommon_2fdescriptor_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fcommon_2fdescriptor_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fcommon_2fdescriptor_2eproto();

  void InitAsDefaultInstance();
  static FieldDescriptorProto* default_instance_;
};
// -------------------------------------------------------------------

class OneofDescriptorProto : public ::google::protobuf::MessageLite {
 public:
  OneofDescriptorProto();
  virtual ~OneofDescriptorProto();

  OneofDescriptorProto(const OneofDescriptorProto& from);

  inline OneofDescriptorProto& operator=(const OneofDescriptorProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const OneofDescriptorProto& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const OneofDescriptorProto* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(OneofDescriptorProto* other);

  // implements Message ----------------------------------------------

  inline OneofDescriptorProto* New() const { return New(NULL); }

  OneofDescriptorProto* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const OneofDescriptorProto& from);
  void MergeFrom(const OneofDescriptorProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OneofDescriptorProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional .perfetto.protos.OneofOptions options = 2;
  bool has_options() const;
  void clear_options();
  static const int kOptionsFieldNumber = 2;
  const ::perfetto::protos::OneofOptions& options() const;
  ::perfetto::protos::OneofOptions* mutable_options();
  ::perfetto::protos::OneofOptions* release_options();
  void set_allocated_options(::perfetto::protos::OneofOptions* options);

  // @@protoc_insertion_point(class_scope:perfetto.protos.OneofDescriptorProto)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_options();
  inline void clear_has_options();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::perfetto::protos::OneofOptions* options_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fcommon_2fdescriptor_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fcommon_2fdescriptor_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fcommon_2fdescriptor_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fcommon_2fdescriptor_2eproto();

  void InitAsDefaultInstance();
  static OneofDescriptorProto* default_instance_;
};
// -------------------------------------------------------------------

class EnumDescriptorProto : public ::google::protobuf::MessageLite {
 public:
  EnumDescriptorProto();
  virtual ~EnumDescriptorProto();

  EnumDescriptorProto(const EnumDescriptorProto& from);

  inline EnumDescriptorProto& operator=(const EnumDescriptorProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const EnumDescriptorProto& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EnumDescriptorProto* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EnumDescriptorProto* other);

  // implements Message ----------------------------------------------

  inline EnumDescriptorProto* New() const { return New(NULL); }

  EnumDescriptorProto* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EnumDescriptorProto& from);
  void MergeFrom(const EnumDescriptorProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EnumDescriptorProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // repeated .perfetto.protos.EnumValueDescriptorProto value = 2;
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::perfetto::protos::EnumValueDescriptorProto& value(int index) const;
  ::perfetto::protos::EnumValueDescriptorProto* mutable_value(int index);
  ::perfetto::protos::EnumValueDescriptorProto* add_value();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::EnumValueDescriptorProto >*
      mutable_value();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::EnumValueDescriptorProto >&
      value() const;

  // repeated string reserved_name = 5;
  int reserved_name_size() const;
  void clear_reserved_name();
  static const int kReservedNameFieldNumber = 5;
  const ::std::string& reserved_name(int index) const;
  ::std::string* mutable_reserved_name(int index);
  void set_reserved_name(int index, const ::std::string& value);
  void set_reserved_name(int index, const char* value);
  void set_reserved_name(int index, const char* value, size_t size);
  ::std::string* add_reserved_name();
  void add_reserved_name(const ::std::string& value);
  void add_reserved_name(const char* value);
  void add_reserved_name(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& reserved_name() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_reserved_name();

  // @@protoc_insertion_point(class_scope:perfetto.protos.EnumDescriptorProto)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::EnumValueDescriptorProto > value_;
  ::google::protobuf::RepeatedPtrField< ::std::string> reserved_name_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fcommon_2fdescriptor_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fcommon_2fdescriptor_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fcommon_2fdescriptor_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fcommon_2fdescriptor_2eproto();

  void InitAsDefaultInstance();
  static EnumDescriptorProto* default_instance_;
};
// -------------------------------------------------------------------

class EnumValueDescriptorProto : public ::google::protobuf::MessageLite {
 public:
  EnumValueDescriptorProto();
  virtual ~EnumValueDescriptorProto();

  EnumValueDescriptorProto(const EnumValueDescriptorProto& from);

  inline EnumValueDescriptorProto& operator=(const EnumValueDescriptorProto& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const EnumValueDescriptorProto& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EnumValueDescriptorProto* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EnumValueDescriptorProto* other);

  // implements Message ----------------------------------------------

  inline EnumValueDescriptorProto* New() const { return New(NULL); }

  EnumValueDescriptorProto* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EnumValueDescriptorProto& from);
  void MergeFrom(const EnumValueDescriptorProto& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EnumValueDescriptorProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional int32 number = 2;
  bool has_number() const;
  void clear_number();
  static const int kNumberFieldNumber = 2;
  ::google::protobuf::int32 number() const;
  void set_number(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.EnumValueDescriptorProto)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_number();
  inline void clear_has_number();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int32 number_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fcommon_2fdescriptor_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fcommon_2fdescriptor_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fcommon_2fdescriptor_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fcommon_2fdescriptor_2eproto();

  void InitAsDefaultInstance();
  static EnumValueDescriptorProto* default_instance_;
};
// -------------------------------------------------------------------

class OneofOptions : public ::google::protobuf::MessageLite {
 public:
  OneofOptions();
  virtual ~OneofOptions();

  OneofOptions(const OneofOptions& from);

  inline OneofOptions& operator=(const OneofOptions& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const OneofOptions& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const OneofOptions* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(OneofOptions* other);

  // implements Message ----------------------------------------------

  inline OneofOptions* New() const { return New(NULL); }

  OneofOptions* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const OneofOptions& from);
  void MergeFrom(const OneofOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OneofOptions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(OneofOptions)
  // @@protoc_insertion_point(class_scope:perfetto.protos.OneofOptions)
 private:

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fcommon_2fdescriptor_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fcommon_2fdescriptor_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fcommon_2fdescriptor_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fcommon_2fdescriptor_2eproto();

  void InitAsDefaultInstance();
  static OneofOptions* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// FileDescriptorSet

// repeated .perfetto.protos.FileDescriptorProto file = 1;
inline int FileDescriptorSet::file_size() const {
  return file_.size();
}
inline void FileDescriptorSet::clear_file() {
  file_.Clear();
}
inline const ::perfetto::protos::FileDescriptorProto& FileDescriptorSet::file(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FileDescriptorSet.file)
  return file_.Get(index);
}
inline ::perfetto::protos::FileDescriptorProto* FileDescriptorSet::mutable_file(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.FileDescriptorSet.file)
  return file_.Mutable(index);
}
inline ::perfetto::protos::FileDescriptorProto* FileDescriptorSet::add_file() {
  // @@protoc_insertion_point(field_add:perfetto.protos.FileDescriptorSet.file)
  return file_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::FileDescriptorProto >*
FileDescriptorSet::mutable_file() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.FileDescriptorSet.file)
  return &file_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::FileDescriptorProto >&
FileDescriptorSet::file() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.FileDescriptorSet.file)
  return file_;
}

// -------------------------------------------------------------------

// FileDescriptorProto

// optional string name = 1;
inline bool FileDescriptorProto::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FileDescriptorProto::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FileDescriptorProto::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FileDescriptorProto::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& FileDescriptorProto::name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FileDescriptorProto.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileDescriptorProto::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.FileDescriptorProto.name)
}
inline void FileDescriptorProto::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.FileDescriptorProto.name)
}
inline void FileDescriptorProto::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.FileDescriptorProto.name)
}
inline ::std::string* FileDescriptorProto::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.FileDescriptorProto.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileDescriptorProto::release_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.FileDescriptorProto.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileDescriptorProto::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.FileDescriptorProto.name)
}

// optional string package = 2;
inline bool FileDescriptorProto::has_package() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FileDescriptorProto::set_has_package() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FileDescriptorProto::clear_has_package() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FileDescriptorProto::clear_package() {
  package_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_package();
}
inline const ::std::string& FileDescriptorProto::package() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FileDescriptorProto.package)
  return package_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileDescriptorProto::set_package(const ::std::string& value) {
  set_has_package();
  package_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.FileDescriptorProto.package)
}
inline void FileDescriptorProto::set_package(const char* value) {
  set_has_package();
  package_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.FileDescriptorProto.package)
}
inline void FileDescriptorProto::set_package(const char* value, size_t size) {
  set_has_package();
  package_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.FileDescriptorProto.package)
}
inline ::std::string* FileDescriptorProto::mutable_package() {
  set_has_package();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.FileDescriptorProto.package)
  return package_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileDescriptorProto::release_package() {
  // @@protoc_insertion_point(field_release:perfetto.protos.FileDescriptorProto.package)
  clear_has_package();
  return package_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileDescriptorProto::set_allocated_package(::std::string* package) {
  if (package != NULL) {
    set_has_package();
  } else {
    clear_has_package();
  }
  package_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), package);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.FileDescriptorProto.package)
}

// repeated string dependency = 3;
inline int FileDescriptorProto::dependency_size() const {
  return dependency_.size();
}
inline void FileDescriptorProto::clear_dependency() {
  dependency_.Clear();
}
inline const ::std::string& FileDescriptorProto::dependency(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FileDescriptorProto.dependency)
  return dependency_.Get(index);
}
inline ::std::string* FileDescriptorProto::mutable_dependency(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.FileDescriptorProto.dependency)
  return dependency_.Mutable(index);
}
inline void FileDescriptorProto::set_dependency(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.FileDescriptorProto.dependency)
  dependency_.Mutable(index)->assign(value);
}
inline void FileDescriptorProto::set_dependency(int index, const char* value) {
  dependency_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.FileDescriptorProto.dependency)
}
inline void FileDescriptorProto::set_dependency(int index, const char* value, size_t size) {
  dependency_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.FileDescriptorProto.dependency)
}
inline ::std::string* FileDescriptorProto::add_dependency() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.FileDescriptorProto.dependency)
  return dependency_.Add();
}
inline void FileDescriptorProto::add_dependency(const ::std::string& value) {
  dependency_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.FileDescriptorProto.dependency)
}
inline void FileDescriptorProto::add_dependency(const char* value) {
  dependency_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.FileDescriptorProto.dependency)
}
inline void FileDescriptorProto::add_dependency(const char* value, size_t size) {
  dependency_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.FileDescriptorProto.dependency)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FileDescriptorProto::dependency() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.FileDescriptorProto.dependency)
  return dependency_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FileDescriptorProto::mutable_dependency() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.FileDescriptorProto.dependency)
  return &dependency_;
}

// repeated int32 public_dependency = 10;
inline int FileDescriptorProto::public_dependency_size() const {
  return public_dependency_.size();
}
inline void FileDescriptorProto::clear_public_dependency() {
  public_dependency_.Clear();
}
inline ::google::protobuf::int32 FileDescriptorProto::public_dependency(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FileDescriptorProto.public_dependency)
  return public_dependency_.Get(index);
}
inline void FileDescriptorProto::set_public_dependency(int index, ::google::protobuf::int32 value) {
  public_dependency_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.FileDescriptorProto.public_dependency)
}
inline void FileDescriptorProto::add_public_dependency(::google::protobuf::int32 value) {
  public_dependency_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.FileDescriptorProto.public_dependency)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
FileDescriptorProto::public_dependency() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.FileDescriptorProto.public_dependency)
  return public_dependency_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
FileDescriptorProto::mutable_public_dependency() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.FileDescriptorProto.public_dependency)
  return &public_dependency_;
}

// repeated int32 weak_dependency = 11;
inline int FileDescriptorProto::weak_dependency_size() const {
  return weak_dependency_.size();
}
inline void FileDescriptorProto::clear_weak_dependency() {
  weak_dependency_.Clear();
}
inline ::google::protobuf::int32 FileDescriptorProto::weak_dependency(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FileDescriptorProto.weak_dependency)
  return weak_dependency_.Get(index);
}
inline void FileDescriptorProto::set_weak_dependency(int index, ::google::protobuf::int32 value) {
  weak_dependency_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.FileDescriptorProto.weak_dependency)
}
inline void FileDescriptorProto::add_weak_dependency(::google::protobuf::int32 value) {
  weak_dependency_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.FileDescriptorProto.weak_dependency)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
FileDescriptorProto::weak_dependency() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.FileDescriptorProto.weak_dependency)
  return weak_dependency_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
FileDescriptorProto::mutable_weak_dependency() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.FileDescriptorProto.weak_dependency)
  return &weak_dependency_;
}

// repeated .perfetto.protos.DescriptorProto message_type = 4;
inline int FileDescriptorProto::message_type_size() const {
  return message_type_.size();
}
inline void FileDescriptorProto::clear_message_type() {
  message_type_.Clear();
}
inline const ::perfetto::protos::DescriptorProto& FileDescriptorProto::message_type(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FileDescriptorProto.message_type)
  return message_type_.Get(index);
}
inline ::perfetto::protos::DescriptorProto* FileDescriptorProto::mutable_message_type(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.FileDescriptorProto.message_type)
  return message_type_.Mutable(index);
}
inline ::perfetto::protos::DescriptorProto* FileDescriptorProto::add_message_type() {
  // @@protoc_insertion_point(field_add:perfetto.protos.FileDescriptorProto.message_type)
  return message_type_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::DescriptorProto >*
FileDescriptorProto::mutable_message_type() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.FileDescriptorProto.message_type)
  return &message_type_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::DescriptorProto >&
FileDescriptorProto::message_type() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.FileDescriptorProto.message_type)
  return message_type_;
}

// repeated .perfetto.protos.EnumDescriptorProto enum_type = 5;
inline int FileDescriptorProto::enum_type_size() const {
  return enum_type_.size();
}
inline void FileDescriptorProto::clear_enum_type() {
  enum_type_.Clear();
}
inline const ::perfetto::protos::EnumDescriptorProto& FileDescriptorProto::enum_type(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FileDescriptorProto.enum_type)
  return enum_type_.Get(index);
}
inline ::perfetto::protos::EnumDescriptorProto* FileDescriptorProto::mutable_enum_type(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.FileDescriptorProto.enum_type)
  return enum_type_.Mutable(index);
}
inline ::perfetto::protos::EnumDescriptorProto* FileDescriptorProto::add_enum_type() {
  // @@protoc_insertion_point(field_add:perfetto.protos.FileDescriptorProto.enum_type)
  return enum_type_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::EnumDescriptorProto >*
FileDescriptorProto::mutable_enum_type() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.FileDescriptorProto.enum_type)
  return &enum_type_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::EnumDescriptorProto >&
FileDescriptorProto::enum_type() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.FileDescriptorProto.enum_type)
  return enum_type_;
}

// repeated .perfetto.protos.FieldDescriptorProto extension = 7;
inline int FileDescriptorProto::extension_size() const {
  return extension_.size();
}
inline void FileDescriptorProto::clear_extension() {
  extension_.Clear();
}
inline const ::perfetto::protos::FieldDescriptorProto& FileDescriptorProto::extension(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FileDescriptorProto.extension)
  return extension_.Get(index);
}
inline ::perfetto::protos::FieldDescriptorProto* FileDescriptorProto::mutable_extension(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.FileDescriptorProto.extension)
  return extension_.Mutable(index);
}
inline ::perfetto::protos::FieldDescriptorProto* FileDescriptorProto::add_extension() {
  // @@protoc_insertion_point(field_add:perfetto.protos.FileDescriptorProto.extension)
  return extension_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::FieldDescriptorProto >*
FileDescriptorProto::mutable_extension() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.FileDescriptorProto.extension)
  return &extension_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::FieldDescriptorProto >&
FileDescriptorProto::extension() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.FileDescriptorProto.extension)
  return extension_;
}

// -------------------------------------------------------------------

// DescriptorProto_ReservedRange

// optional int32 start = 1;
inline bool DescriptorProto_ReservedRange::has_start() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DescriptorProto_ReservedRange::set_has_start() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DescriptorProto_ReservedRange::clear_has_start() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DescriptorProto_ReservedRange::clear_start() {
  start_ = 0;
  clear_has_start();
}
inline ::google::protobuf::int32 DescriptorProto_ReservedRange::start() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DescriptorProto.ReservedRange.start)
  return start_;
}
inline void DescriptorProto_ReservedRange::set_start(::google::protobuf::int32 value) {
  set_has_start();
  start_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.DescriptorProto.ReservedRange.start)
}

// optional int32 end = 2;
inline bool DescriptorProto_ReservedRange::has_end() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DescriptorProto_ReservedRange::set_has_end() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DescriptorProto_ReservedRange::clear_has_end() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DescriptorProto_ReservedRange::clear_end() {
  end_ = 0;
  clear_has_end();
}
inline ::google::protobuf::int32 DescriptorProto_ReservedRange::end() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DescriptorProto.ReservedRange.end)
  return end_;
}
inline void DescriptorProto_ReservedRange::set_end(::google::protobuf::int32 value) {
  set_has_end();
  end_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.DescriptorProto.ReservedRange.end)
}

// -------------------------------------------------------------------

// DescriptorProto

// optional string name = 1;
inline bool DescriptorProto::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DescriptorProto::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DescriptorProto::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DescriptorProto::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& DescriptorProto::name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DescriptorProto.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DescriptorProto::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.DescriptorProto.name)
}
inline void DescriptorProto::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.DescriptorProto.name)
}
inline void DescriptorProto::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.DescriptorProto.name)
}
inline ::std::string* DescriptorProto::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DescriptorProto.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DescriptorProto::release_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DescriptorProto.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DescriptorProto::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DescriptorProto.name)
}

// repeated .perfetto.protos.FieldDescriptorProto field = 2;
inline int DescriptorProto::field_size() const {
  return field_.size();
}
inline void DescriptorProto::clear_field() {
  field_.Clear();
}
inline const ::perfetto::protos::FieldDescriptorProto& DescriptorProto::field(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DescriptorProto.field)
  return field_.Get(index);
}
inline ::perfetto::protos::FieldDescriptorProto* DescriptorProto::mutable_field(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DescriptorProto.field)
  return field_.Mutable(index);
}
inline ::perfetto::protos::FieldDescriptorProto* DescriptorProto::add_field() {
  // @@protoc_insertion_point(field_add:perfetto.protos.DescriptorProto.field)
  return field_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::FieldDescriptorProto >*
DescriptorProto::mutable_field() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.DescriptorProto.field)
  return &field_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::FieldDescriptorProto >&
DescriptorProto::field() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.DescriptorProto.field)
  return field_;
}

// repeated .perfetto.protos.FieldDescriptorProto extension = 6;
inline int DescriptorProto::extension_size() const {
  return extension_.size();
}
inline void DescriptorProto::clear_extension() {
  extension_.Clear();
}
inline const ::perfetto::protos::FieldDescriptorProto& DescriptorProto::extension(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DescriptorProto.extension)
  return extension_.Get(index);
}
inline ::perfetto::protos::FieldDescriptorProto* DescriptorProto::mutable_extension(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DescriptorProto.extension)
  return extension_.Mutable(index);
}
inline ::perfetto::protos::FieldDescriptorProto* DescriptorProto::add_extension() {
  // @@protoc_insertion_point(field_add:perfetto.protos.DescriptorProto.extension)
  return extension_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::FieldDescriptorProto >*
DescriptorProto::mutable_extension() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.DescriptorProto.extension)
  return &extension_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::FieldDescriptorProto >&
DescriptorProto::extension() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.DescriptorProto.extension)
  return extension_;
}

// repeated .perfetto.protos.DescriptorProto nested_type = 3;
inline int DescriptorProto::nested_type_size() const {
  return nested_type_.size();
}
inline void DescriptorProto::clear_nested_type() {
  nested_type_.Clear();
}
inline const ::perfetto::protos::DescriptorProto& DescriptorProto::nested_type(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DescriptorProto.nested_type)
  return nested_type_.Get(index);
}
inline ::perfetto::protos::DescriptorProto* DescriptorProto::mutable_nested_type(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DescriptorProto.nested_type)
  return nested_type_.Mutable(index);
}
inline ::perfetto::protos::DescriptorProto* DescriptorProto::add_nested_type() {
  // @@protoc_insertion_point(field_add:perfetto.protos.DescriptorProto.nested_type)
  return nested_type_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::DescriptorProto >*
DescriptorProto::mutable_nested_type() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.DescriptorProto.nested_type)
  return &nested_type_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::DescriptorProto >&
DescriptorProto::nested_type() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.DescriptorProto.nested_type)
  return nested_type_;
}

// repeated .perfetto.protos.EnumDescriptorProto enum_type = 4;
inline int DescriptorProto::enum_type_size() const {
  return enum_type_.size();
}
inline void DescriptorProto::clear_enum_type() {
  enum_type_.Clear();
}
inline const ::perfetto::protos::EnumDescriptorProto& DescriptorProto::enum_type(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DescriptorProto.enum_type)
  return enum_type_.Get(index);
}
inline ::perfetto::protos::EnumDescriptorProto* DescriptorProto::mutable_enum_type(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DescriptorProto.enum_type)
  return enum_type_.Mutable(index);
}
inline ::perfetto::protos::EnumDescriptorProto* DescriptorProto::add_enum_type() {
  // @@protoc_insertion_point(field_add:perfetto.protos.DescriptorProto.enum_type)
  return enum_type_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::EnumDescriptorProto >*
DescriptorProto::mutable_enum_type() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.DescriptorProto.enum_type)
  return &enum_type_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::EnumDescriptorProto >&
DescriptorProto::enum_type() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.DescriptorProto.enum_type)
  return enum_type_;
}

// repeated .perfetto.protos.OneofDescriptorProto oneof_decl = 8;
inline int DescriptorProto::oneof_decl_size() const {
  return oneof_decl_.size();
}
inline void DescriptorProto::clear_oneof_decl() {
  oneof_decl_.Clear();
}
inline const ::perfetto::protos::OneofDescriptorProto& DescriptorProto::oneof_decl(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DescriptorProto.oneof_decl)
  return oneof_decl_.Get(index);
}
inline ::perfetto::protos::OneofDescriptorProto* DescriptorProto::mutable_oneof_decl(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DescriptorProto.oneof_decl)
  return oneof_decl_.Mutable(index);
}
inline ::perfetto::protos::OneofDescriptorProto* DescriptorProto::add_oneof_decl() {
  // @@protoc_insertion_point(field_add:perfetto.protos.DescriptorProto.oneof_decl)
  return oneof_decl_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::OneofDescriptorProto >*
DescriptorProto::mutable_oneof_decl() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.DescriptorProto.oneof_decl)
  return &oneof_decl_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::OneofDescriptorProto >&
DescriptorProto::oneof_decl() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.DescriptorProto.oneof_decl)
  return oneof_decl_;
}

// repeated .perfetto.protos.DescriptorProto.ReservedRange reserved_range = 9;
inline int DescriptorProto::reserved_range_size() const {
  return reserved_range_.size();
}
inline void DescriptorProto::clear_reserved_range() {
  reserved_range_.Clear();
}
inline const ::perfetto::protos::DescriptorProto_ReservedRange& DescriptorProto::reserved_range(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DescriptorProto.reserved_range)
  return reserved_range_.Get(index);
}
inline ::perfetto::protos::DescriptorProto_ReservedRange* DescriptorProto::mutable_reserved_range(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DescriptorProto.reserved_range)
  return reserved_range_.Mutable(index);
}
inline ::perfetto::protos::DescriptorProto_ReservedRange* DescriptorProto::add_reserved_range() {
  // @@protoc_insertion_point(field_add:perfetto.protos.DescriptorProto.reserved_range)
  return reserved_range_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::DescriptorProto_ReservedRange >*
DescriptorProto::mutable_reserved_range() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.DescriptorProto.reserved_range)
  return &reserved_range_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::DescriptorProto_ReservedRange >&
DescriptorProto::reserved_range() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.DescriptorProto.reserved_range)
  return reserved_range_;
}

// repeated string reserved_name = 10;
inline int DescriptorProto::reserved_name_size() const {
  return reserved_name_.size();
}
inline void DescriptorProto::clear_reserved_name() {
  reserved_name_.Clear();
}
inline const ::std::string& DescriptorProto::reserved_name(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DescriptorProto.reserved_name)
  return reserved_name_.Get(index);
}
inline ::std::string* DescriptorProto::mutable_reserved_name(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DescriptorProto.reserved_name)
  return reserved_name_.Mutable(index);
}
inline void DescriptorProto::set_reserved_name(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.DescriptorProto.reserved_name)
  reserved_name_.Mutable(index)->assign(value);
}
inline void DescriptorProto::set_reserved_name(int index, const char* value) {
  reserved_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.DescriptorProto.reserved_name)
}
inline void DescriptorProto::set_reserved_name(int index, const char* value, size_t size) {
  reserved_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.DescriptorProto.reserved_name)
}
inline ::std::string* DescriptorProto::add_reserved_name() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.DescriptorProto.reserved_name)
  return reserved_name_.Add();
}
inline void DescriptorProto::add_reserved_name(const ::std::string& value) {
  reserved_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.DescriptorProto.reserved_name)
}
inline void DescriptorProto::add_reserved_name(const char* value) {
  reserved_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.DescriptorProto.reserved_name)
}
inline void DescriptorProto::add_reserved_name(const char* value, size_t size) {
  reserved_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.DescriptorProto.reserved_name)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DescriptorProto::reserved_name() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.DescriptorProto.reserved_name)
  return reserved_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DescriptorProto::mutable_reserved_name() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.DescriptorProto.reserved_name)
  return &reserved_name_;
}

// -------------------------------------------------------------------

// FieldDescriptorProto

// optional string name = 1;
inline bool FieldDescriptorProto::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FieldDescriptorProto::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FieldDescriptorProto::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FieldDescriptorProto::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& FieldDescriptorProto::name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FieldDescriptorProto.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FieldDescriptorProto::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.FieldDescriptorProto.name)
}
inline void FieldDescriptorProto::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.FieldDescriptorProto.name)
}
inline void FieldDescriptorProto::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.FieldDescriptorProto.name)
}
inline ::std::string* FieldDescriptorProto::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.FieldDescriptorProto.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FieldDescriptorProto::release_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.FieldDescriptorProto.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FieldDescriptorProto::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.FieldDescriptorProto.name)
}

// optional int32 number = 3;
inline bool FieldDescriptorProto::has_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FieldDescriptorProto::set_has_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FieldDescriptorProto::clear_has_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FieldDescriptorProto::clear_number() {
  number_ = 0;
  clear_has_number();
}
inline ::google::protobuf::int32 FieldDescriptorProto::number() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FieldDescriptorProto.number)
  return number_;
}
inline void FieldDescriptorProto::set_number(::google::protobuf::int32 value) {
  set_has_number();
  number_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.FieldDescriptorProto.number)
}

// optional .perfetto.protos.FieldDescriptorProto.Label label = 4;
inline bool FieldDescriptorProto::has_label() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FieldDescriptorProto::set_has_label() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FieldDescriptorProto::clear_has_label() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FieldDescriptorProto::clear_label() {
  label_ = 1;
  clear_has_label();
}
inline ::perfetto::protos::FieldDescriptorProto_Label FieldDescriptorProto::label() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FieldDescriptorProto.label)
  return static_cast< ::perfetto::protos::FieldDescriptorProto_Label >(label_);
}
inline void FieldDescriptorProto::set_label(::perfetto::protos::FieldDescriptorProto_Label value) {
  assert(::perfetto::protos::FieldDescriptorProto_Label_IsValid(value));
  set_has_label();
  label_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.FieldDescriptorProto.label)
}

// optional .perfetto.protos.FieldDescriptorProto.Type type = 5;
inline bool FieldDescriptorProto::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FieldDescriptorProto::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FieldDescriptorProto::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FieldDescriptorProto::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::perfetto::protos::FieldDescriptorProto_Type FieldDescriptorProto::type() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FieldDescriptorProto.type)
  return static_cast< ::perfetto::protos::FieldDescriptorProto_Type >(type_);
}
inline void FieldDescriptorProto::set_type(::perfetto::protos::FieldDescriptorProto_Type value) {
  assert(::perfetto::protos::FieldDescriptorProto_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.FieldDescriptorProto.type)
}

// optional string type_name = 6;
inline bool FieldDescriptorProto::has_type_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FieldDescriptorProto::set_has_type_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FieldDescriptorProto::clear_has_type_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FieldDescriptorProto::clear_type_name() {
  type_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type_name();
}
inline const ::std::string& FieldDescriptorProto::type_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FieldDescriptorProto.type_name)
  return type_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FieldDescriptorProto::set_type_name(const ::std::string& value) {
  set_has_type_name();
  type_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.FieldDescriptorProto.type_name)
}
inline void FieldDescriptorProto::set_type_name(const char* value) {
  set_has_type_name();
  type_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.FieldDescriptorProto.type_name)
}
inline void FieldDescriptorProto::set_type_name(const char* value, size_t size) {
  set_has_type_name();
  type_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.FieldDescriptorProto.type_name)
}
inline ::std::string* FieldDescriptorProto::mutable_type_name() {
  set_has_type_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.FieldDescriptorProto.type_name)
  return type_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FieldDescriptorProto::release_type_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.FieldDescriptorProto.type_name)
  clear_has_type_name();
  return type_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FieldDescriptorProto::set_allocated_type_name(::std::string* type_name) {
  if (type_name != NULL) {
    set_has_type_name();
  } else {
    clear_has_type_name();
  }
  type_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type_name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.FieldDescriptorProto.type_name)
}

// optional string extendee = 2;
inline bool FieldDescriptorProto::has_extendee() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FieldDescriptorProto::set_has_extendee() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FieldDescriptorProto::clear_has_extendee() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FieldDescriptorProto::clear_extendee() {
  extendee_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_extendee();
}
inline const ::std::string& FieldDescriptorProto::extendee() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FieldDescriptorProto.extendee)
  return extendee_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FieldDescriptorProto::set_extendee(const ::std::string& value) {
  set_has_extendee();
  extendee_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.FieldDescriptorProto.extendee)
}
inline void FieldDescriptorProto::set_extendee(const char* value) {
  set_has_extendee();
  extendee_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.FieldDescriptorProto.extendee)
}
inline void FieldDescriptorProto::set_extendee(const char* value, size_t size) {
  set_has_extendee();
  extendee_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.FieldDescriptorProto.extendee)
}
inline ::std::string* FieldDescriptorProto::mutable_extendee() {
  set_has_extendee();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.FieldDescriptorProto.extendee)
  return extendee_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FieldDescriptorProto::release_extendee() {
  // @@protoc_insertion_point(field_release:perfetto.protos.FieldDescriptorProto.extendee)
  clear_has_extendee();
  return extendee_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FieldDescriptorProto::set_allocated_extendee(::std::string* extendee) {
  if (extendee != NULL) {
    set_has_extendee();
  } else {
    clear_has_extendee();
  }
  extendee_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), extendee);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.FieldDescriptorProto.extendee)
}

// optional string default_value = 7;
inline bool FieldDescriptorProto::has_default_value() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FieldDescriptorProto::set_has_default_value() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FieldDescriptorProto::clear_has_default_value() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FieldDescriptorProto::clear_default_value() {
  default_value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_default_value();
}
inline const ::std::string& FieldDescriptorProto::default_value() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FieldDescriptorProto.default_value)
  return default_value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FieldDescriptorProto::set_default_value(const ::std::string& value) {
  set_has_default_value();
  default_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.FieldDescriptorProto.default_value)
}
inline void FieldDescriptorProto::set_default_value(const char* value) {
  set_has_default_value();
  default_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.FieldDescriptorProto.default_value)
}
inline void FieldDescriptorProto::set_default_value(const char* value, size_t size) {
  set_has_default_value();
  default_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.FieldDescriptorProto.default_value)
}
inline ::std::string* FieldDescriptorProto::mutable_default_value() {
  set_has_default_value();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.FieldDescriptorProto.default_value)
  return default_value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FieldDescriptorProto::release_default_value() {
  // @@protoc_insertion_point(field_release:perfetto.protos.FieldDescriptorProto.default_value)
  clear_has_default_value();
  return default_value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FieldDescriptorProto::set_allocated_default_value(::std::string* default_value) {
  if (default_value != NULL) {
    set_has_default_value();
  } else {
    clear_has_default_value();
  }
  default_value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), default_value);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.FieldDescriptorProto.default_value)
}

// optional int32 oneof_index = 9;
inline bool FieldDescriptorProto::has_oneof_index() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FieldDescriptorProto::set_has_oneof_index() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FieldDescriptorProto::clear_has_oneof_index() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FieldDescriptorProto::clear_oneof_index() {
  oneof_index_ = 0;
  clear_has_oneof_index();
}
inline ::google::protobuf::int32 FieldDescriptorProto::oneof_index() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FieldDescriptorProto.oneof_index)
  return oneof_index_;
}
inline void FieldDescriptorProto::set_oneof_index(::google::protobuf::int32 value) {
  set_has_oneof_index();
  oneof_index_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.FieldDescriptorProto.oneof_index)
}

// -------------------------------------------------------------------

// OneofDescriptorProto

// optional string name = 1;
inline bool OneofDescriptorProto::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OneofDescriptorProto::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OneofDescriptorProto::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OneofDescriptorProto::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& OneofDescriptorProto::name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.OneofDescriptorProto.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OneofDescriptorProto::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.OneofDescriptorProto.name)
}
inline void OneofDescriptorProto::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.OneofDescriptorProto.name)
}
inline void OneofDescriptorProto::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.OneofDescriptorProto.name)
}
inline ::std::string* OneofDescriptorProto::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.OneofDescriptorProto.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OneofDescriptorProto::release_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.OneofDescriptorProto.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OneofDescriptorProto::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.OneofDescriptorProto.name)
}

// optional .perfetto.protos.OneofOptions options = 2;
inline bool OneofDescriptorProto::has_options() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OneofDescriptorProto::set_has_options() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OneofDescriptorProto::clear_has_options() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OneofDescriptorProto::clear_options() {
  if (options_ != NULL) options_->::perfetto::protos::OneofOptions::Clear();
  clear_has_options();
}
inline const ::perfetto::protos::OneofOptions& OneofDescriptorProto::options() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.OneofDescriptorProto.options)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return options_ != NULL ? *options_ : *default_instance().options_;
#else
  return options_ != NULL ? *options_ : *default_instance_->options_;
#endif
}
inline ::perfetto::protos::OneofOptions* OneofDescriptorProto::mutable_options() {
  set_has_options();
  if (options_ == NULL) {
    options_ = new ::perfetto::protos::OneofOptions;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.OneofDescriptorProto.options)
  return options_;
}
inline ::perfetto::protos::OneofOptions* OneofDescriptorProto::release_options() {
  // @@protoc_insertion_point(field_release:perfetto.protos.OneofDescriptorProto.options)
  clear_has_options();
  ::perfetto::protos::OneofOptions* temp = options_;
  options_ = NULL;
  return temp;
}
inline void OneofDescriptorProto::set_allocated_options(::perfetto::protos::OneofOptions* options) {
  delete options_;
  options_ = options;
  if (options) {
    set_has_options();
  } else {
    clear_has_options();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.OneofDescriptorProto.options)
}

// -------------------------------------------------------------------

// EnumDescriptorProto

// optional string name = 1;
inline bool EnumDescriptorProto::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnumDescriptorProto::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnumDescriptorProto::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnumDescriptorProto::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& EnumDescriptorProto::name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.EnumDescriptorProto.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EnumDescriptorProto::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.EnumDescriptorProto.name)
}
inline void EnumDescriptorProto::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.EnumDescriptorProto.name)
}
inline void EnumDescriptorProto::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.EnumDescriptorProto.name)
}
inline ::std::string* EnumDescriptorProto::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.EnumDescriptorProto.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EnumDescriptorProto::release_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.EnumDescriptorProto.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EnumDescriptorProto::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.EnumDescriptorProto.name)
}

// repeated .perfetto.protos.EnumValueDescriptorProto value = 2;
inline int EnumDescriptorProto::value_size() const {
  return value_.size();
}
inline void EnumDescriptorProto::clear_value() {
  value_.Clear();
}
inline const ::perfetto::protos::EnumValueDescriptorProto& EnumDescriptorProto::value(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.EnumDescriptorProto.value)
  return value_.Get(index);
}
inline ::perfetto::protos::EnumValueDescriptorProto* EnumDescriptorProto::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.EnumDescriptorProto.value)
  return value_.Mutable(index);
}
inline ::perfetto::protos::EnumValueDescriptorProto* EnumDescriptorProto::add_value() {
  // @@protoc_insertion_point(field_add:perfetto.protos.EnumDescriptorProto.value)
  return value_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::EnumValueDescriptorProto >*
EnumDescriptorProto::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.EnumDescriptorProto.value)
  return &value_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::EnumValueDescriptorProto >&
EnumDescriptorProto::value() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.EnumDescriptorProto.value)
  return value_;
}

// repeated string reserved_name = 5;
inline int EnumDescriptorProto::reserved_name_size() const {
  return reserved_name_.size();
}
inline void EnumDescriptorProto::clear_reserved_name() {
  reserved_name_.Clear();
}
inline const ::std::string& EnumDescriptorProto::reserved_name(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.EnumDescriptorProto.reserved_name)
  return reserved_name_.Get(index);
}
inline ::std::string* EnumDescriptorProto::mutable_reserved_name(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.EnumDescriptorProto.reserved_name)
  return reserved_name_.Mutable(index);
}
inline void EnumDescriptorProto::set_reserved_name(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.EnumDescriptorProto.reserved_name)
  reserved_name_.Mutable(index)->assign(value);
}
inline void EnumDescriptorProto::set_reserved_name(int index, const char* value) {
  reserved_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.EnumDescriptorProto.reserved_name)
}
inline void EnumDescriptorProto::set_reserved_name(int index, const char* value, size_t size) {
  reserved_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.EnumDescriptorProto.reserved_name)
}
inline ::std::string* EnumDescriptorProto::add_reserved_name() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.EnumDescriptorProto.reserved_name)
  return reserved_name_.Add();
}
inline void EnumDescriptorProto::add_reserved_name(const ::std::string& value) {
  reserved_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.EnumDescriptorProto.reserved_name)
}
inline void EnumDescriptorProto::add_reserved_name(const char* value) {
  reserved_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.EnumDescriptorProto.reserved_name)
}
inline void EnumDescriptorProto::add_reserved_name(const char* value, size_t size) {
  reserved_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.EnumDescriptorProto.reserved_name)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
EnumDescriptorProto::reserved_name() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.EnumDescriptorProto.reserved_name)
  return reserved_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
EnumDescriptorProto::mutable_reserved_name() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.EnumDescriptorProto.reserved_name)
  return &reserved_name_;
}

// -------------------------------------------------------------------

// EnumValueDescriptorProto

// optional string name = 1;
inline bool EnumValueDescriptorProto::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnumValueDescriptorProto::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnumValueDescriptorProto::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnumValueDescriptorProto::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& EnumValueDescriptorProto::name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.EnumValueDescriptorProto.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EnumValueDescriptorProto::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.EnumValueDescriptorProto.name)
}
inline void EnumValueDescriptorProto::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.EnumValueDescriptorProto.name)
}
inline void EnumValueDescriptorProto::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.EnumValueDescriptorProto.name)
}
inline ::std::string* EnumValueDescriptorProto::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.EnumValueDescriptorProto.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EnumValueDescriptorProto::release_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.EnumValueDescriptorProto.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EnumValueDescriptorProto::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.EnumValueDescriptorProto.name)
}

// optional int32 number = 2;
inline bool EnumValueDescriptorProto::has_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnumValueDescriptorProto::set_has_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnumValueDescriptorProto::clear_has_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnumValueDescriptorProto::clear_number() {
  number_ = 0;
  clear_has_number();
}
inline ::google::protobuf::int32 EnumValueDescriptorProto::number() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.EnumValueDescriptorProto.number)
  return number_;
}
inline void EnumValueDescriptorProto::set_number(::google::protobuf::int32 value) {
  set_has_number();
  number_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.EnumValueDescriptorProto.number)
}

// -------------------------------------------------------------------

// OneofOptions

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::perfetto::protos::FieldDescriptorProto_Type> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::perfetto::protos::FieldDescriptorProto_Label> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_perfetto_2fcommon_2fdescriptor_2eproto__INCLUDED
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/common/descriptor.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
// gen_amalgamated expanded: #include "perfetto/common/descriptor.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

void protobuf_ShutdownFile_perfetto_2fcommon_2fdescriptor_2eproto() {
  delete FileDescriptorSet::default_instance_;
  delete FileDescriptorProto::default_instance_;
  delete DescriptorProto::default_instance_;
  delete DescriptorProto_ReservedRange::default_instance_;
  delete FieldDescriptorProto::default_instance_;
  delete OneofDescriptorProto::default_instance_;
  delete EnumDescriptorProto::default_instance_;
  delete EnumValueDescriptorProto::default_instance_;
  delete OneofOptions::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_perfetto_2fcommon_2fdescriptor_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_perfetto_2fcommon_2fdescriptor_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  FileDescriptorSet::default_instance_ = new FileDescriptorSet();
  FileDescriptorProto::default_instance_ = new FileDescriptorProto();
  DescriptorProto::default_instance_ = new DescriptorProto();
  DescriptorProto_ReservedRange::default_instance_ = new DescriptorProto_ReservedRange();
  FieldDescriptorProto::default_instance_ = new FieldDescriptorProto();
  OneofDescriptorProto::default_instance_ = new OneofDescriptorProto();
  EnumDescriptorProto::default_instance_ = new EnumDescriptorProto();
  EnumValueDescriptorProto::default_instance_ = new EnumValueDescriptorProto();
  OneofOptions::default_instance_ = new OneofOptions();
  FileDescriptorSet::default_instance_->InitAsDefaultInstance();
  FileDescriptorProto::default_instance_->InitAsDefaultInstance();
  DescriptorProto::default_instance_->InitAsDefaultInstance();
  DescriptorProto_ReservedRange::default_instance_->InitAsDefaultInstance();
  FieldDescriptorProto::default_instance_->InitAsDefaultInstance();
  OneofDescriptorProto::default_instance_->InitAsDefaultInstance();
  EnumDescriptorProto::default_instance_->InitAsDefaultInstance();
  EnumValueDescriptorProto::default_instance_->InitAsDefaultInstance();
  OneofOptions::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_perfetto_2fcommon_2fdescriptor_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_perfetto_2fcommon_2fdescriptor_2eproto_once_);
void protobuf_AddDesc_perfetto_2fcommon_2fdescriptor_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_perfetto_2fcommon_2fdescriptor_2eproto_once_,
                 &protobuf_AddDesc_perfetto_2fcommon_2fdescriptor_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_perfetto_2fcommon_2fdescriptor_2eproto {
  StaticDescriptorInitializer_perfetto_2fcommon_2fdescriptor_2eproto() {
    protobuf_AddDesc_perfetto_2fcommon_2fdescriptor_2eproto();
  }
} static_descriptor_initializer_perfetto_2fcommon_2fdescriptor_2eproto_;
#endif

namespace {

static void descriptor_pb_MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
static void descriptor_pb_MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

static ::std::string* MutableUnknownFieldsForFileDescriptorSet(
    FileDescriptorSet* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FileDescriptorSet::kFileFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

FileDescriptorSet::FileDescriptorSet()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.FileDescriptorSet)
}

void FileDescriptorSet::InitAsDefaultInstance() {
}

FileDescriptorSet::FileDescriptorSet(const FileDescriptorSet& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.FileDescriptorSet)
}

void FileDescriptorSet::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FileDescriptorSet::~FileDescriptorSet() {
  // @@protoc_insertion_point(destructor:perfetto.protos.FileDescriptorSet)
  SharedDtor();
}

void FileDescriptorSet::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void FileDescriptorSet::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FileDescriptorSet& FileDescriptorSet::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fcommon_2fdescriptor_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fcommon_2fdescriptor_2eproto();
#endif
  return *default_instance_;
}

FileDescriptorSet* FileDescriptorSet::default_instance_ = NULL;

FileDescriptorSet* FileDescriptorSet::New(::google::protobuf::Arena* arena) const {
  FileDescriptorSet* n = new FileDescriptorSet;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void FileDescriptorSet::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.FileDescriptorSet)
  file_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool FileDescriptorSet::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForFileDescriptorSet, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.FileDescriptorSet)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .perfetto.protos.FileDescriptorProto file = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_file:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_file()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_file;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.FileDescriptorSet)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.FileDescriptorSet)
  return false;
#undef DO_
}

void FileDescriptorSet::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.FileDescriptorSet)
  // repeated .perfetto.protos.FileDescriptorProto file = 1;
  for (unsigned int i = 0, n = this->file_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->file(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.FileDescriptorSet)
}

int FileDescriptorSet::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.FileDescriptorSet)
  int total_size = 0;

  // repeated .perfetto.protos.FileDescriptorProto file = 1;
  total_size += 1 * this->file_size();
  for (int i = 0; i < this->file_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->file(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FileDescriptorSet::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FileDescriptorSet*>(&from));
}

void FileDescriptorSet::MergeFrom(const FileDescriptorSet& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.FileDescriptorSet)
  if (GOOGLE_PREDICT_FALSE(&from == this)) descriptor_pb_MergeFromFail(__LINE__);
  file_.MergeFrom(from.file_);
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void FileDescriptorSet::CopyFrom(const FileDescriptorSet& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.FileDescriptorSet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileDescriptorSet::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->file())) return false;
  return true;
}

void FileDescriptorSet::Swap(FileDescriptorSet* other) {
  if (other == this) return;
  InternalSwap(other);
}
void FileDescriptorSet::InternalSwap(FileDescriptorSet* other) {
  file_.UnsafeArenaSwap(&other->file_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string FileDescriptorSet::GetTypeName() const {
  return "perfetto.protos.FileDescriptorSet";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// FileDescriptorSet

// repeated .perfetto.protos.FileDescriptorProto file = 1;
int FileDescriptorSet::file_size() const {
  return file_.size();
}
void FileDescriptorSet::clear_file() {
  file_.Clear();
}
const ::perfetto::protos::FileDescriptorProto& FileDescriptorSet::file(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FileDescriptorSet.file)
  return file_.Get(index);
}
::perfetto::protos::FileDescriptorProto* FileDescriptorSet::mutable_file(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.FileDescriptorSet.file)
  return file_.Mutable(index);
}
::perfetto::protos::FileDescriptorProto* FileDescriptorSet::add_file() {
  // @@protoc_insertion_point(field_add:perfetto.protos.FileDescriptorSet.file)
  return file_.Add();
}
::google::protobuf::RepeatedPtrField< ::perfetto::protos::FileDescriptorProto >*
FileDescriptorSet::mutable_file() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.FileDescriptorSet.file)
  return &file_;
}
const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::FileDescriptorProto >&
FileDescriptorSet::file() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.FileDescriptorSet.file)
  return file_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForFileDescriptorProto(
    FileDescriptorProto* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FileDescriptorProto::kNameFieldNumber;
const int FileDescriptorProto::kPackageFieldNumber;
const int FileDescriptorProto::kDependencyFieldNumber;
const int FileDescriptorProto::kPublicDependencyFieldNumber;
const int FileDescriptorProto::kWeakDependencyFieldNumber;
const int FileDescriptorProto::kMessageTypeFieldNumber;
const int FileDescriptorProto::kEnumTypeFieldNumber;
const int FileDescriptorProto::kExtensionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

FileDescriptorProto::FileDescriptorProto()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.FileDescriptorProto)
}

void FileDescriptorProto::InitAsDefaultInstance() {
}

FileDescriptorProto::FileDescriptorProto(const FileDescriptorProto& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.FileDescriptorProto)
}

void FileDescriptorProto::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  package_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FileDescriptorProto::~FileDescriptorProto() {
  // @@protoc_insertion_point(destructor:perfetto.protos.FileDescriptorProto)
  SharedDtor();
}

void FileDescriptorProto::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  package_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void FileDescriptorProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FileDescriptorProto& FileDescriptorProto::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fcommon_2fdescriptor_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fcommon_2fdescriptor_2eproto();
#endif
  return *default_instance_;
}

FileDescriptorProto* FileDescriptorProto::default_instance_ = NULL;

FileDescriptorProto* FileDescriptorProto::New(::google::protobuf::Arena* arena) const {
  FileDescriptorProto* n = new FileDescriptorProto;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void FileDescriptorProto::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.FileDescriptorProto)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_name()) {
      name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_package()) {
      package_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  dependency_.Clear();
  public_dependency_.Clear();
  weak_dependency_.Clear();
  message_type_.Clear();
  enum_type_.Clear();
  extension_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool FileDescriptorProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForFileDescriptorProto, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.FileDescriptorProto)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_package;
        break;
      }

      // optional string package = 2;
      case 2: {
        if (tag == 18) {
         parse_package:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_package()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_dependency;
        break;
      }

      // repeated string dependency = 3;
      case 3: {
        if (tag == 26) {
         parse_dependency:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_dependency()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_dependency;
        if (input->ExpectTag(34)) goto parse_message_type;
        break;
      }

      // repeated .perfetto.protos.DescriptorProto message_type = 4;
      case 4: {
        if (tag == 34) {
         parse_message_type:
          DO_(input->IncrementRecursionDepth());
         parse_loop_message_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_message_type()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_loop_message_type;
        if (input->ExpectTag(42)) goto parse_loop_enum_type;
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // repeated .perfetto.protos.EnumDescriptorProto enum_type = 5;
      case 5: {
        if (tag == 42) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_enum_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_enum_type()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_loop_enum_type;
        if (input->ExpectTag(58)) goto parse_loop_extension;
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // repeated .perfetto.protos.FieldDescriptorProto extension = 7;
      case 7: {
        if (tag == 58) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_extension:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_extension()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_loop_extension;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(80)) goto parse_public_dependency;
        break;
      }

      // repeated int32 public_dependency = 10;
      case 10: {
        if (tag == 80) {
         parse_public_dependency:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 80, input, this->mutable_public_dependency())));
        } else if (tag == 82) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_public_dependency())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_public_dependency;
        if (input->ExpectTag(88)) goto parse_weak_dependency;
        break;
      }

      // repeated int32 weak_dependency = 11;
      case 11: {
        if (tag == 88) {
         parse_weak_dependency:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 88, input, this->mutable_weak_dependency())));
        } else if (tag == 90) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_weak_dependency())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_weak_dependency;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.FileDescriptorProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.FileDescriptorProto)
  return false;
#undef DO_
}

void FileDescriptorProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.FileDescriptorProto)
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional string package = 2;
  if (has_package()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->package(), output);
  }

  // repeated string dependency = 3;
  for (int i = 0; i < this->dependency_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->dependency(i), output);
  }

  // repeated .perfetto.protos.DescriptorProto message_type = 4;
  for (unsigned int i = 0, n = this->message_type_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->message_type(i), output);
  }

  // repeated .perfetto.protos.EnumDescriptorProto enum_type = 5;
  for (unsigned int i = 0, n = this->enum_type_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->enum_type(i), output);
  }

  // repeated .perfetto.protos.FieldDescriptorProto extension = 7;
  for (unsigned int i = 0, n = this->extension_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, this->extension(i), output);
  }

  // repeated int32 public_dependency = 10;
  for (int i = 0; i < this->public_dependency_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      10, this->public_dependency(i), output);
  }

  // repeated int32 weak_dependency = 11;
  for (int i = 0; i < this->weak_dependency_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      11, this->weak_dependency(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.FileDescriptorProto)
}

int FileDescriptorProto::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.FileDescriptorProto)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional string package = 2;
    if (has_package()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->package());
    }

  }
  // repeated string dependency = 3;
  total_size += 1 * this->dependency_size();
  for (int i = 0; i < this->dependency_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->dependency(i));
  }

  // repeated int32 public_dependency = 10;
  {
    int data_size = 0;
    for (int i = 0; i < this->public_dependency_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->public_dependency(i));
    }
    total_size += 1 * this->public_dependency_size() + data_size;
  }

  // repeated int32 weak_dependency = 11;
  {
    int data_size = 0;
    for (int i = 0; i < this->weak_dependency_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->weak_dependency(i));
    }
    total_size += 1 * this->weak_dependency_size() + data_size;
  }

  // repeated .perfetto.protos.DescriptorProto message_type = 4;
  total_size += 1 * this->message_type_size();
  for (int i = 0; i < this->message_type_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->message_type(i));
  }

  // repeated .perfetto.protos.EnumDescriptorProto enum_type = 5;
  total_size += 1 * this->enum_type_size();
  for (int i = 0; i < this->enum_type_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->enum_type(i));
  }

  // repeated .perfetto.protos.FieldDescriptorProto extension = 7;
  total_size += 1 * this->extension_size();
  for (int i = 0; i < this->extension_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->extension(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FileDescriptorProto::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FileDescriptorProto*>(&from));
}

void FileDescriptorProto::MergeFrom(const FileDescriptorProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.FileDescriptorProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) descriptor_pb_MergeFromFail(__LINE__);
  dependency_.MergeFrom(from.dependency_);
  public_dependency_.MergeFrom(from.public_dependency_);
  weak_dependency_.MergeFrom(from.weak_dependency_);
  message_type_.MergeFrom(from.message_type_);
  enum_type_.MergeFrom(from.enum_type_);
  extension_.MergeFrom(from.extension_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (from.has_package()) {
      set_has_package();
      package_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.package_);
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void FileDescriptorProto::CopyFrom(const FileDescriptorProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.FileDescriptorProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileDescriptorProto::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->message_type())) return false;
  return true;
}

void FileDescriptorProto::Swap(FileDescriptorProto* other) {
  if (other == this) return;
  InternalSwap(other);
}
void FileDescriptorProto::InternalSwap(FileDescriptorProto* other) {
  name_.Swap(&other->name_);
  package_.Swap(&other->package_);
  dependency_.UnsafeArenaSwap(&other->dependency_);
  public_dependency_.UnsafeArenaSwap(&other->public_dependency_);
  weak_dependency_.UnsafeArenaSwap(&other->weak_dependency_);
  message_type_.UnsafeArenaSwap(&other->message_type_);
  enum_type_.UnsafeArenaSwap(&other->enum_type_);
  extension_.UnsafeArenaSwap(&other->extension_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string FileDescriptorProto::GetTypeName() const {
  return "perfetto.protos.FileDescriptorProto";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// FileDescriptorProto

// optional string name = 1;
bool FileDescriptorProto::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void FileDescriptorProto::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
void FileDescriptorProto::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void FileDescriptorProto::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
 const ::std::string& FileDescriptorProto::name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FileDescriptorProto.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FileDescriptorProto::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.FileDescriptorProto.name)
}
 void FileDescriptorProto::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.FileDescriptorProto.name)
}
 void FileDescriptorProto::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.FileDescriptorProto.name)
}
 ::std::string* FileDescriptorProto::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.FileDescriptorProto.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* FileDescriptorProto::release_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.FileDescriptorProto.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FileDescriptorProto::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.FileDescriptorProto.name)
}

// optional string package = 2;
bool FileDescriptorProto::has_package() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void FileDescriptorProto::set_has_package() {
  _has_bits_[0] |= 0x00000002u;
}
void FileDescriptorProto::clear_has_package() {
  _has_bits_[0] &= ~0x00000002u;
}
void FileDescriptorProto::clear_package() {
  package_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_package();
}
 const ::std::string& FileDescriptorProto::package() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FileDescriptorProto.package)
  return package_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FileDescriptorProto::set_package(const ::std::string& value) {
  set_has_package();
  package_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.FileDescriptorProto.package)
}
 void FileDescriptorProto::set_package(const char* value) {
  set_has_package();
  package_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.FileDescriptorProto.package)
}
 void FileDescriptorProto::set_package(const char* value, size_t size) {
  set_has_package();
  package_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.FileDescriptorProto.package)
}
 ::std::string* FileDescriptorProto::mutable_package() {
  set_has_package();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.FileDescriptorProto.package)
  return package_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* FileDescriptorProto::release_package() {
  // @@protoc_insertion_point(field_release:perfetto.protos.FileDescriptorProto.package)
  clear_has_package();
  return package_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FileDescriptorProto::set_allocated_package(::std::string* package) {
  if (package != NULL) {
    set_has_package();
  } else {
    clear_has_package();
  }
  package_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), package);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.FileDescriptorProto.package)
}

// repeated string dependency = 3;
int FileDescriptorProto::dependency_size() const {
  return dependency_.size();
}
void FileDescriptorProto::clear_dependency() {
  dependency_.Clear();
}
 const ::std::string& FileDescriptorProto::dependency(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FileDescriptorProto.dependency)
  return dependency_.Get(index);
}
 ::std::string* FileDescriptorProto::mutable_dependency(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.FileDescriptorProto.dependency)
  return dependency_.Mutable(index);
}
 void FileDescriptorProto::set_dependency(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.FileDescriptorProto.dependency)
  dependency_.Mutable(index)->assign(value);
}
 void FileDescriptorProto::set_dependency(int index, const char* value) {
  dependency_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.FileDescriptorProto.dependency)
}
 void FileDescriptorProto::set_dependency(int index, const char* value, size_t size) {
  dependency_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.FileDescriptorProto.dependency)
}
 ::std::string* FileDescriptorProto::add_dependency() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.FileDescriptorProto.dependency)
  return dependency_.Add();
}
 void FileDescriptorProto::add_dependency(const ::std::string& value) {
  dependency_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.FileDescriptorProto.dependency)
}
 void FileDescriptorProto::add_dependency(const char* value) {
  dependency_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.FileDescriptorProto.dependency)
}
 void FileDescriptorProto::add_dependency(const char* value, size_t size) {
  dependency_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.FileDescriptorProto.dependency)
}
 const ::google::protobuf::RepeatedPtrField< ::std::string>&
FileDescriptorProto::dependency() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.FileDescriptorProto.dependency)
  return dependency_;
}
 ::google::protobuf::RepeatedPtrField< ::std::string>*
FileDescriptorProto::mutable_dependency() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.FileDescriptorProto.dependency)
  return &dependency_;
}

// repeated int32 public_dependency = 10;
int FileDescriptorProto::public_dependency_size() const {
  return public_dependency_.size();
}
void FileDescriptorProto::clear_public_dependency() {
  public_dependency_.Clear();
}
 ::google::protobuf::int32 FileDescriptorProto::public_dependency(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FileDescriptorProto.public_dependency)
  return public_dependency_.Get(index);
}
 void FileDescriptorProto::set_public_dependency(int index, ::google::protobuf::int32 value) {
  public_dependency_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.FileDescriptorProto.public_dependency)
}
 void FileDescriptorProto::add_public_dependency(::google::protobuf::int32 value) {
  public_dependency_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.FileDescriptorProto.public_dependency)
}
 const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
FileDescriptorProto::public_dependency() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.FileDescriptorProto.public_dependency)
  return public_dependency_;
}
 ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
FileDescriptorProto::mutable_public_dependency() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.FileDescriptorProto.public_dependency)
  return &public_dependency_;
}

// repeated int32 weak_dependency = 11;
int FileDescriptorProto::weak_dependency_size() const {
  return weak_dependency_.size();
}
void FileDescriptorProto::clear_weak_dependency() {
  weak_dependency_.Clear();
}
 ::google::protobuf::int32 FileDescriptorProto::weak_dependency(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FileDescriptorProto.weak_dependency)
  return weak_dependency_.Get(index);
}
 void FileDescriptorProto::set_weak_dependency(int index, ::google::protobuf::int32 value) {
  weak_dependency_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.FileDescriptorProto.weak_dependency)
}
 void FileDescriptorProto::add_weak_dependency(::google::protobuf::int32 value) {
  weak_dependency_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.FileDescriptorProto.weak_dependency)
}
 const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
FileDescriptorProto::weak_dependency() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.FileDescriptorProto.weak_dependency)
  return weak_dependency_;
}
 ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
FileDescriptorProto::mutable_weak_dependency() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.FileDescriptorProto.weak_dependency)
  return &weak_dependency_;
}

// repeated .perfetto.protos.DescriptorProto message_type = 4;
int FileDescriptorProto::message_type_size() const {
  return message_type_.size();
}
void FileDescriptorProto::clear_message_type() {
  message_type_.Clear();
}
const ::perfetto::protos::DescriptorProto& FileDescriptorProto::message_type(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FileDescriptorProto.message_type)
  return message_type_.Get(index);
}
::perfetto::protos::DescriptorProto* FileDescriptorProto::mutable_message_type(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.FileDescriptorProto.message_type)
  return message_type_.Mutable(index);
}
::perfetto::protos::DescriptorProto* FileDescriptorProto::add_message_type() {
  // @@protoc_insertion_point(field_add:perfetto.protos.FileDescriptorProto.message_type)
  return message_type_.Add();
}
::google::protobuf::RepeatedPtrField< ::perfetto::protos::DescriptorProto >*
FileDescriptorProto::mutable_message_type() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.FileDescriptorProto.message_type)
  return &message_type_;
}
const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::DescriptorProto >&
FileDescriptorProto::message_type() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.FileDescriptorProto.message_type)
  return message_type_;
}

// repeated .perfetto.protos.EnumDescriptorProto enum_type = 5;
int FileDescriptorProto::enum_type_size() const {
  return enum_type_.size();
}
void FileDescriptorProto::clear_enum_type() {
  enum_type_.Clear();
}
const ::perfetto::protos::EnumDescriptorProto& FileDescriptorProto::enum_type(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FileDescriptorProto.enum_type)
  return enum_type_.Get(index);
}
::perfetto::protos::EnumDescriptorProto* FileDescriptorProto::mutable_enum_type(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.FileDescriptorProto.enum_type)
  return enum_type_.Mutable(index);
}
::perfetto::protos::EnumDescriptorProto* FileDescriptorProto::add_enum_type() {
  // @@protoc_insertion_point(field_add:perfetto.protos.FileDescriptorProto.enum_type)
  return enum_type_.Add();
}
::google::protobuf::RepeatedPtrField< ::perfetto::protos::EnumDescriptorProto >*
FileDescriptorProto::mutable_enum_type() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.FileDescriptorProto.enum_type)
  return &enum_type_;
}
const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::EnumDescriptorProto >&
FileDescriptorProto::enum_type() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.FileDescriptorProto.enum_type)
  return enum_type_;
}

// repeated .perfetto.protos.FieldDescriptorProto extension = 7;
int FileDescriptorProto::extension_size() const {
  return extension_.size();
}
void FileDescriptorProto::clear_extension() {
  extension_.Clear();
}
const ::perfetto::protos::FieldDescriptorProto& FileDescriptorProto::extension(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FileDescriptorProto.extension)
  return extension_.Get(index);
}
::perfetto::protos::FieldDescriptorProto* FileDescriptorProto::mutable_extension(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.FileDescriptorProto.extension)
  return extension_.Mutable(index);
}
::perfetto::protos::FieldDescriptorProto* FileDescriptorProto::add_extension() {
  // @@protoc_insertion_point(field_add:perfetto.protos.FileDescriptorProto.extension)
  return extension_.Add();
}
::google::protobuf::RepeatedPtrField< ::perfetto::protos::FieldDescriptorProto >*
FileDescriptorProto::mutable_extension() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.FileDescriptorProto.extension)
  return &extension_;
}
const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::FieldDescriptorProto >&
FileDescriptorProto::extension() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.FileDescriptorProto.extension)
  return extension_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForDescriptorProto(
    DescriptorProto* ptr) {
  return ptr->mutable_unknown_fields();
}

static ::std::string* MutableUnknownFieldsForDescriptorProto_ReservedRange(
    DescriptorProto_ReservedRange* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DescriptorProto_ReservedRange::kStartFieldNumber;
const int DescriptorProto_ReservedRange::kEndFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DescriptorProto_ReservedRange::DescriptorProto_ReservedRange()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.DescriptorProto.ReservedRange)
}

void DescriptorProto_ReservedRange::InitAsDefaultInstance() {
}

DescriptorProto_ReservedRange::DescriptorProto_ReservedRange(const DescriptorProto_ReservedRange& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.DescriptorProto.ReservedRange)
}

void DescriptorProto_ReservedRange::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  start_ = 0;
  end_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DescriptorProto_ReservedRange::~DescriptorProto_ReservedRange() {
  // @@protoc_insertion_point(destructor:perfetto.protos.DescriptorProto.ReservedRange)
  SharedDtor();
}

void DescriptorProto_ReservedRange::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DescriptorProto_ReservedRange::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DescriptorProto_ReservedRange& DescriptorProto_ReservedRange::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fcommon_2fdescriptor_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fcommon_2fdescriptor_2eproto();
#endif
  return *default_instance_;
}

DescriptorProto_ReservedRange* DescriptorProto_ReservedRange::default_instance_ = NULL;

DescriptorProto_ReservedRange* DescriptorProto_ReservedRange::New(::google::protobuf::Arena* arena) const {
  DescriptorProto_ReservedRange* n = new DescriptorProto_ReservedRange;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DescriptorProto_ReservedRange::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.DescriptorProto.ReservedRange)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(DescriptorProto_ReservedRange, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<DescriptorProto_ReservedRange*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(start_, end_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool DescriptorProto_ReservedRange::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForDescriptorProto_ReservedRange, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.DescriptorProto.ReservedRange)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 start = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &start_)));
          set_has_start();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_end;
        break;
      }

      // optional int32 end = 2;
      case 2: {
        if (tag == 16) {
         parse_end:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &end_)));
          set_has_end();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.DescriptorProto.ReservedRange)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.DescriptorProto.ReservedRange)
  return false;
#undef DO_
}

void DescriptorProto_ReservedRange::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.DescriptorProto.ReservedRange)
  // optional int32 start = 1;
  if (has_start()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->start(), output);
  }

  // optional int32 end = 2;
  if (has_end()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->end(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.DescriptorProto.ReservedRange)
}

int DescriptorProto_ReservedRange::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.DescriptorProto.ReservedRange)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional int32 start = 1;
    if (has_start()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->start());
    }

    // optional int32 end = 2;
    if (has_end()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->end());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DescriptorProto_ReservedRange::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DescriptorProto_ReservedRange*>(&from));
}

void DescriptorProto_ReservedRange::MergeFrom(const DescriptorProto_ReservedRange& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.DescriptorProto.ReservedRange)
  if (GOOGLE_PREDICT_FALSE(&from == this)) descriptor_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_start()) {
      set_start(from.start());
    }
    if (from.has_end()) {
      set_end(from.end());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void DescriptorProto_ReservedRange::CopyFrom(const DescriptorProto_ReservedRange& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.DescriptorProto.ReservedRange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DescriptorProto_ReservedRange::IsInitialized() const {

  return true;
}

void DescriptorProto_ReservedRange::Swap(DescriptorProto_ReservedRange* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DescriptorProto_ReservedRange::InternalSwap(DescriptorProto_ReservedRange* other) {
  std::swap(start_, other->start_);
  std::swap(end_, other->end_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string DescriptorProto_ReservedRange::GetTypeName() const {
  return "perfetto.protos.DescriptorProto.ReservedRange";
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DescriptorProto::kNameFieldNumber;
const int DescriptorProto::kFieldFieldNumber;
const int DescriptorProto::kExtensionFieldNumber;
const int DescriptorProto::kNestedTypeFieldNumber;
const int DescriptorProto::kEnumTypeFieldNumber;
const int DescriptorProto::kOneofDeclFieldNumber;
const int DescriptorProto::kReservedRangeFieldNumber;
const int DescriptorProto::kReservedNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DescriptorProto::DescriptorProto()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.DescriptorProto)
}

void DescriptorProto::InitAsDefaultInstance() {
}

DescriptorProto::DescriptorProto(const DescriptorProto& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.DescriptorProto)
}

void DescriptorProto::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DescriptorProto::~DescriptorProto() {
  // @@protoc_insertion_point(destructor:perfetto.protos.DescriptorProto)
  SharedDtor();
}

void DescriptorProto::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DescriptorProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DescriptorProto& DescriptorProto::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fcommon_2fdescriptor_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fcommon_2fdescriptor_2eproto();
#endif
  return *default_instance_;
}

DescriptorProto* DescriptorProto::default_instance_ = NULL;

DescriptorProto* DescriptorProto::New(::google::protobuf::Arena* arena) const {
  DescriptorProto* n = new DescriptorProto;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DescriptorProto::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.DescriptorProto)
  if (has_name()) {
    name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  field_.Clear();
  extension_.Clear();
  nested_type_.Clear();
  enum_type_.Clear();
  oneof_decl_.Clear();
  reserved_range_.Clear();
  reserved_name_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool DescriptorProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForDescriptorProto, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.DescriptorProto)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_field;
        break;
      }

      // repeated .perfetto.protos.FieldDescriptorProto field = 2;
      case 2: {
        if (tag == 18) {
         parse_field:
          DO_(input->IncrementRecursionDepth());
         parse_loop_field:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_field()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_field;
        if (input->ExpectTag(26)) goto parse_loop_nested_type;
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // repeated .perfetto.protos.DescriptorProto nested_type = 3;
      case 3: {
        if (tag == 26) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_nested_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_nested_type()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_loop_nested_type;
        if (input->ExpectTag(34)) goto parse_loop_enum_type;
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // repeated .perfetto.protos.EnumDescriptorProto enum_type = 4;
      case 4: {
        if (tag == 34) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_enum_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_enum_type()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_loop_enum_type;
        if (input->ExpectTag(50)) goto parse_loop_extension;
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // repeated .perfetto.protos.FieldDescriptorProto extension = 6;
      case 6: {
        if (tag == 50) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_extension:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_extension()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_loop_extension;
        if (input->ExpectTag(66)) goto parse_loop_oneof_decl;
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // repeated .perfetto.protos.OneofDescriptorProto oneof_decl = 8;
      case 8: {
        if (tag == 66) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_oneof_decl:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_oneof_decl()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_loop_oneof_decl;
        if (input->ExpectTag(74)) goto parse_loop_reserved_range;
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // repeated .perfetto.protos.DescriptorProto.ReservedRange reserved_range = 9;
      case 9: {
        if (tag == 74) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_reserved_range:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_reserved_range()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_loop_reserved_range;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(82)) goto parse_reserved_name;
        break;
      }

      // repeated string reserved_name = 10;
      case 10: {
        if (tag == 82) {
         parse_reserved_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_reserved_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_reserved_name;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.DescriptorProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.DescriptorProto)
  return false;
#undef DO_
}

void DescriptorProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.DescriptorProto)
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // repeated .perfetto.protos.FieldDescriptorProto field = 2;
  for (unsigned int i = 0, n = this->field_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->field(i), output);
  }

  // repeated .perfetto.protos.DescriptorProto nested_type = 3;
  for (unsigned int i = 0, n = this->nested_type_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->nested_type(i), output);
  }

  // repeated .perfetto.protos.EnumDescriptorProto enum_type = 4;
  for (unsigned int i = 0, n = this->enum_type_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->enum_type(i), output);
  }

  // repeated .perfetto.protos.FieldDescriptorProto extension = 6;
  for (unsigned int i = 0, n = this->extension_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->extension(i), output);
  }

  // repeated .perfetto.protos.OneofDescriptorProto oneof_decl = 8;
  for (unsigned int i = 0, n = this->oneof_decl_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      8, this->oneof_decl(i), output);
  }

  // repeated .perfetto.protos.DescriptorProto.ReservedRange reserved_range = 9;
  for (unsigned int i = 0, n = this->reserved_range_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      9, this->reserved_range(i), output);
  }

  // repeated string reserved_name = 10;
  for (int i = 0; i < this->reserved_name_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      10, this->reserved_name(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.DescriptorProto)
}

int DescriptorProto::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.DescriptorProto)
  int total_size = 0;

  // optional string name = 1;
  if (has_name()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }

  // repeated .perfetto.protos.FieldDescriptorProto field = 2;
  total_size += 1 * this->field_size();
  for (int i = 0; i < this->field_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->field(i));
  }

  // repeated .perfetto.protos.FieldDescriptorProto extension = 6;
  total_size += 1 * this->extension_size();
  for (int i = 0; i < this->extension_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->extension(i));
  }

  // repeated .perfetto.protos.DescriptorProto nested_type = 3;
  total_size += 1 * this->nested_type_size();
  for (int i = 0; i < this->nested_type_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->nested_type(i));
  }

  // repeated .perfetto.protos.EnumDescriptorProto enum_type = 4;
  total_size += 1 * this->enum_type_size();
  for (int i = 0; i < this->enum_type_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->enum_type(i));
  }

  // repeated .perfetto.protos.OneofDescriptorProto oneof_decl = 8;
  total_size += 1 * this->oneof_decl_size();
  for (int i = 0; i < this->oneof_decl_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->oneof_decl(i));
  }

  // repeated .perfetto.protos.DescriptorProto.ReservedRange reserved_range = 9;
  total_size += 1 * this->reserved_range_size();
  for (int i = 0; i < this->reserved_range_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->reserved_range(i));
  }

  // repeated string reserved_name = 10;
  total_size += 1 * this->reserved_name_size();
  for (int i = 0; i < this->reserved_name_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->reserved_name(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DescriptorProto::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DescriptorProto*>(&from));
}

void DescriptorProto::MergeFrom(const DescriptorProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.DescriptorProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) descriptor_pb_MergeFromFail(__LINE__);
  field_.MergeFrom(from.field_);
  extension_.MergeFrom(from.extension_);
  nested_type_.MergeFrom(from.nested_type_);
  enum_type_.MergeFrom(from.enum_type_);
  oneof_decl_.MergeFrom(from.oneof_decl_);
  reserved_range_.MergeFrom(from.reserved_range_);
  reserved_name_.MergeFrom(from.reserved_name_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void DescriptorProto::CopyFrom(const DescriptorProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.DescriptorProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DescriptorProto::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->nested_type())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->oneof_decl())) return false;
  return true;
}

void DescriptorProto::Swap(DescriptorProto* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DescriptorProto::InternalSwap(DescriptorProto* other) {
  name_.Swap(&other->name_);
  field_.UnsafeArenaSwap(&other->field_);
  extension_.UnsafeArenaSwap(&other->extension_);
  nested_type_.UnsafeArenaSwap(&other->nested_type_);
  enum_type_.UnsafeArenaSwap(&other->enum_type_);
  oneof_decl_.UnsafeArenaSwap(&other->oneof_decl_);
  reserved_range_.UnsafeArenaSwap(&other->reserved_range_);
  reserved_name_.UnsafeArenaSwap(&other->reserved_name_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string DescriptorProto::GetTypeName() const {
  return "perfetto.protos.DescriptorProto";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DescriptorProto_ReservedRange

// optional int32 start = 1;
bool DescriptorProto_ReservedRange::has_start() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void DescriptorProto_ReservedRange::set_has_start() {
  _has_bits_[0] |= 0x00000001u;
}
void DescriptorProto_ReservedRange::clear_has_start() {
  _has_bits_[0] &= ~0x00000001u;
}
void DescriptorProto_ReservedRange::clear_start() {
  start_ = 0;
  clear_has_start();
}
 ::google::protobuf::int32 DescriptorProto_ReservedRange::start() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DescriptorProto.ReservedRange.start)
  return start_;
}
 void DescriptorProto_ReservedRange::set_start(::google::protobuf::int32 value) {
  set_has_start();
  start_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.DescriptorProto.ReservedRange.start)
}

// optional int32 end = 2;
bool DescriptorProto_ReservedRange::has_end() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void DescriptorProto_ReservedRange::set_has_end() {
  _has_bits_[0] |= 0x00000002u;
}
void DescriptorProto_ReservedRange::clear_has_end() {
  _has_bits_[0] &= ~0x00000002u;
}
void DescriptorProto_ReservedRange::clear_end() {
  end_ = 0;
  clear_has_end();
}
 ::google::protobuf::int32 DescriptorProto_ReservedRange::end() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DescriptorProto.ReservedRange.end)
  return end_;
}
 void DescriptorProto_ReservedRange::set_end(::google::protobuf::int32 value) {
  set_has_end();
  end_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.DescriptorProto.ReservedRange.end)
}

// -------------------------------------------------------------------

// DescriptorProto

// optional string name = 1;
bool DescriptorProto::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void DescriptorProto::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
void DescriptorProto::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void DescriptorProto::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
 const ::std::string& DescriptorProto::name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DescriptorProto.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DescriptorProto::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.DescriptorProto.name)
}
 void DescriptorProto::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.DescriptorProto.name)
}
 void DescriptorProto::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.DescriptorProto.name)
}
 ::std::string* DescriptorProto::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DescriptorProto.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* DescriptorProto::release_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DescriptorProto.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DescriptorProto::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DescriptorProto.name)
}

// repeated .perfetto.protos.FieldDescriptorProto field = 2;
int DescriptorProto::field_size() const {
  return field_.size();
}
void DescriptorProto::clear_field() {
  field_.Clear();
}
const ::perfetto::protos::FieldDescriptorProto& DescriptorProto::field(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DescriptorProto.field)
  return field_.Get(index);
}
::perfetto::protos::FieldDescriptorProto* DescriptorProto::mutable_field(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DescriptorProto.field)
  return field_.Mutable(index);
}
::perfetto::protos::FieldDescriptorProto* DescriptorProto::add_field() {
  // @@protoc_insertion_point(field_add:perfetto.protos.DescriptorProto.field)
  return field_.Add();
}
::google::protobuf::RepeatedPtrField< ::perfetto::protos::FieldDescriptorProto >*
DescriptorProto::mutable_field() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.DescriptorProto.field)
  return &field_;
}
const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::FieldDescriptorProto >&
DescriptorProto::field() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.DescriptorProto.field)
  return field_;
}

// repeated .perfetto.protos.FieldDescriptorProto extension = 6;
int DescriptorProto::extension_size() const {
  return extension_.size();
}
void DescriptorProto::clear_extension() {
  extension_.Clear();
}
const ::perfetto::protos::FieldDescriptorProto& DescriptorProto::extension(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DescriptorProto.extension)
  return extension_.Get(index);
}
::perfetto::protos::FieldDescriptorProto* DescriptorProto::mutable_extension(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DescriptorProto.extension)
  return extension_.Mutable(index);
}
::perfetto::protos::FieldDescriptorProto* DescriptorProto::add_extension() {
  // @@protoc_insertion_point(field_add:perfetto.protos.DescriptorProto.extension)
  return extension_.Add();
}
::google::protobuf::RepeatedPtrField< ::perfetto::protos::FieldDescriptorProto >*
DescriptorProto::mutable_extension() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.DescriptorProto.extension)
  return &extension_;
}
const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::FieldDescriptorProto >&
DescriptorProto::extension() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.DescriptorProto.extension)
  return extension_;
}

// repeated .perfetto.protos.DescriptorProto nested_type = 3;
int DescriptorProto::nested_type_size() const {
  return nested_type_.size();
}
void DescriptorProto::clear_nested_type() {
  nested_type_.Clear();
}
const ::perfetto::protos::DescriptorProto& DescriptorProto::nested_type(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DescriptorProto.nested_type)
  return nested_type_.Get(index);
}
::perfetto::protos::DescriptorProto* DescriptorProto::mutable_nested_type(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DescriptorProto.nested_type)
  return nested_type_.Mutable(index);
}
::perfetto::protos::DescriptorProto* DescriptorProto::add_nested_type() {
  // @@protoc_insertion_point(field_add:perfetto.protos.DescriptorProto.nested_type)
  return nested_type_.Add();
}
::google::protobuf::RepeatedPtrField< ::perfetto::protos::DescriptorProto >*
DescriptorProto::mutable_nested_type() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.DescriptorProto.nested_type)
  return &nested_type_;
}
const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::DescriptorProto >&
DescriptorProto::nested_type() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.DescriptorProto.nested_type)
  return nested_type_;
}

// repeated .perfetto.protos.EnumDescriptorProto enum_type = 4;
int DescriptorProto::enum_type_size() const {
  return enum_type_.size();
}
void DescriptorProto::clear_enum_type() {
  enum_type_.Clear();
}
const ::perfetto::protos::EnumDescriptorProto& DescriptorProto::enum_type(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DescriptorProto.enum_type)
  return enum_type_.Get(index);
}
::perfetto::protos::EnumDescriptorProto* DescriptorProto::mutable_enum_type(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DescriptorProto.enum_type)
  return enum_type_.Mutable(index);
}
::perfetto::protos::EnumDescriptorProto* DescriptorProto::add_enum_type() {
  // @@protoc_insertion_point(field_add:perfetto.protos.DescriptorProto.enum_type)
  return enum_type_.Add();
}
::google::protobuf::RepeatedPtrField< ::perfetto::protos::EnumDescriptorProto >*
DescriptorProto::mutable_enum_type() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.DescriptorProto.enum_type)
  return &enum_type_;
}
const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::EnumDescriptorProto >&
DescriptorProto::enum_type() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.DescriptorProto.enum_type)
  return enum_type_;
}

// repeated .perfetto.protos.OneofDescriptorProto oneof_decl = 8;
int DescriptorProto::oneof_decl_size() const {
  return oneof_decl_.size();
}
void DescriptorProto::clear_oneof_decl() {
  oneof_decl_.Clear();
}
const ::perfetto::protos::OneofDescriptorProto& DescriptorProto::oneof_decl(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DescriptorProto.oneof_decl)
  return oneof_decl_.Get(index);
}
::perfetto::protos::OneofDescriptorProto* DescriptorProto::mutable_oneof_decl(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DescriptorProto.oneof_decl)
  return oneof_decl_.Mutable(index);
}
::perfetto::protos::OneofDescriptorProto* DescriptorProto::add_oneof_decl() {
  // @@protoc_insertion_point(field_add:perfetto.protos.DescriptorProto.oneof_decl)
  return oneof_decl_.Add();
}
::google::protobuf::RepeatedPtrField< ::perfetto::protos::OneofDescriptorProto >*
DescriptorProto::mutable_oneof_decl() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.DescriptorProto.oneof_decl)
  return &oneof_decl_;
}
const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::OneofDescriptorProto >&
DescriptorProto::oneof_decl() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.DescriptorProto.oneof_decl)
  return oneof_decl_;
}

// repeated .perfetto.protos.DescriptorProto.ReservedRange reserved_range = 9;
int DescriptorProto::reserved_range_size() const {
  return reserved_range_.size();
}
void DescriptorProto::clear_reserved_range() {
  reserved_range_.Clear();
}
const ::perfetto::protos::DescriptorProto_ReservedRange& DescriptorProto::reserved_range(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DescriptorProto.reserved_range)
  return reserved_range_.Get(index);
}
::perfetto::protos::DescriptorProto_ReservedRange* DescriptorProto::mutable_reserved_range(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DescriptorProto.reserved_range)
  return reserved_range_.Mutable(index);
}
::perfetto::protos::DescriptorProto_ReservedRange* DescriptorProto::add_reserved_range() {
  // @@protoc_insertion_point(field_add:perfetto.protos.DescriptorProto.reserved_range)
  return reserved_range_.Add();
}
::google::protobuf::RepeatedPtrField< ::perfetto::protos::DescriptorProto_ReservedRange >*
DescriptorProto::mutable_reserved_range() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.DescriptorProto.reserved_range)
  return &reserved_range_;
}
const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::DescriptorProto_ReservedRange >&
DescriptorProto::reserved_range() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.DescriptorProto.reserved_range)
  return reserved_range_;
}

// repeated string reserved_name = 10;
int DescriptorProto::reserved_name_size() const {
  return reserved_name_.size();
}
void DescriptorProto::clear_reserved_name() {
  reserved_name_.Clear();
}
 const ::std::string& DescriptorProto::reserved_name(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DescriptorProto.reserved_name)
  return reserved_name_.Get(index);
}
 ::std::string* DescriptorProto::mutable_reserved_name(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DescriptorProto.reserved_name)
  return reserved_name_.Mutable(index);
}
 void DescriptorProto::set_reserved_name(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.DescriptorProto.reserved_name)
  reserved_name_.Mutable(index)->assign(value);
}
 void DescriptorProto::set_reserved_name(int index, const char* value) {
  reserved_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.DescriptorProto.reserved_name)
}
 void DescriptorProto::set_reserved_name(int index, const char* value, size_t size) {
  reserved_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.DescriptorProto.reserved_name)
}
 ::std::string* DescriptorProto::add_reserved_name() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.DescriptorProto.reserved_name)
  return reserved_name_.Add();
}
 void DescriptorProto::add_reserved_name(const ::std::string& value) {
  reserved_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.DescriptorProto.reserved_name)
}
 void DescriptorProto::add_reserved_name(const char* value) {
  reserved_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.DescriptorProto.reserved_name)
}
 void DescriptorProto::add_reserved_name(const char* value, size_t size) {
  reserved_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.DescriptorProto.reserved_name)
}
 const ::google::protobuf::RepeatedPtrField< ::std::string>&
DescriptorProto::reserved_name() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.DescriptorProto.reserved_name)
  return reserved_name_;
}
 ::google::protobuf::RepeatedPtrField< ::std::string>*
DescriptorProto::mutable_reserved_name() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.DescriptorProto.reserved_name)
  return &reserved_name_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForFieldDescriptorProto(
    FieldDescriptorProto* ptr) {
  return ptr->mutable_unknown_fields();
}

bool FieldDescriptorProto_Type_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const FieldDescriptorProto_Type FieldDescriptorProto::TYPE_DOUBLE;
const FieldDescriptorProto_Type FieldDescriptorProto::TYPE_FLOAT;
const FieldDescriptorProto_Type FieldDescriptorProto::TYPE_INT64;
const FieldDescriptorProto_Type FieldDescriptorProto::TYPE_UINT64;
const FieldDescriptorProto_Type FieldDescriptorProto::TYPE_INT32;
const FieldDescriptorProto_Type FieldDescriptorProto::TYPE_FIXED64;
const FieldDescriptorProto_Type FieldDescriptorProto::TYPE_FIXED32;
const FieldDescriptorProto_Type FieldDescriptorProto::TYPE_BOOL;
const FieldDescriptorProto_Type FieldDescriptorProto::TYPE_STRING;
const FieldDescriptorProto_Type FieldDescriptorProto::TYPE_GROUP;
const FieldDescriptorProto_Type FieldDescriptorProto::TYPE_MESSAGE;
const FieldDescriptorProto_Type FieldDescriptorProto::TYPE_BYTES;
const FieldDescriptorProto_Type FieldDescriptorProto::TYPE_UINT32;
const FieldDescriptorProto_Type FieldDescriptorProto::TYPE_ENUM;
const FieldDescriptorProto_Type FieldDescriptorProto::TYPE_SFIXED32;
const FieldDescriptorProto_Type FieldDescriptorProto::TYPE_SFIXED64;
const FieldDescriptorProto_Type FieldDescriptorProto::TYPE_SINT32;
const FieldDescriptorProto_Type FieldDescriptorProto::TYPE_SINT64;
const FieldDescriptorProto_Type FieldDescriptorProto::Type_MIN;
const FieldDescriptorProto_Type FieldDescriptorProto::Type_MAX;
const int FieldDescriptorProto::Type_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
bool FieldDescriptorProto_Label_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const FieldDescriptorProto_Label FieldDescriptorProto::LABEL_OPTIONAL;
const FieldDescriptorProto_Label FieldDescriptorProto::LABEL_REQUIRED;
const FieldDescriptorProto_Label FieldDescriptorProto::LABEL_REPEATED;
const FieldDescriptorProto_Label FieldDescriptorProto::Label_MIN;
const FieldDescriptorProto_Label FieldDescriptorProto::Label_MAX;
const int FieldDescriptorProto::Label_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FieldDescriptorProto::kNameFieldNumber;
const int FieldDescriptorProto::kNumberFieldNumber;
const int FieldDescriptorProto::kLabelFieldNumber;
const int FieldDescriptorProto::kTypeFieldNumber;
const int FieldDescriptorProto::kTypeNameFieldNumber;
const int FieldDescriptorProto::kExtendeeFieldNumber;
const int FieldDescriptorProto::kDefaultValueFieldNumber;
const int FieldDescriptorProto::kOneofIndexFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

FieldDescriptorProto::FieldDescriptorProto()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.FieldDescriptorProto)
}

void FieldDescriptorProto::InitAsDefaultInstance() {
}

FieldDescriptorProto::FieldDescriptorProto(const FieldDescriptorProto& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.FieldDescriptorProto)
}

void FieldDescriptorProto::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  number_ = 0;
  label_ = 1;
  type_ = 1;
  type_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  extendee_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  default_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  oneof_index_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FieldDescriptorProto::~FieldDescriptorProto() {
  // @@protoc_insertion_point(destructor:perfetto.protos.FieldDescriptorProto)
  SharedDtor();
}

void FieldDescriptorProto::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  type_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  extendee_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  default_value_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void FieldDescriptorProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FieldDescriptorProto& FieldDescriptorProto::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fcommon_2fdescriptor_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fcommon_2fdescriptor_2eproto();
#endif
  return *default_instance_;
}

FieldDescriptorProto* FieldDescriptorProto::default_instance_ = NULL;

FieldDescriptorProto* FieldDescriptorProto::New(::google::protobuf::Arena* arena) const {
  FieldDescriptorProto* n = new FieldDescriptorProto;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void FieldDescriptorProto::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.FieldDescriptorProto)
  if (_has_bits_[0 / 32] & 255u) {
    if (has_name()) {
      name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    number_ = 0;
    label_ = 1;
    type_ = 1;
    if (has_type_name()) {
      type_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_extendee()) {
      extendee_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_default_value()) {
      default_value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    oneof_index_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool FieldDescriptorProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForFieldDescriptorProto, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.FieldDescriptorProto)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_extendee;
        break;
      }

      // optional string extendee = 2;
      case 2: {
        if (tag == 18) {
         parse_extendee:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_extendee()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_number;
        break;
      }

      // optional int32 number = 3;
      case 3: {
        if (tag == 24) {
         parse_number:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &number_)));
          set_has_number();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_label;
        break;
      }

      // optional .perfetto.protos.FieldDescriptorProto.Label label = 4;
      case 4: {
        if (tag == 32) {
         parse_label:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::perfetto::protos::FieldDescriptorProto_Label_IsValid(value)) {
            set_label(static_cast< ::perfetto::protos::FieldDescriptorProto_Label >(value));
          } else {
            unknown_fields_stream.WriteVarint32(32);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_type;
        break;
      }

      // optional .perfetto.protos.FieldDescriptorProto.Type type = 5;
      case 5: {
        if (tag == 40) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::perfetto::protos::FieldDescriptorProto_Type_IsValid(value)) {
            set_type(static_cast< ::perfetto::protos::FieldDescriptorProto_Type >(value));
          } else {
            unknown_fields_stream.WriteVarint32(40);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_type_name;
        break;
      }

      // optional string type_name = 6;
      case 6: {
        if (tag == 50) {
         parse_type_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_type_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_default_value;
        break;
      }

      // optional string default_value = 7;
      case 7: {
        if (tag == 58) {
         parse_default_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_default_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_oneof_index;
        break;
      }

      // optional int32 oneof_index = 9;
      case 9: {
        if (tag == 72) {
         parse_oneof_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &oneof_index_)));
          set_has_oneof_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.FieldDescriptorProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.FieldDescriptorProto)
  return false;
#undef DO_
}

void FieldDescriptorProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.FieldDescriptorProto)
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional string extendee = 2;
  if (has_extendee()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->extendee(), output);
  }

  // optional int32 number = 3;
  if (has_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->number(), output);
  }

  // optional .perfetto.protos.FieldDescriptorProto.Label label = 4;
  if (has_label()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->label(), output);
  }

  // optional .perfetto.protos.FieldDescriptorProto.Type type = 5;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->type(), output);
  }

  // optional string type_name = 6;
  if (has_type_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->type_name(), output);
  }

  // optional string default_value = 7;
  if (has_default_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      7, this->default_value(), output);
  }

  // optional int32 oneof_index = 9;
  if (has_oneof_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(9, this->oneof_index(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.FieldDescriptorProto)
}

int FieldDescriptorProto::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.FieldDescriptorProto)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 255u) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional int32 number = 3;
    if (has_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->number());
    }

    // optional .perfetto.protos.FieldDescriptorProto.Label label = 4;
    if (has_label()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->label());
    }

    // optional .perfetto.protos.FieldDescriptorProto.Type type = 5;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional string type_name = 6;
    if (has_type_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->type_name());
    }

    // optional string extendee = 2;
    if (has_extendee()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->extendee());
    }

    // optional string default_value = 7;
    if (has_default_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->default_value());
    }

    // optional int32 oneof_index = 9;
    if (has_oneof_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->oneof_index());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FieldDescriptorProto::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FieldDescriptorProto*>(&from));
}

void FieldDescriptorProto::MergeFrom(const FieldDescriptorProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.FieldDescriptorProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) descriptor_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (from.has_number()) {
      set_number(from.number());
    }
    if (from.has_label()) {
      set_label(from.label());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_type_name()) {
      set_has_type_name();
      type_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.type_name_);
    }
    if (from.has_extendee()) {
      set_has_extendee();
      extendee_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.extendee_);
    }
    if (from.has_default_value()) {
      set_has_default_value();
      default_value_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.default_value_);
    }
    if (from.has_oneof_index()) {
      set_oneof_index(from.oneof_index());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void FieldDescriptorProto::CopyFrom(const FieldDescriptorProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.FieldDescriptorProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FieldDescriptorProto::IsInitialized() const {

  return true;
}

void FieldDescriptorProto::Swap(FieldDescriptorProto* other) {
  if (other == this) return;
  InternalSwap(other);
}
void FieldDescriptorProto::InternalSwap(FieldDescriptorProto* other) {
  name_.Swap(&other->name_);
  std::swap(number_, other->number_);
  std::swap(label_, other->label_);
  std::swap(type_, other->type_);
  type_name_.Swap(&other->type_name_);
  extendee_.Swap(&other->extendee_);
  default_value_.Swap(&other->default_value_);
  std::swap(oneof_index_, other->oneof_index_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string FieldDescriptorProto::GetTypeName() const {
  return "perfetto.protos.FieldDescriptorProto";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// FieldDescriptorProto

// optional string name = 1;
bool FieldDescriptorProto::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void FieldDescriptorProto::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
void FieldDescriptorProto::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void FieldDescriptorProto::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
 const ::std::string& FieldDescriptorProto::name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FieldDescriptorProto.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FieldDescriptorProto::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.FieldDescriptorProto.name)
}
 void FieldDescriptorProto::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.FieldDescriptorProto.name)
}
 void FieldDescriptorProto::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.FieldDescriptorProto.name)
}
 ::std::string* FieldDescriptorProto::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.FieldDescriptorProto.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* FieldDescriptorProto::release_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.FieldDescriptorProto.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FieldDescriptorProto::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.FieldDescriptorProto.name)
}

// optional int32 number = 3;
bool FieldDescriptorProto::has_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void FieldDescriptorProto::set_has_number() {
  _has_bits_[0] |= 0x00000002u;
}
void FieldDescriptorProto::clear_has_number() {
  _has_bits_[0] &= ~0x00000002u;
}
void FieldDescriptorProto::clear_number() {
  number_ = 0;
  clear_has_number();
}
 ::google::protobuf::int32 FieldDescriptorProto::number() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FieldDescriptorProto.number)
  return number_;
}
 void FieldDescriptorProto::set_number(::google::protobuf::int32 value) {
  set_has_number();
  number_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.FieldDescriptorProto.number)
}

// optional .perfetto.protos.FieldDescriptorProto.Label label = 4;
bool FieldDescriptorProto::has_label() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void FieldDescriptorProto::set_has_label() {
  _has_bits_[0] |= 0x00000004u;
}
void FieldDescriptorProto::clear_has_label() {
  _has_bits_[0] &= ~0x00000004u;
}
void FieldDescriptorProto::clear_label() {
  label_ = 1;
  clear_has_label();
}
 ::perfetto::protos::FieldDescriptorProto_Label FieldDescriptorProto::label() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FieldDescriptorProto.label)
  return static_cast< ::perfetto::protos::FieldDescriptorProto_Label >(label_);
}
 void FieldDescriptorProto::set_label(::perfetto::protos::FieldDescriptorProto_Label value) {
  assert(::perfetto::protos::FieldDescriptorProto_Label_IsValid(value));
  set_has_label();
  label_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.FieldDescriptorProto.label)
}

// optional .perfetto.protos.FieldDescriptorProto.Type type = 5;
bool FieldDescriptorProto::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void FieldDescriptorProto::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
void FieldDescriptorProto::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
void FieldDescriptorProto::clear_type() {
  type_ = 1;
  clear_has_type();
}
 ::perfetto::protos::FieldDescriptorProto_Type FieldDescriptorProto::type() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FieldDescriptorProto.type)
  return static_cast< ::perfetto::protos::FieldDescriptorProto_Type >(type_);
}
 void FieldDescriptorProto::set_type(::perfetto::protos::FieldDescriptorProto_Type value) {
  assert(::perfetto::protos::FieldDescriptorProto_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.FieldDescriptorProto.type)
}

// optional string type_name = 6;
bool FieldDescriptorProto::has_type_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void FieldDescriptorProto::set_has_type_name() {
  _has_bits_[0] |= 0x00000010u;
}
void FieldDescriptorProto::clear_has_type_name() {
  _has_bits_[0] &= ~0x00000010u;
}
void FieldDescriptorProto::clear_type_name() {
  type_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type_name();
}
 const ::std::string& FieldDescriptorProto::type_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FieldDescriptorProto.type_name)
  return type_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FieldDescriptorProto::set_type_name(const ::std::string& value) {
  set_has_type_name();
  type_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.FieldDescriptorProto.type_name)
}
 void FieldDescriptorProto::set_type_name(const char* value) {
  set_has_type_name();
  type_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.FieldDescriptorProto.type_name)
}
 void FieldDescriptorProto::set_type_name(const char* value, size_t size) {
  set_has_type_name();
  type_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.FieldDescriptorProto.type_name)
}
 ::std::string* FieldDescriptorProto::mutable_type_name() {
  set_has_type_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.FieldDescriptorProto.type_name)
  return type_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* FieldDescriptorProto::release_type_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.FieldDescriptorProto.type_name)
  clear_has_type_name();
  return type_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FieldDescriptorProto::set_allocated_type_name(::std::string* type_name) {
  if (type_name != NULL) {
    set_has_type_name();
  } else {
    clear_has_type_name();
  }
  type_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type_name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.FieldDescriptorProto.type_name)
}

// optional string extendee = 2;
bool FieldDescriptorProto::has_extendee() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void FieldDescriptorProto::set_has_extendee() {
  _has_bits_[0] |= 0x00000020u;
}
void FieldDescriptorProto::clear_has_extendee() {
  _has_bits_[0] &= ~0x00000020u;
}
void FieldDescriptorProto::clear_extendee() {
  extendee_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_extendee();
}
 const ::std::string& FieldDescriptorProto::extendee() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FieldDescriptorProto.extendee)
  return extendee_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FieldDescriptorProto::set_extendee(const ::std::string& value) {
  set_has_extendee();
  extendee_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.FieldDescriptorProto.extendee)
}
 void FieldDescriptorProto::set_extendee(const char* value) {
  set_has_extendee();
  extendee_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.FieldDescriptorProto.extendee)
}
 void FieldDescriptorProto::set_extendee(const char* value, size_t size) {
  set_has_extendee();
  extendee_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.FieldDescriptorProto.extendee)
}
 ::std::string* FieldDescriptorProto::mutable_extendee() {
  set_has_extendee();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.FieldDescriptorProto.extendee)
  return extendee_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* FieldDescriptorProto::release_extendee() {
  // @@protoc_insertion_point(field_release:perfetto.protos.FieldDescriptorProto.extendee)
  clear_has_extendee();
  return extendee_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FieldDescriptorProto::set_allocated_extendee(::std::string* extendee) {
  if (extendee != NULL) {
    set_has_extendee();
  } else {
    clear_has_extendee();
  }
  extendee_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), extendee);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.FieldDescriptorProto.extendee)
}

// optional string default_value = 7;
bool FieldDescriptorProto::has_default_value() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void FieldDescriptorProto::set_has_default_value() {
  _has_bits_[0] |= 0x00000040u;
}
void FieldDescriptorProto::clear_has_default_value() {
  _has_bits_[0] &= ~0x00000040u;
}
void FieldDescriptorProto::clear_default_value() {
  default_value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_default_value();
}
 const ::std::string& FieldDescriptorProto::default_value() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FieldDescriptorProto.default_value)
  return default_value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FieldDescriptorProto::set_default_value(const ::std::string& value) {
  set_has_default_value();
  default_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.FieldDescriptorProto.default_value)
}
 void FieldDescriptorProto::set_default_value(const char* value) {
  set_has_default_value();
  default_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.FieldDescriptorProto.default_value)
}
 void FieldDescriptorProto::set_default_value(const char* value, size_t size) {
  set_has_default_value();
  default_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.FieldDescriptorProto.default_value)
}
 ::std::string* FieldDescriptorProto::mutable_default_value() {
  set_has_default_value();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.FieldDescriptorProto.default_value)
  return default_value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* FieldDescriptorProto::release_default_value() {
  // @@protoc_insertion_point(field_release:perfetto.protos.FieldDescriptorProto.default_value)
  clear_has_default_value();
  return default_value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FieldDescriptorProto::set_allocated_default_value(::std::string* default_value) {
  if (default_value != NULL) {
    set_has_default_value();
  } else {
    clear_has_default_value();
  }
  default_value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), default_value);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.FieldDescriptorProto.default_value)
}

// optional int32 oneof_index = 9;
bool FieldDescriptorProto::has_oneof_index() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void FieldDescriptorProto::set_has_oneof_index() {
  _has_bits_[0] |= 0x00000080u;
}
void FieldDescriptorProto::clear_has_oneof_index() {
  _has_bits_[0] &= ~0x00000080u;
}
void FieldDescriptorProto::clear_oneof_index() {
  oneof_index_ = 0;
  clear_has_oneof_index();
}
 ::google::protobuf::int32 FieldDescriptorProto::oneof_index() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FieldDescriptorProto.oneof_index)
  return oneof_index_;
}
 void FieldDescriptorProto::set_oneof_index(::google::protobuf::int32 value) {
  set_has_oneof_index();
  oneof_index_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.FieldDescriptorProto.oneof_index)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForOneofDescriptorProto(
    OneofDescriptorProto* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int OneofDescriptorProto::kNameFieldNumber;
const int OneofDescriptorProto::kOptionsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

OneofDescriptorProto::OneofDescriptorProto()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.OneofDescriptorProto)
}

void OneofDescriptorProto::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  options_ = const_cast< ::perfetto::protos::OneofOptions*>(
      ::perfetto::protos::OneofOptions::internal_default_instance());
#else
  options_ = const_cast< ::perfetto::protos::OneofOptions*>(&::perfetto::protos::OneofOptions::default_instance());
#endif
}

OneofDescriptorProto::OneofDescriptorProto(const OneofDescriptorProto& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.OneofDescriptorProto)
}

void OneofDescriptorProto::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  options_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OneofDescriptorProto::~OneofDescriptorProto() {
  // @@protoc_insertion_point(destructor:perfetto.protos.OneofDescriptorProto)
  SharedDtor();
}

void OneofDescriptorProto::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete options_;
  }
}

void OneofDescriptorProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const OneofDescriptorProto& OneofDescriptorProto::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fcommon_2fdescriptor_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fcommon_2fdescriptor_2eproto();
#endif
  return *default_instance_;
}

OneofDescriptorProto* OneofDescriptorProto::default_instance_ = NULL;

OneofDescriptorProto* OneofDescriptorProto::New(::google::protobuf::Arena* arena) const {
  OneofDescriptorProto* n = new OneofDescriptorProto;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void OneofDescriptorProto::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.OneofDescriptorProto)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_name()) {
      name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_options()) {
      if (options_ != NULL) options_->::perfetto::protos::OneofOptions::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool OneofDescriptorProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForOneofDescriptorProto, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.OneofDescriptorProto)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_options;
        break;
      }

      // optional .perfetto.protos.OneofOptions options = 2;
      case 2: {
        if (tag == 18) {
         parse_options:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_options()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.OneofDescriptorProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.OneofDescriptorProto)
  return false;
#undef DO_
}

void OneofDescriptorProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.OneofDescriptorProto)
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional .perfetto.protos.OneofOptions options = 2;
  if (has_options()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *this->options_, output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.OneofDescriptorProto)
}

int OneofDescriptorProto::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.OneofDescriptorProto)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional .perfetto.protos.OneofOptions options = 2;
    if (has_options()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->options_);
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OneofDescriptorProto::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const OneofDescriptorProto*>(&from));
}

void OneofDescriptorProto::MergeFrom(const OneofDescriptorProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.OneofDescriptorProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) descriptor_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (from.has_options()) {
      mutable_options()->::perfetto::protos::OneofOptions::MergeFrom(from.options());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void OneofDescriptorProto::CopyFrom(const OneofDescriptorProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.OneofDescriptorProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OneofDescriptorProto::IsInitialized() const {

  if (has_options()) {
    if (!this->options_->IsInitialized()) return false;
  }
  return true;
}

void OneofDescriptorProto::Swap(OneofDescriptorProto* other) {
  if (other == this) return;
  InternalSwap(other);
}
void OneofDescriptorProto::InternalSwap(OneofDescriptorProto* other) {
  name_.Swap(&other->name_);
  std::swap(options_, other->options_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string OneofDescriptorProto::GetTypeName() const {
  return "perfetto.protos.OneofDescriptorProto";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// OneofDescriptorProto

// optional string name = 1;
bool OneofDescriptorProto::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void OneofDescriptorProto::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
void OneofDescriptorProto::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void OneofDescriptorProto::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
 const ::std::string& OneofDescriptorProto::name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.OneofDescriptorProto.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void OneofDescriptorProto::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.OneofDescriptorProto.name)
}
 void OneofDescriptorProto::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.OneofDescriptorProto.name)
}
 void OneofDescriptorProto::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.OneofDescriptorProto.name)
}
 ::std::string* OneofDescriptorProto::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.OneofDescriptorProto.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* OneofDescriptorProto::release_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.OneofDescriptorProto.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void OneofDescriptorProto::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.OneofDescriptorProto.name)
}

// optional .perfetto.protos.OneofOptions options = 2;
bool OneofDescriptorProto::has_options() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void OneofDescriptorProto::set_has_options() {
  _has_bits_[0] |= 0x00000002u;
}
void OneofDescriptorProto::clear_has_options() {
  _has_bits_[0] &= ~0x00000002u;
}
void OneofDescriptorProto::clear_options() {
  if (options_ != NULL) options_->::perfetto::protos::OneofOptions::Clear();
  clear_has_options();
}
const ::perfetto::protos::OneofOptions& OneofDescriptorProto::options() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.OneofDescriptorProto.options)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return options_ != NULL ? *options_ : *default_instance().options_;
#else
  return options_ != NULL ? *options_ : *default_instance_->options_;
#endif
}
::perfetto::protos::OneofOptions* OneofDescriptorProto::mutable_options() {
  set_has_options();
  if (options_ == NULL) {
    options_ = new ::perfetto::protos::OneofOptions;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.OneofDescriptorProto.options)
  return options_;
}
::perfetto::protos::OneofOptions* OneofDescriptorProto::release_options() {
  // @@protoc_insertion_point(field_release:perfetto.protos.OneofDescriptorProto.options)
  clear_has_options();
  ::perfetto::protos::OneofOptions* temp = options_;
  options_ = NULL;
  return temp;
}
void OneofDescriptorProto::set_allocated_options(::perfetto::protos::OneofOptions* options) {
  delete options_;
  options_ = options;
  if (options) {
    set_has_options();
  } else {
    clear_has_options();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.OneofDescriptorProto.options)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForEnumDescriptorProto(
    EnumDescriptorProto* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EnumDescriptorProto::kNameFieldNumber;
const int EnumDescriptorProto::kValueFieldNumber;
const int EnumDescriptorProto::kReservedNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EnumDescriptorProto::EnumDescriptorProto()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.EnumDescriptorProto)
}

void EnumDescriptorProto::InitAsDefaultInstance() {
}

EnumDescriptorProto::EnumDescriptorProto(const EnumDescriptorProto& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.EnumDescriptorProto)
}

void EnumDescriptorProto::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EnumDescriptorProto::~EnumDescriptorProto() {
  // @@protoc_insertion_point(destructor:perfetto.protos.EnumDescriptorProto)
  SharedDtor();
}

void EnumDescriptorProto::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void EnumDescriptorProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const EnumDescriptorProto& EnumDescriptorProto::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fcommon_2fdescriptor_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fcommon_2fdescriptor_2eproto();
#endif
  return *default_instance_;
}

EnumDescriptorProto* EnumDescriptorProto::default_instance_ = NULL;

EnumDescriptorProto* EnumDescriptorProto::New(::google::protobuf::Arena* arena) const {
  EnumDescriptorProto* n = new EnumDescriptorProto;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void EnumDescriptorProto::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.EnumDescriptorProto)
  if (has_name()) {
    name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.Clear();
  reserved_name_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool EnumDescriptorProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForEnumDescriptorProto, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.EnumDescriptorProto)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_value;
        break;
      }

      // repeated .perfetto.protos.EnumValueDescriptorProto value = 2;
      case 2: {
        if (tag == 18) {
         parse_value:
          DO_(input->IncrementRecursionDepth());
         parse_loop_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_value;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(42)) goto parse_reserved_name;
        break;
      }

      // repeated string reserved_name = 5;
      case 5: {
        if (tag == 42) {
         parse_reserved_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_reserved_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_reserved_name;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.EnumDescriptorProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.EnumDescriptorProto)
  return false;
#undef DO_
}

void EnumDescriptorProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.EnumDescriptorProto)
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // repeated .perfetto.protos.EnumValueDescriptorProto value = 2;
  for (unsigned int i = 0, n = this->value_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->value(i), output);
  }

  // repeated string reserved_name = 5;
  for (int i = 0; i < this->reserved_name_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->reserved_name(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.EnumDescriptorProto)
}

int EnumDescriptorProto::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.EnumDescriptorProto)
  int total_size = 0;

  // optional string name = 1;
  if (has_name()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }

  // repeated .perfetto.protos.EnumValueDescriptorProto value = 2;
  total_size += 1 * this->value_size();
  for (int i = 0; i < this->value_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->value(i));
  }

  // repeated string reserved_name = 5;
  total_size += 1 * this->reserved_name_size();
  for (int i = 0; i < this->reserved_name_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->reserved_name(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EnumDescriptorProto::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const EnumDescriptorProto*>(&from));
}

void EnumDescriptorProto::MergeFrom(const EnumDescriptorProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.EnumDescriptorProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) descriptor_pb_MergeFromFail(__LINE__);
  value_.MergeFrom(from.value_);
  reserved_name_.MergeFrom(from.reserved_name_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void EnumDescriptorProto::CopyFrom(const EnumDescriptorProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.EnumDescriptorProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EnumDescriptorProto::IsInitialized() const {

  return true;
}

void EnumDescriptorProto::Swap(EnumDescriptorProto* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EnumDescriptorProto::InternalSwap(EnumDescriptorProto* other) {
  name_.Swap(&other->name_);
  value_.UnsafeArenaSwap(&other->value_);
  reserved_name_.UnsafeArenaSwap(&other->reserved_name_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string EnumDescriptorProto::GetTypeName() const {
  return "perfetto.protos.EnumDescriptorProto";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// EnumDescriptorProto

// optional string name = 1;
bool EnumDescriptorProto::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void EnumDescriptorProto::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
void EnumDescriptorProto::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void EnumDescriptorProto::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
 const ::std::string& EnumDescriptorProto::name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.EnumDescriptorProto.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void EnumDescriptorProto::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.EnumDescriptorProto.name)
}
 void EnumDescriptorProto::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.EnumDescriptorProto.name)
}
 void EnumDescriptorProto::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.EnumDescriptorProto.name)
}
 ::std::string* EnumDescriptorProto::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.EnumDescriptorProto.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* EnumDescriptorProto::release_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.EnumDescriptorProto.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void EnumDescriptorProto::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.EnumDescriptorProto.name)
}

// repeated .perfetto.protos.EnumValueDescriptorProto value = 2;
int EnumDescriptorProto::value_size() const {
  return value_.size();
}
void EnumDescriptorProto::clear_value() {
  value_.Clear();
}
const ::perfetto::protos::EnumValueDescriptorProto& EnumDescriptorProto::value(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.EnumDescriptorProto.value)
  return value_.Get(index);
}
::perfetto::protos::EnumValueDescriptorProto* EnumDescriptorProto::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.EnumDescriptorProto.value)
  return value_.Mutable(index);
}
::perfetto::protos::EnumValueDescriptorProto* EnumDescriptorProto::add_value() {
  // @@protoc_insertion_point(field_add:perfetto.protos.EnumDescriptorProto.value)
  return value_.Add();
}
::google::protobuf::RepeatedPtrField< ::perfetto::protos::EnumValueDescriptorProto >*
EnumDescriptorProto::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.EnumDescriptorProto.value)
  return &value_;
}
const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::EnumValueDescriptorProto >&
EnumDescriptorProto::value() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.EnumDescriptorProto.value)
  return value_;
}

// repeated string reserved_name = 5;
int EnumDescriptorProto::reserved_name_size() const {
  return reserved_name_.size();
}
void EnumDescriptorProto::clear_reserved_name() {
  reserved_name_.Clear();
}
 const ::std::string& EnumDescriptorProto::reserved_name(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.EnumDescriptorProto.reserved_name)
  return reserved_name_.Get(index);
}
 ::std::string* EnumDescriptorProto::mutable_reserved_name(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.EnumDescriptorProto.reserved_name)
  return reserved_name_.Mutable(index);
}
 void EnumDescriptorProto::set_reserved_name(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.EnumDescriptorProto.reserved_name)
  reserved_name_.Mutable(index)->assign(value);
}
 void EnumDescriptorProto::set_reserved_name(int index, const char* value) {
  reserved_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.EnumDescriptorProto.reserved_name)
}
 void EnumDescriptorProto::set_reserved_name(int index, const char* value, size_t size) {
  reserved_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.EnumDescriptorProto.reserved_name)
}
 ::std::string* EnumDescriptorProto::add_reserved_name() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.EnumDescriptorProto.reserved_name)
  return reserved_name_.Add();
}
 void EnumDescriptorProto::add_reserved_name(const ::std::string& value) {
  reserved_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.EnumDescriptorProto.reserved_name)
}
 void EnumDescriptorProto::add_reserved_name(const char* value) {
  reserved_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.EnumDescriptorProto.reserved_name)
}
 void EnumDescriptorProto::add_reserved_name(const char* value, size_t size) {
  reserved_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.EnumDescriptorProto.reserved_name)
}
 const ::google::protobuf::RepeatedPtrField< ::std::string>&
EnumDescriptorProto::reserved_name() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.EnumDescriptorProto.reserved_name)
  return reserved_name_;
}
 ::google::protobuf::RepeatedPtrField< ::std::string>*
EnumDescriptorProto::mutable_reserved_name() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.EnumDescriptorProto.reserved_name)
  return &reserved_name_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForEnumValueDescriptorProto(
    EnumValueDescriptorProto* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EnumValueDescriptorProto::kNameFieldNumber;
const int EnumValueDescriptorProto::kNumberFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EnumValueDescriptorProto::EnumValueDescriptorProto()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.EnumValueDescriptorProto)
}

void EnumValueDescriptorProto::InitAsDefaultInstance() {
}

EnumValueDescriptorProto::EnumValueDescriptorProto(const EnumValueDescriptorProto& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.EnumValueDescriptorProto)
}

void EnumValueDescriptorProto::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  number_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EnumValueDescriptorProto::~EnumValueDescriptorProto() {
  // @@protoc_insertion_point(destructor:perfetto.protos.EnumValueDescriptorProto)
  SharedDtor();
}

void EnumValueDescriptorProto::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void EnumValueDescriptorProto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const EnumValueDescriptorProto& EnumValueDescriptorProto::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fcommon_2fdescriptor_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fcommon_2fdescriptor_2eproto();
#endif
  return *default_instance_;
}

EnumValueDescriptorProto* EnumValueDescriptorProto::default_instance_ = NULL;

EnumValueDescriptorProto* EnumValueDescriptorProto::New(::google::protobuf::Arena* arena) const {
  EnumValueDescriptorProto* n = new EnumValueDescriptorProto;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void EnumValueDescriptorProto::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.EnumValueDescriptorProto)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_name()) {
      name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    number_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool EnumValueDescriptorProto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForEnumValueDescriptorProto, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.EnumValueDescriptorProto)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_number;
        break;
      }

      // optional int32 number = 2;
      case 2: {
        if (tag == 16) {
         parse_number:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &number_)));
          set_has_number();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.EnumValueDescriptorProto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.EnumValueDescriptorProto)
  return false;
#undef DO_
}

void EnumValueDescriptorProto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.EnumValueDescriptorProto)
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional int32 number = 2;
  if (has_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->number(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.EnumValueDescriptorProto)
}

int EnumValueDescriptorProto::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.EnumValueDescriptorProto)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional int32 number = 2;
    if (has_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->number());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EnumValueDescriptorProto::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const EnumValueDescriptorProto*>(&from));
}

void EnumValueDescriptorProto::MergeFrom(const EnumValueDescriptorProto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.EnumValueDescriptorProto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) descriptor_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (from.has_number()) {
      set_number(from.number());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void EnumValueDescriptorProto::CopyFrom(const EnumValueDescriptorProto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.EnumValueDescriptorProto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EnumValueDescriptorProto::IsInitialized() const {

  return true;
}

void EnumValueDescriptorProto::Swap(EnumValueDescriptorProto* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EnumValueDescriptorProto::InternalSwap(EnumValueDescriptorProto* other) {
  name_.Swap(&other->name_);
  std::swap(number_, other->number_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string EnumValueDescriptorProto::GetTypeName() const {
  return "perfetto.protos.EnumValueDescriptorProto";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// EnumValueDescriptorProto

// optional string name = 1;
bool EnumValueDescriptorProto::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void EnumValueDescriptorProto::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
void EnumValueDescriptorProto::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void EnumValueDescriptorProto::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
 const ::std::string& EnumValueDescriptorProto::name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.EnumValueDescriptorProto.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void EnumValueDescriptorProto::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.EnumValueDescriptorProto.name)
}
 void EnumValueDescriptorProto::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.EnumValueDescriptorProto.name)
}
 void EnumValueDescriptorProto::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.EnumValueDescriptorProto.name)
}
 ::std::string* EnumValueDescriptorProto::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.EnumValueDescriptorProto.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* EnumValueDescriptorProto::release_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.EnumValueDescriptorProto.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void EnumValueDescriptorProto::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.EnumValueDescriptorProto.name)
}

// optional int32 number = 2;
bool EnumValueDescriptorProto::has_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void EnumValueDescriptorProto::set_has_number() {
  _has_bits_[0] |= 0x00000002u;
}
void EnumValueDescriptorProto::clear_has_number() {
  _has_bits_[0] &= ~0x00000002u;
}
void EnumValueDescriptorProto::clear_number() {
  number_ = 0;
  clear_has_number();
}
 ::google::protobuf::int32 EnumValueDescriptorProto::number() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.EnumValueDescriptorProto.number)
  return number_;
}
 void EnumValueDescriptorProto::set_number(::google::protobuf::int32 value) {
  set_has_number();
  number_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.EnumValueDescriptorProto.number)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForOneofOptions(
    OneofOptions* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

OneofOptions::OneofOptions()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.OneofOptions)
}

void OneofOptions::InitAsDefaultInstance() {
}

OneofOptions::OneofOptions(const OneofOptions& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.OneofOptions)
}

void OneofOptions::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OneofOptions::~OneofOptions() {
  // @@protoc_insertion_point(destructor:perfetto.protos.OneofOptions)
  SharedDtor();
}

void OneofOptions::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void OneofOptions::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const OneofOptions& OneofOptions::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fcommon_2fdescriptor_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fcommon_2fdescriptor_2eproto();
#endif
  return *default_instance_;
}

OneofOptions* OneofOptions::default_instance_ = NULL;

OneofOptions* OneofOptions::New(::google::protobuf::Arena* arena) const {
  OneofOptions* n = new OneofOptions;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void OneofOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.OneofOptions)
  _extensions_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool OneofOptions::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForOneofOptions, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.OneofOptions)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    if ((8000u <= tag)) {
    #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
      DO_(_extensions_.ParseField(tag, input, &default_instance(),
                                  &unknown_fields_stream));
    #else
      DO_(_extensions_.ParseField(tag, input, default_instance_,
                                  &unknown_fields_stream));
    #endif
      continue;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.OneofOptions)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.OneofOptions)
  return false;
#undef DO_
}

void OneofOptions::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.OneofOptions)
  // Extension range [1000, 536870912)
  _extensions_.SerializeWithCachedSizes(
      1000, 536870912, output);

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.OneofOptions)
}

int OneofOptions::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.OneofOptions)
  int total_size = 0;

  total_size += _extensions_.ByteSize();

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OneofOptions::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const OneofOptions*>(&from));
}

void OneofOptions::MergeFrom(const OneofOptions& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.OneofOptions)
  if (GOOGLE_PREDICT_FALSE(&from == this)) descriptor_pb_MergeFromFail(__LINE__);
  _extensions_.MergeFrom(from._extensions_);
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void OneofOptions::CopyFrom(const OneofOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.OneofOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OneofOptions::IsInitialized() const {


  if (!_extensions_.IsInitialized()) return false;  return true;
}

void OneofOptions::Swap(OneofOptions* other) {
  if (other == this) return;
  InternalSwap(other);
}
void OneofOptions::InternalSwap(OneofOptions* other) {
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
  _extensions_.Swap(&other->_extensions_);
}

::std::string OneofOptions::GetTypeName() const {
  return "perfetto.protos.OneofOptions";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// OneofOptions

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/common/gpu_counter_descriptor.pb.cc
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/common/gpu_counter_descriptor.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
// gen_amalgamated expanded: #include "perfetto/common/gpu_counter_descriptor.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

void protobuf_ShutdownFile_perfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto() {
  delete GpuCounterDescriptor::default_instance_;
  delete GpuCounterDescriptor_GpuCounterSpec::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_perfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_perfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  GpuCounterDescriptor::default_instance_ = new GpuCounterDescriptor();
  GpuCounterDescriptor_GpuCounterSpec::default_instance_ = new GpuCounterDescriptor_GpuCounterSpec();
  GpuCounterDescriptor::default_instance_->InitAsDefaultInstance();
  GpuCounterDescriptor_GpuCounterSpec::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_perfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_perfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto_once_);
void protobuf_AddDesc_perfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_perfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto_once_,
                 &protobuf_AddDesc_perfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_perfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto {
  StaticDescriptorInitializer_perfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto() {
    protobuf_AddDesc_perfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto();
  }
} static_descriptor_initializer_perfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto_;
#endif

namespace {

static void gpu_counter_descriptor_pb_MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
static void gpu_counter_descriptor_pb_MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

static ::std::string* MutableUnknownFieldsForGpuCounterDescriptor(
    GpuCounterDescriptor* ptr) {
  return ptr->mutable_unknown_fields();
}

static ::std::string* MutableUnknownFieldsForGpuCounterDescriptor_GpuCounterSpec(
    GpuCounterDescriptor_GpuCounterSpec* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GpuCounterDescriptor_GpuCounterSpec::kCounterIdFieldNumber;
const int GpuCounterDescriptor_GpuCounterSpec::kNameFieldNumber;
const int GpuCounterDescriptor_GpuCounterSpec::kDescriptionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GpuCounterDescriptor_GpuCounterSpec::GpuCounterDescriptor_GpuCounterSpec()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec)
}

void GpuCounterDescriptor_GpuCounterSpec::InitAsDefaultInstance() {
}

GpuCounterDescriptor_GpuCounterSpec::GpuCounterDescriptor_GpuCounterSpec(const GpuCounterDescriptor_GpuCounterSpec& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec)
}

void GpuCounterDescriptor_GpuCounterSpec::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  counter_id_ = 0u;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  description_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GpuCounterDescriptor_GpuCounterSpec::~GpuCounterDescriptor_GpuCounterSpec() {
  // @@protoc_insertion_point(destructor:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec)
  SharedDtor();
}

void GpuCounterDescriptor_GpuCounterSpec::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  description_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GpuCounterDescriptor_GpuCounterSpec::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GpuCounterDescriptor_GpuCounterSpec& GpuCounterDescriptor_GpuCounterSpec::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto();
#endif
  return *default_instance_;
}

GpuCounterDescriptor_GpuCounterSpec* GpuCounterDescriptor_GpuCounterSpec::default_instance_ = NULL;

GpuCounterDescriptor_GpuCounterSpec* GpuCounterDescriptor_GpuCounterSpec::New(::google::protobuf::Arena* arena) const {
  GpuCounterDescriptor_GpuCounterSpec* n = new GpuCounterDescriptor_GpuCounterSpec;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GpuCounterDescriptor_GpuCounterSpec::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec)
  if (_has_bits_[0 / 32] & 7u) {
    counter_id_ = 0u;
    if (has_name()) {
      name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_description()) {
      description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool GpuCounterDescriptor_GpuCounterSpec::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForGpuCounterDescriptor_GpuCounterSpec, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 counter_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &counter_id_)));
          set_has_counter_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // optional string name = 2;
      case 2: {
        if (tag == 18) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_description;
        break;
      }

      // optional string description = 3;
      case 3: {
        if (tag == 26) {
         parse_description:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_description()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec)
  return false;
#undef DO_
}

void GpuCounterDescriptor_GpuCounterSpec::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec)
  // optional uint32 counter_id = 1;
  if (has_counter_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->counter_id(), output);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->name(), output);
  }

  // optional string description = 3;
  if (has_description()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->description(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec)
}

int GpuCounterDescriptor_GpuCounterSpec::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 7u) {
    // optional uint32 counter_id = 1;
    if (has_counter_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->counter_id());
    }

    // optional string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional string description = 3;
    if (has_description()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->description());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GpuCounterDescriptor_GpuCounterSpec::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GpuCounterDescriptor_GpuCounterSpec*>(&from));
}

void GpuCounterDescriptor_GpuCounterSpec::MergeFrom(const GpuCounterDescriptor_GpuCounterSpec& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec)
  if (GOOGLE_PREDICT_FALSE(&from == this)) gpu_counter_descriptor_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_counter_id()) {
      set_counter_id(from.counter_id());
    }
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (from.has_description()) {
      set_has_description();
      description_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.description_);
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void GpuCounterDescriptor_GpuCounterSpec::CopyFrom(const GpuCounterDescriptor_GpuCounterSpec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GpuCounterDescriptor_GpuCounterSpec::IsInitialized() const {

  return true;
}

void GpuCounterDescriptor_GpuCounterSpec::Swap(GpuCounterDescriptor_GpuCounterSpec* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GpuCounterDescriptor_GpuCounterSpec::InternalSwap(GpuCounterDescriptor_GpuCounterSpec* other) {
  std::swap(counter_id_, other->counter_id_);
  name_.Swap(&other->name_);
  description_.Swap(&other->description_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string GpuCounterDescriptor_GpuCounterSpec::GetTypeName() const {
  return "perfetto.protos.GpuCounterDescriptor.GpuCounterSpec";
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GpuCounterDescriptor::kSpecsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GpuCounterDescriptor::GpuCounterDescriptor()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.GpuCounterDescriptor)
}

void GpuCounterDescriptor::InitAsDefaultInstance() {
}

GpuCounterDescriptor::GpuCounterDescriptor(const GpuCounterDescriptor& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.GpuCounterDescriptor)
}

void GpuCounterDescriptor::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GpuCounterDescriptor::~GpuCounterDescriptor() {
  // @@protoc_insertion_point(destructor:perfetto.protos.GpuCounterDescriptor)
  SharedDtor();
}

void GpuCounterDescriptor::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GpuCounterDescriptor::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GpuCounterDescriptor& GpuCounterDescriptor::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fcommon_2fgpu_5fcounter_5fdescriptor_2eproto();
#endif
  return *default_instance_;
}

GpuCounterDescriptor* GpuCounterDescriptor::default_instance_ = NULL;

GpuCounterDescriptor* GpuCounterDescriptor::New(::google::protobuf::Arena* arena) const {
  GpuCounterDescriptor* n = new GpuCounterDescriptor;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GpuCounterDescriptor::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.GpuCounterDescriptor)
  specs_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool GpuCounterDescriptor::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForGpuCounterDescriptor, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.GpuCounterDescriptor)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .perfetto.protos.GpuCounterDescriptor.GpuCounterSpec specs = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_specs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_specs()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_specs;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.GpuCounterDescriptor)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.GpuCounterDescriptor)
  return false;
#undef DO_
}

void GpuCounterDescriptor::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.GpuCounterDescriptor)
  // repeated .perfetto.protos.GpuCounterDescriptor.GpuCounterSpec specs = 1;
  for (unsigned int i = 0, n = this->specs_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->specs(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.GpuCounterDescriptor)
}

int GpuCounterDescriptor::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.GpuCounterDescriptor)
  int total_size = 0;

  // repeated .perfetto.protos.GpuCounterDescriptor.GpuCounterSpec specs = 1;
  total_size += 1 * this->specs_size();
  for (int i = 0; i < this->specs_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->specs(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GpuCounterDescriptor::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GpuCounterDescriptor*>(&from));
}

void GpuCounterDescriptor::MergeFrom(const GpuCounterDescriptor& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.GpuCounterDescriptor)
  if (GOOGLE_PREDICT_FALSE(&from == this)) gpu_counter_descriptor_pb_MergeFromFail(__LINE__);
  specs_.MergeFrom(from.specs_);
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void GpuCounterDescriptor::CopyFrom(const GpuCounterDescriptor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.GpuCounterDescriptor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GpuCounterDescriptor::IsInitialized() const {

  return true;
}

void GpuCounterDescriptor::Swap(GpuCounterDescriptor* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GpuCounterDescriptor::InternalSwap(GpuCounterDescriptor* other) {
  specs_.UnsafeArenaSwap(&other->specs_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string GpuCounterDescriptor::GetTypeName() const {
  return "perfetto.protos.GpuCounterDescriptor";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// GpuCounterDescriptor_GpuCounterSpec

// optional uint32 counter_id = 1;
bool GpuCounterDescriptor_GpuCounterSpec::has_counter_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void GpuCounterDescriptor_GpuCounterSpec::set_has_counter_id() {
  _has_bits_[0] |= 0x00000001u;
}
void GpuCounterDescriptor_GpuCounterSpec::clear_has_counter_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void GpuCounterDescriptor_GpuCounterSpec::clear_counter_id() {
  counter_id_ = 0u;
  clear_has_counter_id();
}
 ::google::protobuf::uint32 GpuCounterDescriptor_GpuCounterSpec::counter_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.counter_id)
  return counter_id_;
}
 void GpuCounterDescriptor_GpuCounterSpec::set_counter_id(::google::protobuf::uint32 value) {
  set_has_counter_id();
  counter_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.counter_id)
}

// optional string name = 2;
bool GpuCounterDescriptor_GpuCounterSpec::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void GpuCounterDescriptor_GpuCounterSpec::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
void GpuCounterDescriptor_GpuCounterSpec::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
void GpuCounterDescriptor_GpuCounterSpec::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
 const ::std::string& GpuCounterDescriptor_GpuCounterSpec::name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GpuCounterDescriptor_GpuCounterSpec::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.name)
}
 void GpuCounterDescriptor_GpuCounterSpec::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.name)
}
 void GpuCounterDescriptor_GpuCounterSpec::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.name)
}
 ::std::string* GpuCounterDescriptor_GpuCounterSpec::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* GpuCounterDescriptor_GpuCounterSpec::release_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GpuCounterDescriptor_GpuCounterSpec::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.name)
}

// optional string description = 3;
bool GpuCounterDescriptor_GpuCounterSpec::has_description() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void GpuCounterDescriptor_GpuCounterSpec::set_has_description() {
  _has_bits_[0] |= 0x00000004u;
}
void GpuCounterDescriptor_GpuCounterSpec::clear_has_description() {
  _has_bits_[0] &= ~0x00000004u;
}
void GpuCounterDescriptor_GpuCounterSpec::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_description();
}
 const ::std::string& GpuCounterDescriptor_GpuCounterSpec::description() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.description)
  return description_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GpuCounterDescriptor_GpuCounterSpec::set_description(const ::std::string& value) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.description)
}
 void GpuCounterDescriptor_GpuCounterSpec::set_description(const char* value) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.description)
}
 void GpuCounterDescriptor_GpuCounterSpec::set_description(const char* value, size_t size) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.description)
}
 ::std::string* GpuCounterDescriptor_GpuCounterSpec::mutable_description() {
  set_has_description();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* GpuCounterDescriptor_GpuCounterSpec::release_description() {
  // @@protoc_insertion_point(field_release:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.description)
  clear_has_description();
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void GpuCounterDescriptor_GpuCounterSpec::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    set_has_description();
  } else {
    clear_has_description();
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.GpuCounterDescriptor.GpuCounterSpec.description)
}

// -------------------------------------------------------------------

// GpuCounterDescriptor

// repeated .perfetto.protos.GpuCounterDescriptor.GpuCounterSpec specs = 1;
int GpuCounterDescriptor::specs_size() const {
  return specs_.size();
}
void GpuCounterDescriptor::clear_specs() {
  specs_.Clear();
}
const ::perfetto::protos::GpuCounterDescriptor_GpuCounterSpec& GpuCounterDescriptor::specs(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterDescriptor.specs)
  return specs_.Get(index);
}
::perfetto::protos::GpuCounterDescriptor_GpuCounterSpec* GpuCounterDescriptor::mutable_specs(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GpuCounterDescriptor.specs)
  return specs_.Mutable(index);
}
::perfetto::protos::GpuCounterDescriptor_GpuCounterSpec* GpuCounterDescriptor::add_specs() {
  // @@protoc_insertion_point(field_add:perfetto.protos.GpuCounterDescriptor.specs)
  return specs_.Add();
}
::google::protobuf::RepeatedPtrField< ::perfetto::protos::GpuCounterDescriptor_GpuCounterSpec >*
GpuCounterDescriptor::mutable_specs() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.GpuCounterDescriptor.specs)
  return &specs_;
}
const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::GpuCounterDescriptor_GpuCounterSpec >&
GpuCounterDescriptor::specs() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.GpuCounterDescriptor.specs)
  return specs_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/common/observable_events.pb.cc
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/common/observable_events.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/common/observable_events.proto

#ifndef PROTOBUF_perfetto_2fcommon_2fobservable_5fevents_2eproto__INCLUDED
#define PROTOBUF_perfetto_2fcommon_2fobservable_5fevents_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_perfetto_2fcommon_2fobservable_5fevents_2eproto();
void protobuf_AssignDesc_perfetto_2fcommon_2fobservable_5fevents_2eproto();
void protobuf_ShutdownFile_perfetto_2fcommon_2fobservable_5fevents_2eproto();

class ObservableEvents;
class ObservableEvents_DataSourceInstanceStateChange;

enum ObservableEvents_Type {
  ObservableEvents_Type_TYPE_UNSPECIFIED = 0,
  ObservableEvents_Type_TYPE_DATA_SOURCES_INSTANCES = 1
};
bool ObservableEvents_Type_IsValid(int value);
const ObservableEvents_Type ObservableEvents_Type_Type_MIN = ObservableEvents_Type_TYPE_UNSPECIFIED;
const ObservableEvents_Type ObservableEvents_Type_Type_MAX = ObservableEvents_Type_TYPE_DATA_SOURCES_INSTANCES;
const int ObservableEvents_Type_Type_ARRAYSIZE = ObservableEvents_Type_Type_MAX + 1;

enum ObservableEvents_DataSourceInstanceState {
  ObservableEvents_DataSourceInstanceState_DATA_SOURCE_INSTANCE_STATE_STOPPED = 1,
  ObservableEvents_DataSourceInstanceState_DATA_SOURCE_INSTANCE_STATE_STARTED = 2
};
bool ObservableEvents_DataSourceInstanceState_IsValid(int value);
const ObservableEvents_DataSourceInstanceState ObservableEvents_DataSourceInstanceState_DataSourceInstanceState_MIN = ObservableEvents_DataSourceInstanceState_DATA_SOURCE_INSTANCE_STATE_STOPPED;
const ObservableEvents_DataSourceInstanceState ObservableEvents_DataSourceInstanceState_DataSourceInstanceState_MAX = ObservableEvents_DataSourceInstanceState_DATA_SOURCE_INSTANCE_STATE_STARTED;
const int ObservableEvents_DataSourceInstanceState_DataSourceInstanceState_ARRAYSIZE = ObservableEvents_DataSourceInstanceState_DataSourceInstanceState_MAX + 1;

// ===================================================================

class ObservableEvents_DataSourceInstanceStateChange : public ::google::protobuf::MessageLite {
 public:
  ObservableEvents_DataSourceInstanceStateChange();
  virtual ~ObservableEvents_DataSourceInstanceStateChange();

  ObservableEvents_DataSourceInstanceStateChange(const ObservableEvents_DataSourceInstanceStateChange& from);

  inline ObservableEvents_DataSourceInstanceStateChange& operator=(const ObservableEvents_DataSourceInstanceStateChange& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ObservableEvents_DataSourceInstanceStateChange& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ObservableEvents_DataSourceInstanceStateChange* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ObservableEvents_DataSourceInstanceStateChange* other);

  // implements Message ----------------------------------------------

  inline ObservableEvents_DataSourceInstanceStateChange* New() const { return New(NULL); }

  ObservableEvents_DataSourceInstanceStateChange* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ObservableEvents_DataSourceInstanceStateChange& from);
  void MergeFrom(const ObservableEvents_DataSourceInstanceStateChange& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ObservableEvents_DataSourceInstanceStateChange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string producer_name = 1;
  bool has_producer_name() const;
  void clear_producer_name();
  static const int kProducerNameFieldNumber = 1;
  const ::std::string& producer_name() const;
  void set_producer_name(const ::std::string& value);
  void set_producer_name(const char* value);
  void set_producer_name(const char* value, size_t size);
  ::std::string* mutable_producer_name();
  ::std::string* release_producer_name();
  void set_allocated_producer_name(::std::string* producer_name);

  // optional string data_source_name = 2;
  bool has_data_source_name() const;
  void clear_data_source_name();
  static const int kDataSourceNameFieldNumber = 2;
  const ::std::string& data_source_name() const;
  void set_data_source_name(const ::std::string& value);
  void set_data_source_name(const char* value);
  void set_data_source_name(const char* value, size_t size);
  ::std::string* mutable_data_source_name();
  ::std::string* release_data_source_name();
  void set_allocated_data_source_name(::std::string* data_source_name);

  // optional .perfetto.protos.ObservableEvents.DataSourceInstanceState state = 3;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 3;
  ::perfetto::protos::ObservableEvents_DataSourceInstanceState state() const;
  void set_state(::perfetto::protos::ObservableEvents_DataSourceInstanceState value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange)
 private:
  inline void set_has_producer_name();
  inline void clear_has_producer_name();
  inline void set_has_data_source_name();
  inline void clear_has_data_source_name();
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr producer_name_;
  ::google::protobuf::internal::ArenaStringPtr data_source_name_;
  int state_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fcommon_2fobservable_5fevents_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fcommon_2fobservable_5fevents_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fcommon_2fobservable_5fevents_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fcommon_2fobservable_5fevents_2eproto();

  void InitAsDefaultInstance();
  static ObservableEvents_DataSourceInstanceStateChange* default_instance_;
};
// -------------------------------------------------------------------

class ObservableEvents : public ::google::protobuf::MessageLite {
 public:
  ObservableEvents();
  virtual ~ObservableEvents();

  ObservableEvents(const ObservableEvents& from);

  inline ObservableEvents& operator=(const ObservableEvents& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ObservableEvents& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ObservableEvents* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ObservableEvents* other);

  // implements Message ----------------------------------------------

  inline ObservableEvents* New() const { return New(NULL); }

  ObservableEvents* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ObservableEvents& from);
  void MergeFrom(const ObservableEvents& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ObservableEvents* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ObservableEvents_DataSourceInstanceStateChange DataSourceInstanceStateChange;

  typedef ObservableEvents_Type Type;
  static const Type TYPE_UNSPECIFIED =
    ObservableEvents_Type_TYPE_UNSPECIFIED;
  static const Type TYPE_DATA_SOURCES_INSTANCES =
    ObservableEvents_Type_TYPE_DATA_SOURCES_INSTANCES;
  static inline bool Type_IsValid(int value) {
    return ObservableEvents_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ObservableEvents_Type_Type_MIN;
  static const Type Type_MAX =
    ObservableEvents_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ObservableEvents_Type_Type_ARRAYSIZE;

  typedef ObservableEvents_DataSourceInstanceState DataSourceInstanceState;
  static const DataSourceInstanceState DATA_SOURCE_INSTANCE_STATE_STOPPED =
    ObservableEvents_DataSourceInstanceState_DATA_SOURCE_INSTANCE_STATE_STOPPED;
  static const DataSourceInstanceState DATA_SOURCE_INSTANCE_STATE_STARTED =
    ObservableEvents_DataSourceInstanceState_DATA_SOURCE_INSTANCE_STATE_STARTED;
  static inline bool DataSourceInstanceState_IsValid(int value) {
    return ObservableEvents_DataSourceInstanceState_IsValid(value);
  }
  static const DataSourceInstanceState DataSourceInstanceState_MIN =
    ObservableEvents_DataSourceInstanceState_DataSourceInstanceState_MIN;
  static const DataSourceInstanceState DataSourceInstanceState_MAX =
    ObservableEvents_DataSourceInstanceState_DataSourceInstanceState_MAX;
  static const int DataSourceInstanceState_ARRAYSIZE =
    ObservableEvents_DataSourceInstanceState_DataSourceInstanceState_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .perfetto.protos.ObservableEvents.DataSourceInstanceStateChange instance_state_changes = 1;
  int instance_state_changes_size() const;
  void clear_instance_state_changes();
  static const int kInstanceStateChangesFieldNumber = 1;
  const ::perfetto::protos::ObservableEvents_DataSourceInstanceStateChange& instance_state_changes(int index) const;
  ::perfetto::protos::ObservableEvents_DataSourceInstanceStateChange* mutable_instance_state_changes(int index);
  ::perfetto::protos::ObservableEvents_DataSourceInstanceStateChange* add_instance_state_changes();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::ObservableEvents_DataSourceInstanceStateChange >*
      mutable_instance_state_changes();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::ObservableEvents_DataSourceInstanceStateChange >&
      instance_state_changes() const;

  // @@protoc_insertion_point(class_scope:perfetto.protos.ObservableEvents)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::ObservableEvents_DataSourceInstanceStateChange > instance_state_changes_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fcommon_2fobservable_5fevents_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fcommon_2fobservable_5fevents_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fcommon_2fobservable_5fevents_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fcommon_2fobservable_5fevents_2eproto();

  void InitAsDefaultInstance();
  static ObservableEvents* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// ObservableEvents_DataSourceInstanceStateChange

// optional string producer_name = 1;
inline bool ObservableEvents_DataSourceInstanceStateChange::has_producer_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObservableEvents_DataSourceInstanceStateChange::set_has_producer_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ObservableEvents_DataSourceInstanceStateChange::clear_has_producer_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ObservableEvents_DataSourceInstanceStateChange::clear_producer_name() {
  producer_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_producer_name();
}
inline const ::std::string& ObservableEvents_DataSourceInstanceStateChange::producer_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.producer_name)
  return producer_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ObservableEvents_DataSourceInstanceStateChange::set_producer_name(const ::std::string& value) {
  set_has_producer_name();
  producer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.producer_name)
}
inline void ObservableEvents_DataSourceInstanceStateChange::set_producer_name(const char* value) {
  set_has_producer_name();
  producer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.producer_name)
}
inline void ObservableEvents_DataSourceInstanceStateChange::set_producer_name(const char* value, size_t size) {
  set_has_producer_name();
  producer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.producer_name)
}
inline ::std::string* ObservableEvents_DataSourceInstanceStateChange::mutable_producer_name() {
  set_has_producer_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.producer_name)
  return producer_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ObservableEvents_DataSourceInstanceStateChange::release_producer_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.producer_name)
  clear_has_producer_name();
  return producer_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ObservableEvents_DataSourceInstanceStateChange::set_allocated_producer_name(::std::string* producer_name) {
  if (producer_name != NULL) {
    set_has_producer_name();
  } else {
    clear_has_producer_name();
  }
  producer_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), producer_name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.producer_name)
}

// optional string data_source_name = 2;
inline bool ObservableEvents_DataSourceInstanceStateChange::has_data_source_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ObservableEvents_DataSourceInstanceStateChange::set_has_data_source_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ObservableEvents_DataSourceInstanceStateChange::clear_has_data_source_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ObservableEvents_DataSourceInstanceStateChange::clear_data_source_name() {
  data_source_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data_source_name();
}
inline const ::std::string& ObservableEvents_DataSourceInstanceStateChange::data_source_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.data_source_name)
  return data_source_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ObservableEvents_DataSourceInstanceStateChange::set_data_source_name(const ::std::string& value) {
  set_has_data_source_name();
  data_source_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.data_source_name)
}
inline void ObservableEvents_DataSourceInstanceStateChange::set_data_source_name(const char* value) {
  set_has_data_source_name();
  data_source_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.data_source_name)
}
inline void ObservableEvents_DataSourceInstanceStateChange::set_data_source_name(const char* value, size_t size) {
  set_has_data_source_name();
  data_source_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.data_source_name)
}
inline ::std::string* ObservableEvents_DataSourceInstanceStateChange::mutable_data_source_name() {
  set_has_data_source_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.data_source_name)
  return data_source_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ObservableEvents_DataSourceInstanceStateChange::release_data_source_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.data_source_name)
  clear_has_data_source_name();
  return data_source_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ObservableEvents_DataSourceInstanceStateChange::set_allocated_data_source_name(::std::string* data_source_name) {
  if (data_source_name != NULL) {
    set_has_data_source_name();
  } else {
    clear_has_data_source_name();
  }
  data_source_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data_source_name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.data_source_name)
}

// optional .perfetto.protos.ObservableEvents.DataSourceInstanceState state = 3;
inline bool ObservableEvents_DataSourceInstanceStateChange::has_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ObservableEvents_DataSourceInstanceStateChange::set_has_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ObservableEvents_DataSourceInstanceStateChange::clear_has_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ObservableEvents_DataSourceInstanceStateChange::clear_state() {
  state_ = 1;
  clear_has_state();
}
inline ::perfetto::protos::ObservableEvents_DataSourceInstanceState ObservableEvents_DataSourceInstanceStateChange::state() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.state)
  return static_cast< ::perfetto::protos::ObservableEvents_DataSourceInstanceState >(state_);
}
inline void ObservableEvents_DataSourceInstanceStateChange::set_state(::perfetto::protos::ObservableEvents_DataSourceInstanceState value) {
  assert(::perfetto::protos::ObservableEvents_DataSourceInstanceState_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.state)
}

// -------------------------------------------------------------------

// ObservableEvents

// repeated .perfetto.protos.ObservableEvents.DataSourceInstanceStateChange instance_state_changes = 1;
inline int ObservableEvents::instance_state_changes_size() const {
  return instance_state_changes_.size();
}
inline void ObservableEvents::clear_instance_state_changes() {
  instance_state_changes_.Clear();
}
inline const ::perfetto::protos::ObservableEvents_DataSourceInstanceStateChange& ObservableEvents::instance_state_changes(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ObservableEvents.instance_state_changes)
  return instance_state_changes_.Get(index);
}
inline ::perfetto::protos::ObservableEvents_DataSourceInstanceStateChange* ObservableEvents::mutable_instance_state_changes(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.ObservableEvents.instance_state_changes)
  return instance_state_changes_.Mutable(index);
}
inline ::perfetto::protos::ObservableEvents_DataSourceInstanceStateChange* ObservableEvents::add_instance_state_changes() {
  // @@protoc_insertion_point(field_add:perfetto.protos.ObservableEvents.instance_state_changes)
  return instance_state_changes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::ObservableEvents_DataSourceInstanceStateChange >*
ObservableEvents::mutable_instance_state_changes() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.ObservableEvents.instance_state_changes)
  return &instance_state_changes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::ObservableEvents_DataSourceInstanceStateChange >&
ObservableEvents::instance_state_changes() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.ObservableEvents.instance_state_changes)
  return instance_state_changes_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::perfetto::protos::ObservableEvents_Type> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::perfetto::protos::ObservableEvents_DataSourceInstanceState> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_perfetto_2fcommon_2fobservable_5fevents_2eproto__INCLUDED
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/common/observable_events.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
// gen_amalgamated expanded: #include "perfetto/common/observable_events.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

void protobuf_ShutdownFile_perfetto_2fcommon_2fobservable_5fevents_2eproto() {
  delete ObservableEvents::default_instance_;
  delete ObservableEvents_DataSourceInstanceStateChange::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_perfetto_2fcommon_2fobservable_5fevents_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_perfetto_2fcommon_2fobservable_5fevents_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ObservableEvents::default_instance_ = new ObservableEvents();
  ObservableEvents_DataSourceInstanceStateChange::default_instance_ = new ObservableEvents_DataSourceInstanceStateChange();
  ObservableEvents::default_instance_->InitAsDefaultInstance();
  ObservableEvents_DataSourceInstanceStateChange::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_perfetto_2fcommon_2fobservable_5fevents_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_perfetto_2fcommon_2fobservable_5fevents_2eproto_once_);
void protobuf_AddDesc_perfetto_2fcommon_2fobservable_5fevents_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_perfetto_2fcommon_2fobservable_5fevents_2eproto_once_,
                 &protobuf_AddDesc_perfetto_2fcommon_2fobservable_5fevents_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_perfetto_2fcommon_2fobservable_5fevents_2eproto {
  StaticDescriptorInitializer_perfetto_2fcommon_2fobservable_5fevents_2eproto() {
    protobuf_AddDesc_perfetto_2fcommon_2fobservable_5fevents_2eproto();
  }
} static_descriptor_initializer_perfetto_2fcommon_2fobservable_5fevents_2eproto_;
#endif

namespace {

static void observable_events_pb_MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
static void observable_events_pb_MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

static ::std::string* MutableUnknownFieldsForObservableEvents(
    ObservableEvents* ptr) {
  return ptr->mutable_unknown_fields();
}

bool ObservableEvents_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const ObservableEvents_Type ObservableEvents::TYPE_UNSPECIFIED;
const ObservableEvents_Type ObservableEvents::TYPE_DATA_SOURCES_INSTANCES;
const ObservableEvents_Type ObservableEvents::Type_MIN;
const ObservableEvents_Type ObservableEvents::Type_MAX;
const int ObservableEvents::Type_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
bool ObservableEvents_DataSourceInstanceState_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const ObservableEvents_DataSourceInstanceState ObservableEvents::DATA_SOURCE_INSTANCE_STATE_STOPPED;
const ObservableEvents_DataSourceInstanceState ObservableEvents::DATA_SOURCE_INSTANCE_STATE_STARTED;
const ObservableEvents_DataSourceInstanceState ObservableEvents::DataSourceInstanceState_MIN;
const ObservableEvents_DataSourceInstanceState ObservableEvents::DataSourceInstanceState_MAX;
const int ObservableEvents::DataSourceInstanceState_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
static ::std::string* MutableUnknownFieldsForObservableEvents_DataSourceInstanceStateChange(
    ObservableEvents_DataSourceInstanceStateChange* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ObservableEvents_DataSourceInstanceStateChange::kProducerNameFieldNumber;
const int ObservableEvents_DataSourceInstanceStateChange::kDataSourceNameFieldNumber;
const int ObservableEvents_DataSourceInstanceStateChange::kStateFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ObservableEvents_DataSourceInstanceStateChange::ObservableEvents_DataSourceInstanceStateChange()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange)
}

void ObservableEvents_DataSourceInstanceStateChange::InitAsDefaultInstance() {
}

ObservableEvents_DataSourceInstanceStateChange::ObservableEvents_DataSourceInstanceStateChange(const ObservableEvents_DataSourceInstanceStateChange& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange)
}

void ObservableEvents_DataSourceInstanceStateChange::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  producer_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  data_source_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  state_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ObservableEvents_DataSourceInstanceStateChange::~ObservableEvents_DataSourceInstanceStateChange() {
  // @@protoc_insertion_point(destructor:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange)
  SharedDtor();
}

void ObservableEvents_DataSourceInstanceStateChange::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  producer_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  data_source_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ObservableEvents_DataSourceInstanceStateChange::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ObservableEvents_DataSourceInstanceStateChange& ObservableEvents_DataSourceInstanceStateChange::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fcommon_2fobservable_5fevents_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fcommon_2fobservable_5fevents_2eproto();
#endif
  return *default_instance_;
}

ObservableEvents_DataSourceInstanceStateChange* ObservableEvents_DataSourceInstanceStateChange::default_instance_ = NULL;

ObservableEvents_DataSourceInstanceStateChange* ObservableEvents_DataSourceInstanceStateChange::New(::google::protobuf::Arena* arena) const {
  ObservableEvents_DataSourceInstanceStateChange* n = new ObservableEvents_DataSourceInstanceStateChange;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ObservableEvents_DataSourceInstanceStateChange::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange)
  if (_has_bits_[0 / 32] & 7u) {
    if (has_producer_name()) {
      producer_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_data_source_name()) {
      data_source_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    state_ = 1;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool ObservableEvents_DataSourceInstanceStateChange::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForObservableEvents_DataSourceInstanceStateChange, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string producer_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_producer_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_data_source_name;
        break;
      }

      // optional string data_source_name = 2;
      case 2: {
        if (tag == 18) {
         parse_data_source_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_data_source_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_state;
        break;
      }

      // optional .perfetto.protos.ObservableEvents.DataSourceInstanceState state = 3;
      case 3: {
        if (tag == 24) {
         parse_state:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::perfetto::protos::ObservableEvents_DataSourceInstanceState_IsValid(value)) {
            set_state(static_cast< ::perfetto::protos::ObservableEvents_DataSourceInstanceState >(value));
          } else {
            unknown_fields_stream.WriteVarint32(24);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange)
  return false;
#undef DO_
}

void ObservableEvents_DataSourceInstanceStateChange::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange)
  // optional string producer_name = 1;
  if (has_producer_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->producer_name(), output);
  }

  // optional string data_source_name = 2;
  if (has_data_source_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->data_source_name(), output);
  }

  // optional .perfetto.protos.ObservableEvents.DataSourceInstanceState state = 3;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->state(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange)
}

int ObservableEvents_DataSourceInstanceStateChange::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 7u) {
    // optional string producer_name = 1;
    if (has_producer_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->producer_name());
    }

    // optional string data_source_name = 2;
    if (has_data_source_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->data_source_name());
    }

    // optional .perfetto.protos.ObservableEvents.DataSourceInstanceState state = 3;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->state());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ObservableEvents_DataSourceInstanceStateChange::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ObservableEvents_DataSourceInstanceStateChange*>(&from));
}

void ObservableEvents_DataSourceInstanceStateChange::MergeFrom(const ObservableEvents_DataSourceInstanceStateChange& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange)
  if (GOOGLE_PREDICT_FALSE(&from == this)) observable_events_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_producer_name()) {
      set_has_producer_name();
      producer_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.producer_name_);
    }
    if (from.has_data_source_name()) {
      set_has_data_source_name();
      data_source_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.data_source_name_);
    }
    if (from.has_state()) {
      set_state(from.state());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void ObservableEvents_DataSourceInstanceStateChange::CopyFrom(const ObservableEvents_DataSourceInstanceStateChange& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObservableEvents_DataSourceInstanceStateChange::IsInitialized() const {

  return true;
}

void ObservableEvents_DataSourceInstanceStateChange::Swap(ObservableEvents_DataSourceInstanceStateChange* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ObservableEvents_DataSourceInstanceStateChange::InternalSwap(ObservableEvents_DataSourceInstanceStateChange* other) {
  producer_name_.Swap(&other->producer_name_);
  data_source_name_.Swap(&other->data_source_name_);
  std::swap(state_, other->state_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ObservableEvents_DataSourceInstanceStateChange::GetTypeName() const {
  return "perfetto.protos.ObservableEvents.DataSourceInstanceStateChange";
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ObservableEvents::kInstanceStateChangesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ObservableEvents::ObservableEvents()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.ObservableEvents)
}

void ObservableEvents::InitAsDefaultInstance() {
}

ObservableEvents::ObservableEvents(const ObservableEvents& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.ObservableEvents)
}

void ObservableEvents::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ObservableEvents::~ObservableEvents() {
  // @@protoc_insertion_point(destructor:perfetto.protos.ObservableEvents)
  SharedDtor();
}

void ObservableEvents::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ObservableEvents::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ObservableEvents& ObservableEvents::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fcommon_2fobservable_5fevents_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fcommon_2fobservable_5fevents_2eproto();
#endif
  return *default_instance_;
}

ObservableEvents* ObservableEvents::default_instance_ = NULL;

ObservableEvents* ObservableEvents::New(::google::protobuf::Arena* arena) const {
  ObservableEvents* n = new ObservableEvents;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ObservableEvents::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.ObservableEvents)
  instance_state_changes_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool ObservableEvents::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForObservableEvents, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.ObservableEvents)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .perfetto.protos.ObservableEvents.DataSourceInstanceStateChange instance_state_changes = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_instance_state_changes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_instance_state_changes()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_instance_state_changes;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.ObservableEvents)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.ObservableEvents)
  return false;
#undef DO_
}

void ObservableEvents::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.ObservableEvents)
  // repeated .perfetto.protos.ObservableEvents.DataSourceInstanceStateChange instance_state_changes = 1;
  for (unsigned int i = 0, n = this->instance_state_changes_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->instance_state_changes(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.ObservableEvents)
}

int ObservableEvents::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.ObservableEvents)
  int total_size = 0;

  // repeated .perfetto.protos.ObservableEvents.DataSourceInstanceStateChange instance_state_changes = 1;
  total_size += 1 * this->instance_state_changes_size();
  for (int i = 0; i < this->instance_state_changes_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->instance_state_changes(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ObservableEvents::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ObservableEvents*>(&from));
}

void ObservableEvents::MergeFrom(const ObservableEvents& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.ObservableEvents)
  if (GOOGLE_PREDICT_FALSE(&from == this)) observable_events_pb_MergeFromFail(__LINE__);
  instance_state_changes_.MergeFrom(from.instance_state_changes_);
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void ObservableEvents::CopyFrom(const ObservableEvents& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.ObservableEvents)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObservableEvents::IsInitialized() const {

  return true;
}

void ObservableEvents::Swap(ObservableEvents* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ObservableEvents::InternalSwap(ObservableEvents* other) {
  instance_state_changes_.UnsafeArenaSwap(&other->instance_state_changes_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ObservableEvents::GetTypeName() const {
  return "perfetto.protos.ObservableEvents";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ObservableEvents_DataSourceInstanceStateChange

// optional string producer_name = 1;
bool ObservableEvents_DataSourceInstanceStateChange::has_producer_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ObservableEvents_DataSourceInstanceStateChange::set_has_producer_name() {
  _has_bits_[0] |= 0x00000001u;
}
void ObservableEvents_DataSourceInstanceStateChange::clear_has_producer_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void ObservableEvents_DataSourceInstanceStateChange::clear_producer_name() {
  producer_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_producer_name();
}
 const ::std::string& ObservableEvents_DataSourceInstanceStateChange::producer_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.producer_name)
  return producer_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ObservableEvents_DataSourceInstanceStateChange::set_producer_name(const ::std::string& value) {
  set_has_producer_name();
  producer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.producer_name)
}
 void ObservableEvents_DataSourceInstanceStateChange::set_producer_name(const char* value) {
  set_has_producer_name();
  producer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.producer_name)
}
 void ObservableEvents_DataSourceInstanceStateChange::set_producer_name(const char* value, size_t size) {
  set_has_producer_name();
  producer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.producer_name)
}
 ::std::string* ObservableEvents_DataSourceInstanceStateChange::mutable_producer_name() {
  set_has_producer_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.producer_name)
  return producer_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ObservableEvents_DataSourceInstanceStateChange::release_producer_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.producer_name)
  clear_has_producer_name();
  return producer_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ObservableEvents_DataSourceInstanceStateChange::set_allocated_producer_name(::std::string* producer_name) {
  if (producer_name != NULL) {
    set_has_producer_name();
  } else {
    clear_has_producer_name();
  }
  producer_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), producer_name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.producer_name)
}

// optional string data_source_name = 2;
bool ObservableEvents_DataSourceInstanceStateChange::has_data_source_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ObservableEvents_DataSourceInstanceStateChange::set_has_data_source_name() {
  _has_bits_[0] |= 0x00000002u;
}
void ObservableEvents_DataSourceInstanceStateChange::clear_has_data_source_name() {
  _has_bits_[0] &= ~0x00000002u;
}
void ObservableEvents_DataSourceInstanceStateChange::clear_data_source_name() {
  data_source_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data_source_name();
}
 const ::std::string& ObservableEvents_DataSourceInstanceStateChange::data_source_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.data_source_name)
  return data_source_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ObservableEvents_DataSourceInstanceStateChange::set_data_source_name(const ::std::string& value) {
  set_has_data_source_name();
  data_source_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.data_source_name)
}
 void ObservableEvents_DataSourceInstanceStateChange::set_data_source_name(const char* value) {
  set_has_data_source_name();
  data_source_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.data_source_name)
}
 void ObservableEvents_DataSourceInstanceStateChange::set_data_source_name(const char* value, size_t size) {
  set_has_data_source_name();
  data_source_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.data_source_name)
}
 ::std::string* ObservableEvents_DataSourceInstanceStateChange::mutable_data_source_name() {
  set_has_data_source_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.data_source_name)
  return data_source_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ObservableEvents_DataSourceInstanceStateChange::release_data_source_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.data_source_name)
  clear_has_data_source_name();
  return data_source_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ObservableEvents_DataSourceInstanceStateChange::set_allocated_data_source_name(::std::string* data_source_name) {
  if (data_source_name != NULL) {
    set_has_data_source_name();
  } else {
    clear_has_data_source_name();
  }
  data_source_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data_source_name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.data_source_name)
}

// optional .perfetto.protos.ObservableEvents.DataSourceInstanceState state = 3;
bool ObservableEvents_DataSourceInstanceStateChange::has_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ObservableEvents_DataSourceInstanceStateChange::set_has_state() {
  _has_bits_[0] |= 0x00000004u;
}
void ObservableEvents_DataSourceInstanceStateChange::clear_has_state() {
  _has_bits_[0] &= ~0x00000004u;
}
void ObservableEvents_DataSourceInstanceStateChange::clear_state() {
  state_ = 1;
  clear_has_state();
}
 ::perfetto::protos::ObservableEvents_DataSourceInstanceState ObservableEvents_DataSourceInstanceStateChange::state() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.state)
  return static_cast< ::perfetto::protos::ObservableEvents_DataSourceInstanceState >(state_);
}
 void ObservableEvents_DataSourceInstanceStateChange::set_state(::perfetto::protos::ObservableEvents_DataSourceInstanceState value) {
  assert(::perfetto::protos::ObservableEvents_DataSourceInstanceState_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.ObservableEvents.DataSourceInstanceStateChange.state)
}

// -------------------------------------------------------------------

// ObservableEvents

// repeated .perfetto.protos.ObservableEvents.DataSourceInstanceStateChange instance_state_changes = 1;
int ObservableEvents::instance_state_changes_size() const {
  return instance_state_changes_.size();
}
void ObservableEvents::clear_instance_state_changes() {
  instance_state_changes_.Clear();
}
const ::perfetto::protos::ObservableEvents_DataSourceInstanceStateChange& ObservableEvents::instance_state_changes(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ObservableEvents.instance_state_changes)
  return instance_state_changes_.Get(index);
}
::perfetto::protos::ObservableEvents_DataSourceInstanceStateChange* ObservableEvents::mutable_instance_state_changes(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.ObservableEvents.instance_state_changes)
  return instance_state_changes_.Mutable(index);
}
::perfetto::protos::ObservableEvents_DataSourceInstanceStateChange* ObservableEvents::add_instance_state_changes() {
  // @@protoc_insertion_point(field_add:perfetto.protos.ObservableEvents.instance_state_changes)
  return instance_state_changes_.Add();
}
::google::protobuf::RepeatedPtrField< ::perfetto::protos::ObservableEvents_DataSourceInstanceStateChange >*
ObservableEvents::mutable_instance_state_changes() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.ObservableEvents.instance_state_changes)
  return &instance_state_changes_;
}
const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::ObservableEvents_DataSourceInstanceStateChange >&
ObservableEvents::instance_state_changes() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.ObservableEvents.instance_state_changes)
  return instance_state_changes_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/common/sys_stats_counters.pb.cc
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/common/sys_stats_counters.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/common/sys_stats_counters.proto

#ifndef PROTOBUF_perfetto_2fcommon_2fsys_5fstats_5fcounters_2eproto__INCLUDED
#define PROTOBUF_perfetto_2fcommon_2fsys_5fstats_5fcounters_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_perfetto_2fcommon_2fsys_5fstats_5fcounters_2eproto();
void protobuf_AssignDesc_perfetto_2fcommon_2fsys_5fstats_5fcounters_2eproto();
void protobuf_ShutdownFile_perfetto_2fcommon_2fsys_5fstats_5fcounters_2eproto();


enum MeminfoCounters {
  MEMINFO_UNSPECIFIED = 0,
  MEMINFO_MEM_TOTAL = 1,
  MEMINFO_MEM_FREE = 2,
  MEMINFO_MEM_AVAILABLE = 3,
  MEMINFO_BUFFERS = 4,
  MEMINFO_CACHED = 5,
  MEMINFO_SWAP_CACHED = 6,
  MEMINFO_ACTIVE = 7,
  MEMINFO_INACTIVE = 8,
  MEMINFO_ACTIVE_ANON = 9,
  MEMINFO_INACTIVE_ANON = 10,
  MEMINFO_ACTIVE_FILE = 11,
  MEMINFO_INACTIVE_FILE = 12,
  MEMINFO_UNEVICTABLE = 13,
  MEMINFO_MLOCKED = 14,
  MEMINFO_SWAP_TOTAL = 15,
  MEMINFO_SWAP_FREE = 16,
  MEMINFO_DIRTY = 17,
  MEMINFO_WRITEBACK = 18,
  MEMINFO_ANON_PAGES = 19,
  MEMINFO_MAPPED = 20,
  MEMINFO_SHMEM = 21,
  MEMINFO_SLAB = 22,
  MEMINFO_SLAB_RECLAIMABLE = 23,
  MEMINFO_SLAB_UNRECLAIMABLE = 24,
  MEMINFO_KERNEL_STACK = 25,
  MEMINFO_PAGE_TABLES = 26,
  MEMINFO_COMMIT_LIMIT = 27,
  MEMINFO_COMMITED_AS = 28,
  MEMINFO_VMALLOC_TOTAL = 29,
  MEMINFO_VMALLOC_USED = 30,
  MEMINFO_VMALLOC_CHUNK = 31,
  MEMINFO_CMA_TOTAL = 32,
  MEMINFO_CMA_FREE = 33
};
bool MeminfoCounters_IsValid(int value);
const MeminfoCounters MeminfoCounters_MIN = MEMINFO_UNSPECIFIED;
const MeminfoCounters MeminfoCounters_MAX = MEMINFO_CMA_FREE;
const int MeminfoCounters_ARRAYSIZE = MeminfoCounters_MAX + 1;

enum VmstatCounters {
  VMSTAT_UNSPECIFIED = 0,
  VMSTAT_NR_FREE_PAGES = 1,
  VMSTAT_NR_ALLOC_BATCH = 2,
  VMSTAT_NR_INACTIVE_ANON = 3,
  VMSTAT_NR_ACTIVE_ANON = 4,
  VMSTAT_NR_INACTIVE_FILE = 5,
  VMSTAT_NR_ACTIVE_FILE = 6,
  VMSTAT_NR_UNEVICTABLE = 7,
  VMSTAT_NR_MLOCK = 8,
  VMSTAT_NR_ANON_PAGES = 9,
  VMSTAT_NR_MAPPED = 10,
  VMSTAT_NR_FILE_PAGES = 11,
  VMSTAT_NR_DIRTY = 12,
  VMSTAT_NR_WRITEBACK = 13,
  VMSTAT_NR_SLAB_RECLAIMABLE = 14,
  VMSTAT_NR_SLAB_UNRECLAIMABLE = 15,
  VMSTAT_NR_PAGE_TABLE_PAGES = 16,
  VMSTAT_NR_KERNEL_STACK = 17,
  VMSTAT_NR_OVERHEAD = 18,
  VMSTAT_NR_UNSTABLE = 19,
  VMSTAT_NR_BOUNCE = 20,
  VMSTAT_NR_VMSCAN_WRITE = 21,
  VMSTAT_NR_VMSCAN_IMMEDIATE_RECLAIM = 22,
  VMSTAT_NR_WRITEBACK_TEMP = 23,
  VMSTAT_NR_ISOLATED_ANON = 24,
  VMSTAT_NR_ISOLATED_FILE = 25,
  VMSTAT_NR_SHMEM = 26,
  VMSTAT_NR_DIRTIED = 27,
  VMSTAT_NR_WRITTEN = 28,
  VMSTAT_NR_PAGES_SCANNED = 29,
  VMSTAT_WORKINGSET_REFAULT = 30,
  VMSTAT_WORKINGSET_ACTIVATE = 31,
  VMSTAT_WORKINGSET_NODERECLAIM = 32,
  VMSTAT_NR_ANON_TRANSPARENT_HUGEPAGES = 33,
  VMSTAT_NR_FREE_CMA = 34,
  VMSTAT_NR_SWAPCACHE = 35,
  VMSTAT_NR_DIRTY_THRESHOLD = 36,
  VMSTAT_NR_DIRTY_BACKGROUND_THRESHOLD = 37,
  VMSTAT_PGPGIN = 38,
  VMSTAT_PGPGOUT = 39,
  VMSTAT_PGPGOUTCLEAN = 40,
  VMSTAT_PSWPIN = 41,
  VMSTAT_PSWPOUT = 42,
  VMSTAT_PGALLOC_DMA = 43,
  VMSTAT_PGALLOC_NORMAL = 44,
  VMSTAT_PGALLOC_MOVABLE = 45,
  VMSTAT_PGFREE = 46,
  VMSTAT_PGACTIVATE = 47,
  VMSTAT_PGDEACTIVATE = 48,
  VMSTAT_PGFAULT = 49,
  VMSTAT_PGMAJFAULT = 50,
  VMSTAT_PGREFILL_DMA = 51,
  VMSTAT_PGREFILL_NORMAL = 52,
  VMSTAT_PGREFILL_MOVABLE = 53,
  VMSTAT_PGSTEAL_KSWAPD_DMA = 54,
  VMSTAT_PGSTEAL_KSWAPD_NORMAL = 55,
  VMSTAT_PGSTEAL_KSWAPD_MOVABLE = 56,
  VMSTAT_PGSTEAL_DIRECT_DMA = 57,
  VMSTAT_PGSTEAL_DIRECT_NORMAL = 58,
  VMSTAT_PGSTEAL_DIRECT_MOVABLE = 59,
  VMSTAT_PGSCAN_KSWAPD_DMA = 60,
  VMSTAT_PGSCAN_KSWAPD_NORMAL = 61,
  VMSTAT_PGSCAN_KSWAPD_MOVABLE = 62,
  VMSTAT_PGSCAN_DIRECT_DMA = 63,
  VMSTAT_PGSCAN_DIRECT_NORMAL = 64,
  VMSTAT_PGSCAN_DIRECT_MOVABLE = 65,
  VMSTAT_PGSCAN_DIRECT_THROTTLE = 66,
  VMSTAT_PGINODESTEAL = 67,
  VMSTAT_SLABS_SCANNED = 68,
  VMSTAT_KSWAPD_INODESTEAL = 69,
  VMSTAT_KSWAPD_LOW_WMARK_HIT_QUICKLY = 70,
  VMSTAT_KSWAPD_HIGH_WMARK_HIT_QUICKLY = 71,
  VMSTAT_PAGEOUTRUN = 72,
  VMSTAT_ALLOCSTALL = 73,
  VMSTAT_PGROTATED = 74,
  VMSTAT_DROP_PAGECACHE = 75,
  VMSTAT_DROP_SLAB = 76,
  VMSTAT_PGMIGRATE_SUCCESS = 77,
  VMSTAT_PGMIGRATE_FAIL = 78,
  VMSTAT_COMPACT_MIGRATE_SCANNED = 79,
  VMSTAT_COMPACT_FREE_SCANNED = 80,
  VMSTAT_COMPACT_ISOLATED = 81,
  VMSTAT_COMPACT_STALL = 82,
  VMSTAT_COMPACT_FAIL = 83,
  VMSTAT_COMPACT_SUCCESS = 84,
  VMSTAT_COMPACT_DAEMON_WAKE = 85,
  VMSTAT_UNEVICTABLE_PGS_CULLED = 86,
  VMSTAT_UNEVICTABLE_PGS_SCANNED = 87,
  VMSTAT_UNEVICTABLE_PGS_RESCUED = 88,
  VMSTAT_UNEVICTABLE_PGS_MLOCKED = 89,
  VMSTAT_UNEVICTABLE_PGS_MUNLOCKED = 90,
  VMSTAT_UNEVICTABLE_PGS_CLEARED = 91,
  VMSTAT_UNEVICTABLE_PGS_STRANDED = 92,
  VMSTAT_NR_ZSPAGES = 93,
  VMSTAT_NR_ION_HEAP = 94,
  VMSTAT_NR_GPU_HEAP = 95
};
bool VmstatCounters_IsValid(int value);
const VmstatCounters VmstatCounters_MIN = VMSTAT_UNSPECIFIED;
const VmstatCounters VmstatCounters_MAX = VMSTAT_NR_GPU_HEAP;
const int VmstatCounters_ARRAYSIZE = VmstatCounters_MAX + 1;

// ===================================================================


// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::perfetto::protos::MeminfoCounters> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::perfetto::protos::VmstatCounters> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_perfetto_2fcommon_2fsys_5fstats_5fcounters_2eproto__INCLUDED
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/common/sys_stats_counters.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
// gen_amalgamated expanded: #include "perfetto/common/sys_stats_counters.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

void protobuf_ShutdownFile_perfetto_2fcommon_2fsys_5fstats_5fcounters_2eproto() {
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_perfetto_2fcommon_2fsys_5fstats_5fcounters_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_perfetto_2fcommon_2fsys_5fstats_5fcounters_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_perfetto_2fcommon_2fsys_5fstats_5fcounters_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_perfetto_2fcommon_2fsys_5fstats_5fcounters_2eproto_once_);
void protobuf_AddDesc_perfetto_2fcommon_2fsys_5fstats_5fcounters_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_perfetto_2fcommon_2fsys_5fstats_5fcounters_2eproto_once_,
                 &protobuf_AddDesc_perfetto_2fcommon_2fsys_5fstats_5fcounters_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_perfetto_2fcommon_2fsys_5fstats_5fcounters_2eproto {
  StaticDescriptorInitializer_perfetto_2fcommon_2fsys_5fstats_5fcounters_2eproto() {
    protobuf_AddDesc_perfetto_2fcommon_2fsys_5fstats_5fcounters_2eproto();
  }
} static_descriptor_initializer_perfetto_2fcommon_2fsys_5fstats_5fcounters_2eproto_;
#endif
bool MeminfoCounters_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
      return true;
    default:
      return false;
  }
}

bool VmstatCounters_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 65:
    case 66:
    case 67:
    case 68:
    case 69:
    case 70:
    case 71:
    case 72:
    case 73:
    case 74:
    case 75:
    case 76:
    case 77:
    case 78:
    case 79:
    case 80:
    case 81:
    case 82:
    case 83:
    case 84:
    case 85:
    case 86:
    case 87:
    case 88:
    case 89:
    case 90:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
      return true;
    default:
      return false;
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/common/tracing_service_state.pb.cc
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/common/tracing_service_state.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/common/tracing_service_state.proto

#ifndef PROTOBUF_perfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto__INCLUDED
#define PROTOBUF_perfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// gen_amalgamated expanded: #include "perfetto/common/data_source_descriptor.pb.h"
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_perfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto();
void protobuf_AssignDesc_perfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto();
void protobuf_ShutdownFile_perfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto();

class TracingServiceState;
class TracingServiceState_DataSource;
class TracingServiceState_Producer;

// ===================================================================

class TracingServiceState_Producer : public ::google::protobuf::MessageLite {
 public:
  TracingServiceState_Producer();
  virtual ~TracingServiceState_Producer();

  TracingServiceState_Producer(const TracingServiceState_Producer& from);

  inline TracingServiceState_Producer& operator=(const TracingServiceState_Producer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TracingServiceState_Producer& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TracingServiceState_Producer* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TracingServiceState_Producer* other);

  // implements Message ----------------------------------------------

  inline TracingServiceState_Producer* New() const { return New(NULL); }

  TracingServiceState_Producer* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TracingServiceState_Producer& from);
  void MergeFrom(const TracingServiceState_Producer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TracingServiceState_Producer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional int32 uid = 3;
  bool has_uid() const;
  void clear_uid();
  static const int kUidFieldNumber = 3;
  ::google::protobuf::int32 uid() const;
  void set_uid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.TracingServiceState.Producer)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_uid();
  inline void clear_has_uid();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 uid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto();

  void InitAsDefaultInstance();
  static TracingServiceState_Producer* default_instance_;
};
// -------------------------------------------------------------------

class TracingServiceState_DataSource : public ::google::protobuf::MessageLite {
 public:
  TracingServiceState_DataSource();
  virtual ~TracingServiceState_DataSource();

  TracingServiceState_DataSource(const TracingServiceState_DataSource& from);

  inline TracingServiceState_DataSource& operator=(const TracingServiceState_DataSource& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TracingServiceState_DataSource& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TracingServiceState_DataSource* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TracingServiceState_DataSource* other);

  // implements Message ----------------------------------------------

  inline TracingServiceState_DataSource* New() const { return New(NULL); }

  TracingServiceState_DataSource* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TracingServiceState_DataSource& from);
  void MergeFrom(const TracingServiceState_DataSource& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TracingServiceState_DataSource* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .perfetto.protos.DataSourceDescriptor ds_descriptor = 1;
  bool has_ds_descriptor() const;
  void clear_ds_descriptor();
  static const int kDsDescriptorFieldNumber = 1;
  const ::perfetto::protos::DataSourceDescriptor& ds_descriptor() const;
  ::perfetto::protos::DataSourceDescriptor* mutable_ds_descriptor();
  ::perfetto::protos::DataSourceDescriptor* release_ds_descriptor();
  void set_allocated_ds_descriptor(::perfetto::protos::DataSourceDescriptor* ds_descriptor);

  // optional int32 producer_id = 2;
  bool has_producer_id() const;
  void clear_producer_id();
  static const int kProducerIdFieldNumber = 2;
  ::google::protobuf::int32 producer_id() const;
  void set_producer_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.TracingServiceState.DataSource)
 private:
  inline void set_has_ds_descriptor();
  inline void clear_has_ds_descriptor();
  inline void set_has_producer_id();
  inline void clear_has_producer_id();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::perfetto::protos::DataSourceDescriptor* ds_descriptor_;
  ::google::protobuf::int32 producer_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto();

  void InitAsDefaultInstance();
  static TracingServiceState_DataSource* default_instance_;
};
// -------------------------------------------------------------------

class TracingServiceState : public ::google::protobuf::MessageLite {
 public:
  TracingServiceState();
  virtual ~TracingServiceState();

  TracingServiceState(const TracingServiceState& from);

  inline TracingServiceState& operator=(const TracingServiceState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TracingServiceState& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TracingServiceState* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TracingServiceState* other);

  // implements Message ----------------------------------------------

  inline TracingServiceState* New() const { return New(NULL); }

  TracingServiceState* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TracingServiceState& from);
  void MergeFrom(const TracingServiceState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TracingServiceState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef TracingServiceState_Producer Producer;
  typedef TracingServiceState_DataSource DataSource;

  // accessors -------------------------------------------------------

  // repeated .perfetto.protos.TracingServiceState.Producer producers = 1;
  int producers_size() const;
  void clear_producers();
  static const int kProducersFieldNumber = 1;
  const ::perfetto::protos::TracingServiceState_Producer& producers(int index) const;
  ::perfetto::protos::TracingServiceState_Producer* mutable_producers(int index);
  ::perfetto::protos::TracingServiceState_Producer* add_producers();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TracingServiceState_Producer >*
      mutable_producers();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TracingServiceState_Producer >&
      producers() const;

  // repeated .perfetto.protos.TracingServiceState.DataSource data_sources = 2;
  int data_sources_size() const;
  void clear_data_sources();
  static const int kDataSourcesFieldNumber = 2;
  const ::perfetto::protos::TracingServiceState_DataSource& data_sources(int index) const;
  ::perfetto::protos::TracingServiceState_DataSource* mutable_data_sources(int index);
  ::perfetto::protos::TracingServiceState_DataSource* add_data_sources();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TracingServiceState_DataSource >*
      mutable_data_sources();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TracingServiceState_DataSource >&
      data_sources() const;

  // optional int32 num_sessions = 3;
  bool has_num_sessions() const;
  void clear_num_sessions();
  static const int kNumSessionsFieldNumber = 3;
  ::google::protobuf::int32 num_sessions() const;
  void set_num_sessions(::google::protobuf::int32 value);

  // optional int32 num_sessions_started = 4;
  bool has_num_sessions_started() const;
  void clear_num_sessions_started();
  static const int kNumSessionsStartedFieldNumber = 4;
  ::google::protobuf::int32 num_sessions_started() const;
  void set_num_sessions_started(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.TracingServiceState)
 private:
  inline void set_has_num_sessions();
  inline void clear_has_num_sessions();
  inline void set_has_num_sessions_started();
  inline void clear_has_num_sessions_started();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TracingServiceState_Producer > producers_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TracingServiceState_DataSource > data_sources_;
  ::google::protobuf::int32 num_sessions_;
  ::google::protobuf::int32 num_sessions_started_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto();

  void InitAsDefaultInstance();
  static TracingServiceState* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// TracingServiceState_Producer

// optional int32 id = 1;
inline bool TracingServiceState_Producer::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TracingServiceState_Producer::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TracingServiceState_Producer::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TracingServiceState_Producer::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 TracingServiceState_Producer::id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TracingServiceState.Producer.id)
  return id_;
}
inline void TracingServiceState_Producer::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TracingServiceState.Producer.id)
}

// optional string name = 2;
inline bool TracingServiceState_Producer::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TracingServiceState_Producer::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TracingServiceState_Producer::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TracingServiceState_Producer::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& TracingServiceState_Producer::name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TracingServiceState.Producer.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TracingServiceState_Producer::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.TracingServiceState.Producer.name)
}
inline void TracingServiceState_Producer::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.TracingServiceState.Producer.name)
}
inline void TracingServiceState_Producer::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.TracingServiceState.Producer.name)
}
inline ::std::string* TracingServiceState_Producer::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TracingServiceState.Producer.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TracingServiceState_Producer::release_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TracingServiceState.Producer.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TracingServiceState_Producer::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TracingServiceState.Producer.name)
}

// optional int32 uid = 3;
inline bool TracingServiceState_Producer::has_uid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TracingServiceState_Producer::set_has_uid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TracingServiceState_Producer::clear_has_uid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TracingServiceState_Producer::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 TracingServiceState_Producer::uid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TracingServiceState.Producer.uid)
  return uid_;
}
inline void TracingServiceState_Producer::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TracingServiceState.Producer.uid)
}

// -------------------------------------------------------------------

// TracingServiceState_DataSource

// optional .perfetto.protos.DataSourceDescriptor ds_descriptor = 1;
inline bool TracingServiceState_DataSource::has_ds_descriptor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TracingServiceState_DataSource::set_has_ds_descriptor() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TracingServiceState_DataSource::clear_has_ds_descriptor() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TracingServiceState_DataSource::clear_ds_descriptor() {
  if (ds_descriptor_ != NULL) ds_descriptor_->::perfetto::protos::DataSourceDescriptor::Clear();
  clear_has_ds_descriptor();
}
inline const ::perfetto::protos::DataSourceDescriptor& TracingServiceState_DataSource::ds_descriptor() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TracingServiceState.DataSource.ds_descriptor)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return ds_descriptor_ != NULL ? *ds_descriptor_ : *default_instance().ds_descriptor_;
#else
  return ds_descriptor_ != NULL ? *ds_descriptor_ : *default_instance_->ds_descriptor_;
#endif
}
inline ::perfetto::protos::DataSourceDescriptor* TracingServiceState_DataSource::mutable_ds_descriptor() {
  set_has_ds_descriptor();
  if (ds_descriptor_ == NULL) {
    ds_descriptor_ = new ::perfetto::protos::DataSourceDescriptor;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TracingServiceState.DataSource.ds_descriptor)
  return ds_descriptor_;
}
inline ::perfetto::protos::DataSourceDescriptor* TracingServiceState_DataSource::release_ds_descriptor() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TracingServiceState.DataSource.ds_descriptor)
  clear_has_ds_descriptor();
  ::perfetto::protos::DataSourceDescriptor* temp = ds_descriptor_;
  ds_descriptor_ = NULL;
  return temp;
}
inline void TracingServiceState_DataSource::set_allocated_ds_descriptor(::perfetto::protos::DataSourceDescriptor* ds_descriptor) {
  delete ds_descriptor_;
  ds_descriptor_ = ds_descriptor;
  if (ds_descriptor) {
    set_has_ds_descriptor();
  } else {
    clear_has_ds_descriptor();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TracingServiceState.DataSource.ds_descriptor)
}

// optional int32 producer_id = 2;
inline bool TracingServiceState_DataSource::has_producer_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TracingServiceState_DataSource::set_has_producer_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TracingServiceState_DataSource::clear_has_producer_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TracingServiceState_DataSource::clear_producer_id() {
  producer_id_ = 0;
  clear_has_producer_id();
}
inline ::google::protobuf::int32 TracingServiceState_DataSource::producer_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TracingServiceState.DataSource.producer_id)
  return producer_id_;
}
inline void TracingServiceState_DataSource::set_producer_id(::google::protobuf::int32 value) {
  set_has_producer_id();
  producer_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TracingServiceState.DataSource.producer_id)
}

// -------------------------------------------------------------------

// TracingServiceState

// repeated .perfetto.protos.TracingServiceState.Producer producers = 1;
inline int TracingServiceState::producers_size() const {
  return producers_.size();
}
inline void TracingServiceState::clear_producers() {
  producers_.Clear();
}
inline const ::perfetto::protos::TracingServiceState_Producer& TracingServiceState::producers(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TracingServiceState.producers)
  return producers_.Get(index);
}
inline ::perfetto::protos::TracingServiceState_Producer* TracingServiceState::mutable_producers(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TracingServiceState.producers)
  return producers_.Mutable(index);
}
inline ::perfetto::protos::TracingServiceState_Producer* TracingServiceState::add_producers() {
  // @@protoc_insertion_point(field_add:perfetto.protos.TracingServiceState.producers)
  return producers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TracingServiceState_Producer >*
TracingServiceState::mutable_producers() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.TracingServiceState.producers)
  return &producers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TracingServiceState_Producer >&
TracingServiceState::producers() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.TracingServiceState.producers)
  return producers_;
}

// repeated .perfetto.protos.TracingServiceState.DataSource data_sources = 2;
inline int TracingServiceState::data_sources_size() const {
  return data_sources_.size();
}
inline void TracingServiceState::clear_data_sources() {
  data_sources_.Clear();
}
inline const ::perfetto::protos::TracingServiceState_DataSource& TracingServiceState::data_sources(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TracingServiceState.data_sources)
  return data_sources_.Get(index);
}
inline ::perfetto::protos::TracingServiceState_DataSource* TracingServiceState::mutable_data_sources(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TracingServiceState.data_sources)
  return data_sources_.Mutable(index);
}
inline ::perfetto::protos::TracingServiceState_DataSource* TracingServiceState::add_data_sources() {
  // @@protoc_insertion_point(field_add:perfetto.protos.TracingServiceState.data_sources)
  return data_sources_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TracingServiceState_DataSource >*
TracingServiceState::mutable_data_sources() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.TracingServiceState.data_sources)
  return &data_sources_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TracingServiceState_DataSource >&
TracingServiceState::data_sources() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.TracingServiceState.data_sources)
  return data_sources_;
}

// optional int32 num_sessions = 3;
inline bool TracingServiceState::has_num_sessions() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TracingServiceState::set_has_num_sessions() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TracingServiceState::clear_has_num_sessions() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TracingServiceState::clear_num_sessions() {
  num_sessions_ = 0;
  clear_has_num_sessions();
}
inline ::google::protobuf::int32 TracingServiceState::num_sessions() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TracingServiceState.num_sessions)
  return num_sessions_;
}
inline void TracingServiceState::set_num_sessions(::google::protobuf::int32 value) {
  set_has_num_sessions();
  num_sessions_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TracingServiceState.num_sessions)
}

// optional int32 num_sessions_started = 4;
inline bool TracingServiceState::has_num_sessions_started() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TracingServiceState::set_has_num_sessions_started() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TracingServiceState::clear_has_num_sessions_started() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TracingServiceState::clear_num_sessions_started() {
  num_sessions_started_ = 0;
  clear_has_num_sessions_started();
}
inline ::google::protobuf::int32 TracingServiceState::num_sessions_started() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TracingServiceState.num_sessions_started)
  return num_sessions_started_;
}
inline void TracingServiceState::set_num_sessions_started(::google::protobuf::int32 value) {
  set_has_num_sessions_started();
  num_sessions_started_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TracingServiceState.num_sessions_started)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_perfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto__INCLUDED
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/common/tracing_service_state.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
// gen_amalgamated expanded: #include "perfetto/common/tracing_service_state.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

void protobuf_ShutdownFile_perfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto() {
  delete TracingServiceState::default_instance_;
  delete TracingServiceState_Producer::default_instance_;
  delete TracingServiceState_DataSource::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_perfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_perfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::perfetto::protos::protobuf_AddDesc_perfetto_2fcommon_2fdata_5fsource_5fdescriptor_2eproto();
  TracingServiceState::default_instance_ = new TracingServiceState();
  TracingServiceState_Producer::default_instance_ = new TracingServiceState_Producer();
  TracingServiceState_DataSource::default_instance_ = new TracingServiceState_DataSource();
  TracingServiceState::default_instance_->InitAsDefaultInstance();
  TracingServiceState_Producer::default_instance_->InitAsDefaultInstance();
  TracingServiceState_DataSource::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_perfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_perfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto_once_);
void protobuf_AddDesc_perfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_perfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto_once_,
                 &protobuf_AddDesc_perfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_perfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto {
  StaticDescriptorInitializer_perfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto() {
    protobuf_AddDesc_perfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto();
  }
} static_descriptor_initializer_perfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto_;
#endif

namespace {

static void tracing_service_state_pb_MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
static void tracing_service_state_pb_MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

static ::std::string* MutableUnknownFieldsForTracingServiceState(
    TracingServiceState* ptr) {
  return ptr->mutable_unknown_fields();
}

static ::std::string* MutableUnknownFieldsForTracingServiceState_Producer(
    TracingServiceState_Producer* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TracingServiceState_Producer::kIdFieldNumber;
const int TracingServiceState_Producer::kNameFieldNumber;
const int TracingServiceState_Producer::kUidFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TracingServiceState_Producer::TracingServiceState_Producer()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.TracingServiceState.Producer)
}

void TracingServiceState_Producer::InitAsDefaultInstance() {
}

TracingServiceState_Producer::TracingServiceState_Producer(const TracingServiceState_Producer& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.TracingServiceState.Producer)
}

void TracingServiceState_Producer::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  id_ = 0;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  uid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TracingServiceState_Producer::~TracingServiceState_Producer() {
  // @@protoc_insertion_point(destructor:perfetto.protos.TracingServiceState.Producer)
  SharedDtor();
}

void TracingServiceState_Producer::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TracingServiceState_Producer::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TracingServiceState_Producer& TracingServiceState_Producer::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto();
#endif
  return *default_instance_;
}

TracingServiceState_Producer* TracingServiceState_Producer::default_instance_ = NULL;

TracingServiceState_Producer* TracingServiceState_Producer::New(::google::protobuf::Arena* arena) const {
  TracingServiceState_Producer* n = new TracingServiceState_Producer;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TracingServiceState_Producer::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.TracingServiceState.Producer)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(TracingServiceState_Producer, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<TracingServiceState_Producer*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 7u) {
    ZR_(id_, uid_);
    if (has_name()) {
      name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool TracingServiceState_Producer::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForTracingServiceState_Producer, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.TracingServiceState.Producer)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // optional string name = 2;
      case 2: {
        if (tag == 18) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_uid;
        break;
      }

      // optional int32 uid = 3;
      case 3: {
        if (tag == 24) {
         parse_uid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &uid_)));
          set_has_uid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.TracingServiceState.Producer)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.TracingServiceState.Producer)
  return false;
#undef DO_
}

void TracingServiceState_Producer::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.TracingServiceState.Producer)
  // optional int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->name(), output);
  }

  // optional int32 uid = 3;
  if (has_uid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->uid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.TracingServiceState.Producer)
}

int TracingServiceState_Producer::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.TracingServiceState.Producer)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 7u) {
    // optional int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // optional string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional int32 uid = 3;
    if (has_uid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->uid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TracingServiceState_Producer::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TracingServiceState_Producer*>(&from));
}

void TracingServiceState_Producer::MergeFrom(const TracingServiceState_Producer& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.TracingServiceState.Producer)
  if (GOOGLE_PREDICT_FALSE(&from == this)) tracing_service_state_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (from.has_uid()) {
      set_uid(from.uid());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void TracingServiceState_Producer::CopyFrom(const TracingServiceState_Producer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.TracingServiceState.Producer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TracingServiceState_Producer::IsInitialized() const {

  return true;
}

void TracingServiceState_Producer::Swap(TracingServiceState_Producer* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TracingServiceState_Producer::InternalSwap(TracingServiceState_Producer* other) {
  std::swap(id_, other->id_);
  name_.Swap(&other->name_);
  std::swap(uid_, other->uid_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string TracingServiceState_Producer::GetTypeName() const {
  return "perfetto.protos.TracingServiceState.Producer";
}


// -------------------------------------------------------------------

static ::std::string* MutableUnknownFieldsForTracingServiceState_DataSource(
    TracingServiceState_DataSource* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TracingServiceState_DataSource::kDsDescriptorFieldNumber;
const int TracingServiceState_DataSource::kProducerIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TracingServiceState_DataSource::TracingServiceState_DataSource()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.TracingServiceState.DataSource)
}

void TracingServiceState_DataSource::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  ds_descriptor_ = const_cast< ::perfetto::protos::DataSourceDescriptor*>(
      ::perfetto::protos::DataSourceDescriptor::internal_default_instance());
#else
  ds_descriptor_ = const_cast< ::perfetto::protos::DataSourceDescriptor*>(&::perfetto::protos::DataSourceDescriptor::default_instance());
#endif
}

TracingServiceState_DataSource::TracingServiceState_DataSource(const TracingServiceState_DataSource& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.TracingServiceState.DataSource)
}

void TracingServiceState_DataSource::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ds_descriptor_ = NULL;
  producer_id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TracingServiceState_DataSource::~TracingServiceState_DataSource() {
  // @@protoc_insertion_point(destructor:perfetto.protos.TracingServiceState.DataSource)
  SharedDtor();
}

void TracingServiceState_DataSource::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete ds_descriptor_;
  }
}

void TracingServiceState_DataSource::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TracingServiceState_DataSource& TracingServiceState_DataSource::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto();
#endif
  return *default_instance_;
}

TracingServiceState_DataSource* TracingServiceState_DataSource::default_instance_ = NULL;

TracingServiceState_DataSource* TracingServiceState_DataSource::New(::google::protobuf::Arena* arena) const {
  TracingServiceState_DataSource* n = new TracingServiceState_DataSource;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TracingServiceState_DataSource::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.TracingServiceState.DataSource)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_ds_descriptor()) {
      if (ds_descriptor_ != NULL) ds_descriptor_->::perfetto::protos::DataSourceDescriptor::Clear();
    }
    producer_id_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool TracingServiceState_DataSource::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForTracingServiceState_DataSource, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.TracingServiceState.DataSource)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .perfetto.protos.DataSourceDescriptor ds_descriptor = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ds_descriptor()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_producer_id;
        break;
      }

      // optional int32 producer_id = 2;
      case 2: {
        if (tag == 16) {
         parse_producer_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &producer_id_)));
          set_has_producer_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.TracingServiceState.DataSource)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.TracingServiceState.DataSource)
  return false;
#undef DO_
}

void TracingServiceState_DataSource::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.TracingServiceState.DataSource)
  // optional .perfetto.protos.DataSourceDescriptor ds_descriptor = 1;
  if (has_ds_descriptor()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->ds_descriptor_, output);
  }

  // optional int32 producer_id = 2;
  if (has_producer_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->producer_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.TracingServiceState.DataSource)
}

int TracingServiceState_DataSource::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.TracingServiceState.DataSource)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional .perfetto.protos.DataSourceDescriptor ds_descriptor = 1;
    if (has_ds_descriptor()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->ds_descriptor_);
    }

    // optional int32 producer_id = 2;
    if (has_producer_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->producer_id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TracingServiceState_DataSource::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TracingServiceState_DataSource*>(&from));
}

void TracingServiceState_DataSource::MergeFrom(const TracingServiceState_DataSource& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.TracingServiceState.DataSource)
  if (GOOGLE_PREDICT_FALSE(&from == this)) tracing_service_state_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ds_descriptor()) {
      mutable_ds_descriptor()->::perfetto::protos::DataSourceDescriptor::MergeFrom(from.ds_descriptor());
    }
    if (from.has_producer_id()) {
      set_producer_id(from.producer_id());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void TracingServiceState_DataSource::CopyFrom(const TracingServiceState_DataSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.TracingServiceState.DataSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TracingServiceState_DataSource::IsInitialized() const {

  return true;
}

void TracingServiceState_DataSource::Swap(TracingServiceState_DataSource* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TracingServiceState_DataSource::InternalSwap(TracingServiceState_DataSource* other) {
  std::swap(ds_descriptor_, other->ds_descriptor_);
  std::swap(producer_id_, other->producer_id_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string TracingServiceState_DataSource::GetTypeName() const {
  return "perfetto.protos.TracingServiceState.DataSource";
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TracingServiceState::kProducersFieldNumber;
const int TracingServiceState::kDataSourcesFieldNumber;
const int TracingServiceState::kNumSessionsFieldNumber;
const int TracingServiceState::kNumSessionsStartedFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TracingServiceState::TracingServiceState()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.TracingServiceState)
}

void TracingServiceState::InitAsDefaultInstance() {
}

TracingServiceState::TracingServiceState(const TracingServiceState& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.TracingServiceState)
}

void TracingServiceState::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  num_sessions_ = 0;
  num_sessions_started_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TracingServiceState::~TracingServiceState() {
  // @@protoc_insertion_point(destructor:perfetto.protos.TracingServiceState)
  SharedDtor();
}

void TracingServiceState::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TracingServiceState::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TracingServiceState& TracingServiceState::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto();
#endif
  return *default_instance_;
}

TracingServiceState* TracingServiceState::default_instance_ = NULL;

TracingServiceState* TracingServiceState::New(::google::protobuf::Arena* arena) const {
  TracingServiceState* n = new TracingServiceState;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TracingServiceState::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.TracingServiceState)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(TracingServiceState, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<TracingServiceState*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(num_sessions_, num_sessions_started_);

#undef ZR_HELPER_
#undef ZR_

  producers_.Clear();
  data_sources_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool TracingServiceState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForTracingServiceState, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.TracingServiceState)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .perfetto.protos.TracingServiceState.Producer producers = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_producers:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_producers()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_producers;
        if (input->ExpectTag(18)) goto parse_loop_data_sources;
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // repeated .perfetto.protos.TracingServiceState.DataSource data_sources = 2;
      case 2: {
        if (tag == 18) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_data_sources:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_data_sources()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_data_sources;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(24)) goto parse_num_sessions;
        break;
      }

      // optional int32 num_sessions = 3;
      case 3: {
        if (tag == 24) {
         parse_num_sessions:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_sessions_)));
          set_has_num_sessions();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_num_sessions_started;
        break;
      }

      // optional int32 num_sessions_started = 4;
      case 4: {
        if (tag == 32) {
         parse_num_sessions_started:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_sessions_started_)));
          set_has_num_sessions_started();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.TracingServiceState)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.TracingServiceState)
  return false;
#undef DO_
}

void TracingServiceState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.TracingServiceState)
  // repeated .perfetto.protos.TracingServiceState.Producer producers = 1;
  for (unsigned int i = 0, n = this->producers_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->producers(i), output);
  }

  // repeated .perfetto.protos.TracingServiceState.DataSource data_sources = 2;
  for (unsigned int i = 0, n = this->data_sources_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->data_sources(i), output);
  }

  // optional int32 num_sessions = 3;
  if (has_num_sessions()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->num_sessions(), output);
  }

  // optional int32 num_sessions_started = 4;
  if (has_num_sessions_started()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->num_sessions_started(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.TracingServiceState)
}

int TracingServiceState::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.TracingServiceState)
  int total_size = 0;

  if (_has_bits_[2 / 32] & 12u) {
    // optional int32 num_sessions = 3;
    if (has_num_sessions()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->num_sessions());
    }

    // optional int32 num_sessions_started = 4;
    if (has_num_sessions_started()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->num_sessions_started());
    }

  }
  // repeated .perfetto.protos.TracingServiceState.Producer producers = 1;
  total_size += 1 * this->producers_size();
  for (int i = 0; i < this->producers_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->producers(i));
  }

  // repeated .perfetto.protos.TracingServiceState.DataSource data_sources = 2;
  total_size += 1 * this->data_sources_size();
  for (int i = 0; i < this->data_sources_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->data_sources(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TracingServiceState::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TracingServiceState*>(&from));
}

void TracingServiceState::MergeFrom(const TracingServiceState& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.TracingServiceState)
  if (GOOGLE_PREDICT_FALSE(&from == this)) tracing_service_state_pb_MergeFromFail(__LINE__);
  producers_.MergeFrom(from.producers_);
  data_sources_.MergeFrom(from.data_sources_);
  if (from._has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    if (from.has_num_sessions()) {
      set_num_sessions(from.num_sessions());
    }
    if (from.has_num_sessions_started()) {
      set_num_sessions_started(from.num_sessions_started());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void TracingServiceState::CopyFrom(const TracingServiceState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.TracingServiceState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TracingServiceState::IsInitialized() const {

  return true;
}

void TracingServiceState::Swap(TracingServiceState* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TracingServiceState::InternalSwap(TracingServiceState* other) {
  producers_.UnsafeArenaSwap(&other->producers_);
  data_sources_.UnsafeArenaSwap(&other->data_sources_);
  std::swap(num_sessions_, other->num_sessions_);
  std::swap(num_sessions_started_, other->num_sessions_started_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string TracingServiceState::GetTypeName() const {
  return "perfetto.protos.TracingServiceState";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TracingServiceState_Producer

// optional int32 id = 1;
bool TracingServiceState_Producer::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TracingServiceState_Producer::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
void TracingServiceState_Producer::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void TracingServiceState_Producer::clear_id() {
  id_ = 0;
  clear_has_id();
}
 ::google::protobuf::int32 TracingServiceState_Producer::id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TracingServiceState.Producer.id)
  return id_;
}
 void TracingServiceState_Producer::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TracingServiceState.Producer.id)
}

// optional string name = 2;
bool TracingServiceState_Producer::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void TracingServiceState_Producer::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
void TracingServiceState_Producer::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
void TracingServiceState_Producer::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
 const ::std::string& TracingServiceState_Producer::name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TracingServiceState.Producer.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TracingServiceState_Producer::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.TracingServiceState.Producer.name)
}
 void TracingServiceState_Producer::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.TracingServiceState.Producer.name)
}
 void TracingServiceState_Producer::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.TracingServiceState.Producer.name)
}
 ::std::string* TracingServiceState_Producer::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TracingServiceState.Producer.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* TracingServiceState_Producer::release_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TracingServiceState.Producer.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TracingServiceState_Producer::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TracingServiceState.Producer.name)
}

// optional int32 uid = 3;
bool TracingServiceState_Producer::has_uid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void TracingServiceState_Producer::set_has_uid() {
  _has_bits_[0] |= 0x00000004u;
}
void TracingServiceState_Producer::clear_has_uid() {
  _has_bits_[0] &= ~0x00000004u;
}
void TracingServiceState_Producer::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
 ::google::protobuf::int32 TracingServiceState_Producer::uid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TracingServiceState.Producer.uid)
  return uid_;
}
 void TracingServiceState_Producer::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TracingServiceState.Producer.uid)
}

// -------------------------------------------------------------------

// TracingServiceState_DataSource

// optional .perfetto.protos.DataSourceDescriptor ds_descriptor = 1;
bool TracingServiceState_DataSource::has_ds_descriptor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TracingServiceState_DataSource::set_has_ds_descriptor() {
  _has_bits_[0] |= 0x00000001u;
}
void TracingServiceState_DataSource::clear_has_ds_descriptor() {
  _has_bits_[0] &= ~0x00000001u;
}
void TracingServiceState_DataSource::clear_ds_descriptor() {
  if (ds_descriptor_ != NULL) ds_descriptor_->::perfetto::protos::DataSourceDescriptor::Clear();
  clear_has_ds_descriptor();
}
const ::perfetto::protos::DataSourceDescriptor& TracingServiceState_DataSource::ds_descriptor() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TracingServiceState.DataSource.ds_descriptor)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return ds_descriptor_ != NULL ? *ds_descriptor_ : *default_instance().ds_descriptor_;
#else
  return ds_descriptor_ != NULL ? *ds_descriptor_ : *default_instance_->ds_descriptor_;
#endif
}
::perfetto::protos::DataSourceDescriptor* TracingServiceState_DataSource::mutable_ds_descriptor() {
  set_has_ds_descriptor();
  if (ds_descriptor_ == NULL) {
    ds_descriptor_ = new ::perfetto::protos::DataSourceDescriptor;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TracingServiceState.DataSource.ds_descriptor)
  return ds_descriptor_;
}
::perfetto::protos::DataSourceDescriptor* TracingServiceState_DataSource::release_ds_descriptor() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TracingServiceState.DataSource.ds_descriptor)
  clear_has_ds_descriptor();
  ::perfetto::protos::DataSourceDescriptor* temp = ds_descriptor_;
  ds_descriptor_ = NULL;
  return temp;
}
void TracingServiceState_DataSource::set_allocated_ds_descriptor(::perfetto::protos::DataSourceDescriptor* ds_descriptor) {
  delete ds_descriptor_;
  ds_descriptor_ = ds_descriptor;
  if (ds_descriptor) {
    set_has_ds_descriptor();
  } else {
    clear_has_ds_descriptor();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TracingServiceState.DataSource.ds_descriptor)
}

// optional int32 producer_id = 2;
bool TracingServiceState_DataSource::has_producer_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void TracingServiceState_DataSource::set_has_producer_id() {
  _has_bits_[0] |= 0x00000002u;
}
void TracingServiceState_DataSource::clear_has_producer_id() {
  _has_bits_[0] &= ~0x00000002u;
}
void TracingServiceState_DataSource::clear_producer_id() {
  producer_id_ = 0;
  clear_has_producer_id();
}
 ::google::protobuf::int32 TracingServiceState_DataSource::producer_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TracingServiceState.DataSource.producer_id)
  return producer_id_;
}
 void TracingServiceState_DataSource::set_producer_id(::google::protobuf::int32 value) {
  set_has_producer_id();
  producer_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TracingServiceState.DataSource.producer_id)
}

// -------------------------------------------------------------------

// TracingServiceState

// repeated .perfetto.protos.TracingServiceState.Producer producers = 1;
int TracingServiceState::producers_size() const {
  return producers_.size();
}
void TracingServiceState::clear_producers() {
  producers_.Clear();
}
const ::perfetto::protos::TracingServiceState_Producer& TracingServiceState::producers(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TracingServiceState.producers)
  return producers_.Get(index);
}
::perfetto::protos::TracingServiceState_Producer* TracingServiceState::mutable_producers(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TracingServiceState.producers)
  return producers_.Mutable(index);
}
::perfetto::protos::TracingServiceState_Producer* TracingServiceState::add_producers() {
  // @@protoc_insertion_point(field_add:perfetto.protos.TracingServiceState.producers)
  return producers_.Add();
}
::google::protobuf::RepeatedPtrField< ::perfetto::protos::TracingServiceState_Producer >*
TracingServiceState::mutable_producers() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.TracingServiceState.producers)
  return &producers_;
}
const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TracingServiceState_Producer >&
TracingServiceState::producers() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.TracingServiceState.producers)
  return producers_;
}

// repeated .perfetto.protos.TracingServiceState.DataSource data_sources = 2;
int TracingServiceState::data_sources_size() const {
  return data_sources_.size();
}
void TracingServiceState::clear_data_sources() {
  data_sources_.Clear();
}
const ::perfetto::protos::TracingServiceState_DataSource& TracingServiceState::data_sources(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TracingServiceState.data_sources)
  return data_sources_.Get(index);
}
::perfetto::protos::TracingServiceState_DataSource* TracingServiceState::mutable_data_sources(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TracingServiceState.data_sources)
  return data_sources_.Mutable(index);
}
::perfetto::protos::TracingServiceState_DataSource* TracingServiceState::add_data_sources() {
  // @@protoc_insertion_point(field_add:perfetto.protos.TracingServiceState.data_sources)
  return data_sources_.Add();
}
::google::protobuf::RepeatedPtrField< ::perfetto::protos::TracingServiceState_DataSource >*
TracingServiceState::mutable_data_sources() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.TracingServiceState.data_sources)
  return &data_sources_;
}
const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TracingServiceState_DataSource >&
TracingServiceState::data_sources() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.TracingServiceState.data_sources)
  return data_sources_;
}

// optional int32 num_sessions = 3;
bool TracingServiceState::has_num_sessions() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void TracingServiceState::set_has_num_sessions() {
  _has_bits_[0] |= 0x00000004u;
}
void TracingServiceState::clear_has_num_sessions() {
  _has_bits_[0] &= ~0x00000004u;
}
void TracingServiceState::clear_num_sessions() {
  num_sessions_ = 0;
  clear_has_num_sessions();
}
 ::google::protobuf::int32 TracingServiceState::num_sessions() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TracingServiceState.num_sessions)
  return num_sessions_;
}
 void TracingServiceState::set_num_sessions(::google::protobuf::int32 value) {
  set_has_num_sessions();
  num_sessions_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TracingServiceState.num_sessions)
}

// optional int32 num_sessions_started = 4;
bool TracingServiceState::has_num_sessions_started() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void TracingServiceState::set_has_num_sessions_started() {
  _has_bits_[0] |= 0x00000008u;
}
void TracingServiceState::clear_has_num_sessions_started() {
  _has_bits_[0] &= ~0x00000008u;
}
void TracingServiceState::clear_num_sessions_started() {
  num_sessions_started_ = 0;
  clear_has_num_sessions_started();
}
 ::google::protobuf::int32 TracingServiceState::num_sessions_started() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TracingServiceState.num_sessions_started)
  return num_sessions_started_;
}
 void TracingServiceState::set_num_sessions_started(::google::protobuf::int32 value) {
  set_has_num_sessions_started();
  num_sessions_started_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TracingServiceState.num_sessions_started)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/common/trace_stats.pb.cc
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/common/trace_stats.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/common/trace_stats.proto

#ifndef PROTOBUF_perfetto_2fcommon_2ftrace_5fstats_2eproto__INCLUDED
#define PROTOBUF_perfetto_2fcommon_2ftrace_5fstats_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_perfetto_2fcommon_2ftrace_5fstats_2eproto();
void protobuf_AssignDesc_perfetto_2fcommon_2ftrace_5fstats_2eproto();
void protobuf_ShutdownFile_perfetto_2fcommon_2ftrace_5fstats_2eproto();

class TraceStats;
class TraceStats_BufferStats;

// ===================================================================

class TraceStats_BufferStats : public ::google::protobuf::MessageLite {
 public:
  TraceStats_BufferStats();
  virtual ~TraceStats_BufferStats();

  TraceStats_BufferStats(const TraceStats_BufferStats& from);

  inline TraceStats_BufferStats& operator=(const TraceStats_BufferStats& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TraceStats_BufferStats& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TraceStats_BufferStats* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TraceStats_BufferStats* other);

  // implements Message ----------------------------------------------

  inline TraceStats_BufferStats* New() const { return New(NULL); }

  TraceStats_BufferStats* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TraceStats_BufferStats& from);
  void MergeFrom(const TraceStats_BufferStats& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TraceStats_BufferStats* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 buffer_size = 12;
  bool has_buffer_size() const;
  void clear_buffer_size();
  static const int kBufferSizeFieldNumber = 12;
  ::google::protobuf::uint64 buffer_size() const;
  void set_buffer_size(::google::protobuf::uint64 value);

  // optional uint64 bytes_written = 1;
  bool has_bytes_written() const;
  void clear_bytes_written();
  static const int kBytesWrittenFieldNumber = 1;
  ::google::protobuf::uint64 bytes_written() const;
  void set_bytes_written(::google::protobuf::uint64 value);

  // optional uint64 bytes_overwritten = 13;
  bool has_bytes_overwritten() const;
  void clear_bytes_overwritten();
  static const int kBytesOverwrittenFieldNumber = 13;
  ::google::protobuf::uint64 bytes_overwritten() const;
  void set_bytes_overwritten(::google::protobuf::uint64 value);

  // optional uint64 bytes_read = 14;
  bool has_bytes_read() const;
  void clear_bytes_read();
  static const int kBytesReadFieldNumber = 14;
  ::google::protobuf::uint64 bytes_read() const;
  void set_bytes_read(::google::protobuf::uint64 value);

  // optional uint64 padding_bytes_written = 15;
  bool has_padding_bytes_written() const;
  void clear_padding_bytes_written();
  static const int kPaddingBytesWrittenFieldNumber = 15;
  ::google::protobuf::uint64 padding_bytes_written() const;
  void set_padding_bytes_written(::google::protobuf::uint64 value);

  // optional uint64 padding_bytes_cleared = 16;
  bool has_padding_bytes_cleared() const;
  void clear_padding_bytes_cleared();
  static const int kPaddingBytesClearedFieldNumber = 16;
  ::google::protobuf::uint64 padding_bytes_cleared() const;
  void set_padding_bytes_cleared(::google::protobuf::uint64 value);

  // optional uint64 chunks_written = 2;
  bool has_chunks_written() const;
  void clear_chunks_written();
  static const int kChunksWrittenFieldNumber = 2;
  ::google::protobuf::uint64 chunks_written() const;
  void set_chunks_written(::google::protobuf::uint64 value);

  // optional uint64 chunks_rewritten = 10;
  bool has_chunks_rewritten() const;
  void clear_chunks_rewritten();
  static const int kChunksRewrittenFieldNumber = 10;
  ::google::protobuf::uint64 chunks_rewritten() const;
  void set_chunks_rewritten(::google::protobuf::uint64 value);

  // optional uint64 chunks_overwritten = 3;
  bool has_chunks_overwritten() const;
  void clear_chunks_overwritten();
  static const int kChunksOverwrittenFieldNumber = 3;
  ::google::protobuf::uint64 chunks_overwritten() const;
  void set_chunks_overwritten(::google::protobuf::uint64 value);

  // optional uint64 chunks_discarded = 18;
  bool has_chunks_discarded() const;
  void clear_chunks_discarded();
  static const int kChunksDiscardedFieldNumber = 18;
  ::google::protobuf::uint64 chunks_discarded() const;
  void set_chunks_discarded(::google::protobuf::uint64 value);

  // optional uint64 chunks_read = 17;
  bool has_chunks_read() const;
  void clear_chunks_read();
  static const int kChunksReadFieldNumber = 17;
  ::google::protobuf::uint64 chunks_read() const;
  void set_chunks_read(::google::protobuf::uint64 value);

  // optional uint64 chunks_committed_out_of_order = 11;
  bool has_chunks_committed_out_of_order() const;
  void clear_chunks_committed_out_of_order();
  static const int kChunksCommittedOutOfOrderFieldNumber = 11;
  ::google::protobuf::uint64 chunks_committed_out_of_order() const;
  void set_chunks_committed_out_of_order(::google::protobuf::uint64 value);

  // optional uint64 write_wrap_count = 4;
  bool has_write_wrap_count() const;
  void clear_write_wrap_count();
  static const int kWriteWrapCountFieldNumber = 4;
  ::google::protobuf::uint64 write_wrap_count() const;
  void set_write_wrap_count(::google::protobuf::uint64 value);

  // optional uint64 patches_succeeded = 5;
  bool has_patches_succeeded() const;
  void clear_patches_succeeded();
  static const int kPatchesSucceededFieldNumber = 5;
  ::google::protobuf::uint64 patches_succeeded() const;
  void set_patches_succeeded(::google::protobuf::uint64 value);

  // optional uint64 patches_failed = 6;
  bool has_patches_failed() const;
  void clear_patches_failed();
  static const int kPatchesFailedFieldNumber = 6;
  ::google::protobuf::uint64 patches_failed() const;
  void set_patches_failed(::google::protobuf::uint64 value);

  // optional uint64 readaheads_succeeded = 7;
  bool has_readaheads_succeeded() const;
  void clear_readaheads_succeeded();
  static const int kReadaheadsSucceededFieldNumber = 7;
  ::google::protobuf::uint64 readaheads_succeeded() const;
  void set_readaheads_succeeded(::google::protobuf::uint64 value);

  // optional uint64 readaheads_failed = 8;
  bool has_readaheads_failed() const;
  void clear_readaheads_failed();
  static const int kReadaheadsFailedFieldNumber = 8;
  ::google::protobuf::uint64 readaheads_failed() const;
  void set_readaheads_failed(::google::protobuf::uint64 value);

  // optional uint64 abi_violations = 9;
  bool has_abi_violations() const;
  void clear_abi_violations();
  static const int kAbiViolationsFieldNumber = 9;
  ::google::protobuf::uint64 abi_violations() const;
  void set_abi_violations(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.TraceStats.BufferStats)
 private:
  inline void set_has_buffer_size();
  inline void clear_has_buffer_size();
  inline void set_has_bytes_written();
  inline void clear_has_bytes_written();
  inline void set_has_bytes_overwritten();
  inline void clear_has_bytes_overwritten();
  inline void set_has_bytes_read();
  inline void clear_has_bytes_read();
  inline void set_has_padding_bytes_written();
  inline void clear_has_padding_bytes_written();
  inline void set_has_padding_bytes_cleared();
  inline void clear_has_padding_bytes_cleared();
  inline void set_has_chunks_written();
  inline void clear_has_chunks_written();
  inline void set_has_chunks_rewritten();
  inline void clear_has_chunks_rewritten();
  inline void set_has_chunks_overwritten();
  inline void clear_has_chunks_overwritten();
  inline void set_has_chunks_discarded();
  inline void clear_has_chunks_discarded();
  inline void set_has_chunks_read();
  inline void clear_has_chunks_read();
  inline void set_has_chunks_committed_out_of_order();
  inline void clear_has_chunks_committed_out_of_order();
  inline void set_has_write_wrap_count();
  inline void clear_has_write_wrap_count();
  inline void set_has_patches_succeeded();
  inline void clear_has_patches_succeeded();
  inline void set_has_patches_failed();
  inline void clear_has_patches_failed();
  inline void set_has_readaheads_succeeded();
  inline void clear_has_readaheads_succeeded();
  inline void set_has_readaheads_failed();
  inline void clear_has_readaheads_failed();
  inline void set_has_abi_violations();
  inline void clear_has_abi_violations();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 buffer_size_;
  ::google::protobuf::uint64 bytes_written_;
  ::google::protobuf::uint64 bytes_overwritten_;
  ::google::protobuf::uint64 bytes_read_;
  ::google::protobuf::uint64 padding_bytes_written_;
  ::google::protobuf::uint64 padding_bytes_cleared_;
  ::google::protobuf::uint64 chunks_written_;
  ::google::protobuf::uint64 chunks_rewritten_;
  ::google::protobuf::uint64 chunks_overwritten_;
  ::google::protobuf::uint64 chunks_discarded_;
  ::google::protobuf::uint64 chunks_read_;
  ::google::protobuf::uint64 chunks_committed_out_of_order_;
  ::google::protobuf::uint64 write_wrap_count_;
  ::google::protobuf::uint64 patches_succeeded_;
  ::google::protobuf::uint64 patches_failed_;
  ::google::protobuf::uint64 readaheads_succeeded_;
  ::google::protobuf::uint64 readaheads_failed_;
  ::google::protobuf::uint64 abi_violations_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fcommon_2ftrace_5fstats_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fcommon_2ftrace_5fstats_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fcommon_2ftrace_5fstats_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fcommon_2ftrace_5fstats_2eproto();

  void InitAsDefaultInstance();
  static TraceStats_BufferStats* default_instance_;
};
// -------------------------------------------------------------------

class TraceStats : public ::google::protobuf::MessageLite {
 public:
  TraceStats();
  virtual ~TraceStats();

  TraceStats(const TraceStats& from);

  inline TraceStats& operator=(const TraceStats& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TraceStats& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TraceStats* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TraceStats* other);

  // implements Message ----------------------------------------------

  inline TraceStats* New() const { return New(NULL); }

  TraceStats* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TraceStats& from);
  void MergeFrom(const TraceStats& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TraceStats* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef TraceStats_BufferStats BufferStats;

  // accessors -------------------------------------------------------

  // repeated .perfetto.protos.TraceStats.BufferStats buffer_stats = 1;
  int buffer_stats_size() const;
  void clear_buffer_stats();
  static const int kBufferStatsFieldNumber = 1;
  const ::perfetto::protos::TraceStats_BufferStats& buffer_stats(int index) const;
  ::perfetto::protos::TraceStats_BufferStats* mutable_buffer_stats(int index);
  ::perfetto::protos::TraceStats_BufferStats* add_buffer_stats();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceStats_BufferStats >*
      mutable_buffer_stats();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceStats_BufferStats >&
      buffer_stats() const;

  // optional uint32 producers_connected = 2;
  bool has_producers_connected() const;
  void clear_producers_connected();
  static const int kProducersConnectedFieldNumber = 2;
  ::google::protobuf::uint32 producers_connected() const;
  void set_producers_connected(::google::protobuf::uint32 value);

  // optional uint64 producers_seen = 3;
  bool has_producers_seen() const;
  void clear_producers_seen();
  static const int kProducersSeenFieldNumber = 3;
  ::google::protobuf::uint64 producers_seen() const;
  void set_producers_seen(::google::protobuf::uint64 value);

  // optional uint32 data_sources_registered = 4;
  bool has_data_sources_registered() const;
  void clear_data_sources_registered();
  static const int kDataSourcesRegisteredFieldNumber = 4;
  ::google::protobuf::uint32 data_sources_registered() const;
  void set_data_sources_registered(::google::protobuf::uint32 value);

  // optional uint64 data_sources_seen = 5;
  bool has_data_sources_seen() const;
  void clear_data_sources_seen();
  static const int kDataSourcesSeenFieldNumber = 5;
  ::google::protobuf::uint64 data_sources_seen() const;
  void set_data_sources_seen(::google::protobuf::uint64 value);

  // optional uint32 tracing_sessions = 6;
  bool has_tracing_sessions() const;
  void clear_tracing_sessions();
  static const int kTracingSessionsFieldNumber = 6;
  ::google::protobuf::uint32 tracing_sessions() const;
  void set_tracing_sessions(::google::protobuf::uint32 value);

  // optional uint32 total_buffers = 7;
  bool has_total_buffers() const;
  void clear_total_buffers();
  static const int kTotalBuffersFieldNumber = 7;
  ::google::protobuf::uint32 total_buffers() const;
  void set_total_buffers(::google::protobuf::uint32 value);

  // optional uint64 chunks_discarded = 8;
  bool has_chunks_discarded() const;
  void clear_chunks_discarded();
  static const int kChunksDiscardedFieldNumber = 8;
  ::google::protobuf::uint64 chunks_discarded() const;
  void set_chunks_discarded(::google::protobuf::uint64 value);

  // optional uint64 patches_discarded = 9;
  bool has_patches_discarded() const;
  void clear_patches_discarded();
  static const int kPatchesDiscardedFieldNumber = 9;
  ::google::protobuf::uint64 patches_discarded() const;
  void set_patches_discarded(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.TraceStats)
 private:
  inline void set_has_producers_connected();
  inline void clear_has_producers_connected();
  inline void set_has_producers_seen();
  inline void clear_has_producers_seen();
  inline void set_has_data_sources_registered();
  inline void clear_has_data_sources_registered();
  inline void set_has_data_sources_seen();
  inline void clear_has_data_sources_seen();
  inline void set_has_tracing_sessions();
  inline void clear_has_tracing_sessions();
  inline void set_has_total_buffers();
  inline void clear_has_total_buffers();
  inline void set_has_chunks_discarded();
  inline void clear_has_chunks_discarded();
  inline void set_has_patches_discarded();
  inline void clear_has_patches_discarded();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceStats_BufferStats > buffer_stats_;
  ::google::protobuf::uint64 producers_seen_;
  ::google::protobuf::uint32 producers_connected_;
  ::google::protobuf::uint32 data_sources_registered_;
  ::google::protobuf::uint64 data_sources_seen_;
  ::google::protobuf::uint32 tracing_sessions_;
  ::google::protobuf::uint32 total_buffers_;
  ::google::protobuf::uint64 chunks_discarded_;
  ::google::protobuf::uint64 patches_discarded_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fcommon_2ftrace_5fstats_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fcommon_2ftrace_5fstats_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fcommon_2ftrace_5fstats_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fcommon_2ftrace_5fstats_2eproto();

  void InitAsDefaultInstance();
  static TraceStats* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// TraceStats_BufferStats

// optional uint64 buffer_size = 12;
inline bool TraceStats_BufferStats::has_buffer_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TraceStats_BufferStats::set_has_buffer_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TraceStats_BufferStats::clear_has_buffer_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TraceStats_BufferStats::clear_buffer_size() {
  buffer_size_ = GOOGLE_ULONGLONG(0);
  clear_has_buffer_size();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::buffer_size() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.buffer_size)
  return buffer_size_;
}
inline void TraceStats_BufferStats::set_buffer_size(::google::protobuf::uint64 value) {
  set_has_buffer_size();
  buffer_size_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.buffer_size)
}

// optional uint64 bytes_written = 1;
inline bool TraceStats_BufferStats::has_bytes_written() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TraceStats_BufferStats::set_has_bytes_written() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TraceStats_BufferStats::clear_has_bytes_written() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TraceStats_BufferStats::clear_bytes_written() {
  bytes_written_ = GOOGLE_ULONGLONG(0);
  clear_has_bytes_written();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::bytes_written() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.bytes_written)
  return bytes_written_;
}
inline void TraceStats_BufferStats::set_bytes_written(::google::protobuf::uint64 value) {
  set_has_bytes_written();
  bytes_written_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.bytes_written)
}

// optional uint64 bytes_overwritten = 13;
inline bool TraceStats_BufferStats::has_bytes_overwritten() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TraceStats_BufferStats::set_has_bytes_overwritten() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TraceStats_BufferStats::clear_has_bytes_overwritten() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TraceStats_BufferStats::clear_bytes_overwritten() {
  bytes_overwritten_ = GOOGLE_ULONGLONG(0);
  clear_has_bytes_overwritten();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::bytes_overwritten() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.bytes_overwritten)
  return bytes_overwritten_;
}
inline void TraceStats_BufferStats::set_bytes_overwritten(::google::protobuf::uint64 value) {
  set_has_bytes_overwritten();
  bytes_overwritten_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.bytes_overwritten)
}

// optional uint64 bytes_read = 14;
inline bool TraceStats_BufferStats::has_bytes_read() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TraceStats_BufferStats::set_has_bytes_read() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TraceStats_BufferStats::clear_has_bytes_read() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TraceStats_BufferStats::clear_bytes_read() {
  bytes_read_ = GOOGLE_ULONGLONG(0);
  clear_has_bytes_read();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::bytes_read() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.bytes_read)
  return bytes_read_;
}
inline void TraceStats_BufferStats::set_bytes_read(::google::protobuf::uint64 value) {
  set_has_bytes_read();
  bytes_read_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.bytes_read)
}

// optional uint64 padding_bytes_written = 15;
inline bool TraceStats_BufferStats::has_padding_bytes_written() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TraceStats_BufferStats::set_has_padding_bytes_written() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TraceStats_BufferStats::clear_has_padding_bytes_written() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TraceStats_BufferStats::clear_padding_bytes_written() {
  padding_bytes_written_ = GOOGLE_ULONGLONG(0);
  clear_has_padding_bytes_written();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::padding_bytes_written() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.padding_bytes_written)
  return padding_bytes_written_;
}
inline void TraceStats_BufferStats::set_padding_bytes_written(::google::protobuf::uint64 value) {
  set_has_padding_bytes_written();
  padding_bytes_written_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.padding_bytes_written)
}

// optional uint64 padding_bytes_cleared = 16;
inline bool TraceStats_BufferStats::has_padding_bytes_cleared() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TraceStats_BufferStats::set_has_padding_bytes_cleared() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TraceStats_BufferStats::clear_has_padding_bytes_cleared() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TraceStats_BufferStats::clear_padding_bytes_cleared() {
  padding_bytes_cleared_ = GOOGLE_ULONGLONG(0);
  clear_has_padding_bytes_cleared();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::padding_bytes_cleared() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.padding_bytes_cleared)
  return padding_bytes_cleared_;
}
inline void TraceStats_BufferStats::set_padding_bytes_cleared(::google::protobuf::uint64 value) {
  set_has_padding_bytes_cleared();
  padding_bytes_cleared_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.padding_bytes_cleared)
}

// optional uint64 chunks_written = 2;
inline bool TraceStats_BufferStats::has_chunks_written() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TraceStats_BufferStats::set_has_chunks_written() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TraceStats_BufferStats::clear_has_chunks_written() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TraceStats_BufferStats::clear_chunks_written() {
  chunks_written_ = GOOGLE_ULONGLONG(0);
  clear_has_chunks_written();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::chunks_written() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.chunks_written)
  return chunks_written_;
}
inline void TraceStats_BufferStats::set_chunks_written(::google::protobuf::uint64 value) {
  set_has_chunks_written();
  chunks_written_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.chunks_written)
}

// optional uint64 chunks_rewritten = 10;
inline bool TraceStats_BufferStats::has_chunks_rewritten() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TraceStats_BufferStats::set_has_chunks_rewritten() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TraceStats_BufferStats::clear_has_chunks_rewritten() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TraceStats_BufferStats::clear_chunks_rewritten() {
  chunks_rewritten_ = GOOGLE_ULONGLONG(0);
  clear_has_chunks_rewritten();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::chunks_rewritten() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.chunks_rewritten)
  return chunks_rewritten_;
}
inline void TraceStats_BufferStats::set_chunks_rewritten(::google::protobuf::uint64 value) {
  set_has_chunks_rewritten();
  chunks_rewritten_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.chunks_rewritten)
}

// optional uint64 chunks_overwritten = 3;
inline bool TraceStats_BufferStats::has_chunks_overwritten() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TraceStats_BufferStats::set_has_chunks_overwritten() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TraceStats_BufferStats::clear_has_chunks_overwritten() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TraceStats_BufferStats::clear_chunks_overwritten() {
  chunks_overwritten_ = GOOGLE_ULONGLONG(0);
  clear_has_chunks_overwritten();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::chunks_overwritten() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.chunks_overwritten)
  return chunks_overwritten_;
}
inline void TraceStats_BufferStats::set_chunks_overwritten(::google::protobuf::uint64 value) {
  set_has_chunks_overwritten();
  chunks_overwritten_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.chunks_overwritten)
}

// optional uint64 chunks_discarded = 18;
inline bool TraceStats_BufferStats::has_chunks_discarded() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TraceStats_BufferStats::set_has_chunks_discarded() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TraceStats_BufferStats::clear_has_chunks_discarded() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TraceStats_BufferStats::clear_chunks_discarded() {
  chunks_discarded_ = GOOGLE_ULONGLONG(0);
  clear_has_chunks_discarded();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::chunks_discarded() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.chunks_discarded)
  return chunks_discarded_;
}
inline void TraceStats_BufferStats::set_chunks_discarded(::google::protobuf::uint64 value) {
  set_has_chunks_discarded();
  chunks_discarded_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.chunks_discarded)
}

// optional uint64 chunks_read = 17;
inline bool TraceStats_BufferStats::has_chunks_read() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TraceStats_BufferStats::set_has_chunks_read() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TraceStats_BufferStats::clear_has_chunks_read() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TraceStats_BufferStats::clear_chunks_read() {
  chunks_read_ = GOOGLE_ULONGLONG(0);
  clear_has_chunks_read();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::chunks_read() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.chunks_read)
  return chunks_read_;
}
inline void TraceStats_BufferStats::set_chunks_read(::google::protobuf::uint64 value) {
  set_has_chunks_read();
  chunks_read_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.chunks_read)
}

// optional uint64 chunks_committed_out_of_order = 11;
inline bool TraceStats_BufferStats::has_chunks_committed_out_of_order() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TraceStats_BufferStats::set_has_chunks_committed_out_of_order() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TraceStats_BufferStats::clear_has_chunks_committed_out_of_order() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TraceStats_BufferStats::clear_chunks_committed_out_of_order() {
  chunks_committed_out_of_order_ = GOOGLE_ULONGLONG(0);
  clear_has_chunks_committed_out_of_order();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::chunks_committed_out_of_order() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.chunks_committed_out_of_order)
  return chunks_committed_out_of_order_;
}
inline void TraceStats_BufferStats::set_chunks_committed_out_of_order(::google::protobuf::uint64 value) {
  set_has_chunks_committed_out_of_order();
  chunks_committed_out_of_order_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.chunks_committed_out_of_order)
}

// optional uint64 write_wrap_count = 4;
inline bool TraceStats_BufferStats::has_write_wrap_count() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TraceStats_BufferStats::set_has_write_wrap_count() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TraceStats_BufferStats::clear_has_write_wrap_count() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TraceStats_BufferStats::clear_write_wrap_count() {
  write_wrap_count_ = GOOGLE_ULONGLONG(0);
  clear_has_write_wrap_count();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::write_wrap_count() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.write_wrap_count)
  return write_wrap_count_;
}
inline void TraceStats_BufferStats::set_write_wrap_count(::google::protobuf::uint64 value) {
  set_has_write_wrap_count();
  write_wrap_count_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.write_wrap_count)
}

// optional uint64 patches_succeeded = 5;
inline bool TraceStats_BufferStats::has_patches_succeeded() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TraceStats_BufferStats::set_has_patches_succeeded() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TraceStats_BufferStats::clear_has_patches_succeeded() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TraceStats_BufferStats::clear_patches_succeeded() {
  patches_succeeded_ = GOOGLE_ULONGLONG(0);
  clear_has_patches_succeeded();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::patches_succeeded() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.patches_succeeded)
  return patches_succeeded_;
}
inline void TraceStats_BufferStats::set_patches_succeeded(::google::protobuf::uint64 value) {
  set_has_patches_succeeded();
  patches_succeeded_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.patches_succeeded)
}

// optional uint64 patches_failed = 6;
inline bool TraceStats_BufferStats::has_patches_failed() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TraceStats_BufferStats::set_has_patches_failed() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TraceStats_BufferStats::clear_has_patches_failed() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TraceStats_BufferStats::clear_patches_failed() {
  patches_failed_ = GOOGLE_ULONGLONG(0);
  clear_has_patches_failed();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::patches_failed() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.patches_failed)
  return patches_failed_;
}
inline void TraceStats_BufferStats::set_patches_failed(::google::protobuf::uint64 value) {
  set_has_patches_failed();
  patches_failed_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.patches_failed)
}

// optional uint64 readaheads_succeeded = 7;
inline bool TraceStats_BufferStats::has_readaheads_succeeded() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TraceStats_BufferStats::set_has_readaheads_succeeded() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TraceStats_BufferStats::clear_has_readaheads_succeeded() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TraceStats_BufferStats::clear_readaheads_succeeded() {
  readaheads_succeeded_ = GOOGLE_ULONGLONG(0);
  clear_has_readaheads_succeeded();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::readaheads_succeeded() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.readaheads_succeeded)
  return readaheads_succeeded_;
}
inline void TraceStats_BufferStats::set_readaheads_succeeded(::google::protobuf::uint64 value) {
  set_has_readaheads_succeeded();
  readaheads_succeeded_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.readaheads_succeeded)
}

// optional uint64 readaheads_failed = 8;
inline bool TraceStats_BufferStats::has_readaheads_failed() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TraceStats_BufferStats::set_has_readaheads_failed() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TraceStats_BufferStats::clear_has_readaheads_failed() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TraceStats_BufferStats::clear_readaheads_failed() {
  readaheads_failed_ = GOOGLE_ULONGLONG(0);
  clear_has_readaheads_failed();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::readaheads_failed() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.readaheads_failed)
  return readaheads_failed_;
}
inline void TraceStats_BufferStats::set_readaheads_failed(::google::protobuf::uint64 value) {
  set_has_readaheads_failed();
  readaheads_failed_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.readaheads_failed)
}

// optional uint64 abi_violations = 9;
inline bool TraceStats_BufferStats::has_abi_violations() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TraceStats_BufferStats::set_has_abi_violations() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TraceStats_BufferStats::clear_has_abi_violations() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TraceStats_BufferStats::clear_abi_violations() {
  abi_violations_ = GOOGLE_ULONGLONG(0);
  clear_has_abi_violations();
}
inline ::google::protobuf::uint64 TraceStats_BufferStats::abi_violations() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.abi_violations)
  return abi_violations_;
}
inline void TraceStats_BufferStats::set_abi_violations(::google::protobuf::uint64 value) {
  set_has_abi_violations();
  abi_violations_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.abi_violations)
}

// -------------------------------------------------------------------

// TraceStats

// repeated .perfetto.protos.TraceStats.BufferStats buffer_stats = 1;
inline int TraceStats::buffer_stats_size() const {
  return buffer_stats_.size();
}
inline void TraceStats::clear_buffer_stats() {
  buffer_stats_.Clear();
}
inline const ::perfetto::protos::TraceStats_BufferStats& TraceStats::buffer_stats(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.buffer_stats)
  return buffer_stats_.Get(index);
}
inline ::perfetto::protos::TraceStats_BufferStats* TraceStats::mutable_buffer_stats(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceStats.buffer_stats)
  return buffer_stats_.Mutable(index);
}
inline ::perfetto::protos::TraceStats_BufferStats* TraceStats::add_buffer_stats() {
  // @@protoc_insertion_point(field_add:perfetto.protos.TraceStats.buffer_stats)
  return buffer_stats_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceStats_BufferStats >*
TraceStats::mutable_buffer_stats() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.TraceStats.buffer_stats)
  return &buffer_stats_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceStats_BufferStats >&
TraceStats::buffer_stats() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.TraceStats.buffer_stats)
  return buffer_stats_;
}

// optional uint32 producers_connected = 2;
inline bool TraceStats::has_producers_connected() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TraceStats::set_has_producers_connected() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TraceStats::clear_has_producers_connected() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TraceStats::clear_producers_connected() {
  producers_connected_ = 0u;
  clear_has_producers_connected();
}
inline ::google::protobuf::uint32 TraceStats::producers_connected() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.producers_connected)
  return producers_connected_;
}
inline void TraceStats::set_producers_connected(::google::protobuf::uint32 value) {
  set_has_producers_connected();
  producers_connected_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.producers_connected)
}

// optional uint64 producers_seen = 3;
inline bool TraceStats::has_producers_seen() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TraceStats::set_has_producers_seen() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TraceStats::clear_has_producers_seen() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TraceStats::clear_producers_seen() {
  producers_seen_ = GOOGLE_ULONGLONG(0);
  clear_has_producers_seen();
}
inline ::google::protobuf::uint64 TraceStats::producers_seen() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.producers_seen)
  return producers_seen_;
}
inline void TraceStats::set_producers_seen(::google::protobuf::uint64 value) {
  set_has_producers_seen();
  producers_seen_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.producers_seen)
}

// optional uint32 data_sources_registered = 4;
inline bool TraceStats::has_data_sources_registered() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TraceStats::set_has_data_sources_registered() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TraceStats::clear_has_data_sources_registered() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TraceStats::clear_data_sources_registered() {
  data_sources_registered_ = 0u;
  clear_has_data_sources_registered();
}
inline ::google::protobuf::uint32 TraceStats::data_sources_registered() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.data_sources_registered)
  return data_sources_registered_;
}
inline void TraceStats::set_data_sources_registered(::google::protobuf::uint32 value) {
  set_has_data_sources_registered();
  data_sources_registered_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.data_sources_registered)
}

// optional uint64 data_sources_seen = 5;
inline bool TraceStats::has_data_sources_seen() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TraceStats::set_has_data_sources_seen() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TraceStats::clear_has_data_sources_seen() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TraceStats::clear_data_sources_seen() {
  data_sources_seen_ = GOOGLE_ULONGLONG(0);
  clear_has_data_sources_seen();
}
inline ::google::protobuf::uint64 TraceStats::data_sources_seen() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.data_sources_seen)
  return data_sources_seen_;
}
inline void TraceStats::set_data_sources_seen(::google::protobuf::uint64 value) {
  set_has_data_sources_seen();
  data_sources_seen_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.data_sources_seen)
}

// optional uint32 tracing_sessions = 6;
inline bool TraceStats::has_tracing_sessions() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TraceStats::set_has_tracing_sessions() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TraceStats::clear_has_tracing_sessions() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TraceStats::clear_tracing_sessions() {
  tracing_sessions_ = 0u;
  clear_has_tracing_sessions();
}
inline ::google::protobuf::uint32 TraceStats::tracing_sessions() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.tracing_sessions)
  return tracing_sessions_;
}
inline void TraceStats::set_tracing_sessions(::google::protobuf::uint32 value) {
  set_has_tracing_sessions();
  tracing_sessions_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.tracing_sessions)
}

// optional uint32 total_buffers = 7;
inline bool TraceStats::has_total_buffers() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TraceStats::set_has_total_buffers() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TraceStats::clear_has_total_buffers() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TraceStats::clear_total_buffers() {
  total_buffers_ = 0u;
  clear_has_total_buffers();
}
inline ::google::protobuf::uint32 TraceStats::total_buffers() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.total_buffers)
  return total_buffers_;
}
inline void TraceStats::set_total_buffers(::google::protobuf::uint32 value) {
  set_has_total_buffers();
  total_buffers_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.total_buffers)
}

// optional uint64 chunks_discarded = 8;
inline bool TraceStats::has_chunks_discarded() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TraceStats::set_has_chunks_discarded() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TraceStats::clear_has_chunks_discarded() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TraceStats::clear_chunks_discarded() {
  chunks_discarded_ = GOOGLE_ULONGLONG(0);
  clear_has_chunks_discarded();
}
inline ::google::protobuf::uint64 TraceStats::chunks_discarded() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.chunks_discarded)
  return chunks_discarded_;
}
inline void TraceStats::set_chunks_discarded(::google::protobuf::uint64 value) {
  set_has_chunks_discarded();
  chunks_discarded_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.chunks_discarded)
}

// optional uint64 patches_discarded = 9;
inline bool TraceStats::has_patches_discarded() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TraceStats::set_has_patches_discarded() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TraceStats::clear_has_patches_discarded() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TraceStats::clear_patches_discarded() {
  patches_discarded_ = GOOGLE_ULONGLONG(0);
  clear_has_patches_discarded();
}
inline ::google::protobuf::uint64 TraceStats::patches_discarded() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.patches_discarded)
  return patches_discarded_;
}
inline void TraceStats::set_patches_discarded(::google::protobuf::uint64 value) {
  set_has_patches_discarded();
  patches_discarded_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.patches_discarded)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_perfetto_2fcommon_2ftrace_5fstats_2eproto__INCLUDED
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/common/trace_stats.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
// gen_amalgamated expanded: #include "perfetto/common/trace_stats.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

void protobuf_ShutdownFile_perfetto_2fcommon_2ftrace_5fstats_2eproto() {
  delete TraceStats::default_instance_;
  delete TraceStats_BufferStats::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_perfetto_2fcommon_2ftrace_5fstats_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_perfetto_2fcommon_2ftrace_5fstats_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  TraceStats::default_instance_ = new TraceStats();
  TraceStats_BufferStats::default_instance_ = new TraceStats_BufferStats();
  TraceStats::default_instance_->InitAsDefaultInstance();
  TraceStats_BufferStats::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_perfetto_2fcommon_2ftrace_5fstats_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_perfetto_2fcommon_2ftrace_5fstats_2eproto_once_);
void protobuf_AddDesc_perfetto_2fcommon_2ftrace_5fstats_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_perfetto_2fcommon_2ftrace_5fstats_2eproto_once_,
                 &protobuf_AddDesc_perfetto_2fcommon_2ftrace_5fstats_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_perfetto_2fcommon_2ftrace_5fstats_2eproto {
  StaticDescriptorInitializer_perfetto_2fcommon_2ftrace_5fstats_2eproto() {
    protobuf_AddDesc_perfetto_2fcommon_2ftrace_5fstats_2eproto();
  }
} static_descriptor_initializer_perfetto_2fcommon_2ftrace_5fstats_2eproto_;
#endif

namespace {

static void trace_stats_pb_MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
static void trace_stats_pb_MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

static ::std::string* MutableUnknownFieldsForTraceStats(
    TraceStats* ptr) {
  return ptr->mutable_unknown_fields();
}

static ::std::string* MutableUnknownFieldsForTraceStats_BufferStats(
    TraceStats_BufferStats* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TraceStats_BufferStats::kBufferSizeFieldNumber;
const int TraceStats_BufferStats::kBytesWrittenFieldNumber;
const int TraceStats_BufferStats::kBytesOverwrittenFieldNumber;
const int TraceStats_BufferStats::kBytesReadFieldNumber;
const int TraceStats_BufferStats::kPaddingBytesWrittenFieldNumber;
const int TraceStats_BufferStats::kPaddingBytesClearedFieldNumber;
const int TraceStats_BufferStats::kChunksWrittenFieldNumber;
const int TraceStats_BufferStats::kChunksRewrittenFieldNumber;
const int TraceStats_BufferStats::kChunksOverwrittenFieldNumber;
const int TraceStats_BufferStats::kChunksDiscardedFieldNumber;
const int TraceStats_BufferStats::kChunksReadFieldNumber;
const int TraceStats_BufferStats::kChunksCommittedOutOfOrderFieldNumber;
const int TraceStats_BufferStats::kWriteWrapCountFieldNumber;
const int TraceStats_BufferStats::kPatchesSucceededFieldNumber;
const int TraceStats_BufferStats::kPatchesFailedFieldNumber;
const int TraceStats_BufferStats::kReadaheadsSucceededFieldNumber;
const int TraceStats_BufferStats::kReadaheadsFailedFieldNumber;
const int TraceStats_BufferStats::kAbiViolationsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TraceStats_BufferStats::TraceStats_BufferStats()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.TraceStats.BufferStats)
}

void TraceStats_BufferStats::InitAsDefaultInstance() {
}

TraceStats_BufferStats::TraceStats_BufferStats(const TraceStats_BufferStats& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.TraceStats.BufferStats)
}

void TraceStats_BufferStats::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  buffer_size_ = GOOGLE_ULONGLONG(0);
  bytes_written_ = GOOGLE_ULONGLONG(0);
  bytes_overwritten_ = GOOGLE_ULONGLONG(0);
  bytes_read_ = GOOGLE_ULONGLONG(0);
  padding_bytes_written_ = GOOGLE_ULONGLONG(0);
  padding_bytes_cleared_ = GOOGLE_ULONGLONG(0);
  chunks_written_ = GOOGLE_ULONGLONG(0);
  chunks_rewritten_ = GOOGLE_ULONGLONG(0);
  chunks_overwritten_ = GOOGLE_ULONGLONG(0);
  chunks_discarded_ = GOOGLE_ULONGLONG(0);
  chunks_read_ = GOOGLE_ULONGLONG(0);
  chunks_committed_out_of_order_ = GOOGLE_ULONGLONG(0);
  write_wrap_count_ = GOOGLE_ULONGLONG(0);
  patches_succeeded_ = GOOGLE_ULONGLONG(0);
  patches_failed_ = GOOGLE_ULONGLONG(0);
  readaheads_succeeded_ = GOOGLE_ULONGLONG(0);
  readaheads_failed_ = GOOGLE_ULONGLONG(0);
  abi_violations_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TraceStats_BufferStats::~TraceStats_BufferStats() {
  // @@protoc_insertion_point(destructor:perfetto.protos.TraceStats.BufferStats)
  SharedDtor();
}

void TraceStats_BufferStats::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TraceStats_BufferStats::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TraceStats_BufferStats& TraceStats_BufferStats::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fcommon_2ftrace_5fstats_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fcommon_2ftrace_5fstats_2eproto();
#endif
  return *default_instance_;
}

TraceStats_BufferStats* TraceStats_BufferStats::default_instance_ = NULL;

TraceStats_BufferStats* TraceStats_BufferStats::New(::google::protobuf::Arena* arena) const {
  TraceStats_BufferStats* n = new TraceStats_BufferStats;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TraceStats_BufferStats::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.TraceStats.BufferStats)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(TraceStats_BufferStats, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<TraceStats_BufferStats*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    ZR_(buffer_size_, chunks_rewritten_);
  }
  if (_has_bits_[8 / 32] & 65280u) {
    ZR_(chunks_overwritten_, readaheads_succeeded_);
  }
  ZR_(readaheads_failed_, abi_violations_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool TraceStats_BufferStats::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForTraceStats_BufferStats, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.TraceStats.BufferStats)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 bytes_written = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &bytes_written_)));
          set_has_bytes_written();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_chunks_written;
        break;
      }

      // optional uint64 chunks_written = 2;
      case 2: {
        if (tag == 16) {
         parse_chunks_written:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &chunks_written_)));
          set_has_chunks_written();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_chunks_overwritten;
        break;
      }

      // optional uint64 chunks_overwritten = 3;
      case 3: {
        if (tag == 24) {
         parse_chunks_overwritten:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &chunks_overwritten_)));
          set_has_chunks_overwritten();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_write_wrap_count;
        break;
      }

      // optional uint64 write_wrap_count = 4;
      case 4: {
        if (tag == 32) {
         parse_write_wrap_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &write_wrap_count_)));
          set_has_write_wrap_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_patches_succeeded;
        break;
      }

      // optional uint64 patches_succeeded = 5;
      case 5: {
        if (tag == 40) {
         parse_patches_succeeded:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &patches_succeeded_)));
          set_has_patches_succeeded();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_patches_failed;
        break;
      }

      // optional uint64 patches_failed = 6;
      case 6: {
        if (tag == 48) {
         parse_patches_failed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &patches_failed_)));
          set_has_patches_failed();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_readaheads_succeeded;
        break;
      }

      // optional uint64 readaheads_succeeded = 7;
      case 7: {
        if (tag == 56) {
         parse_readaheads_succeeded:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &readaheads_succeeded_)));
          set_has_readaheads_succeeded();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_readaheads_failed;
        break;
      }

      // optional uint64 readaheads_failed = 8;
      case 8: {
        if (tag == 64) {
         parse_readaheads_failed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &readaheads_failed_)));
          set_has_readaheads_failed();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_abi_violations;
        break;
      }

      // optional uint64 abi_violations = 9;
      case 9: {
        if (tag == 72) {
         parse_abi_violations:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &abi_violations_)));
          set_has_abi_violations();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_chunks_rewritten;
        break;
      }

      // optional uint64 chunks_rewritten = 10;
      case 10: {
        if (tag == 80) {
         parse_chunks_rewritten:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &chunks_rewritten_)));
          set_has_chunks_rewritten();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_chunks_committed_out_of_order;
        break;
      }

      // optional uint64 chunks_committed_out_of_order = 11;
      case 11: {
        if (tag == 88) {
         parse_chunks_committed_out_of_order:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &chunks_committed_out_of_order_)));
          set_has_chunks_committed_out_of_order();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_buffer_size;
        break;
      }

      // optional uint64 buffer_size = 12;
      case 12: {
        if (tag == 96) {
         parse_buffer_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &buffer_size_)));
          set_has_buffer_size();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(104)) goto parse_bytes_overwritten;
        break;
      }

      // optional uint64 bytes_overwritten = 13;
      case 13: {
        if (tag == 104) {
         parse_bytes_overwritten:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &bytes_overwritten_)));
          set_has_bytes_overwritten();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(112)) goto parse_bytes_read;
        break;
      }

      // optional uint64 bytes_read = 14;
      case 14: {
        if (tag == 112) {
         parse_bytes_read:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &bytes_read_)));
          set_has_bytes_read();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(120)) goto parse_padding_bytes_written;
        break;
      }

      // optional uint64 padding_bytes_written = 15;
      case 15: {
        if (tag == 120) {
         parse_padding_bytes_written:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &padding_bytes_written_)));
          set_has_padding_bytes_written();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(128)) goto parse_padding_bytes_cleared;
        break;
      }

      // optional uint64 padding_bytes_cleared = 16;
      case 16: {
        if (tag == 128) {
         parse_padding_bytes_cleared:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &padding_bytes_cleared_)));
          set_has_padding_bytes_cleared();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(136)) goto parse_chunks_read;
        break;
      }

      // optional uint64 chunks_read = 17;
      case 17: {
        if (tag == 136) {
         parse_chunks_read:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &chunks_read_)));
          set_has_chunks_read();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(144)) goto parse_chunks_discarded;
        break;
      }

      // optional uint64 chunks_discarded = 18;
      case 18: {
        if (tag == 144) {
         parse_chunks_discarded:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &chunks_discarded_)));
          set_has_chunks_discarded();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.TraceStats.BufferStats)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.TraceStats.BufferStats)
  return false;
#undef DO_
}

void TraceStats_BufferStats::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.TraceStats.BufferStats)
  // optional uint64 bytes_written = 1;
  if (has_bytes_written()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->bytes_written(), output);
  }

  // optional uint64 chunks_written = 2;
  if (has_chunks_written()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->chunks_written(), output);
  }

  // optional uint64 chunks_overwritten = 3;
  if (has_chunks_overwritten()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->chunks_overwritten(), output);
  }

  // optional uint64 write_wrap_count = 4;
  if (has_write_wrap_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->write_wrap_count(), output);
  }

  // optional uint64 patches_succeeded = 5;
  if (has_patches_succeeded()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->patches_succeeded(), output);
  }

  // optional uint64 patches_failed = 6;
  if (has_patches_failed()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(6, this->patches_failed(), output);
  }

  // optional uint64 readaheads_succeeded = 7;
  if (has_readaheads_succeeded()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(7, this->readaheads_succeeded(), output);
  }

  // optional uint64 readaheads_failed = 8;
  if (has_readaheads_failed()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(8, this->readaheads_failed(), output);
  }

  // optional uint64 abi_violations = 9;
  if (has_abi_violations()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(9, this->abi_violations(), output);
  }

  // optional uint64 chunks_rewritten = 10;
  if (has_chunks_rewritten()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(10, this->chunks_rewritten(), output);
  }

  // optional uint64 chunks_committed_out_of_order = 11;
  if (has_chunks_committed_out_of_order()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(11, this->chunks_committed_out_of_order(), output);
  }

  // optional uint64 buffer_size = 12;
  if (has_buffer_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(12, this->buffer_size(), output);
  }

  // optional uint64 bytes_overwritten = 13;
  if (has_bytes_overwritten()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(13, this->bytes_overwritten(), output);
  }

  // optional uint64 bytes_read = 14;
  if (has_bytes_read()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(14, this->bytes_read(), output);
  }

  // optional uint64 padding_bytes_written = 15;
  if (has_padding_bytes_written()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(15, this->padding_bytes_written(), output);
  }

  // optional uint64 padding_bytes_cleared = 16;
  if (has_padding_bytes_cleared()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(16, this->padding_bytes_cleared(), output);
  }

  // optional uint64 chunks_read = 17;
  if (has_chunks_read()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(17, this->chunks_read(), output);
  }

  // optional uint64 chunks_discarded = 18;
  if (has_chunks_discarded()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(18, this->chunks_discarded(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.TraceStats.BufferStats)
}

int TraceStats_BufferStats::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.TraceStats.BufferStats)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 255u) {
    // optional uint64 buffer_size = 12;
    if (has_buffer_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->buffer_size());
    }

    // optional uint64 bytes_written = 1;
    if (has_bytes_written()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->bytes_written());
    }

    // optional uint64 bytes_overwritten = 13;
    if (has_bytes_overwritten()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->bytes_overwritten());
    }

    // optional uint64 bytes_read = 14;
    if (has_bytes_read()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->bytes_read());
    }

    // optional uint64 padding_bytes_written = 15;
    if (has_padding_bytes_written()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->padding_bytes_written());
    }

    // optional uint64 padding_bytes_cleared = 16;
    if (has_padding_bytes_cleared()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->padding_bytes_cleared());
    }

    // optional uint64 chunks_written = 2;
    if (has_chunks_written()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->chunks_written());
    }

    // optional uint64 chunks_rewritten = 10;
    if (has_chunks_rewritten()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->chunks_rewritten());
    }

  }
  if (_has_bits_[8 / 32] & 65280u) {
    // optional uint64 chunks_overwritten = 3;
    if (has_chunks_overwritten()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->chunks_overwritten());
    }

    // optional uint64 chunks_discarded = 18;
    if (has_chunks_discarded()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->chunks_discarded());
    }

    // optional uint64 chunks_read = 17;
    if (has_chunks_read()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->chunks_read());
    }

    // optional uint64 chunks_committed_out_of_order = 11;
    if (has_chunks_committed_out_of_order()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->chunks_committed_out_of_order());
    }

    // optional uint64 write_wrap_count = 4;
    if (has_write_wrap_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->write_wrap_count());
    }

    // optional uint64 patches_succeeded = 5;
    if (has_patches_succeeded()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->patches_succeeded());
    }

    // optional uint64 patches_failed = 6;
    if (has_patches_failed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->patches_failed());
    }

    // optional uint64 readaheads_succeeded = 7;
    if (has_readaheads_succeeded()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->readaheads_succeeded());
    }

  }
  if (_has_bits_[16 / 32] & 196608u) {
    // optional uint64 readaheads_failed = 8;
    if (has_readaheads_failed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->readaheads_failed());
    }

    // optional uint64 abi_violations = 9;
    if (has_abi_violations()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->abi_violations());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TraceStats_BufferStats::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TraceStats_BufferStats*>(&from));
}

void TraceStats_BufferStats::MergeFrom(const TraceStats_BufferStats& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.TraceStats.BufferStats)
  if (GOOGLE_PREDICT_FALSE(&from == this)) trace_stats_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_buffer_size()) {
      set_buffer_size(from.buffer_size());
    }
    if (from.has_bytes_written()) {
      set_bytes_written(from.bytes_written());
    }
    if (from.has_bytes_overwritten()) {
      set_bytes_overwritten(from.bytes_overwritten());
    }
    if (from.has_bytes_read()) {
      set_bytes_read(from.bytes_read());
    }
    if (from.has_padding_bytes_written()) {
      set_padding_bytes_written(from.padding_bytes_written());
    }
    if (from.has_padding_bytes_cleared()) {
      set_padding_bytes_cleared(from.padding_bytes_cleared());
    }
    if (from.has_chunks_written()) {
      set_chunks_written(from.chunks_written());
    }
    if (from.has_chunks_rewritten()) {
      set_chunks_rewritten(from.chunks_rewritten());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_chunks_overwritten()) {
      set_chunks_overwritten(from.chunks_overwritten());
    }
    if (from.has_chunks_discarded()) {
      set_chunks_discarded(from.chunks_discarded());
    }
    if (from.has_chunks_read()) {
      set_chunks_read(from.chunks_read());
    }
    if (from.has_chunks_committed_out_of_order()) {
      set_chunks_committed_out_of_order(from.chunks_committed_out_of_order());
    }
    if (from.has_write_wrap_count()) {
      set_write_wrap_count(from.write_wrap_count());
    }
    if (from.has_patches_succeeded()) {
      set_patches_succeeded(from.patches_succeeded());
    }
    if (from.has_patches_failed()) {
      set_patches_failed(from.patches_failed());
    }
    if (from.has_readaheads_succeeded()) {
      set_readaheads_succeeded(from.readaheads_succeeded());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_readaheads_failed()) {
      set_readaheads_failed(from.readaheads_failed());
    }
    if (from.has_abi_violations()) {
      set_abi_violations(from.abi_violations());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void TraceStats_BufferStats::CopyFrom(const TraceStats_BufferStats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.TraceStats.BufferStats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TraceStats_BufferStats::IsInitialized() const {

  return true;
}

void TraceStats_BufferStats::Swap(TraceStats_BufferStats* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TraceStats_BufferStats::InternalSwap(TraceStats_BufferStats* other) {
  std::swap(buffer_size_, other->buffer_size_);
  std::swap(bytes_written_, other->bytes_written_);
  std::swap(bytes_overwritten_, other->bytes_overwritten_);
  std::swap(bytes_read_, other->bytes_read_);
  std::swap(padding_bytes_written_, other->padding_bytes_written_);
  std::swap(padding_bytes_cleared_, other->padding_bytes_cleared_);
  std::swap(chunks_written_, other->chunks_written_);
  std::swap(chunks_rewritten_, other->chunks_rewritten_);
  std::swap(chunks_overwritten_, other->chunks_overwritten_);
  std::swap(chunks_discarded_, other->chunks_discarded_);
  std::swap(chunks_read_, other->chunks_read_);
  std::swap(chunks_committed_out_of_order_, other->chunks_committed_out_of_order_);
  std::swap(write_wrap_count_, other->write_wrap_count_);
  std::swap(patches_succeeded_, other->patches_succeeded_);
  std::swap(patches_failed_, other->patches_failed_);
  std::swap(readaheads_succeeded_, other->readaheads_succeeded_);
  std::swap(readaheads_failed_, other->readaheads_failed_);
  std::swap(abi_violations_, other->abi_violations_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string TraceStats_BufferStats::GetTypeName() const {
  return "perfetto.protos.TraceStats.BufferStats";
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TraceStats::kBufferStatsFieldNumber;
const int TraceStats::kProducersConnectedFieldNumber;
const int TraceStats::kProducersSeenFieldNumber;
const int TraceStats::kDataSourcesRegisteredFieldNumber;
const int TraceStats::kDataSourcesSeenFieldNumber;
const int TraceStats::kTracingSessionsFieldNumber;
const int TraceStats::kTotalBuffersFieldNumber;
const int TraceStats::kChunksDiscardedFieldNumber;
const int TraceStats::kPatchesDiscardedFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TraceStats::TraceStats()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.TraceStats)
}

void TraceStats::InitAsDefaultInstance() {
}

TraceStats::TraceStats(const TraceStats& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.TraceStats)
}

void TraceStats::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  producers_connected_ = 0u;
  producers_seen_ = GOOGLE_ULONGLONG(0);
  data_sources_registered_ = 0u;
  data_sources_seen_ = GOOGLE_ULONGLONG(0);
  tracing_sessions_ = 0u;
  total_buffers_ = 0u;
  chunks_discarded_ = GOOGLE_ULONGLONG(0);
  patches_discarded_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TraceStats::~TraceStats() {
  // @@protoc_insertion_point(destructor:perfetto.protos.TraceStats)
  SharedDtor();
}

void TraceStats::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TraceStats::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TraceStats& TraceStats::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fcommon_2ftrace_5fstats_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fcommon_2ftrace_5fstats_2eproto();
#endif
  return *default_instance_;
}

TraceStats* TraceStats::default_instance_ = NULL;

TraceStats* TraceStats::New(::google::protobuf::Arena* arena) const {
  TraceStats* n = new TraceStats;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TraceStats::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.TraceStats)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(TraceStats, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<TraceStats*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 254u) {
    ZR_(producers_seen_, chunks_discarded_);
  }
  patches_discarded_ = GOOGLE_ULONGLONG(0);

#undef ZR_HELPER_
#undef ZR_

  buffer_stats_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool TraceStats::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForTraceStats, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.TraceStats)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .perfetto.protos.TraceStats.BufferStats buffer_stats = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_buffer_stats:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_buffer_stats()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_buffer_stats;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(16)) goto parse_producers_connected;
        break;
      }

      // optional uint32 producers_connected = 2;
      case 2: {
        if (tag == 16) {
         parse_producers_connected:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &producers_connected_)));
          set_has_producers_connected();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_producers_seen;
        break;
      }

      // optional uint64 producers_seen = 3;
      case 3: {
        if (tag == 24) {
         parse_producers_seen:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &producers_seen_)));
          set_has_producers_seen();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_data_sources_registered;
        break;
      }

      // optional uint32 data_sources_registered = 4;
      case 4: {
        if (tag == 32) {
         parse_data_sources_registered:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &data_sources_registered_)));
          set_has_data_sources_registered();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_data_sources_seen;
        break;
      }

      // optional uint64 data_sources_seen = 5;
      case 5: {
        if (tag == 40) {
         parse_data_sources_seen:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &data_sources_seen_)));
          set_has_data_sources_seen();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_tracing_sessions;
        break;
      }

      // optional uint32 tracing_sessions = 6;
      case 6: {
        if (tag == 48) {
         parse_tracing_sessions:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &tracing_sessions_)));
          set_has_tracing_sessions();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_total_buffers;
        break;
      }

      // optional uint32 total_buffers = 7;
      case 7: {
        if (tag == 56) {
         parse_total_buffers:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &total_buffers_)));
          set_has_total_buffers();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_chunks_discarded;
        break;
      }

      // optional uint64 chunks_discarded = 8;
      case 8: {
        if (tag == 64) {
         parse_chunks_discarded:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &chunks_discarded_)));
          set_has_chunks_discarded();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_patches_discarded;
        break;
      }

      // optional uint64 patches_discarded = 9;
      case 9: {
        if (tag == 72) {
         parse_patches_discarded:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &patches_discarded_)));
          set_has_patches_discarded();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.TraceStats)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.TraceStats)
  return false;
#undef DO_
}

void TraceStats::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.TraceStats)
  // repeated .perfetto.protos.TraceStats.BufferStats buffer_stats = 1;
  for (unsigned int i = 0, n = this->buffer_stats_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->buffer_stats(i), output);
  }

  // optional uint32 producers_connected = 2;
  if (has_producers_connected()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->producers_connected(), output);
  }

  // optional uint64 producers_seen = 3;
  if (has_producers_seen()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->producers_seen(), output);
  }

  // optional uint32 data_sources_registered = 4;
  if (has_data_sources_registered()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->data_sources_registered(), output);
  }

  // optional uint64 data_sources_seen = 5;
  if (has_data_sources_seen()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->data_sources_seen(), output);
  }

  // optional uint32 tracing_sessions = 6;
  if (has_tracing_sessions()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->tracing_sessions(), output);
  }

  // optional uint32 total_buffers = 7;
  if (has_total_buffers()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->total_buffers(), output);
  }

  // optional uint64 chunks_discarded = 8;
  if (has_chunks_discarded()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(8, this->chunks_discarded(), output);
  }

  // optional uint64 patches_discarded = 9;
  if (has_patches_discarded()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(9, this->patches_discarded(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.TraceStats)
}

int TraceStats::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.TraceStats)
  int total_size = 0;

  if (_has_bits_[1 / 32] & 254u) {
    // optional uint32 producers_connected = 2;
    if (has_producers_connected()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->producers_connected());
    }

    // optional uint64 producers_seen = 3;
    if (has_producers_seen()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->producers_seen());
    }

    // optional uint32 data_sources_registered = 4;
    if (has_data_sources_registered()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->data_sources_registered());
    }

    // optional uint64 data_sources_seen = 5;
    if (has_data_sources_seen()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->data_sources_seen());
    }

    // optional uint32 tracing_sessions = 6;
    if (has_tracing_sessions()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->tracing_sessions());
    }

    // optional uint32 total_buffers = 7;
    if (has_total_buffers()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->total_buffers());
    }

    // optional uint64 chunks_discarded = 8;
    if (has_chunks_discarded()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->chunks_discarded());
    }

  }
  // optional uint64 patches_discarded = 9;
  if (has_patches_discarded()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->patches_discarded());
  }

  // repeated .perfetto.protos.TraceStats.BufferStats buffer_stats = 1;
  total_size += 1 * this->buffer_stats_size();
  for (int i = 0; i < this->buffer_stats_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->buffer_stats(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TraceStats::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TraceStats*>(&from));
}

void TraceStats::MergeFrom(const TraceStats& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.TraceStats)
  if (GOOGLE_PREDICT_FALSE(&from == this)) trace_stats_pb_MergeFromFail(__LINE__);
  buffer_stats_.MergeFrom(from.buffer_stats_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_producers_connected()) {
      set_producers_connected(from.producers_connected());
    }
    if (from.has_producers_seen()) {
      set_producers_seen(from.producers_seen());
    }
    if (from.has_data_sources_registered()) {
      set_data_sources_registered(from.data_sources_registered());
    }
    if (from.has_data_sources_seen()) {
      set_data_sources_seen(from.data_sources_seen());
    }
    if (from.has_tracing_sessions()) {
      set_tracing_sessions(from.tracing_sessions());
    }
    if (from.has_total_buffers()) {
      set_total_buffers(from.total_buffers());
    }
    if (from.has_chunks_discarded()) {
      set_chunks_discarded(from.chunks_discarded());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_patches_discarded()) {
      set_patches_discarded(from.patches_discarded());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void TraceStats::CopyFrom(const TraceStats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.TraceStats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TraceStats::IsInitialized() const {

  return true;
}

void TraceStats::Swap(TraceStats* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TraceStats::InternalSwap(TraceStats* other) {
  buffer_stats_.UnsafeArenaSwap(&other->buffer_stats_);
  std::swap(producers_connected_, other->producers_connected_);
  std::swap(producers_seen_, other->producers_seen_);
  std::swap(data_sources_registered_, other->data_sources_registered_);
  std::swap(data_sources_seen_, other->data_sources_seen_);
  std::swap(tracing_sessions_, other->tracing_sessions_);
  std::swap(total_buffers_, other->total_buffers_);
  std::swap(chunks_discarded_, other->chunks_discarded_);
  std::swap(patches_discarded_, other->patches_discarded_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string TraceStats::GetTypeName() const {
  return "perfetto.protos.TraceStats";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TraceStats_BufferStats

// optional uint64 buffer_size = 12;
bool TraceStats_BufferStats::has_buffer_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TraceStats_BufferStats::set_has_buffer_size() {
  _has_bits_[0] |= 0x00000001u;
}
void TraceStats_BufferStats::clear_has_buffer_size() {
  _has_bits_[0] &= ~0x00000001u;
}
void TraceStats_BufferStats::clear_buffer_size() {
  buffer_size_ = GOOGLE_ULONGLONG(0);
  clear_has_buffer_size();
}
 ::google::protobuf::uint64 TraceStats_BufferStats::buffer_size() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.buffer_size)
  return buffer_size_;
}
 void TraceStats_BufferStats::set_buffer_size(::google::protobuf::uint64 value) {
  set_has_buffer_size();
  buffer_size_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.buffer_size)
}

// optional uint64 bytes_written = 1;
bool TraceStats_BufferStats::has_bytes_written() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void TraceStats_BufferStats::set_has_bytes_written() {
  _has_bits_[0] |= 0x00000002u;
}
void TraceStats_BufferStats::clear_has_bytes_written() {
  _has_bits_[0] &= ~0x00000002u;
}
void TraceStats_BufferStats::clear_bytes_written() {
  bytes_written_ = GOOGLE_ULONGLONG(0);
  clear_has_bytes_written();
}
 ::google::protobuf::uint64 TraceStats_BufferStats::bytes_written() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.bytes_written)
  return bytes_written_;
}
 void TraceStats_BufferStats::set_bytes_written(::google::protobuf::uint64 value) {
  set_has_bytes_written();
  bytes_written_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.bytes_written)
}

// optional uint64 bytes_overwritten = 13;
bool TraceStats_BufferStats::has_bytes_overwritten() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void TraceStats_BufferStats::set_has_bytes_overwritten() {
  _has_bits_[0] |= 0x00000004u;
}
void TraceStats_BufferStats::clear_has_bytes_overwritten() {
  _has_bits_[0] &= ~0x00000004u;
}
void TraceStats_BufferStats::clear_bytes_overwritten() {
  bytes_overwritten_ = GOOGLE_ULONGLONG(0);
  clear_has_bytes_overwritten();
}
 ::google::protobuf::uint64 TraceStats_BufferStats::bytes_overwritten() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.bytes_overwritten)
  return bytes_overwritten_;
}
 void TraceStats_BufferStats::set_bytes_overwritten(::google::protobuf::uint64 value) {
  set_has_bytes_overwritten();
  bytes_overwritten_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.bytes_overwritten)
}

// optional uint64 bytes_read = 14;
bool TraceStats_BufferStats::has_bytes_read() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void TraceStats_BufferStats::set_has_bytes_read() {
  _has_bits_[0] |= 0x00000008u;
}
void TraceStats_BufferStats::clear_has_bytes_read() {
  _has_bits_[0] &= ~0x00000008u;
}
void TraceStats_BufferStats::clear_bytes_read() {
  bytes_read_ = GOOGLE_ULONGLONG(0);
  clear_has_bytes_read();
}
 ::google::protobuf::uint64 TraceStats_BufferStats::bytes_read() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.bytes_read)
  return bytes_read_;
}
 void TraceStats_BufferStats::set_bytes_read(::google::protobuf::uint64 value) {
  set_has_bytes_read();
  bytes_read_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.bytes_read)
}

// optional uint64 padding_bytes_written = 15;
bool TraceStats_BufferStats::has_padding_bytes_written() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void TraceStats_BufferStats::set_has_padding_bytes_written() {
  _has_bits_[0] |= 0x00000010u;
}
void TraceStats_BufferStats::clear_has_padding_bytes_written() {
  _has_bits_[0] &= ~0x00000010u;
}
void TraceStats_BufferStats::clear_padding_bytes_written() {
  padding_bytes_written_ = GOOGLE_ULONGLONG(0);
  clear_has_padding_bytes_written();
}
 ::google::protobuf::uint64 TraceStats_BufferStats::padding_bytes_written() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.padding_bytes_written)
  return padding_bytes_written_;
}
 void TraceStats_BufferStats::set_padding_bytes_written(::google::protobuf::uint64 value) {
  set_has_padding_bytes_written();
  padding_bytes_written_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.padding_bytes_written)
}

// optional uint64 padding_bytes_cleared = 16;
bool TraceStats_BufferStats::has_padding_bytes_cleared() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void TraceStats_BufferStats::set_has_padding_bytes_cleared() {
  _has_bits_[0] |= 0x00000020u;
}
void TraceStats_BufferStats::clear_has_padding_bytes_cleared() {
  _has_bits_[0] &= ~0x00000020u;
}
void TraceStats_BufferStats::clear_padding_bytes_cleared() {
  padding_bytes_cleared_ = GOOGLE_ULONGLONG(0);
  clear_has_padding_bytes_cleared();
}
 ::google::protobuf::uint64 TraceStats_BufferStats::padding_bytes_cleared() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.padding_bytes_cleared)
  return padding_bytes_cleared_;
}
 void TraceStats_BufferStats::set_padding_bytes_cleared(::google::protobuf::uint64 value) {
  set_has_padding_bytes_cleared();
  padding_bytes_cleared_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.padding_bytes_cleared)
}

// optional uint64 chunks_written = 2;
bool TraceStats_BufferStats::has_chunks_written() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void TraceStats_BufferStats::set_has_chunks_written() {
  _has_bits_[0] |= 0x00000040u;
}
void TraceStats_BufferStats::clear_has_chunks_written() {
  _has_bits_[0] &= ~0x00000040u;
}
void TraceStats_BufferStats::clear_chunks_written() {
  chunks_written_ = GOOGLE_ULONGLONG(0);
  clear_has_chunks_written();
}
 ::google::protobuf::uint64 TraceStats_BufferStats::chunks_written() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.chunks_written)
  return chunks_written_;
}
 void TraceStats_BufferStats::set_chunks_written(::google::protobuf::uint64 value) {
  set_has_chunks_written();
  chunks_written_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.chunks_written)
}

// optional uint64 chunks_rewritten = 10;
bool TraceStats_BufferStats::has_chunks_rewritten() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void TraceStats_BufferStats::set_has_chunks_rewritten() {
  _has_bits_[0] |= 0x00000080u;
}
void TraceStats_BufferStats::clear_has_chunks_rewritten() {
  _has_bits_[0] &= ~0x00000080u;
}
void TraceStats_BufferStats::clear_chunks_rewritten() {
  chunks_rewritten_ = GOOGLE_ULONGLONG(0);
  clear_has_chunks_rewritten();
}
 ::google::protobuf::uint64 TraceStats_BufferStats::chunks_rewritten() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.chunks_rewritten)
  return chunks_rewritten_;
}
 void TraceStats_BufferStats::set_chunks_rewritten(::google::protobuf::uint64 value) {
  set_has_chunks_rewritten();
  chunks_rewritten_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.chunks_rewritten)
}

// optional uint64 chunks_overwritten = 3;
bool TraceStats_BufferStats::has_chunks_overwritten() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void TraceStats_BufferStats::set_has_chunks_overwritten() {
  _has_bits_[0] |= 0x00000100u;
}
void TraceStats_BufferStats::clear_has_chunks_overwritten() {
  _has_bits_[0] &= ~0x00000100u;
}
void TraceStats_BufferStats::clear_chunks_overwritten() {
  chunks_overwritten_ = GOOGLE_ULONGLONG(0);
  clear_has_chunks_overwritten();
}
 ::google::protobuf::uint64 TraceStats_BufferStats::chunks_overwritten() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.chunks_overwritten)
  return chunks_overwritten_;
}
 void TraceStats_BufferStats::set_chunks_overwritten(::google::protobuf::uint64 value) {
  set_has_chunks_overwritten();
  chunks_overwritten_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.chunks_overwritten)
}

// optional uint64 chunks_discarded = 18;
bool TraceStats_BufferStats::has_chunks_discarded() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void TraceStats_BufferStats::set_has_chunks_discarded() {
  _has_bits_[0] |= 0x00000200u;
}
void TraceStats_BufferStats::clear_has_chunks_discarded() {
  _has_bits_[0] &= ~0x00000200u;
}
void TraceStats_BufferStats::clear_chunks_discarded() {
  chunks_discarded_ = GOOGLE_ULONGLONG(0);
  clear_has_chunks_discarded();
}
 ::google::protobuf::uint64 TraceStats_BufferStats::chunks_discarded() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.chunks_discarded)
  return chunks_discarded_;
}
 void TraceStats_BufferStats::set_chunks_discarded(::google::protobuf::uint64 value) {
  set_has_chunks_discarded();
  chunks_discarded_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.chunks_discarded)
}

// optional uint64 chunks_read = 17;
bool TraceStats_BufferStats::has_chunks_read() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
void TraceStats_BufferStats::set_has_chunks_read() {
  _has_bits_[0] |= 0x00000400u;
}
void TraceStats_BufferStats::clear_has_chunks_read() {
  _has_bits_[0] &= ~0x00000400u;
}
void TraceStats_BufferStats::clear_chunks_read() {
  chunks_read_ = GOOGLE_ULONGLONG(0);
  clear_has_chunks_read();
}
 ::google::protobuf::uint64 TraceStats_BufferStats::chunks_read() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.chunks_read)
  return chunks_read_;
}
 void TraceStats_BufferStats::set_chunks_read(::google::protobuf::uint64 value) {
  set_has_chunks_read();
  chunks_read_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.chunks_read)
}

// optional uint64 chunks_committed_out_of_order = 11;
bool TraceStats_BufferStats::has_chunks_committed_out_of_order() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
void TraceStats_BufferStats::set_has_chunks_committed_out_of_order() {
  _has_bits_[0] |= 0x00000800u;
}
void TraceStats_BufferStats::clear_has_chunks_committed_out_of_order() {
  _has_bits_[0] &= ~0x00000800u;
}
void TraceStats_BufferStats::clear_chunks_committed_out_of_order() {
  chunks_committed_out_of_order_ = GOOGLE_ULONGLONG(0);
  clear_has_chunks_committed_out_of_order();
}
 ::google::protobuf::uint64 TraceStats_BufferStats::chunks_committed_out_of_order() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.chunks_committed_out_of_order)
  return chunks_committed_out_of_order_;
}
 void TraceStats_BufferStats::set_chunks_committed_out_of_order(::google::protobuf::uint64 value) {
  set_has_chunks_committed_out_of_order();
  chunks_committed_out_of_order_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.chunks_committed_out_of_order)
}

// optional uint64 write_wrap_count = 4;
bool TraceStats_BufferStats::has_write_wrap_count() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
void TraceStats_BufferStats::set_has_write_wrap_count() {
  _has_bits_[0] |= 0x00001000u;
}
void TraceStats_BufferStats::clear_has_write_wrap_count() {
  _has_bits_[0] &= ~0x00001000u;
}
void TraceStats_BufferStats::clear_write_wrap_count() {
  write_wrap_count_ = GOOGLE_ULONGLONG(0);
  clear_has_write_wrap_count();
}
 ::google::protobuf::uint64 TraceStats_BufferStats::write_wrap_count() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.write_wrap_count)
  return write_wrap_count_;
}
 void TraceStats_BufferStats::set_write_wrap_count(::google::protobuf::uint64 value) {
  set_has_write_wrap_count();
  write_wrap_count_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.write_wrap_count)
}

// optional uint64 patches_succeeded = 5;
bool TraceStats_BufferStats::has_patches_succeeded() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
void TraceStats_BufferStats::set_has_patches_succeeded() {
  _has_bits_[0] |= 0x00002000u;
}
void TraceStats_BufferStats::clear_has_patches_succeeded() {
  _has_bits_[0] &= ~0x00002000u;
}
void TraceStats_BufferStats::clear_patches_succeeded() {
  patches_succeeded_ = GOOGLE_ULONGLONG(0);
  clear_has_patches_succeeded();
}
 ::google::protobuf::uint64 TraceStats_BufferStats::patches_succeeded() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.patches_succeeded)
  return patches_succeeded_;
}
 void TraceStats_BufferStats::set_patches_succeeded(::google::protobuf::uint64 value) {
  set_has_patches_succeeded();
  patches_succeeded_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.patches_succeeded)
}

// optional uint64 patches_failed = 6;
bool TraceStats_BufferStats::has_patches_failed() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
void TraceStats_BufferStats::set_has_patches_failed() {
  _has_bits_[0] |= 0x00004000u;
}
void TraceStats_BufferStats::clear_has_patches_failed() {
  _has_bits_[0] &= ~0x00004000u;
}
void TraceStats_BufferStats::clear_patches_failed() {
  patches_failed_ = GOOGLE_ULONGLONG(0);
  clear_has_patches_failed();
}
 ::google::protobuf::uint64 TraceStats_BufferStats::patches_failed() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.patches_failed)
  return patches_failed_;
}
 void TraceStats_BufferStats::set_patches_failed(::google::protobuf::uint64 value) {
  set_has_patches_failed();
  patches_failed_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.patches_failed)
}

// optional uint64 readaheads_succeeded = 7;
bool TraceStats_BufferStats::has_readaheads_succeeded() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
void TraceStats_BufferStats::set_has_readaheads_succeeded() {
  _has_bits_[0] |= 0x00008000u;
}
void TraceStats_BufferStats::clear_has_readaheads_succeeded() {
  _has_bits_[0] &= ~0x00008000u;
}
void TraceStats_BufferStats::clear_readaheads_succeeded() {
  readaheads_succeeded_ = GOOGLE_ULONGLONG(0);
  clear_has_readaheads_succeeded();
}
 ::google::protobuf::uint64 TraceStats_BufferStats::readaheads_succeeded() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.readaheads_succeeded)
  return readaheads_succeeded_;
}
 void TraceStats_BufferStats::set_readaheads_succeeded(::google::protobuf::uint64 value) {
  set_has_readaheads_succeeded();
  readaheads_succeeded_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.readaheads_succeeded)
}

// optional uint64 readaheads_failed = 8;
bool TraceStats_BufferStats::has_readaheads_failed() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
void TraceStats_BufferStats::set_has_readaheads_failed() {
  _has_bits_[0] |= 0x00010000u;
}
void TraceStats_BufferStats::clear_has_readaheads_failed() {
  _has_bits_[0] &= ~0x00010000u;
}
void TraceStats_BufferStats::clear_readaheads_failed() {
  readaheads_failed_ = GOOGLE_ULONGLONG(0);
  clear_has_readaheads_failed();
}
 ::google::protobuf::uint64 TraceStats_BufferStats::readaheads_failed() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.readaheads_failed)
  return readaheads_failed_;
}
 void TraceStats_BufferStats::set_readaheads_failed(::google::protobuf::uint64 value) {
  set_has_readaheads_failed();
  readaheads_failed_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.readaheads_failed)
}

// optional uint64 abi_violations = 9;
bool TraceStats_BufferStats::has_abi_violations() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
void TraceStats_BufferStats::set_has_abi_violations() {
  _has_bits_[0] |= 0x00020000u;
}
void TraceStats_BufferStats::clear_has_abi_violations() {
  _has_bits_[0] &= ~0x00020000u;
}
void TraceStats_BufferStats::clear_abi_violations() {
  abi_violations_ = GOOGLE_ULONGLONG(0);
  clear_has_abi_violations();
}
 ::google::protobuf::uint64 TraceStats_BufferStats::abi_violations() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.BufferStats.abi_violations)
  return abi_violations_;
}
 void TraceStats_BufferStats::set_abi_violations(::google::protobuf::uint64 value) {
  set_has_abi_violations();
  abi_violations_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.BufferStats.abi_violations)
}

// -------------------------------------------------------------------

// TraceStats

// repeated .perfetto.protos.TraceStats.BufferStats buffer_stats = 1;
int TraceStats::buffer_stats_size() const {
  return buffer_stats_.size();
}
void TraceStats::clear_buffer_stats() {
  buffer_stats_.Clear();
}
const ::perfetto::protos::TraceStats_BufferStats& TraceStats::buffer_stats(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.buffer_stats)
  return buffer_stats_.Get(index);
}
::perfetto::protos::TraceStats_BufferStats* TraceStats::mutable_buffer_stats(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceStats.buffer_stats)
  return buffer_stats_.Mutable(index);
}
::perfetto::protos::TraceStats_BufferStats* TraceStats::add_buffer_stats() {
  // @@protoc_insertion_point(field_add:perfetto.protos.TraceStats.buffer_stats)
  return buffer_stats_.Add();
}
::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceStats_BufferStats >*
TraceStats::mutable_buffer_stats() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.TraceStats.buffer_stats)
  return &buffer_stats_;
}
const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceStats_BufferStats >&
TraceStats::buffer_stats() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.TraceStats.buffer_stats)
  return buffer_stats_;
}

// optional uint32 producers_connected = 2;
bool TraceStats::has_producers_connected() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void TraceStats::set_has_producers_connected() {
  _has_bits_[0] |= 0x00000002u;
}
void TraceStats::clear_has_producers_connected() {
  _has_bits_[0] &= ~0x00000002u;
}
void TraceStats::clear_producers_connected() {
  producers_connected_ = 0u;
  clear_has_producers_connected();
}
 ::google::protobuf::uint32 TraceStats::producers_connected() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.producers_connected)
  return producers_connected_;
}
 void TraceStats::set_producers_connected(::google::protobuf::uint32 value) {
  set_has_producers_connected();
  producers_connected_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.producers_connected)
}

// optional uint64 producers_seen = 3;
bool TraceStats::has_producers_seen() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void TraceStats::set_has_producers_seen() {
  _has_bits_[0] |= 0x00000004u;
}
void TraceStats::clear_has_producers_seen() {
  _has_bits_[0] &= ~0x00000004u;
}
void TraceStats::clear_producers_seen() {
  producers_seen_ = GOOGLE_ULONGLONG(0);
  clear_has_producers_seen();
}
 ::google::protobuf::uint64 TraceStats::producers_seen() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.producers_seen)
  return producers_seen_;
}
 void TraceStats::set_producers_seen(::google::protobuf::uint64 value) {
  set_has_producers_seen();
  producers_seen_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.producers_seen)
}

// optional uint32 data_sources_registered = 4;
bool TraceStats::has_data_sources_registered() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void TraceStats::set_has_data_sources_registered() {
  _has_bits_[0] |= 0x00000008u;
}
void TraceStats::clear_has_data_sources_registered() {
  _has_bits_[0] &= ~0x00000008u;
}
void TraceStats::clear_data_sources_registered() {
  data_sources_registered_ = 0u;
  clear_has_data_sources_registered();
}
 ::google::protobuf::uint32 TraceStats::data_sources_registered() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.data_sources_registered)
  return data_sources_registered_;
}
 void TraceStats::set_data_sources_registered(::google::protobuf::uint32 value) {
  set_has_data_sources_registered();
  data_sources_registered_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.data_sources_registered)
}

// optional uint64 data_sources_seen = 5;
bool TraceStats::has_data_sources_seen() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void TraceStats::set_has_data_sources_seen() {
  _has_bits_[0] |= 0x00000010u;
}
void TraceStats::clear_has_data_sources_seen() {
  _has_bits_[0] &= ~0x00000010u;
}
void TraceStats::clear_data_sources_seen() {
  data_sources_seen_ = GOOGLE_ULONGLONG(0);
  clear_has_data_sources_seen();
}
 ::google::protobuf::uint64 TraceStats::data_sources_seen() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.data_sources_seen)
  return data_sources_seen_;
}
 void TraceStats::set_data_sources_seen(::google::protobuf::uint64 value) {
  set_has_data_sources_seen();
  data_sources_seen_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.data_sources_seen)
}

// optional uint32 tracing_sessions = 6;
bool TraceStats::has_tracing_sessions() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void TraceStats::set_has_tracing_sessions() {
  _has_bits_[0] |= 0x00000020u;
}
void TraceStats::clear_has_tracing_sessions() {
  _has_bits_[0] &= ~0x00000020u;
}
void TraceStats::clear_tracing_sessions() {
  tracing_sessions_ = 0u;
  clear_has_tracing_sessions();
}
 ::google::protobuf::uint32 TraceStats::tracing_sessions() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.tracing_sessions)
  return tracing_sessions_;
}
 void TraceStats::set_tracing_sessions(::google::protobuf::uint32 value) {
  set_has_tracing_sessions();
  tracing_sessions_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.tracing_sessions)
}

// optional uint32 total_buffers = 7;
bool TraceStats::has_total_buffers() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void TraceStats::set_has_total_buffers() {
  _has_bits_[0] |= 0x00000040u;
}
void TraceStats::clear_has_total_buffers() {
  _has_bits_[0] &= ~0x00000040u;
}
void TraceStats::clear_total_buffers() {
  total_buffers_ = 0u;
  clear_has_total_buffers();
}
 ::google::protobuf::uint32 TraceStats::total_buffers() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.total_buffers)
  return total_buffers_;
}
 void TraceStats::set_total_buffers(::google::protobuf::uint32 value) {
  set_has_total_buffers();
  total_buffers_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.total_buffers)
}

// optional uint64 chunks_discarded = 8;
bool TraceStats::has_chunks_discarded() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void TraceStats::set_has_chunks_discarded() {
  _has_bits_[0] |= 0x00000080u;
}
void TraceStats::clear_has_chunks_discarded() {
  _has_bits_[0] &= ~0x00000080u;
}
void TraceStats::clear_chunks_discarded() {
  chunks_discarded_ = GOOGLE_ULONGLONG(0);
  clear_has_chunks_discarded();
}
 ::google::protobuf::uint64 TraceStats::chunks_discarded() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.chunks_discarded)
  return chunks_discarded_;
}
 void TraceStats::set_chunks_discarded(::google::protobuf::uint64 value) {
  set_has_chunks_discarded();
  chunks_discarded_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.chunks_discarded)
}

// optional uint64 patches_discarded = 9;
bool TraceStats::has_patches_discarded() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void TraceStats::set_has_patches_discarded() {
  _has_bits_[0] |= 0x00000100u;
}
void TraceStats::clear_has_patches_discarded() {
  _has_bits_[0] &= ~0x00000100u;
}
void TraceStats::clear_patches_discarded() {
  patches_discarded_ = GOOGLE_ULONGLONG(0);
  clear_has_patches_discarded();
}
 ::google::protobuf::uint64 TraceStats::patches_discarded() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceStats.patches_discarded)
  return patches_discarded_;
}
 void TraceStats::set_patches_discarded(::google::protobuf::uint64 value) {
  set_has_patches_discarded();
  patches_discarded_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceStats.patches_discarded)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/config/android/android_log_config.pb.cc
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/config/android/android_log_config.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/config/android/android_log_config.proto

#ifndef PROTOBUF_perfetto_2fconfig_2fandroid_2fandroid_5flog_5fconfig_2eproto__INCLUDED
#define PROTOBUF_perfetto_2fconfig_2fandroid_2fandroid_5flog_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// gen_amalgamated expanded: #include "perfetto/common/android_log_constants.pb.h"
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_perfetto_2fconfig_2fandroid_2fandroid_5flog_5fconfig_2eproto();
void protobuf_AssignDesc_perfetto_2fconfig_2fandroid_2fandroid_5flog_5fconfig_2eproto();
void protobuf_ShutdownFile_perfetto_2fconfig_2fandroid_2fandroid_5flog_5fconfig_2eproto();

class AndroidLogConfig;

// ===================================================================

class AndroidLogConfig : public ::google::protobuf::MessageLite {
 public:
  AndroidLogConfig();
  virtual ~AndroidLogConfig();

  AndroidLogConfig(const AndroidLogConfig& from);

  inline AndroidLogConfig& operator=(const AndroidLogConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const AndroidLogConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AndroidLogConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AndroidLogConfig* other);

  // implements Message ----------------------------------------------

  inline AndroidLogConfig* New() const { return New(NULL); }

  AndroidLogConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AndroidLogConfig& from);
  void MergeFrom(const AndroidLogConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AndroidLogConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .perfetto.protos.AndroidLogId log_ids = 1;
  int log_ids_size() const;
  void clear_log_ids();
  static const int kLogIdsFieldNumber = 1;
  ::perfetto::protos::AndroidLogId log_ids(int index) const;
  void set_log_ids(int index, ::perfetto::protos::AndroidLogId value);
  void add_log_ids(::perfetto::protos::AndroidLogId value);
  const ::google::protobuf::RepeatedField<int>& log_ids() const;
  ::google::protobuf::RepeatedField<int>* mutable_log_ids();

  // optional .perfetto.protos.AndroidLogPriority min_prio = 3;
  bool has_min_prio() const;
  void clear_min_prio();
  static const int kMinPrioFieldNumber = 3;
  ::perfetto::protos::AndroidLogPriority min_prio() const;
  void set_min_prio(::perfetto::protos::AndroidLogPriority value);

  // repeated string filter_tags = 4;
  int filter_tags_size() const;
  void clear_filter_tags();
  static const int kFilterTagsFieldNumber = 4;
  const ::std::string& filter_tags(int index) const;
  ::std::string* mutable_filter_tags(int index);
  void set_filter_tags(int index, const ::std::string& value);
  void set_filter_tags(int index, const char* value);
  void set_filter_tags(int index, const char* value, size_t size);
  ::std::string* add_filter_tags();
  void add_filter_tags(const ::std::string& value);
  void add_filter_tags(const char* value);
  void add_filter_tags(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& filter_tags() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_filter_tags();

  // @@protoc_insertion_point(class_scope:perfetto.protos.AndroidLogConfig)
 private:
  inline void set_has_min_prio();
  inline void clear_has_min_prio();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField<int> log_ids_;
  ::google::protobuf::RepeatedPtrField< ::std::string> filter_tags_;
  int min_prio_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fconfig_2fandroid_2fandroid_5flog_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fconfig_2fandroid_2fandroid_5flog_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fconfig_2fandroid_2fandroid_5flog_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fconfig_2fandroid_2fandroid_5flog_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static AndroidLogConfig* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// AndroidLogConfig

// repeated .perfetto.protos.AndroidLogId log_ids = 1;
inline int AndroidLogConfig::log_ids_size() const {
  return log_ids_.size();
}
inline void AndroidLogConfig::clear_log_ids() {
  log_ids_.Clear();
}
inline ::perfetto::protos::AndroidLogId AndroidLogConfig::log_ids(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AndroidLogConfig.log_ids)
  return static_cast< ::perfetto::protos::AndroidLogId >(log_ids_.Get(index));
}
inline void AndroidLogConfig::set_log_ids(int index, ::perfetto::protos::AndroidLogId value) {
  assert(::perfetto::protos::AndroidLogId_IsValid(value));
  log_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.AndroidLogConfig.log_ids)
}
inline void AndroidLogConfig::add_log_ids(::perfetto::protos::AndroidLogId value) {
  assert(::perfetto::protos::AndroidLogId_IsValid(value));
  log_ids_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.AndroidLogConfig.log_ids)
}
inline const ::google::protobuf::RepeatedField<int>&
AndroidLogConfig::log_ids() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.AndroidLogConfig.log_ids)
  return log_ids_;
}
inline ::google::protobuf::RepeatedField<int>*
AndroidLogConfig::mutable_log_ids() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.AndroidLogConfig.log_ids)
  return &log_ids_;
}

// optional .perfetto.protos.AndroidLogPriority min_prio = 3;
inline bool AndroidLogConfig::has_min_prio() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AndroidLogConfig::set_has_min_prio() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AndroidLogConfig::clear_has_min_prio() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AndroidLogConfig::clear_min_prio() {
  min_prio_ = 0;
  clear_has_min_prio();
}
inline ::perfetto::protos::AndroidLogPriority AndroidLogConfig::min_prio() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AndroidLogConfig.min_prio)
  return static_cast< ::perfetto::protos::AndroidLogPriority >(min_prio_);
}
inline void AndroidLogConfig::set_min_prio(::perfetto::protos::AndroidLogPriority value) {
  assert(::perfetto::protos::AndroidLogPriority_IsValid(value));
  set_has_min_prio();
  min_prio_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.AndroidLogConfig.min_prio)
}

// repeated string filter_tags = 4;
inline int AndroidLogConfig::filter_tags_size() const {
  return filter_tags_.size();
}
inline void AndroidLogConfig::clear_filter_tags() {
  filter_tags_.Clear();
}
inline const ::std::string& AndroidLogConfig::filter_tags(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AndroidLogConfig.filter_tags)
  return filter_tags_.Get(index);
}
inline ::std::string* AndroidLogConfig::mutable_filter_tags(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.AndroidLogConfig.filter_tags)
  return filter_tags_.Mutable(index);
}
inline void AndroidLogConfig::set_filter_tags(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.AndroidLogConfig.filter_tags)
  filter_tags_.Mutable(index)->assign(value);
}
inline void AndroidLogConfig::set_filter_tags(int index, const char* value) {
  filter_tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.AndroidLogConfig.filter_tags)
}
inline void AndroidLogConfig::set_filter_tags(int index, const char* value, size_t size) {
  filter_tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.AndroidLogConfig.filter_tags)
}
inline ::std::string* AndroidLogConfig::add_filter_tags() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.AndroidLogConfig.filter_tags)
  return filter_tags_.Add();
}
inline void AndroidLogConfig::add_filter_tags(const ::std::string& value) {
  filter_tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.AndroidLogConfig.filter_tags)
}
inline void AndroidLogConfig::add_filter_tags(const char* value) {
  filter_tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.AndroidLogConfig.filter_tags)
}
inline void AndroidLogConfig::add_filter_tags(const char* value, size_t size) {
  filter_tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.AndroidLogConfig.filter_tags)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AndroidLogConfig::filter_tags() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.AndroidLogConfig.filter_tags)
  return filter_tags_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AndroidLogConfig::mutable_filter_tags() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.AndroidLogConfig.filter_tags)
  return &filter_tags_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_perfetto_2fconfig_2fandroid_2fandroid_5flog_5fconfig_2eproto__INCLUDED
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/config/android/android_log_config.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
// gen_amalgamated expanded: #include "perfetto/config/android/android_log_config.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

void protobuf_ShutdownFile_perfetto_2fconfig_2fandroid_2fandroid_5flog_5fconfig_2eproto() {
  delete AndroidLogConfig::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_perfetto_2fconfig_2fandroid_2fandroid_5flog_5fconfig_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_perfetto_2fconfig_2fandroid_2fandroid_5flog_5fconfig_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::perfetto::protos::protobuf_AddDesc_perfetto_2fcommon_2fandroid_5flog_5fconstants_2eproto();
  AndroidLogConfig::default_instance_ = new AndroidLogConfig();
  AndroidLogConfig::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_perfetto_2fconfig_2fandroid_2fandroid_5flog_5fconfig_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_perfetto_2fconfig_2fandroid_2fandroid_5flog_5fconfig_2eproto_once_);
void protobuf_AddDesc_perfetto_2fconfig_2fandroid_2fandroid_5flog_5fconfig_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_perfetto_2fconfig_2fandroid_2fandroid_5flog_5fconfig_2eproto_once_,
                 &protobuf_AddDesc_perfetto_2fconfig_2fandroid_2fandroid_5flog_5fconfig_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_perfetto_2fconfig_2fandroid_2fandroid_5flog_5fconfig_2eproto {
  StaticDescriptorInitializer_perfetto_2fconfig_2fandroid_2fandroid_5flog_5fconfig_2eproto() {
    protobuf_AddDesc_perfetto_2fconfig_2fandroid_2fandroid_5flog_5fconfig_2eproto();
  }
} static_descriptor_initializer_perfetto_2fconfig_2fandroid_2fandroid_5flog_5fconfig_2eproto_;
#endif

namespace {

static void android_log_config_pb_MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
static void android_log_config_pb_MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

static ::std::string* MutableUnknownFieldsForAndroidLogConfig(
    AndroidLogConfig* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int AndroidLogConfig::kLogIdsFieldNumber;
const int AndroidLogConfig::kMinPrioFieldNumber;
const int AndroidLogConfig::kFilterTagsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

AndroidLogConfig::AndroidLogConfig()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.AndroidLogConfig)
}

void AndroidLogConfig::InitAsDefaultInstance() {
}

AndroidLogConfig::AndroidLogConfig(const AndroidLogConfig& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.AndroidLogConfig)
}

void AndroidLogConfig::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  min_prio_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AndroidLogConfig::~AndroidLogConfig() {
  // @@protoc_insertion_point(destructor:perfetto.protos.AndroidLogConfig)
  SharedDtor();
}

void AndroidLogConfig::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AndroidLogConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AndroidLogConfig& AndroidLogConfig::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fconfig_2fandroid_2fandroid_5flog_5fconfig_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fconfig_2fandroid_2fandroid_5flog_5fconfig_2eproto();
#endif
  return *default_instance_;
}

AndroidLogConfig* AndroidLogConfig::default_instance_ = NULL;

AndroidLogConfig* AndroidLogConfig::New(::google::protobuf::Arena* arena) const {
  AndroidLogConfig* n = new AndroidLogConfig;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void AndroidLogConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.AndroidLogConfig)
  min_prio_ = 0;
  log_ids_.Clear();
  filter_tags_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool AndroidLogConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForAndroidLogConfig, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.AndroidLogConfig)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .perfetto.protos.AndroidLogId log_ids = 1;
      case 1: {
        if (tag == 8) {
         parse_log_ids:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::perfetto::protos::AndroidLogId_IsValid(value)) {
            add_log_ids(static_cast< ::perfetto::protos::AndroidLogId >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedEnumPreserveUnknowns(
                 input,
                 1,
                 ::perfetto::protos::AndroidLogId_IsValid,
                 &unknown_fields_stream,
                 this->mutable_log_ids())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(8)) goto parse_log_ids;
        if (input->ExpectTag(24)) goto parse_min_prio;
        break;
      }

      // optional .perfetto.protos.AndroidLogPriority min_prio = 3;
      case 3: {
        if (tag == 24) {
         parse_min_prio:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::perfetto::protos::AndroidLogPriority_IsValid(value)) {
            set_min_prio(static_cast< ::perfetto::protos::AndroidLogPriority >(value));
          } else {
            unknown_fields_stream.WriteVarint32(24);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_filter_tags;
        break;
      }

      // repeated string filter_tags = 4;
      case 4: {
        if (tag == 34) {
         parse_filter_tags:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_filter_tags()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_filter_tags;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.AndroidLogConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.AndroidLogConfig)
  return false;
#undef DO_
}

void AndroidLogConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.AndroidLogConfig)
  // repeated .perfetto.protos.AndroidLogId log_ids = 1;
  for (int i = 0; i < this->log_ids_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->log_ids(i), output);
  }

  // optional .perfetto.protos.AndroidLogPriority min_prio = 3;
  if (has_min_prio()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->min_prio(), output);
  }

  // repeated string filter_tags = 4;
  for (int i = 0; i < this->filter_tags_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->filter_tags(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.AndroidLogConfig)
}

int AndroidLogConfig::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.AndroidLogConfig)
  int total_size = 0;

  // optional .perfetto.protos.AndroidLogPriority min_prio = 3;
  if (has_min_prio()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->min_prio());
  }

  // repeated .perfetto.protos.AndroidLogId log_ids = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->log_ids_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::EnumSize(
        this->log_ids(i));
    }
    total_size += 1 * this->log_ids_size() + data_size;
  }

  // repeated string filter_tags = 4;
  total_size += 1 * this->filter_tags_size();
  for (int i = 0; i < this->filter_tags_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->filter_tags(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AndroidLogConfig::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AndroidLogConfig*>(&from));
}

void AndroidLogConfig::MergeFrom(const AndroidLogConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.AndroidLogConfig)
  if (GOOGLE_PREDICT_FALSE(&from == this)) android_log_config_pb_MergeFromFail(__LINE__);
  log_ids_.MergeFrom(from.log_ids_);
  filter_tags_.MergeFrom(from.filter_tags_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_min_prio()) {
      set_min_prio(from.min_prio());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void AndroidLogConfig::CopyFrom(const AndroidLogConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.AndroidLogConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AndroidLogConfig::IsInitialized() const {

  return true;
}

void AndroidLogConfig::Swap(AndroidLogConfig* other) {
  if (other == this) return;
  InternalSwap(other);
}
void AndroidLogConfig::InternalSwap(AndroidLogConfig* other) {
  log_ids_.UnsafeArenaSwap(&other->log_ids_);
  std::swap(min_prio_, other->min_prio_);
  filter_tags_.UnsafeArenaSwap(&other->filter_tags_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string AndroidLogConfig::GetTypeName() const {
  return "perfetto.protos.AndroidLogConfig";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// AndroidLogConfig

// repeated .perfetto.protos.AndroidLogId log_ids = 1;
int AndroidLogConfig::log_ids_size() const {
  return log_ids_.size();
}
void AndroidLogConfig::clear_log_ids() {
  log_ids_.Clear();
}
 ::perfetto::protos::AndroidLogId AndroidLogConfig::log_ids(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AndroidLogConfig.log_ids)
  return static_cast< ::perfetto::protos::AndroidLogId >(log_ids_.Get(index));
}
 void AndroidLogConfig::set_log_ids(int index, ::perfetto::protos::AndroidLogId value) {
  assert(::perfetto::protos::AndroidLogId_IsValid(value));
  log_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.AndroidLogConfig.log_ids)
}
 void AndroidLogConfig::add_log_ids(::perfetto::protos::AndroidLogId value) {
  assert(::perfetto::protos::AndroidLogId_IsValid(value));
  log_ids_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.AndroidLogConfig.log_ids)
}
 const ::google::protobuf::RepeatedField<int>&
AndroidLogConfig::log_ids() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.AndroidLogConfig.log_ids)
  return log_ids_;
}
 ::google::protobuf::RepeatedField<int>*
AndroidLogConfig::mutable_log_ids() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.AndroidLogConfig.log_ids)
  return &log_ids_;
}

// optional .perfetto.protos.AndroidLogPriority min_prio = 3;
bool AndroidLogConfig::has_min_prio() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void AndroidLogConfig::set_has_min_prio() {
  _has_bits_[0] |= 0x00000002u;
}
void AndroidLogConfig::clear_has_min_prio() {
  _has_bits_[0] &= ~0x00000002u;
}
void AndroidLogConfig::clear_min_prio() {
  min_prio_ = 0;
  clear_has_min_prio();
}
 ::perfetto::protos::AndroidLogPriority AndroidLogConfig::min_prio() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AndroidLogConfig.min_prio)
  return static_cast< ::perfetto::protos::AndroidLogPriority >(min_prio_);
}
 void AndroidLogConfig::set_min_prio(::perfetto::protos::AndroidLogPriority value) {
  assert(::perfetto::protos::AndroidLogPriority_IsValid(value));
  set_has_min_prio();
  min_prio_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.AndroidLogConfig.min_prio)
}

// repeated string filter_tags = 4;
int AndroidLogConfig::filter_tags_size() const {
  return filter_tags_.size();
}
void AndroidLogConfig::clear_filter_tags() {
  filter_tags_.Clear();
}
 const ::std::string& AndroidLogConfig::filter_tags(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AndroidLogConfig.filter_tags)
  return filter_tags_.Get(index);
}
 ::std::string* AndroidLogConfig::mutable_filter_tags(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.AndroidLogConfig.filter_tags)
  return filter_tags_.Mutable(index);
}
 void AndroidLogConfig::set_filter_tags(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.AndroidLogConfig.filter_tags)
  filter_tags_.Mutable(index)->assign(value);
}
 void AndroidLogConfig::set_filter_tags(int index, const char* value) {
  filter_tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.AndroidLogConfig.filter_tags)
}
 void AndroidLogConfig::set_filter_tags(int index, const char* value, size_t size) {
  filter_tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.AndroidLogConfig.filter_tags)
}
 ::std::string* AndroidLogConfig::add_filter_tags() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.AndroidLogConfig.filter_tags)
  return filter_tags_.Add();
}
 void AndroidLogConfig::add_filter_tags(const ::std::string& value) {
  filter_tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.AndroidLogConfig.filter_tags)
}
 void AndroidLogConfig::add_filter_tags(const char* value) {
  filter_tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.AndroidLogConfig.filter_tags)
}
 void AndroidLogConfig::add_filter_tags(const char* value, size_t size) {
  filter_tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.AndroidLogConfig.filter_tags)
}
 const ::google::protobuf::RepeatedPtrField< ::std::string>&
AndroidLogConfig::filter_tags() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.AndroidLogConfig.filter_tags)
  return filter_tags_;
}
 ::google::protobuf::RepeatedPtrField< ::std::string>*
AndroidLogConfig::mutable_filter_tags() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.AndroidLogConfig.filter_tags)
  return &filter_tags_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/config/android/packages_list_config.pb.cc
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/config/android/packages_list_config.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/config/android/packages_list_config.proto

#ifndef PROTOBUF_perfetto_2fconfig_2fandroid_2fpackages_5flist_5fconfig_2eproto__INCLUDED
#define PROTOBUF_perfetto_2fconfig_2fandroid_2fpackages_5flist_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_perfetto_2fconfig_2fandroid_2fpackages_5flist_5fconfig_2eproto();
void protobuf_AssignDesc_perfetto_2fconfig_2fandroid_2fpackages_5flist_5fconfig_2eproto();
void protobuf_ShutdownFile_perfetto_2fconfig_2fandroid_2fpackages_5flist_5fconfig_2eproto();

class PackagesListConfig;

// ===================================================================

class PackagesListConfig : public ::google::protobuf::MessageLite {
 public:
  PackagesListConfig();
  virtual ~PackagesListConfig();

  PackagesListConfig(const PackagesListConfig& from);

  inline PackagesListConfig& operator=(const PackagesListConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const PackagesListConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PackagesListConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PackagesListConfig* other);

  // implements Message ----------------------------------------------

  inline PackagesListConfig* New() const { return New(NULL); }

  PackagesListConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PackagesListConfig& from);
  void MergeFrom(const PackagesListConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PackagesListConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string package_name_filter = 1;
  int package_name_filter_size() const;
  void clear_package_name_filter();
  static const int kPackageNameFilterFieldNumber = 1;
  const ::std::string& package_name_filter(int index) const;
  ::std::string* mutable_package_name_filter(int index);
  void set_package_name_filter(int index, const ::std::string& value);
  void set_package_name_filter(int index, const char* value);
  void set_package_name_filter(int index, const char* value, size_t size);
  ::std::string* add_package_name_filter();
  void add_package_name_filter(const ::std::string& value);
  void add_package_name_filter(const char* value);
  void add_package_name_filter(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& package_name_filter() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_package_name_filter();

  // @@protoc_insertion_point(class_scope:perfetto.protos.PackagesListConfig)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> package_name_filter_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fconfig_2fandroid_2fpackages_5flist_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fconfig_2fandroid_2fpackages_5flist_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fconfig_2fandroid_2fpackages_5flist_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fconfig_2fandroid_2fpackages_5flist_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static PackagesListConfig* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// PackagesListConfig

// repeated string package_name_filter = 1;
inline int PackagesListConfig::package_name_filter_size() const {
  return package_name_filter_.size();
}
inline void PackagesListConfig::clear_package_name_filter() {
  package_name_filter_.Clear();
}
inline const ::std::string& PackagesListConfig::package_name_filter(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.PackagesListConfig.package_name_filter)
  return package_name_filter_.Get(index);
}
inline ::std::string* PackagesListConfig::mutable_package_name_filter(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.PackagesListConfig.package_name_filter)
  return package_name_filter_.Mutable(index);
}
inline void PackagesListConfig::set_package_name_filter(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.PackagesListConfig.package_name_filter)
  package_name_filter_.Mutable(index)->assign(value);
}
inline void PackagesListConfig::set_package_name_filter(int index, const char* value) {
  package_name_filter_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.PackagesListConfig.package_name_filter)
}
inline void PackagesListConfig::set_package_name_filter(int index, const char* value, size_t size) {
  package_name_filter_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.PackagesListConfig.package_name_filter)
}
inline ::std::string* PackagesListConfig::add_package_name_filter() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.PackagesListConfig.package_name_filter)
  return package_name_filter_.Add();
}
inline void PackagesListConfig::add_package_name_filter(const ::std::string& value) {
  package_name_filter_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.PackagesListConfig.package_name_filter)
}
inline void PackagesListConfig::add_package_name_filter(const char* value) {
  package_name_filter_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.PackagesListConfig.package_name_filter)
}
inline void PackagesListConfig::add_package_name_filter(const char* value, size_t size) {
  package_name_filter_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.PackagesListConfig.package_name_filter)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PackagesListConfig::package_name_filter() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.PackagesListConfig.package_name_filter)
  return package_name_filter_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PackagesListConfig::mutable_package_name_filter() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.PackagesListConfig.package_name_filter)
  return &package_name_filter_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_perfetto_2fconfig_2fandroid_2fpackages_5flist_5fconfig_2eproto__INCLUDED
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/config/android/packages_list_config.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
// gen_amalgamated expanded: #include "perfetto/config/android/packages_list_config.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

void protobuf_ShutdownFile_perfetto_2fconfig_2fandroid_2fpackages_5flist_5fconfig_2eproto() {
  delete PackagesListConfig::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_perfetto_2fconfig_2fandroid_2fpackages_5flist_5fconfig_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_perfetto_2fconfig_2fandroid_2fpackages_5flist_5fconfig_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  PackagesListConfig::default_instance_ = new PackagesListConfig();
  PackagesListConfig::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_perfetto_2fconfig_2fandroid_2fpackages_5flist_5fconfig_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_perfetto_2fconfig_2fandroid_2fpackages_5flist_5fconfig_2eproto_once_);
void protobuf_AddDesc_perfetto_2fconfig_2fandroid_2fpackages_5flist_5fconfig_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_perfetto_2fconfig_2fandroid_2fpackages_5flist_5fconfig_2eproto_once_,
                 &protobuf_AddDesc_perfetto_2fconfig_2fandroid_2fpackages_5flist_5fconfig_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_perfetto_2fconfig_2fandroid_2fpackages_5flist_5fconfig_2eproto {
  StaticDescriptorInitializer_perfetto_2fconfig_2fandroid_2fpackages_5flist_5fconfig_2eproto() {
    protobuf_AddDesc_perfetto_2fconfig_2fandroid_2fpackages_5flist_5fconfig_2eproto();
  }
} static_descriptor_initializer_perfetto_2fconfig_2fandroid_2fpackages_5flist_5fconfig_2eproto_;
#endif

namespace {

static void packages_list_config_pb_MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
static void packages_list_config_pb_MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

static ::std::string* MutableUnknownFieldsForPackagesListConfig(
    PackagesListConfig* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PackagesListConfig::kPackageNameFilterFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PackagesListConfig::PackagesListConfig()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.PackagesListConfig)
}

void PackagesListConfig::InitAsDefaultInstance() {
}

PackagesListConfig::PackagesListConfig(const PackagesListConfig& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.PackagesListConfig)
}

void PackagesListConfig::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PackagesListConfig::~PackagesListConfig() {
  // @@protoc_insertion_point(destructor:perfetto.protos.PackagesListConfig)
  SharedDtor();
}

void PackagesListConfig::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void PackagesListConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const PackagesListConfig& PackagesListConfig::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fconfig_2fandroid_2fpackages_5flist_5fconfig_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fconfig_2fandroid_2fpackages_5flist_5fconfig_2eproto();
#endif
  return *default_instance_;
}

PackagesListConfig* PackagesListConfig::default_instance_ = NULL;

PackagesListConfig* PackagesListConfig::New(::google::protobuf::Arena* arena) const {
  PackagesListConfig* n = new PackagesListConfig;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PackagesListConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.PackagesListConfig)
  package_name_filter_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool PackagesListConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForPackagesListConfig, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.PackagesListConfig)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated string package_name_filter = 1;
      case 1: {
        if (tag == 10) {
         parse_package_name_filter:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_package_name_filter()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_package_name_filter;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.PackagesListConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.PackagesListConfig)
  return false;
#undef DO_
}

void PackagesListConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.PackagesListConfig)
  // repeated string package_name_filter = 1;
  for (int i = 0; i < this->package_name_filter_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->package_name_filter(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.PackagesListConfig)
}

int PackagesListConfig::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.PackagesListConfig)
  int total_size = 0;

  // repeated string package_name_filter = 1;
  total_size += 1 * this->package_name_filter_size();
  for (int i = 0; i < this->package_name_filter_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->package_name_filter(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PackagesListConfig::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const PackagesListConfig*>(&from));
}

void PackagesListConfig::MergeFrom(const PackagesListConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.PackagesListConfig)
  if (GOOGLE_PREDICT_FALSE(&from == this)) packages_list_config_pb_MergeFromFail(__LINE__);
  package_name_filter_.MergeFrom(from.package_name_filter_);
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void PackagesListConfig::CopyFrom(const PackagesListConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.PackagesListConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PackagesListConfig::IsInitialized() const {

  return true;
}

void PackagesListConfig::Swap(PackagesListConfig* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PackagesListConfig::InternalSwap(PackagesListConfig* other) {
  package_name_filter_.UnsafeArenaSwap(&other->package_name_filter_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string PackagesListConfig::GetTypeName() const {
  return "perfetto.protos.PackagesListConfig";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PackagesListConfig

// repeated string package_name_filter = 1;
int PackagesListConfig::package_name_filter_size() const {
  return package_name_filter_.size();
}
void PackagesListConfig::clear_package_name_filter() {
  package_name_filter_.Clear();
}
 const ::std::string& PackagesListConfig::package_name_filter(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.PackagesListConfig.package_name_filter)
  return package_name_filter_.Get(index);
}
 ::std::string* PackagesListConfig::mutable_package_name_filter(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.PackagesListConfig.package_name_filter)
  return package_name_filter_.Mutable(index);
}
 void PackagesListConfig::set_package_name_filter(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.PackagesListConfig.package_name_filter)
  package_name_filter_.Mutable(index)->assign(value);
}
 void PackagesListConfig::set_package_name_filter(int index, const char* value) {
  package_name_filter_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.PackagesListConfig.package_name_filter)
}
 void PackagesListConfig::set_package_name_filter(int index, const char* value, size_t size) {
  package_name_filter_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.PackagesListConfig.package_name_filter)
}
 ::std::string* PackagesListConfig::add_package_name_filter() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.PackagesListConfig.package_name_filter)
  return package_name_filter_.Add();
}
 void PackagesListConfig::add_package_name_filter(const ::std::string& value) {
  package_name_filter_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.PackagesListConfig.package_name_filter)
}
 void PackagesListConfig::add_package_name_filter(const char* value) {
  package_name_filter_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.PackagesListConfig.package_name_filter)
}
 void PackagesListConfig::add_package_name_filter(const char* value, size_t size) {
  package_name_filter_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.PackagesListConfig.package_name_filter)
}
 const ::google::protobuf::RepeatedPtrField< ::std::string>&
PackagesListConfig::package_name_filter() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.PackagesListConfig.package_name_filter)
  return package_name_filter_;
}
 ::google::protobuf::RepeatedPtrField< ::std::string>*
PackagesListConfig::mutable_package_name_filter() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.PackagesListConfig.package_name_filter)
  return &package_name_filter_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/config/chrome/chrome_config.pb.cc
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/config/chrome/chrome_config.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/config/chrome/chrome_config.proto

#ifndef PROTOBUF_perfetto_2fconfig_2fchrome_2fchrome_5fconfig_2eproto__INCLUDED
#define PROTOBUF_perfetto_2fconfig_2fchrome_2fchrome_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_perfetto_2fconfig_2fchrome_2fchrome_5fconfig_2eproto();
void protobuf_AssignDesc_perfetto_2fconfig_2fchrome_2fchrome_5fconfig_2eproto();
void protobuf_ShutdownFile_perfetto_2fconfig_2fchrome_2fchrome_5fconfig_2eproto();

class ChromeConfig;

// ===================================================================

class ChromeConfig : public ::google::protobuf::MessageLite {
 public:
  ChromeConfig();
  virtual ~ChromeConfig();

  ChromeConfig(const ChromeConfig& from);

  inline ChromeConfig& operator=(const ChromeConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ChromeConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ChromeConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ChromeConfig* other);

  // implements Message ----------------------------------------------

  inline ChromeConfig* New() const { return New(NULL); }

  ChromeConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChromeConfig& from);
  void MergeFrom(const ChromeConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChromeConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string trace_config = 1;
  bool has_trace_config() const;
  void clear_trace_config();
  static const int kTraceConfigFieldNumber = 1;
  const ::std::string& trace_config() const;
  void set_trace_config(const ::std::string& value);
  void set_trace_config(const char* value);
  void set_trace_config(const char* value, size_t size);
  ::std::string* mutable_trace_config();
  ::std::string* release_trace_config();
  void set_allocated_trace_config(::std::string* trace_config);

  // optional bool privacy_filtering_enabled = 2;
  bool has_privacy_filtering_enabled() const;
  void clear_privacy_filtering_enabled();
  static const int kPrivacyFilteringEnabledFieldNumber = 2;
  bool privacy_filtering_enabled() const;
  void set_privacy_filtering_enabled(bool value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.ChromeConfig)
 private:
  inline void set_has_trace_config();
  inline void clear_has_trace_config();
  inline void set_has_privacy_filtering_enabled();
  inline void clear_has_privacy_filtering_enabled();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr trace_config_;
  bool privacy_filtering_enabled_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fconfig_2fchrome_2fchrome_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fconfig_2fchrome_2fchrome_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fconfig_2fchrome_2fchrome_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fconfig_2fchrome_2fchrome_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static ChromeConfig* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// ChromeConfig

// optional string trace_config = 1;
inline bool ChromeConfig::has_trace_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChromeConfig::set_has_trace_config() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChromeConfig::clear_has_trace_config() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChromeConfig::clear_trace_config() {
  trace_config_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_trace_config();
}
inline const ::std::string& ChromeConfig::trace_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ChromeConfig.trace_config)
  return trace_config_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChromeConfig::set_trace_config(const ::std::string& value) {
  set_has_trace_config();
  trace_config_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.ChromeConfig.trace_config)
}
inline void ChromeConfig::set_trace_config(const char* value) {
  set_has_trace_config();
  trace_config_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.ChromeConfig.trace_config)
}
inline void ChromeConfig::set_trace_config(const char* value, size_t size) {
  set_has_trace_config();
  trace_config_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.ChromeConfig.trace_config)
}
inline ::std::string* ChromeConfig::mutable_trace_config() {
  set_has_trace_config();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.ChromeConfig.trace_config)
  return trace_config_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChromeConfig::release_trace_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.ChromeConfig.trace_config)
  clear_has_trace_config();
  return trace_config_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChromeConfig::set_allocated_trace_config(::std::string* trace_config) {
  if (trace_config != NULL) {
    set_has_trace_config();
  } else {
    clear_has_trace_config();
  }
  trace_config_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), trace_config);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.ChromeConfig.trace_config)
}

// optional bool privacy_filtering_enabled = 2;
inline bool ChromeConfig::has_privacy_filtering_enabled() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChromeConfig::set_has_privacy_filtering_enabled() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChromeConfig::clear_has_privacy_filtering_enabled() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChromeConfig::clear_privacy_filtering_enabled() {
  privacy_filtering_enabled_ = false;
  clear_has_privacy_filtering_enabled();
}
inline bool ChromeConfig::privacy_filtering_enabled() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ChromeConfig.privacy_filtering_enabled)
  return privacy_filtering_enabled_;
}
inline void ChromeConfig::set_privacy_filtering_enabled(bool value) {
  set_has_privacy_filtering_enabled();
  privacy_filtering_enabled_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.ChromeConfig.privacy_filtering_enabled)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_perfetto_2fconfig_2fchrome_2fchrome_5fconfig_2eproto__INCLUDED
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/config/chrome/chrome_config.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
// gen_amalgamated expanded: #include "perfetto/config/chrome/chrome_config.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

void protobuf_ShutdownFile_perfetto_2fconfig_2fchrome_2fchrome_5fconfig_2eproto() {
  delete ChromeConfig::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_perfetto_2fconfig_2fchrome_2fchrome_5fconfig_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_perfetto_2fconfig_2fchrome_2fchrome_5fconfig_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ChromeConfig::default_instance_ = new ChromeConfig();
  ChromeConfig::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_perfetto_2fconfig_2fchrome_2fchrome_5fconfig_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_perfetto_2fconfig_2fchrome_2fchrome_5fconfig_2eproto_once_);
void protobuf_AddDesc_perfetto_2fconfig_2fchrome_2fchrome_5fconfig_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_perfetto_2fconfig_2fchrome_2fchrome_5fconfig_2eproto_once_,
                 &protobuf_AddDesc_perfetto_2fconfig_2fchrome_2fchrome_5fconfig_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_perfetto_2fconfig_2fchrome_2fchrome_5fconfig_2eproto {
  StaticDescriptorInitializer_perfetto_2fconfig_2fchrome_2fchrome_5fconfig_2eproto() {
    protobuf_AddDesc_perfetto_2fconfig_2fchrome_2fchrome_5fconfig_2eproto();
  }
} static_descriptor_initializer_perfetto_2fconfig_2fchrome_2fchrome_5fconfig_2eproto_;
#endif

namespace {

static void chrome_config_pb_MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
static void chrome_config_pb_MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

static ::std::string* MutableUnknownFieldsForChromeConfig(
    ChromeConfig* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ChromeConfig::kTraceConfigFieldNumber;
const int ChromeConfig::kPrivacyFilteringEnabledFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ChromeConfig::ChromeConfig()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.ChromeConfig)
}

void ChromeConfig::InitAsDefaultInstance() {
}

ChromeConfig::ChromeConfig(const ChromeConfig& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.ChromeConfig)
}

void ChromeConfig::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  trace_config_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  privacy_filtering_enabled_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChromeConfig::~ChromeConfig() {
  // @@protoc_insertion_point(destructor:perfetto.protos.ChromeConfig)
  SharedDtor();
}

void ChromeConfig::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  trace_config_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ChromeConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ChromeConfig& ChromeConfig::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fconfig_2fchrome_2fchrome_5fconfig_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fconfig_2fchrome_2fchrome_5fconfig_2eproto();
#endif
  return *default_instance_;
}

ChromeConfig* ChromeConfig::default_instance_ = NULL;

ChromeConfig* ChromeConfig::New(::google::protobuf::Arena* arena) const {
  ChromeConfig* n = new ChromeConfig;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ChromeConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.ChromeConfig)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_trace_config()) {
      trace_config_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    privacy_filtering_enabled_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool ChromeConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForChromeConfig, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.ChromeConfig)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string trace_config = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_trace_config()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_privacy_filtering_enabled;
        break;
      }

      // optional bool privacy_filtering_enabled = 2;
      case 2: {
        if (tag == 16) {
         parse_privacy_filtering_enabled:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &privacy_filtering_enabled_)));
          set_has_privacy_filtering_enabled();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.ChromeConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.ChromeConfig)
  return false;
#undef DO_
}

void ChromeConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.ChromeConfig)
  // optional string trace_config = 1;
  if (has_trace_config()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->trace_config(), output);
  }

  // optional bool privacy_filtering_enabled = 2;
  if (has_privacy_filtering_enabled()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->privacy_filtering_enabled(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.ChromeConfig)
}

int ChromeConfig::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.ChromeConfig)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional string trace_config = 1;
    if (has_trace_config()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->trace_config());
    }

    // optional bool privacy_filtering_enabled = 2;
    if (has_privacy_filtering_enabled()) {
      total_size += 1 + 1;
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChromeConfig::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ChromeConfig*>(&from));
}

void ChromeConfig::MergeFrom(const ChromeConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.ChromeConfig)
  if (GOOGLE_PREDICT_FALSE(&from == this)) chrome_config_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_trace_config()) {
      set_has_trace_config();
      trace_config_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.trace_config_);
    }
    if (from.has_privacy_filtering_enabled()) {
      set_privacy_filtering_enabled(from.privacy_filtering_enabled());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void ChromeConfig::CopyFrom(const ChromeConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.ChromeConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChromeConfig::IsInitialized() const {

  return true;
}

void ChromeConfig::Swap(ChromeConfig* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ChromeConfig::InternalSwap(ChromeConfig* other) {
  trace_config_.Swap(&other->trace_config_);
  std::swap(privacy_filtering_enabled_, other->privacy_filtering_enabled_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ChromeConfig::GetTypeName() const {
  return "perfetto.protos.ChromeConfig";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ChromeConfig

// optional string trace_config = 1;
bool ChromeConfig::has_trace_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ChromeConfig::set_has_trace_config() {
  _has_bits_[0] |= 0x00000001u;
}
void ChromeConfig::clear_has_trace_config() {
  _has_bits_[0] &= ~0x00000001u;
}
void ChromeConfig::clear_trace_config() {
  trace_config_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_trace_config();
}
 const ::std::string& ChromeConfig::trace_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ChromeConfig.trace_config)
  return trace_config_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ChromeConfig::set_trace_config(const ::std::string& value) {
  set_has_trace_config();
  trace_config_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.ChromeConfig.trace_config)
}
 void ChromeConfig::set_trace_config(const char* value) {
  set_has_trace_config();
  trace_config_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.ChromeConfig.trace_config)
}
 void ChromeConfig::set_trace_config(const char* value, size_t size) {
  set_has_trace_config();
  trace_config_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.ChromeConfig.trace_config)
}
 ::std::string* ChromeConfig::mutable_trace_config() {
  set_has_trace_config();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.ChromeConfig.trace_config)
  return trace_config_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ChromeConfig::release_trace_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.ChromeConfig.trace_config)
  clear_has_trace_config();
  return trace_config_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ChromeConfig::set_allocated_trace_config(::std::string* trace_config) {
  if (trace_config != NULL) {
    set_has_trace_config();
  } else {
    clear_has_trace_config();
  }
  trace_config_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), trace_config);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.ChromeConfig.trace_config)
}

// optional bool privacy_filtering_enabled = 2;
bool ChromeConfig::has_privacy_filtering_enabled() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ChromeConfig::set_has_privacy_filtering_enabled() {
  _has_bits_[0] |= 0x00000002u;
}
void ChromeConfig::clear_has_privacy_filtering_enabled() {
  _has_bits_[0] &= ~0x00000002u;
}
void ChromeConfig::clear_privacy_filtering_enabled() {
  privacy_filtering_enabled_ = false;
  clear_has_privacy_filtering_enabled();
}
 bool ChromeConfig::privacy_filtering_enabled() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ChromeConfig.privacy_filtering_enabled)
  return privacy_filtering_enabled_;
}
 void ChromeConfig::set_privacy_filtering_enabled(bool value) {
  set_has_privacy_filtering_enabled();
  privacy_filtering_enabled_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.ChromeConfig.privacy_filtering_enabled)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/config/data_source_config.pb.cc
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/config/data_source_config.pb.h
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/config/ftrace/ftrace_config.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/config/ftrace/ftrace_config.proto

#ifndef PROTOBUF_perfetto_2fconfig_2fftrace_2fftrace_5fconfig_2eproto__INCLUDED
#define PROTOBUF_perfetto_2fconfig_2fftrace_2fftrace_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_perfetto_2fconfig_2fftrace_2fftrace_5fconfig_2eproto();
void protobuf_AssignDesc_perfetto_2fconfig_2fftrace_2fftrace_5fconfig_2eproto();
void protobuf_ShutdownFile_perfetto_2fconfig_2fftrace_2fftrace_5fconfig_2eproto();

class FtraceConfig;

// ===================================================================

class FtraceConfig : public ::google::protobuf::MessageLite {
 public:
  FtraceConfig();
  virtual ~FtraceConfig();

  FtraceConfig(const FtraceConfig& from);

  inline FtraceConfig& operator=(const FtraceConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const FtraceConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FtraceConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FtraceConfig* other);

  // implements Message ----------------------------------------------

  inline FtraceConfig* New() const { return New(NULL); }

  FtraceConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FtraceConfig& from);
  void MergeFrom(const FtraceConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FtraceConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string ftrace_events = 1;
  int ftrace_events_size() const;
  void clear_ftrace_events();
  static const int kFtraceEventsFieldNumber = 1;
  const ::std::string& ftrace_events(int index) const;
  ::std::string* mutable_ftrace_events(int index);
  void set_ftrace_events(int index, const ::std::string& value);
  void set_ftrace_events(int index, const char* value);
  void set_ftrace_events(int index, const char* value, size_t size);
  ::std::string* add_ftrace_events();
  void add_ftrace_events(const ::std::string& value);
  void add_ftrace_events(const char* value);
  void add_ftrace_events(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& ftrace_events() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_ftrace_events();

  // repeated string atrace_categories = 2;
  int atrace_categories_size() const;
  void clear_atrace_categories();
  static const int kAtraceCategoriesFieldNumber = 2;
  const ::std::string& atrace_categories(int index) const;
  ::std::string* mutable_atrace_categories(int index);
  void set_atrace_categories(int index, const ::std::string& value);
  void set_atrace_categories(int index, const char* value);
  void set_atrace_categories(int index, const char* value, size_t size);
  ::std::string* add_atrace_categories();
  void add_atrace_categories(const ::std::string& value);
  void add_atrace_categories(const char* value);
  void add_atrace_categories(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& atrace_categories() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_atrace_categories();

  // repeated string atrace_apps = 3;
  int atrace_apps_size() const;
  void clear_atrace_apps();
  static const int kAtraceAppsFieldNumber = 3;
  const ::std::string& atrace_apps(int index) const;
  ::std::string* mutable_atrace_apps(int index);
  void set_atrace_apps(int index, const ::std::string& value);
  void set_atrace_apps(int index, const char* value);
  void set_atrace_apps(int index, const char* value, size_t size);
  ::std::string* add_atrace_apps();
  void add_atrace_apps(const ::std::string& value);
  void add_atrace_apps(const char* value);
  void add_atrace_apps(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& atrace_apps() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_atrace_apps();

  // optional uint32 buffer_size_kb = 10;
  bool has_buffer_size_kb() const;
  void clear_buffer_size_kb();
  static const int kBufferSizeKbFieldNumber = 10;
  ::google::protobuf::uint32 buffer_size_kb() const;
  void set_buffer_size_kb(::google::protobuf::uint32 value);

  // optional uint32 drain_period_ms = 11;
  bool has_drain_period_ms() const;
  void clear_drain_period_ms();
  static const int kDrainPeriodMsFieldNumber = 11;
  ::google::protobuf::uint32 drain_period_ms() const;
  void set_drain_period_ms(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.FtraceConfig)
 private:
  inline void set_has_buffer_size_kb();
  inline void clear_has_buffer_size_kb();
  inline void set_has_drain_period_ms();
  inline void clear_has_drain_period_ms();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> ftrace_events_;
  ::google::protobuf::RepeatedPtrField< ::std::string> atrace_categories_;
  ::google::protobuf::RepeatedPtrField< ::std::string> atrace_apps_;
  ::google::protobuf::uint32 buffer_size_kb_;
  ::google::protobuf::uint32 drain_period_ms_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fconfig_2fftrace_2fftrace_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fconfig_2fftrace_2fftrace_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fconfig_2fftrace_2fftrace_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fconfig_2fftrace_2fftrace_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static FtraceConfig* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// FtraceConfig

// repeated string ftrace_events = 1;
inline int FtraceConfig::ftrace_events_size() const {
  return ftrace_events_.size();
}
inline void FtraceConfig::clear_ftrace_events() {
  ftrace_events_.Clear();
}
inline const ::std::string& FtraceConfig::ftrace_events(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FtraceConfig.ftrace_events)
  return ftrace_events_.Get(index);
}
inline ::std::string* FtraceConfig::mutable_ftrace_events(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.FtraceConfig.ftrace_events)
  return ftrace_events_.Mutable(index);
}
inline void FtraceConfig::set_ftrace_events(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.FtraceConfig.ftrace_events)
  ftrace_events_.Mutable(index)->assign(value);
}
inline void FtraceConfig::set_ftrace_events(int index, const char* value) {
  ftrace_events_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.FtraceConfig.ftrace_events)
}
inline void FtraceConfig::set_ftrace_events(int index, const char* value, size_t size) {
  ftrace_events_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.FtraceConfig.ftrace_events)
}
inline ::std::string* FtraceConfig::add_ftrace_events() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.FtraceConfig.ftrace_events)
  return ftrace_events_.Add();
}
inline void FtraceConfig::add_ftrace_events(const ::std::string& value) {
  ftrace_events_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.FtraceConfig.ftrace_events)
}
inline void FtraceConfig::add_ftrace_events(const char* value) {
  ftrace_events_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.FtraceConfig.ftrace_events)
}
inline void FtraceConfig::add_ftrace_events(const char* value, size_t size) {
  ftrace_events_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.FtraceConfig.ftrace_events)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FtraceConfig::ftrace_events() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.FtraceConfig.ftrace_events)
  return ftrace_events_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FtraceConfig::mutable_ftrace_events() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.FtraceConfig.ftrace_events)
  return &ftrace_events_;
}

// repeated string atrace_categories = 2;
inline int FtraceConfig::atrace_categories_size() const {
  return atrace_categories_.size();
}
inline void FtraceConfig::clear_atrace_categories() {
  atrace_categories_.Clear();
}
inline const ::std::string& FtraceConfig::atrace_categories(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FtraceConfig.atrace_categories)
  return atrace_categories_.Get(index);
}
inline ::std::string* FtraceConfig::mutable_atrace_categories(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.FtraceConfig.atrace_categories)
  return atrace_categories_.Mutable(index);
}
inline void FtraceConfig::set_atrace_categories(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.FtraceConfig.atrace_categories)
  atrace_categories_.Mutable(index)->assign(value);
}
inline void FtraceConfig::set_atrace_categories(int index, const char* value) {
  atrace_categories_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.FtraceConfig.atrace_categories)
}
inline void FtraceConfig::set_atrace_categories(int index, const char* value, size_t size) {
  atrace_categories_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.FtraceConfig.atrace_categories)
}
inline ::std::string* FtraceConfig::add_atrace_categories() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.FtraceConfig.atrace_categories)
  return atrace_categories_.Add();
}
inline void FtraceConfig::add_atrace_categories(const ::std::string& value) {
  atrace_categories_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.FtraceConfig.atrace_categories)
}
inline void FtraceConfig::add_atrace_categories(const char* value) {
  atrace_categories_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.FtraceConfig.atrace_categories)
}
inline void FtraceConfig::add_atrace_categories(const char* value, size_t size) {
  atrace_categories_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.FtraceConfig.atrace_categories)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FtraceConfig::atrace_categories() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.FtraceConfig.atrace_categories)
  return atrace_categories_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FtraceConfig::mutable_atrace_categories() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.FtraceConfig.atrace_categories)
  return &atrace_categories_;
}

// repeated string atrace_apps = 3;
inline int FtraceConfig::atrace_apps_size() const {
  return atrace_apps_.size();
}
inline void FtraceConfig::clear_atrace_apps() {
  atrace_apps_.Clear();
}
inline const ::std::string& FtraceConfig::atrace_apps(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FtraceConfig.atrace_apps)
  return atrace_apps_.Get(index);
}
inline ::std::string* FtraceConfig::mutable_atrace_apps(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.FtraceConfig.atrace_apps)
  return atrace_apps_.Mutable(index);
}
inline void FtraceConfig::set_atrace_apps(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.FtraceConfig.atrace_apps)
  atrace_apps_.Mutable(index)->assign(value);
}
inline void FtraceConfig::set_atrace_apps(int index, const char* value) {
  atrace_apps_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.FtraceConfig.atrace_apps)
}
inline void FtraceConfig::set_atrace_apps(int index, const char* value, size_t size) {
  atrace_apps_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.FtraceConfig.atrace_apps)
}
inline ::std::string* FtraceConfig::add_atrace_apps() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.FtraceConfig.atrace_apps)
  return atrace_apps_.Add();
}
inline void FtraceConfig::add_atrace_apps(const ::std::string& value) {
  atrace_apps_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.FtraceConfig.atrace_apps)
}
inline void FtraceConfig::add_atrace_apps(const char* value) {
  atrace_apps_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.FtraceConfig.atrace_apps)
}
inline void FtraceConfig::add_atrace_apps(const char* value, size_t size) {
  atrace_apps_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.FtraceConfig.atrace_apps)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FtraceConfig::atrace_apps() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.FtraceConfig.atrace_apps)
  return atrace_apps_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FtraceConfig::mutable_atrace_apps() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.FtraceConfig.atrace_apps)
  return &atrace_apps_;
}

// optional uint32 buffer_size_kb = 10;
inline bool FtraceConfig::has_buffer_size_kb() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FtraceConfig::set_has_buffer_size_kb() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FtraceConfig::clear_has_buffer_size_kb() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FtraceConfig::clear_buffer_size_kb() {
  buffer_size_kb_ = 0u;
  clear_has_buffer_size_kb();
}
inline ::google::protobuf::uint32 FtraceConfig::buffer_size_kb() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FtraceConfig.buffer_size_kb)
  return buffer_size_kb_;
}
inline void FtraceConfig::set_buffer_size_kb(::google::protobuf::uint32 value) {
  set_has_buffer_size_kb();
  buffer_size_kb_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.FtraceConfig.buffer_size_kb)
}

// optional uint32 drain_period_ms = 11;
inline bool FtraceConfig::has_drain_period_ms() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FtraceConfig::set_has_drain_period_ms() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FtraceConfig::clear_has_drain_period_ms() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FtraceConfig::clear_drain_period_ms() {
  drain_period_ms_ = 0u;
  clear_has_drain_period_ms();
}
inline ::google::protobuf::uint32 FtraceConfig::drain_period_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FtraceConfig.drain_period_ms)
  return drain_period_ms_;
}
inline void FtraceConfig::set_drain_period_ms(::google::protobuf::uint32 value) {
  set_has_drain_period_ms();
  drain_period_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.FtraceConfig.drain_period_ms)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_perfetto_2fconfig_2fftrace_2fftrace_5fconfig_2eproto__INCLUDED
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/config/gpu/gpu_counter_config.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/config/gpu/gpu_counter_config.proto

#ifndef PROTOBUF_perfetto_2fconfig_2fgpu_2fgpu_5fcounter_5fconfig_2eproto__INCLUDED
#define PROTOBUF_perfetto_2fconfig_2fgpu_2fgpu_5fcounter_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_perfetto_2fconfig_2fgpu_2fgpu_5fcounter_5fconfig_2eproto();
void protobuf_AssignDesc_perfetto_2fconfig_2fgpu_2fgpu_5fcounter_5fconfig_2eproto();
void protobuf_ShutdownFile_perfetto_2fconfig_2fgpu_2fgpu_5fcounter_5fconfig_2eproto();

class GpuCounterConfig;

// ===================================================================

class GpuCounterConfig : public ::google::protobuf::MessageLite {
 public:
  GpuCounterConfig();
  virtual ~GpuCounterConfig();

  GpuCounterConfig(const GpuCounterConfig& from);

  inline GpuCounterConfig& operator=(const GpuCounterConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const GpuCounterConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GpuCounterConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GpuCounterConfig* other);

  // implements Message ----------------------------------------------

  inline GpuCounterConfig* New() const { return New(NULL); }

  GpuCounterConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GpuCounterConfig& from);
  void MergeFrom(const GpuCounterConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GpuCounterConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 counter_period_ns = 1;
  bool has_counter_period_ns() const;
  void clear_counter_period_ns();
  static const int kCounterPeriodNsFieldNumber = 1;
  ::google::protobuf::uint64 counter_period_ns() const;
  void set_counter_period_ns(::google::protobuf::uint64 value);

  // repeated uint32 counter_ids = 2;
  int counter_ids_size() const;
  void clear_counter_ids();
  static const int kCounterIdsFieldNumber = 2;
  ::google::protobuf::uint32 counter_ids(int index) const;
  void set_counter_ids(int index, ::google::protobuf::uint32 value);
  void add_counter_ids(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      counter_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_counter_ids();

  // @@protoc_insertion_point(class_scope:perfetto.protos.GpuCounterConfig)
 private:
  inline void set_has_counter_period_ns();
  inline void clear_has_counter_period_ns();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 counter_period_ns_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > counter_ids_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fconfig_2fgpu_2fgpu_5fcounter_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fconfig_2fgpu_2fgpu_5fcounter_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fconfig_2fgpu_2fgpu_5fcounter_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fconfig_2fgpu_2fgpu_5fcounter_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static GpuCounterConfig* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// GpuCounterConfig

// optional uint64 counter_period_ns = 1;
inline bool GpuCounterConfig::has_counter_period_ns() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GpuCounterConfig::set_has_counter_period_ns() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GpuCounterConfig::clear_has_counter_period_ns() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GpuCounterConfig::clear_counter_period_ns() {
  counter_period_ns_ = GOOGLE_ULONGLONG(0);
  clear_has_counter_period_ns();
}
inline ::google::protobuf::uint64 GpuCounterConfig::counter_period_ns() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterConfig.counter_period_ns)
  return counter_period_ns_;
}
inline void GpuCounterConfig::set_counter_period_ns(::google::protobuf::uint64 value) {
  set_has_counter_period_ns();
  counter_period_ns_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.GpuCounterConfig.counter_period_ns)
}

// repeated uint32 counter_ids = 2;
inline int GpuCounterConfig::counter_ids_size() const {
  return counter_ids_.size();
}
inline void GpuCounterConfig::clear_counter_ids() {
  counter_ids_.Clear();
}
inline ::google::protobuf::uint32 GpuCounterConfig::counter_ids(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterConfig.counter_ids)
  return counter_ids_.Get(index);
}
inline void GpuCounterConfig::set_counter_ids(int index, ::google::protobuf::uint32 value) {
  counter_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.GpuCounterConfig.counter_ids)
}
inline void GpuCounterConfig::add_counter_ids(::google::protobuf::uint32 value) {
  counter_ids_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.GpuCounterConfig.counter_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
GpuCounterConfig::counter_ids() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.GpuCounterConfig.counter_ids)
  return counter_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
GpuCounterConfig::mutable_counter_ids() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.GpuCounterConfig.counter_ids)
  return &counter_ids_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_perfetto_2fconfig_2fgpu_2fgpu_5fcounter_5fconfig_2eproto__INCLUDED
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/config/inode_file/inode_file_config.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/config/inode_file/inode_file_config.proto

#ifndef PROTOBUF_perfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto__INCLUDED
#define PROTOBUF_perfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_perfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto();
void protobuf_AssignDesc_perfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto();
void protobuf_ShutdownFile_perfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto();

class InodeFileConfig;
class InodeFileConfig_MountPointMappingEntry;

// ===================================================================

class InodeFileConfig_MountPointMappingEntry : public ::google::protobuf::MessageLite {
 public:
  InodeFileConfig_MountPointMappingEntry();
  virtual ~InodeFileConfig_MountPointMappingEntry();

  InodeFileConfig_MountPointMappingEntry(const InodeFileConfig_MountPointMappingEntry& from);

  inline InodeFileConfig_MountPointMappingEntry& operator=(const InodeFileConfig_MountPointMappingEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const InodeFileConfig_MountPointMappingEntry& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const InodeFileConfig_MountPointMappingEntry* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(InodeFileConfig_MountPointMappingEntry* other);

  // implements Message ----------------------------------------------

  inline InodeFileConfig_MountPointMappingEntry* New() const { return New(NULL); }

  InodeFileConfig_MountPointMappingEntry* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const InodeFileConfig_MountPointMappingEntry& from);
  void MergeFrom(const InodeFileConfig_MountPointMappingEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InodeFileConfig_MountPointMappingEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string mountpoint = 1;
  bool has_mountpoint() const;
  void clear_mountpoint();
  static const int kMountpointFieldNumber = 1;
  const ::std::string& mountpoint() const;
  void set_mountpoint(const ::std::string& value);
  void set_mountpoint(const char* value);
  void set_mountpoint(const char* value, size_t size);
  ::std::string* mutable_mountpoint();
  ::std::string* release_mountpoint();
  void set_allocated_mountpoint(::std::string* mountpoint);

  // repeated string scan_roots = 2;
  int scan_roots_size() const;
  void clear_scan_roots();
  static const int kScanRootsFieldNumber = 2;
  const ::std::string& scan_roots(int index) const;
  ::std::string* mutable_scan_roots(int index);
  void set_scan_roots(int index, const ::std::string& value);
  void set_scan_roots(int index, const char* value);
  void set_scan_roots(int index, const char* value, size_t size);
  ::std::string* add_scan_roots();
  void add_scan_roots(const ::std::string& value);
  void add_scan_roots(const char* value);
  void add_scan_roots(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& scan_roots() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_scan_roots();

  // @@protoc_insertion_point(class_scope:perfetto.protos.InodeFileConfig.MountPointMappingEntry)
 private:
  inline void set_has_mountpoint();
  inline void clear_has_mountpoint();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr mountpoint_;
  ::google::protobuf::RepeatedPtrField< ::std::string> scan_roots_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static InodeFileConfig_MountPointMappingEntry* default_instance_;
};
// -------------------------------------------------------------------

class InodeFileConfig : public ::google::protobuf::MessageLite {
 public:
  InodeFileConfig();
  virtual ~InodeFileConfig();

  InodeFileConfig(const InodeFileConfig& from);

  inline InodeFileConfig& operator=(const InodeFileConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const InodeFileConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const InodeFileConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(InodeFileConfig* other);

  // implements Message ----------------------------------------------

  inline InodeFileConfig* New() const { return New(NULL); }

  InodeFileConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const InodeFileConfig& from);
  void MergeFrom(const InodeFileConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InodeFileConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef InodeFileConfig_MountPointMappingEntry MountPointMappingEntry;

  // accessors -------------------------------------------------------

  // optional uint32 scan_interval_ms = 1;
  bool has_scan_interval_ms() const;
  void clear_scan_interval_ms();
  static const int kScanIntervalMsFieldNumber = 1;
  ::google::protobuf::uint32 scan_interval_ms() const;
  void set_scan_interval_ms(::google::protobuf::uint32 value);

  // optional uint32 scan_delay_ms = 2;
  bool has_scan_delay_ms() const;
  void clear_scan_delay_ms();
  static const int kScanDelayMsFieldNumber = 2;
  ::google::protobuf::uint32 scan_delay_ms() const;
  void set_scan_delay_ms(::google::protobuf::uint32 value);

  // optional uint32 scan_batch_size = 3;
  bool has_scan_batch_size() const;
  void clear_scan_batch_size();
  static const int kScanBatchSizeFieldNumber = 3;
  ::google::protobuf::uint32 scan_batch_size() const;
  void set_scan_batch_size(::google::protobuf::uint32 value);

  // optional bool do_not_scan = 4;
  bool has_do_not_scan() const;
  void clear_do_not_scan();
  static const int kDoNotScanFieldNumber = 4;
  bool do_not_scan() const;
  void set_do_not_scan(bool value);

  // repeated string scan_mount_points = 5;
  int scan_mount_points_size() const;
  void clear_scan_mount_points();
  static const int kScanMountPointsFieldNumber = 5;
  const ::std::string& scan_mount_points(int index) const;
  ::std::string* mutable_scan_mount_points(int index);
  void set_scan_mount_points(int index, const ::std::string& value);
  void set_scan_mount_points(int index, const char* value);
  void set_scan_mount_points(int index, const char* value, size_t size);
  ::std::string* add_scan_mount_points();
  void add_scan_mount_points(const ::std::string& value);
  void add_scan_mount_points(const char* value);
  void add_scan_mount_points(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& scan_mount_points() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_scan_mount_points();

  // repeated .perfetto.protos.InodeFileConfig.MountPointMappingEntry mount_point_mapping = 6;
  int mount_point_mapping_size() const;
  void clear_mount_point_mapping();
  static const int kMountPointMappingFieldNumber = 6;
  const ::perfetto::protos::InodeFileConfig_MountPointMappingEntry& mount_point_mapping(int index) const;
  ::perfetto::protos::InodeFileConfig_MountPointMappingEntry* mutable_mount_point_mapping(int index);
  ::perfetto::protos::InodeFileConfig_MountPointMappingEntry* add_mount_point_mapping();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::InodeFileConfig_MountPointMappingEntry >*
      mutable_mount_point_mapping();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::InodeFileConfig_MountPointMappingEntry >&
      mount_point_mapping() const;

  // @@protoc_insertion_point(class_scope:perfetto.protos.InodeFileConfig)
 private:
  inline void set_has_scan_interval_ms();
  inline void clear_has_scan_interval_ms();
  inline void set_has_scan_delay_ms();
  inline void clear_has_scan_delay_ms();
  inline void set_has_scan_batch_size();
  inline void clear_has_scan_batch_size();
  inline void set_has_do_not_scan();
  inline void clear_has_do_not_scan();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 scan_interval_ms_;
  ::google::protobuf::uint32 scan_delay_ms_;
  ::google::protobuf::uint32 scan_batch_size_;
  bool do_not_scan_;
  ::google::protobuf::RepeatedPtrField< ::std::string> scan_mount_points_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::InodeFileConfig_MountPointMappingEntry > mount_point_mapping_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static InodeFileConfig* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// InodeFileConfig_MountPointMappingEntry

// optional string mountpoint = 1;
inline bool InodeFileConfig_MountPointMappingEntry::has_mountpoint() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InodeFileConfig_MountPointMappingEntry::set_has_mountpoint() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InodeFileConfig_MountPointMappingEntry::clear_has_mountpoint() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InodeFileConfig_MountPointMappingEntry::clear_mountpoint() {
  mountpoint_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mountpoint();
}
inline const ::std::string& InodeFileConfig_MountPointMappingEntry::mountpoint() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InodeFileConfig.MountPointMappingEntry.mountpoint)
  return mountpoint_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InodeFileConfig_MountPointMappingEntry::set_mountpoint(const ::std::string& value) {
  set_has_mountpoint();
  mountpoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.InodeFileConfig.MountPointMappingEntry.mountpoint)
}
inline void InodeFileConfig_MountPointMappingEntry::set_mountpoint(const char* value) {
  set_has_mountpoint();
  mountpoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.InodeFileConfig.MountPointMappingEntry.mountpoint)
}
inline void InodeFileConfig_MountPointMappingEntry::set_mountpoint(const char* value, size_t size) {
  set_has_mountpoint();
  mountpoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.InodeFileConfig.MountPointMappingEntry.mountpoint)
}
inline ::std::string* InodeFileConfig_MountPointMappingEntry::mutable_mountpoint() {
  set_has_mountpoint();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.InodeFileConfig.MountPointMappingEntry.mountpoint)
  return mountpoint_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InodeFileConfig_MountPointMappingEntry::release_mountpoint() {
  // @@protoc_insertion_point(field_release:perfetto.protos.InodeFileConfig.MountPointMappingEntry.mountpoint)
  clear_has_mountpoint();
  return mountpoint_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InodeFileConfig_MountPointMappingEntry::set_allocated_mountpoint(::std::string* mountpoint) {
  if (mountpoint != NULL) {
    set_has_mountpoint();
  } else {
    clear_has_mountpoint();
  }
  mountpoint_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mountpoint);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.InodeFileConfig.MountPointMappingEntry.mountpoint)
}

// repeated string scan_roots = 2;
inline int InodeFileConfig_MountPointMappingEntry::scan_roots_size() const {
  return scan_roots_.size();
}
inline void InodeFileConfig_MountPointMappingEntry::clear_scan_roots() {
  scan_roots_.Clear();
}
inline const ::std::string& InodeFileConfig_MountPointMappingEntry::scan_roots(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InodeFileConfig.MountPointMappingEntry.scan_roots)
  return scan_roots_.Get(index);
}
inline ::std::string* InodeFileConfig_MountPointMappingEntry::mutable_scan_roots(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.InodeFileConfig.MountPointMappingEntry.scan_roots)
  return scan_roots_.Mutable(index);
}
inline void InodeFileConfig_MountPointMappingEntry::set_scan_roots(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.InodeFileConfig.MountPointMappingEntry.scan_roots)
  scan_roots_.Mutable(index)->assign(value);
}
inline void InodeFileConfig_MountPointMappingEntry::set_scan_roots(int index, const char* value) {
  scan_roots_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.InodeFileConfig.MountPointMappingEntry.scan_roots)
}
inline void InodeFileConfig_MountPointMappingEntry::set_scan_roots(int index, const char* value, size_t size) {
  scan_roots_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.InodeFileConfig.MountPointMappingEntry.scan_roots)
}
inline ::std::string* InodeFileConfig_MountPointMappingEntry::add_scan_roots() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.InodeFileConfig.MountPointMappingEntry.scan_roots)
  return scan_roots_.Add();
}
inline void InodeFileConfig_MountPointMappingEntry::add_scan_roots(const ::std::string& value) {
  scan_roots_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.InodeFileConfig.MountPointMappingEntry.scan_roots)
}
inline void InodeFileConfig_MountPointMappingEntry::add_scan_roots(const char* value) {
  scan_roots_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.InodeFileConfig.MountPointMappingEntry.scan_roots)
}
inline void InodeFileConfig_MountPointMappingEntry::add_scan_roots(const char* value, size_t size) {
  scan_roots_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.InodeFileConfig.MountPointMappingEntry.scan_roots)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
InodeFileConfig_MountPointMappingEntry::scan_roots() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.InodeFileConfig.MountPointMappingEntry.scan_roots)
  return scan_roots_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
InodeFileConfig_MountPointMappingEntry::mutable_scan_roots() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.InodeFileConfig.MountPointMappingEntry.scan_roots)
  return &scan_roots_;
}

// -------------------------------------------------------------------

// InodeFileConfig

// optional uint32 scan_interval_ms = 1;
inline bool InodeFileConfig::has_scan_interval_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InodeFileConfig::set_has_scan_interval_ms() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InodeFileConfig::clear_has_scan_interval_ms() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InodeFileConfig::clear_scan_interval_ms() {
  scan_interval_ms_ = 0u;
  clear_has_scan_interval_ms();
}
inline ::google::protobuf::uint32 InodeFileConfig::scan_interval_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InodeFileConfig.scan_interval_ms)
  return scan_interval_ms_;
}
inline void InodeFileConfig::set_scan_interval_ms(::google::protobuf::uint32 value) {
  set_has_scan_interval_ms();
  scan_interval_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.InodeFileConfig.scan_interval_ms)
}

// optional uint32 scan_delay_ms = 2;
inline bool InodeFileConfig::has_scan_delay_ms() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InodeFileConfig::set_has_scan_delay_ms() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InodeFileConfig::clear_has_scan_delay_ms() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InodeFileConfig::clear_scan_delay_ms() {
  scan_delay_ms_ = 0u;
  clear_has_scan_delay_ms();
}
inline ::google::protobuf::uint32 InodeFileConfig::scan_delay_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InodeFileConfig.scan_delay_ms)
  return scan_delay_ms_;
}
inline void InodeFileConfig::set_scan_delay_ms(::google::protobuf::uint32 value) {
  set_has_scan_delay_ms();
  scan_delay_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.InodeFileConfig.scan_delay_ms)
}

// optional uint32 scan_batch_size = 3;
inline bool InodeFileConfig::has_scan_batch_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InodeFileConfig::set_has_scan_batch_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InodeFileConfig::clear_has_scan_batch_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InodeFileConfig::clear_scan_batch_size() {
  scan_batch_size_ = 0u;
  clear_has_scan_batch_size();
}
inline ::google::protobuf::uint32 InodeFileConfig::scan_batch_size() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InodeFileConfig.scan_batch_size)
  return scan_batch_size_;
}
inline void InodeFileConfig::set_scan_batch_size(::google::protobuf::uint32 value) {
  set_has_scan_batch_size();
  scan_batch_size_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.InodeFileConfig.scan_batch_size)
}

// optional bool do_not_scan = 4;
inline bool InodeFileConfig::has_do_not_scan() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InodeFileConfig::set_has_do_not_scan() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InodeFileConfig::clear_has_do_not_scan() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InodeFileConfig::clear_do_not_scan() {
  do_not_scan_ = false;
  clear_has_do_not_scan();
}
inline bool InodeFileConfig::do_not_scan() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InodeFileConfig.do_not_scan)
  return do_not_scan_;
}
inline void InodeFileConfig::set_do_not_scan(bool value) {
  set_has_do_not_scan();
  do_not_scan_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.InodeFileConfig.do_not_scan)
}

// repeated string scan_mount_points = 5;
inline int InodeFileConfig::scan_mount_points_size() const {
  return scan_mount_points_.size();
}
inline void InodeFileConfig::clear_scan_mount_points() {
  scan_mount_points_.Clear();
}
inline const ::std::string& InodeFileConfig::scan_mount_points(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InodeFileConfig.scan_mount_points)
  return scan_mount_points_.Get(index);
}
inline ::std::string* InodeFileConfig::mutable_scan_mount_points(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.InodeFileConfig.scan_mount_points)
  return scan_mount_points_.Mutable(index);
}
inline void InodeFileConfig::set_scan_mount_points(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.InodeFileConfig.scan_mount_points)
  scan_mount_points_.Mutable(index)->assign(value);
}
inline void InodeFileConfig::set_scan_mount_points(int index, const char* value) {
  scan_mount_points_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.InodeFileConfig.scan_mount_points)
}
inline void InodeFileConfig::set_scan_mount_points(int index, const char* value, size_t size) {
  scan_mount_points_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.InodeFileConfig.scan_mount_points)
}
inline ::std::string* InodeFileConfig::add_scan_mount_points() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.InodeFileConfig.scan_mount_points)
  return scan_mount_points_.Add();
}
inline void InodeFileConfig::add_scan_mount_points(const ::std::string& value) {
  scan_mount_points_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.InodeFileConfig.scan_mount_points)
}
inline void InodeFileConfig::add_scan_mount_points(const char* value) {
  scan_mount_points_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.InodeFileConfig.scan_mount_points)
}
inline void InodeFileConfig::add_scan_mount_points(const char* value, size_t size) {
  scan_mount_points_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.InodeFileConfig.scan_mount_points)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
InodeFileConfig::scan_mount_points() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.InodeFileConfig.scan_mount_points)
  return scan_mount_points_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
InodeFileConfig::mutable_scan_mount_points() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.InodeFileConfig.scan_mount_points)
  return &scan_mount_points_;
}

// repeated .perfetto.protos.InodeFileConfig.MountPointMappingEntry mount_point_mapping = 6;
inline int InodeFileConfig::mount_point_mapping_size() const {
  return mount_point_mapping_.size();
}
inline void InodeFileConfig::clear_mount_point_mapping() {
  mount_point_mapping_.Clear();
}
inline const ::perfetto::protos::InodeFileConfig_MountPointMappingEntry& InodeFileConfig::mount_point_mapping(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InodeFileConfig.mount_point_mapping)
  return mount_point_mapping_.Get(index);
}
inline ::perfetto::protos::InodeFileConfig_MountPointMappingEntry* InodeFileConfig::mutable_mount_point_mapping(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.InodeFileConfig.mount_point_mapping)
  return mount_point_mapping_.Mutable(index);
}
inline ::perfetto::protos::InodeFileConfig_MountPointMappingEntry* InodeFileConfig::add_mount_point_mapping() {
  // @@protoc_insertion_point(field_add:perfetto.protos.InodeFileConfig.mount_point_mapping)
  return mount_point_mapping_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::InodeFileConfig_MountPointMappingEntry >*
InodeFileConfig::mutable_mount_point_mapping() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.InodeFileConfig.mount_point_mapping)
  return &mount_point_mapping_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::InodeFileConfig_MountPointMappingEntry >&
InodeFileConfig::mount_point_mapping() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.InodeFileConfig.mount_point_mapping)
  return mount_point_mapping_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_perfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto__INCLUDED
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/config/power/android_power_config.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/config/power/android_power_config.proto

#ifndef PROTOBUF_perfetto_2fconfig_2fpower_2fandroid_5fpower_5fconfig_2eproto__INCLUDED
#define PROTOBUF_perfetto_2fconfig_2fpower_2fandroid_5fpower_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_perfetto_2fconfig_2fpower_2fandroid_5fpower_5fconfig_2eproto();
void protobuf_AssignDesc_perfetto_2fconfig_2fpower_2fandroid_5fpower_5fconfig_2eproto();
void protobuf_ShutdownFile_perfetto_2fconfig_2fpower_2fandroid_5fpower_5fconfig_2eproto();

class AndroidPowerConfig;

enum AndroidPowerConfig_BatteryCounters {
  AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_UNSPECIFIED = 0,
  AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_CHARGE = 1,
  AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_CAPACITY_PERCENT = 2,
  AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_CURRENT = 3,
  AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_CURRENT_AVG = 4
};
bool AndroidPowerConfig_BatteryCounters_IsValid(int value);
const AndroidPowerConfig_BatteryCounters AndroidPowerConfig_BatteryCounters_BatteryCounters_MIN = AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_UNSPECIFIED;
const AndroidPowerConfig_BatteryCounters AndroidPowerConfig_BatteryCounters_BatteryCounters_MAX = AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_CURRENT_AVG;
const int AndroidPowerConfig_BatteryCounters_BatteryCounters_ARRAYSIZE = AndroidPowerConfig_BatteryCounters_BatteryCounters_MAX + 1;

// ===================================================================

class AndroidPowerConfig : public ::google::protobuf::MessageLite {
 public:
  AndroidPowerConfig();
  virtual ~AndroidPowerConfig();

  AndroidPowerConfig(const AndroidPowerConfig& from);

  inline AndroidPowerConfig& operator=(const AndroidPowerConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const AndroidPowerConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AndroidPowerConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AndroidPowerConfig* other);

  // implements Message ----------------------------------------------

  inline AndroidPowerConfig* New() const { return New(NULL); }

  AndroidPowerConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AndroidPowerConfig& from);
  void MergeFrom(const AndroidPowerConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AndroidPowerConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef AndroidPowerConfig_BatteryCounters BatteryCounters;
  static const BatteryCounters BATTERY_COUNTER_UNSPECIFIED =
    AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_UNSPECIFIED;
  static const BatteryCounters BATTERY_COUNTER_CHARGE =
    AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_CHARGE;
  static const BatteryCounters BATTERY_COUNTER_CAPACITY_PERCENT =
    AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_CAPACITY_PERCENT;
  static const BatteryCounters BATTERY_COUNTER_CURRENT =
    AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_CURRENT;
  static const BatteryCounters BATTERY_COUNTER_CURRENT_AVG =
    AndroidPowerConfig_BatteryCounters_BATTERY_COUNTER_CURRENT_AVG;
  static inline bool BatteryCounters_IsValid(int value) {
    return AndroidPowerConfig_BatteryCounters_IsValid(value);
  }
  static const BatteryCounters BatteryCounters_MIN =
    AndroidPowerConfig_BatteryCounters_BatteryCounters_MIN;
  static const BatteryCounters BatteryCounters_MAX =
    AndroidPowerConfig_BatteryCounters_BatteryCounters_MAX;
  static const int BatteryCounters_ARRAYSIZE =
    AndroidPowerConfig_BatteryCounters_BatteryCounters_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional uint32 battery_poll_ms = 1;
  bool has_battery_poll_ms() const;
  void clear_battery_poll_ms();
  static const int kBatteryPollMsFieldNumber = 1;
  ::google::protobuf::uint32 battery_poll_ms() const;
  void set_battery_poll_ms(::google::protobuf::uint32 value);

  // repeated .perfetto.protos.AndroidPowerConfig.BatteryCounters battery_counters = 2;
  int battery_counters_size() const;
  void clear_battery_counters();
  static const int kBatteryCountersFieldNumber = 2;
  ::perfetto::protos::AndroidPowerConfig_BatteryCounters battery_counters(int index) const;
  void set_battery_counters(int index, ::perfetto::protos::AndroidPowerConfig_BatteryCounters value);
  void add_battery_counters(::perfetto::protos::AndroidPowerConfig_BatteryCounters value);
  const ::google::protobuf::RepeatedField<int>& battery_counters() const;
  ::google::protobuf::RepeatedField<int>* mutable_battery_counters();

  // optional bool collect_power_rails = 3;
  bool has_collect_power_rails() const;
  void clear_collect_power_rails();
  static const int kCollectPowerRailsFieldNumber = 3;
  bool collect_power_rails() const;
  void set_collect_power_rails(bool value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.AndroidPowerConfig)
 private:
  inline void set_has_battery_poll_ms();
  inline void clear_has_battery_poll_ms();
  inline void set_has_collect_power_rails();
  inline void clear_has_collect_power_rails();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField<int> battery_counters_;
  ::google::protobuf::uint32 battery_poll_ms_;
  bool collect_power_rails_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fconfig_2fpower_2fandroid_5fpower_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fconfig_2fpower_2fandroid_5fpower_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fconfig_2fpower_2fandroid_5fpower_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fconfig_2fpower_2fandroid_5fpower_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static AndroidPowerConfig* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// AndroidPowerConfig

// optional uint32 battery_poll_ms = 1;
inline bool AndroidPowerConfig::has_battery_poll_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AndroidPowerConfig::set_has_battery_poll_ms() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AndroidPowerConfig::clear_has_battery_poll_ms() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AndroidPowerConfig::clear_battery_poll_ms() {
  battery_poll_ms_ = 0u;
  clear_has_battery_poll_ms();
}
inline ::google::protobuf::uint32 AndroidPowerConfig::battery_poll_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AndroidPowerConfig.battery_poll_ms)
  return battery_poll_ms_;
}
inline void AndroidPowerConfig::set_battery_poll_ms(::google::protobuf::uint32 value) {
  set_has_battery_poll_ms();
  battery_poll_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.AndroidPowerConfig.battery_poll_ms)
}

// repeated .perfetto.protos.AndroidPowerConfig.BatteryCounters battery_counters = 2;
inline int AndroidPowerConfig::battery_counters_size() const {
  return battery_counters_.size();
}
inline void AndroidPowerConfig::clear_battery_counters() {
  battery_counters_.Clear();
}
inline ::perfetto::protos::AndroidPowerConfig_BatteryCounters AndroidPowerConfig::battery_counters(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AndroidPowerConfig.battery_counters)
  return static_cast< ::perfetto::protos::AndroidPowerConfig_BatteryCounters >(battery_counters_.Get(index));
}
inline void AndroidPowerConfig::set_battery_counters(int index, ::perfetto::protos::AndroidPowerConfig_BatteryCounters value) {
  assert(::perfetto::protos::AndroidPowerConfig_BatteryCounters_IsValid(value));
  battery_counters_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.AndroidPowerConfig.battery_counters)
}
inline void AndroidPowerConfig::add_battery_counters(::perfetto::protos::AndroidPowerConfig_BatteryCounters value) {
  assert(::perfetto::protos::AndroidPowerConfig_BatteryCounters_IsValid(value));
  battery_counters_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.AndroidPowerConfig.battery_counters)
}
inline const ::google::protobuf::RepeatedField<int>&
AndroidPowerConfig::battery_counters() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.AndroidPowerConfig.battery_counters)
  return battery_counters_;
}
inline ::google::protobuf::RepeatedField<int>*
AndroidPowerConfig::mutable_battery_counters() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.AndroidPowerConfig.battery_counters)
  return &battery_counters_;
}

// optional bool collect_power_rails = 3;
inline bool AndroidPowerConfig::has_collect_power_rails() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AndroidPowerConfig::set_has_collect_power_rails() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AndroidPowerConfig::clear_has_collect_power_rails() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AndroidPowerConfig::clear_collect_power_rails() {
  collect_power_rails_ = false;
  clear_has_collect_power_rails();
}
inline bool AndroidPowerConfig::collect_power_rails() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AndroidPowerConfig.collect_power_rails)
  return collect_power_rails_;
}
inline void AndroidPowerConfig::set_collect_power_rails(bool value) {
  set_has_collect_power_rails();
  collect_power_rails_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.AndroidPowerConfig.collect_power_rails)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::perfetto::protos::AndroidPowerConfig_BatteryCounters> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_perfetto_2fconfig_2fpower_2fandroid_5fpower_5fconfig_2eproto__INCLUDED
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/config/process_stats/process_stats_config.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/config/process_stats/process_stats_config.proto

#ifndef PROTOBUF_perfetto_2fconfig_2fprocess_5fstats_2fprocess_5fstats_5fconfig_2eproto__INCLUDED
#define PROTOBUF_perfetto_2fconfig_2fprocess_5fstats_2fprocess_5fstats_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_perfetto_2fconfig_2fprocess_5fstats_2fprocess_5fstats_5fconfig_2eproto();
void protobuf_AssignDesc_perfetto_2fconfig_2fprocess_5fstats_2fprocess_5fstats_5fconfig_2eproto();
void protobuf_ShutdownFile_perfetto_2fconfig_2fprocess_5fstats_2fprocess_5fstats_5fconfig_2eproto();

class ProcessStatsConfig;

enum ProcessStatsConfig_Quirks {
  ProcessStatsConfig_Quirks_QUIRKS_UNSPECIFIED = 0,
  ProcessStatsConfig_Quirks_DISABLE_INITIAL_DUMP PROTOBUF_DEPRECATED = 1,
  ProcessStatsConfig_Quirks_DISABLE_ON_DEMAND = 2
};
bool ProcessStatsConfig_Quirks_IsValid(int value);
const ProcessStatsConfig_Quirks ProcessStatsConfig_Quirks_Quirks_MIN = ProcessStatsConfig_Quirks_QUIRKS_UNSPECIFIED;
const ProcessStatsConfig_Quirks ProcessStatsConfig_Quirks_Quirks_MAX = ProcessStatsConfig_Quirks_DISABLE_ON_DEMAND;
const int ProcessStatsConfig_Quirks_Quirks_ARRAYSIZE = ProcessStatsConfig_Quirks_Quirks_MAX + 1;

// ===================================================================

class ProcessStatsConfig : public ::google::protobuf::MessageLite {
 public:
  ProcessStatsConfig();
  virtual ~ProcessStatsConfig();

  ProcessStatsConfig(const ProcessStatsConfig& from);

  inline ProcessStatsConfig& operator=(const ProcessStatsConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ProcessStatsConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ProcessStatsConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ProcessStatsConfig* other);

  // implements Message ----------------------------------------------

  inline ProcessStatsConfig* New() const { return New(NULL); }

  ProcessStatsConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ProcessStatsConfig& from);
  void MergeFrom(const ProcessStatsConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ProcessStatsConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ProcessStatsConfig_Quirks Quirks;
  static const Quirks QUIRKS_UNSPECIFIED =
    ProcessStatsConfig_Quirks_QUIRKS_UNSPECIFIED;
  PROTOBUF_DEPRECATED_ATTR static const Quirks DISABLE_INITIAL_DUMP =
    ProcessStatsConfig_Quirks_DISABLE_INITIAL_DUMP;
  static const Quirks DISABLE_ON_DEMAND =
    ProcessStatsConfig_Quirks_DISABLE_ON_DEMAND;
  static inline bool Quirks_IsValid(int value) {
    return ProcessStatsConfig_Quirks_IsValid(value);
  }
  static const Quirks Quirks_MIN =
    ProcessStatsConfig_Quirks_Quirks_MIN;
  static const Quirks Quirks_MAX =
    ProcessStatsConfig_Quirks_Quirks_MAX;
  static const int Quirks_ARRAYSIZE =
    ProcessStatsConfig_Quirks_Quirks_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .perfetto.protos.ProcessStatsConfig.Quirks quirks = 1;
  int quirks_size() const;
  void clear_quirks();
  static const int kQuirksFieldNumber = 1;
  ::perfetto::protos::ProcessStatsConfig_Quirks quirks(int index) const;
  void set_quirks(int index, ::perfetto::protos::ProcessStatsConfig_Quirks value);
  void add_quirks(::perfetto::protos::ProcessStatsConfig_Quirks value);
  const ::google::protobuf::RepeatedField<int>& quirks() const;
  ::google::protobuf::RepeatedField<int>* mutable_quirks();

  // optional bool scan_all_processes_on_start = 2;
  bool has_scan_all_processes_on_start() const;
  void clear_scan_all_processes_on_start();
  static const int kScanAllProcessesOnStartFieldNumber = 2;
  bool scan_all_processes_on_start() const;
  void set_scan_all_processes_on_start(bool value);

  // optional bool record_thread_names = 3;
  bool has_record_thread_names() const;
  void clear_record_thread_names();
  static const int kRecordThreadNamesFieldNumber = 3;
  bool record_thread_names() const;
  void set_record_thread_names(bool value);

  // optional uint32 proc_stats_poll_ms = 4;
  bool has_proc_stats_poll_ms() const;
  void clear_proc_stats_poll_ms();
  static const int kProcStatsPollMsFieldNumber = 4;
  ::google::protobuf::uint32 proc_stats_poll_ms() const;
  void set_proc_stats_poll_ms(::google::protobuf::uint32 value);

  // optional uint32 proc_stats_cache_ttl_ms = 6;
  bool has_proc_stats_cache_ttl_ms() const;
  void clear_proc_stats_cache_ttl_ms();
  static const int kProcStatsCacheTtlMsFieldNumber = 6;
  ::google::protobuf::uint32 proc_stats_cache_ttl_ms() const;
  void set_proc_stats_cache_ttl_ms(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.ProcessStatsConfig)
 private:
  inline void set_has_scan_all_processes_on_start();
  inline void clear_has_scan_all_processes_on_start();
  inline void set_has_record_thread_names();
  inline void clear_has_record_thread_names();
  inline void set_has_proc_stats_poll_ms();
  inline void clear_has_proc_stats_poll_ms();
  inline void set_has_proc_stats_cache_ttl_ms();
  inline void clear_has_proc_stats_cache_ttl_ms();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField<int> quirks_;
  bool scan_all_processes_on_start_;
  bool record_thread_names_;
  ::google::protobuf::uint32 proc_stats_poll_ms_;
  ::google::protobuf::uint32 proc_stats_cache_ttl_ms_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fconfig_2fprocess_5fstats_2fprocess_5fstats_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fconfig_2fprocess_5fstats_2fprocess_5fstats_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fconfig_2fprocess_5fstats_2fprocess_5fstats_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fconfig_2fprocess_5fstats_2fprocess_5fstats_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static ProcessStatsConfig* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// ProcessStatsConfig

// repeated .perfetto.protos.ProcessStatsConfig.Quirks quirks = 1;
inline int ProcessStatsConfig::quirks_size() const {
  return quirks_.size();
}
inline void ProcessStatsConfig::clear_quirks() {
  quirks_.Clear();
}
inline ::perfetto::protos::ProcessStatsConfig_Quirks ProcessStatsConfig::quirks(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ProcessStatsConfig.quirks)
  return static_cast< ::perfetto::protos::ProcessStatsConfig_Quirks >(quirks_.Get(index));
}
inline void ProcessStatsConfig::set_quirks(int index, ::perfetto::protos::ProcessStatsConfig_Quirks value) {
  assert(::perfetto::protos::ProcessStatsConfig_Quirks_IsValid(value));
  quirks_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.ProcessStatsConfig.quirks)
}
inline void ProcessStatsConfig::add_quirks(::perfetto::protos::ProcessStatsConfig_Quirks value) {
  assert(::perfetto::protos::ProcessStatsConfig_Quirks_IsValid(value));
  quirks_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.ProcessStatsConfig.quirks)
}
inline const ::google::protobuf::RepeatedField<int>&
ProcessStatsConfig::quirks() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.ProcessStatsConfig.quirks)
  return quirks_;
}
inline ::google::protobuf::RepeatedField<int>*
ProcessStatsConfig::mutable_quirks() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.ProcessStatsConfig.quirks)
  return &quirks_;
}

// optional bool scan_all_processes_on_start = 2;
inline bool ProcessStatsConfig::has_scan_all_processes_on_start() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProcessStatsConfig::set_has_scan_all_processes_on_start() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProcessStatsConfig::clear_has_scan_all_processes_on_start() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProcessStatsConfig::clear_scan_all_processes_on_start() {
  scan_all_processes_on_start_ = false;
  clear_has_scan_all_processes_on_start();
}
inline bool ProcessStatsConfig::scan_all_processes_on_start() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ProcessStatsConfig.scan_all_processes_on_start)
  return scan_all_processes_on_start_;
}
inline void ProcessStatsConfig::set_scan_all_processes_on_start(bool value) {
  set_has_scan_all_processes_on_start();
  scan_all_processes_on_start_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.ProcessStatsConfig.scan_all_processes_on_start)
}

// optional bool record_thread_names = 3;
inline bool ProcessStatsConfig::has_record_thread_names() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProcessStatsConfig::set_has_record_thread_names() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProcessStatsConfig::clear_has_record_thread_names() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProcessStatsConfig::clear_record_thread_names() {
  record_thread_names_ = false;
  clear_has_record_thread_names();
}
inline bool ProcessStatsConfig::record_thread_names() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ProcessStatsConfig.record_thread_names)
  return record_thread_names_;
}
inline void ProcessStatsConfig::set_record_thread_names(bool value) {
  set_has_record_thread_names();
  record_thread_names_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.ProcessStatsConfig.record_thread_names)
}

// optional uint32 proc_stats_poll_ms = 4;
inline bool ProcessStatsConfig::has_proc_stats_poll_ms() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProcessStatsConfig::set_has_proc_stats_poll_ms() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProcessStatsConfig::clear_has_proc_stats_poll_ms() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProcessStatsConfig::clear_proc_stats_poll_ms() {
  proc_stats_poll_ms_ = 0u;
  clear_has_proc_stats_poll_ms();
}
inline ::google::protobuf::uint32 ProcessStatsConfig::proc_stats_poll_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ProcessStatsConfig.proc_stats_poll_ms)
  return proc_stats_poll_ms_;
}
inline void ProcessStatsConfig::set_proc_stats_poll_ms(::google::protobuf::uint32 value) {
  set_has_proc_stats_poll_ms();
  proc_stats_poll_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.ProcessStatsConfig.proc_stats_poll_ms)
}

// optional uint32 proc_stats_cache_ttl_ms = 6;
inline bool ProcessStatsConfig::has_proc_stats_cache_ttl_ms() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProcessStatsConfig::set_has_proc_stats_cache_ttl_ms() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProcessStatsConfig::clear_has_proc_stats_cache_ttl_ms() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProcessStatsConfig::clear_proc_stats_cache_ttl_ms() {
  proc_stats_cache_ttl_ms_ = 0u;
  clear_has_proc_stats_cache_ttl_ms();
}
inline ::google::protobuf::uint32 ProcessStatsConfig::proc_stats_cache_ttl_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ProcessStatsConfig.proc_stats_cache_ttl_ms)
  return proc_stats_cache_ttl_ms_;
}
inline void ProcessStatsConfig::set_proc_stats_cache_ttl_ms(::google::protobuf::uint32 value) {
  set_has_proc_stats_cache_ttl_ms();
  proc_stats_cache_ttl_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.ProcessStatsConfig.proc_stats_cache_ttl_ms)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::perfetto::protos::ProcessStatsConfig_Quirks> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_perfetto_2fconfig_2fprocess_5fstats_2fprocess_5fstats_5fconfig_2eproto__INCLUDED
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/config/profiling/heapprofd_config.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/config/profiling/heapprofd_config.proto

#ifndef PROTOBUF_perfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto__INCLUDED
#define PROTOBUF_perfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_perfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto();
void protobuf_AssignDesc_perfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto();
void protobuf_ShutdownFile_perfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto();

class HeapprofdConfig;
class HeapprofdConfig_ContinuousDumpConfig;

// ===================================================================

class HeapprofdConfig_ContinuousDumpConfig : public ::google::protobuf::MessageLite {
 public:
  HeapprofdConfig_ContinuousDumpConfig();
  virtual ~HeapprofdConfig_ContinuousDumpConfig();

  HeapprofdConfig_ContinuousDumpConfig(const HeapprofdConfig_ContinuousDumpConfig& from);

  inline HeapprofdConfig_ContinuousDumpConfig& operator=(const HeapprofdConfig_ContinuousDumpConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const HeapprofdConfig_ContinuousDumpConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const HeapprofdConfig_ContinuousDumpConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(HeapprofdConfig_ContinuousDumpConfig* other);

  // implements Message ----------------------------------------------

  inline HeapprofdConfig_ContinuousDumpConfig* New() const { return New(NULL); }

  HeapprofdConfig_ContinuousDumpConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const HeapprofdConfig_ContinuousDumpConfig& from);
  void MergeFrom(const HeapprofdConfig_ContinuousDumpConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HeapprofdConfig_ContinuousDumpConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 dump_phase_ms = 5;
  bool has_dump_phase_ms() const;
  void clear_dump_phase_ms();
  static const int kDumpPhaseMsFieldNumber = 5;
  ::google::protobuf::uint32 dump_phase_ms() const;
  void set_dump_phase_ms(::google::protobuf::uint32 value);

  // optional uint32 dump_interval_ms = 6;
  bool has_dump_interval_ms() const;
  void clear_dump_interval_ms();
  static const int kDumpIntervalMsFieldNumber = 6;
  ::google::protobuf::uint32 dump_interval_ms() const;
  void set_dump_interval_ms(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.HeapprofdConfig.ContinuousDumpConfig)
 private:
  inline void set_has_dump_phase_ms();
  inline void clear_has_dump_phase_ms();
  inline void set_has_dump_interval_ms();
  inline void clear_has_dump_interval_ms();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 dump_phase_ms_;
  ::google::protobuf::uint32 dump_interval_ms_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static HeapprofdConfig_ContinuousDumpConfig* default_instance_;
};
// -------------------------------------------------------------------

class HeapprofdConfig : public ::google::protobuf::MessageLite {
 public:
  HeapprofdConfig();
  virtual ~HeapprofdConfig();

  HeapprofdConfig(const HeapprofdConfig& from);

  inline HeapprofdConfig& operator=(const HeapprofdConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const HeapprofdConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const HeapprofdConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(HeapprofdConfig* other);

  // implements Message ----------------------------------------------

  inline HeapprofdConfig* New() const { return New(NULL); }

  HeapprofdConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const HeapprofdConfig& from);
  void MergeFrom(const HeapprofdConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HeapprofdConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef HeapprofdConfig_ContinuousDumpConfig ContinuousDumpConfig;

  // accessors -------------------------------------------------------

  // optional uint64 sampling_interval_bytes = 1;
  bool has_sampling_interval_bytes() const;
  void clear_sampling_interval_bytes();
  static const int kSamplingIntervalBytesFieldNumber = 1;
  ::google::protobuf::uint64 sampling_interval_bytes() const;
  void set_sampling_interval_bytes(::google::protobuf::uint64 value);

  // repeated string process_cmdline = 2;
  int process_cmdline_size() const;
  void clear_process_cmdline();
  static const int kProcessCmdlineFieldNumber = 2;
  const ::std::string& process_cmdline(int index) const;
  ::std::string* mutable_process_cmdline(int index);
  void set_process_cmdline(int index, const ::std::string& value);
  void set_process_cmdline(int index, const char* value);
  void set_process_cmdline(int index, const char* value, size_t size);
  ::std::string* add_process_cmdline();
  void add_process_cmdline(const ::std::string& value);
  void add_process_cmdline(const char* value);
  void add_process_cmdline(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& process_cmdline() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_process_cmdline();

  // repeated uint64 pid = 4;
  int pid_size() const;
  void clear_pid();
  static const int kPidFieldNumber = 4;
  ::google::protobuf::uint64 pid(int index) const;
  void set_pid(int index, ::google::protobuf::uint64 value);
  void add_pid(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      pid() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_pid();

  // optional bool all = 5;
  bool has_all() const;
  void clear_all();
  static const int kAllFieldNumber = 5;
  bool all() const;
  void set_all(bool value);

  // repeated string skip_symbol_prefix = 7;
  int skip_symbol_prefix_size() const;
  void clear_skip_symbol_prefix();
  static const int kSkipSymbolPrefixFieldNumber = 7;
  const ::std::string& skip_symbol_prefix(int index) const;
  ::std::string* mutable_skip_symbol_prefix(int index);
  void set_skip_symbol_prefix(int index, const ::std::string& value);
  void set_skip_symbol_prefix(int index, const char* value);
  void set_skip_symbol_prefix(int index, const char* value, size_t size);
  ::std::string* add_skip_symbol_prefix();
  void add_skip_symbol_prefix(const ::std::string& value);
  void add_skip_symbol_prefix(const char* value);
  void add_skip_symbol_prefix(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& skip_symbol_prefix() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_skip_symbol_prefix();

  // optional .perfetto.protos.HeapprofdConfig.ContinuousDumpConfig continuous_dump_config = 6;
  bool has_continuous_dump_config() const;
  void clear_continuous_dump_config();
  static const int kContinuousDumpConfigFieldNumber = 6;
  const ::perfetto::protos::HeapprofdConfig_ContinuousDumpConfig& continuous_dump_config() const;
  ::perfetto::protos::HeapprofdConfig_ContinuousDumpConfig* mutable_continuous_dump_config();
  ::perfetto::protos::HeapprofdConfig_ContinuousDumpConfig* release_continuous_dump_config();
  void set_allocated_continuous_dump_config(::perfetto::protos::HeapprofdConfig_ContinuousDumpConfig* continuous_dump_config);

  // optional uint64 shmem_size_bytes = 8;
  bool has_shmem_size_bytes() const;
  void clear_shmem_size_bytes();
  static const int kShmemSizeBytesFieldNumber = 8;
  ::google::protobuf::uint64 shmem_size_bytes() const;
  void set_shmem_size_bytes(::google::protobuf::uint64 value);

  // optional bool block_client = 9;
  bool has_block_client() const;
  void clear_block_client();
  static const int kBlockClientFieldNumber = 9;
  bool block_client() const;
  void set_block_client(bool value);

  // optional bool no_startup = 10;
  bool has_no_startup() const;
  void clear_no_startup();
  static const int kNoStartupFieldNumber = 10;
  bool no_startup() const;
  void set_no_startup(bool value);

  // optional bool no_running = 11;
  bool has_no_running() const;
  void clear_no_running();
  static const int kNoRunningFieldNumber = 11;
  bool no_running() const;
  void set_no_running(bool value);

  // optional bool idle_allocations = 12;
  bool has_idle_allocations() const;
  void clear_idle_allocations();
  static const int kIdleAllocationsFieldNumber = 12;
  bool idle_allocations() const;
  void set_idle_allocations(bool value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.HeapprofdConfig)
 private:
  inline void set_has_sampling_interval_bytes();
  inline void clear_has_sampling_interval_bytes();
  inline void set_has_all();
  inline void clear_has_all();
  inline void set_has_continuous_dump_config();
  inline void clear_has_continuous_dump_config();
  inline void set_has_shmem_size_bytes();
  inline void clear_has_shmem_size_bytes();
  inline void set_has_block_client();
  inline void clear_has_block_client();
  inline void set_has_no_startup();
  inline void clear_has_no_startup();
  inline void set_has_no_running();
  inline void clear_has_no_running();
  inline void set_has_idle_allocations();
  inline void clear_has_idle_allocations();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 sampling_interval_bytes_;
  ::google::protobuf::RepeatedPtrField< ::std::string> process_cmdline_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > pid_;
  ::google::protobuf::RepeatedPtrField< ::std::string> skip_symbol_prefix_;
  ::perfetto::protos::HeapprofdConfig_ContinuousDumpConfig* continuous_dump_config_;
  ::google::protobuf::uint64 shmem_size_bytes_;
  bool all_;
  bool block_client_;
  bool no_startup_;
  bool no_running_;
  bool idle_allocations_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static HeapprofdConfig* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// HeapprofdConfig_ContinuousDumpConfig

// optional uint32 dump_phase_ms = 5;
inline bool HeapprofdConfig_ContinuousDumpConfig::has_dump_phase_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeapprofdConfig_ContinuousDumpConfig::set_has_dump_phase_ms() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeapprofdConfig_ContinuousDumpConfig::clear_has_dump_phase_ms() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeapprofdConfig_ContinuousDumpConfig::clear_dump_phase_ms() {
  dump_phase_ms_ = 0u;
  clear_has_dump_phase_ms();
}
inline ::google::protobuf::uint32 HeapprofdConfig_ContinuousDumpConfig::dump_phase_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.ContinuousDumpConfig.dump_phase_ms)
  return dump_phase_ms_;
}
inline void HeapprofdConfig_ContinuousDumpConfig::set_dump_phase_ms(::google::protobuf::uint32 value) {
  set_has_dump_phase_ms();
  dump_phase_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.HeapprofdConfig.ContinuousDumpConfig.dump_phase_ms)
}

// optional uint32 dump_interval_ms = 6;
inline bool HeapprofdConfig_ContinuousDumpConfig::has_dump_interval_ms() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HeapprofdConfig_ContinuousDumpConfig::set_has_dump_interval_ms() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HeapprofdConfig_ContinuousDumpConfig::clear_has_dump_interval_ms() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HeapprofdConfig_ContinuousDumpConfig::clear_dump_interval_ms() {
  dump_interval_ms_ = 0u;
  clear_has_dump_interval_ms();
}
inline ::google::protobuf::uint32 HeapprofdConfig_ContinuousDumpConfig::dump_interval_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.ContinuousDumpConfig.dump_interval_ms)
  return dump_interval_ms_;
}
inline void HeapprofdConfig_ContinuousDumpConfig::set_dump_interval_ms(::google::protobuf::uint32 value) {
  set_has_dump_interval_ms();
  dump_interval_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.HeapprofdConfig.ContinuousDumpConfig.dump_interval_ms)
}

// -------------------------------------------------------------------

// HeapprofdConfig

// optional uint64 sampling_interval_bytes = 1;
inline bool HeapprofdConfig::has_sampling_interval_bytes() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeapprofdConfig::set_has_sampling_interval_bytes() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeapprofdConfig::clear_has_sampling_interval_bytes() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeapprofdConfig::clear_sampling_interval_bytes() {
  sampling_interval_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_sampling_interval_bytes();
}
inline ::google::protobuf::uint64 HeapprofdConfig::sampling_interval_bytes() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.sampling_interval_bytes)
  return sampling_interval_bytes_;
}
inline void HeapprofdConfig::set_sampling_interval_bytes(::google::protobuf::uint64 value) {
  set_has_sampling_interval_bytes();
  sampling_interval_bytes_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.HeapprofdConfig.sampling_interval_bytes)
}

// repeated string process_cmdline = 2;
inline int HeapprofdConfig::process_cmdline_size() const {
  return process_cmdline_.size();
}
inline void HeapprofdConfig::clear_process_cmdline() {
  process_cmdline_.Clear();
}
inline const ::std::string& HeapprofdConfig::process_cmdline(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.process_cmdline)
  return process_cmdline_.Get(index);
}
inline ::std::string* HeapprofdConfig::mutable_process_cmdline(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.HeapprofdConfig.process_cmdline)
  return process_cmdline_.Mutable(index);
}
inline void HeapprofdConfig::set_process_cmdline(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.HeapprofdConfig.process_cmdline)
  process_cmdline_.Mutable(index)->assign(value);
}
inline void HeapprofdConfig::set_process_cmdline(int index, const char* value) {
  process_cmdline_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.HeapprofdConfig.process_cmdline)
}
inline void HeapprofdConfig::set_process_cmdline(int index, const char* value, size_t size) {
  process_cmdline_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.HeapprofdConfig.process_cmdline)
}
inline ::std::string* HeapprofdConfig::add_process_cmdline() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.HeapprofdConfig.process_cmdline)
  return process_cmdline_.Add();
}
inline void HeapprofdConfig::add_process_cmdline(const ::std::string& value) {
  process_cmdline_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.HeapprofdConfig.process_cmdline)
}
inline void HeapprofdConfig::add_process_cmdline(const char* value) {
  process_cmdline_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.HeapprofdConfig.process_cmdline)
}
inline void HeapprofdConfig::add_process_cmdline(const char* value, size_t size) {
  process_cmdline_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.HeapprofdConfig.process_cmdline)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
HeapprofdConfig::process_cmdline() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.HeapprofdConfig.process_cmdline)
  return process_cmdline_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
HeapprofdConfig::mutable_process_cmdline() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.HeapprofdConfig.process_cmdline)
  return &process_cmdline_;
}

// repeated uint64 pid = 4;
inline int HeapprofdConfig::pid_size() const {
  return pid_.size();
}
inline void HeapprofdConfig::clear_pid() {
  pid_.Clear();
}
inline ::google::protobuf::uint64 HeapprofdConfig::pid(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.pid)
  return pid_.Get(index);
}
inline void HeapprofdConfig::set_pid(int index, ::google::protobuf::uint64 value) {
  pid_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.HeapprofdConfig.pid)
}
inline void HeapprofdConfig::add_pid(::google::protobuf::uint64 value) {
  pid_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.HeapprofdConfig.pid)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
HeapprofdConfig::pid() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.HeapprofdConfig.pid)
  return pid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
HeapprofdConfig::mutable_pid() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.HeapprofdConfig.pid)
  return &pid_;
}

// optional bool all = 5;
inline bool HeapprofdConfig::has_all() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HeapprofdConfig::set_has_all() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HeapprofdConfig::clear_has_all() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HeapprofdConfig::clear_all() {
  all_ = false;
  clear_has_all();
}
inline bool HeapprofdConfig::all() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.all)
  return all_;
}
inline void HeapprofdConfig::set_all(bool value) {
  set_has_all();
  all_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.HeapprofdConfig.all)
}

// repeated string skip_symbol_prefix = 7;
inline int HeapprofdConfig::skip_symbol_prefix_size() const {
  return skip_symbol_prefix_.size();
}
inline void HeapprofdConfig::clear_skip_symbol_prefix() {
  skip_symbol_prefix_.Clear();
}
inline const ::std::string& HeapprofdConfig::skip_symbol_prefix(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.skip_symbol_prefix)
  return skip_symbol_prefix_.Get(index);
}
inline ::std::string* HeapprofdConfig::mutable_skip_symbol_prefix(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.HeapprofdConfig.skip_symbol_prefix)
  return skip_symbol_prefix_.Mutable(index);
}
inline void HeapprofdConfig::set_skip_symbol_prefix(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.HeapprofdConfig.skip_symbol_prefix)
  skip_symbol_prefix_.Mutable(index)->assign(value);
}
inline void HeapprofdConfig::set_skip_symbol_prefix(int index, const char* value) {
  skip_symbol_prefix_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.HeapprofdConfig.skip_symbol_prefix)
}
inline void HeapprofdConfig::set_skip_symbol_prefix(int index, const char* value, size_t size) {
  skip_symbol_prefix_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.HeapprofdConfig.skip_symbol_prefix)
}
inline ::std::string* HeapprofdConfig::add_skip_symbol_prefix() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.HeapprofdConfig.skip_symbol_prefix)
  return skip_symbol_prefix_.Add();
}
inline void HeapprofdConfig::add_skip_symbol_prefix(const ::std::string& value) {
  skip_symbol_prefix_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.HeapprofdConfig.skip_symbol_prefix)
}
inline void HeapprofdConfig::add_skip_symbol_prefix(const char* value) {
  skip_symbol_prefix_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.HeapprofdConfig.skip_symbol_prefix)
}
inline void HeapprofdConfig::add_skip_symbol_prefix(const char* value, size_t size) {
  skip_symbol_prefix_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.HeapprofdConfig.skip_symbol_prefix)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
HeapprofdConfig::skip_symbol_prefix() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.HeapprofdConfig.skip_symbol_prefix)
  return skip_symbol_prefix_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
HeapprofdConfig::mutable_skip_symbol_prefix() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.HeapprofdConfig.skip_symbol_prefix)
  return &skip_symbol_prefix_;
}

// optional .perfetto.protos.HeapprofdConfig.ContinuousDumpConfig continuous_dump_config = 6;
inline bool HeapprofdConfig::has_continuous_dump_config() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HeapprofdConfig::set_has_continuous_dump_config() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HeapprofdConfig::clear_has_continuous_dump_config() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HeapprofdConfig::clear_continuous_dump_config() {
  if (continuous_dump_config_ != NULL) continuous_dump_config_->::perfetto::protos::HeapprofdConfig_ContinuousDumpConfig::Clear();
  clear_has_continuous_dump_config();
}
inline const ::perfetto::protos::HeapprofdConfig_ContinuousDumpConfig& HeapprofdConfig::continuous_dump_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.continuous_dump_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return continuous_dump_config_ != NULL ? *continuous_dump_config_ : *default_instance().continuous_dump_config_;
#else
  return continuous_dump_config_ != NULL ? *continuous_dump_config_ : *default_instance_->continuous_dump_config_;
#endif
}
inline ::perfetto::protos::HeapprofdConfig_ContinuousDumpConfig* HeapprofdConfig::mutable_continuous_dump_config() {
  set_has_continuous_dump_config();
  if (continuous_dump_config_ == NULL) {
    continuous_dump_config_ = new ::perfetto::protos::HeapprofdConfig_ContinuousDumpConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.HeapprofdConfig.continuous_dump_config)
  return continuous_dump_config_;
}
inline ::perfetto::protos::HeapprofdConfig_ContinuousDumpConfig* HeapprofdConfig::release_continuous_dump_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.HeapprofdConfig.continuous_dump_config)
  clear_has_continuous_dump_config();
  ::perfetto::protos::HeapprofdConfig_ContinuousDumpConfig* temp = continuous_dump_config_;
  continuous_dump_config_ = NULL;
  return temp;
}
inline void HeapprofdConfig::set_allocated_continuous_dump_config(::perfetto::protos::HeapprofdConfig_ContinuousDumpConfig* continuous_dump_config) {
  delete continuous_dump_config_;
  continuous_dump_config_ = continuous_dump_config;
  if (continuous_dump_config) {
    set_has_continuous_dump_config();
  } else {
    clear_has_continuous_dump_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.HeapprofdConfig.continuous_dump_config)
}

// optional uint64 shmem_size_bytes = 8;
inline bool HeapprofdConfig::has_shmem_size_bytes() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void HeapprofdConfig::set_has_shmem_size_bytes() {
  _has_bits_[0] |= 0x00000040u;
}
inline void HeapprofdConfig::clear_has_shmem_size_bytes() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void HeapprofdConfig::clear_shmem_size_bytes() {
  shmem_size_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_shmem_size_bytes();
}
inline ::google::protobuf::uint64 HeapprofdConfig::shmem_size_bytes() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.shmem_size_bytes)
  return shmem_size_bytes_;
}
inline void HeapprofdConfig::set_shmem_size_bytes(::google::protobuf::uint64 value) {
  set_has_shmem_size_bytes();
  shmem_size_bytes_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.HeapprofdConfig.shmem_size_bytes)
}

// optional bool block_client = 9;
inline bool HeapprofdConfig::has_block_client() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void HeapprofdConfig::set_has_block_client() {
  _has_bits_[0] |= 0x00000080u;
}
inline void HeapprofdConfig::clear_has_block_client() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void HeapprofdConfig::clear_block_client() {
  block_client_ = false;
  clear_has_block_client();
}
inline bool HeapprofdConfig::block_client() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.block_client)
  return block_client_;
}
inline void HeapprofdConfig::set_block_client(bool value) {
  set_has_block_client();
  block_client_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.HeapprofdConfig.block_client)
}

// optional bool no_startup = 10;
inline bool HeapprofdConfig::has_no_startup() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void HeapprofdConfig::set_has_no_startup() {
  _has_bits_[0] |= 0x00000100u;
}
inline void HeapprofdConfig::clear_has_no_startup() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void HeapprofdConfig::clear_no_startup() {
  no_startup_ = false;
  clear_has_no_startup();
}
inline bool HeapprofdConfig::no_startup() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.no_startup)
  return no_startup_;
}
inline void HeapprofdConfig::set_no_startup(bool value) {
  set_has_no_startup();
  no_startup_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.HeapprofdConfig.no_startup)
}

// optional bool no_running = 11;
inline bool HeapprofdConfig::has_no_running() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void HeapprofdConfig::set_has_no_running() {
  _has_bits_[0] |= 0x00000200u;
}
inline void HeapprofdConfig::clear_has_no_running() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void HeapprofdConfig::clear_no_running() {
  no_running_ = false;
  clear_has_no_running();
}
inline bool HeapprofdConfig::no_running() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.no_running)
  return no_running_;
}
inline void HeapprofdConfig::set_no_running(bool value) {
  set_has_no_running();
  no_running_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.HeapprofdConfig.no_running)
}

// optional bool idle_allocations = 12;
inline bool HeapprofdConfig::has_idle_allocations() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void HeapprofdConfig::set_has_idle_allocations() {
  _has_bits_[0] |= 0x00000400u;
}
inline void HeapprofdConfig::clear_has_idle_allocations() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void HeapprofdConfig::clear_idle_allocations() {
  idle_allocations_ = false;
  clear_has_idle_allocations();
}
inline bool HeapprofdConfig::idle_allocations() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.idle_allocations)
  return idle_allocations_;
}
inline void HeapprofdConfig::set_idle_allocations(bool value) {
  set_has_idle_allocations();
  idle_allocations_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.HeapprofdConfig.idle_allocations)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_perfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto__INCLUDED
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/config/sys_stats/sys_stats_config.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/config/sys_stats/sys_stats_config.proto

#ifndef PROTOBUF_perfetto_2fconfig_2fsys_5fstats_2fsys_5fstats_5fconfig_2eproto__INCLUDED
#define PROTOBUF_perfetto_2fconfig_2fsys_5fstats_2fsys_5fstats_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
// gen_amalgamated expanded: #include "perfetto/common/sys_stats_counters.pb.h"
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_perfetto_2fconfig_2fsys_5fstats_2fsys_5fstats_5fconfig_2eproto();
void protobuf_AssignDesc_perfetto_2fconfig_2fsys_5fstats_2fsys_5fstats_5fconfig_2eproto();
void protobuf_ShutdownFile_perfetto_2fconfig_2fsys_5fstats_2fsys_5fstats_5fconfig_2eproto();

class SysStatsConfig;

enum SysStatsConfig_StatCounters {
  SysStatsConfig_StatCounters_STAT_UNSPECIFIED = 0,
  SysStatsConfig_StatCounters_STAT_CPU_TIMES = 1,
  SysStatsConfig_StatCounters_STAT_IRQ_COUNTS = 2,
  SysStatsConfig_StatCounters_STAT_SOFTIRQ_COUNTS = 3,
  SysStatsConfig_StatCounters_STAT_FORK_COUNT = 4
};
bool SysStatsConfig_StatCounters_IsValid(int value);
const SysStatsConfig_StatCounters SysStatsConfig_StatCounters_StatCounters_MIN = SysStatsConfig_StatCounters_STAT_UNSPECIFIED;
const SysStatsConfig_StatCounters SysStatsConfig_StatCounters_StatCounters_MAX = SysStatsConfig_StatCounters_STAT_FORK_COUNT;
const int SysStatsConfig_StatCounters_StatCounters_ARRAYSIZE = SysStatsConfig_StatCounters_StatCounters_MAX + 1;

// ===================================================================

class SysStatsConfig : public ::google::protobuf::MessageLite {
 public:
  SysStatsConfig();
  virtual ~SysStatsConfig();

  SysStatsConfig(const SysStatsConfig& from);

  inline SysStatsConfig& operator=(const SysStatsConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const SysStatsConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SysStatsConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SysStatsConfig* other);

  // implements Message ----------------------------------------------

  inline SysStatsConfig* New() const { return New(NULL); }

  SysStatsConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SysStatsConfig& from);
  void MergeFrom(const SysStatsConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SysStatsConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef SysStatsConfig_StatCounters StatCounters;
  static const StatCounters STAT_UNSPECIFIED =
    SysStatsConfig_StatCounters_STAT_UNSPECIFIED;
  static const StatCounters STAT_CPU_TIMES =
    SysStatsConfig_StatCounters_STAT_CPU_TIMES;
  static const StatCounters STAT_IRQ_COUNTS =
    SysStatsConfig_StatCounters_STAT_IRQ_COUNTS;
  static const StatCounters STAT_SOFTIRQ_COUNTS =
    SysStatsConfig_StatCounters_STAT_SOFTIRQ_COUNTS;
  static const StatCounters STAT_FORK_COUNT =
    SysStatsConfig_StatCounters_STAT_FORK_COUNT;
  static inline bool StatCounters_IsValid(int value) {
    return SysStatsConfig_StatCounters_IsValid(value);
  }
  static const StatCounters StatCounters_MIN =
    SysStatsConfig_StatCounters_StatCounters_MIN;
  static const StatCounters StatCounters_MAX =
    SysStatsConfig_StatCounters_StatCounters_MAX;
  static const int StatCounters_ARRAYSIZE =
    SysStatsConfig_StatCounters_StatCounters_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional uint32 meminfo_period_ms = 1;
  bool has_meminfo_period_ms() const;
  void clear_meminfo_period_ms();
  static const int kMeminfoPeriodMsFieldNumber = 1;
  ::google::protobuf::uint32 meminfo_period_ms() const;
  void set_meminfo_period_ms(::google::protobuf::uint32 value);

  // repeated .perfetto.protos.MeminfoCounters meminfo_counters = 2;
  int meminfo_counters_size() const;
  void clear_meminfo_counters();
  static const int kMeminfoCountersFieldNumber = 2;
  ::perfetto::protos::MeminfoCounters meminfo_counters(int index) const;
  void set_meminfo_counters(int index, ::perfetto::protos::MeminfoCounters value);
  void add_meminfo_counters(::perfetto::protos::MeminfoCounters value);
  const ::google::protobuf::RepeatedField<int>& meminfo_counters() const;
  ::google::protobuf::RepeatedField<int>* mutable_meminfo_counters();

  // optional uint32 vmstat_period_ms = 3;
  bool has_vmstat_period_ms() const;
  void clear_vmstat_period_ms();
  static const int kVmstatPeriodMsFieldNumber = 3;
  ::google::protobuf::uint32 vmstat_period_ms() const;
  void set_vmstat_period_ms(::google::protobuf::uint32 value);

  // repeated .perfetto.protos.VmstatCounters vmstat_counters = 4;
  int vmstat_counters_size() const;
  void clear_vmstat_counters();
  static const int kVmstatCountersFieldNumber = 4;
  ::perfetto::protos::VmstatCounters vmstat_counters(int index) const;
  void set_vmstat_counters(int index, ::perfetto::protos::VmstatCounters value);
  void add_vmstat_counters(::perfetto::protos::VmstatCounters value);
  const ::google::protobuf::RepeatedField<int>& vmstat_counters() const;
  ::google::protobuf::RepeatedField<int>* mutable_vmstat_counters();

  // optional uint32 stat_period_ms = 5;
  bool has_stat_period_ms() const;
  void clear_stat_period_ms();
  static const int kStatPeriodMsFieldNumber = 5;
  ::google::protobuf::uint32 stat_period_ms() const;
  void set_stat_period_ms(::google::protobuf::uint32 value);

  // repeated .perfetto.protos.SysStatsConfig.StatCounters stat_counters = 6;
  int stat_counters_size() const;
  void clear_stat_counters();
  static const int kStatCountersFieldNumber = 6;
  ::perfetto::protos::SysStatsConfig_StatCounters stat_counters(int index) const;
  void set_stat_counters(int index, ::perfetto::protos::SysStatsConfig_StatCounters value);
  void add_stat_counters(::perfetto::protos::SysStatsConfig_StatCounters value);
  const ::google::protobuf::RepeatedField<int>& stat_counters() const;
  ::google::protobuf::RepeatedField<int>* mutable_stat_counters();

  // @@protoc_insertion_point(class_scope:perfetto.protos.SysStatsConfig)
 private:
  inline void set_has_meminfo_period_ms();
  inline void clear_has_meminfo_period_ms();
  inline void set_has_vmstat_period_ms();
  inline void clear_has_vmstat_period_ms();
  inline void set_has_stat_period_ms();
  inline void clear_has_stat_period_ms();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField<int> meminfo_counters_;
  ::google::protobuf::uint32 meminfo_period_ms_;
  ::google::protobuf::uint32 vmstat_period_ms_;
  ::google::protobuf::RepeatedField<int> vmstat_counters_;
  ::google::protobuf::RepeatedField<int> stat_counters_;
  ::google::protobuf::uint32 stat_period_ms_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fconfig_2fsys_5fstats_2fsys_5fstats_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fconfig_2fsys_5fstats_2fsys_5fstats_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fconfig_2fsys_5fstats_2fsys_5fstats_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fconfig_2fsys_5fstats_2fsys_5fstats_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static SysStatsConfig* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// SysStatsConfig

// optional uint32 meminfo_period_ms = 1;
inline bool SysStatsConfig::has_meminfo_period_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SysStatsConfig::set_has_meminfo_period_ms() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SysStatsConfig::clear_has_meminfo_period_ms() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SysStatsConfig::clear_meminfo_period_ms() {
  meminfo_period_ms_ = 0u;
  clear_has_meminfo_period_ms();
}
inline ::google::protobuf::uint32 SysStatsConfig::meminfo_period_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SysStatsConfig.meminfo_period_ms)
  return meminfo_period_ms_;
}
inline void SysStatsConfig::set_meminfo_period_ms(::google::protobuf::uint32 value) {
  set_has_meminfo_period_ms();
  meminfo_period_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.SysStatsConfig.meminfo_period_ms)
}

// repeated .perfetto.protos.MeminfoCounters meminfo_counters = 2;
inline int SysStatsConfig::meminfo_counters_size() const {
  return meminfo_counters_.size();
}
inline void SysStatsConfig::clear_meminfo_counters() {
  meminfo_counters_.Clear();
}
inline ::perfetto::protos::MeminfoCounters SysStatsConfig::meminfo_counters(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SysStatsConfig.meminfo_counters)
  return static_cast< ::perfetto::protos::MeminfoCounters >(meminfo_counters_.Get(index));
}
inline void SysStatsConfig::set_meminfo_counters(int index, ::perfetto::protos::MeminfoCounters value) {
  assert(::perfetto::protos::MeminfoCounters_IsValid(value));
  meminfo_counters_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SysStatsConfig.meminfo_counters)
}
inline void SysStatsConfig::add_meminfo_counters(::perfetto::protos::MeminfoCounters value) {
  assert(::perfetto::protos::MeminfoCounters_IsValid(value));
  meminfo_counters_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.SysStatsConfig.meminfo_counters)
}
inline const ::google::protobuf::RepeatedField<int>&
SysStatsConfig::meminfo_counters() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.SysStatsConfig.meminfo_counters)
  return meminfo_counters_;
}
inline ::google::protobuf::RepeatedField<int>*
SysStatsConfig::mutable_meminfo_counters() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.SysStatsConfig.meminfo_counters)
  return &meminfo_counters_;
}

// optional uint32 vmstat_period_ms = 3;
inline bool SysStatsConfig::has_vmstat_period_ms() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SysStatsConfig::set_has_vmstat_period_ms() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SysStatsConfig::clear_has_vmstat_period_ms() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SysStatsConfig::clear_vmstat_period_ms() {
  vmstat_period_ms_ = 0u;
  clear_has_vmstat_period_ms();
}
inline ::google::protobuf::uint32 SysStatsConfig::vmstat_period_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SysStatsConfig.vmstat_period_ms)
  return vmstat_period_ms_;
}
inline void SysStatsConfig::set_vmstat_period_ms(::google::protobuf::uint32 value) {
  set_has_vmstat_period_ms();
  vmstat_period_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.SysStatsConfig.vmstat_period_ms)
}

// repeated .perfetto.protos.VmstatCounters vmstat_counters = 4;
inline int SysStatsConfig::vmstat_counters_size() const {
  return vmstat_counters_.size();
}
inline void SysStatsConfig::clear_vmstat_counters() {
  vmstat_counters_.Clear();
}
inline ::perfetto::protos::VmstatCounters SysStatsConfig::vmstat_counters(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SysStatsConfig.vmstat_counters)
  return static_cast< ::perfetto::protos::VmstatCounters >(vmstat_counters_.Get(index));
}
inline void SysStatsConfig::set_vmstat_counters(int index, ::perfetto::protos::VmstatCounters value) {
  assert(::perfetto::protos::VmstatCounters_IsValid(value));
  vmstat_counters_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SysStatsConfig.vmstat_counters)
}
inline void SysStatsConfig::add_vmstat_counters(::perfetto::protos::VmstatCounters value) {
  assert(::perfetto::protos::VmstatCounters_IsValid(value));
  vmstat_counters_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.SysStatsConfig.vmstat_counters)
}
inline const ::google::protobuf::RepeatedField<int>&
SysStatsConfig::vmstat_counters() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.SysStatsConfig.vmstat_counters)
  return vmstat_counters_;
}
inline ::google::protobuf::RepeatedField<int>*
SysStatsConfig::mutable_vmstat_counters() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.SysStatsConfig.vmstat_counters)
  return &vmstat_counters_;
}

// optional uint32 stat_period_ms = 5;
inline bool SysStatsConfig::has_stat_period_ms() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SysStatsConfig::set_has_stat_period_ms() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SysStatsConfig::clear_has_stat_period_ms() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SysStatsConfig::clear_stat_period_ms() {
  stat_period_ms_ = 0u;
  clear_has_stat_period_ms();
}
inline ::google::protobuf::uint32 SysStatsConfig::stat_period_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SysStatsConfig.stat_period_ms)
  return stat_period_ms_;
}
inline void SysStatsConfig::set_stat_period_ms(::google::protobuf::uint32 value) {
  set_has_stat_period_ms();
  stat_period_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.SysStatsConfig.stat_period_ms)
}

// repeated .perfetto.protos.SysStatsConfig.StatCounters stat_counters = 6;
inline int SysStatsConfig::stat_counters_size() const {
  return stat_counters_.size();
}
inline void SysStatsConfig::clear_stat_counters() {
  stat_counters_.Clear();
}
inline ::perfetto::protos::SysStatsConfig_StatCounters SysStatsConfig::stat_counters(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SysStatsConfig.stat_counters)
  return static_cast< ::perfetto::protos::SysStatsConfig_StatCounters >(stat_counters_.Get(index));
}
inline void SysStatsConfig::set_stat_counters(int index, ::perfetto::protos::SysStatsConfig_StatCounters value) {
  assert(::perfetto::protos::SysStatsConfig_StatCounters_IsValid(value));
  stat_counters_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SysStatsConfig.stat_counters)
}
inline void SysStatsConfig::add_stat_counters(::perfetto::protos::SysStatsConfig_StatCounters value) {
  assert(::perfetto::protos::SysStatsConfig_StatCounters_IsValid(value));
  stat_counters_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.SysStatsConfig.stat_counters)
}
inline const ::google::protobuf::RepeatedField<int>&
SysStatsConfig::stat_counters() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.SysStatsConfig.stat_counters)
  return stat_counters_;
}
inline ::google::protobuf::RepeatedField<int>*
SysStatsConfig::mutable_stat_counters() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.SysStatsConfig.stat_counters)
  return &stat_counters_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::perfetto::protos::SysStatsConfig_StatCounters> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_perfetto_2fconfig_2fsys_5fstats_2fsys_5fstats_5fconfig_2eproto__INCLUDED
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/config/test_config.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/config/test_config.proto

#ifndef PROTOBUF_perfetto_2fconfig_2ftest_5fconfig_2eproto__INCLUDED
#define PROTOBUF_perfetto_2fconfig_2ftest_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_perfetto_2fconfig_2ftest_5fconfig_2eproto();
void protobuf_AssignDesc_perfetto_2fconfig_2ftest_5fconfig_2eproto();
void protobuf_ShutdownFile_perfetto_2fconfig_2ftest_5fconfig_2eproto();

class TestConfig;
class TestConfig_DummyFields;

// ===================================================================

class TestConfig_DummyFields : public ::google::protobuf::MessageLite {
 public:
  TestConfig_DummyFields();
  virtual ~TestConfig_DummyFields();

  TestConfig_DummyFields(const TestConfig_DummyFields& from);

  inline TestConfig_DummyFields& operator=(const TestConfig_DummyFields& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TestConfig_DummyFields& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TestConfig_DummyFields* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TestConfig_DummyFields* other);

  // implements Message ----------------------------------------------

  inline TestConfig_DummyFields* New() const { return New(NULL); }

  TestConfig_DummyFields* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TestConfig_DummyFields& from);
  void MergeFrom(const TestConfig_DummyFields& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TestConfig_DummyFields* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 field_uint32 = 1;
  bool has_field_uint32() const;
  void clear_field_uint32();
  static const int kFieldUint32FieldNumber = 1;
  ::google::protobuf::uint32 field_uint32() const;
  void set_field_uint32(::google::protobuf::uint32 value);

  // optional int32 field_int32 = 2;
  bool has_field_int32() const;
  void clear_field_int32();
  static const int kFieldInt32FieldNumber = 2;
  ::google::protobuf::int32 field_int32() const;
  void set_field_int32(::google::protobuf::int32 value);

  // optional uint64 field_uint64 = 3;
  bool has_field_uint64() const;
  void clear_field_uint64();
  static const int kFieldUint64FieldNumber = 3;
  ::google::protobuf::uint64 field_uint64() const;
  void set_field_uint64(::google::protobuf::uint64 value);

  // optional int64 field_int64 = 4;
  bool has_field_int64() const;
  void clear_field_int64();
  static const int kFieldInt64FieldNumber = 4;
  ::google::protobuf::int64 field_int64() const;
  void set_field_int64(::google::protobuf::int64 value);

  // optional fixed64 field_fixed64 = 5;
  bool has_field_fixed64() const;
  void clear_field_fixed64();
  static const int kFieldFixed64FieldNumber = 5;
  ::google::protobuf::uint64 field_fixed64() const;
  void set_field_fixed64(::google::protobuf::uint64 value);

  // optional sfixed64 field_sfixed64 = 6;
  bool has_field_sfixed64() const;
  void clear_field_sfixed64();
  static const int kFieldSfixed64FieldNumber = 6;
  ::google::protobuf::int64 field_sfixed64() const;
  void set_field_sfixed64(::google::protobuf::int64 value);

  // optional fixed32 field_fixed32 = 7;
  bool has_field_fixed32() const;
  void clear_field_fixed32();
  static const int kFieldFixed32FieldNumber = 7;
  ::google::protobuf::uint32 field_fixed32() const;
  void set_field_fixed32(::google::protobuf::uint32 value);

  // optional sfixed32 field_sfixed32 = 8;
  bool has_field_sfixed32() const;
  void clear_field_sfixed32();
  static const int kFieldSfixed32FieldNumber = 8;
  ::google::protobuf::int32 field_sfixed32() const;
  void set_field_sfixed32(::google::protobuf::int32 value);

  // optional double field_double = 9;
  bool has_field_double() const;
  void clear_field_double();
  static const int kFieldDoubleFieldNumber = 9;
  double field_double() const;
  void set_field_double(double value);

  // optional float field_float = 10;
  bool has_field_float() const;
  void clear_field_float();
  static const int kFieldFloatFieldNumber = 10;
  float field_float() const;
  void set_field_float(float value);

  // optional sint64 field_sint64 = 11;
  bool has_field_sint64() const;
  void clear_field_sint64();
  static const int kFieldSint64FieldNumber = 11;
  ::google::protobuf::int64 field_sint64() const;
  void set_field_sint64(::google::protobuf::int64 value);

  // optional sint32 field_sint32 = 12;
  bool has_field_sint32() const;
  void clear_field_sint32();
  static const int kFieldSint32FieldNumber = 12;
  ::google::protobuf::int32 field_sint32() const;
  void set_field_sint32(::google::protobuf::int32 value);

  // optional string field_string = 13;
  bool has_field_string() const;
  void clear_field_string();
  static const int kFieldStringFieldNumber = 13;
  const ::std::string& field_string() const;
  void set_field_string(const ::std::string& value);
  void set_field_string(const char* value);
  void set_field_string(const char* value, size_t size);
  ::std::string* mutable_field_string();
  ::std::string* release_field_string();
  void set_allocated_field_string(::std::string* field_string);

  // optional bytes field_bytes = 14;
  bool has_field_bytes() const;
  void clear_field_bytes();
  static const int kFieldBytesFieldNumber = 14;
  const ::std::string& field_bytes() const;
  void set_field_bytes(const ::std::string& value);
  void set_field_bytes(const char* value);
  void set_field_bytes(const void* value, size_t size);
  ::std::string* mutable_field_bytes();
  ::std::string* release_field_bytes();
  void set_allocated_field_bytes(::std::string* field_bytes);

  // @@protoc_insertion_point(class_scope:perfetto.protos.TestConfig.DummyFields)
 private:
  inline void set_has_field_uint32();
  inline void clear_has_field_uint32();
  inline void set_has_field_int32();
  inline void clear_has_field_int32();
  inline void set_has_field_uint64();
  inline void clear_has_field_uint64();
  inline void set_has_field_int64();
  inline void clear_has_field_int64();
  inline void set_has_field_fixed64();
  inline void clear_has_field_fixed64();
  inline void set_has_field_sfixed64();
  inline void clear_has_field_sfixed64();
  inline void set_has_field_fixed32();
  inline void clear_has_field_fixed32();
  inline void set_has_field_sfixed32();
  inline void clear_has_field_sfixed32();
  inline void set_has_field_double();
  inline void clear_has_field_double();
  inline void set_has_field_float();
  inline void clear_has_field_float();
  inline void set_has_field_sint64();
  inline void clear_has_field_sint64();
  inline void set_has_field_sint32();
  inline void clear_has_field_sint32();
  inline void set_has_field_string();
  inline void clear_has_field_string();
  inline void set_has_field_bytes();
  inline void clear_has_field_bytes();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 field_uint32_;
  ::google::protobuf::int32 field_int32_;
  ::google::protobuf::uint64 field_uint64_;
  ::google::protobuf::int64 field_int64_;
  ::google::protobuf::uint64 field_fixed64_;
  ::google::protobuf::int64 field_sfixed64_;
  ::google::protobuf::uint32 field_fixed32_;
  ::google::protobuf::int32 field_sfixed32_;
  double field_double_;
  ::google::protobuf::int64 field_sint64_;
  float field_float_;
  ::google::protobuf::int32 field_sint32_;
  ::google::protobuf::internal::ArenaStringPtr field_string_;
  ::google::protobuf::internal::ArenaStringPtr field_bytes_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fconfig_2ftest_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fconfig_2ftest_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fconfig_2ftest_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fconfig_2ftest_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static TestConfig_DummyFields* default_instance_;
};
// -------------------------------------------------------------------

class TestConfig : public ::google::protobuf::MessageLite {
 public:
  TestConfig();
  virtual ~TestConfig();

  TestConfig(const TestConfig& from);

  inline TestConfig& operator=(const TestConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TestConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TestConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TestConfig* other);

  // implements Message ----------------------------------------------

  inline TestConfig* New() const { return New(NULL); }

  TestConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TestConfig& from);
  void MergeFrom(const TestConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TestConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef TestConfig_DummyFields DummyFields;

  // accessors -------------------------------------------------------

  // optional uint32 message_count = 1;
  bool has_message_count() const;
  void clear_message_count();
  static const int kMessageCountFieldNumber = 1;
  ::google::protobuf::uint32 message_count() const;
  void set_message_count(::google::protobuf::uint32 value);

  // optional uint32 max_messages_per_second = 2;
  bool has_max_messages_per_second() const;
  void clear_max_messages_per_second();
  static const int kMaxMessagesPerSecondFieldNumber = 2;
  ::google::protobuf::uint32 max_messages_per_second() const;
  void set_max_messages_per_second(::google::protobuf::uint32 value);

  // optional uint32 seed = 3;
  bool has_seed() const;
  void clear_seed();
  static const int kSeedFieldNumber = 3;
  ::google::protobuf::uint32 seed() const;
  void set_seed(::google::protobuf::uint32 value);

  // optional uint32 message_size = 4;
  bool has_message_size() const;
  void clear_message_size();
  static const int kMessageSizeFieldNumber = 4;
  ::google::protobuf::uint32 message_size() const;
  void set_message_size(::google::protobuf::uint32 value);

  // optional bool send_batch_on_register = 5;
  bool has_send_batch_on_register() const;
  void clear_send_batch_on_register();
  static const int kSendBatchOnRegisterFieldNumber = 5;
  bool send_batch_on_register() const;
  void set_send_batch_on_register(bool value);

  // optional .perfetto.protos.TestConfig.DummyFields dummy_fields = 6;
  bool has_dummy_fields() const;
  void clear_dummy_fields();
  static const int kDummyFieldsFieldNumber = 6;
  const ::perfetto::protos::TestConfig_DummyFields& dummy_fields() const;
  ::perfetto::protos::TestConfig_DummyFields* mutable_dummy_fields();
  ::perfetto::protos::TestConfig_DummyFields* release_dummy_fields();
  void set_allocated_dummy_fields(::perfetto::protos::TestConfig_DummyFields* dummy_fields);

  // @@protoc_insertion_point(class_scope:perfetto.protos.TestConfig)
 private:
  inline void set_has_message_count();
  inline void clear_has_message_count();
  inline void set_has_max_messages_per_second();
  inline void clear_has_max_messages_per_second();
  inline void set_has_seed();
  inline void clear_has_seed();
  inline void set_has_message_size();
  inline void clear_has_message_size();
  inline void set_has_send_batch_on_register();
  inline void clear_has_send_batch_on_register();
  inline void set_has_dummy_fields();
  inline void clear_has_dummy_fields();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 message_count_;
  ::google::protobuf::uint32 max_messages_per_second_;
  ::google::protobuf::uint32 seed_;
  ::google::protobuf::uint32 message_size_;
  ::perfetto::protos::TestConfig_DummyFields* dummy_fields_;
  bool send_batch_on_register_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fconfig_2ftest_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fconfig_2ftest_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fconfig_2ftest_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fconfig_2ftest_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static TestConfig* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// TestConfig_DummyFields

// optional uint32 field_uint32 = 1;
inline bool TestConfig_DummyFields::has_field_uint32() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TestConfig_DummyFields::set_has_field_uint32() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TestConfig_DummyFields::clear_has_field_uint32() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TestConfig_DummyFields::clear_field_uint32() {
  field_uint32_ = 0u;
  clear_has_field_uint32();
}
inline ::google::protobuf::uint32 TestConfig_DummyFields::field_uint32() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_uint32)
  return field_uint32_;
}
inline void TestConfig_DummyFields::set_field_uint32(::google::protobuf::uint32 value) {
  set_has_field_uint32();
  field_uint32_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_uint32)
}

// optional int32 field_int32 = 2;
inline bool TestConfig_DummyFields::has_field_int32() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TestConfig_DummyFields::set_has_field_int32() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TestConfig_DummyFields::clear_has_field_int32() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TestConfig_DummyFields::clear_field_int32() {
  field_int32_ = 0;
  clear_has_field_int32();
}
inline ::google::protobuf::int32 TestConfig_DummyFields::field_int32() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_int32)
  return field_int32_;
}
inline void TestConfig_DummyFields::set_field_int32(::google::protobuf::int32 value) {
  set_has_field_int32();
  field_int32_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_int32)
}

// optional uint64 field_uint64 = 3;
inline bool TestConfig_DummyFields::has_field_uint64() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TestConfig_DummyFields::set_has_field_uint64() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TestConfig_DummyFields::clear_has_field_uint64() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TestConfig_DummyFields::clear_field_uint64() {
  field_uint64_ = GOOGLE_ULONGLONG(0);
  clear_has_field_uint64();
}
inline ::google::protobuf::uint64 TestConfig_DummyFields::field_uint64() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_uint64)
  return field_uint64_;
}
inline void TestConfig_DummyFields::set_field_uint64(::google::protobuf::uint64 value) {
  set_has_field_uint64();
  field_uint64_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_uint64)
}

// optional int64 field_int64 = 4;
inline bool TestConfig_DummyFields::has_field_int64() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TestConfig_DummyFields::set_has_field_int64() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TestConfig_DummyFields::clear_has_field_int64() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TestConfig_DummyFields::clear_field_int64() {
  field_int64_ = GOOGLE_LONGLONG(0);
  clear_has_field_int64();
}
inline ::google::protobuf::int64 TestConfig_DummyFields::field_int64() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_int64)
  return field_int64_;
}
inline void TestConfig_DummyFields::set_field_int64(::google::protobuf::int64 value) {
  set_has_field_int64();
  field_int64_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_int64)
}

// optional fixed64 field_fixed64 = 5;
inline bool TestConfig_DummyFields::has_field_fixed64() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TestConfig_DummyFields::set_has_field_fixed64() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TestConfig_DummyFields::clear_has_field_fixed64() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TestConfig_DummyFields::clear_field_fixed64() {
  field_fixed64_ = GOOGLE_ULONGLONG(0);
  clear_has_field_fixed64();
}
inline ::google::protobuf::uint64 TestConfig_DummyFields::field_fixed64() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_fixed64)
  return field_fixed64_;
}
inline void TestConfig_DummyFields::set_field_fixed64(::google::protobuf::uint64 value) {
  set_has_field_fixed64();
  field_fixed64_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_fixed64)
}

// optional sfixed64 field_sfixed64 = 6;
inline bool TestConfig_DummyFields::has_field_sfixed64() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TestConfig_DummyFields::set_has_field_sfixed64() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TestConfig_DummyFields::clear_has_field_sfixed64() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TestConfig_DummyFields::clear_field_sfixed64() {
  field_sfixed64_ = GOOGLE_LONGLONG(0);
  clear_has_field_sfixed64();
}
inline ::google::protobuf::int64 TestConfig_DummyFields::field_sfixed64() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_sfixed64)
  return field_sfixed64_;
}
inline void TestConfig_DummyFields::set_field_sfixed64(::google::protobuf::int64 value) {
  set_has_field_sfixed64();
  field_sfixed64_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_sfixed64)
}

// optional fixed32 field_fixed32 = 7;
inline bool TestConfig_DummyFields::has_field_fixed32() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TestConfig_DummyFields::set_has_field_fixed32() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TestConfig_DummyFields::clear_has_field_fixed32() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TestConfig_DummyFields::clear_field_fixed32() {
  field_fixed32_ = 0u;
  clear_has_field_fixed32();
}
inline ::google::protobuf::uint32 TestConfig_DummyFields::field_fixed32() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_fixed32)
  return field_fixed32_;
}
inline void TestConfig_DummyFields::set_field_fixed32(::google::protobuf::uint32 value) {
  set_has_field_fixed32();
  field_fixed32_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_fixed32)
}

// optional sfixed32 field_sfixed32 = 8;
inline bool TestConfig_DummyFields::has_field_sfixed32() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TestConfig_DummyFields::set_has_field_sfixed32() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TestConfig_DummyFields::clear_has_field_sfixed32() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TestConfig_DummyFields::clear_field_sfixed32() {
  field_sfixed32_ = 0;
  clear_has_field_sfixed32();
}
inline ::google::protobuf::int32 TestConfig_DummyFields::field_sfixed32() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_sfixed32)
  return field_sfixed32_;
}
inline void TestConfig_DummyFields::set_field_sfixed32(::google::protobuf::int32 value) {
  set_has_field_sfixed32();
  field_sfixed32_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_sfixed32)
}

// optional double field_double = 9;
inline bool TestConfig_DummyFields::has_field_double() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TestConfig_DummyFields::set_has_field_double() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TestConfig_DummyFields::clear_has_field_double() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TestConfig_DummyFields::clear_field_double() {
  field_double_ = 0;
  clear_has_field_double();
}
inline double TestConfig_DummyFields::field_double() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_double)
  return field_double_;
}
inline void TestConfig_DummyFields::set_field_double(double value) {
  set_has_field_double();
  field_double_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_double)
}

// optional float field_float = 10;
inline bool TestConfig_DummyFields::has_field_float() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TestConfig_DummyFields::set_has_field_float() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TestConfig_DummyFields::clear_has_field_float() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TestConfig_DummyFields::clear_field_float() {
  field_float_ = 0;
  clear_has_field_float();
}
inline float TestConfig_DummyFields::field_float() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_float)
  return field_float_;
}
inline void TestConfig_DummyFields::set_field_float(float value) {
  set_has_field_float();
  field_float_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_float)
}

// optional sint64 field_sint64 = 11;
inline bool TestConfig_DummyFields::has_field_sint64() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TestConfig_DummyFields::set_has_field_sint64() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TestConfig_DummyFields::clear_has_field_sint64() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TestConfig_DummyFields::clear_field_sint64() {
  field_sint64_ = GOOGLE_LONGLONG(0);
  clear_has_field_sint64();
}
inline ::google::protobuf::int64 TestConfig_DummyFields::field_sint64() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_sint64)
  return field_sint64_;
}
inline void TestConfig_DummyFields::set_field_sint64(::google::protobuf::int64 value) {
  set_has_field_sint64();
  field_sint64_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_sint64)
}

// optional sint32 field_sint32 = 12;
inline bool TestConfig_DummyFields::has_field_sint32() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TestConfig_DummyFields::set_has_field_sint32() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TestConfig_DummyFields::clear_has_field_sint32() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TestConfig_DummyFields::clear_field_sint32() {
  field_sint32_ = 0;
  clear_has_field_sint32();
}
inline ::google::protobuf::int32 TestConfig_DummyFields::field_sint32() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_sint32)
  return field_sint32_;
}
inline void TestConfig_DummyFields::set_field_sint32(::google::protobuf::int32 value) {
  set_has_field_sint32();
  field_sint32_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_sint32)
}

// optional string field_string = 13;
inline bool TestConfig_DummyFields::has_field_string() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TestConfig_DummyFields::set_has_field_string() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TestConfig_DummyFields::clear_has_field_string() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TestConfig_DummyFields::clear_field_string() {
  field_string_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_field_string();
}
inline const ::std::string& TestConfig_DummyFields::field_string() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_string)
  return field_string_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TestConfig_DummyFields::set_field_string(const ::std::string& value) {
  set_has_field_string();
  field_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_string)
}
inline void TestConfig_DummyFields::set_field_string(const char* value) {
  set_has_field_string();
  field_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.TestConfig.DummyFields.field_string)
}
inline void TestConfig_DummyFields::set_field_string(const char* value, size_t size) {
  set_has_field_string();
  field_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.TestConfig.DummyFields.field_string)
}
inline ::std::string* TestConfig_DummyFields::mutable_field_string() {
  set_has_field_string();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TestConfig.DummyFields.field_string)
  return field_string_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TestConfig_DummyFields::release_field_string() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TestConfig.DummyFields.field_string)
  clear_has_field_string();
  return field_string_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TestConfig_DummyFields::set_allocated_field_string(::std::string* field_string) {
  if (field_string != NULL) {
    set_has_field_string();
  } else {
    clear_has_field_string();
  }
  field_string_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), field_string);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TestConfig.DummyFields.field_string)
}

// optional bytes field_bytes = 14;
inline bool TestConfig_DummyFields::has_field_bytes() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TestConfig_DummyFields::set_has_field_bytes() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TestConfig_DummyFields::clear_has_field_bytes() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TestConfig_DummyFields::clear_field_bytes() {
  field_bytes_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_field_bytes();
}
inline const ::std::string& TestConfig_DummyFields::field_bytes() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_bytes)
  return field_bytes_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TestConfig_DummyFields::set_field_bytes(const ::std::string& value) {
  set_has_field_bytes();
  field_bytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_bytes)
}
inline void TestConfig_DummyFields::set_field_bytes(const char* value) {
  set_has_field_bytes();
  field_bytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.TestConfig.DummyFields.field_bytes)
}
inline void TestConfig_DummyFields::set_field_bytes(const void* value, size_t size) {
  set_has_field_bytes();
  field_bytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.TestConfig.DummyFields.field_bytes)
}
inline ::std::string* TestConfig_DummyFields::mutable_field_bytes() {
  set_has_field_bytes();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TestConfig.DummyFields.field_bytes)
  return field_bytes_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TestConfig_DummyFields::release_field_bytes() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TestConfig.DummyFields.field_bytes)
  clear_has_field_bytes();
  return field_bytes_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TestConfig_DummyFields::set_allocated_field_bytes(::std::string* field_bytes) {
  if (field_bytes != NULL) {
    set_has_field_bytes();
  } else {
    clear_has_field_bytes();
  }
  field_bytes_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), field_bytes);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TestConfig.DummyFields.field_bytes)
}

// -------------------------------------------------------------------

// TestConfig

// optional uint32 message_count = 1;
inline bool TestConfig::has_message_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TestConfig::set_has_message_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TestConfig::clear_has_message_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TestConfig::clear_message_count() {
  message_count_ = 0u;
  clear_has_message_count();
}
inline ::google::protobuf::uint32 TestConfig::message_count() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.message_count)
  return message_count_;
}
inline void TestConfig::set_message_count(::google::protobuf::uint32 value) {
  set_has_message_count();
  message_count_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.message_count)
}

// optional uint32 max_messages_per_second = 2;
inline bool TestConfig::has_max_messages_per_second() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TestConfig::set_has_max_messages_per_second() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TestConfig::clear_has_max_messages_per_second() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TestConfig::clear_max_messages_per_second() {
  max_messages_per_second_ = 0u;
  clear_has_max_messages_per_second();
}
inline ::google::protobuf::uint32 TestConfig::max_messages_per_second() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.max_messages_per_second)
  return max_messages_per_second_;
}
inline void TestConfig::set_max_messages_per_second(::google::protobuf::uint32 value) {
  set_has_max_messages_per_second();
  max_messages_per_second_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.max_messages_per_second)
}

// optional uint32 seed = 3;
inline bool TestConfig::has_seed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TestConfig::set_has_seed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TestConfig::clear_has_seed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TestConfig::clear_seed() {
  seed_ = 0u;
  clear_has_seed();
}
inline ::google::protobuf::uint32 TestConfig::seed() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.seed)
  return seed_;
}
inline void TestConfig::set_seed(::google::protobuf::uint32 value) {
  set_has_seed();
  seed_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.seed)
}

// optional uint32 message_size = 4;
inline bool TestConfig::has_message_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TestConfig::set_has_message_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TestConfig::clear_has_message_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TestConfig::clear_message_size() {
  message_size_ = 0u;
  clear_has_message_size();
}
inline ::google::protobuf::uint32 TestConfig::message_size() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.message_size)
  return message_size_;
}
inline void TestConfig::set_message_size(::google::protobuf::uint32 value) {
  set_has_message_size();
  message_size_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.message_size)
}

// optional bool send_batch_on_register = 5;
inline bool TestConfig::has_send_batch_on_register() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TestConfig::set_has_send_batch_on_register() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TestConfig::clear_has_send_batch_on_register() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TestConfig::clear_send_batch_on_register() {
  send_batch_on_register_ = false;
  clear_has_send_batch_on_register();
}
inline bool TestConfig::send_batch_on_register() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.send_batch_on_register)
  return send_batch_on_register_;
}
inline void TestConfig::set_send_batch_on_register(bool value) {
  set_has_send_batch_on_register();
  send_batch_on_register_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.send_batch_on_register)
}

// optional .perfetto.protos.TestConfig.DummyFields dummy_fields = 6;
inline bool TestConfig::has_dummy_fields() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TestConfig::set_has_dummy_fields() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TestConfig::clear_has_dummy_fields() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TestConfig::clear_dummy_fields() {
  if (dummy_fields_ != NULL) dummy_fields_->::perfetto::protos::TestConfig_DummyFields::Clear();
  clear_has_dummy_fields();
}
inline const ::perfetto::protos::TestConfig_DummyFields& TestConfig::dummy_fields() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.dummy_fields)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return dummy_fields_ != NULL ? *dummy_fields_ : *default_instance().dummy_fields_;
#else
  return dummy_fields_ != NULL ? *dummy_fields_ : *default_instance_->dummy_fields_;
#endif
}
inline ::perfetto::protos::TestConfig_DummyFields* TestConfig::mutable_dummy_fields() {
  set_has_dummy_fields();
  if (dummy_fields_ == NULL) {
    dummy_fields_ = new ::perfetto::protos::TestConfig_DummyFields;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TestConfig.dummy_fields)
  return dummy_fields_;
}
inline ::perfetto::protos::TestConfig_DummyFields* TestConfig::release_dummy_fields() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TestConfig.dummy_fields)
  clear_has_dummy_fields();
  ::perfetto::protos::TestConfig_DummyFields* temp = dummy_fields_;
  dummy_fields_ = NULL;
  return temp;
}
inline void TestConfig::set_allocated_dummy_fields(::perfetto::protos::TestConfig_DummyFields* dummy_fields) {
  delete dummy_fields_;
  dummy_fields_ = dummy_fields;
  if (dummy_fields) {
    set_has_dummy_fields();
  } else {
    clear_has_dummy_fields();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TestConfig.dummy_fields)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_perfetto_2fconfig_2ftest_5fconfig_2eproto__INCLUDED
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/config/data_source_config.proto

#ifndef PROTOBUF_perfetto_2fconfig_2fdata_5fsource_5fconfig_2eproto__INCLUDED
#define PROTOBUF_perfetto_2fconfig_2fdata_5fsource_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// gen_amalgamated expanded: #include "perfetto/config/android/android_log_config.pb.h"
// gen_amalgamated expanded: #include "perfetto/config/android/packages_list_config.pb.h"
// gen_amalgamated expanded: #include "perfetto/config/chrome/chrome_config.pb.h"
// gen_amalgamated expanded: #include "perfetto/config/ftrace/ftrace_config.pb.h"
// gen_amalgamated expanded: #include "perfetto/config/gpu/gpu_counter_config.pb.h"
// gen_amalgamated expanded: #include "perfetto/config/inode_file/inode_file_config.pb.h"
// gen_amalgamated expanded: #include "perfetto/config/power/android_power_config.pb.h"
// gen_amalgamated expanded: #include "perfetto/config/process_stats/process_stats_config.pb.h"
// gen_amalgamated expanded: #include "perfetto/config/profiling/heapprofd_config.pb.h"
// gen_amalgamated expanded: #include "perfetto/config/sys_stats/sys_stats_config.pb.h"
// gen_amalgamated expanded: #include "perfetto/config/test_config.pb.h"
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_perfetto_2fconfig_2fdata_5fsource_5fconfig_2eproto();
void protobuf_AssignDesc_perfetto_2fconfig_2fdata_5fsource_5fconfig_2eproto();
void protobuf_ShutdownFile_perfetto_2fconfig_2fdata_5fsource_5fconfig_2eproto();

class DataSourceConfig;

// ===================================================================

class DataSourceConfig : public ::google::protobuf::MessageLite {
 public:
  DataSourceConfig();
  virtual ~DataSourceConfig();

  DataSourceConfig(const DataSourceConfig& from);

  inline DataSourceConfig& operator=(const DataSourceConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const DataSourceConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DataSourceConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DataSourceConfig* other);

  // implements Message ----------------------------------------------

  inline DataSourceConfig* New() const { return New(NULL); }

  DataSourceConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DataSourceConfig& from);
  void MergeFrom(const DataSourceConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DataSourceConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional uint32 target_buffer = 2;
  bool has_target_buffer() const;
  void clear_target_buffer();
  static const int kTargetBufferFieldNumber = 2;
  ::google::protobuf::uint32 target_buffer() const;
  void set_target_buffer(::google::protobuf::uint32 value);

  // optional uint32 trace_duration_ms = 3;
  bool has_trace_duration_ms() const;
  void clear_trace_duration_ms();
  static const int kTraceDurationMsFieldNumber = 3;
  ::google::protobuf::uint32 trace_duration_ms() const;
  void set_trace_duration_ms(::google::protobuf::uint32 value);

  // optional bool enable_extra_guardrails = 6;
  bool has_enable_extra_guardrails() const;
  void clear_enable_extra_guardrails();
  static const int kEnableExtraGuardrailsFieldNumber = 6;
  bool enable_extra_guardrails() const;
  void set_enable_extra_guardrails(bool value);

  // optional uint64 tracing_session_id = 4;
  bool has_tracing_session_id() const;
  void clear_tracing_session_id();
  static const int kTracingSessionIdFieldNumber = 4;
  ::google::protobuf::uint64 tracing_session_id() const;
  void set_tracing_session_id(::google::protobuf::uint64 value);

  // optional .perfetto.protos.FtraceConfig ftrace_config = 100 [lazy = true];
  bool has_ftrace_config() const;
  void clear_ftrace_config();
  static const int kFtraceConfigFieldNumber = 100;
  const ::perfetto::protos::FtraceConfig& ftrace_config() const;
  ::perfetto::protos::FtraceConfig* mutable_ftrace_config();
  ::perfetto::protos::FtraceConfig* release_ftrace_config();
  void set_allocated_ftrace_config(::perfetto::protos::FtraceConfig* ftrace_config);

  // optional .perfetto.protos.InodeFileConfig inode_file_config = 102 [lazy = true];
  bool has_inode_file_config() const;
  void clear_inode_file_config();
  static const int kInodeFileConfigFieldNumber = 102;
  const ::perfetto::protos::InodeFileConfig& inode_file_config() const;
  ::perfetto::protos::InodeFileConfig* mutable_inode_file_config();
  ::perfetto::protos::InodeFileConfig* release_inode_file_config();
  void set_allocated_inode_file_config(::perfetto::protos::InodeFileConfig* inode_file_config);

  // optional .perfetto.protos.ProcessStatsConfig process_stats_config = 103 [lazy = true];
  bool has_process_stats_config() const;
  void clear_process_stats_config();
  static const int kProcessStatsConfigFieldNumber = 103;
  const ::perfetto::protos::ProcessStatsConfig& process_stats_config() const;
  ::perfetto::protos::ProcessStatsConfig* mutable_process_stats_config();
  ::perfetto::protos::ProcessStatsConfig* release_process_stats_config();
  void set_allocated_process_stats_config(::perfetto::protos::ProcessStatsConfig* process_stats_config);

  // optional .perfetto.protos.SysStatsConfig sys_stats_config = 104 [lazy = true];
  bool has_sys_stats_config() const;
  void clear_sys_stats_config();
  static const int kSysStatsConfigFieldNumber = 104;
  const ::perfetto::protos::SysStatsConfig& sys_stats_config() const;
  ::perfetto::protos::SysStatsConfig* mutable_sys_stats_config();
  ::perfetto::protos::SysStatsConfig* release_sys_stats_config();
  void set_allocated_sys_stats_config(::perfetto::protos::SysStatsConfig* sys_stats_config);

  // optional .perfetto.protos.HeapprofdConfig heapprofd_config = 105 [lazy = true];
  bool has_heapprofd_config() const;
  void clear_heapprofd_config();
  static const int kHeapprofdConfigFieldNumber = 105;
  const ::perfetto::protos::HeapprofdConfig& heapprofd_config() const;
  ::perfetto::protos::HeapprofdConfig* mutable_heapprofd_config();
  ::perfetto::protos::HeapprofdConfig* release_heapprofd_config();
  void set_allocated_heapprofd_config(::perfetto::protos::HeapprofdConfig* heapprofd_config);

  // optional .perfetto.protos.AndroidPowerConfig android_power_config = 106 [lazy = true];
  bool has_android_power_config() const;
  void clear_android_power_config();
  static const int kAndroidPowerConfigFieldNumber = 106;
  const ::perfetto::protos::AndroidPowerConfig& android_power_config() const;
  ::perfetto::protos::AndroidPowerConfig* mutable_android_power_config();
  ::perfetto::protos::AndroidPowerConfig* release_android_power_config();
  void set_allocated_android_power_config(::perfetto::protos::AndroidPowerConfig* android_power_config);

  // optional .perfetto.protos.AndroidLogConfig android_log_config = 107 [lazy = true];
  bool has_android_log_config() const;
  void clear_android_log_config();
  static const int kAndroidLogConfigFieldNumber = 107;
  const ::perfetto::protos::AndroidLogConfig& android_log_config() const;
  ::perfetto::protos::AndroidLogConfig* mutable_android_log_config();
  ::perfetto::protos::AndroidLogConfig* release_android_log_config();
  void set_allocated_android_log_config(::perfetto::protos::AndroidLogConfig* android_log_config);

  // optional .perfetto.protos.GpuCounterConfig gpu_counter_config = 108 [lazy = true];
  bool has_gpu_counter_config() const;
  void clear_gpu_counter_config();
  static const int kGpuCounterConfigFieldNumber = 108;
  const ::perfetto::protos::GpuCounterConfig& gpu_counter_config() const;
  ::perfetto::protos::GpuCounterConfig* mutable_gpu_counter_config();
  ::perfetto::protos::GpuCounterConfig* release_gpu_counter_config();
  void set_allocated_gpu_counter_config(::perfetto::protos::GpuCounterConfig* gpu_counter_config);

  // optional .perfetto.protos.PackagesListConfig packages_list_config = 109 [lazy = true];
  bool has_packages_list_config() const;
  void clear_packages_list_config();
  static const int kPackagesListConfigFieldNumber = 109;
  const ::perfetto::protos::PackagesListConfig& packages_list_config() const;
  ::perfetto::protos::PackagesListConfig* mutable_packages_list_config();
  ::perfetto::protos::PackagesListConfig* release_packages_list_config();
  void set_allocated_packages_list_config(::perfetto::protos::PackagesListConfig* packages_list_config);

  // optional .perfetto.protos.ChromeConfig chrome_config = 101;
  bool has_chrome_config() const;
  void clear_chrome_config();
  static const int kChromeConfigFieldNumber = 101;
  const ::perfetto::protos::ChromeConfig& chrome_config() const;
  ::perfetto::protos::ChromeConfig* mutable_chrome_config();
  ::perfetto::protos::ChromeConfig* release_chrome_config();
  void set_allocated_chrome_config(::perfetto::protos::ChromeConfig* chrome_config);

  // optional string legacy_config = 1000;
  bool has_legacy_config() const;
  void clear_legacy_config();
  static const int kLegacyConfigFieldNumber = 1000;
  const ::std::string& legacy_config() const;
  void set_legacy_config(const ::std::string& value);
  void set_legacy_config(const char* value);
  void set_legacy_config(const char* value, size_t size);
  ::std::string* mutable_legacy_config();
  ::std::string* release_legacy_config();
  void set_allocated_legacy_config(::std::string* legacy_config);

  // optional .perfetto.protos.TestConfig for_testing = 1001;
  bool has_for_testing() const;
  void clear_for_testing();
  static const int kForTestingFieldNumber = 1001;
  const ::perfetto::protos::TestConfig& for_testing() const;
  ::perfetto::protos::TestConfig* mutable_for_testing();
  ::perfetto::protos::TestConfig* release_for_testing();
  void set_allocated_for_testing(::perfetto::protos::TestConfig* for_testing);

  // @@protoc_insertion_point(class_scope:perfetto.protos.DataSourceConfig)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_target_buffer();
  inline void clear_has_target_buffer();
  inline void set_has_trace_duration_ms();
  inline void clear_has_trace_duration_ms();
  inline void set_has_enable_extra_guardrails();
  inline void clear_has_enable_extra_guardrails();
  inline void set_has_tracing_session_id();
  inline void clear_has_tracing_session_id();
  inline void set_has_ftrace_config();
  inline void clear_has_ftrace_config();
  inline void set_has_inode_file_config();
  inline void clear_has_inode_file_config();
  inline void set_has_process_stats_config();
  inline void clear_has_process_stats_config();
  inline void set_has_sys_stats_config();
  inline void clear_has_sys_stats_config();
  inline void set_has_heapprofd_config();
  inline void clear_has_heapprofd_config();
  inline void set_has_android_power_config();
  inline void clear_has_android_power_config();
  inline void set_has_android_log_config();
  inline void clear_has_android_log_config();
  inline void set_has_gpu_counter_config();
  inline void clear_has_gpu_counter_config();
  inline void set_has_packages_list_config();
  inline void clear_has_packages_list_config();
  inline void set_has_chrome_config();
  inline void clear_has_chrome_config();
  inline void set_has_legacy_config();
  inline void clear_has_legacy_config();
  inline void set_has_for_testing();
  inline void clear_has_for_testing();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint32 target_buffer_;
  ::google::protobuf::uint32 trace_duration_ms_;
  ::google::protobuf::uint64 tracing_session_id_;
  ::perfetto::protos::FtraceConfig* ftrace_config_;
  ::perfetto::protos::InodeFileConfig* inode_file_config_;
  ::perfetto::protos::ProcessStatsConfig* process_stats_config_;
  ::perfetto::protos::SysStatsConfig* sys_stats_config_;
  ::perfetto::protos::HeapprofdConfig* heapprofd_config_;
  ::perfetto::protos::AndroidPowerConfig* android_power_config_;
  ::perfetto::protos::AndroidLogConfig* android_log_config_;
  ::perfetto::protos::GpuCounterConfig* gpu_counter_config_;
  ::perfetto::protos::PackagesListConfig* packages_list_config_;
  ::perfetto::protos::ChromeConfig* chrome_config_;
  ::google::protobuf::internal::ArenaStringPtr legacy_config_;
  ::perfetto::protos::TestConfig* for_testing_;
  bool enable_extra_guardrails_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fconfig_2fdata_5fsource_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fconfig_2fdata_5fsource_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fconfig_2fdata_5fsource_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fconfig_2fdata_5fsource_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static DataSourceConfig* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// DataSourceConfig

// optional string name = 1;
inline bool DataSourceConfig::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataSourceConfig::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataSourceConfig::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataSourceConfig::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& DataSourceConfig::name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DataSourceConfig::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.DataSourceConfig.name)
}
inline void DataSourceConfig::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.DataSourceConfig.name)
}
inline void DataSourceConfig::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.DataSourceConfig.name)
}
inline ::std::string* DataSourceConfig::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceConfig.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DataSourceConfig::release_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceConfig.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DataSourceConfig::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceConfig.name)
}

// optional uint32 target_buffer = 2;
inline bool DataSourceConfig::has_target_buffer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataSourceConfig::set_has_target_buffer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataSourceConfig::clear_has_target_buffer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataSourceConfig::clear_target_buffer() {
  target_buffer_ = 0u;
  clear_has_target_buffer();
}
inline ::google::protobuf::uint32 DataSourceConfig::target_buffer() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.target_buffer)
  return target_buffer_;
}
inline void DataSourceConfig::set_target_buffer(::google::protobuf::uint32 value) {
  set_has_target_buffer();
  target_buffer_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.DataSourceConfig.target_buffer)
}

// optional uint32 trace_duration_ms = 3;
inline bool DataSourceConfig::has_trace_duration_ms() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DataSourceConfig::set_has_trace_duration_ms() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DataSourceConfig::clear_has_trace_duration_ms() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DataSourceConfig::clear_trace_duration_ms() {
  trace_duration_ms_ = 0u;
  clear_has_trace_duration_ms();
}
inline ::google::protobuf::uint32 DataSourceConfig::trace_duration_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.trace_duration_ms)
  return trace_duration_ms_;
}
inline void DataSourceConfig::set_trace_duration_ms(::google::protobuf::uint32 value) {
  set_has_trace_duration_ms();
  trace_duration_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.DataSourceConfig.trace_duration_ms)
}

// optional bool enable_extra_guardrails = 6;
inline bool DataSourceConfig::has_enable_extra_guardrails() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DataSourceConfig::set_has_enable_extra_guardrails() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DataSourceConfig::clear_has_enable_extra_guardrails() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DataSourceConfig::clear_enable_extra_guardrails() {
  enable_extra_guardrails_ = false;
  clear_has_enable_extra_guardrails();
}
inline bool DataSourceConfig::enable_extra_guardrails() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.enable_extra_guardrails)
  return enable_extra_guardrails_;
}
inline void DataSourceConfig::set_enable_extra_guardrails(bool value) {
  set_has_enable_extra_guardrails();
  enable_extra_guardrails_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.DataSourceConfig.enable_extra_guardrails)
}

// optional uint64 tracing_session_id = 4;
inline bool DataSourceConfig::has_tracing_session_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DataSourceConfig::set_has_tracing_session_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DataSourceConfig::clear_has_tracing_session_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DataSourceConfig::clear_tracing_session_id() {
  tracing_session_id_ = GOOGLE_ULONGLONG(0);
  clear_has_tracing_session_id();
}
inline ::google::protobuf::uint64 DataSourceConfig::tracing_session_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.tracing_session_id)
  return tracing_session_id_;
}
inline void DataSourceConfig::set_tracing_session_id(::google::protobuf::uint64 value) {
  set_has_tracing_session_id();
  tracing_session_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.DataSourceConfig.tracing_session_id)
}

// optional .perfetto.protos.FtraceConfig ftrace_config = 100 [lazy = true];
inline bool DataSourceConfig::has_ftrace_config() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DataSourceConfig::set_has_ftrace_config() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DataSourceConfig::clear_has_ftrace_config() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DataSourceConfig::clear_ftrace_config() {
  if (ftrace_config_ != NULL) ftrace_config_->::perfetto::protos::FtraceConfig::Clear();
  clear_has_ftrace_config();
}
inline const ::perfetto::protos::FtraceConfig& DataSourceConfig::ftrace_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.ftrace_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return ftrace_config_ != NULL ? *ftrace_config_ : *default_instance().ftrace_config_;
#else
  return ftrace_config_ != NULL ? *ftrace_config_ : *default_instance_->ftrace_config_;
#endif
}
inline ::perfetto::protos::FtraceConfig* DataSourceConfig::mutable_ftrace_config() {
  set_has_ftrace_config();
  if (ftrace_config_ == NULL) {
    ftrace_config_ = new ::perfetto::protos::FtraceConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceConfig.ftrace_config)
  return ftrace_config_;
}
inline ::perfetto::protos::FtraceConfig* DataSourceConfig::release_ftrace_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceConfig.ftrace_config)
  clear_has_ftrace_config();
  ::perfetto::protos::FtraceConfig* temp = ftrace_config_;
  ftrace_config_ = NULL;
  return temp;
}
inline void DataSourceConfig::set_allocated_ftrace_config(::perfetto::protos::FtraceConfig* ftrace_config) {
  delete ftrace_config_;
  ftrace_config_ = ftrace_config;
  if (ftrace_config) {
    set_has_ftrace_config();
  } else {
    clear_has_ftrace_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceConfig.ftrace_config)
}

// optional .perfetto.protos.InodeFileConfig inode_file_config = 102 [lazy = true];
inline bool DataSourceConfig::has_inode_file_config() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DataSourceConfig::set_has_inode_file_config() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DataSourceConfig::clear_has_inode_file_config() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DataSourceConfig::clear_inode_file_config() {
  if (inode_file_config_ != NULL) inode_file_config_->::perfetto::protos::InodeFileConfig::Clear();
  clear_has_inode_file_config();
}
inline const ::perfetto::protos::InodeFileConfig& DataSourceConfig::inode_file_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.inode_file_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return inode_file_config_ != NULL ? *inode_file_config_ : *default_instance().inode_file_config_;
#else
  return inode_file_config_ != NULL ? *inode_file_config_ : *default_instance_->inode_file_config_;
#endif
}
inline ::perfetto::protos::InodeFileConfig* DataSourceConfig::mutable_inode_file_config() {
  set_has_inode_file_config();
  if (inode_file_config_ == NULL) {
    inode_file_config_ = new ::perfetto::protos::InodeFileConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceConfig.inode_file_config)
  return inode_file_config_;
}
inline ::perfetto::protos::InodeFileConfig* DataSourceConfig::release_inode_file_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceConfig.inode_file_config)
  clear_has_inode_file_config();
  ::perfetto::protos::InodeFileConfig* temp = inode_file_config_;
  inode_file_config_ = NULL;
  return temp;
}
inline void DataSourceConfig::set_allocated_inode_file_config(::perfetto::protos::InodeFileConfig* inode_file_config) {
  delete inode_file_config_;
  inode_file_config_ = inode_file_config;
  if (inode_file_config) {
    set_has_inode_file_config();
  } else {
    clear_has_inode_file_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceConfig.inode_file_config)
}

// optional .perfetto.protos.ProcessStatsConfig process_stats_config = 103 [lazy = true];
inline bool DataSourceConfig::has_process_stats_config() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DataSourceConfig::set_has_process_stats_config() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DataSourceConfig::clear_has_process_stats_config() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DataSourceConfig::clear_process_stats_config() {
  if (process_stats_config_ != NULL) process_stats_config_->::perfetto::protos::ProcessStatsConfig::Clear();
  clear_has_process_stats_config();
}
inline const ::perfetto::protos::ProcessStatsConfig& DataSourceConfig::process_stats_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.process_stats_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return process_stats_config_ != NULL ? *process_stats_config_ : *default_instance().process_stats_config_;
#else
  return process_stats_config_ != NULL ? *process_stats_config_ : *default_instance_->process_stats_config_;
#endif
}
inline ::perfetto::protos::ProcessStatsConfig* DataSourceConfig::mutable_process_stats_config() {
  set_has_process_stats_config();
  if (process_stats_config_ == NULL) {
    process_stats_config_ = new ::perfetto::protos::ProcessStatsConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceConfig.process_stats_config)
  return process_stats_config_;
}
inline ::perfetto::protos::ProcessStatsConfig* DataSourceConfig::release_process_stats_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceConfig.process_stats_config)
  clear_has_process_stats_config();
  ::perfetto::protos::ProcessStatsConfig* temp = process_stats_config_;
  process_stats_config_ = NULL;
  return temp;
}
inline void DataSourceConfig::set_allocated_process_stats_config(::perfetto::protos::ProcessStatsConfig* process_stats_config) {
  delete process_stats_config_;
  process_stats_config_ = process_stats_config;
  if (process_stats_config) {
    set_has_process_stats_config();
  } else {
    clear_has_process_stats_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceConfig.process_stats_config)
}

// optional .perfetto.protos.SysStatsConfig sys_stats_config = 104 [lazy = true];
inline bool DataSourceConfig::has_sys_stats_config() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DataSourceConfig::set_has_sys_stats_config() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DataSourceConfig::clear_has_sys_stats_config() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DataSourceConfig::clear_sys_stats_config() {
  if (sys_stats_config_ != NULL) sys_stats_config_->::perfetto::protos::SysStatsConfig::Clear();
  clear_has_sys_stats_config();
}
inline const ::perfetto::protos::SysStatsConfig& DataSourceConfig::sys_stats_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.sys_stats_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return sys_stats_config_ != NULL ? *sys_stats_config_ : *default_instance().sys_stats_config_;
#else
  return sys_stats_config_ != NULL ? *sys_stats_config_ : *default_instance_->sys_stats_config_;
#endif
}
inline ::perfetto::protos::SysStatsConfig* DataSourceConfig::mutable_sys_stats_config() {
  set_has_sys_stats_config();
  if (sys_stats_config_ == NULL) {
    sys_stats_config_ = new ::perfetto::protos::SysStatsConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceConfig.sys_stats_config)
  return sys_stats_config_;
}
inline ::perfetto::protos::SysStatsConfig* DataSourceConfig::release_sys_stats_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceConfig.sys_stats_config)
  clear_has_sys_stats_config();
  ::perfetto::protos::SysStatsConfig* temp = sys_stats_config_;
  sys_stats_config_ = NULL;
  return temp;
}
inline void DataSourceConfig::set_allocated_sys_stats_config(::perfetto::protos::SysStatsConfig* sys_stats_config) {
  delete sys_stats_config_;
  sys_stats_config_ = sys_stats_config;
  if (sys_stats_config) {
    set_has_sys_stats_config();
  } else {
    clear_has_sys_stats_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceConfig.sys_stats_config)
}

// optional .perfetto.protos.HeapprofdConfig heapprofd_config = 105 [lazy = true];
inline bool DataSourceConfig::has_heapprofd_config() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DataSourceConfig::set_has_heapprofd_config() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DataSourceConfig::clear_has_heapprofd_config() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DataSourceConfig::clear_heapprofd_config() {
  if (heapprofd_config_ != NULL) heapprofd_config_->::perfetto::protos::HeapprofdConfig::Clear();
  clear_has_heapprofd_config();
}
inline const ::perfetto::protos::HeapprofdConfig& DataSourceConfig::heapprofd_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.heapprofd_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return heapprofd_config_ != NULL ? *heapprofd_config_ : *default_instance().heapprofd_config_;
#else
  return heapprofd_config_ != NULL ? *heapprofd_config_ : *default_instance_->heapprofd_config_;
#endif
}
inline ::perfetto::protos::HeapprofdConfig* DataSourceConfig::mutable_heapprofd_config() {
  set_has_heapprofd_config();
  if (heapprofd_config_ == NULL) {
    heapprofd_config_ = new ::perfetto::protos::HeapprofdConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceConfig.heapprofd_config)
  return heapprofd_config_;
}
inline ::perfetto::protos::HeapprofdConfig* DataSourceConfig::release_heapprofd_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceConfig.heapprofd_config)
  clear_has_heapprofd_config();
  ::perfetto::protos::HeapprofdConfig* temp = heapprofd_config_;
  heapprofd_config_ = NULL;
  return temp;
}
inline void DataSourceConfig::set_allocated_heapprofd_config(::perfetto::protos::HeapprofdConfig* heapprofd_config) {
  delete heapprofd_config_;
  heapprofd_config_ = heapprofd_config;
  if (heapprofd_config) {
    set_has_heapprofd_config();
  } else {
    clear_has_heapprofd_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceConfig.heapprofd_config)
}

// optional .perfetto.protos.AndroidPowerConfig android_power_config = 106 [lazy = true];
inline bool DataSourceConfig::has_android_power_config() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DataSourceConfig::set_has_android_power_config() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DataSourceConfig::clear_has_android_power_config() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DataSourceConfig::clear_android_power_config() {
  if (android_power_config_ != NULL) android_power_config_->::perfetto::protos::AndroidPowerConfig::Clear();
  clear_has_android_power_config();
}
inline const ::perfetto::protos::AndroidPowerConfig& DataSourceConfig::android_power_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.android_power_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return android_power_config_ != NULL ? *android_power_config_ : *default_instance().android_power_config_;
#else
  return android_power_config_ != NULL ? *android_power_config_ : *default_instance_->android_power_config_;
#endif
}
inline ::perfetto::protos::AndroidPowerConfig* DataSourceConfig::mutable_android_power_config() {
  set_has_android_power_config();
  if (android_power_config_ == NULL) {
    android_power_config_ = new ::perfetto::protos::AndroidPowerConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceConfig.android_power_config)
  return android_power_config_;
}
inline ::perfetto::protos::AndroidPowerConfig* DataSourceConfig::release_android_power_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceConfig.android_power_config)
  clear_has_android_power_config();
  ::perfetto::protos::AndroidPowerConfig* temp = android_power_config_;
  android_power_config_ = NULL;
  return temp;
}
inline void DataSourceConfig::set_allocated_android_power_config(::perfetto::protos::AndroidPowerConfig* android_power_config) {
  delete android_power_config_;
  android_power_config_ = android_power_config;
  if (android_power_config) {
    set_has_android_power_config();
  } else {
    clear_has_android_power_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceConfig.android_power_config)
}

// optional .perfetto.protos.AndroidLogConfig android_log_config = 107 [lazy = true];
inline bool DataSourceConfig::has_android_log_config() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DataSourceConfig::set_has_android_log_config() {
  _has_bits_[0] |= 0x00000800u;
}
inline void DataSourceConfig::clear_has_android_log_config() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void DataSourceConfig::clear_android_log_config() {
  if (android_log_config_ != NULL) android_log_config_->::perfetto::protos::AndroidLogConfig::Clear();
  clear_has_android_log_config();
}
inline const ::perfetto::protos::AndroidLogConfig& DataSourceConfig::android_log_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.android_log_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return android_log_config_ != NULL ? *android_log_config_ : *default_instance().android_log_config_;
#else
  return android_log_config_ != NULL ? *android_log_config_ : *default_instance_->android_log_config_;
#endif
}
inline ::perfetto::protos::AndroidLogConfig* DataSourceConfig::mutable_android_log_config() {
  set_has_android_log_config();
  if (android_log_config_ == NULL) {
    android_log_config_ = new ::perfetto::protos::AndroidLogConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceConfig.android_log_config)
  return android_log_config_;
}
inline ::perfetto::protos::AndroidLogConfig* DataSourceConfig::release_android_log_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceConfig.android_log_config)
  clear_has_android_log_config();
  ::perfetto::protos::AndroidLogConfig* temp = android_log_config_;
  android_log_config_ = NULL;
  return temp;
}
inline void DataSourceConfig::set_allocated_android_log_config(::perfetto::protos::AndroidLogConfig* android_log_config) {
  delete android_log_config_;
  android_log_config_ = android_log_config;
  if (android_log_config) {
    set_has_android_log_config();
  } else {
    clear_has_android_log_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceConfig.android_log_config)
}

// optional .perfetto.protos.GpuCounterConfig gpu_counter_config = 108 [lazy = true];
inline bool DataSourceConfig::has_gpu_counter_config() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void DataSourceConfig::set_has_gpu_counter_config() {
  _has_bits_[0] |= 0x00001000u;
}
inline void DataSourceConfig::clear_has_gpu_counter_config() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void DataSourceConfig::clear_gpu_counter_config() {
  if (gpu_counter_config_ != NULL) gpu_counter_config_->::perfetto::protos::GpuCounterConfig::Clear();
  clear_has_gpu_counter_config();
}
inline const ::perfetto::protos::GpuCounterConfig& DataSourceConfig::gpu_counter_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.gpu_counter_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return gpu_counter_config_ != NULL ? *gpu_counter_config_ : *default_instance().gpu_counter_config_;
#else
  return gpu_counter_config_ != NULL ? *gpu_counter_config_ : *default_instance_->gpu_counter_config_;
#endif
}
inline ::perfetto::protos::GpuCounterConfig* DataSourceConfig::mutable_gpu_counter_config() {
  set_has_gpu_counter_config();
  if (gpu_counter_config_ == NULL) {
    gpu_counter_config_ = new ::perfetto::protos::GpuCounterConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceConfig.gpu_counter_config)
  return gpu_counter_config_;
}
inline ::perfetto::protos::GpuCounterConfig* DataSourceConfig::release_gpu_counter_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceConfig.gpu_counter_config)
  clear_has_gpu_counter_config();
  ::perfetto::protos::GpuCounterConfig* temp = gpu_counter_config_;
  gpu_counter_config_ = NULL;
  return temp;
}
inline void DataSourceConfig::set_allocated_gpu_counter_config(::perfetto::protos::GpuCounterConfig* gpu_counter_config) {
  delete gpu_counter_config_;
  gpu_counter_config_ = gpu_counter_config;
  if (gpu_counter_config) {
    set_has_gpu_counter_config();
  } else {
    clear_has_gpu_counter_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceConfig.gpu_counter_config)
}

// optional .perfetto.protos.PackagesListConfig packages_list_config = 109 [lazy = true];
inline bool DataSourceConfig::has_packages_list_config() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void DataSourceConfig::set_has_packages_list_config() {
  _has_bits_[0] |= 0x00002000u;
}
inline void DataSourceConfig::clear_has_packages_list_config() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void DataSourceConfig::clear_packages_list_config() {
  if (packages_list_config_ != NULL) packages_list_config_->::perfetto::protos::PackagesListConfig::Clear();
  clear_has_packages_list_config();
}
inline const ::perfetto::protos::PackagesListConfig& DataSourceConfig::packages_list_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.packages_list_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return packages_list_config_ != NULL ? *packages_list_config_ : *default_instance().packages_list_config_;
#else
  return packages_list_config_ != NULL ? *packages_list_config_ : *default_instance_->packages_list_config_;
#endif
}
inline ::perfetto::protos::PackagesListConfig* DataSourceConfig::mutable_packages_list_config() {
  set_has_packages_list_config();
  if (packages_list_config_ == NULL) {
    packages_list_config_ = new ::perfetto::protos::PackagesListConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceConfig.packages_list_config)
  return packages_list_config_;
}
inline ::perfetto::protos::PackagesListConfig* DataSourceConfig::release_packages_list_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceConfig.packages_list_config)
  clear_has_packages_list_config();
  ::perfetto::protos::PackagesListConfig* temp = packages_list_config_;
  packages_list_config_ = NULL;
  return temp;
}
inline void DataSourceConfig::set_allocated_packages_list_config(::perfetto::protos::PackagesListConfig* packages_list_config) {
  delete packages_list_config_;
  packages_list_config_ = packages_list_config;
  if (packages_list_config) {
    set_has_packages_list_config();
  } else {
    clear_has_packages_list_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceConfig.packages_list_config)
}

// optional .perfetto.protos.ChromeConfig chrome_config = 101;
inline bool DataSourceConfig::has_chrome_config() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void DataSourceConfig::set_has_chrome_config() {
  _has_bits_[0] |= 0x00004000u;
}
inline void DataSourceConfig::clear_has_chrome_config() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void DataSourceConfig::clear_chrome_config() {
  if (chrome_config_ != NULL) chrome_config_->::perfetto::protos::ChromeConfig::Clear();
  clear_has_chrome_config();
}
inline const ::perfetto::protos::ChromeConfig& DataSourceConfig::chrome_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.chrome_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return chrome_config_ != NULL ? *chrome_config_ : *default_instance().chrome_config_;
#else
  return chrome_config_ != NULL ? *chrome_config_ : *default_instance_->chrome_config_;
#endif
}
inline ::perfetto::protos::ChromeConfig* DataSourceConfig::mutable_chrome_config() {
  set_has_chrome_config();
  if (chrome_config_ == NULL) {
    chrome_config_ = new ::perfetto::protos::ChromeConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceConfig.chrome_config)
  return chrome_config_;
}
inline ::perfetto::protos::ChromeConfig* DataSourceConfig::release_chrome_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceConfig.chrome_config)
  clear_has_chrome_config();
  ::perfetto::protos::ChromeConfig* temp = chrome_config_;
  chrome_config_ = NULL;
  return temp;
}
inline void DataSourceConfig::set_allocated_chrome_config(::perfetto::protos::ChromeConfig* chrome_config) {
  delete chrome_config_;
  chrome_config_ = chrome_config;
  if (chrome_config) {
    set_has_chrome_config();
  } else {
    clear_has_chrome_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceConfig.chrome_config)
}

// optional string legacy_config = 1000;
inline bool DataSourceConfig::has_legacy_config() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void DataSourceConfig::set_has_legacy_config() {
  _has_bits_[0] |= 0x00008000u;
}
inline void DataSourceConfig::clear_has_legacy_config() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void DataSourceConfig::clear_legacy_config() {
  legacy_config_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_legacy_config();
}
inline const ::std::string& DataSourceConfig::legacy_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.legacy_config)
  return legacy_config_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DataSourceConfig::set_legacy_config(const ::std::string& value) {
  set_has_legacy_config();
  legacy_config_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.DataSourceConfig.legacy_config)
}
inline void DataSourceConfig::set_legacy_config(const char* value) {
  set_has_legacy_config();
  legacy_config_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.DataSourceConfig.legacy_config)
}
inline void DataSourceConfig::set_legacy_config(const char* value, size_t size) {
  set_has_legacy_config();
  legacy_config_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.DataSourceConfig.legacy_config)
}
inline ::std::string* DataSourceConfig::mutable_legacy_config() {
  set_has_legacy_config();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceConfig.legacy_config)
  return legacy_config_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DataSourceConfig::release_legacy_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceConfig.legacy_config)
  clear_has_legacy_config();
  return legacy_config_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DataSourceConfig::set_allocated_legacy_config(::std::string* legacy_config) {
  if (legacy_config != NULL) {
    set_has_legacy_config();
  } else {
    clear_has_legacy_config();
  }
  legacy_config_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), legacy_config);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceConfig.legacy_config)
}

// optional .perfetto.protos.TestConfig for_testing = 1001;
inline bool DataSourceConfig::has_for_testing() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void DataSourceConfig::set_has_for_testing() {
  _has_bits_[0] |= 0x00010000u;
}
inline void DataSourceConfig::clear_has_for_testing() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void DataSourceConfig::clear_for_testing() {
  if (for_testing_ != NULL) for_testing_->::perfetto::protos::TestConfig::Clear();
  clear_has_for_testing();
}
inline const ::perfetto::protos::TestConfig& DataSourceConfig::for_testing() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.for_testing)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return for_testing_ != NULL ? *for_testing_ : *default_instance().for_testing_;
#else
  return for_testing_ != NULL ? *for_testing_ : *default_instance_->for_testing_;
#endif
}
inline ::perfetto::protos::TestConfig* DataSourceConfig::mutable_for_testing() {
  set_has_for_testing();
  if (for_testing_ == NULL) {
    for_testing_ = new ::perfetto::protos::TestConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceConfig.for_testing)
  return for_testing_;
}
inline ::perfetto::protos::TestConfig* DataSourceConfig::release_for_testing() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceConfig.for_testing)
  clear_has_for_testing();
  ::perfetto::protos::TestConfig* temp = for_testing_;
  for_testing_ = NULL;
  return temp;
}
inline void DataSourceConfig::set_allocated_for_testing(::perfetto::protos::TestConfig* for_testing) {
  delete for_testing_;
  for_testing_ = for_testing;
  if (for_testing) {
    set_has_for_testing();
  } else {
    clear_has_for_testing();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceConfig.for_testing)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_perfetto_2fconfig_2fdata_5fsource_5fconfig_2eproto__INCLUDED
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/config/data_source_config.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
// gen_amalgamated expanded: #include "perfetto/config/data_source_config.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

void protobuf_ShutdownFile_perfetto_2fconfig_2fdata_5fsource_5fconfig_2eproto() {
  delete DataSourceConfig::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_perfetto_2fconfig_2fdata_5fsource_5fconfig_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_perfetto_2fconfig_2fdata_5fsource_5fconfig_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::perfetto::protos::protobuf_AddDesc_perfetto_2fconfig_2fandroid_2fandroid_5flog_5fconfig_2eproto();
  ::perfetto::protos::protobuf_AddDesc_perfetto_2fconfig_2fandroid_2fpackages_5flist_5fconfig_2eproto();
  ::perfetto::protos::protobuf_AddDesc_perfetto_2fconfig_2fchrome_2fchrome_5fconfig_2eproto();
  ::perfetto::protos::protobuf_AddDesc_perfetto_2fconfig_2fftrace_2fftrace_5fconfig_2eproto();
  ::perfetto::protos::protobuf_AddDesc_perfetto_2fconfig_2fgpu_2fgpu_5fcounter_5fconfig_2eproto();
  ::perfetto::protos::protobuf_AddDesc_perfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto();
  ::perfetto::protos::protobuf_AddDesc_perfetto_2fconfig_2fpower_2fandroid_5fpower_5fconfig_2eproto();
  ::perfetto::protos::protobuf_AddDesc_perfetto_2fconfig_2fprocess_5fstats_2fprocess_5fstats_5fconfig_2eproto();
  ::perfetto::protos::protobuf_AddDesc_perfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto();
  ::perfetto::protos::protobuf_AddDesc_perfetto_2fconfig_2fsys_5fstats_2fsys_5fstats_5fconfig_2eproto();
  ::perfetto::protos::protobuf_AddDesc_perfetto_2fconfig_2ftest_5fconfig_2eproto();
  DataSourceConfig::default_instance_ = new DataSourceConfig();
  DataSourceConfig::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_perfetto_2fconfig_2fdata_5fsource_5fconfig_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_perfetto_2fconfig_2fdata_5fsource_5fconfig_2eproto_once_);
void protobuf_AddDesc_perfetto_2fconfig_2fdata_5fsource_5fconfig_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_perfetto_2fconfig_2fdata_5fsource_5fconfig_2eproto_once_,
                 &protobuf_AddDesc_perfetto_2fconfig_2fdata_5fsource_5fconfig_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_perfetto_2fconfig_2fdata_5fsource_5fconfig_2eproto {
  StaticDescriptorInitializer_perfetto_2fconfig_2fdata_5fsource_5fconfig_2eproto() {
    protobuf_AddDesc_perfetto_2fconfig_2fdata_5fsource_5fconfig_2eproto();
  }
} static_descriptor_initializer_perfetto_2fconfig_2fdata_5fsource_5fconfig_2eproto_;
#endif

namespace {

static void data_source_config_pb_MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
static void data_source_config_pb_MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

static ::std::string* MutableUnknownFieldsForDataSourceConfig(
    DataSourceConfig* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DataSourceConfig::kNameFieldNumber;
const int DataSourceConfig::kTargetBufferFieldNumber;
const int DataSourceConfig::kTraceDurationMsFieldNumber;
const int DataSourceConfig::kEnableExtraGuardrailsFieldNumber;
const int DataSourceConfig::kTracingSessionIdFieldNumber;
const int DataSourceConfig::kFtraceConfigFieldNumber;
const int DataSourceConfig::kInodeFileConfigFieldNumber;
const int DataSourceConfig::kProcessStatsConfigFieldNumber;
const int DataSourceConfig::kSysStatsConfigFieldNumber;
const int DataSourceConfig::kHeapprofdConfigFieldNumber;
const int DataSourceConfig::kAndroidPowerConfigFieldNumber;
const int DataSourceConfig::kAndroidLogConfigFieldNumber;
const int DataSourceConfig::kGpuCounterConfigFieldNumber;
const int DataSourceConfig::kPackagesListConfigFieldNumber;
const int DataSourceConfig::kChromeConfigFieldNumber;
const int DataSourceConfig::kLegacyConfigFieldNumber;
const int DataSourceConfig::kForTestingFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DataSourceConfig::DataSourceConfig()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.DataSourceConfig)
}

void DataSourceConfig::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  ftrace_config_ = const_cast< ::perfetto::protos::FtraceConfig*>(
      ::perfetto::protos::FtraceConfig::internal_default_instance());
#else
  ftrace_config_ = const_cast< ::perfetto::protos::FtraceConfig*>(&::perfetto::protos::FtraceConfig::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  inode_file_config_ = const_cast< ::perfetto::protos::InodeFileConfig*>(
      ::perfetto::protos::InodeFileConfig::internal_default_instance());
#else
  inode_file_config_ = const_cast< ::perfetto::protos::InodeFileConfig*>(&::perfetto::protos::InodeFileConfig::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  process_stats_config_ = const_cast< ::perfetto::protos::ProcessStatsConfig*>(
      ::perfetto::protos::ProcessStatsConfig::internal_default_instance());
#else
  process_stats_config_ = const_cast< ::perfetto::protos::ProcessStatsConfig*>(&::perfetto::protos::ProcessStatsConfig::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  sys_stats_config_ = const_cast< ::perfetto::protos::SysStatsConfig*>(
      ::perfetto::protos::SysStatsConfig::internal_default_instance());
#else
  sys_stats_config_ = const_cast< ::perfetto::protos::SysStatsConfig*>(&::perfetto::protos::SysStatsConfig::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  heapprofd_config_ = const_cast< ::perfetto::protos::HeapprofdConfig*>(
      ::perfetto::protos::HeapprofdConfig::internal_default_instance());
#else
  heapprofd_config_ = const_cast< ::perfetto::protos::HeapprofdConfig*>(&::perfetto::protos::HeapprofdConfig::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  android_power_config_ = const_cast< ::perfetto::protos::AndroidPowerConfig*>(
      ::perfetto::protos::AndroidPowerConfig::internal_default_instance());
#else
  android_power_config_ = const_cast< ::perfetto::protos::AndroidPowerConfig*>(&::perfetto::protos::AndroidPowerConfig::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  android_log_config_ = const_cast< ::perfetto::protos::AndroidLogConfig*>(
      ::perfetto::protos::AndroidLogConfig::internal_default_instance());
#else
  android_log_config_ = const_cast< ::perfetto::protos::AndroidLogConfig*>(&::perfetto::protos::AndroidLogConfig::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  gpu_counter_config_ = const_cast< ::perfetto::protos::GpuCounterConfig*>(
      ::perfetto::protos::GpuCounterConfig::internal_default_instance());
#else
  gpu_counter_config_ = const_cast< ::perfetto::protos::GpuCounterConfig*>(&::perfetto::protos::GpuCounterConfig::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  packages_list_config_ = const_cast< ::perfetto::protos::PackagesListConfig*>(
      ::perfetto::protos::PackagesListConfig::internal_default_instance());
#else
  packages_list_config_ = const_cast< ::perfetto::protos::PackagesListConfig*>(&::perfetto::protos::PackagesListConfig::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  chrome_config_ = const_cast< ::perfetto::protos::ChromeConfig*>(
      ::perfetto::protos::ChromeConfig::internal_default_instance());
#else
  chrome_config_ = const_cast< ::perfetto::protos::ChromeConfig*>(&::perfetto::protos::ChromeConfig::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  for_testing_ = const_cast< ::perfetto::protos::TestConfig*>(
      ::perfetto::protos::TestConfig::internal_default_instance());
#else
  for_testing_ = const_cast< ::perfetto::protos::TestConfig*>(&::perfetto::protos::TestConfig::default_instance());
#endif
}

DataSourceConfig::DataSourceConfig(const DataSourceConfig& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.DataSourceConfig)
}

void DataSourceConfig::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  target_buffer_ = 0u;
  trace_duration_ms_ = 0u;
  enable_extra_guardrails_ = false;
  tracing_session_id_ = GOOGLE_ULONGLONG(0);
  ftrace_config_ = NULL;
  inode_file_config_ = NULL;
  process_stats_config_ = NULL;
  sys_stats_config_ = NULL;
  heapprofd_config_ = NULL;
  android_power_config_ = NULL;
  android_log_config_ = NULL;
  gpu_counter_config_ = NULL;
  packages_list_config_ = NULL;
  chrome_config_ = NULL;
  legacy_config_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  for_testing_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DataSourceConfig::~DataSourceConfig() {
  // @@protoc_insertion_point(destructor:perfetto.protos.DataSourceConfig)
  SharedDtor();
}

void DataSourceConfig::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  legacy_config_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete ftrace_config_;
    delete inode_file_config_;
    delete process_stats_config_;
    delete sys_stats_config_;
    delete heapprofd_config_;
    delete android_power_config_;
    delete android_log_config_;
    delete gpu_counter_config_;
    delete packages_list_config_;
    delete chrome_config_;
    delete for_testing_;
  }
}

void DataSourceConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DataSourceConfig& DataSourceConfig::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fconfig_2fdata_5fsource_5fconfig_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fconfig_2fdata_5fsource_5fconfig_2eproto();
#endif
  return *default_instance_;
}

DataSourceConfig* DataSourceConfig::default_instance_ = NULL;

DataSourceConfig* DataSourceConfig::New(::google::protobuf::Arena* arena) const {
  DataSourceConfig* n = new DataSourceConfig;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DataSourceConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.DataSourceConfig)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(DataSourceConfig, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<DataSourceConfig*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    ZR_(target_buffer_, tracing_session_id_);
    if (has_name()) {
      name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    enable_extra_guardrails_ = false;
    if (has_ftrace_config()) {
      if (ftrace_config_ != NULL) ftrace_config_->::perfetto::protos::FtraceConfig::Clear();
    }
    if (has_inode_file_config()) {
      if (inode_file_config_ != NULL) inode_file_config_->::perfetto::protos::InodeFileConfig::Clear();
    }
    if (has_process_stats_config()) {
      if (process_stats_config_ != NULL) process_stats_config_->::perfetto::protos::ProcessStatsConfig::Clear();
    }
  }
  if (_has_bits_[8 / 32] & 65280u) {
    if (has_sys_stats_config()) {
      if (sys_stats_config_ != NULL) sys_stats_config_->::perfetto::protos::SysStatsConfig::Clear();
    }
    if (has_heapprofd_config()) {
      if (heapprofd_config_ != NULL) heapprofd_config_->::perfetto::protos::HeapprofdConfig::Clear();
    }
    if (has_android_power_config()) {
      if (android_power_config_ != NULL) android_power_config_->::perfetto::protos::AndroidPowerConfig::Clear();
    }
    if (has_android_log_config()) {
      if (android_log_config_ != NULL) android_log_config_->::perfetto::protos::AndroidLogConfig::Clear();
    }
    if (has_gpu_counter_config()) {
      if (gpu_counter_config_ != NULL) gpu_counter_config_->::perfetto::protos::GpuCounterConfig::Clear();
    }
    if (has_packages_list_config()) {
      if (packages_list_config_ != NULL) packages_list_config_->::perfetto::protos::PackagesListConfig::Clear();
    }
    if (has_chrome_config()) {
      if (chrome_config_ != NULL) chrome_config_->::perfetto::protos::ChromeConfig::Clear();
    }
    if (has_legacy_config()) {
      legacy_config_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  if (has_for_testing()) {
    if (for_testing_ != NULL) for_testing_->::perfetto::protos::TestConfig::Clear();
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool DataSourceConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForDataSourceConfig, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.DataSourceConfig)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_target_buffer;
        break;
      }

      // optional uint32 target_buffer = 2;
      case 2: {
        if (tag == 16) {
         parse_target_buffer:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &target_buffer_)));
          set_has_target_buffer();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_trace_duration_ms;
        break;
      }

      // optional uint32 trace_duration_ms = 3;
      case 3: {
        if (tag == 24) {
         parse_trace_duration_ms:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &trace_duration_ms_)));
          set_has_trace_duration_ms();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_tracing_session_id;
        break;
      }

      // optional uint64 tracing_session_id = 4;
      case 4: {
        if (tag == 32) {
         parse_tracing_session_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &tracing_session_id_)));
          set_has_tracing_session_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_enable_extra_guardrails;
        break;
      }

      // optional bool enable_extra_guardrails = 6;
      case 6: {
        if (tag == 48) {
         parse_enable_extra_guardrails:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &enable_extra_guardrails_)));
          set_has_enable_extra_guardrails();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(802)) goto parse_ftrace_config;
        break;
      }

      // optional .perfetto.protos.FtraceConfig ftrace_config = 100 [lazy = true];
      case 100: {
        if (tag == 802) {
         parse_ftrace_config:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ftrace_config()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(810)) goto parse_chrome_config;
        break;
      }

      // optional .perfetto.protos.ChromeConfig chrome_config = 101;
      case 101: {
        if (tag == 810) {
         parse_chrome_config:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_chrome_config()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(818)) goto parse_inode_file_config;
        break;
      }

      // optional .perfetto.protos.InodeFileConfig inode_file_config = 102 [lazy = true];
      case 102: {
        if (tag == 818) {
         parse_inode_file_config:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_inode_file_config()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(826)) goto parse_process_stats_config;
        break;
      }

      // optional .perfetto.protos.ProcessStatsConfig process_stats_config = 103 [lazy = true];
      case 103: {
        if (tag == 826) {
         parse_process_stats_config:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_process_stats_config()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(834)) goto parse_sys_stats_config;
        break;
      }

      // optional .perfetto.protos.SysStatsConfig sys_stats_config = 104 [lazy = true];
      case 104: {
        if (tag == 834) {
         parse_sys_stats_config:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_sys_stats_config()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(842)) goto parse_heapprofd_config;
        break;
      }

      // optional .perfetto.protos.HeapprofdConfig heapprofd_config = 105 [lazy = true];
      case 105: {
        if (tag == 842) {
         parse_heapprofd_config:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_heapprofd_config()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(850)) goto parse_android_power_config;
        break;
      }

      // optional .perfetto.protos.AndroidPowerConfig android_power_config = 106 [lazy = true];
      case 106: {
        if (tag == 850) {
         parse_android_power_config:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_android_power_config()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(858)) goto parse_android_log_config;
        break;
      }

      // optional .perfetto.protos.AndroidLogConfig android_log_config = 107 [lazy = true];
      case 107: {
        if (tag == 858) {
         parse_android_log_config:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_android_log_config()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(866)) goto parse_gpu_counter_config;
        break;
      }

      // optional .perfetto.protos.GpuCounterConfig gpu_counter_config = 108 [lazy = true];
      case 108: {
        if (tag == 866) {
         parse_gpu_counter_config:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_gpu_counter_config()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(874)) goto parse_packages_list_config;
        break;
      }

      // optional .perfetto.protos.PackagesListConfig packages_list_config = 109 [lazy = true];
      case 109: {
        if (tag == 874) {
         parse_packages_list_config:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_packages_list_config()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(8002)) goto parse_legacy_config;
        break;
      }

      // optional string legacy_config = 1000;
      case 1000: {
        if (tag == 8002) {
         parse_legacy_config:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_legacy_config()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(8010)) goto parse_for_testing;
        break;
      }

      // optional .perfetto.protos.TestConfig for_testing = 1001;
      case 1001: {
        if (tag == 8010) {
         parse_for_testing:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_for_testing()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.DataSourceConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.DataSourceConfig)
  return false;
#undef DO_
}

void DataSourceConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.DataSourceConfig)
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional uint32 target_buffer = 2;
  if (has_target_buffer()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->target_buffer(), output);
  }

  // optional uint32 trace_duration_ms = 3;
  if (has_trace_duration_ms()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->trace_duration_ms(), output);
  }

  // optional uint64 tracing_session_id = 4;
  if (has_tracing_session_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->tracing_session_id(), output);
  }

  // optional bool enable_extra_guardrails = 6;
  if (has_enable_extra_guardrails()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->enable_extra_guardrails(), output);
  }

  // optional .perfetto.protos.FtraceConfig ftrace_config = 100 [lazy = true];
  if (has_ftrace_config()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      100, *this->ftrace_config_, output);
  }

  // optional .perfetto.protos.ChromeConfig chrome_config = 101;
  if (has_chrome_config()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      101, *this->chrome_config_, output);
  }

  // optional .perfetto.protos.InodeFileConfig inode_file_config = 102 [lazy = true];
  if (has_inode_file_config()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      102, *this->inode_file_config_, output);
  }

  // optional .perfetto.protos.ProcessStatsConfig process_stats_config = 103 [lazy = true];
  if (has_process_stats_config()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      103, *this->process_stats_config_, output);
  }

  // optional .perfetto.protos.SysStatsConfig sys_stats_config = 104 [lazy = true];
  if (has_sys_stats_config()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      104, *this->sys_stats_config_, output);
  }

  // optional .perfetto.protos.HeapprofdConfig heapprofd_config = 105 [lazy = true];
  if (has_heapprofd_config()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      105, *this->heapprofd_config_, output);
  }

  // optional .perfetto.protos.AndroidPowerConfig android_power_config = 106 [lazy = true];
  if (has_android_power_config()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      106, *this->android_power_config_, output);
  }

  // optional .perfetto.protos.AndroidLogConfig android_log_config = 107 [lazy = true];
  if (has_android_log_config()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      107, *this->android_log_config_, output);
  }

  // optional .perfetto.protos.GpuCounterConfig gpu_counter_config = 108 [lazy = true];
  if (has_gpu_counter_config()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      108, *this->gpu_counter_config_, output);
  }

  // optional .perfetto.protos.PackagesListConfig packages_list_config = 109 [lazy = true];
  if (has_packages_list_config()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      109, *this->packages_list_config_, output);
  }

  // optional string legacy_config = 1000;
  if (has_legacy_config()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1000, this->legacy_config(), output);
  }

  // optional .perfetto.protos.TestConfig for_testing = 1001;
  if (has_for_testing()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1001, *this->for_testing_, output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.DataSourceConfig)
}

int DataSourceConfig::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.DataSourceConfig)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 255u) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional uint32 target_buffer = 2;
    if (has_target_buffer()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->target_buffer());
    }

    // optional uint32 trace_duration_ms = 3;
    if (has_trace_duration_ms()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->trace_duration_ms());
    }

    // optional bool enable_extra_guardrails = 6;
    if (has_enable_extra_guardrails()) {
      total_size += 1 + 1;
    }

    // optional uint64 tracing_session_id = 4;
    if (has_tracing_session_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->tracing_session_id());
    }

    // optional .perfetto.protos.FtraceConfig ftrace_config = 100 [lazy = true];
    if (has_ftrace_config()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->ftrace_config_);
    }

    // optional .perfetto.protos.InodeFileConfig inode_file_config = 102 [lazy = true];
    if (has_inode_file_config()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->inode_file_config_);
    }

    // optional .perfetto.protos.ProcessStatsConfig process_stats_config = 103 [lazy = true];
    if (has_process_stats_config()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->process_stats_config_);
    }

  }
  if (_has_bits_[8 / 32] & 65280u) {
    // optional .perfetto.protos.SysStatsConfig sys_stats_config = 104 [lazy = true];
    if (has_sys_stats_config()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->sys_stats_config_);
    }

    // optional .perfetto.protos.HeapprofdConfig heapprofd_config = 105 [lazy = true];
    if (has_heapprofd_config()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->heapprofd_config_);
    }

    // optional .perfetto.protos.AndroidPowerConfig android_power_config = 106 [lazy = true];
    if (has_android_power_config()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->android_power_config_);
    }

    // optional .perfetto.protos.AndroidLogConfig android_log_config = 107 [lazy = true];
    if (has_android_log_config()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->android_log_config_);
    }

    // optional .perfetto.protos.GpuCounterConfig gpu_counter_config = 108 [lazy = true];
    if (has_gpu_counter_config()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->gpu_counter_config_);
    }

    // optional .perfetto.protos.PackagesListConfig packages_list_config = 109 [lazy = true];
    if (has_packages_list_config()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->packages_list_config_);
    }

    // optional .perfetto.protos.ChromeConfig chrome_config = 101;
    if (has_chrome_config()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->chrome_config_);
    }

    // optional string legacy_config = 1000;
    if (has_legacy_config()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->legacy_config());
    }

  }
  // optional .perfetto.protos.TestConfig for_testing = 1001;
  if (has_for_testing()) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->for_testing_);
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DataSourceConfig::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DataSourceConfig*>(&from));
}

void DataSourceConfig::MergeFrom(const DataSourceConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.DataSourceConfig)
  if (GOOGLE_PREDICT_FALSE(&from == this)) data_source_config_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (from.has_target_buffer()) {
      set_target_buffer(from.target_buffer());
    }
    if (from.has_trace_duration_ms()) {
      set_trace_duration_ms(from.trace_duration_ms());
    }
    if (from.has_enable_extra_guardrails()) {
      set_enable_extra_guardrails(from.enable_extra_guardrails());
    }
    if (from.has_tracing_session_id()) {
      set_tracing_session_id(from.tracing_session_id());
    }
    if (from.has_ftrace_config()) {
      mutable_ftrace_config()->::perfetto::protos::FtraceConfig::MergeFrom(from.ftrace_config());
    }
    if (from.has_inode_file_config()) {
      mutable_inode_file_config()->::perfetto::protos::InodeFileConfig::MergeFrom(from.inode_file_config());
    }
    if (from.has_process_stats_config()) {
      mutable_process_stats_config()->::perfetto::protos::ProcessStatsConfig::MergeFrom(from.process_stats_config());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_sys_stats_config()) {
      mutable_sys_stats_config()->::perfetto::protos::SysStatsConfig::MergeFrom(from.sys_stats_config());
    }
    if (from.has_heapprofd_config()) {
      mutable_heapprofd_config()->::perfetto::protos::HeapprofdConfig::MergeFrom(from.heapprofd_config());
    }
    if (from.has_android_power_config()) {
      mutable_android_power_config()->::perfetto::protos::AndroidPowerConfig::MergeFrom(from.android_power_config());
    }
    if (from.has_android_log_config()) {
      mutable_android_log_config()->::perfetto::protos::AndroidLogConfig::MergeFrom(from.android_log_config());
    }
    if (from.has_gpu_counter_config()) {
      mutable_gpu_counter_config()->::perfetto::protos::GpuCounterConfig::MergeFrom(from.gpu_counter_config());
    }
    if (from.has_packages_list_config()) {
      mutable_packages_list_config()->::perfetto::protos::PackagesListConfig::MergeFrom(from.packages_list_config());
    }
    if (from.has_chrome_config()) {
      mutable_chrome_config()->::perfetto::protos::ChromeConfig::MergeFrom(from.chrome_config());
    }
    if (from.has_legacy_config()) {
      set_has_legacy_config();
      legacy_config_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.legacy_config_);
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_for_testing()) {
      mutable_for_testing()->::perfetto::protos::TestConfig::MergeFrom(from.for_testing());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void DataSourceConfig::CopyFrom(const DataSourceConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.DataSourceConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DataSourceConfig::IsInitialized() const {

  return true;
}

void DataSourceConfig::Swap(DataSourceConfig* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DataSourceConfig::InternalSwap(DataSourceConfig* other) {
  name_.Swap(&other->name_);
  std::swap(target_buffer_, other->target_buffer_);
  std::swap(trace_duration_ms_, other->trace_duration_ms_);
  std::swap(enable_extra_guardrails_, other->enable_extra_guardrails_);
  std::swap(tracing_session_id_, other->tracing_session_id_);
  std::swap(ftrace_config_, other->ftrace_config_);
  std::swap(inode_file_config_, other->inode_file_config_);
  std::swap(process_stats_config_, other->process_stats_config_);
  std::swap(sys_stats_config_, other->sys_stats_config_);
  std::swap(heapprofd_config_, other->heapprofd_config_);
  std::swap(android_power_config_, other->android_power_config_);
  std::swap(android_log_config_, other->android_log_config_);
  std::swap(gpu_counter_config_, other->gpu_counter_config_);
  std::swap(packages_list_config_, other->packages_list_config_);
  std::swap(chrome_config_, other->chrome_config_);
  legacy_config_.Swap(&other->legacy_config_);
  std::swap(for_testing_, other->for_testing_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string DataSourceConfig::GetTypeName() const {
  return "perfetto.protos.DataSourceConfig";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DataSourceConfig

// optional string name = 1;
bool DataSourceConfig::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void DataSourceConfig::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
void DataSourceConfig::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void DataSourceConfig::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
 const ::std::string& DataSourceConfig::name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DataSourceConfig::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.DataSourceConfig.name)
}
 void DataSourceConfig::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.DataSourceConfig.name)
}
 void DataSourceConfig::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.DataSourceConfig.name)
}
 ::std::string* DataSourceConfig::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceConfig.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* DataSourceConfig::release_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceConfig.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DataSourceConfig::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceConfig.name)
}

// optional uint32 target_buffer = 2;
bool DataSourceConfig::has_target_buffer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void DataSourceConfig::set_has_target_buffer() {
  _has_bits_[0] |= 0x00000002u;
}
void DataSourceConfig::clear_has_target_buffer() {
  _has_bits_[0] &= ~0x00000002u;
}
void DataSourceConfig::clear_target_buffer() {
  target_buffer_ = 0u;
  clear_has_target_buffer();
}
 ::google::protobuf::uint32 DataSourceConfig::target_buffer() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.target_buffer)
  return target_buffer_;
}
 void DataSourceConfig::set_target_buffer(::google::protobuf::uint32 value) {
  set_has_target_buffer();
  target_buffer_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.DataSourceConfig.target_buffer)
}

// optional uint32 trace_duration_ms = 3;
bool DataSourceConfig::has_trace_duration_ms() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void DataSourceConfig::set_has_trace_duration_ms() {
  _has_bits_[0] |= 0x00000004u;
}
void DataSourceConfig::clear_has_trace_duration_ms() {
  _has_bits_[0] &= ~0x00000004u;
}
void DataSourceConfig::clear_trace_duration_ms() {
  trace_duration_ms_ = 0u;
  clear_has_trace_duration_ms();
}
 ::google::protobuf::uint32 DataSourceConfig::trace_duration_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.trace_duration_ms)
  return trace_duration_ms_;
}
 void DataSourceConfig::set_trace_duration_ms(::google::protobuf::uint32 value) {
  set_has_trace_duration_ms();
  trace_duration_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.DataSourceConfig.trace_duration_ms)
}

// optional bool enable_extra_guardrails = 6;
bool DataSourceConfig::has_enable_extra_guardrails() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void DataSourceConfig::set_has_enable_extra_guardrails() {
  _has_bits_[0] |= 0x00000008u;
}
void DataSourceConfig::clear_has_enable_extra_guardrails() {
  _has_bits_[0] &= ~0x00000008u;
}
void DataSourceConfig::clear_enable_extra_guardrails() {
  enable_extra_guardrails_ = false;
  clear_has_enable_extra_guardrails();
}
 bool DataSourceConfig::enable_extra_guardrails() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.enable_extra_guardrails)
  return enable_extra_guardrails_;
}
 void DataSourceConfig::set_enable_extra_guardrails(bool value) {
  set_has_enable_extra_guardrails();
  enable_extra_guardrails_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.DataSourceConfig.enable_extra_guardrails)
}

// optional uint64 tracing_session_id = 4;
bool DataSourceConfig::has_tracing_session_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void DataSourceConfig::set_has_tracing_session_id() {
  _has_bits_[0] |= 0x00000010u;
}
void DataSourceConfig::clear_has_tracing_session_id() {
  _has_bits_[0] &= ~0x00000010u;
}
void DataSourceConfig::clear_tracing_session_id() {
  tracing_session_id_ = GOOGLE_ULONGLONG(0);
  clear_has_tracing_session_id();
}
 ::google::protobuf::uint64 DataSourceConfig::tracing_session_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.tracing_session_id)
  return tracing_session_id_;
}
 void DataSourceConfig::set_tracing_session_id(::google::protobuf::uint64 value) {
  set_has_tracing_session_id();
  tracing_session_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.DataSourceConfig.tracing_session_id)
}

// optional .perfetto.protos.FtraceConfig ftrace_config = 100 [lazy = true];
bool DataSourceConfig::has_ftrace_config() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void DataSourceConfig::set_has_ftrace_config() {
  _has_bits_[0] |= 0x00000020u;
}
void DataSourceConfig::clear_has_ftrace_config() {
  _has_bits_[0] &= ~0x00000020u;
}
void DataSourceConfig::clear_ftrace_config() {
  if (ftrace_config_ != NULL) ftrace_config_->::perfetto::protos::FtraceConfig::Clear();
  clear_has_ftrace_config();
}
const ::perfetto::protos::FtraceConfig& DataSourceConfig::ftrace_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.ftrace_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return ftrace_config_ != NULL ? *ftrace_config_ : *default_instance().ftrace_config_;
#else
  return ftrace_config_ != NULL ? *ftrace_config_ : *default_instance_->ftrace_config_;
#endif
}
::perfetto::protos::FtraceConfig* DataSourceConfig::mutable_ftrace_config() {
  set_has_ftrace_config();
  if (ftrace_config_ == NULL) {
    ftrace_config_ = new ::perfetto::protos::FtraceConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceConfig.ftrace_config)
  return ftrace_config_;
}
::perfetto::protos::FtraceConfig* DataSourceConfig::release_ftrace_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceConfig.ftrace_config)
  clear_has_ftrace_config();
  ::perfetto::protos::FtraceConfig* temp = ftrace_config_;
  ftrace_config_ = NULL;
  return temp;
}
void DataSourceConfig::set_allocated_ftrace_config(::perfetto::protos::FtraceConfig* ftrace_config) {
  delete ftrace_config_;
  ftrace_config_ = ftrace_config;
  if (ftrace_config) {
    set_has_ftrace_config();
  } else {
    clear_has_ftrace_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceConfig.ftrace_config)
}

// optional .perfetto.protos.InodeFileConfig inode_file_config = 102 [lazy = true];
bool DataSourceConfig::has_inode_file_config() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void DataSourceConfig::set_has_inode_file_config() {
  _has_bits_[0] |= 0x00000040u;
}
void DataSourceConfig::clear_has_inode_file_config() {
  _has_bits_[0] &= ~0x00000040u;
}
void DataSourceConfig::clear_inode_file_config() {
  if (inode_file_config_ != NULL) inode_file_config_->::perfetto::protos::InodeFileConfig::Clear();
  clear_has_inode_file_config();
}
const ::perfetto::protos::InodeFileConfig& DataSourceConfig::inode_file_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.inode_file_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return inode_file_config_ != NULL ? *inode_file_config_ : *default_instance().inode_file_config_;
#else
  return inode_file_config_ != NULL ? *inode_file_config_ : *default_instance_->inode_file_config_;
#endif
}
::perfetto::protos::InodeFileConfig* DataSourceConfig::mutable_inode_file_config() {
  set_has_inode_file_config();
  if (inode_file_config_ == NULL) {
    inode_file_config_ = new ::perfetto::protos::InodeFileConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceConfig.inode_file_config)
  return inode_file_config_;
}
::perfetto::protos::InodeFileConfig* DataSourceConfig::release_inode_file_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceConfig.inode_file_config)
  clear_has_inode_file_config();
  ::perfetto::protos::InodeFileConfig* temp = inode_file_config_;
  inode_file_config_ = NULL;
  return temp;
}
void DataSourceConfig::set_allocated_inode_file_config(::perfetto::protos::InodeFileConfig* inode_file_config) {
  delete inode_file_config_;
  inode_file_config_ = inode_file_config;
  if (inode_file_config) {
    set_has_inode_file_config();
  } else {
    clear_has_inode_file_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceConfig.inode_file_config)
}

// optional .perfetto.protos.ProcessStatsConfig process_stats_config = 103 [lazy = true];
bool DataSourceConfig::has_process_stats_config() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void DataSourceConfig::set_has_process_stats_config() {
  _has_bits_[0] |= 0x00000080u;
}
void DataSourceConfig::clear_has_process_stats_config() {
  _has_bits_[0] &= ~0x00000080u;
}
void DataSourceConfig::clear_process_stats_config() {
  if (process_stats_config_ != NULL) process_stats_config_->::perfetto::protos::ProcessStatsConfig::Clear();
  clear_has_process_stats_config();
}
const ::perfetto::protos::ProcessStatsConfig& DataSourceConfig::process_stats_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.process_stats_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return process_stats_config_ != NULL ? *process_stats_config_ : *default_instance().process_stats_config_;
#else
  return process_stats_config_ != NULL ? *process_stats_config_ : *default_instance_->process_stats_config_;
#endif
}
::perfetto::protos::ProcessStatsConfig* DataSourceConfig::mutable_process_stats_config() {
  set_has_process_stats_config();
  if (process_stats_config_ == NULL) {
    process_stats_config_ = new ::perfetto::protos::ProcessStatsConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceConfig.process_stats_config)
  return process_stats_config_;
}
::perfetto::protos::ProcessStatsConfig* DataSourceConfig::release_process_stats_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceConfig.process_stats_config)
  clear_has_process_stats_config();
  ::perfetto::protos::ProcessStatsConfig* temp = process_stats_config_;
  process_stats_config_ = NULL;
  return temp;
}
void DataSourceConfig::set_allocated_process_stats_config(::perfetto::protos::ProcessStatsConfig* process_stats_config) {
  delete process_stats_config_;
  process_stats_config_ = process_stats_config;
  if (process_stats_config) {
    set_has_process_stats_config();
  } else {
    clear_has_process_stats_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceConfig.process_stats_config)
}

// optional .perfetto.protos.SysStatsConfig sys_stats_config = 104 [lazy = true];
bool DataSourceConfig::has_sys_stats_config() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void DataSourceConfig::set_has_sys_stats_config() {
  _has_bits_[0] |= 0x00000100u;
}
void DataSourceConfig::clear_has_sys_stats_config() {
  _has_bits_[0] &= ~0x00000100u;
}
void DataSourceConfig::clear_sys_stats_config() {
  if (sys_stats_config_ != NULL) sys_stats_config_->::perfetto::protos::SysStatsConfig::Clear();
  clear_has_sys_stats_config();
}
const ::perfetto::protos::SysStatsConfig& DataSourceConfig::sys_stats_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.sys_stats_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return sys_stats_config_ != NULL ? *sys_stats_config_ : *default_instance().sys_stats_config_;
#else
  return sys_stats_config_ != NULL ? *sys_stats_config_ : *default_instance_->sys_stats_config_;
#endif
}
::perfetto::protos::SysStatsConfig* DataSourceConfig::mutable_sys_stats_config() {
  set_has_sys_stats_config();
  if (sys_stats_config_ == NULL) {
    sys_stats_config_ = new ::perfetto::protos::SysStatsConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceConfig.sys_stats_config)
  return sys_stats_config_;
}
::perfetto::protos::SysStatsConfig* DataSourceConfig::release_sys_stats_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceConfig.sys_stats_config)
  clear_has_sys_stats_config();
  ::perfetto::protos::SysStatsConfig* temp = sys_stats_config_;
  sys_stats_config_ = NULL;
  return temp;
}
void DataSourceConfig::set_allocated_sys_stats_config(::perfetto::protos::SysStatsConfig* sys_stats_config) {
  delete sys_stats_config_;
  sys_stats_config_ = sys_stats_config;
  if (sys_stats_config) {
    set_has_sys_stats_config();
  } else {
    clear_has_sys_stats_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceConfig.sys_stats_config)
}

// optional .perfetto.protos.HeapprofdConfig heapprofd_config = 105 [lazy = true];
bool DataSourceConfig::has_heapprofd_config() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void DataSourceConfig::set_has_heapprofd_config() {
  _has_bits_[0] |= 0x00000200u;
}
void DataSourceConfig::clear_has_heapprofd_config() {
  _has_bits_[0] &= ~0x00000200u;
}
void DataSourceConfig::clear_heapprofd_config() {
  if (heapprofd_config_ != NULL) heapprofd_config_->::perfetto::protos::HeapprofdConfig::Clear();
  clear_has_heapprofd_config();
}
const ::perfetto::protos::HeapprofdConfig& DataSourceConfig::heapprofd_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.heapprofd_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return heapprofd_config_ != NULL ? *heapprofd_config_ : *default_instance().heapprofd_config_;
#else
  return heapprofd_config_ != NULL ? *heapprofd_config_ : *default_instance_->heapprofd_config_;
#endif
}
::perfetto::protos::HeapprofdConfig* DataSourceConfig::mutable_heapprofd_config() {
  set_has_heapprofd_config();
  if (heapprofd_config_ == NULL) {
    heapprofd_config_ = new ::perfetto::protos::HeapprofdConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceConfig.heapprofd_config)
  return heapprofd_config_;
}
::perfetto::protos::HeapprofdConfig* DataSourceConfig::release_heapprofd_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceConfig.heapprofd_config)
  clear_has_heapprofd_config();
  ::perfetto::protos::HeapprofdConfig* temp = heapprofd_config_;
  heapprofd_config_ = NULL;
  return temp;
}
void DataSourceConfig::set_allocated_heapprofd_config(::perfetto::protos::HeapprofdConfig* heapprofd_config) {
  delete heapprofd_config_;
  heapprofd_config_ = heapprofd_config;
  if (heapprofd_config) {
    set_has_heapprofd_config();
  } else {
    clear_has_heapprofd_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceConfig.heapprofd_config)
}

// optional .perfetto.protos.AndroidPowerConfig android_power_config = 106 [lazy = true];
bool DataSourceConfig::has_android_power_config() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
void DataSourceConfig::set_has_android_power_config() {
  _has_bits_[0] |= 0x00000400u;
}
void DataSourceConfig::clear_has_android_power_config() {
  _has_bits_[0] &= ~0x00000400u;
}
void DataSourceConfig::clear_android_power_config() {
  if (android_power_config_ != NULL) android_power_config_->::perfetto::protos::AndroidPowerConfig::Clear();
  clear_has_android_power_config();
}
const ::perfetto::protos::AndroidPowerConfig& DataSourceConfig::android_power_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.android_power_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return android_power_config_ != NULL ? *android_power_config_ : *default_instance().android_power_config_;
#else
  return android_power_config_ != NULL ? *android_power_config_ : *default_instance_->android_power_config_;
#endif
}
::perfetto::protos::AndroidPowerConfig* DataSourceConfig::mutable_android_power_config() {
  set_has_android_power_config();
  if (android_power_config_ == NULL) {
    android_power_config_ = new ::perfetto::protos::AndroidPowerConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceConfig.android_power_config)
  return android_power_config_;
}
::perfetto::protos::AndroidPowerConfig* DataSourceConfig::release_android_power_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceConfig.android_power_config)
  clear_has_android_power_config();
  ::perfetto::protos::AndroidPowerConfig* temp = android_power_config_;
  android_power_config_ = NULL;
  return temp;
}
void DataSourceConfig::set_allocated_android_power_config(::perfetto::protos::AndroidPowerConfig* android_power_config) {
  delete android_power_config_;
  android_power_config_ = android_power_config;
  if (android_power_config) {
    set_has_android_power_config();
  } else {
    clear_has_android_power_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceConfig.android_power_config)
}

// optional .perfetto.protos.AndroidLogConfig android_log_config = 107 [lazy = true];
bool DataSourceConfig::has_android_log_config() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
void DataSourceConfig::set_has_android_log_config() {
  _has_bits_[0] |= 0x00000800u;
}
void DataSourceConfig::clear_has_android_log_config() {
  _has_bits_[0] &= ~0x00000800u;
}
void DataSourceConfig::clear_android_log_config() {
  if (android_log_config_ != NULL) android_log_config_->::perfetto::protos::AndroidLogConfig::Clear();
  clear_has_android_log_config();
}
const ::perfetto::protos::AndroidLogConfig& DataSourceConfig::android_log_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.android_log_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return android_log_config_ != NULL ? *android_log_config_ : *default_instance().android_log_config_;
#else
  return android_log_config_ != NULL ? *android_log_config_ : *default_instance_->android_log_config_;
#endif
}
::perfetto::protos::AndroidLogConfig* DataSourceConfig::mutable_android_log_config() {
  set_has_android_log_config();
  if (android_log_config_ == NULL) {
    android_log_config_ = new ::perfetto::protos::AndroidLogConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceConfig.android_log_config)
  return android_log_config_;
}
::perfetto::protos::AndroidLogConfig* DataSourceConfig::release_android_log_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceConfig.android_log_config)
  clear_has_android_log_config();
  ::perfetto::protos::AndroidLogConfig* temp = android_log_config_;
  android_log_config_ = NULL;
  return temp;
}
void DataSourceConfig::set_allocated_android_log_config(::perfetto::protos::AndroidLogConfig* android_log_config) {
  delete android_log_config_;
  android_log_config_ = android_log_config;
  if (android_log_config) {
    set_has_android_log_config();
  } else {
    clear_has_android_log_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceConfig.android_log_config)
}

// optional .perfetto.protos.GpuCounterConfig gpu_counter_config = 108 [lazy = true];
bool DataSourceConfig::has_gpu_counter_config() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
void DataSourceConfig::set_has_gpu_counter_config() {
  _has_bits_[0] |= 0x00001000u;
}
void DataSourceConfig::clear_has_gpu_counter_config() {
  _has_bits_[0] &= ~0x00001000u;
}
void DataSourceConfig::clear_gpu_counter_config() {
  if (gpu_counter_config_ != NULL) gpu_counter_config_->::perfetto::protos::GpuCounterConfig::Clear();
  clear_has_gpu_counter_config();
}
const ::perfetto::protos::GpuCounterConfig& DataSourceConfig::gpu_counter_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.gpu_counter_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return gpu_counter_config_ != NULL ? *gpu_counter_config_ : *default_instance().gpu_counter_config_;
#else
  return gpu_counter_config_ != NULL ? *gpu_counter_config_ : *default_instance_->gpu_counter_config_;
#endif
}
::perfetto::protos::GpuCounterConfig* DataSourceConfig::mutable_gpu_counter_config() {
  set_has_gpu_counter_config();
  if (gpu_counter_config_ == NULL) {
    gpu_counter_config_ = new ::perfetto::protos::GpuCounterConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceConfig.gpu_counter_config)
  return gpu_counter_config_;
}
::perfetto::protos::GpuCounterConfig* DataSourceConfig::release_gpu_counter_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceConfig.gpu_counter_config)
  clear_has_gpu_counter_config();
  ::perfetto::protos::GpuCounterConfig* temp = gpu_counter_config_;
  gpu_counter_config_ = NULL;
  return temp;
}
void DataSourceConfig::set_allocated_gpu_counter_config(::perfetto::protos::GpuCounterConfig* gpu_counter_config) {
  delete gpu_counter_config_;
  gpu_counter_config_ = gpu_counter_config;
  if (gpu_counter_config) {
    set_has_gpu_counter_config();
  } else {
    clear_has_gpu_counter_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceConfig.gpu_counter_config)
}

// optional .perfetto.protos.PackagesListConfig packages_list_config = 109 [lazy = true];
bool DataSourceConfig::has_packages_list_config() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
void DataSourceConfig::set_has_packages_list_config() {
  _has_bits_[0] |= 0x00002000u;
}
void DataSourceConfig::clear_has_packages_list_config() {
  _has_bits_[0] &= ~0x00002000u;
}
void DataSourceConfig::clear_packages_list_config() {
  if (packages_list_config_ != NULL) packages_list_config_->::perfetto::protos::PackagesListConfig::Clear();
  clear_has_packages_list_config();
}
const ::perfetto::protos::PackagesListConfig& DataSourceConfig::packages_list_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.packages_list_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return packages_list_config_ != NULL ? *packages_list_config_ : *default_instance().packages_list_config_;
#else
  return packages_list_config_ != NULL ? *packages_list_config_ : *default_instance_->packages_list_config_;
#endif
}
::perfetto::protos::PackagesListConfig* DataSourceConfig::mutable_packages_list_config() {
  set_has_packages_list_config();
  if (packages_list_config_ == NULL) {
    packages_list_config_ = new ::perfetto::protos::PackagesListConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceConfig.packages_list_config)
  return packages_list_config_;
}
::perfetto::protos::PackagesListConfig* DataSourceConfig::release_packages_list_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceConfig.packages_list_config)
  clear_has_packages_list_config();
  ::perfetto::protos::PackagesListConfig* temp = packages_list_config_;
  packages_list_config_ = NULL;
  return temp;
}
void DataSourceConfig::set_allocated_packages_list_config(::perfetto::protos::PackagesListConfig* packages_list_config) {
  delete packages_list_config_;
  packages_list_config_ = packages_list_config;
  if (packages_list_config) {
    set_has_packages_list_config();
  } else {
    clear_has_packages_list_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceConfig.packages_list_config)
}

// optional .perfetto.protos.ChromeConfig chrome_config = 101;
bool DataSourceConfig::has_chrome_config() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
void DataSourceConfig::set_has_chrome_config() {
  _has_bits_[0] |= 0x00004000u;
}
void DataSourceConfig::clear_has_chrome_config() {
  _has_bits_[0] &= ~0x00004000u;
}
void DataSourceConfig::clear_chrome_config() {
  if (chrome_config_ != NULL) chrome_config_->::perfetto::protos::ChromeConfig::Clear();
  clear_has_chrome_config();
}
const ::perfetto::protos::ChromeConfig& DataSourceConfig::chrome_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.chrome_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return chrome_config_ != NULL ? *chrome_config_ : *default_instance().chrome_config_;
#else
  return chrome_config_ != NULL ? *chrome_config_ : *default_instance_->chrome_config_;
#endif
}
::perfetto::protos::ChromeConfig* DataSourceConfig::mutable_chrome_config() {
  set_has_chrome_config();
  if (chrome_config_ == NULL) {
    chrome_config_ = new ::perfetto::protos::ChromeConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceConfig.chrome_config)
  return chrome_config_;
}
::perfetto::protos::ChromeConfig* DataSourceConfig::release_chrome_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceConfig.chrome_config)
  clear_has_chrome_config();
  ::perfetto::protos::ChromeConfig* temp = chrome_config_;
  chrome_config_ = NULL;
  return temp;
}
void DataSourceConfig::set_allocated_chrome_config(::perfetto::protos::ChromeConfig* chrome_config) {
  delete chrome_config_;
  chrome_config_ = chrome_config;
  if (chrome_config) {
    set_has_chrome_config();
  } else {
    clear_has_chrome_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceConfig.chrome_config)
}

// optional string legacy_config = 1000;
bool DataSourceConfig::has_legacy_config() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
void DataSourceConfig::set_has_legacy_config() {
  _has_bits_[0] |= 0x00008000u;
}
void DataSourceConfig::clear_has_legacy_config() {
  _has_bits_[0] &= ~0x00008000u;
}
void DataSourceConfig::clear_legacy_config() {
  legacy_config_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_legacy_config();
}
 const ::std::string& DataSourceConfig::legacy_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.legacy_config)
  return legacy_config_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DataSourceConfig::set_legacy_config(const ::std::string& value) {
  set_has_legacy_config();
  legacy_config_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.DataSourceConfig.legacy_config)
}
 void DataSourceConfig::set_legacy_config(const char* value) {
  set_has_legacy_config();
  legacy_config_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.DataSourceConfig.legacy_config)
}
 void DataSourceConfig::set_legacy_config(const char* value, size_t size) {
  set_has_legacy_config();
  legacy_config_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.DataSourceConfig.legacy_config)
}
 ::std::string* DataSourceConfig::mutable_legacy_config() {
  set_has_legacy_config();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceConfig.legacy_config)
  return legacy_config_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* DataSourceConfig::release_legacy_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceConfig.legacy_config)
  clear_has_legacy_config();
  return legacy_config_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DataSourceConfig::set_allocated_legacy_config(::std::string* legacy_config) {
  if (legacy_config != NULL) {
    set_has_legacy_config();
  } else {
    clear_has_legacy_config();
  }
  legacy_config_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), legacy_config);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceConfig.legacy_config)
}

// optional .perfetto.protos.TestConfig for_testing = 1001;
bool DataSourceConfig::has_for_testing() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
void DataSourceConfig::set_has_for_testing() {
  _has_bits_[0] |= 0x00010000u;
}
void DataSourceConfig::clear_has_for_testing() {
  _has_bits_[0] &= ~0x00010000u;
}
void DataSourceConfig::clear_for_testing() {
  if (for_testing_ != NULL) for_testing_->::perfetto::protos::TestConfig::Clear();
  clear_has_for_testing();
}
const ::perfetto::protos::TestConfig& DataSourceConfig::for_testing() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DataSourceConfig.for_testing)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return for_testing_ != NULL ? *for_testing_ : *default_instance().for_testing_;
#else
  return for_testing_ != NULL ? *for_testing_ : *default_instance_->for_testing_;
#endif
}
::perfetto::protos::TestConfig* DataSourceConfig::mutable_for_testing() {
  set_has_for_testing();
  if (for_testing_ == NULL) {
    for_testing_ = new ::perfetto::protos::TestConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DataSourceConfig.for_testing)
  return for_testing_;
}
::perfetto::protos::TestConfig* DataSourceConfig::release_for_testing() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DataSourceConfig.for_testing)
  clear_has_for_testing();
  ::perfetto::protos::TestConfig* temp = for_testing_;
  for_testing_ = NULL;
  return temp;
}
void DataSourceConfig::set_allocated_for_testing(::perfetto::protos::TestConfig* for_testing) {
  delete for_testing_;
  for_testing_ = for_testing;
  if (for_testing) {
    set_has_for_testing();
  } else {
    clear_has_for_testing();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DataSourceConfig.for_testing)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/config/ftrace/ftrace_config.pb.cc
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/config/ftrace/ftrace_config.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
// gen_amalgamated expanded: #include "perfetto/config/ftrace/ftrace_config.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

void protobuf_ShutdownFile_perfetto_2fconfig_2fftrace_2fftrace_5fconfig_2eproto() {
  delete FtraceConfig::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_perfetto_2fconfig_2fftrace_2fftrace_5fconfig_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_perfetto_2fconfig_2fftrace_2fftrace_5fconfig_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  FtraceConfig::default_instance_ = new FtraceConfig();
  FtraceConfig::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_perfetto_2fconfig_2fftrace_2fftrace_5fconfig_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_perfetto_2fconfig_2fftrace_2fftrace_5fconfig_2eproto_once_);
void protobuf_AddDesc_perfetto_2fconfig_2fftrace_2fftrace_5fconfig_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_perfetto_2fconfig_2fftrace_2fftrace_5fconfig_2eproto_once_,
                 &protobuf_AddDesc_perfetto_2fconfig_2fftrace_2fftrace_5fconfig_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_perfetto_2fconfig_2fftrace_2fftrace_5fconfig_2eproto {
  StaticDescriptorInitializer_perfetto_2fconfig_2fftrace_2fftrace_5fconfig_2eproto() {
    protobuf_AddDesc_perfetto_2fconfig_2fftrace_2fftrace_5fconfig_2eproto();
  }
} static_descriptor_initializer_perfetto_2fconfig_2fftrace_2fftrace_5fconfig_2eproto_;
#endif

namespace {

static void ftrace_config_pb_MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
static void ftrace_config_pb_MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

static ::std::string* MutableUnknownFieldsForFtraceConfig(
    FtraceConfig* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FtraceConfig::kFtraceEventsFieldNumber;
const int FtraceConfig::kAtraceCategoriesFieldNumber;
const int FtraceConfig::kAtraceAppsFieldNumber;
const int FtraceConfig::kBufferSizeKbFieldNumber;
const int FtraceConfig::kDrainPeriodMsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

FtraceConfig::FtraceConfig()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.FtraceConfig)
}

void FtraceConfig::InitAsDefaultInstance() {
}

FtraceConfig::FtraceConfig(const FtraceConfig& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.FtraceConfig)
}

void FtraceConfig::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  buffer_size_kb_ = 0u;
  drain_period_ms_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FtraceConfig::~FtraceConfig() {
  // @@protoc_insertion_point(destructor:perfetto.protos.FtraceConfig)
  SharedDtor();
}

void FtraceConfig::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void FtraceConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FtraceConfig& FtraceConfig::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fconfig_2fftrace_2fftrace_5fconfig_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fconfig_2fftrace_2fftrace_5fconfig_2eproto();
#endif
  return *default_instance_;
}

FtraceConfig* FtraceConfig::default_instance_ = NULL;

FtraceConfig* FtraceConfig::New(::google::protobuf::Arena* arena) const {
  FtraceConfig* n = new FtraceConfig;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void FtraceConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.FtraceConfig)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(FtraceConfig, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<FtraceConfig*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(buffer_size_kb_, drain_period_ms_);

#undef ZR_HELPER_
#undef ZR_

  ftrace_events_.Clear();
  atrace_categories_.Clear();
  atrace_apps_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool FtraceConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForFtraceConfig, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.FtraceConfig)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated string ftrace_events = 1;
      case 1: {
        if (tag == 10) {
         parse_ftrace_events:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_ftrace_events()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_ftrace_events;
        if (input->ExpectTag(18)) goto parse_atrace_categories;
        break;
      }

      // repeated string atrace_categories = 2;
      case 2: {
        if (tag == 18) {
         parse_atrace_categories:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_atrace_categories()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_atrace_categories;
        if (input->ExpectTag(26)) goto parse_atrace_apps;
        break;
      }

      // repeated string atrace_apps = 3;
      case 3: {
        if (tag == 26) {
         parse_atrace_apps:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_atrace_apps()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_atrace_apps;
        if (input->ExpectTag(80)) goto parse_buffer_size_kb;
        break;
      }

      // optional uint32 buffer_size_kb = 10;
      case 10: {
        if (tag == 80) {
         parse_buffer_size_kb:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &buffer_size_kb_)));
          set_has_buffer_size_kb();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_drain_period_ms;
        break;
      }

      // optional uint32 drain_period_ms = 11;
      case 11: {
        if (tag == 88) {
         parse_drain_period_ms:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &drain_period_ms_)));
          set_has_drain_period_ms();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.FtraceConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.FtraceConfig)
  return false;
#undef DO_
}

void FtraceConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.FtraceConfig)
  // repeated string ftrace_events = 1;
  for (int i = 0; i < this->ftrace_events_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->ftrace_events(i), output);
  }

  // repeated string atrace_categories = 2;
  for (int i = 0; i < this->atrace_categories_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->atrace_categories(i), output);
  }

  // repeated string atrace_apps = 3;
  for (int i = 0; i < this->atrace_apps_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->atrace_apps(i), output);
  }

  // optional uint32 buffer_size_kb = 10;
  if (has_buffer_size_kb()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->buffer_size_kb(), output);
  }

  // optional uint32 drain_period_ms = 11;
  if (has_drain_period_ms()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(11, this->drain_period_ms(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.FtraceConfig)
}

int FtraceConfig::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.FtraceConfig)
  int total_size = 0;

  if (_has_bits_[3 / 32] & 24u) {
    // optional uint32 buffer_size_kb = 10;
    if (has_buffer_size_kb()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->buffer_size_kb());
    }

    // optional uint32 drain_period_ms = 11;
    if (has_drain_period_ms()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->drain_period_ms());
    }

  }
  // repeated string ftrace_events = 1;
  total_size += 1 * this->ftrace_events_size();
  for (int i = 0; i < this->ftrace_events_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->ftrace_events(i));
  }

  // repeated string atrace_categories = 2;
  total_size += 1 * this->atrace_categories_size();
  for (int i = 0; i < this->atrace_categories_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->atrace_categories(i));
  }

  // repeated string atrace_apps = 3;
  total_size += 1 * this->atrace_apps_size();
  for (int i = 0; i < this->atrace_apps_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->atrace_apps(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FtraceConfig::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FtraceConfig*>(&from));
}

void FtraceConfig::MergeFrom(const FtraceConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.FtraceConfig)
  if (GOOGLE_PREDICT_FALSE(&from == this)) ftrace_config_pb_MergeFromFail(__LINE__);
  ftrace_events_.MergeFrom(from.ftrace_events_);
  atrace_categories_.MergeFrom(from.atrace_categories_);
  atrace_apps_.MergeFrom(from.atrace_apps_);
  if (from._has_bits_[3 / 32] & (0xffu << (3 % 32))) {
    if (from.has_buffer_size_kb()) {
      set_buffer_size_kb(from.buffer_size_kb());
    }
    if (from.has_drain_period_ms()) {
      set_drain_period_ms(from.drain_period_ms());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void FtraceConfig::CopyFrom(const FtraceConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.FtraceConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FtraceConfig::IsInitialized() const {

  return true;
}

void FtraceConfig::Swap(FtraceConfig* other) {
  if (other == this) return;
  InternalSwap(other);
}
void FtraceConfig::InternalSwap(FtraceConfig* other) {
  ftrace_events_.UnsafeArenaSwap(&other->ftrace_events_);
  atrace_categories_.UnsafeArenaSwap(&other->atrace_categories_);
  atrace_apps_.UnsafeArenaSwap(&other->atrace_apps_);
  std::swap(buffer_size_kb_, other->buffer_size_kb_);
  std::swap(drain_period_ms_, other->drain_period_ms_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string FtraceConfig::GetTypeName() const {
  return "perfetto.protos.FtraceConfig";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// FtraceConfig

// repeated string ftrace_events = 1;
int FtraceConfig::ftrace_events_size() const {
  return ftrace_events_.size();
}
void FtraceConfig::clear_ftrace_events() {
  ftrace_events_.Clear();
}
 const ::std::string& FtraceConfig::ftrace_events(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FtraceConfig.ftrace_events)
  return ftrace_events_.Get(index);
}
 ::std::string* FtraceConfig::mutable_ftrace_events(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.FtraceConfig.ftrace_events)
  return ftrace_events_.Mutable(index);
}
 void FtraceConfig::set_ftrace_events(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.FtraceConfig.ftrace_events)
  ftrace_events_.Mutable(index)->assign(value);
}
 void FtraceConfig::set_ftrace_events(int index, const char* value) {
  ftrace_events_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.FtraceConfig.ftrace_events)
}
 void FtraceConfig::set_ftrace_events(int index, const char* value, size_t size) {
  ftrace_events_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.FtraceConfig.ftrace_events)
}
 ::std::string* FtraceConfig::add_ftrace_events() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.FtraceConfig.ftrace_events)
  return ftrace_events_.Add();
}
 void FtraceConfig::add_ftrace_events(const ::std::string& value) {
  ftrace_events_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.FtraceConfig.ftrace_events)
}
 void FtraceConfig::add_ftrace_events(const char* value) {
  ftrace_events_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.FtraceConfig.ftrace_events)
}
 void FtraceConfig::add_ftrace_events(const char* value, size_t size) {
  ftrace_events_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.FtraceConfig.ftrace_events)
}
 const ::google::protobuf::RepeatedPtrField< ::std::string>&
FtraceConfig::ftrace_events() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.FtraceConfig.ftrace_events)
  return ftrace_events_;
}
 ::google::protobuf::RepeatedPtrField< ::std::string>*
FtraceConfig::mutable_ftrace_events() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.FtraceConfig.ftrace_events)
  return &ftrace_events_;
}

// repeated string atrace_categories = 2;
int FtraceConfig::atrace_categories_size() const {
  return atrace_categories_.size();
}
void FtraceConfig::clear_atrace_categories() {
  atrace_categories_.Clear();
}
 const ::std::string& FtraceConfig::atrace_categories(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FtraceConfig.atrace_categories)
  return atrace_categories_.Get(index);
}
 ::std::string* FtraceConfig::mutable_atrace_categories(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.FtraceConfig.atrace_categories)
  return atrace_categories_.Mutable(index);
}
 void FtraceConfig::set_atrace_categories(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.FtraceConfig.atrace_categories)
  atrace_categories_.Mutable(index)->assign(value);
}
 void FtraceConfig::set_atrace_categories(int index, const char* value) {
  atrace_categories_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.FtraceConfig.atrace_categories)
}
 void FtraceConfig::set_atrace_categories(int index, const char* value, size_t size) {
  atrace_categories_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.FtraceConfig.atrace_categories)
}
 ::std::string* FtraceConfig::add_atrace_categories() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.FtraceConfig.atrace_categories)
  return atrace_categories_.Add();
}
 void FtraceConfig::add_atrace_categories(const ::std::string& value) {
  atrace_categories_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.FtraceConfig.atrace_categories)
}
 void FtraceConfig::add_atrace_categories(const char* value) {
  atrace_categories_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.FtraceConfig.atrace_categories)
}
 void FtraceConfig::add_atrace_categories(const char* value, size_t size) {
  atrace_categories_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.FtraceConfig.atrace_categories)
}
 const ::google::protobuf::RepeatedPtrField< ::std::string>&
FtraceConfig::atrace_categories() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.FtraceConfig.atrace_categories)
  return atrace_categories_;
}
 ::google::protobuf::RepeatedPtrField< ::std::string>*
FtraceConfig::mutable_atrace_categories() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.FtraceConfig.atrace_categories)
  return &atrace_categories_;
}

// repeated string atrace_apps = 3;
int FtraceConfig::atrace_apps_size() const {
  return atrace_apps_.size();
}
void FtraceConfig::clear_atrace_apps() {
  atrace_apps_.Clear();
}
 const ::std::string& FtraceConfig::atrace_apps(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FtraceConfig.atrace_apps)
  return atrace_apps_.Get(index);
}
 ::std::string* FtraceConfig::mutable_atrace_apps(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.FtraceConfig.atrace_apps)
  return atrace_apps_.Mutable(index);
}
 void FtraceConfig::set_atrace_apps(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.FtraceConfig.atrace_apps)
  atrace_apps_.Mutable(index)->assign(value);
}
 void FtraceConfig::set_atrace_apps(int index, const char* value) {
  atrace_apps_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.FtraceConfig.atrace_apps)
}
 void FtraceConfig::set_atrace_apps(int index, const char* value, size_t size) {
  atrace_apps_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.FtraceConfig.atrace_apps)
}
 ::std::string* FtraceConfig::add_atrace_apps() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.FtraceConfig.atrace_apps)
  return atrace_apps_.Add();
}
 void FtraceConfig::add_atrace_apps(const ::std::string& value) {
  atrace_apps_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.FtraceConfig.atrace_apps)
}
 void FtraceConfig::add_atrace_apps(const char* value) {
  atrace_apps_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.FtraceConfig.atrace_apps)
}
 void FtraceConfig::add_atrace_apps(const char* value, size_t size) {
  atrace_apps_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.FtraceConfig.atrace_apps)
}
 const ::google::protobuf::RepeatedPtrField< ::std::string>&
FtraceConfig::atrace_apps() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.FtraceConfig.atrace_apps)
  return atrace_apps_;
}
 ::google::protobuf::RepeatedPtrField< ::std::string>*
FtraceConfig::mutable_atrace_apps() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.FtraceConfig.atrace_apps)
  return &atrace_apps_;
}

// optional uint32 buffer_size_kb = 10;
bool FtraceConfig::has_buffer_size_kb() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void FtraceConfig::set_has_buffer_size_kb() {
  _has_bits_[0] |= 0x00000008u;
}
void FtraceConfig::clear_has_buffer_size_kb() {
  _has_bits_[0] &= ~0x00000008u;
}
void FtraceConfig::clear_buffer_size_kb() {
  buffer_size_kb_ = 0u;
  clear_has_buffer_size_kb();
}
 ::google::protobuf::uint32 FtraceConfig::buffer_size_kb() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FtraceConfig.buffer_size_kb)
  return buffer_size_kb_;
}
 void FtraceConfig::set_buffer_size_kb(::google::protobuf::uint32 value) {
  set_has_buffer_size_kb();
  buffer_size_kb_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.FtraceConfig.buffer_size_kb)
}

// optional uint32 drain_period_ms = 11;
bool FtraceConfig::has_drain_period_ms() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void FtraceConfig::set_has_drain_period_ms() {
  _has_bits_[0] |= 0x00000010u;
}
void FtraceConfig::clear_has_drain_period_ms() {
  _has_bits_[0] &= ~0x00000010u;
}
void FtraceConfig::clear_drain_period_ms() {
  drain_period_ms_ = 0u;
  clear_has_drain_period_ms();
}
 ::google::protobuf::uint32 FtraceConfig::drain_period_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FtraceConfig.drain_period_ms)
  return drain_period_ms_;
}
 void FtraceConfig::set_drain_period_ms(::google::protobuf::uint32 value) {
  set_has_drain_period_ms();
  drain_period_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.FtraceConfig.drain_period_ms)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/config/gpu/gpu_counter_config.pb.cc
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/config/gpu/gpu_counter_config.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
// gen_amalgamated expanded: #include "perfetto/config/gpu/gpu_counter_config.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

void protobuf_ShutdownFile_perfetto_2fconfig_2fgpu_2fgpu_5fcounter_5fconfig_2eproto() {
  delete GpuCounterConfig::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_perfetto_2fconfig_2fgpu_2fgpu_5fcounter_5fconfig_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_perfetto_2fconfig_2fgpu_2fgpu_5fcounter_5fconfig_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  GpuCounterConfig::default_instance_ = new GpuCounterConfig();
  GpuCounterConfig::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_perfetto_2fconfig_2fgpu_2fgpu_5fcounter_5fconfig_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_perfetto_2fconfig_2fgpu_2fgpu_5fcounter_5fconfig_2eproto_once_);
void protobuf_AddDesc_perfetto_2fconfig_2fgpu_2fgpu_5fcounter_5fconfig_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_perfetto_2fconfig_2fgpu_2fgpu_5fcounter_5fconfig_2eproto_once_,
                 &protobuf_AddDesc_perfetto_2fconfig_2fgpu_2fgpu_5fcounter_5fconfig_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_perfetto_2fconfig_2fgpu_2fgpu_5fcounter_5fconfig_2eproto {
  StaticDescriptorInitializer_perfetto_2fconfig_2fgpu_2fgpu_5fcounter_5fconfig_2eproto() {
    protobuf_AddDesc_perfetto_2fconfig_2fgpu_2fgpu_5fcounter_5fconfig_2eproto();
  }
} static_descriptor_initializer_perfetto_2fconfig_2fgpu_2fgpu_5fcounter_5fconfig_2eproto_;
#endif

namespace {

static void gpu_counter_config_pb_MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
static void gpu_counter_config_pb_MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

static ::std::string* MutableUnknownFieldsForGpuCounterConfig(
    GpuCounterConfig* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GpuCounterConfig::kCounterPeriodNsFieldNumber;
const int GpuCounterConfig::kCounterIdsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GpuCounterConfig::GpuCounterConfig()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.GpuCounterConfig)
}

void GpuCounterConfig::InitAsDefaultInstance() {
}

GpuCounterConfig::GpuCounterConfig(const GpuCounterConfig& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.GpuCounterConfig)
}

void GpuCounterConfig::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  counter_period_ns_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GpuCounterConfig::~GpuCounterConfig() {
  // @@protoc_insertion_point(destructor:perfetto.protos.GpuCounterConfig)
  SharedDtor();
}

void GpuCounterConfig::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GpuCounterConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GpuCounterConfig& GpuCounterConfig::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fconfig_2fgpu_2fgpu_5fcounter_5fconfig_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fconfig_2fgpu_2fgpu_5fcounter_5fconfig_2eproto();
#endif
  return *default_instance_;
}

GpuCounterConfig* GpuCounterConfig::default_instance_ = NULL;

GpuCounterConfig* GpuCounterConfig::New(::google::protobuf::Arena* arena) const {
  GpuCounterConfig* n = new GpuCounterConfig;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GpuCounterConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.GpuCounterConfig)
  counter_period_ns_ = GOOGLE_ULONGLONG(0);
  counter_ids_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool GpuCounterConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForGpuCounterConfig, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.GpuCounterConfig)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 counter_period_ns = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &counter_period_ns_)));
          set_has_counter_period_ns();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_counter_ids;
        break;
      }

      // repeated uint32 counter_ids = 2;
      case 2: {
        if (tag == 16) {
         parse_counter_ids:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 16, input, this->mutable_counter_ids())));
        } else if (tag == 18) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_counter_ids())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_counter_ids;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.GpuCounterConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.GpuCounterConfig)
  return false;
#undef DO_
}

void GpuCounterConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.GpuCounterConfig)
  // optional uint64 counter_period_ns = 1;
  if (has_counter_period_ns()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->counter_period_ns(), output);
  }

  // repeated uint32 counter_ids = 2;
  for (int i = 0; i < this->counter_ids_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      2, this->counter_ids(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.GpuCounterConfig)
}

int GpuCounterConfig::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.GpuCounterConfig)
  int total_size = 0;

  // optional uint64 counter_period_ns = 1;
  if (has_counter_period_ns()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->counter_period_ns());
  }

  // repeated uint32 counter_ids = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->counter_ids_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->counter_ids(i));
    }
    total_size += 1 * this->counter_ids_size() + data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GpuCounterConfig::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GpuCounterConfig*>(&from));
}

void GpuCounterConfig::MergeFrom(const GpuCounterConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.GpuCounterConfig)
  if (GOOGLE_PREDICT_FALSE(&from == this)) gpu_counter_config_pb_MergeFromFail(__LINE__);
  counter_ids_.MergeFrom(from.counter_ids_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_counter_period_ns()) {
      set_counter_period_ns(from.counter_period_ns());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void GpuCounterConfig::CopyFrom(const GpuCounterConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.GpuCounterConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GpuCounterConfig::IsInitialized() const {

  return true;
}

void GpuCounterConfig::Swap(GpuCounterConfig* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GpuCounterConfig::InternalSwap(GpuCounterConfig* other) {
  std::swap(counter_period_ns_, other->counter_period_ns_);
  counter_ids_.UnsafeArenaSwap(&other->counter_ids_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string GpuCounterConfig::GetTypeName() const {
  return "perfetto.protos.GpuCounterConfig";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// GpuCounterConfig

// optional uint64 counter_period_ns = 1;
bool GpuCounterConfig::has_counter_period_ns() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void GpuCounterConfig::set_has_counter_period_ns() {
  _has_bits_[0] |= 0x00000001u;
}
void GpuCounterConfig::clear_has_counter_period_ns() {
  _has_bits_[0] &= ~0x00000001u;
}
void GpuCounterConfig::clear_counter_period_ns() {
  counter_period_ns_ = GOOGLE_ULONGLONG(0);
  clear_has_counter_period_ns();
}
 ::google::protobuf::uint64 GpuCounterConfig::counter_period_ns() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterConfig.counter_period_ns)
  return counter_period_ns_;
}
 void GpuCounterConfig::set_counter_period_ns(::google::protobuf::uint64 value) {
  set_has_counter_period_ns();
  counter_period_ns_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.GpuCounterConfig.counter_period_ns)
}

// repeated uint32 counter_ids = 2;
int GpuCounterConfig::counter_ids_size() const {
  return counter_ids_.size();
}
void GpuCounterConfig::clear_counter_ids() {
  counter_ids_.Clear();
}
 ::google::protobuf::uint32 GpuCounterConfig::counter_ids(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GpuCounterConfig.counter_ids)
  return counter_ids_.Get(index);
}
 void GpuCounterConfig::set_counter_ids(int index, ::google::protobuf::uint32 value) {
  counter_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.GpuCounterConfig.counter_ids)
}
 void GpuCounterConfig::add_counter_ids(::google::protobuf::uint32 value) {
  counter_ids_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.GpuCounterConfig.counter_ids)
}
 const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
GpuCounterConfig::counter_ids() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.GpuCounterConfig.counter_ids)
  return counter_ids_;
}
 ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
GpuCounterConfig::mutable_counter_ids() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.GpuCounterConfig.counter_ids)
  return &counter_ids_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/config/inode_file/inode_file_config.pb.cc
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/config/inode_file/inode_file_config.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
// gen_amalgamated expanded: #include "perfetto/config/inode_file/inode_file_config.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

void protobuf_ShutdownFile_perfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto() {
  delete InodeFileConfig::default_instance_;
  delete InodeFileConfig_MountPointMappingEntry::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_perfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_perfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  InodeFileConfig::default_instance_ = new InodeFileConfig();
  InodeFileConfig_MountPointMappingEntry::default_instance_ = new InodeFileConfig_MountPointMappingEntry();
  InodeFileConfig::default_instance_->InitAsDefaultInstance();
  InodeFileConfig_MountPointMappingEntry::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_perfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_perfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto_once_);
void protobuf_AddDesc_perfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_perfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto_once_,
                 &protobuf_AddDesc_perfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_perfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto {
  StaticDescriptorInitializer_perfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto() {
    protobuf_AddDesc_perfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto();
  }
} static_descriptor_initializer_perfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto_;
#endif

namespace {

static void inode_file_config_pb_MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
static void inode_file_config_pb_MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

static ::std::string* MutableUnknownFieldsForInodeFileConfig(
    InodeFileConfig* ptr) {
  return ptr->mutable_unknown_fields();
}

static ::std::string* MutableUnknownFieldsForInodeFileConfig_MountPointMappingEntry(
    InodeFileConfig_MountPointMappingEntry* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int InodeFileConfig_MountPointMappingEntry::kMountpointFieldNumber;
const int InodeFileConfig_MountPointMappingEntry::kScanRootsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

InodeFileConfig_MountPointMappingEntry::InodeFileConfig_MountPointMappingEntry()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.InodeFileConfig.MountPointMappingEntry)
}

void InodeFileConfig_MountPointMappingEntry::InitAsDefaultInstance() {
}

InodeFileConfig_MountPointMappingEntry::InodeFileConfig_MountPointMappingEntry(const InodeFileConfig_MountPointMappingEntry& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.InodeFileConfig.MountPointMappingEntry)
}

void InodeFileConfig_MountPointMappingEntry::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  mountpoint_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

InodeFileConfig_MountPointMappingEntry::~InodeFileConfig_MountPointMappingEntry() {
  // @@protoc_insertion_point(destructor:perfetto.protos.InodeFileConfig.MountPointMappingEntry)
  SharedDtor();
}

void InodeFileConfig_MountPointMappingEntry::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  mountpoint_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void InodeFileConfig_MountPointMappingEntry::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const InodeFileConfig_MountPointMappingEntry& InodeFileConfig_MountPointMappingEntry::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto();
#endif
  return *default_instance_;
}

InodeFileConfig_MountPointMappingEntry* InodeFileConfig_MountPointMappingEntry::default_instance_ = NULL;

InodeFileConfig_MountPointMappingEntry* InodeFileConfig_MountPointMappingEntry::New(::google::protobuf::Arena* arena) const {
  InodeFileConfig_MountPointMappingEntry* n = new InodeFileConfig_MountPointMappingEntry;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void InodeFileConfig_MountPointMappingEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.InodeFileConfig.MountPointMappingEntry)
  if (has_mountpoint()) {
    mountpoint_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  scan_roots_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool InodeFileConfig_MountPointMappingEntry::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForInodeFileConfig_MountPointMappingEntry, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.InodeFileConfig.MountPointMappingEntry)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string mountpoint = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_mountpoint()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_scan_roots;
        break;
      }

      // repeated string scan_roots = 2;
      case 2: {
        if (tag == 18) {
         parse_scan_roots:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_scan_roots()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_scan_roots;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.InodeFileConfig.MountPointMappingEntry)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.InodeFileConfig.MountPointMappingEntry)
  return false;
#undef DO_
}

void InodeFileConfig_MountPointMappingEntry::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.InodeFileConfig.MountPointMappingEntry)
  // optional string mountpoint = 1;
  if (has_mountpoint()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->mountpoint(), output);
  }

  // repeated string scan_roots = 2;
  for (int i = 0; i < this->scan_roots_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->scan_roots(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.InodeFileConfig.MountPointMappingEntry)
}

int InodeFileConfig_MountPointMappingEntry::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.InodeFileConfig.MountPointMappingEntry)
  int total_size = 0;

  // optional string mountpoint = 1;
  if (has_mountpoint()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->mountpoint());
  }

  // repeated string scan_roots = 2;
  total_size += 1 * this->scan_roots_size();
  for (int i = 0; i < this->scan_roots_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->scan_roots(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void InodeFileConfig_MountPointMappingEntry::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const InodeFileConfig_MountPointMappingEntry*>(&from));
}

void InodeFileConfig_MountPointMappingEntry::MergeFrom(const InodeFileConfig_MountPointMappingEntry& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.InodeFileConfig.MountPointMappingEntry)
  if (GOOGLE_PREDICT_FALSE(&from == this)) inode_file_config_pb_MergeFromFail(__LINE__);
  scan_roots_.MergeFrom(from.scan_roots_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mountpoint()) {
      set_has_mountpoint();
      mountpoint_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.mountpoint_);
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void InodeFileConfig_MountPointMappingEntry::CopyFrom(const InodeFileConfig_MountPointMappingEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.InodeFileConfig.MountPointMappingEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InodeFileConfig_MountPointMappingEntry::IsInitialized() const {

  return true;
}

void InodeFileConfig_MountPointMappingEntry::Swap(InodeFileConfig_MountPointMappingEntry* other) {
  if (other == this) return;
  InternalSwap(other);
}
void InodeFileConfig_MountPointMappingEntry::InternalSwap(InodeFileConfig_MountPointMappingEntry* other) {
  mountpoint_.Swap(&other->mountpoint_);
  scan_roots_.UnsafeArenaSwap(&other->scan_roots_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string InodeFileConfig_MountPointMappingEntry::GetTypeName() const {
  return "perfetto.protos.InodeFileConfig.MountPointMappingEntry";
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int InodeFileConfig::kScanIntervalMsFieldNumber;
const int InodeFileConfig::kScanDelayMsFieldNumber;
const int InodeFileConfig::kScanBatchSizeFieldNumber;
const int InodeFileConfig::kDoNotScanFieldNumber;
const int InodeFileConfig::kScanMountPointsFieldNumber;
const int InodeFileConfig::kMountPointMappingFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

InodeFileConfig::InodeFileConfig()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.InodeFileConfig)
}

void InodeFileConfig::InitAsDefaultInstance() {
}

InodeFileConfig::InodeFileConfig(const InodeFileConfig& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.InodeFileConfig)
}

void InodeFileConfig::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  scan_interval_ms_ = 0u;
  scan_delay_ms_ = 0u;
  scan_batch_size_ = 0u;
  do_not_scan_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

InodeFileConfig::~InodeFileConfig() {
  // @@protoc_insertion_point(destructor:perfetto.protos.InodeFileConfig)
  SharedDtor();
}

void InodeFileConfig::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void InodeFileConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const InodeFileConfig& InodeFileConfig::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fconfig_2finode_5ffile_2finode_5ffile_5fconfig_2eproto();
#endif
  return *default_instance_;
}

InodeFileConfig* InodeFileConfig::default_instance_ = NULL;

InodeFileConfig* InodeFileConfig::New(::google::protobuf::Arena* arena) const {
  InodeFileConfig* n = new InodeFileConfig;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void InodeFileConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.InodeFileConfig)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(InodeFileConfig, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<InodeFileConfig*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(scan_interval_ms_, do_not_scan_);

#undef ZR_HELPER_
#undef ZR_

  scan_mount_points_.Clear();
  mount_point_mapping_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool InodeFileConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForInodeFileConfig, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.InodeFileConfig)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 scan_interval_ms = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &scan_interval_ms_)));
          set_has_scan_interval_ms();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_scan_delay_ms;
        break;
      }

      // optional uint32 scan_delay_ms = 2;
      case 2: {
        if (tag == 16) {
         parse_scan_delay_ms:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &scan_delay_ms_)));
          set_has_scan_delay_ms();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_scan_batch_size;
        break;
      }

      // optional uint32 scan_batch_size = 3;
      case 3: {
        if (tag == 24) {
         parse_scan_batch_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &scan_batch_size_)));
          set_has_scan_batch_size();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_do_not_scan;
        break;
      }

      // optional bool do_not_scan = 4;
      case 4: {
        if (tag == 32) {
         parse_do_not_scan:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &do_not_scan_)));
          set_has_do_not_scan();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_scan_mount_points;
        break;
      }

      // repeated string scan_mount_points = 5;
      case 5: {
        if (tag == 42) {
         parse_scan_mount_points:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_scan_mount_points()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_scan_mount_points;
        if (input->ExpectTag(50)) goto parse_mount_point_mapping;
        break;
      }

      // repeated .perfetto.protos.InodeFileConfig.MountPointMappingEntry mount_point_mapping = 6;
      case 6: {
        if (tag == 50) {
         parse_mount_point_mapping:
          DO_(input->IncrementRecursionDepth());
         parse_loop_mount_point_mapping:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_mount_point_mapping()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_loop_mount_point_mapping;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.InodeFileConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.InodeFileConfig)
  return false;
#undef DO_
}

void InodeFileConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.InodeFileConfig)
  // optional uint32 scan_interval_ms = 1;
  if (has_scan_interval_ms()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->scan_interval_ms(), output);
  }

  // optional uint32 scan_delay_ms = 2;
  if (has_scan_delay_ms()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->scan_delay_ms(), output);
  }

  // optional uint32 scan_batch_size = 3;
  if (has_scan_batch_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->scan_batch_size(), output);
  }

  // optional bool do_not_scan = 4;
  if (has_do_not_scan()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->do_not_scan(), output);
  }

  // repeated string scan_mount_points = 5;
  for (int i = 0; i < this->scan_mount_points_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->scan_mount_points(i), output);
  }

  // repeated .perfetto.protos.InodeFileConfig.MountPointMappingEntry mount_point_mapping = 6;
  for (unsigned int i = 0, n = this->mount_point_mapping_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->mount_point_mapping(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.InodeFileConfig)
}

int InodeFileConfig::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.InodeFileConfig)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 15u) {
    // optional uint32 scan_interval_ms = 1;
    if (has_scan_interval_ms()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->scan_interval_ms());
    }

    // optional uint32 scan_delay_ms = 2;
    if (has_scan_delay_ms()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->scan_delay_ms());
    }

    // optional uint32 scan_batch_size = 3;
    if (has_scan_batch_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->scan_batch_size());
    }

    // optional bool do_not_scan = 4;
    if (has_do_not_scan()) {
      total_size += 1 + 1;
    }

  }
  // repeated string scan_mount_points = 5;
  total_size += 1 * this->scan_mount_points_size();
  for (int i = 0; i < this->scan_mount_points_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->scan_mount_points(i));
  }

  // repeated .perfetto.protos.InodeFileConfig.MountPointMappingEntry mount_point_mapping = 6;
  total_size += 1 * this->mount_point_mapping_size();
  for (int i = 0; i < this->mount_point_mapping_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->mount_point_mapping(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void InodeFileConfig::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const InodeFileConfig*>(&from));
}

void InodeFileConfig::MergeFrom(const InodeFileConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.InodeFileConfig)
  if (GOOGLE_PREDICT_FALSE(&from == this)) inode_file_config_pb_MergeFromFail(__LINE__);
  scan_mount_points_.MergeFrom(from.scan_mount_points_);
  mount_point_mapping_.MergeFrom(from.mount_point_mapping_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_scan_interval_ms()) {
      set_scan_interval_ms(from.scan_interval_ms());
    }
    if (from.has_scan_delay_ms()) {
      set_scan_delay_ms(from.scan_delay_ms());
    }
    if (from.has_scan_batch_size()) {
      set_scan_batch_size(from.scan_batch_size());
    }
    if (from.has_do_not_scan()) {
      set_do_not_scan(from.do_not_scan());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void InodeFileConfig::CopyFrom(const InodeFileConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.InodeFileConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InodeFileConfig::IsInitialized() const {

  return true;
}

void InodeFileConfig::Swap(InodeFileConfig* other) {
  if (other == this) return;
  InternalSwap(other);
}
void InodeFileConfig::InternalSwap(InodeFileConfig* other) {
  std::swap(scan_interval_ms_, other->scan_interval_ms_);
  std::swap(scan_delay_ms_, other->scan_delay_ms_);
  std::swap(scan_batch_size_, other->scan_batch_size_);
  std::swap(do_not_scan_, other->do_not_scan_);
  scan_mount_points_.UnsafeArenaSwap(&other->scan_mount_points_);
  mount_point_mapping_.UnsafeArenaSwap(&other->mount_point_mapping_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string InodeFileConfig::GetTypeName() const {
  return "perfetto.protos.InodeFileConfig";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// InodeFileConfig_MountPointMappingEntry

// optional string mountpoint = 1;
bool InodeFileConfig_MountPointMappingEntry::has_mountpoint() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void InodeFileConfig_MountPointMappingEntry::set_has_mountpoint() {
  _has_bits_[0] |= 0x00000001u;
}
void InodeFileConfig_MountPointMappingEntry::clear_has_mountpoint() {
  _has_bits_[0] &= ~0x00000001u;
}
void InodeFileConfig_MountPointMappingEntry::clear_mountpoint() {
  mountpoint_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mountpoint();
}
 const ::std::string& InodeFileConfig_MountPointMappingEntry::mountpoint() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InodeFileConfig.MountPointMappingEntry.mountpoint)
  return mountpoint_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void InodeFileConfig_MountPointMappingEntry::set_mountpoint(const ::std::string& value) {
  set_has_mountpoint();
  mountpoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.InodeFileConfig.MountPointMappingEntry.mountpoint)
}
 void InodeFileConfig_MountPointMappingEntry::set_mountpoint(const char* value) {
  set_has_mountpoint();
  mountpoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.InodeFileConfig.MountPointMappingEntry.mountpoint)
}
 void InodeFileConfig_MountPointMappingEntry::set_mountpoint(const char* value, size_t size) {
  set_has_mountpoint();
  mountpoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.InodeFileConfig.MountPointMappingEntry.mountpoint)
}
 ::std::string* InodeFileConfig_MountPointMappingEntry::mutable_mountpoint() {
  set_has_mountpoint();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.InodeFileConfig.MountPointMappingEntry.mountpoint)
  return mountpoint_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* InodeFileConfig_MountPointMappingEntry::release_mountpoint() {
  // @@protoc_insertion_point(field_release:perfetto.protos.InodeFileConfig.MountPointMappingEntry.mountpoint)
  clear_has_mountpoint();
  return mountpoint_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void InodeFileConfig_MountPointMappingEntry::set_allocated_mountpoint(::std::string* mountpoint) {
  if (mountpoint != NULL) {
    set_has_mountpoint();
  } else {
    clear_has_mountpoint();
  }
  mountpoint_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mountpoint);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.InodeFileConfig.MountPointMappingEntry.mountpoint)
}

// repeated string scan_roots = 2;
int InodeFileConfig_MountPointMappingEntry::scan_roots_size() const {
  return scan_roots_.size();
}
void InodeFileConfig_MountPointMappingEntry::clear_scan_roots() {
  scan_roots_.Clear();
}
 const ::std::string& InodeFileConfig_MountPointMappingEntry::scan_roots(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InodeFileConfig.MountPointMappingEntry.scan_roots)
  return scan_roots_.Get(index);
}
 ::std::string* InodeFileConfig_MountPointMappingEntry::mutable_scan_roots(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.InodeFileConfig.MountPointMappingEntry.scan_roots)
  return scan_roots_.Mutable(index);
}
 void InodeFileConfig_MountPointMappingEntry::set_scan_roots(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.InodeFileConfig.MountPointMappingEntry.scan_roots)
  scan_roots_.Mutable(index)->assign(value);
}
 void InodeFileConfig_MountPointMappingEntry::set_scan_roots(int index, const char* value) {
  scan_roots_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.InodeFileConfig.MountPointMappingEntry.scan_roots)
}
 void InodeFileConfig_MountPointMappingEntry::set_scan_roots(int index, const char* value, size_t size) {
  scan_roots_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.InodeFileConfig.MountPointMappingEntry.scan_roots)
}
 ::std::string* InodeFileConfig_MountPointMappingEntry::add_scan_roots() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.InodeFileConfig.MountPointMappingEntry.scan_roots)
  return scan_roots_.Add();
}
 void InodeFileConfig_MountPointMappingEntry::add_scan_roots(const ::std::string& value) {
  scan_roots_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.InodeFileConfig.MountPointMappingEntry.scan_roots)
}
 void InodeFileConfig_MountPointMappingEntry::add_scan_roots(const char* value) {
  scan_roots_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.InodeFileConfig.MountPointMappingEntry.scan_roots)
}
 void InodeFileConfig_MountPointMappingEntry::add_scan_roots(const char* value, size_t size) {
  scan_roots_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.InodeFileConfig.MountPointMappingEntry.scan_roots)
}
 const ::google::protobuf::RepeatedPtrField< ::std::string>&
InodeFileConfig_MountPointMappingEntry::scan_roots() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.InodeFileConfig.MountPointMappingEntry.scan_roots)
  return scan_roots_;
}
 ::google::protobuf::RepeatedPtrField< ::std::string>*
InodeFileConfig_MountPointMappingEntry::mutable_scan_roots() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.InodeFileConfig.MountPointMappingEntry.scan_roots)
  return &scan_roots_;
}

// -------------------------------------------------------------------

// InodeFileConfig

// optional uint32 scan_interval_ms = 1;
bool InodeFileConfig::has_scan_interval_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void InodeFileConfig::set_has_scan_interval_ms() {
  _has_bits_[0] |= 0x00000001u;
}
void InodeFileConfig::clear_has_scan_interval_ms() {
  _has_bits_[0] &= ~0x00000001u;
}
void InodeFileConfig::clear_scan_interval_ms() {
  scan_interval_ms_ = 0u;
  clear_has_scan_interval_ms();
}
 ::google::protobuf::uint32 InodeFileConfig::scan_interval_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InodeFileConfig.scan_interval_ms)
  return scan_interval_ms_;
}
 void InodeFileConfig::set_scan_interval_ms(::google::protobuf::uint32 value) {
  set_has_scan_interval_ms();
  scan_interval_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.InodeFileConfig.scan_interval_ms)
}

// optional uint32 scan_delay_ms = 2;
bool InodeFileConfig::has_scan_delay_ms() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void InodeFileConfig::set_has_scan_delay_ms() {
  _has_bits_[0] |= 0x00000002u;
}
void InodeFileConfig::clear_has_scan_delay_ms() {
  _has_bits_[0] &= ~0x00000002u;
}
void InodeFileConfig::clear_scan_delay_ms() {
  scan_delay_ms_ = 0u;
  clear_has_scan_delay_ms();
}
 ::google::protobuf::uint32 InodeFileConfig::scan_delay_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InodeFileConfig.scan_delay_ms)
  return scan_delay_ms_;
}
 void InodeFileConfig::set_scan_delay_ms(::google::protobuf::uint32 value) {
  set_has_scan_delay_ms();
  scan_delay_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.InodeFileConfig.scan_delay_ms)
}

// optional uint32 scan_batch_size = 3;
bool InodeFileConfig::has_scan_batch_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void InodeFileConfig::set_has_scan_batch_size() {
  _has_bits_[0] |= 0x00000004u;
}
void InodeFileConfig::clear_has_scan_batch_size() {
  _has_bits_[0] &= ~0x00000004u;
}
void InodeFileConfig::clear_scan_batch_size() {
  scan_batch_size_ = 0u;
  clear_has_scan_batch_size();
}
 ::google::protobuf::uint32 InodeFileConfig::scan_batch_size() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InodeFileConfig.scan_batch_size)
  return scan_batch_size_;
}
 void InodeFileConfig::set_scan_batch_size(::google::protobuf::uint32 value) {
  set_has_scan_batch_size();
  scan_batch_size_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.InodeFileConfig.scan_batch_size)
}

// optional bool do_not_scan = 4;
bool InodeFileConfig::has_do_not_scan() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void InodeFileConfig::set_has_do_not_scan() {
  _has_bits_[0] |= 0x00000008u;
}
void InodeFileConfig::clear_has_do_not_scan() {
  _has_bits_[0] &= ~0x00000008u;
}
void InodeFileConfig::clear_do_not_scan() {
  do_not_scan_ = false;
  clear_has_do_not_scan();
}
 bool InodeFileConfig::do_not_scan() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InodeFileConfig.do_not_scan)
  return do_not_scan_;
}
 void InodeFileConfig::set_do_not_scan(bool value) {
  set_has_do_not_scan();
  do_not_scan_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.InodeFileConfig.do_not_scan)
}

// repeated string scan_mount_points = 5;
int InodeFileConfig::scan_mount_points_size() const {
  return scan_mount_points_.size();
}
void InodeFileConfig::clear_scan_mount_points() {
  scan_mount_points_.Clear();
}
 const ::std::string& InodeFileConfig::scan_mount_points(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InodeFileConfig.scan_mount_points)
  return scan_mount_points_.Get(index);
}
 ::std::string* InodeFileConfig::mutable_scan_mount_points(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.InodeFileConfig.scan_mount_points)
  return scan_mount_points_.Mutable(index);
}
 void InodeFileConfig::set_scan_mount_points(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.InodeFileConfig.scan_mount_points)
  scan_mount_points_.Mutable(index)->assign(value);
}
 void InodeFileConfig::set_scan_mount_points(int index, const char* value) {
  scan_mount_points_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.InodeFileConfig.scan_mount_points)
}
 void InodeFileConfig::set_scan_mount_points(int index, const char* value, size_t size) {
  scan_mount_points_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.InodeFileConfig.scan_mount_points)
}
 ::std::string* InodeFileConfig::add_scan_mount_points() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.InodeFileConfig.scan_mount_points)
  return scan_mount_points_.Add();
}
 void InodeFileConfig::add_scan_mount_points(const ::std::string& value) {
  scan_mount_points_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.InodeFileConfig.scan_mount_points)
}
 void InodeFileConfig::add_scan_mount_points(const char* value) {
  scan_mount_points_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.InodeFileConfig.scan_mount_points)
}
 void InodeFileConfig::add_scan_mount_points(const char* value, size_t size) {
  scan_mount_points_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.InodeFileConfig.scan_mount_points)
}
 const ::google::protobuf::RepeatedPtrField< ::std::string>&
InodeFileConfig::scan_mount_points() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.InodeFileConfig.scan_mount_points)
  return scan_mount_points_;
}
 ::google::protobuf::RepeatedPtrField< ::std::string>*
InodeFileConfig::mutable_scan_mount_points() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.InodeFileConfig.scan_mount_points)
  return &scan_mount_points_;
}

// repeated .perfetto.protos.InodeFileConfig.MountPointMappingEntry mount_point_mapping = 6;
int InodeFileConfig::mount_point_mapping_size() const {
  return mount_point_mapping_.size();
}
void InodeFileConfig::clear_mount_point_mapping() {
  mount_point_mapping_.Clear();
}
const ::perfetto::protos::InodeFileConfig_MountPointMappingEntry& InodeFileConfig::mount_point_mapping(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InodeFileConfig.mount_point_mapping)
  return mount_point_mapping_.Get(index);
}
::perfetto::protos::InodeFileConfig_MountPointMappingEntry* InodeFileConfig::mutable_mount_point_mapping(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.InodeFileConfig.mount_point_mapping)
  return mount_point_mapping_.Mutable(index);
}
::perfetto::protos::InodeFileConfig_MountPointMappingEntry* InodeFileConfig::add_mount_point_mapping() {
  // @@protoc_insertion_point(field_add:perfetto.protos.InodeFileConfig.mount_point_mapping)
  return mount_point_mapping_.Add();
}
::google::protobuf::RepeatedPtrField< ::perfetto::protos::InodeFileConfig_MountPointMappingEntry >*
InodeFileConfig::mutable_mount_point_mapping() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.InodeFileConfig.mount_point_mapping)
  return &mount_point_mapping_;
}
const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::InodeFileConfig_MountPointMappingEntry >&
InodeFileConfig::mount_point_mapping() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.InodeFileConfig.mount_point_mapping)
  return mount_point_mapping_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/config/power/android_power_config.pb.cc
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/config/power/android_power_config.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
// gen_amalgamated expanded: #include "perfetto/config/power/android_power_config.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

void protobuf_ShutdownFile_perfetto_2fconfig_2fpower_2fandroid_5fpower_5fconfig_2eproto() {
  delete AndroidPowerConfig::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_perfetto_2fconfig_2fpower_2fandroid_5fpower_5fconfig_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_perfetto_2fconfig_2fpower_2fandroid_5fpower_5fconfig_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  AndroidPowerConfig::default_instance_ = new AndroidPowerConfig();
  AndroidPowerConfig::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_perfetto_2fconfig_2fpower_2fandroid_5fpower_5fconfig_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_perfetto_2fconfig_2fpower_2fandroid_5fpower_5fconfig_2eproto_once_);
void protobuf_AddDesc_perfetto_2fconfig_2fpower_2fandroid_5fpower_5fconfig_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_perfetto_2fconfig_2fpower_2fandroid_5fpower_5fconfig_2eproto_once_,
                 &protobuf_AddDesc_perfetto_2fconfig_2fpower_2fandroid_5fpower_5fconfig_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_perfetto_2fconfig_2fpower_2fandroid_5fpower_5fconfig_2eproto {
  StaticDescriptorInitializer_perfetto_2fconfig_2fpower_2fandroid_5fpower_5fconfig_2eproto() {
    protobuf_AddDesc_perfetto_2fconfig_2fpower_2fandroid_5fpower_5fconfig_2eproto();
  }
} static_descriptor_initializer_perfetto_2fconfig_2fpower_2fandroid_5fpower_5fconfig_2eproto_;
#endif

namespace {

static void android_power_config_pb_MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
static void android_power_config_pb_MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

static ::std::string* MutableUnknownFieldsForAndroidPowerConfig(
    AndroidPowerConfig* ptr) {
  return ptr->mutable_unknown_fields();
}

bool AndroidPowerConfig_BatteryCounters_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const AndroidPowerConfig_BatteryCounters AndroidPowerConfig::BATTERY_COUNTER_UNSPECIFIED;
const AndroidPowerConfig_BatteryCounters AndroidPowerConfig::BATTERY_COUNTER_CHARGE;
const AndroidPowerConfig_BatteryCounters AndroidPowerConfig::BATTERY_COUNTER_CAPACITY_PERCENT;
const AndroidPowerConfig_BatteryCounters AndroidPowerConfig::BATTERY_COUNTER_CURRENT;
const AndroidPowerConfig_BatteryCounters AndroidPowerConfig::BATTERY_COUNTER_CURRENT_AVG;
const AndroidPowerConfig_BatteryCounters AndroidPowerConfig::BatteryCounters_MIN;
const AndroidPowerConfig_BatteryCounters AndroidPowerConfig::BatteryCounters_MAX;
const int AndroidPowerConfig::BatteryCounters_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int AndroidPowerConfig::kBatteryPollMsFieldNumber;
const int AndroidPowerConfig::kBatteryCountersFieldNumber;
const int AndroidPowerConfig::kCollectPowerRailsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

AndroidPowerConfig::AndroidPowerConfig()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.AndroidPowerConfig)
}

void AndroidPowerConfig::InitAsDefaultInstance() {
}

AndroidPowerConfig::AndroidPowerConfig(const AndroidPowerConfig& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.AndroidPowerConfig)
}

void AndroidPowerConfig::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  battery_poll_ms_ = 0u;
  collect_power_rails_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AndroidPowerConfig::~AndroidPowerConfig() {
  // @@protoc_insertion_point(destructor:perfetto.protos.AndroidPowerConfig)
  SharedDtor();
}

void AndroidPowerConfig::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AndroidPowerConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AndroidPowerConfig& AndroidPowerConfig::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fconfig_2fpower_2fandroid_5fpower_5fconfig_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fconfig_2fpower_2fandroid_5fpower_5fconfig_2eproto();
#endif
  return *default_instance_;
}

AndroidPowerConfig* AndroidPowerConfig::default_instance_ = NULL;

AndroidPowerConfig* AndroidPowerConfig::New(::google::protobuf::Arena* arena) const {
  AndroidPowerConfig* n = new AndroidPowerConfig;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void AndroidPowerConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.AndroidPowerConfig)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(AndroidPowerConfig, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<AndroidPowerConfig*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(battery_poll_ms_, collect_power_rails_);

#undef ZR_HELPER_
#undef ZR_

  battery_counters_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool AndroidPowerConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForAndroidPowerConfig, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.AndroidPowerConfig)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 battery_poll_ms = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &battery_poll_ms_)));
          set_has_battery_poll_ms();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_battery_counters;
        break;
      }

      // repeated .perfetto.protos.AndroidPowerConfig.BatteryCounters battery_counters = 2;
      case 2: {
        if (tag == 16) {
         parse_battery_counters:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::perfetto::protos::AndroidPowerConfig_BatteryCounters_IsValid(value)) {
            add_battery_counters(static_cast< ::perfetto::protos::AndroidPowerConfig_BatteryCounters >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else if (tag == 18) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedEnumPreserveUnknowns(
                 input,
                 2,
                 ::perfetto::protos::AndroidPowerConfig_BatteryCounters_IsValid,
                 &unknown_fields_stream,
                 this->mutable_battery_counters())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_battery_counters;
        if (input->ExpectTag(24)) goto parse_collect_power_rails;
        break;
      }

      // optional bool collect_power_rails = 3;
      case 3: {
        if (tag == 24) {
         parse_collect_power_rails:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &collect_power_rails_)));
          set_has_collect_power_rails();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.AndroidPowerConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.AndroidPowerConfig)
  return false;
#undef DO_
}

void AndroidPowerConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.AndroidPowerConfig)
  // optional uint32 battery_poll_ms = 1;
  if (has_battery_poll_ms()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->battery_poll_ms(), output);
  }

  // repeated .perfetto.protos.AndroidPowerConfig.BatteryCounters battery_counters = 2;
  for (int i = 0; i < this->battery_counters_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->battery_counters(i), output);
  }

  // optional bool collect_power_rails = 3;
  if (has_collect_power_rails()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->collect_power_rails(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.AndroidPowerConfig)
}

int AndroidPowerConfig::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.AndroidPowerConfig)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 5u) {
    // optional uint32 battery_poll_ms = 1;
    if (has_battery_poll_ms()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->battery_poll_ms());
    }

    // optional bool collect_power_rails = 3;
    if (has_collect_power_rails()) {
      total_size += 1 + 1;
    }

  }
  // repeated .perfetto.protos.AndroidPowerConfig.BatteryCounters battery_counters = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->battery_counters_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::EnumSize(
        this->battery_counters(i));
    }
    total_size += 1 * this->battery_counters_size() + data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AndroidPowerConfig::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AndroidPowerConfig*>(&from));
}

void AndroidPowerConfig::MergeFrom(const AndroidPowerConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.AndroidPowerConfig)
  if (GOOGLE_PREDICT_FALSE(&from == this)) android_power_config_pb_MergeFromFail(__LINE__);
  battery_counters_.MergeFrom(from.battery_counters_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_battery_poll_ms()) {
      set_battery_poll_ms(from.battery_poll_ms());
    }
    if (from.has_collect_power_rails()) {
      set_collect_power_rails(from.collect_power_rails());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void AndroidPowerConfig::CopyFrom(const AndroidPowerConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.AndroidPowerConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AndroidPowerConfig::IsInitialized() const {

  return true;
}

void AndroidPowerConfig::Swap(AndroidPowerConfig* other) {
  if (other == this) return;
  InternalSwap(other);
}
void AndroidPowerConfig::InternalSwap(AndroidPowerConfig* other) {
  std::swap(battery_poll_ms_, other->battery_poll_ms_);
  battery_counters_.UnsafeArenaSwap(&other->battery_counters_);
  std::swap(collect_power_rails_, other->collect_power_rails_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string AndroidPowerConfig::GetTypeName() const {
  return "perfetto.protos.AndroidPowerConfig";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// AndroidPowerConfig

// optional uint32 battery_poll_ms = 1;
bool AndroidPowerConfig::has_battery_poll_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void AndroidPowerConfig::set_has_battery_poll_ms() {
  _has_bits_[0] |= 0x00000001u;
}
void AndroidPowerConfig::clear_has_battery_poll_ms() {
  _has_bits_[0] &= ~0x00000001u;
}
void AndroidPowerConfig::clear_battery_poll_ms() {
  battery_poll_ms_ = 0u;
  clear_has_battery_poll_ms();
}
 ::google::protobuf::uint32 AndroidPowerConfig::battery_poll_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AndroidPowerConfig.battery_poll_ms)
  return battery_poll_ms_;
}
 void AndroidPowerConfig::set_battery_poll_ms(::google::protobuf::uint32 value) {
  set_has_battery_poll_ms();
  battery_poll_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.AndroidPowerConfig.battery_poll_ms)
}

// repeated .perfetto.protos.AndroidPowerConfig.BatteryCounters battery_counters = 2;
int AndroidPowerConfig::battery_counters_size() const {
  return battery_counters_.size();
}
void AndroidPowerConfig::clear_battery_counters() {
  battery_counters_.Clear();
}
 ::perfetto::protos::AndroidPowerConfig_BatteryCounters AndroidPowerConfig::battery_counters(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AndroidPowerConfig.battery_counters)
  return static_cast< ::perfetto::protos::AndroidPowerConfig_BatteryCounters >(battery_counters_.Get(index));
}
 void AndroidPowerConfig::set_battery_counters(int index, ::perfetto::protos::AndroidPowerConfig_BatteryCounters value) {
  assert(::perfetto::protos::AndroidPowerConfig_BatteryCounters_IsValid(value));
  battery_counters_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.AndroidPowerConfig.battery_counters)
}
 void AndroidPowerConfig::add_battery_counters(::perfetto::protos::AndroidPowerConfig_BatteryCounters value) {
  assert(::perfetto::protos::AndroidPowerConfig_BatteryCounters_IsValid(value));
  battery_counters_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.AndroidPowerConfig.battery_counters)
}
 const ::google::protobuf::RepeatedField<int>&
AndroidPowerConfig::battery_counters() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.AndroidPowerConfig.battery_counters)
  return battery_counters_;
}
 ::google::protobuf::RepeatedField<int>*
AndroidPowerConfig::mutable_battery_counters() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.AndroidPowerConfig.battery_counters)
  return &battery_counters_;
}

// optional bool collect_power_rails = 3;
bool AndroidPowerConfig::has_collect_power_rails() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void AndroidPowerConfig::set_has_collect_power_rails() {
  _has_bits_[0] |= 0x00000004u;
}
void AndroidPowerConfig::clear_has_collect_power_rails() {
  _has_bits_[0] &= ~0x00000004u;
}
void AndroidPowerConfig::clear_collect_power_rails() {
  collect_power_rails_ = false;
  clear_has_collect_power_rails();
}
 bool AndroidPowerConfig::collect_power_rails() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AndroidPowerConfig.collect_power_rails)
  return collect_power_rails_;
}
 void AndroidPowerConfig::set_collect_power_rails(bool value) {
  set_has_collect_power_rails();
  collect_power_rails_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.AndroidPowerConfig.collect_power_rails)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/config/process_stats/process_stats_config.pb.cc
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/config/process_stats/process_stats_config.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
// gen_amalgamated expanded: #include "perfetto/config/process_stats/process_stats_config.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

void protobuf_ShutdownFile_perfetto_2fconfig_2fprocess_5fstats_2fprocess_5fstats_5fconfig_2eproto() {
  delete ProcessStatsConfig::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_perfetto_2fconfig_2fprocess_5fstats_2fprocess_5fstats_5fconfig_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_perfetto_2fconfig_2fprocess_5fstats_2fprocess_5fstats_5fconfig_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ProcessStatsConfig::default_instance_ = new ProcessStatsConfig();
  ProcessStatsConfig::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_perfetto_2fconfig_2fprocess_5fstats_2fprocess_5fstats_5fconfig_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_perfetto_2fconfig_2fprocess_5fstats_2fprocess_5fstats_5fconfig_2eproto_once_);
void protobuf_AddDesc_perfetto_2fconfig_2fprocess_5fstats_2fprocess_5fstats_5fconfig_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_perfetto_2fconfig_2fprocess_5fstats_2fprocess_5fstats_5fconfig_2eproto_once_,
                 &protobuf_AddDesc_perfetto_2fconfig_2fprocess_5fstats_2fprocess_5fstats_5fconfig_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_perfetto_2fconfig_2fprocess_5fstats_2fprocess_5fstats_5fconfig_2eproto {
  StaticDescriptorInitializer_perfetto_2fconfig_2fprocess_5fstats_2fprocess_5fstats_5fconfig_2eproto() {
    protobuf_AddDesc_perfetto_2fconfig_2fprocess_5fstats_2fprocess_5fstats_5fconfig_2eproto();
  }
} static_descriptor_initializer_perfetto_2fconfig_2fprocess_5fstats_2fprocess_5fstats_5fconfig_2eproto_;
#endif

namespace {

static void process_stats_config_pb_MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
static void process_stats_config_pb_MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

static ::std::string* MutableUnknownFieldsForProcessStatsConfig(
    ProcessStatsConfig* ptr) {
  return ptr->mutable_unknown_fields();
}

bool ProcessStatsConfig_Quirks_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const ProcessStatsConfig_Quirks ProcessStatsConfig::QUIRKS_UNSPECIFIED;
const ProcessStatsConfig_Quirks ProcessStatsConfig::DISABLE_INITIAL_DUMP;
const ProcessStatsConfig_Quirks ProcessStatsConfig::DISABLE_ON_DEMAND;
const ProcessStatsConfig_Quirks ProcessStatsConfig::Quirks_MIN;
const ProcessStatsConfig_Quirks ProcessStatsConfig::Quirks_MAX;
const int ProcessStatsConfig::Quirks_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ProcessStatsConfig::kQuirksFieldNumber;
const int ProcessStatsConfig::kScanAllProcessesOnStartFieldNumber;
const int ProcessStatsConfig::kRecordThreadNamesFieldNumber;
const int ProcessStatsConfig::kProcStatsPollMsFieldNumber;
const int ProcessStatsConfig::kProcStatsCacheTtlMsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ProcessStatsConfig::ProcessStatsConfig()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.ProcessStatsConfig)
}

void ProcessStatsConfig::InitAsDefaultInstance() {
}

ProcessStatsConfig::ProcessStatsConfig(const ProcessStatsConfig& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.ProcessStatsConfig)
}

void ProcessStatsConfig::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  scan_all_processes_on_start_ = false;
  record_thread_names_ = false;
  proc_stats_poll_ms_ = 0u;
  proc_stats_cache_ttl_ms_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ProcessStatsConfig::~ProcessStatsConfig() {
  // @@protoc_insertion_point(destructor:perfetto.protos.ProcessStatsConfig)
  SharedDtor();
}

void ProcessStatsConfig::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ProcessStatsConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ProcessStatsConfig& ProcessStatsConfig::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fconfig_2fprocess_5fstats_2fprocess_5fstats_5fconfig_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fconfig_2fprocess_5fstats_2fprocess_5fstats_5fconfig_2eproto();
#endif
  return *default_instance_;
}

ProcessStatsConfig* ProcessStatsConfig::default_instance_ = NULL;

ProcessStatsConfig* ProcessStatsConfig::New(::google::protobuf::Arena* arena) const {
  ProcessStatsConfig* n = new ProcessStatsConfig;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ProcessStatsConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.ProcessStatsConfig)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(ProcessStatsConfig, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<ProcessStatsConfig*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(scan_all_processes_on_start_, proc_stats_cache_ttl_ms_);

#undef ZR_HELPER_
#undef ZR_

  quirks_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool ProcessStatsConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForProcessStatsConfig, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.ProcessStatsConfig)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .perfetto.protos.ProcessStatsConfig.Quirks quirks = 1;
      case 1: {
        if (tag == 8) {
         parse_quirks:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::perfetto::protos::ProcessStatsConfig_Quirks_IsValid(value)) {
            add_quirks(static_cast< ::perfetto::protos::ProcessStatsConfig_Quirks >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedEnumPreserveUnknowns(
                 input,
                 1,
                 ::perfetto::protos::ProcessStatsConfig_Quirks_IsValid,
                 &unknown_fields_stream,
                 this->mutable_quirks())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(8)) goto parse_quirks;
        if (input->ExpectTag(16)) goto parse_scan_all_processes_on_start;
        break;
      }

      // optional bool scan_all_processes_on_start = 2;
      case 2: {
        if (tag == 16) {
         parse_scan_all_processes_on_start:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &scan_all_processes_on_start_)));
          set_has_scan_all_processes_on_start();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_record_thread_names;
        break;
      }

      // optional bool record_thread_names = 3;
      case 3: {
        if (tag == 24) {
         parse_record_thread_names:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &record_thread_names_)));
          set_has_record_thread_names();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_proc_stats_poll_ms;
        break;
      }

      // optional uint32 proc_stats_poll_ms = 4;
      case 4: {
        if (tag == 32) {
         parse_proc_stats_poll_ms:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &proc_stats_poll_ms_)));
          set_has_proc_stats_poll_ms();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_proc_stats_cache_ttl_ms;
        break;
      }

      // optional uint32 proc_stats_cache_ttl_ms = 6;
      case 6: {
        if (tag == 48) {
         parse_proc_stats_cache_ttl_ms:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &proc_stats_cache_ttl_ms_)));
          set_has_proc_stats_cache_ttl_ms();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.ProcessStatsConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.ProcessStatsConfig)
  return false;
#undef DO_
}

void ProcessStatsConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.ProcessStatsConfig)
  // repeated .perfetto.protos.ProcessStatsConfig.Quirks quirks = 1;
  for (int i = 0; i < this->quirks_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->quirks(i), output);
  }

  // optional bool scan_all_processes_on_start = 2;
  if (has_scan_all_processes_on_start()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->scan_all_processes_on_start(), output);
  }

  // optional bool record_thread_names = 3;
  if (has_record_thread_names()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->record_thread_names(), output);
  }

  // optional uint32 proc_stats_poll_ms = 4;
  if (has_proc_stats_poll_ms()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->proc_stats_poll_ms(), output);
  }

  // optional uint32 proc_stats_cache_ttl_ms = 6;
  if (has_proc_stats_cache_ttl_ms()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->proc_stats_cache_ttl_ms(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.ProcessStatsConfig)
}

int ProcessStatsConfig::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.ProcessStatsConfig)
  int total_size = 0;

  if (_has_bits_[1 / 32] & 30u) {
    // optional bool scan_all_processes_on_start = 2;
    if (has_scan_all_processes_on_start()) {
      total_size += 1 + 1;
    }

    // optional bool record_thread_names = 3;
    if (has_record_thread_names()) {
      total_size += 1 + 1;
    }

    // optional uint32 proc_stats_poll_ms = 4;
    if (has_proc_stats_poll_ms()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->proc_stats_poll_ms());
    }

    // optional uint32 proc_stats_cache_ttl_ms = 6;
    if (has_proc_stats_cache_ttl_ms()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->proc_stats_cache_ttl_ms());
    }

  }
  // repeated .perfetto.protos.ProcessStatsConfig.Quirks quirks = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->quirks_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::EnumSize(
        this->quirks(i));
    }
    total_size += 1 * this->quirks_size() + data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ProcessStatsConfig::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ProcessStatsConfig*>(&from));
}

void ProcessStatsConfig::MergeFrom(const ProcessStatsConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.ProcessStatsConfig)
  if (GOOGLE_PREDICT_FALSE(&from == this)) process_stats_config_pb_MergeFromFail(__LINE__);
  quirks_.MergeFrom(from.quirks_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_scan_all_processes_on_start()) {
      set_scan_all_processes_on_start(from.scan_all_processes_on_start());
    }
    if (from.has_record_thread_names()) {
      set_record_thread_names(from.record_thread_names());
    }
    if (from.has_proc_stats_poll_ms()) {
      set_proc_stats_poll_ms(from.proc_stats_poll_ms());
    }
    if (from.has_proc_stats_cache_ttl_ms()) {
      set_proc_stats_cache_ttl_ms(from.proc_stats_cache_ttl_ms());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void ProcessStatsConfig::CopyFrom(const ProcessStatsConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.ProcessStatsConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProcessStatsConfig::IsInitialized() const {

  return true;
}

void ProcessStatsConfig::Swap(ProcessStatsConfig* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ProcessStatsConfig::InternalSwap(ProcessStatsConfig* other) {
  quirks_.UnsafeArenaSwap(&other->quirks_);
  std::swap(scan_all_processes_on_start_, other->scan_all_processes_on_start_);
  std::swap(record_thread_names_, other->record_thread_names_);
  std::swap(proc_stats_poll_ms_, other->proc_stats_poll_ms_);
  std::swap(proc_stats_cache_ttl_ms_, other->proc_stats_cache_ttl_ms_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ProcessStatsConfig::GetTypeName() const {
  return "perfetto.protos.ProcessStatsConfig";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ProcessStatsConfig

// repeated .perfetto.protos.ProcessStatsConfig.Quirks quirks = 1;
int ProcessStatsConfig::quirks_size() const {
  return quirks_.size();
}
void ProcessStatsConfig::clear_quirks() {
  quirks_.Clear();
}
 ::perfetto::protos::ProcessStatsConfig_Quirks ProcessStatsConfig::quirks(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ProcessStatsConfig.quirks)
  return static_cast< ::perfetto::protos::ProcessStatsConfig_Quirks >(quirks_.Get(index));
}
 void ProcessStatsConfig::set_quirks(int index, ::perfetto::protos::ProcessStatsConfig_Quirks value) {
  assert(::perfetto::protos::ProcessStatsConfig_Quirks_IsValid(value));
  quirks_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.ProcessStatsConfig.quirks)
}
 void ProcessStatsConfig::add_quirks(::perfetto::protos::ProcessStatsConfig_Quirks value) {
  assert(::perfetto::protos::ProcessStatsConfig_Quirks_IsValid(value));
  quirks_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.ProcessStatsConfig.quirks)
}
 const ::google::protobuf::RepeatedField<int>&
ProcessStatsConfig::quirks() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.ProcessStatsConfig.quirks)
  return quirks_;
}
 ::google::protobuf::RepeatedField<int>*
ProcessStatsConfig::mutable_quirks() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.ProcessStatsConfig.quirks)
  return &quirks_;
}

// optional bool scan_all_processes_on_start = 2;
bool ProcessStatsConfig::has_scan_all_processes_on_start() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ProcessStatsConfig::set_has_scan_all_processes_on_start() {
  _has_bits_[0] |= 0x00000002u;
}
void ProcessStatsConfig::clear_has_scan_all_processes_on_start() {
  _has_bits_[0] &= ~0x00000002u;
}
void ProcessStatsConfig::clear_scan_all_processes_on_start() {
  scan_all_processes_on_start_ = false;
  clear_has_scan_all_processes_on_start();
}
 bool ProcessStatsConfig::scan_all_processes_on_start() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ProcessStatsConfig.scan_all_processes_on_start)
  return scan_all_processes_on_start_;
}
 void ProcessStatsConfig::set_scan_all_processes_on_start(bool value) {
  set_has_scan_all_processes_on_start();
  scan_all_processes_on_start_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.ProcessStatsConfig.scan_all_processes_on_start)
}

// optional bool record_thread_names = 3;
bool ProcessStatsConfig::has_record_thread_names() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ProcessStatsConfig::set_has_record_thread_names() {
  _has_bits_[0] |= 0x00000004u;
}
void ProcessStatsConfig::clear_has_record_thread_names() {
  _has_bits_[0] &= ~0x00000004u;
}
void ProcessStatsConfig::clear_record_thread_names() {
  record_thread_names_ = false;
  clear_has_record_thread_names();
}
 bool ProcessStatsConfig::record_thread_names() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ProcessStatsConfig.record_thread_names)
  return record_thread_names_;
}
 void ProcessStatsConfig::set_record_thread_names(bool value) {
  set_has_record_thread_names();
  record_thread_names_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.ProcessStatsConfig.record_thread_names)
}

// optional uint32 proc_stats_poll_ms = 4;
bool ProcessStatsConfig::has_proc_stats_poll_ms() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ProcessStatsConfig::set_has_proc_stats_poll_ms() {
  _has_bits_[0] |= 0x00000008u;
}
void ProcessStatsConfig::clear_has_proc_stats_poll_ms() {
  _has_bits_[0] &= ~0x00000008u;
}
void ProcessStatsConfig::clear_proc_stats_poll_ms() {
  proc_stats_poll_ms_ = 0u;
  clear_has_proc_stats_poll_ms();
}
 ::google::protobuf::uint32 ProcessStatsConfig::proc_stats_poll_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ProcessStatsConfig.proc_stats_poll_ms)
  return proc_stats_poll_ms_;
}
 void ProcessStatsConfig::set_proc_stats_poll_ms(::google::protobuf::uint32 value) {
  set_has_proc_stats_poll_ms();
  proc_stats_poll_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.ProcessStatsConfig.proc_stats_poll_ms)
}

// optional uint32 proc_stats_cache_ttl_ms = 6;
bool ProcessStatsConfig::has_proc_stats_cache_ttl_ms() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void ProcessStatsConfig::set_has_proc_stats_cache_ttl_ms() {
  _has_bits_[0] |= 0x00000010u;
}
void ProcessStatsConfig::clear_has_proc_stats_cache_ttl_ms() {
  _has_bits_[0] &= ~0x00000010u;
}
void ProcessStatsConfig::clear_proc_stats_cache_ttl_ms() {
  proc_stats_cache_ttl_ms_ = 0u;
  clear_has_proc_stats_cache_ttl_ms();
}
 ::google::protobuf::uint32 ProcessStatsConfig::proc_stats_cache_ttl_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ProcessStatsConfig.proc_stats_cache_ttl_ms)
  return proc_stats_cache_ttl_ms_;
}
 void ProcessStatsConfig::set_proc_stats_cache_ttl_ms(::google::protobuf::uint32 value) {
  set_has_proc_stats_cache_ttl_ms();
  proc_stats_cache_ttl_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.ProcessStatsConfig.proc_stats_cache_ttl_ms)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/config/profiling/heapprofd_config.pb.cc
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/config/profiling/heapprofd_config.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
// gen_amalgamated expanded: #include "perfetto/config/profiling/heapprofd_config.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

void protobuf_ShutdownFile_perfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto() {
  delete HeapprofdConfig::default_instance_;
  delete HeapprofdConfig_ContinuousDumpConfig::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_perfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_perfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  HeapprofdConfig::default_instance_ = new HeapprofdConfig();
  HeapprofdConfig_ContinuousDumpConfig::default_instance_ = new HeapprofdConfig_ContinuousDumpConfig();
  HeapprofdConfig::default_instance_->InitAsDefaultInstance();
  HeapprofdConfig_ContinuousDumpConfig::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_perfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_perfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto_once_);
void protobuf_AddDesc_perfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_perfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto_once_,
                 &protobuf_AddDesc_perfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_perfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto {
  StaticDescriptorInitializer_perfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto() {
    protobuf_AddDesc_perfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto();
  }
} static_descriptor_initializer_perfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto_;
#endif

namespace {

static void heapprofd_config_pb_MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
static void heapprofd_config_pb_MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

static ::std::string* MutableUnknownFieldsForHeapprofdConfig(
    HeapprofdConfig* ptr) {
  return ptr->mutable_unknown_fields();
}

static ::std::string* MutableUnknownFieldsForHeapprofdConfig_ContinuousDumpConfig(
    HeapprofdConfig_ContinuousDumpConfig* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int HeapprofdConfig_ContinuousDumpConfig::kDumpPhaseMsFieldNumber;
const int HeapprofdConfig_ContinuousDumpConfig::kDumpIntervalMsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

HeapprofdConfig_ContinuousDumpConfig::HeapprofdConfig_ContinuousDumpConfig()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.HeapprofdConfig.ContinuousDumpConfig)
}

void HeapprofdConfig_ContinuousDumpConfig::InitAsDefaultInstance() {
}

HeapprofdConfig_ContinuousDumpConfig::HeapprofdConfig_ContinuousDumpConfig(const HeapprofdConfig_ContinuousDumpConfig& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.HeapprofdConfig.ContinuousDumpConfig)
}

void HeapprofdConfig_ContinuousDumpConfig::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  dump_phase_ms_ = 0u;
  dump_interval_ms_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HeapprofdConfig_ContinuousDumpConfig::~HeapprofdConfig_ContinuousDumpConfig() {
  // @@protoc_insertion_point(destructor:perfetto.protos.HeapprofdConfig.ContinuousDumpConfig)
  SharedDtor();
}

void HeapprofdConfig_ContinuousDumpConfig::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void HeapprofdConfig_ContinuousDumpConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const HeapprofdConfig_ContinuousDumpConfig& HeapprofdConfig_ContinuousDumpConfig::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto();
#endif
  return *default_instance_;
}

HeapprofdConfig_ContinuousDumpConfig* HeapprofdConfig_ContinuousDumpConfig::default_instance_ = NULL;

HeapprofdConfig_ContinuousDumpConfig* HeapprofdConfig_ContinuousDumpConfig::New(::google::protobuf::Arena* arena) const {
  HeapprofdConfig_ContinuousDumpConfig* n = new HeapprofdConfig_ContinuousDumpConfig;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void HeapprofdConfig_ContinuousDumpConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.HeapprofdConfig.ContinuousDumpConfig)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(HeapprofdConfig_ContinuousDumpConfig, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<HeapprofdConfig_ContinuousDumpConfig*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(dump_phase_ms_, dump_interval_ms_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool HeapprofdConfig_ContinuousDumpConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForHeapprofdConfig_ContinuousDumpConfig, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.HeapprofdConfig.ContinuousDumpConfig)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 dump_phase_ms = 5;
      case 5: {
        if (tag == 40) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &dump_phase_ms_)));
          set_has_dump_phase_ms();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_dump_interval_ms;
        break;
      }

      // optional uint32 dump_interval_ms = 6;
      case 6: {
        if (tag == 48) {
         parse_dump_interval_ms:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &dump_interval_ms_)));
          set_has_dump_interval_ms();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.HeapprofdConfig.ContinuousDumpConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.HeapprofdConfig.ContinuousDumpConfig)
  return false;
#undef DO_
}

void HeapprofdConfig_ContinuousDumpConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.HeapprofdConfig.ContinuousDumpConfig)
  // optional uint32 dump_phase_ms = 5;
  if (has_dump_phase_ms()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->dump_phase_ms(), output);
  }

  // optional uint32 dump_interval_ms = 6;
  if (has_dump_interval_ms()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->dump_interval_ms(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.HeapprofdConfig.ContinuousDumpConfig)
}

int HeapprofdConfig_ContinuousDumpConfig::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.HeapprofdConfig.ContinuousDumpConfig)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional uint32 dump_phase_ms = 5;
    if (has_dump_phase_ms()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->dump_phase_ms());
    }

    // optional uint32 dump_interval_ms = 6;
    if (has_dump_interval_ms()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->dump_interval_ms());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HeapprofdConfig_ContinuousDumpConfig::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const HeapprofdConfig_ContinuousDumpConfig*>(&from));
}

void HeapprofdConfig_ContinuousDumpConfig::MergeFrom(const HeapprofdConfig_ContinuousDumpConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.HeapprofdConfig.ContinuousDumpConfig)
  if (GOOGLE_PREDICT_FALSE(&from == this)) heapprofd_config_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_dump_phase_ms()) {
      set_dump_phase_ms(from.dump_phase_ms());
    }
    if (from.has_dump_interval_ms()) {
      set_dump_interval_ms(from.dump_interval_ms());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void HeapprofdConfig_ContinuousDumpConfig::CopyFrom(const HeapprofdConfig_ContinuousDumpConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.HeapprofdConfig.ContinuousDumpConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HeapprofdConfig_ContinuousDumpConfig::IsInitialized() const {

  return true;
}

void HeapprofdConfig_ContinuousDumpConfig::Swap(HeapprofdConfig_ContinuousDumpConfig* other) {
  if (other == this) return;
  InternalSwap(other);
}
void HeapprofdConfig_ContinuousDumpConfig::InternalSwap(HeapprofdConfig_ContinuousDumpConfig* other) {
  std::swap(dump_phase_ms_, other->dump_phase_ms_);
  std::swap(dump_interval_ms_, other->dump_interval_ms_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string HeapprofdConfig_ContinuousDumpConfig::GetTypeName() const {
  return "perfetto.protos.HeapprofdConfig.ContinuousDumpConfig";
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int HeapprofdConfig::kSamplingIntervalBytesFieldNumber;
const int HeapprofdConfig::kProcessCmdlineFieldNumber;
const int HeapprofdConfig::kPidFieldNumber;
const int HeapprofdConfig::kAllFieldNumber;
const int HeapprofdConfig::kSkipSymbolPrefixFieldNumber;
const int HeapprofdConfig::kContinuousDumpConfigFieldNumber;
const int HeapprofdConfig::kShmemSizeBytesFieldNumber;
const int HeapprofdConfig::kBlockClientFieldNumber;
const int HeapprofdConfig::kNoStartupFieldNumber;
const int HeapprofdConfig::kNoRunningFieldNumber;
const int HeapprofdConfig::kIdleAllocationsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

HeapprofdConfig::HeapprofdConfig()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.HeapprofdConfig)
}

void HeapprofdConfig::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  continuous_dump_config_ = const_cast< ::perfetto::protos::HeapprofdConfig_ContinuousDumpConfig*>(
      ::perfetto::protos::HeapprofdConfig_ContinuousDumpConfig::internal_default_instance());
#else
  continuous_dump_config_ = const_cast< ::perfetto::protos::HeapprofdConfig_ContinuousDumpConfig*>(&::perfetto::protos::HeapprofdConfig_ContinuousDumpConfig::default_instance());
#endif
}

HeapprofdConfig::HeapprofdConfig(const HeapprofdConfig& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.HeapprofdConfig)
}

void HeapprofdConfig::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  sampling_interval_bytes_ = GOOGLE_ULONGLONG(0);
  all_ = false;
  continuous_dump_config_ = NULL;
  shmem_size_bytes_ = GOOGLE_ULONGLONG(0);
  block_client_ = false;
  no_startup_ = false;
  no_running_ = false;
  idle_allocations_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HeapprofdConfig::~HeapprofdConfig() {
  // @@protoc_insertion_point(destructor:perfetto.protos.HeapprofdConfig)
  SharedDtor();
}

void HeapprofdConfig::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete continuous_dump_config_;
  }
}

void HeapprofdConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const HeapprofdConfig& HeapprofdConfig::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fconfig_2fprofiling_2fheapprofd_5fconfig_2eproto();
#endif
  return *default_instance_;
}

HeapprofdConfig* HeapprofdConfig::default_instance_ = NULL;

HeapprofdConfig* HeapprofdConfig::New(::google::protobuf::Arena* arena) const {
  HeapprofdConfig* n = new HeapprofdConfig;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void HeapprofdConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.HeapprofdConfig)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(HeapprofdConfig, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<HeapprofdConfig*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 233u) {
    ZR_(shmem_size_bytes_, block_client_);
    sampling_interval_bytes_ = GOOGLE_ULONGLONG(0);
    if (has_continuous_dump_config()) {
      if (continuous_dump_config_ != NULL) continuous_dump_config_->::perfetto::protos::HeapprofdConfig_ContinuousDumpConfig::Clear();
    }
  }
  ZR_(no_startup_, idle_allocations_);

#undef ZR_HELPER_
#undef ZR_

  process_cmdline_.Clear();
  pid_.Clear();
  skip_symbol_prefix_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool HeapprofdConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForHeapprofdConfig, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.HeapprofdConfig)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 sampling_interval_bytes = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &sampling_interval_bytes_)));
          set_has_sampling_interval_bytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_process_cmdline;
        break;
      }

      // repeated string process_cmdline = 2;
      case 2: {
        if (tag == 18) {
         parse_process_cmdline:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_process_cmdline()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_process_cmdline;
        if (input->ExpectTag(32)) goto parse_pid;
        break;
      }

      // repeated uint64 pid = 4;
      case 4: {
        if (tag == 32) {
         parse_pid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 1, 32, input, this->mutable_pid())));
        } else if (tag == 34) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, this->mutable_pid())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_pid;
        if (input->ExpectTag(40)) goto parse_all;
        break;
      }

      // optional bool all = 5;
      case 5: {
        if (tag == 40) {
         parse_all:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &all_)));
          set_has_all();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_continuous_dump_config;
        break;
      }

      // optional .perfetto.protos.HeapprofdConfig.ContinuousDumpConfig continuous_dump_config = 6;
      case 6: {
        if (tag == 50) {
         parse_continuous_dump_config:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_continuous_dump_config()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_skip_symbol_prefix;
        break;
      }

      // repeated string skip_symbol_prefix = 7;
      case 7: {
        if (tag == 58) {
         parse_skip_symbol_prefix:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_skip_symbol_prefix()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_skip_symbol_prefix;
        if (input->ExpectTag(64)) goto parse_shmem_size_bytes;
        break;
      }

      // optional uint64 shmem_size_bytes = 8;
      case 8: {
        if (tag == 64) {
         parse_shmem_size_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &shmem_size_bytes_)));
          set_has_shmem_size_bytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_block_client;
        break;
      }

      // optional bool block_client = 9;
      case 9: {
        if (tag == 72) {
         parse_block_client:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &block_client_)));
          set_has_block_client();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_no_startup;
        break;
      }

      // optional bool no_startup = 10;
      case 10: {
        if (tag == 80) {
         parse_no_startup:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &no_startup_)));
          set_has_no_startup();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_no_running;
        break;
      }

      // optional bool no_running = 11;
      case 11: {
        if (tag == 88) {
         parse_no_running:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &no_running_)));
          set_has_no_running();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_idle_allocations;
        break;
      }

      // optional bool idle_allocations = 12;
      case 12: {
        if (tag == 96) {
         parse_idle_allocations:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &idle_allocations_)));
          set_has_idle_allocations();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.HeapprofdConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.HeapprofdConfig)
  return false;
#undef DO_
}

void HeapprofdConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.HeapprofdConfig)
  // optional uint64 sampling_interval_bytes = 1;
  if (has_sampling_interval_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->sampling_interval_bytes(), output);
  }

  // repeated string process_cmdline = 2;
  for (int i = 0; i < this->process_cmdline_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->process_cmdline(i), output);
  }

  // repeated uint64 pid = 4;
  for (int i = 0; i < this->pid_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(
      4, this->pid(i), output);
  }

  // optional bool all = 5;
  if (has_all()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->all(), output);
  }

  // optional .perfetto.protos.HeapprofdConfig.ContinuousDumpConfig continuous_dump_config = 6;
  if (has_continuous_dump_config()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, *this->continuous_dump_config_, output);
  }

  // repeated string skip_symbol_prefix = 7;
  for (int i = 0; i < this->skip_symbol_prefix_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      7, this->skip_symbol_prefix(i), output);
  }

  // optional uint64 shmem_size_bytes = 8;
  if (has_shmem_size_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(8, this->shmem_size_bytes(), output);
  }

  // optional bool block_client = 9;
  if (has_block_client()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(9, this->block_client(), output);
  }

  // optional bool no_startup = 10;
  if (has_no_startup()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(10, this->no_startup(), output);
  }

  // optional bool no_running = 11;
  if (has_no_running()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(11, this->no_running(), output);
  }

  // optional bool idle_allocations = 12;
  if (has_idle_allocations()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(12, this->idle_allocations(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.HeapprofdConfig)
}

int HeapprofdConfig::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.HeapprofdConfig)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 233u) {
    // optional uint64 sampling_interval_bytes = 1;
    if (has_sampling_interval_bytes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->sampling_interval_bytes());
    }

    // optional bool all = 5;
    if (has_all()) {
      total_size += 1 + 1;
    }

    // optional .perfetto.protos.HeapprofdConfig.ContinuousDumpConfig continuous_dump_config = 6;
    if (has_continuous_dump_config()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->continuous_dump_config_);
    }

    // optional uint64 shmem_size_bytes = 8;
    if (has_shmem_size_bytes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->shmem_size_bytes());
    }

    // optional bool block_client = 9;
    if (has_block_client()) {
      total_size += 1 + 1;
    }

  }
  if (_has_bits_[8 / 32] & 1792u) {
    // optional bool no_startup = 10;
    if (has_no_startup()) {
      total_size += 1 + 1;
    }

    // optional bool no_running = 11;
    if (has_no_running()) {
      total_size += 1 + 1;
    }

    // optional bool idle_allocations = 12;
    if (has_idle_allocations()) {
      total_size += 1 + 1;
    }

  }
  // repeated string process_cmdline = 2;
  total_size += 1 * this->process_cmdline_size();
  for (int i = 0; i < this->process_cmdline_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->process_cmdline(i));
  }

  // repeated uint64 pid = 4;
  {
    int data_size = 0;
    for (int i = 0; i < this->pid_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt64Size(this->pid(i));
    }
    total_size += 1 * this->pid_size() + data_size;
  }

  // repeated string skip_symbol_prefix = 7;
  total_size += 1 * this->skip_symbol_prefix_size();
  for (int i = 0; i < this->skip_symbol_prefix_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->skip_symbol_prefix(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HeapprofdConfig::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const HeapprofdConfig*>(&from));
}

void HeapprofdConfig::MergeFrom(const HeapprofdConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.HeapprofdConfig)
  if (GOOGLE_PREDICT_FALSE(&from == this)) heapprofd_config_pb_MergeFromFail(__LINE__);
  process_cmdline_.MergeFrom(from.process_cmdline_);
  pid_.MergeFrom(from.pid_);
  skip_symbol_prefix_.MergeFrom(from.skip_symbol_prefix_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sampling_interval_bytes()) {
      set_sampling_interval_bytes(from.sampling_interval_bytes());
    }
    if (from.has_all()) {
      set_all(from.all());
    }
    if (from.has_continuous_dump_config()) {
      mutable_continuous_dump_config()->::perfetto::protos::HeapprofdConfig_ContinuousDumpConfig::MergeFrom(from.continuous_dump_config());
    }
    if (from.has_shmem_size_bytes()) {
      set_shmem_size_bytes(from.shmem_size_bytes());
    }
    if (from.has_block_client()) {
      set_block_client(from.block_client());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_no_startup()) {
      set_no_startup(from.no_startup());
    }
    if (from.has_no_running()) {
      set_no_running(from.no_running());
    }
    if (from.has_idle_allocations()) {
      set_idle_allocations(from.idle_allocations());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void HeapprofdConfig::CopyFrom(const HeapprofdConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.HeapprofdConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HeapprofdConfig::IsInitialized() const {

  return true;
}

void HeapprofdConfig::Swap(HeapprofdConfig* other) {
  if (other == this) return;
  InternalSwap(other);
}
void HeapprofdConfig::InternalSwap(HeapprofdConfig* other) {
  std::swap(sampling_interval_bytes_, other->sampling_interval_bytes_);
  process_cmdline_.UnsafeArenaSwap(&other->process_cmdline_);
  pid_.UnsafeArenaSwap(&other->pid_);
  std::swap(all_, other->all_);
  skip_symbol_prefix_.UnsafeArenaSwap(&other->skip_symbol_prefix_);
  std::swap(continuous_dump_config_, other->continuous_dump_config_);
  std::swap(shmem_size_bytes_, other->shmem_size_bytes_);
  std::swap(block_client_, other->block_client_);
  std::swap(no_startup_, other->no_startup_);
  std::swap(no_running_, other->no_running_);
  std::swap(idle_allocations_, other->idle_allocations_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string HeapprofdConfig::GetTypeName() const {
  return "perfetto.protos.HeapprofdConfig";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// HeapprofdConfig_ContinuousDumpConfig

// optional uint32 dump_phase_ms = 5;
bool HeapprofdConfig_ContinuousDumpConfig::has_dump_phase_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void HeapprofdConfig_ContinuousDumpConfig::set_has_dump_phase_ms() {
  _has_bits_[0] |= 0x00000001u;
}
void HeapprofdConfig_ContinuousDumpConfig::clear_has_dump_phase_ms() {
  _has_bits_[0] &= ~0x00000001u;
}
void HeapprofdConfig_ContinuousDumpConfig::clear_dump_phase_ms() {
  dump_phase_ms_ = 0u;
  clear_has_dump_phase_ms();
}
 ::google::protobuf::uint32 HeapprofdConfig_ContinuousDumpConfig::dump_phase_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.ContinuousDumpConfig.dump_phase_ms)
  return dump_phase_ms_;
}
 void HeapprofdConfig_ContinuousDumpConfig::set_dump_phase_ms(::google::protobuf::uint32 value) {
  set_has_dump_phase_ms();
  dump_phase_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.HeapprofdConfig.ContinuousDumpConfig.dump_phase_ms)
}

// optional uint32 dump_interval_ms = 6;
bool HeapprofdConfig_ContinuousDumpConfig::has_dump_interval_ms() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void HeapprofdConfig_ContinuousDumpConfig::set_has_dump_interval_ms() {
  _has_bits_[0] |= 0x00000002u;
}
void HeapprofdConfig_ContinuousDumpConfig::clear_has_dump_interval_ms() {
  _has_bits_[0] &= ~0x00000002u;
}
void HeapprofdConfig_ContinuousDumpConfig::clear_dump_interval_ms() {
  dump_interval_ms_ = 0u;
  clear_has_dump_interval_ms();
}
 ::google::protobuf::uint32 HeapprofdConfig_ContinuousDumpConfig::dump_interval_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.ContinuousDumpConfig.dump_interval_ms)
  return dump_interval_ms_;
}
 void HeapprofdConfig_ContinuousDumpConfig::set_dump_interval_ms(::google::protobuf::uint32 value) {
  set_has_dump_interval_ms();
  dump_interval_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.HeapprofdConfig.ContinuousDumpConfig.dump_interval_ms)
}

// -------------------------------------------------------------------

// HeapprofdConfig

// optional uint64 sampling_interval_bytes = 1;
bool HeapprofdConfig::has_sampling_interval_bytes() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void HeapprofdConfig::set_has_sampling_interval_bytes() {
  _has_bits_[0] |= 0x00000001u;
}
void HeapprofdConfig::clear_has_sampling_interval_bytes() {
  _has_bits_[0] &= ~0x00000001u;
}
void HeapprofdConfig::clear_sampling_interval_bytes() {
  sampling_interval_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_sampling_interval_bytes();
}
 ::google::protobuf::uint64 HeapprofdConfig::sampling_interval_bytes() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.sampling_interval_bytes)
  return sampling_interval_bytes_;
}
 void HeapprofdConfig::set_sampling_interval_bytes(::google::protobuf::uint64 value) {
  set_has_sampling_interval_bytes();
  sampling_interval_bytes_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.HeapprofdConfig.sampling_interval_bytes)
}

// repeated string process_cmdline = 2;
int HeapprofdConfig::process_cmdline_size() const {
  return process_cmdline_.size();
}
void HeapprofdConfig::clear_process_cmdline() {
  process_cmdline_.Clear();
}
 const ::std::string& HeapprofdConfig::process_cmdline(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.process_cmdline)
  return process_cmdline_.Get(index);
}
 ::std::string* HeapprofdConfig::mutable_process_cmdline(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.HeapprofdConfig.process_cmdline)
  return process_cmdline_.Mutable(index);
}
 void HeapprofdConfig::set_process_cmdline(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.HeapprofdConfig.process_cmdline)
  process_cmdline_.Mutable(index)->assign(value);
}
 void HeapprofdConfig::set_process_cmdline(int index, const char* value) {
  process_cmdline_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.HeapprofdConfig.process_cmdline)
}
 void HeapprofdConfig::set_process_cmdline(int index, const char* value, size_t size) {
  process_cmdline_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.HeapprofdConfig.process_cmdline)
}
 ::std::string* HeapprofdConfig::add_process_cmdline() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.HeapprofdConfig.process_cmdline)
  return process_cmdline_.Add();
}
 void HeapprofdConfig::add_process_cmdline(const ::std::string& value) {
  process_cmdline_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.HeapprofdConfig.process_cmdline)
}
 void HeapprofdConfig::add_process_cmdline(const char* value) {
  process_cmdline_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.HeapprofdConfig.process_cmdline)
}
 void HeapprofdConfig::add_process_cmdline(const char* value, size_t size) {
  process_cmdline_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.HeapprofdConfig.process_cmdline)
}
 const ::google::protobuf::RepeatedPtrField< ::std::string>&
HeapprofdConfig::process_cmdline() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.HeapprofdConfig.process_cmdline)
  return process_cmdline_;
}
 ::google::protobuf::RepeatedPtrField< ::std::string>*
HeapprofdConfig::mutable_process_cmdline() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.HeapprofdConfig.process_cmdline)
  return &process_cmdline_;
}

// repeated uint64 pid = 4;
int HeapprofdConfig::pid_size() const {
  return pid_.size();
}
void HeapprofdConfig::clear_pid() {
  pid_.Clear();
}
 ::google::protobuf::uint64 HeapprofdConfig::pid(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.pid)
  return pid_.Get(index);
}
 void HeapprofdConfig::set_pid(int index, ::google::protobuf::uint64 value) {
  pid_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.HeapprofdConfig.pid)
}
 void HeapprofdConfig::add_pid(::google::protobuf::uint64 value) {
  pid_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.HeapprofdConfig.pid)
}
 const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
HeapprofdConfig::pid() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.HeapprofdConfig.pid)
  return pid_;
}
 ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
HeapprofdConfig::mutable_pid() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.HeapprofdConfig.pid)
  return &pid_;
}

// optional bool all = 5;
bool HeapprofdConfig::has_all() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void HeapprofdConfig::set_has_all() {
  _has_bits_[0] |= 0x00000008u;
}
void HeapprofdConfig::clear_has_all() {
  _has_bits_[0] &= ~0x00000008u;
}
void HeapprofdConfig::clear_all() {
  all_ = false;
  clear_has_all();
}
 bool HeapprofdConfig::all() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.all)
  return all_;
}
 void HeapprofdConfig::set_all(bool value) {
  set_has_all();
  all_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.HeapprofdConfig.all)
}

// repeated string skip_symbol_prefix = 7;
int HeapprofdConfig::skip_symbol_prefix_size() const {
  return skip_symbol_prefix_.size();
}
void HeapprofdConfig::clear_skip_symbol_prefix() {
  skip_symbol_prefix_.Clear();
}
 const ::std::string& HeapprofdConfig::skip_symbol_prefix(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.skip_symbol_prefix)
  return skip_symbol_prefix_.Get(index);
}
 ::std::string* HeapprofdConfig::mutable_skip_symbol_prefix(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.HeapprofdConfig.skip_symbol_prefix)
  return skip_symbol_prefix_.Mutable(index);
}
 void HeapprofdConfig::set_skip_symbol_prefix(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.HeapprofdConfig.skip_symbol_prefix)
  skip_symbol_prefix_.Mutable(index)->assign(value);
}
 void HeapprofdConfig::set_skip_symbol_prefix(int index, const char* value) {
  skip_symbol_prefix_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.HeapprofdConfig.skip_symbol_prefix)
}
 void HeapprofdConfig::set_skip_symbol_prefix(int index, const char* value, size_t size) {
  skip_symbol_prefix_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.HeapprofdConfig.skip_symbol_prefix)
}
 ::std::string* HeapprofdConfig::add_skip_symbol_prefix() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.HeapprofdConfig.skip_symbol_prefix)
  return skip_symbol_prefix_.Add();
}
 void HeapprofdConfig::add_skip_symbol_prefix(const ::std::string& value) {
  skip_symbol_prefix_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.HeapprofdConfig.skip_symbol_prefix)
}
 void HeapprofdConfig::add_skip_symbol_prefix(const char* value) {
  skip_symbol_prefix_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.HeapprofdConfig.skip_symbol_prefix)
}
 void HeapprofdConfig::add_skip_symbol_prefix(const char* value, size_t size) {
  skip_symbol_prefix_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.HeapprofdConfig.skip_symbol_prefix)
}
 const ::google::protobuf::RepeatedPtrField< ::std::string>&
HeapprofdConfig::skip_symbol_prefix() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.HeapprofdConfig.skip_symbol_prefix)
  return skip_symbol_prefix_;
}
 ::google::protobuf::RepeatedPtrField< ::std::string>*
HeapprofdConfig::mutable_skip_symbol_prefix() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.HeapprofdConfig.skip_symbol_prefix)
  return &skip_symbol_prefix_;
}

// optional .perfetto.protos.HeapprofdConfig.ContinuousDumpConfig continuous_dump_config = 6;
bool HeapprofdConfig::has_continuous_dump_config() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void HeapprofdConfig::set_has_continuous_dump_config() {
  _has_bits_[0] |= 0x00000020u;
}
void HeapprofdConfig::clear_has_continuous_dump_config() {
  _has_bits_[0] &= ~0x00000020u;
}
void HeapprofdConfig::clear_continuous_dump_config() {
  if (continuous_dump_config_ != NULL) continuous_dump_config_->::perfetto::protos::HeapprofdConfig_ContinuousDumpConfig::Clear();
  clear_has_continuous_dump_config();
}
const ::perfetto::protos::HeapprofdConfig_ContinuousDumpConfig& HeapprofdConfig::continuous_dump_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.continuous_dump_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return continuous_dump_config_ != NULL ? *continuous_dump_config_ : *default_instance().continuous_dump_config_;
#else
  return continuous_dump_config_ != NULL ? *continuous_dump_config_ : *default_instance_->continuous_dump_config_;
#endif
}
::perfetto::protos::HeapprofdConfig_ContinuousDumpConfig* HeapprofdConfig::mutable_continuous_dump_config() {
  set_has_continuous_dump_config();
  if (continuous_dump_config_ == NULL) {
    continuous_dump_config_ = new ::perfetto::protos::HeapprofdConfig_ContinuousDumpConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.HeapprofdConfig.continuous_dump_config)
  return continuous_dump_config_;
}
::perfetto::protos::HeapprofdConfig_ContinuousDumpConfig* HeapprofdConfig::release_continuous_dump_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.HeapprofdConfig.continuous_dump_config)
  clear_has_continuous_dump_config();
  ::perfetto::protos::HeapprofdConfig_ContinuousDumpConfig* temp = continuous_dump_config_;
  continuous_dump_config_ = NULL;
  return temp;
}
void HeapprofdConfig::set_allocated_continuous_dump_config(::perfetto::protos::HeapprofdConfig_ContinuousDumpConfig* continuous_dump_config) {
  delete continuous_dump_config_;
  continuous_dump_config_ = continuous_dump_config;
  if (continuous_dump_config) {
    set_has_continuous_dump_config();
  } else {
    clear_has_continuous_dump_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.HeapprofdConfig.continuous_dump_config)
}

// optional uint64 shmem_size_bytes = 8;
bool HeapprofdConfig::has_shmem_size_bytes() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void HeapprofdConfig::set_has_shmem_size_bytes() {
  _has_bits_[0] |= 0x00000040u;
}
void HeapprofdConfig::clear_has_shmem_size_bytes() {
  _has_bits_[0] &= ~0x00000040u;
}
void HeapprofdConfig::clear_shmem_size_bytes() {
  shmem_size_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_shmem_size_bytes();
}
 ::google::protobuf::uint64 HeapprofdConfig::shmem_size_bytes() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.shmem_size_bytes)
  return shmem_size_bytes_;
}
 void HeapprofdConfig::set_shmem_size_bytes(::google::protobuf::uint64 value) {
  set_has_shmem_size_bytes();
  shmem_size_bytes_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.HeapprofdConfig.shmem_size_bytes)
}

// optional bool block_client = 9;
bool HeapprofdConfig::has_block_client() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void HeapprofdConfig::set_has_block_client() {
  _has_bits_[0] |= 0x00000080u;
}
void HeapprofdConfig::clear_has_block_client() {
  _has_bits_[0] &= ~0x00000080u;
}
void HeapprofdConfig::clear_block_client() {
  block_client_ = false;
  clear_has_block_client();
}
 bool HeapprofdConfig::block_client() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.block_client)
  return block_client_;
}
 void HeapprofdConfig::set_block_client(bool value) {
  set_has_block_client();
  block_client_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.HeapprofdConfig.block_client)
}

// optional bool no_startup = 10;
bool HeapprofdConfig::has_no_startup() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void HeapprofdConfig::set_has_no_startup() {
  _has_bits_[0] |= 0x00000100u;
}
void HeapprofdConfig::clear_has_no_startup() {
  _has_bits_[0] &= ~0x00000100u;
}
void HeapprofdConfig::clear_no_startup() {
  no_startup_ = false;
  clear_has_no_startup();
}
 bool HeapprofdConfig::no_startup() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.no_startup)
  return no_startup_;
}
 void HeapprofdConfig::set_no_startup(bool value) {
  set_has_no_startup();
  no_startup_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.HeapprofdConfig.no_startup)
}

// optional bool no_running = 11;
bool HeapprofdConfig::has_no_running() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void HeapprofdConfig::set_has_no_running() {
  _has_bits_[0] |= 0x00000200u;
}
void HeapprofdConfig::clear_has_no_running() {
  _has_bits_[0] &= ~0x00000200u;
}
void HeapprofdConfig::clear_no_running() {
  no_running_ = false;
  clear_has_no_running();
}
 bool HeapprofdConfig::no_running() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.no_running)
  return no_running_;
}
 void HeapprofdConfig::set_no_running(bool value) {
  set_has_no_running();
  no_running_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.HeapprofdConfig.no_running)
}

// optional bool idle_allocations = 12;
bool HeapprofdConfig::has_idle_allocations() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
void HeapprofdConfig::set_has_idle_allocations() {
  _has_bits_[0] |= 0x00000400u;
}
void HeapprofdConfig::clear_has_idle_allocations() {
  _has_bits_[0] &= ~0x00000400u;
}
void HeapprofdConfig::clear_idle_allocations() {
  idle_allocations_ = false;
  clear_has_idle_allocations();
}
 bool HeapprofdConfig::idle_allocations() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.HeapprofdConfig.idle_allocations)
  return idle_allocations_;
}
 void HeapprofdConfig::set_idle_allocations(bool value) {
  set_has_idle_allocations();
  idle_allocations_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.HeapprofdConfig.idle_allocations)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/config/sys_stats/sys_stats_config.pb.cc
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/config/sys_stats/sys_stats_config.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
// gen_amalgamated expanded: #include "perfetto/config/sys_stats/sys_stats_config.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

void protobuf_ShutdownFile_perfetto_2fconfig_2fsys_5fstats_2fsys_5fstats_5fconfig_2eproto() {
  delete SysStatsConfig::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_perfetto_2fconfig_2fsys_5fstats_2fsys_5fstats_5fconfig_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_perfetto_2fconfig_2fsys_5fstats_2fsys_5fstats_5fconfig_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::perfetto::protos::protobuf_AddDesc_perfetto_2fcommon_2fsys_5fstats_5fcounters_2eproto();
  SysStatsConfig::default_instance_ = new SysStatsConfig();
  SysStatsConfig::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_perfetto_2fconfig_2fsys_5fstats_2fsys_5fstats_5fconfig_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_perfetto_2fconfig_2fsys_5fstats_2fsys_5fstats_5fconfig_2eproto_once_);
void protobuf_AddDesc_perfetto_2fconfig_2fsys_5fstats_2fsys_5fstats_5fconfig_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_perfetto_2fconfig_2fsys_5fstats_2fsys_5fstats_5fconfig_2eproto_once_,
                 &protobuf_AddDesc_perfetto_2fconfig_2fsys_5fstats_2fsys_5fstats_5fconfig_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_perfetto_2fconfig_2fsys_5fstats_2fsys_5fstats_5fconfig_2eproto {
  StaticDescriptorInitializer_perfetto_2fconfig_2fsys_5fstats_2fsys_5fstats_5fconfig_2eproto() {
    protobuf_AddDesc_perfetto_2fconfig_2fsys_5fstats_2fsys_5fstats_5fconfig_2eproto();
  }
} static_descriptor_initializer_perfetto_2fconfig_2fsys_5fstats_2fsys_5fstats_5fconfig_2eproto_;
#endif

namespace {

static void sys_stats_config_pb_MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
static void sys_stats_config_pb_MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

static ::std::string* MutableUnknownFieldsForSysStatsConfig(
    SysStatsConfig* ptr) {
  return ptr->mutable_unknown_fields();
}

bool SysStatsConfig_StatCounters_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const SysStatsConfig_StatCounters SysStatsConfig::STAT_UNSPECIFIED;
const SysStatsConfig_StatCounters SysStatsConfig::STAT_CPU_TIMES;
const SysStatsConfig_StatCounters SysStatsConfig::STAT_IRQ_COUNTS;
const SysStatsConfig_StatCounters SysStatsConfig::STAT_SOFTIRQ_COUNTS;
const SysStatsConfig_StatCounters SysStatsConfig::STAT_FORK_COUNT;
const SysStatsConfig_StatCounters SysStatsConfig::StatCounters_MIN;
const SysStatsConfig_StatCounters SysStatsConfig::StatCounters_MAX;
const int SysStatsConfig::StatCounters_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SysStatsConfig::kMeminfoPeriodMsFieldNumber;
const int SysStatsConfig::kMeminfoCountersFieldNumber;
const int SysStatsConfig::kVmstatPeriodMsFieldNumber;
const int SysStatsConfig::kVmstatCountersFieldNumber;
const int SysStatsConfig::kStatPeriodMsFieldNumber;
const int SysStatsConfig::kStatCountersFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SysStatsConfig::SysStatsConfig()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.SysStatsConfig)
}

void SysStatsConfig::InitAsDefaultInstance() {
}

SysStatsConfig::SysStatsConfig(const SysStatsConfig& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SysStatsConfig)
}

void SysStatsConfig::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  meminfo_period_ms_ = 0u;
  vmstat_period_ms_ = 0u;
  stat_period_ms_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SysStatsConfig::~SysStatsConfig() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SysStatsConfig)
  SharedDtor();
}

void SysStatsConfig::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void SysStatsConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SysStatsConfig& SysStatsConfig::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fconfig_2fsys_5fstats_2fsys_5fstats_5fconfig_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fconfig_2fsys_5fstats_2fsys_5fstats_5fconfig_2eproto();
#endif
  return *default_instance_;
}

SysStatsConfig* SysStatsConfig::default_instance_ = NULL;

SysStatsConfig* SysStatsConfig::New(::google::protobuf::Arena* arena) const {
  SysStatsConfig* n = new SysStatsConfig;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SysStatsConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SysStatsConfig)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(SysStatsConfig, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<SysStatsConfig*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 21u) {
    ZR_(meminfo_period_ms_, vmstat_period_ms_);
    stat_period_ms_ = 0u;
  }

#undef ZR_HELPER_
#undef ZR_

  meminfo_counters_.Clear();
  vmstat_counters_.Clear();
  stat_counters_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool SysStatsConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForSysStatsConfig, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.SysStatsConfig)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 meminfo_period_ms = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &meminfo_period_ms_)));
          set_has_meminfo_period_ms();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_meminfo_counters;
        break;
      }

      // repeated .perfetto.protos.MeminfoCounters meminfo_counters = 2;
      case 2: {
        if (tag == 16) {
         parse_meminfo_counters:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::perfetto::protos::MeminfoCounters_IsValid(value)) {
            add_meminfo_counters(static_cast< ::perfetto::protos::MeminfoCounters >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else if (tag == 18) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedEnumPreserveUnknowns(
                 input,
                 2,
                 ::perfetto::protos::MeminfoCounters_IsValid,
                 &unknown_fields_stream,
                 this->mutable_meminfo_counters())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_meminfo_counters;
        if (input->ExpectTag(24)) goto parse_vmstat_period_ms;
        break;
      }

      // optional uint32 vmstat_period_ms = 3;
      case 3: {
        if (tag == 24) {
         parse_vmstat_period_ms:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &vmstat_period_ms_)));
          set_has_vmstat_period_ms();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_vmstat_counters;
        break;
      }

      // repeated .perfetto.protos.VmstatCounters vmstat_counters = 4;
      case 4: {
        if (tag == 32) {
         parse_vmstat_counters:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::perfetto::protos::VmstatCounters_IsValid(value)) {
            add_vmstat_counters(static_cast< ::perfetto::protos::VmstatCounters >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else if (tag == 34) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedEnumPreserveUnknowns(
                 input,
                 4,
                 ::perfetto::protos::VmstatCounters_IsValid,
                 &unknown_fields_stream,
                 this->mutable_vmstat_counters())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_vmstat_counters;
        if (input->ExpectTag(40)) goto parse_stat_period_ms;
        break;
      }

      // optional uint32 stat_period_ms = 5;
      case 5: {
        if (tag == 40) {
         parse_stat_period_ms:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &stat_period_ms_)));
          set_has_stat_period_ms();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_stat_counters;
        break;
      }

      // repeated .perfetto.protos.SysStatsConfig.StatCounters stat_counters = 6;
      case 6: {
        if (tag == 48) {
         parse_stat_counters:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::perfetto::protos::SysStatsConfig_StatCounters_IsValid(value)) {
            add_stat_counters(static_cast< ::perfetto::protos::SysStatsConfig_StatCounters >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else if (tag == 50) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedEnumPreserveUnknowns(
                 input,
                 6,
                 ::perfetto::protos::SysStatsConfig_StatCounters_IsValid,
                 &unknown_fields_stream,
                 this->mutable_stat_counters())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_stat_counters;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.SysStatsConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.SysStatsConfig)
  return false;
#undef DO_
}

void SysStatsConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.SysStatsConfig)
  // optional uint32 meminfo_period_ms = 1;
  if (has_meminfo_period_ms()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->meminfo_period_ms(), output);
  }

  // repeated .perfetto.protos.MeminfoCounters meminfo_counters = 2;
  for (int i = 0; i < this->meminfo_counters_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->meminfo_counters(i), output);
  }

  // optional uint32 vmstat_period_ms = 3;
  if (has_vmstat_period_ms()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->vmstat_period_ms(), output);
  }

  // repeated .perfetto.protos.VmstatCounters vmstat_counters = 4;
  for (int i = 0; i < this->vmstat_counters_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->vmstat_counters(i), output);
  }

  // optional uint32 stat_period_ms = 5;
  if (has_stat_period_ms()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->stat_period_ms(), output);
  }

  // repeated .perfetto.protos.SysStatsConfig.StatCounters stat_counters = 6;
  for (int i = 0; i < this->stat_counters_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->stat_counters(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.SysStatsConfig)
}

int SysStatsConfig::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SysStatsConfig)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 21u) {
    // optional uint32 meminfo_period_ms = 1;
    if (has_meminfo_period_ms()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->meminfo_period_ms());
    }

    // optional uint32 vmstat_period_ms = 3;
    if (has_vmstat_period_ms()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->vmstat_period_ms());
    }

    // optional uint32 stat_period_ms = 5;
    if (has_stat_period_ms()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->stat_period_ms());
    }

  }
  // repeated .perfetto.protos.MeminfoCounters meminfo_counters = 2;
  {
    int data_size = 0;
    for (int i = 0; i < this->meminfo_counters_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::EnumSize(
        this->meminfo_counters(i));
    }
    total_size += 1 * this->meminfo_counters_size() + data_size;
  }

  // repeated .perfetto.protos.VmstatCounters vmstat_counters = 4;
  {
    int data_size = 0;
    for (int i = 0; i < this->vmstat_counters_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::EnumSize(
        this->vmstat_counters(i));
    }
    total_size += 1 * this->vmstat_counters_size() + data_size;
  }

  // repeated .perfetto.protos.SysStatsConfig.StatCounters stat_counters = 6;
  {
    int data_size = 0;
    for (int i = 0; i < this->stat_counters_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::EnumSize(
        this->stat_counters(i));
    }
    total_size += 1 * this->stat_counters_size() + data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SysStatsConfig::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SysStatsConfig*>(&from));
}

void SysStatsConfig::MergeFrom(const SysStatsConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SysStatsConfig)
  if (GOOGLE_PREDICT_FALSE(&from == this)) sys_stats_config_pb_MergeFromFail(__LINE__);
  meminfo_counters_.MergeFrom(from.meminfo_counters_);
  vmstat_counters_.MergeFrom(from.vmstat_counters_);
  stat_counters_.MergeFrom(from.stat_counters_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_meminfo_period_ms()) {
      set_meminfo_period_ms(from.meminfo_period_ms());
    }
    if (from.has_vmstat_period_ms()) {
      set_vmstat_period_ms(from.vmstat_period_ms());
    }
    if (from.has_stat_period_ms()) {
      set_stat_period_ms(from.stat_period_ms());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void SysStatsConfig::CopyFrom(const SysStatsConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SysStatsConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SysStatsConfig::IsInitialized() const {

  return true;
}

void SysStatsConfig::Swap(SysStatsConfig* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SysStatsConfig::InternalSwap(SysStatsConfig* other) {
  std::swap(meminfo_period_ms_, other->meminfo_period_ms_);
  meminfo_counters_.UnsafeArenaSwap(&other->meminfo_counters_);
  std::swap(vmstat_period_ms_, other->vmstat_period_ms_);
  vmstat_counters_.UnsafeArenaSwap(&other->vmstat_counters_);
  std::swap(stat_period_ms_, other->stat_period_ms_);
  stat_counters_.UnsafeArenaSwap(&other->stat_counters_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string SysStatsConfig::GetTypeName() const {
  return "perfetto.protos.SysStatsConfig";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SysStatsConfig

// optional uint32 meminfo_period_ms = 1;
bool SysStatsConfig::has_meminfo_period_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void SysStatsConfig::set_has_meminfo_period_ms() {
  _has_bits_[0] |= 0x00000001u;
}
void SysStatsConfig::clear_has_meminfo_period_ms() {
  _has_bits_[0] &= ~0x00000001u;
}
void SysStatsConfig::clear_meminfo_period_ms() {
  meminfo_period_ms_ = 0u;
  clear_has_meminfo_period_ms();
}
 ::google::protobuf::uint32 SysStatsConfig::meminfo_period_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SysStatsConfig.meminfo_period_ms)
  return meminfo_period_ms_;
}
 void SysStatsConfig::set_meminfo_period_ms(::google::protobuf::uint32 value) {
  set_has_meminfo_period_ms();
  meminfo_period_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.SysStatsConfig.meminfo_period_ms)
}

// repeated .perfetto.protos.MeminfoCounters meminfo_counters = 2;
int SysStatsConfig::meminfo_counters_size() const {
  return meminfo_counters_.size();
}
void SysStatsConfig::clear_meminfo_counters() {
  meminfo_counters_.Clear();
}
 ::perfetto::protos::MeminfoCounters SysStatsConfig::meminfo_counters(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SysStatsConfig.meminfo_counters)
  return static_cast< ::perfetto::protos::MeminfoCounters >(meminfo_counters_.Get(index));
}
 void SysStatsConfig::set_meminfo_counters(int index, ::perfetto::protos::MeminfoCounters value) {
  assert(::perfetto::protos::MeminfoCounters_IsValid(value));
  meminfo_counters_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SysStatsConfig.meminfo_counters)
}
 void SysStatsConfig::add_meminfo_counters(::perfetto::protos::MeminfoCounters value) {
  assert(::perfetto::protos::MeminfoCounters_IsValid(value));
  meminfo_counters_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.SysStatsConfig.meminfo_counters)
}
 const ::google::protobuf::RepeatedField<int>&
SysStatsConfig::meminfo_counters() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.SysStatsConfig.meminfo_counters)
  return meminfo_counters_;
}
 ::google::protobuf::RepeatedField<int>*
SysStatsConfig::mutable_meminfo_counters() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.SysStatsConfig.meminfo_counters)
  return &meminfo_counters_;
}

// optional uint32 vmstat_period_ms = 3;
bool SysStatsConfig::has_vmstat_period_ms() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void SysStatsConfig::set_has_vmstat_period_ms() {
  _has_bits_[0] |= 0x00000004u;
}
void SysStatsConfig::clear_has_vmstat_period_ms() {
  _has_bits_[0] &= ~0x00000004u;
}
void SysStatsConfig::clear_vmstat_period_ms() {
  vmstat_period_ms_ = 0u;
  clear_has_vmstat_period_ms();
}
 ::google::protobuf::uint32 SysStatsConfig::vmstat_period_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SysStatsConfig.vmstat_period_ms)
  return vmstat_period_ms_;
}
 void SysStatsConfig::set_vmstat_period_ms(::google::protobuf::uint32 value) {
  set_has_vmstat_period_ms();
  vmstat_period_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.SysStatsConfig.vmstat_period_ms)
}

// repeated .perfetto.protos.VmstatCounters vmstat_counters = 4;
int SysStatsConfig::vmstat_counters_size() const {
  return vmstat_counters_.size();
}
void SysStatsConfig::clear_vmstat_counters() {
  vmstat_counters_.Clear();
}
 ::perfetto::protos::VmstatCounters SysStatsConfig::vmstat_counters(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SysStatsConfig.vmstat_counters)
  return static_cast< ::perfetto::protos::VmstatCounters >(vmstat_counters_.Get(index));
}
 void SysStatsConfig::set_vmstat_counters(int index, ::perfetto::protos::VmstatCounters value) {
  assert(::perfetto::protos::VmstatCounters_IsValid(value));
  vmstat_counters_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SysStatsConfig.vmstat_counters)
}
 void SysStatsConfig::add_vmstat_counters(::perfetto::protos::VmstatCounters value) {
  assert(::perfetto::protos::VmstatCounters_IsValid(value));
  vmstat_counters_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.SysStatsConfig.vmstat_counters)
}
 const ::google::protobuf::RepeatedField<int>&
SysStatsConfig::vmstat_counters() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.SysStatsConfig.vmstat_counters)
  return vmstat_counters_;
}
 ::google::protobuf::RepeatedField<int>*
SysStatsConfig::mutable_vmstat_counters() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.SysStatsConfig.vmstat_counters)
  return &vmstat_counters_;
}

// optional uint32 stat_period_ms = 5;
bool SysStatsConfig::has_stat_period_ms() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void SysStatsConfig::set_has_stat_period_ms() {
  _has_bits_[0] |= 0x00000010u;
}
void SysStatsConfig::clear_has_stat_period_ms() {
  _has_bits_[0] &= ~0x00000010u;
}
void SysStatsConfig::clear_stat_period_ms() {
  stat_period_ms_ = 0u;
  clear_has_stat_period_ms();
}
 ::google::protobuf::uint32 SysStatsConfig::stat_period_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SysStatsConfig.stat_period_ms)
  return stat_period_ms_;
}
 void SysStatsConfig::set_stat_period_ms(::google::protobuf::uint32 value) {
  set_has_stat_period_ms();
  stat_period_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.SysStatsConfig.stat_period_ms)
}

// repeated .perfetto.protos.SysStatsConfig.StatCounters stat_counters = 6;
int SysStatsConfig::stat_counters_size() const {
  return stat_counters_.size();
}
void SysStatsConfig::clear_stat_counters() {
  stat_counters_.Clear();
}
 ::perfetto::protos::SysStatsConfig_StatCounters SysStatsConfig::stat_counters(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SysStatsConfig.stat_counters)
  return static_cast< ::perfetto::protos::SysStatsConfig_StatCounters >(stat_counters_.Get(index));
}
 void SysStatsConfig::set_stat_counters(int index, ::perfetto::protos::SysStatsConfig_StatCounters value) {
  assert(::perfetto::protos::SysStatsConfig_StatCounters_IsValid(value));
  stat_counters_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.SysStatsConfig.stat_counters)
}
 void SysStatsConfig::add_stat_counters(::perfetto::protos::SysStatsConfig_StatCounters value) {
  assert(::perfetto::protos::SysStatsConfig_StatCounters_IsValid(value));
  stat_counters_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.SysStatsConfig.stat_counters)
}
 const ::google::protobuf::RepeatedField<int>&
SysStatsConfig::stat_counters() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.SysStatsConfig.stat_counters)
  return stat_counters_;
}
 ::google::protobuf::RepeatedField<int>*
SysStatsConfig::mutable_stat_counters() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.SysStatsConfig.stat_counters)
  return &stat_counters_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/config/test_config.pb.cc
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/config/test_config.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
// gen_amalgamated expanded: #include "perfetto/config/test_config.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

void protobuf_ShutdownFile_perfetto_2fconfig_2ftest_5fconfig_2eproto() {
  delete TestConfig::default_instance_;
  delete TestConfig_DummyFields::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_perfetto_2fconfig_2ftest_5fconfig_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_perfetto_2fconfig_2ftest_5fconfig_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  TestConfig::default_instance_ = new TestConfig();
  TestConfig_DummyFields::default_instance_ = new TestConfig_DummyFields();
  TestConfig::default_instance_->InitAsDefaultInstance();
  TestConfig_DummyFields::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_perfetto_2fconfig_2ftest_5fconfig_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_perfetto_2fconfig_2ftest_5fconfig_2eproto_once_);
void protobuf_AddDesc_perfetto_2fconfig_2ftest_5fconfig_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_perfetto_2fconfig_2ftest_5fconfig_2eproto_once_,
                 &protobuf_AddDesc_perfetto_2fconfig_2ftest_5fconfig_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_perfetto_2fconfig_2ftest_5fconfig_2eproto {
  StaticDescriptorInitializer_perfetto_2fconfig_2ftest_5fconfig_2eproto() {
    protobuf_AddDesc_perfetto_2fconfig_2ftest_5fconfig_2eproto();
  }
} static_descriptor_initializer_perfetto_2fconfig_2ftest_5fconfig_2eproto_;
#endif

namespace {

static void test_config_pb_MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
static void test_config_pb_MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

static ::std::string* MutableUnknownFieldsForTestConfig(
    TestConfig* ptr) {
  return ptr->mutable_unknown_fields();
}

static ::std::string* MutableUnknownFieldsForTestConfig_DummyFields(
    TestConfig_DummyFields* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TestConfig_DummyFields::kFieldUint32FieldNumber;
const int TestConfig_DummyFields::kFieldInt32FieldNumber;
const int TestConfig_DummyFields::kFieldUint64FieldNumber;
const int TestConfig_DummyFields::kFieldInt64FieldNumber;
const int TestConfig_DummyFields::kFieldFixed64FieldNumber;
const int TestConfig_DummyFields::kFieldSfixed64FieldNumber;
const int TestConfig_DummyFields::kFieldFixed32FieldNumber;
const int TestConfig_DummyFields::kFieldSfixed32FieldNumber;
const int TestConfig_DummyFields::kFieldDoubleFieldNumber;
const int TestConfig_DummyFields::kFieldFloatFieldNumber;
const int TestConfig_DummyFields::kFieldSint64FieldNumber;
const int TestConfig_DummyFields::kFieldSint32FieldNumber;
const int TestConfig_DummyFields::kFieldStringFieldNumber;
const int TestConfig_DummyFields::kFieldBytesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TestConfig_DummyFields::TestConfig_DummyFields()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.TestConfig.DummyFields)
}

void TestConfig_DummyFields::InitAsDefaultInstance() {
}

TestConfig_DummyFields::TestConfig_DummyFields(const TestConfig_DummyFields& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.TestConfig.DummyFields)
}

void TestConfig_DummyFields::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  field_uint32_ = 0u;
  field_int32_ = 0;
  field_uint64_ = GOOGLE_ULONGLONG(0);
  field_int64_ = GOOGLE_LONGLONG(0);
  field_fixed64_ = GOOGLE_ULONGLONG(0);
  field_sfixed64_ = GOOGLE_LONGLONG(0);
  field_fixed32_ = 0u;
  field_sfixed32_ = 0;
  field_double_ = 0;
  field_float_ = 0;
  field_sint64_ = GOOGLE_LONGLONG(0);
  field_sint32_ = 0;
  field_string_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  field_bytes_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TestConfig_DummyFields::~TestConfig_DummyFields() {
  // @@protoc_insertion_point(destructor:perfetto.protos.TestConfig.DummyFields)
  SharedDtor();
}

void TestConfig_DummyFields::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  field_string_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  field_bytes_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TestConfig_DummyFields::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TestConfig_DummyFields& TestConfig_DummyFields::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fconfig_2ftest_5fconfig_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fconfig_2ftest_5fconfig_2eproto();
#endif
  return *default_instance_;
}

TestConfig_DummyFields* TestConfig_DummyFields::default_instance_ = NULL;

TestConfig_DummyFields* TestConfig_DummyFields::New(::google::protobuf::Arena* arena) const {
  TestConfig_DummyFields* n = new TestConfig_DummyFields;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TestConfig_DummyFields::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.TestConfig.DummyFields)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(TestConfig_DummyFields, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<TestConfig_DummyFields*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    ZR_(field_uint32_, field_sfixed32_);
  }
  if (_has_bits_[8 / 32] & 16128u) {
    ZR_(field_double_, field_sint32_);
    if (has_field_string()) {
      field_string_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_field_bytes()) {
      field_bytes_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool TestConfig_DummyFields::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForTestConfig_DummyFields, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.TestConfig.DummyFields)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 field_uint32 = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &field_uint32_)));
          set_has_field_uint32();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_field_int32;
        break;
      }

      // optional int32 field_int32 = 2;
      case 2: {
        if (tag == 16) {
         parse_field_int32:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &field_int32_)));
          set_has_field_int32();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_field_uint64;
        break;
      }

      // optional uint64 field_uint64 = 3;
      case 3: {
        if (tag == 24) {
         parse_field_uint64:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &field_uint64_)));
          set_has_field_uint64();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_field_int64;
        break;
      }

      // optional int64 field_int64 = 4;
      case 4: {
        if (tag == 32) {
         parse_field_int64:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &field_int64_)));
          set_has_field_int64();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(41)) goto parse_field_fixed64;
        break;
      }

      // optional fixed64 field_fixed64 = 5;
      case 5: {
        if (tag == 41) {
         parse_field_fixed64:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED64>(
                 input, &field_fixed64_)));
          set_has_field_fixed64();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(49)) goto parse_field_sfixed64;
        break;
      }

      // optional sfixed64 field_sfixed64 = 6;
      case 6: {
        if (tag == 49) {
         parse_field_sfixed64:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_SFIXED64>(
                 input, &field_sfixed64_)));
          set_has_field_sfixed64();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(61)) goto parse_field_fixed32;
        break;
      }

      // optional fixed32 field_fixed32 = 7;
      case 7: {
        if (tag == 61) {
         parse_field_fixed32:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &field_fixed32_)));
          set_has_field_fixed32();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(69)) goto parse_field_sfixed32;
        break;
      }

      // optional sfixed32 field_sfixed32 = 8;
      case 8: {
        if (tag == 69) {
         parse_field_sfixed32:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SFIXED32>(
                 input, &field_sfixed32_)));
          set_has_field_sfixed32();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(73)) goto parse_field_double;
        break;
      }

      // optional double field_double = 9;
      case 9: {
        if (tag == 73) {
         parse_field_double:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &field_double_)));
          set_has_field_double();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(85)) goto parse_field_float;
        break;
      }

      // optional float field_float = 10;
      case 10: {
        if (tag == 85) {
         parse_field_float:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &field_float_)));
          set_has_field_float();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_field_sint64;
        break;
      }

      // optional sint64 field_sint64 = 11;
      case 11: {
        if (tag == 88) {
         parse_field_sint64:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_SINT64>(
                 input, &field_sint64_)));
          set_has_field_sint64();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_field_sint32;
        break;
      }

      // optional sint32 field_sint32 = 12;
      case 12: {
        if (tag == 96) {
         parse_field_sint32:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &field_sint32_)));
          set_has_field_sint32();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(106)) goto parse_field_string;
        break;
      }

      // optional string field_string = 13;
      case 13: {
        if (tag == 106) {
         parse_field_string:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_field_string()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(114)) goto parse_field_bytes;
        break;
      }

      // optional bytes field_bytes = 14;
      case 14: {
        if (tag == 114) {
         parse_field_bytes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_field_bytes()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.TestConfig.DummyFields)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.TestConfig.DummyFields)
  return false;
#undef DO_
}

void TestConfig_DummyFields::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.TestConfig.DummyFields)
  // optional uint32 field_uint32 = 1;
  if (has_field_uint32()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->field_uint32(), output);
  }

  // optional int32 field_int32 = 2;
  if (has_field_int32()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->field_int32(), output);
  }

  // optional uint64 field_uint64 = 3;
  if (has_field_uint64()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->field_uint64(), output);
  }

  // optional int64 field_int64 = 4;
  if (has_field_int64()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(4, this->field_int64(), output);
  }

  // optional fixed64 field_fixed64 = 5;
  if (has_field_fixed64()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed64(5, this->field_fixed64(), output);
  }

  // optional sfixed64 field_sfixed64 = 6;
  if (has_field_sfixed64()) {
    ::google::protobuf::internal::WireFormatLite::WriteSFixed64(6, this->field_sfixed64(), output);
  }

  // optional fixed32 field_fixed32 = 7;
  if (has_field_fixed32()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(7, this->field_fixed32(), output);
  }

  // optional sfixed32 field_sfixed32 = 8;
  if (has_field_sfixed32()) {
    ::google::protobuf::internal::WireFormatLite::WriteSFixed32(8, this->field_sfixed32(), output);
  }

  // optional double field_double = 9;
  if (has_field_double()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(9, this->field_double(), output);
  }

  // optional float field_float = 10;
  if (has_field_float()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(10, this->field_float(), output);
  }

  // optional sint64 field_sint64 = 11;
  if (has_field_sint64()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt64(11, this->field_sint64(), output);
  }

  // optional sint32 field_sint32 = 12;
  if (has_field_sint32()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(12, this->field_sint32(), output);
  }

  // optional string field_string = 13;
  if (has_field_string()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      13, this->field_string(), output);
  }

  // optional bytes field_bytes = 14;
  if (has_field_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      14, this->field_bytes(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.TestConfig.DummyFields)
}

int TestConfig_DummyFields::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.TestConfig.DummyFields)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 255u) {
    // optional uint32 field_uint32 = 1;
    if (has_field_uint32()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->field_uint32());
    }

    // optional int32 field_int32 = 2;
    if (has_field_int32()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->field_int32());
    }

    // optional uint64 field_uint64 = 3;
    if (has_field_uint64()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->field_uint64());
    }

    // optional int64 field_int64 = 4;
    if (has_field_int64()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->field_int64());
    }

    // optional fixed64 field_fixed64 = 5;
    if (has_field_fixed64()) {
      total_size += 1 + 8;
    }

    // optional sfixed64 field_sfixed64 = 6;
    if (has_field_sfixed64()) {
      total_size += 1 + 8;
    }

    // optional fixed32 field_fixed32 = 7;
    if (has_field_fixed32()) {
      total_size += 1 + 4;
    }

    // optional sfixed32 field_sfixed32 = 8;
    if (has_field_sfixed32()) {
      total_size += 1 + 4;
    }

  }
  if (_has_bits_[8 / 32] & 16128u) {
    // optional double field_double = 9;
    if (has_field_double()) {
      total_size += 1 + 8;
    }

    // optional float field_float = 10;
    if (has_field_float()) {
      total_size += 1 + 4;
    }

    // optional sint64 field_sint64 = 11;
    if (has_field_sint64()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt64Size(
          this->field_sint64());
    }

    // optional sint32 field_sint32 = 12;
    if (has_field_sint32()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->field_sint32());
    }

    // optional string field_string = 13;
    if (has_field_string()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->field_string());
    }

    // optional bytes field_bytes = 14;
    if (has_field_bytes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->field_bytes());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TestConfig_DummyFields::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TestConfig_DummyFields*>(&from));
}

void TestConfig_DummyFields::MergeFrom(const TestConfig_DummyFields& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.TestConfig.DummyFields)
  if (GOOGLE_PREDICT_FALSE(&from == this)) test_config_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_field_uint32()) {
      set_field_uint32(from.field_uint32());
    }
    if (from.has_field_int32()) {
      set_field_int32(from.field_int32());
    }
    if (from.has_field_uint64()) {
      set_field_uint64(from.field_uint64());
    }
    if (from.has_field_int64()) {
      set_field_int64(from.field_int64());
    }
    if (from.has_field_fixed64()) {
      set_field_fixed64(from.field_fixed64());
    }
    if (from.has_field_sfixed64()) {
      set_field_sfixed64(from.field_sfixed64());
    }
    if (from.has_field_fixed32()) {
      set_field_fixed32(from.field_fixed32());
    }
    if (from.has_field_sfixed32()) {
      set_field_sfixed32(from.field_sfixed32());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_field_double()) {
      set_field_double(from.field_double());
    }
    if (from.has_field_float()) {
      set_field_float(from.field_float());
    }
    if (from.has_field_sint64()) {
      set_field_sint64(from.field_sint64());
    }
    if (from.has_field_sint32()) {
      set_field_sint32(from.field_sint32());
    }
    if (from.has_field_string()) {
      set_has_field_string();
      field_string_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.field_string_);
    }
    if (from.has_field_bytes()) {
      set_has_field_bytes();
      field_bytes_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.field_bytes_);
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void TestConfig_DummyFields::CopyFrom(const TestConfig_DummyFields& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.TestConfig.DummyFields)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TestConfig_DummyFields::IsInitialized() const {

  return true;
}

void TestConfig_DummyFields::Swap(TestConfig_DummyFields* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TestConfig_DummyFields::InternalSwap(TestConfig_DummyFields* other) {
  std::swap(field_uint32_, other->field_uint32_);
  std::swap(field_int32_, other->field_int32_);
  std::swap(field_uint64_, other->field_uint64_);
  std::swap(field_int64_, other->field_int64_);
  std::swap(field_fixed64_, other->field_fixed64_);
  std::swap(field_sfixed64_, other->field_sfixed64_);
  std::swap(field_fixed32_, other->field_fixed32_);
  std::swap(field_sfixed32_, other->field_sfixed32_);
  std::swap(field_double_, other->field_double_);
  std::swap(field_float_, other->field_float_);
  std::swap(field_sint64_, other->field_sint64_);
  std::swap(field_sint32_, other->field_sint32_);
  field_string_.Swap(&other->field_string_);
  field_bytes_.Swap(&other->field_bytes_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string TestConfig_DummyFields::GetTypeName() const {
  return "perfetto.protos.TestConfig.DummyFields";
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TestConfig::kMessageCountFieldNumber;
const int TestConfig::kMaxMessagesPerSecondFieldNumber;
const int TestConfig::kSeedFieldNumber;
const int TestConfig::kMessageSizeFieldNumber;
const int TestConfig::kSendBatchOnRegisterFieldNumber;
const int TestConfig::kDummyFieldsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TestConfig::TestConfig()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.TestConfig)
}

void TestConfig::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  dummy_fields_ = const_cast< ::perfetto::protos::TestConfig_DummyFields*>(
      ::perfetto::protos::TestConfig_DummyFields::internal_default_instance());
#else
  dummy_fields_ = const_cast< ::perfetto::protos::TestConfig_DummyFields*>(&::perfetto::protos::TestConfig_DummyFields::default_instance());
#endif
}

TestConfig::TestConfig(const TestConfig& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.TestConfig)
}

void TestConfig::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  message_count_ = 0u;
  max_messages_per_second_ = 0u;
  seed_ = 0u;
  message_size_ = 0u;
  send_batch_on_register_ = false;
  dummy_fields_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TestConfig::~TestConfig() {
  // @@protoc_insertion_point(destructor:perfetto.protos.TestConfig)
  SharedDtor();
}

void TestConfig::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete dummy_fields_;
  }
}

void TestConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TestConfig& TestConfig::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fconfig_2ftest_5fconfig_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fconfig_2ftest_5fconfig_2eproto();
#endif
  return *default_instance_;
}

TestConfig* TestConfig::default_instance_ = NULL;

TestConfig* TestConfig::New(::google::protobuf::Arena* arena) const {
  TestConfig* n = new TestConfig;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TestConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.TestConfig)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(TestConfig, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<TestConfig*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 63u) {
    ZR_(message_count_, message_size_);
    send_batch_on_register_ = false;
    if (has_dummy_fields()) {
      if (dummy_fields_ != NULL) dummy_fields_->::perfetto::protos::TestConfig_DummyFields::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool TestConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForTestConfig, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.TestConfig)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 message_count = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &message_count_)));
          set_has_message_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_max_messages_per_second;
        break;
      }

      // optional uint32 max_messages_per_second = 2;
      case 2: {
        if (tag == 16) {
         parse_max_messages_per_second:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &max_messages_per_second_)));
          set_has_max_messages_per_second();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_seed;
        break;
      }

      // optional uint32 seed = 3;
      case 3: {
        if (tag == 24) {
         parse_seed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &seed_)));
          set_has_seed();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_message_size;
        break;
      }

      // optional uint32 message_size = 4;
      case 4: {
        if (tag == 32) {
         parse_message_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &message_size_)));
          set_has_message_size();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_send_batch_on_register;
        break;
      }

      // optional bool send_batch_on_register = 5;
      case 5: {
        if (tag == 40) {
         parse_send_batch_on_register:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &send_batch_on_register_)));
          set_has_send_batch_on_register();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_dummy_fields;
        break;
      }

      // optional .perfetto.protos.TestConfig.DummyFields dummy_fields = 6;
      case 6: {
        if (tag == 50) {
         parse_dummy_fields:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_dummy_fields()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.TestConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.TestConfig)
  return false;
#undef DO_
}

void TestConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.TestConfig)
  // optional uint32 message_count = 1;
  if (has_message_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->message_count(), output);
  }

  // optional uint32 max_messages_per_second = 2;
  if (has_max_messages_per_second()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->max_messages_per_second(), output);
  }

  // optional uint32 seed = 3;
  if (has_seed()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->seed(), output);
  }

  // optional uint32 message_size = 4;
  if (has_message_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->message_size(), output);
  }

  // optional bool send_batch_on_register = 5;
  if (has_send_batch_on_register()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->send_batch_on_register(), output);
  }

  // optional .perfetto.protos.TestConfig.DummyFields dummy_fields = 6;
  if (has_dummy_fields()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, *this->dummy_fields_, output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.TestConfig)
}

int TestConfig::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.TestConfig)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 63u) {
    // optional uint32 message_count = 1;
    if (has_message_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->message_count());
    }

    // optional uint32 max_messages_per_second = 2;
    if (has_max_messages_per_second()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->max_messages_per_second());
    }

    // optional uint32 seed = 3;
    if (has_seed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->seed());
    }

    // optional uint32 message_size = 4;
    if (has_message_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->message_size());
    }

    // optional bool send_batch_on_register = 5;
    if (has_send_batch_on_register()) {
      total_size += 1 + 1;
    }

    // optional .perfetto.protos.TestConfig.DummyFields dummy_fields = 6;
    if (has_dummy_fields()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->dummy_fields_);
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TestConfig::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TestConfig*>(&from));
}

void TestConfig::MergeFrom(const TestConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.TestConfig)
  if (GOOGLE_PREDICT_FALSE(&from == this)) test_config_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_message_count()) {
      set_message_count(from.message_count());
    }
    if (from.has_max_messages_per_second()) {
      set_max_messages_per_second(from.max_messages_per_second());
    }
    if (from.has_seed()) {
      set_seed(from.seed());
    }
    if (from.has_message_size()) {
      set_message_size(from.message_size());
    }
    if (from.has_send_batch_on_register()) {
      set_send_batch_on_register(from.send_batch_on_register());
    }
    if (from.has_dummy_fields()) {
      mutable_dummy_fields()->::perfetto::protos::TestConfig_DummyFields::MergeFrom(from.dummy_fields());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void TestConfig::CopyFrom(const TestConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.TestConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TestConfig::IsInitialized() const {

  return true;
}

void TestConfig::Swap(TestConfig* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TestConfig::InternalSwap(TestConfig* other) {
  std::swap(message_count_, other->message_count_);
  std::swap(max_messages_per_second_, other->max_messages_per_second_);
  std::swap(seed_, other->seed_);
  std::swap(message_size_, other->message_size_);
  std::swap(send_batch_on_register_, other->send_batch_on_register_);
  std::swap(dummy_fields_, other->dummy_fields_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string TestConfig::GetTypeName() const {
  return "perfetto.protos.TestConfig";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TestConfig_DummyFields

// optional uint32 field_uint32 = 1;
bool TestConfig_DummyFields::has_field_uint32() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TestConfig_DummyFields::set_has_field_uint32() {
  _has_bits_[0] |= 0x00000001u;
}
void TestConfig_DummyFields::clear_has_field_uint32() {
  _has_bits_[0] &= ~0x00000001u;
}
void TestConfig_DummyFields::clear_field_uint32() {
  field_uint32_ = 0u;
  clear_has_field_uint32();
}
 ::google::protobuf::uint32 TestConfig_DummyFields::field_uint32() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_uint32)
  return field_uint32_;
}
 void TestConfig_DummyFields::set_field_uint32(::google::protobuf::uint32 value) {
  set_has_field_uint32();
  field_uint32_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_uint32)
}

// optional int32 field_int32 = 2;
bool TestConfig_DummyFields::has_field_int32() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void TestConfig_DummyFields::set_has_field_int32() {
  _has_bits_[0] |= 0x00000002u;
}
void TestConfig_DummyFields::clear_has_field_int32() {
  _has_bits_[0] &= ~0x00000002u;
}
void TestConfig_DummyFields::clear_field_int32() {
  field_int32_ = 0;
  clear_has_field_int32();
}
 ::google::protobuf::int32 TestConfig_DummyFields::field_int32() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_int32)
  return field_int32_;
}
 void TestConfig_DummyFields::set_field_int32(::google::protobuf::int32 value) {
  set_has_field_int32();
  field_int32_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_int32)
}

// optional uint64 field_uint64 = 3;
bool TestConfig_DummyFields::has_field_uint64() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void TestConfig_DummyFields::set_has_field_uint64() {
  _has_bits_[0] |= 0x00000004u;
}
void TestConfig_DummyFields::clear_has_field_uint64() {
  _has_bits_[0] &= ~0x00000004u;
}
void TestConfig_DummyFields::clear_field_uint64() {
  field_uint64_ = GOOGLE_ULONGLONG(0);
  clear_has_field_uint64();
}
 ::google::protobuf::uint64 TestConfig_DummyFields::field_uint64() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_uint64)
  return field_uint64_;
}
 void TestConfig_DummyFields::set_field_uint64(::google::protobuf::uint64 value) {
  set_has_field_uint64();
  field_uint64_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_uint64)
}

// optional int64 field_int64 = 4;
bool TestConfig_DummyFields::has_field_int64() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void TestConfig_DummyFields::set_has_field_int64() {
  _has_bits_[0] |= 0x00000008u;
}
void TestConfig_DummyFields::clear_has_field_int64() {
  _has_bits_[0] &= ~0x00000008u;
}
void TestConfig_DummyFields::clear_field_int64() {
  field_int64_ = GOOGLE_LONGLONG(0);
  clear_has_field_int64();
}
 ::google::protobuf::int64 TestConfig_DummyFields::field_int64() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_int64)
  return field_int64_;
}
 void TestConfig_DummyFields::set_field_int64(::google::protobuf::int64 value) {
  set_has_field_int64();
  field_int64_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_int64)
}

// optional fixed64 field_fixed64 = 5;
bool TestConfig_DummyFields::has_field_fixed64() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void TestConfig_DummyFields::set_has_field_fixed64() {
  _has_bits_[0] |= 0x00000010u;
}
void TestConfig_DummyFields::clear_has_field_fixed64() {
  _has_bits_[0] &= ~0x00000010u;
}
void TestConfig_DummyFields::clear_field_fixed64() {
  field_fixed64_ = GOOGLE_ULONGLONG(0);
  clear_has_field_fixed64();
}
 ::google::protobuf::uint64 TestConfig_DummyFields::field_fixed64() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_fixed64)
  return field_fixed64_;
}
 void TestConfig_DummyFields::set_field_fixed64(::google::protobuf::uint64 value) {
  set_has_field_fixed64();
  field_fixed64_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_fixed64)
}

// optional sfixed64 field_sfixed64 = 6;
bool TestConfig_DummyFields::has_field_sfixed64() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void TestConfig_DummyFields::set_has_field_sfixed64() {
  _has_bits_[0] |= 0x00000020u;
}
void TestConfig_DummyFields::clear_has_field_sfixed64() {
  _has_bits_[0] &= ~0x00000020u;
}
void TestConfig_DummyFields::clear_field_sfixed64() {
  field_sfixed64_ = GOOGLE_LONGLONG(0);
  clear_has_field_sfixed64();
}
 ::google::protobuf::int64 TestConfig_DummyFields::field_sfixed64() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_sfixed64)
  return field_sfixed64_;
}
 void TestConfig_DummyFields::set_field_sfixed64(::google::protobuf::int64 value) {
  set_has_field_sfixed64();
  field_sfixed64_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_sfixed64)
}

// optional fixed32 field_fixed32 = 7;
bool TestConfig_DummyFields::has_field_fixed32() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void TestConfig_DummyFields::set_has_field_fixed32() {
  _has_bits_[0] |= 0x00000040u;
}
void TestConfig_DummyFields::clear_has_field_fixed32() {
  _has_bits_[0] &= ~0x00000040u;
}
void TestConfig_DummyFields::clear_field_fixed32() {
  field_fixed32_ = 0u;
  clear_has_field_fixed32();
}
 ::google::protobuf::uint32 TestConfig_DummyFields::field_fixed32() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_fixed32)
  return field_fixed32_;
}
 void TestConfig_DummyFields::set_field_fixed32(::google::protobuf::uint32 value) {
  set_has_field_fixed32();
  field_fixed32_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_fixed32)
}

// optional sfixed32 field_sfixed32 = 8;
bool TestConfig_DummyFields::has_field_sfixed32() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void TestConfig_DummyFields::set_has_field_sfixed32() {
  _has_bits_[0] |= 0x00000080u;
}
void TestConfig_DummyFields::clear_has_field_sfixed32() {
  _has_bits_[0] &= ~0x00000080u;
}
void TestConfig_DummyFields::clear_field_sfixed32() {
  field_sfixed32_ = 0;
  clear_has_field_sfixed32();
}
 ::google::protobuf::int32 TestConfig_DummyFields::field_sfixed32() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_sfixed32)
  return field_sfixed32_;
}
 void TestConfig_DummyFields::set_field_sfixed32(::google::protobuf::int32 value) {
  set_has_field_sfixed32();
  field_sfixed32_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_sfixed32)
}

// optional double field_double = 9;
bool TestConfig_DummyFields::has_field_double() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void TestConfig_DummyFields::set_has_field_double() {
  _has_bits_[0] |= 0x00000100u;
}
void TestConfig_DummyFields::clear_has_field_double() {
  _has_bits_[0] &= ~0x00000100u;
}
void TestConfig_DummyFields::clear_field_double() {
  field_double_ = 0;
  clear_has_field_double();
}
 double TestConfig_DummyFields::field_double() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_double)
  return field_double_;
}
 void TestConfig_DummyFields::set_field_double(double value) {
  set_has_field_double();
  field_double_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_double)
}

// optional float field_float = 10;
bool TestConfig_DummyFields::has_field_float() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void TestConfig_DummyFields::set_has_field_float() {
  _has_bits_[0] |= 0x00000200u;
}
void TestConfig_DummyFields::clear_has_field_float() {
  _has_bits_[0] &= ~0x00000200u;
}
void TestConfig_DummyFields::clear_field_float() {
  field_float_ = 0;
  clear_has_field_float();
}
 float TestConfig_DummyFields::field_float() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_float)
  return field_float_;
}
 void TestConfig_DummyFields::set_field_float(float value) {
  set_has_field_float();
  field_float_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_float)
}

// optional sint64 field_sint64 = 11;
bool TestConfig_DummyFields::has_field_sint64() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
void TestConfig_DummyFields::set_has_field_sint64() {
  _has_bits_[0] |= 0x00000400u;
}
void TestConfig_DummyFields::clear_has_field_sint64() {
  _has_bits_[0] &= ~0x00000400u;
}
void TestConfig_DummyFields::clear_field_sint64() {
  field_sint64_ = GOOGLE_LONGLONG(0);
  clear_has_field_sint64();
}
 ::google::protobuf::int64 TestConfig_DummyFields::field_sint64() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_sint64)
  return field_sint64_;
}
 void TestConfig_DummyFields::set_field_sint64(::google::protobuf::int64 value) {
  set_has_field_sint64();
  field_sint64_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_sint64)
}

// optional sint32 field_sint32 = 12;
bool TestConfig_DummyFields::has_field_sint32() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
void TestConfig_DummyFields::set_has_field_sint32() {
  _has_bits_[0] |= 0x00000800u;
}
void TestConfig_DummyFields::clear_has_field_sint32() {
  _has_bits_[0] &= ~0x00000800u;
}
void TestConfig_DummyFields::clear_field_sint32() {
  field_sint32_ = 0;
  clear_has_field_sint32();
}
 ::google::protobuf::int32 TestConfig_DummyFields::field_sint32() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_sint32)
  return field_sint32_;
}
 void TestConfig_DummyFields::set_field_sint32(::google::protobuf::int32 value) {
  set_has_field_sint32();
  field_sint32_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_sint32)
}

// optional string field_string = 13;
bool TestConfig_DummyFields::has_field_string() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
void TestConfig_DummyFields::set_has_field_string() {
  _has_bits_[0] |= 0x00001000u;
}
void TestConfig_DummyFields::clear_has_field_string() {
  _has_bits_[0] &= ~0x00001000u;
}
void TestConfig_DummyFields::clear_field_string() {
  field_string_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_field_string();
}
 const ::std::string& TestConfig_DummyFields::field_string() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_string)
  return field_string_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TestConfig_DummyFields::set_field_string(const ::std::string& value) {
  set_has_field_string();
  field_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_string)
}
 void TestConfig_DummyFields::set_field_string(const char* value) {
  set_has_field_string();
  field_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.TestConfig.DummyFields.field_string)
}
 void TestConfig_DummyFields::set_field_string(const char* value, size_t size) {
  set_has_field_string();
  field_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.TestConfig.DummyFields.field_string)
}
 ::std::string* TestConfig_DummyFields::mutable_field_string() {
  set_has_field_string();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TestConfig.DummyFields.field_string)
  return field_string_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* TestConfig_DummyFields::release_field_string() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TestConfig.DummyFields.field_string)
  clear_has_field_string();
  return field_string_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TestConfig_DummyFields::set_allocated_field_string(::std::string* field_string) {
  if (field_string != NULL) {
    set_has_field_string();
  } else {
    clear_has_field_string();
  }
  field_string_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), field_string);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TestConfig.DummyFields.field_string)
}

// optional bytes field_bytes = 14;
bool TestConfig_DummyFields::has_field_bytes() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
void TestConfig_DummyFields::set_has_field_bytes() {
  _has_bits_[0] |= 0x00002000u;
}
void TestConfig_DummyFields::clear_has_field_bytes() {
  _has_bits_[0] &= ~0x00002000u;
}
void TestConfig_DummyFields::clear_field_bytes() {
  field_bytes_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_field_bytes();
}
 const ::std::string& TestConfig_DummyFields::field_bytes() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.DummyFields.field_bytes)
  return field_bytes_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TestConfig_DummyFields::set_field_bytes(const ::std::string& value) {
  set_has_field_bytes();
  field_bytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.DummyFields.field_bytes)
}
 void TestConfig_DummyFields::set_field_bytes(const char* value) {
  set_has_field_bytes();
  field_bytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.TestConfig.DummyFields.field_bytes)
}
 void TestConfig_DummyFields::set_field_bytes(const void* value, size_t size) {
  set_has_field_bytes();
  field_bytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.TestConfig.DummyFields.field_bytes)
}
 ::std::string* TestConfig_DummyFields::mutable_field_bytes() {
  set_has_field_bytes();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TestConfig.DummyFields.field_bytes)
  return field_bytes_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* TestConfig_DummyFields::release_field_bytes() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TestConfig.DummyFields.field_bytes)
  clear_has_field_bytes();
  return field_bytes_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TestConfig_DummyFields::set_allocated_field_bytes(::std::string* field_bytes) {
  if (field_bytes != NULL) {
    set_has_field_bytes();
  } else {
    clear_has_field_bytes();
  }
  field_bytes_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), field_bytes);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TestConfig.DummyFields.field_bytes)
}

// -------------------------------------------------------------------

// TestConfig

// optional uint32 message_count = 1;
bool TestConfig::has_message_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TestConfig::set_has_message_count() {
  _has_bits_[0] |= 0x00000001u;
}
void TestConfig::clear_has_message_count() {
  _has_bits_[0] &= ~0x00000001u;
}
void TestConfig::clear_message_count() {
  message_count_ = 0u;
  clear_has_message_count();
}
 ::google::protobuf::uint32 TestConfig::message_count() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.message_count)
  return message_count_;
}
 void TestConfig::set_message_count(::google::protobuf::uint32 value) {
  set_has_message_count();
  message_count_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.message_count)
}

// optional uint32 max_messages_per_second = 2;
bool TestConfig::has_max_messages_per_second() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void TestConfig::set_has_max_messages_per_second() {
  _has_bits_[0] |= 0x00000002u;
}
void TestConfig::clear_has_max_messages_per_second() {
  _has_bits_[0] &= ~0x00000002u;
}
void TestConfig::clear_max_messages_per_second() {
  max_messages_per_second_ = 0u;
  clear_has_max_messages_per_second();
}
 ::google::protobuf::uint32 TestConfig::max_messages_per_second() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.max_messages_per_second)
  return max_messages_per_second_;
}
 void TestConfig::set_max_messages_per_second(::google::protobuf::uint32 value) {
  set_has_max_messages_per_second();
  max_messages_per_second_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.max_messages_per_second)
}

// optional uint32 seed = 3;
bool TestConfig::has_seed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void TestConfig::set_has_seed() {
  _has_bits_[0] |= 0x00000004u;
}
void TestConfig::clear_has_seed() {
  _has_bits_[0] &= ~0x00000004u;
}
void TestConfig::clear_seed() {
  seed_ = 0u;
  clear_has_seed();
}
 ::google::protobuf::uint32 TestConfig::seed() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.seed)
  return seed_;
}
 void TestConfig::set_seed(::google::protobuf::uint32 value) {
  set_has_seed();
  seed_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.seed)
}

// optional uint32 message_size = 4;
bool TestConfig::has_message_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void TestConfig::set_has_message_size() {
  _has_bits_[0] |= 0x00000008u;
}
void TestConfig::clear_has_message_size() {
  _has_bits_[0] &= ~0x00000008u;
}
void TestConfig::clear_message_size() {
  message_size_ = 0u;
  clear_has_message_size();
}
 ::google::protobuf::uint32 TestConfig::message_size() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.message_size)
  return message_size_;
}
 void TestConfig::set_message_size(::google::protobuf::uint32 value) {
  set_has_message_size();
  message_size_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.message_size)
}

// optional bool send_batch_on_register = 5;
bool TestConfig::has_send_batch_on_register() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void TestConfig::set_has_send_batch_on_register() {
  _has_bits_[0] |= 0x00000010u;
}
void TestConfig::clear_has_send_batch_on_register() {
  _has_bits_[0] &= ~0x00000010u;
}
void TestConfig::clear_send_batch_on_register() {
  send_batch_on_register_ = false;
  clear_has_send_batch_on_register();
}
 bool TestConfig::send_batch_on_register() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.send_batch_on_register)
  return send_batch_on_register_;
}
 void TestConfig::set_send_batch_on_register(bool value) {
  set_has_send_batch_on_register();
  send_batch_on_register_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TestConfig.send_batch_on_register)
}

// optional .perfetto.protos.TestConfig.DummyFields dummy_fields = 6;
bool TestConfig::has_dummy_fields() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void TestConfig::set_has_dummy_fields() {
  _has_bits_[0] |= 0x00000020u;
}
void TestConfig::clear_has_dummy_fields() {
  _has_bits_[0] &= ~0x00000020u;
}
void TestConfig::clear_dummy_fields() {
  if (dummy_fields_ != NULL) dummy_fields_->::perfetto::protos::TestConfig_DummyFields::Clear();
  clear_has_dummy_fields();
}
const ::perfetto::protos::TestConfig_DummyFields& TestConfig::dummy_fields() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TestConfig.dummy_fields)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return dummy_fields_ != NULL ? *dummy_fields_ : *default_instance().dummy_fields_;
#else
  return dummy_fields_ != NULL ? *dummy_fields_ : *default_instance_->dummy_fields_;
#endif
}
::perfetto::protos::TestConfig_DummyFields* TestConfig::mutable_dummy_fields() {
  set_has_dummy_fields();
  if (dummy_fields_ == NULL) {
    dummy_fields_ = new ::perfetto::protos::TestConfig_DummyFields;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TestConfig.dummy_fields)
  return dummy_fields_;
}
::perfetto::protos::TestConfig_DummyFields* TestConfig::release_dummy_fields() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TestConfig.dummy_fields)
  clear_has_dummy_fields();
  ::perfetto::protos::TestConfig_DummyFields* temp = dummy_fields_;
  dummy_fields_ = NULL;
  return temp;
}
void TestConfig::set_allocated_dummy_fields(::perfetto::protos::TestConfig_DummyFields* dummy_fields) {
  delete dummy_fields_;
  dummy_fields_ = dummy_fields;
  if (dummy_fields) {
    set_has_dummy_fields();
  } else {
    clear_has_dummy_fields();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TestConfig.dummy_fields)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/config/trace_config.pb.cc
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/config/trace_config.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/config/trace_config.proto

#ifndef PROTOBUF_perfetto_2fconfig_2ftrace_5fconfig_2eproto__INCLUDED
#define PROTOBUF_perfetto_2fconfig_2ftrace_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
// gen_amalgamated expanded: #include "perfetto/config/data_source_config.pb.h"
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto();
void protobuf_AssignDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto();
void protobuf_ShutdownFile_perfetto_2fconfig_2ftrace_5fconfig_2eproto();

class TraceConfig;
class TraceConfig_BufferConfig;
class TraceConfig_BuiltinDataSource;
class TraceConfig_DataSource;
class TraceConfig_GuardrailOverrides;
class TraceConfig_IncidentReportConfig;
class TraceConfig_IncrementalStateConfig;
class TraceConfig_ProducerConfig;
class TraceConfig_StatsdMetadata;
class TraceConfig_TriggerConfig;
class TraceConfig_TriggerConfig_Trigger;

enum TraceConfig_BufferConfig_FillPolicy {
  TraceConfig_BufferConfig_FillPolicy_UNSPECIFIED = 0,
  TraceConfig_BufferConfig_FillPolicy_RING_BUFFER = 1,
  TraceConfig_BufferConfig_FillPolicy_DISCARD = 2
};
bool TraceConfig_BufferConfig_FillPolicy_IsValid(int value);
const TraceConfig_BufferConfig_FillPolicy TraceConfig_BufferConfig_FillPolicy_FillPolicy_MIN = TraceConfig_BufferConfig_FillPolicy_UNSPECIFIED;
const TraceConfig_BufferConfig_FillPolicy TraceConfig_BufferConfig_FillPolicy_FillPolicy_MAX = TraceConfig_BufferConfig_FillPolicy_DISCARD;
const int TraceConfig_BufferConfig_FillPolicy_FillPolicy_ARRAYSIZE = TraceConfig_BufferConfig_FillPolicy_FillPolicy_MAX + 1;

enum TraceConfig_TriggerConfig_TriggerMode {
  TraceConfig_TriggerConfig_TriggerMode_UNSPECIFIED = 0,
  TraceConfig_TriggerConfig_TriggerMode_START_TRACING = 1,
  TraceConfig_TriggerConfig_TriggerMode_STOP_TRACING = 2
};
bool TraceConfig_TriggerConfig_TriggerMode_IsValid(int value);
const TraceConfig_TriggerConfig_TriggerMode TraceConfig_TriggerConfig_TriggerMode_TriggerMode_MIN = TraceConfig_TriggerConfig_TriggerMode_UNSPECIFIED;
const TraceConfig_TriggerConfig_TriggerMode TraceConfig_TriggerConfig_TriggerMode_TriggerMode_MAX = TraceConfig_TriggerConfig_TriggerMode_STOP_TRACING;
const int TraceConfig_TriggerConfig_TriggerMode_TriggerMode_ARRAYSIZE = TraceConfig_TriggerConfig_TriggerMode_TriggerMode_MAX + 1;

enum TraceConfig_LockdownModeOperation {
  TraceConfig_LockdownModeOperation_LOCKDOWN_UNCHANGED = 0,
  TraceConfig_LockdownModeOperation_LOCKDOWN_CLEAR = 1,
  TraceConfig_LockdownModeOperation_LOCKDOWN_SET = 2
};
bool TraceConfig_LockdownModeOperation_IsValid(int value);
const TraceConfig_LockdownModeOperation TraceConfig_LockdownModeOperation_LockdownModeOperation_MIN = TraceConfig_LockdownModeOperation_LOCKDOWN_UNCHANGED;
const TraceConfig_LockdownModeOperation TraceConfig_LockdownModeOperation_LockdownModeOperation_MAX = TraceConfig_LockdownModeOperation_LOCKDOWN_SET;
const int TraceConfig_LockdownModeOperation_LockdownModeOperation_ARRAYSIZE = TraceConfig_LockdownModeOperation_LockdownModeOperation_MAX + 1;

enum TraceConfig_CompressionType {
  TraceConfig_CompressionType_COMPRESSION_TYPE_UNSPECIFIED = 0,
  TraceConfig_CompressionType_COMPRESSION_TYPE_DEFLATE = 1
};
bool TraceConfig_CompressionType_IsValid(int value);
const TraceConfig_CompressionType TraceConfig_CompressionType_CompressionType_MIN = TraceConfig_CompressionType_COMPRESSION_TYPE_UNSPECIFIED;
const TraceConfig_CompressionType TraceConfig_CompressionType_CompressionType_MAX = TraceConfig_CompressionType_COMPRESSION_TYPE_DEFLATE;
const int TraceConfig_CompressionType_CompressionType_ARRAYSIZE = TraceConfig_CompressionType_CompressionType_MAX + 1;

// ===================================================================

class TraceConfig_BufferConfig : public ::google::protobuf::MessageLite {
 public:
  TraceConfig_BufferConfig();
  virtual ~TraceConfig_BufferConfig();

  TraceConfig_BufferConfig(const TraceConfig_BufferConfig& from);

  inline TraceConfig_BufferConfig& operator=(const TraceConfig_BufferConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TraceConfig_BufferConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TraceConfig_BufferConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TraceConfig_BufferConfig* other);

  // implements Message ----------------------------------------------

  inline TraceConfig_BufferConfig* New() const { return New(NULL); }

  TraceConfig_BufferConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TraceConfig_BufferConfig& from);
  void MergeFrom(const TraceConfig_BufferConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TraceConfig_BufferConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef TraceConfig_BufferConfig_FillPolicy FillPolicy;
  static const FillPolicy UNSPECIFIED =
    TraceConfig_BufferConfig_FillPolicy_UNSPECIFIED;
  static const FillPolicy RING_BUFFER =
    TraceConfig_BufferConfig_FillPolicy_RING_BUFFER;
  static const FillPolicy DISCARD =
    TraceConfig_BufferConfig_FillPolicy_DISCARD;
  static inline bool FillPolicy_IsValid(int value) {
    return TraceConfig_BufferConfig_FillPolicy_IsValid(value);
  }
  static const FillPolicy FillPolicy_MIN =
    TraceConfig_BufferConfig_FillPolicy_FillPolicy_MIN;
  static const FillPolicy FillPolicy_MAX =
    TraceConfig_BufferConfig_FillPolicy_FillPolicy_MAX;
  static const int FillPolicy_ARRAYSIZE =
    TraceConfig_BufferConfig_FillPolicy_FillPolicy_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional uint32 size_kb = 1;
  bool has_size_kb() const;
  void clear_size_kb();
  static const int kSizeKbFieldNumber = 1;
  ::google::protobuf::uint32 size_kb() const;
  void set_size_kb(::google::protobuf::uint32 value);

  // optional .perfetto.protos.TraceConfig.BufferConfig.FillPolicy fill_policy = 4;
  bool has_fill_policy() const;
  void clear_fill_policy();
  static const int kFillPolicyFieldNumber = 4;
  ::perfetto::protos::TraceConfig_BufferConfig_FillPolicy fill_policy() const;
  void set_fill_policy(::perfetto::protos::TraceConfig_BufferConfig_FillPolicy value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.TraceConfig.BufferConfig)
 private:
  inline void set_has_size_kb();
  inline void clear_has_size_kb();
  inline void set_has_fill_policy();
  inline void clear_has_fill_policy();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 size_kb_;
  int fill_policy_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fconfig_2ftrace_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static TraceConfig_BufferConfig* default_instance_;
};
// -------------------------------------------------------------------

class TraceConfig_DataSource : public ::google::protobuf::MessageLite {
 public:
  TraceConfig_DataSource();
  virtual ~TraceConfig_DataSource();

  TraceConfig_DataSource(const TraceConfig_DataSource& from);

  inline TraceConfig_DataSource& operator=(const TraceConfig_DataSource& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TraceConfig_DataSource& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TraceConfig_DataSource* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TraceConfig_DataSource* other);

  // implements Message ----------------------------------------------

  inline TraceConfig_DataSource* New() const { return New(NULL); }

  TraceConfig_DataSource* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TraceConfig_DataSource& from);
  void MergeFrom(const TraceConfig_DataSource& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TraceConfig_DataSource* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .perfetto.protos.DataSourceConfig config = 1;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 1;
  const ::perfetto::protos::DataSourceConfig& config() const;
  ::perfetto::protos::DataSourceConfig* mutable_config();
  ::perfetto::protos::DataSourceConfig* release_config();
  void set_allocated_config(::perfetto::protos::DataSourceConfig* config);

  // repeated string producer_name_filter = 2;
  int producer_name_filter_size() const;
  void clear_producer_name_filter();
  static const int kProducerNameFilterFieldNumber = 2;
  const ::std::string& producer_name_filter(int index) const;
  ::std::string* mutable_producer_name_filter(int index);
  void set_producer_name_filter(int index, const ::std::string& value);
  void set_producer_name_filter(int index, const char* value);
  void set_producer_name_filter(int index, const char* value, size_t size);
  ::std::string* add_producer_name_filter();
  void add_producer_name_filter(const ::std::string& value);
  void add_producer_name_filter(const char* value);
  void add_producer_name_filter(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& producer_name_filter() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_producer_name_filter();

  // @@protoc_insertion_point(class_scope:perfetto.protos.TraceConfig.DataSource)
 private:
  inline void set_has_config();
  inline void clear_has_config();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::perfetto::protos::DataSourceConfig* config_;
  ::google::protobuf::RepeatedPtrField< ::std::string> producer_name_filter_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fconfig_2ftrace_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static TraceConfig_DataSource* default_instance_;
};
// -------------------------------------------------------------------

class TraceConfig_BuiltinDataSource : public ::google::protobuf::MessageLite {
 public:
  TraceConfig_BuiltinDataSource();
  virtual ~TraceConfig_BuiltinDataSource();

  TraceConfig_BuiltinDataSource(const TraceConfig_BuiltinDataSource& from);

  inline TraceConfig_BuiltinDataSource& operator=(const TraceConfig_BuiltinDataSource& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TraceConfig_BuiltinDataSource& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TraceConfig_BuiltinDataSource* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TraceConfig_BuiltinDataSource* other);

  // implements Message ----------------------------------------------

  inline TraceConfig_BuiltinDataSource* New() const { return New(NULL); }

  TraceConfig_BuiltinDataSource* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TraceConfig_BuiltinDataSource& from);
  void MergeFrom(const TraceConfig_BuiltinDataSource& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TraceConfig_BuiltinDataSource* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool disable_clock_snapshotting = 1;
  bool has_disable_clock_snapshotting() const;
  void clear_disable_clock_snapshotting();
  static const int kDisableClockSnapshottingFieldNumber = 1;
  bool disable_clock_snapshotting() const;
  void set_disable_clock_snapshotting(bool value);

  // optional bool disable_trace_config = 2;
  bool has_disable_trace_config() const;
  void clear_disable_trace_config();
  static const int kDisableTraceConfigFieldNumber = 2;
  bool disable_trace_config() const;
  void set_disable_trace_config(bool value);

  // optional bool disable_system_info = 3;
  bool has_disable_system_info() const;
  void clear_disable_system_info();
  static const int kDisableSystemInfoFieldNumber = 3;
  bool disable_system_info() const;
  void set_disable_system_info(bool value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.TraceConfig.BuiltinDataSource)
 private:
  inline void set_has_disable_clock_snapshotting();
  inline void clear_has_disable_clock_snapshotting();
  inline void set_has_disable_trace_config();
  inline void clear_has_disable_trace_config();
  inline void set_has_disable_system_info();
  inline void clear_has_disable_system_info();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool disable_clock_snapshotting_;
  bool disable_trace_config_;
  bool disable_system_info_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fconfig_2ftrace_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static TraceConfig_BuiltinDataSource* default_instance_;
};
// -------------------------------------------------------------------

class TraceConfig_ProducerConfig : public ::google::protobuf::MessageLite {
 public:
  TraceConfig_ProducerConfig();
  virtual ~TraceConfig_ProducerConfig();

  TraceConfig_ProducerConfig(const TraceConfig_ProducerConfig& from);

  inline TraceConfig_ProducerConfig& operator=(const TraceConfig_ProducerConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TraceConfig_ProducerConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TraceConfig_ProducerConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TraceConfig_ProducerConfig* other);

  // implements Message ----------------------------------------------

  inline TraceConfig_ProducerConfig* New() const { return New(NULL); }

  TraceConfig_ProducerConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TraceConfig_ProducerConfig& from);
  void MergeFrom(const TraceConfig_ProducerConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TraceConfig_ProducerConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string producer_name = 1;
  bool has_producer_name() const;
  void clear_producer_name();
  static const int kProducerNameFieldNumber = 1;
  const ::std::string& producer_name() const;
  void set_producer_name(const ::std::string& value);
  void set_producer_name(const char* value);
  void set_producer_name(const char* value, size_t size);
  ::std::string* mutable_producer_name();
  ::std::string* release_producer_name();
  void set_allocated_producer_name(::std::string* producer_name);

  // optional uint32 shm_size_kb = 2;
  bool has_shm_size_kb() const;
  void clear_shm_size_kb();
  static const int kShmSizeKbFieldNumber = 2;
  ::google::protobuf::uint32 shm_size_kb() const;
  void set_shm_size_kb(::google::protobuf::uint32 value);

  // optional uint32 page_size_kb = 3;
  bool has_page_size_kb() const;
  void clear_page_size_kb();
  static const int kPageSizeKbFieldNumber = 3;
  ::google::protobuf::uint32 page_size_kb() const;
  void set_page_size_kb(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.TraceConfig.ProducerConfig)
 private:
  inline void set_has_producer_name();
  inline void clear_has_producer_name();
  inline void set_has_shm_size_kb();
  inline void clear_has_shm_size_kb();
  inline void set_has_page_size_kb();
  inline void clear_has_page_size_kb();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr producer_name_;
  ::google::protobuf::uint32 shm_size_kb_;
  ::google::protobuf::uint32 page_size_kb_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fconfig_2ftrace_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static TraceConfig_ProducerConfig* default_instance_;
};
// -------------------------------------------------------------------

class TraceConfig_StatsdMetadata : public ::google::protobuf::MessageLite {
 public:
  TraceConfig_StatsdMetadata();
  virtual ~TraceConfig_StatsdMetadata();

  TraceConfig_StatsdMetadata(const TraceConfig_StatsdMetadata& from);

  inline TraceConfig_StatsdMetadata& operator=(const TraceConfig_StatsdMetadata& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TraceConfig_StatsdMetadata& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TraceConfig_StatsdMetadata* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TraceConfig_StatsdMetadata* other);

  // implements Message ----------------------------------------------

  inline TraceConfig_StatsdMetadata* New() const { return New(NULL); }

  TraceConfig_StatsdMetadata* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TraceConfig_StatsdMetadata& from);
  void MergeFrom(const TraceConfig_StatsdMetadata& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TraceConfig_StatsdMetadata* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 triggering_alert_id = 1;
  bool has_triggering_alert_id() const;
  void clear_triggering_alert_id();
  static const int kTriggeringAlertIdFieldNumber = 1;
  ::google::protobuf::int64 triggering_alert_id() const;
  void set_triggering_alert_id(::google::protobuf::int64 value);

  // optional int32 triggering_config_uid = 2;
  bool has_triggering_config_uid() const;
  void clear_triggering_config_uid();
  static const int kTriggeringConfigUidFieldNumber = 2;
  ::google::protobuf::int32 triggering_config_uid() const;
  void set_triggering_config_uid(::google::protobuf::int32 value);

  // optional int64 triggering_config_id = 3;
  bool has_triggering_config_id() const;
  void clear_triggering_config_id();
  static const int kTriggeringConfigIdFieldNumber = 3;
  ::google::protobuf::int64 triggering_config_id() const;
  void set_triggering_config_id(::google::protobuf::int64 value);

  // optional int64 triggering_subscription_id = 4;
  bool has_triggering_subscription_id() const;
  void clear_triggering_subscription_id();
  static const int kTriggeringSubscriptionIdFieldNumber = 4;
  ::google::protobuf::int64 triggering_subscription_id() const;
  void set_triggering_subscription_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.TraceConfig.StatsdMetadata)
 private:
  inline void set_has_triggering_alert_id();
  inline void clear_has_triggering_alert_id();
  inline void set_has_triggering_config_uid();
  inline void clear_has_triggering_config_uid();
  inline void set_has_triggering_config_id();
  inline void clear_has_triggering_config_id();
  inline void set_has_triggering_subscription_id();
  inline void clear_has_triggering_subscription_id();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 triggering_alert_id_;
  ::google::protobuf::int64 triggering_config_id_;
  ::google::protobuf::int64 triggering_subscription_id_;
  ::google::protobuf::int32 triggering_config_uid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fconfig_2ftrace_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static TraceConfig_StatsdMetadata* default_instance_;
};
// -------------------------------------------------------------------

class TraceConfig_GuardrailOverrides : public ::google::protobuf::MessageLite {
 public:
  TraceConfig_GuardrailOverrides();
  virtual ~TraceConfig_GuardrailOverrides();

  TraceConfig_GuardrailOverrides(const TraceConfig_GuardrailOverrides& from);

  inline TraceConfig_GuardrailOverrides& operator=(const TraceConfig_GuardrailOverrides& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TraceConfig_GuardrailOverrides& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TraceConfig_GuardrailOverrides* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TraceConfig_GuardrailOverrides* other);

  // implements Message ----------------------------------------------

  inline TraceConfig_GuardrailOverrides* New() const { return New(NULL); }

  TraceConfig_GuardrailOverrides* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TraceConfig_GuardrailOverrides& from);
  void MergeFrom(const TraceConfig_GuardrailOverrides& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TraceConfig_GuardrailOverrides* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 max_upload_per_day_bytes = 1;
  bool has_max_upload_per_day_bytes() const;
  void clear_max_upload_per_day_bytes();
  static const int kMaxUploadPerDayBytesFieldNumber = 1;
  ::google::protobuf::uint64 max_upload_per_day_bytes() const;
  void set_max_upload_per_day_bytes(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.TraceConfig.GuardrailOverrides)
 private:
  inline void set_has_max_upload_per_day_bytes();
  inline void clear_has_max_upload_per_day_bytes();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 max_upload_per_day_bytes_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fconfig_2ftrace_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static TraceConfig_GuardrailOverrides* default_instance_;
};
// -------------------------------------------------------------------

class TraceConfig_TriggerConfig_Trigger : public ::google::protobuf::MessageLite {
 public:
  TraceConfig_TriggerConfig_Trigger();
  virtual ~TraceConfig_TriggerConfig_Trigger();

  TraceConfig_TriggerConfig_Trigger(const TraceConfig_TriggerConfig_Trigger& from);

  inline TraceConfig_TriggerConfig_Trigger& operator=(const TraceConfig_TriggerConfig_Trigger& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TraceConfig_TriggerConfig_Trigger& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TraceConfig_TriggerConfig_Trigger* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TraceConfig_TriggerConfig_Trigger* other);

  // implements Message ----------------------------------------------

  inline TraceConfig_TriggerConfig_Trigger* New() const { return New(NULL); }

  TraceConfig_TriggerConfig_Trigger* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TraceConfig_TriggerConfig_Trigger& from);
  void MergeFrom(const TraceConfig_TriggerConfig_Trigger& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TraceConfig_TriggerConfig_Trigger* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string producer_name_regex = 2;
  bool has_producer_name_regex() const;
  void clear_producer_name_regex();
  static const int kProducerNameRegexFieldNumber = 2;
  const ::std::string& producer_name_regex() const;
  void set_producer_name_regex(const ::std::string& value);
  void set_producer_name_regex(const char* value);
  void set_producer_name_regex(const char* value, size_t size);
  ::std::string* mutable_producer_name_regex();
  ::std::string* release_producer_name_regex();
  void set_allocated_producer_name_regex(::std::string* producer_name_regex);

  // optional uint32 stop_delay_ms = 3;
  bool has_stop_delay_ms() const;
  void clear_stop_delay_ms();
  static const int kStopDelayMsFieldNumber = 3;
  ::google::protobuf::uint32 stop_delay_ms() const;
  void set_stop_delay_ms(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.TraceConfig.TriggerConfig.Trigger)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_producer_name_regex();
  inline void clear_has_producer_name_regex();
  inline void set_has_stop_delay_ms();
  inline void clear_has_stop_delay_ms();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr producer_name_regex_;
  ::google::protobuf::uint32 stop_delay_ms_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fconfig_2ftrace_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static TraceConfig_TriggerConfig_Trigger* default_instance_;
};
// -------------------------------------------------------------------

class TraceConfig_TriggerConfig : public ::google::protobuf::MessageLite {
 public:
  TraceConfig_TriggerConfig();
  virtual ~TraceConfig_TriggerConfig();

  TraceConfig_TriggerConfig(const TraceConfig_TriggerConfig& from);

  inline TraceConfig_TriggerConfig& operator=(const TraceConfig_TriggerConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TraceConfig_TriggerConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TraceConfig_TriggerConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TraceConfig_TriggerConfig* other);

  // implements Message ----------------------------------------------

  inline TraceConfig_TriggerConfig* New() const { return New(NULL); }

  TraceConfig_TriggerConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TraceConfig_TriggerConfig& from);
  void MergeFrom(const TraceConfig_TriggerConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TraceConfig_TriggerConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef TraceConfig_TriggerConfig_Trigger Trigger;

  typedef TraceConfig_TriggerConfig_TriggerMode TriggerMode;
  static const TriggerMode UNSPECIFIED =
    TraceConfig_TriggerConfig_TriggerMode_UNSPECIFIED;
  static const TriggerMode START_TRACING =
    TraceConfig_TriggerConfig_TriggerMode_START_TRACING;
  static const TriggerMode STOP_TRACING =
    TraceConfig_TriggerConfig_TriggerMode_STOP_TRACING;
  static inline bool TriggerMode_IsValid(int value) {
    return TraceConfig_TriggerConfig_TriggerMode_IsValid(value);
  }
  static const TriggerMode TriggerMode_MIN =
    TraceConfig_TriggerConfig_TriggerMode_TriggerMode_MIN;
  static const TriggerMode TriggerMode_MAX =
    TraceConfig_TriggerConfig_TriggerMode_TriggerMode_MAX;
  static const int TriggerMode_ARRAYSIZE =
    TraceConfig_TriggerConfig_TriggerMode_TriggerMode_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .perfetto.protos.TraceConfig.TriggerConfig.TriggerMode trigger_mode = 1;
  bool has_trigger_mode() const;
  void clear_trigger_mode();
  static const int kTriggerModeFieldNumber = 1;
  ::perfetto::protos::TraceConfig_TriggerConfig_TriggerMode trigger_mode() const;
  void set_trigger_mode(::perfetto::protos::TraceConfig_TriggerConfig_TriggerMode value);

  // repeated .perfetto.protos.TraceConfig.TriggerConfig.Trigger triggers = 2;
  int triggers_size() const;
  void clear_triggers();
  static const int kTriggersFieldNumber = 2;
  const ::perfetto::protos::TraceConfig_TriggerConfig_Trigger& triggers(int index) const;
  ::perfetto::protos::TraceConfig_TriggerConfig_Trigger* mutable_triggers(int index);
  ::perfetto::protos::TraceConfig_TriggerConfig_Trigger* add_triggers();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_TriggerConfig_Trigger >*
      mutable_triggers();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_TriggerConfig_Trigger >&
      triggers() const;

  // optional uint32 trigger_timeout_ms = 3;
  bool has_trigger_timeout_ms() const;
  void clear_trigger_timeout_ms();
  static const int kTriggerTimeoutMsFieldNumber = 3;
  ::google::protobuf::uint32 trigger_timeout_ms() const;
  void set_trigger_timeout_ms(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.TraceConfig.TriggerConfig)
 private:
  inline void set_has_trigger_mode();
  inline void clear_has_trigger_mode();
  inline void set_has_trigger_timeout_ms();
  inline void clear_has_trigger_timeout_ms();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_TriggerConfig_Trigger > triggers_;
  int trigger_mode_;
  ::google::protobuf::uint32 trigger_timeout_ms_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fconfig_2ftrace_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static TraceConfig_TriggerConfig* default_instance_;
};
// -------------------------------------------------------------------

class TraceConfig_IncrementalStateConfig : public ::google::protobuf::MessageLite {
 public:
  TraceConfig_IncrementalStateConfig();
  virtual ~TraceConfig_IncrementalStateConfig();

  TraceConfig_IncrementalStateConfig(const TraceConfig_IncrementalStateConfig& from);

  inline TraceConfig_IncrementalStateConfig& operator=(const TraceConfig_IncrementalStateConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TraceConfig_IncrementalStateConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TraceConfig_IncrementalStateConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TraceConfig_IncrementalStateConfig* other);

  // implements Message ----------------------------------------------

  inline TraceConfig_IncrementalStateConfig* New() const { return New(NULL); }

  TraceConfig_IncrementalStateConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TraceConfig_IncrementalStateConfig& from);
  void MergeFrom(const TraceConfig_IncrementalStateConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TraceConfig_IncrementalStateConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 clear_period_ms = 1;
  bool has_clear_period_ms() const;
  void clear_clear_period_ms();
  static const int kClearPeriodMsFieldNumber = 1;
  ::google::protobuf::uint32 clear_period_ms() const;
  void set_clear_period_ms(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.TraceConfig.IncrementalStateConfig)
 private:
  inline void set_has_clear_period_ms();
  inline void clear_has_clear_period_ms();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 clear_period_ms_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fconfig_2ftrace_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static TraceConfig_IncrementalStateConfig* default_instance_;
};
// -------------------------------------------------------------------

class TraceConfig_IncidentReportConfig : public ::google::protobuf::MessageLite {
 public:
  TraceConfig_IncidentReportConfig();
  virtual ~TraceConfig_IncidentReportConfig();

  TraceConfig_IncidentReportConfig(const TraceConfig_IncidentReportConfig& from);

  inline TraceConfig_IncidentReportConfig& operator=(const TraceConfig_IncidentReportConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TraceConfig_IncidentReportConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TraceConfig_IncidentReportConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TraceConfig_IncidentReportConfig* other);

  // implements Message ----------------------------------------------

  inline TraceConfig_IncidentReportConfig* New() const { return New(NULL); }

  TraceConfig_IncidentReportConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TraceConfig_IncidentReportConfig& from);
  void MergeFrom(const TraceConfig_IncidentReportConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TraceConfig_IncidentReportConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string destination_package = 1;
  bool has_destination_package() const;
  void clear_destination_package();
  static const int kDestinationPackageFieldNumber = 1;
  const ::std::string& destination_package() const;
  void set_destination_package(const ::std::string& value);
  void set_destination_package(const char* value);
  void set_destination_package(const char* value, size_t size);
  ::std::string* mutable_destination_package();
  ::std::string* release_destination_package();
  void set_allocated_destination_package(::std::string* destination_package);

  // optional string destination_class = 2;
  bool has_destination_class() const;
  void clear_destination_class();
  static const int kDestinationClassFieldNumber = 2;
  const ::std::string& destination_class() const;
  void set_destination_class(const ::std::string& value);
  void set_destination_class(const char* value);
  void set_destination_class(const char* value, size_t size);
  ::std::string* mutable_destination_class();
  ::std::string* release_destination_class();
  void set_allocated_destination_class(::std::string* destination_class);

  // optional int32 privacy_level = 3;
  bool has_privacy_level() const;
  void clear_privacy_level();
  static const int kPrivacyLevelFieldNumber = 3;
  ::google::protobuf::int32 privacy_level() const;
  void set_privacy_level(::google::protobuf::int32 value);

  // optional bool skip_dropbox = 4;
  bool has_skip_dropbox() const;
  void clear_skip_dropbox();
  static const int kSkipDropboxFieldNumber = 4;
  bool skip_dropbox() const;
  void set_skip_dropbox(bool value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.TraceConfig.IncidentReportConfig)
 private:
  inline void set_has_destination_package();
  inline void clear_has_destination_package();
  inline void set_has_destination_class();
  inline void clear_has_destination_class();
  inline void set_has_privacy_level();
  inline void clear_has_privacy_level();
  inline void set_has_skip_dropbox();
  inline void clear_has_skip_dropbox();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr destination_package_;
  ::google::protobuf::internal::ArenaStringPtr destination_class_;
  ::google::protobuf::int32 privacy_level_;
  bool skip_dropbox_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fconfig_2ftrace_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static TraceConfig_IncidentReportConfig* default_instance_;
};
// -------------------------------------------------------------------

class TraceConfig : public ::google::protobuf::MessageLite {
 public:
  TraceConfig();
  virtual ~TraceConfig();

  TraceConfig(const TraceConfig& from);

  inline TraceConfig& operator=(const TraceConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const TraceConfig& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TraceConfig* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TraceConfig* other);

  // implements Message ----------------------------------------------

  inline TraceConfig* New() const { return New(NULL); }

  TraceConfig* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TraceConfig& from);
  void MergeFrom(const TraceConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TraceConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef TraceConfig_BufferConfig BufferConfig;
  typedef TraceConfig_DataSource DataSource;
  typedef TraceConfig_BuiltinDataSource BuiltinDataSource;
  typedef TraceConfig_ProducerConfig ProducerConfig;
  typedef TraceConfig_StatsdMetadata StatsdMetadata;
  typedef TraceConfig_GuardrailOverrides GuardrailOverrides;
  typedef TraceConfig_TriggerConfig TriggerConfig;
  typedef TraceConfig_IncrementalStateConfig IncrementalStateConfig;
  typedef TraceConfig_IncidentReportConfig IncidentReportConfig;

  typedef TraceConfig_LockdownModeOperation LockdownModeOperation;
  static const LockdownModeOperation LOCKDOWN_UNCHANGED =
    TraceConfig_LockdownModeOperation_LOCKDOWN_UNCHANGED;
  static const LockdownModeOperation LOCKDOWN_CLEAR =
    TraceConfig_LockdownModeOperation_LOCKDOWN_CLEAR;
  static const LockdownModeOperation LOCKDOWN_SET =
    TraceConfig_LockdownModeOperation_LOCKDOWN_SET;
  static inline bool LockdownModeOperation_IsValid(int value) {
    return TraceConfig_LockdownModeOperation_IsValid(value);
  }
  static const LockdownModeOperation LockdownModeOperation_MIN =
    TraceConfig_LockdownModeOperation_LockdownModeOperation_MIN;
  static const LockdownModeOperation LockdownModeOperation_MAX =
    TraceConfig_LockdownModeOperation_LockdownModeOperation_MAX;
  static const int LockdownModeOperation_ARRAYSIZE =
    TraceConfig_LockdownModeOperation_LockdownModeOperation_ARRAYSIZE;

  typedef TraceConfig_CompressionType CompressionType;
  static const CompressionType COMPRESSION_TYPE_UNSPECIFIED =
    TraceConfig_CompressionType_COMPRESSION_TYPE_UNSPECIFIED;
  static const CompressionType COMPRESSION_TYPE_DEFLATE =
    TraceConfig_CompressionType_COMPRESSION_TYPE_DEFLATE;
  static inline bool CompressionType_IsValid(int value) {
    return TraceConfig_CompressionType_IsValid(value);
  }
  static const CompressionType CompressionType_MIN =
    TraceConfig_CompressionType_CompressionType_MIN;
  static const CompressionType CompressionType_MAX =
    TraceConfig_CompressionType_CompressionType_MAX;
  static const int CompressionType_ARRAYSIZE =
    TraceConfig_CompressionType_CompressionType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .perfetto.protos.TraceConfig.BufferConfig buffers = 1;
  int buffers_size() const;
  void clear_buffers();
  static const int kBuffersFieldNumber = 1;
  const ::perfetto::protos::TraceConfig_BufferConfig& buffers(int index) const;
  ::perfetto::protos::TraceConfig_BufferConfig* mutable_buffers(int index);
  ::perfetto::protos::TraceConfig_BufferConfig* add_buffers();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_BufferConfig >*
      mutable_buffers();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_BufferConfig >&
      buffers() const;

  // repeated .perfetto.protos.TraceConfig.DataSource data_sources = 2;
  int data_sources_size() const;
  void clear_data_sources();
  static const int kDataSourcesFieldNumber = 2;
  const ::perfetto::protos::TraceConfig_DataSource& data_sources(int index) const;
  ::perfetto::protos::TraceConfig_DataSource* mutable_data_sources(int index);
  ::perfetto::protos::TraceConfig_DataSource* add_data_sources();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_DataSource >*
      mutable_data_sources();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_DataSource >&
      data_sources() const;

  // optional .perfetto.protos.TraceConfig.BuiltinDataSource builtin_data_sources = 20;
  bool has_builtin_data_sources() const;
  void clear_builtin_data_sources();
  static const int kBuiltinDataSourcesFieldNumber = 20;
  const ::perfetto::protos::TraceConfig_BuiltinDataSource& builtin_data_sources() const;
  ::perfetto::protos::TraceConfig_BuiltinDataSource* mutable_builtin_data_sources();
  ::perfetto::protos::TraceConfig_BuiltinDataSource* release_builtin_data_sources();
  void set_allocated_builtin_data_sources(::perfetto::protos::TraceConfig_BuiltinDataSource* builtin_data_sources);

  // optional uint32 duration_ms = 3;
  bool has_duration_ms() const;
  void clear_duration_ms();
  static const int kDurationMsFieldNumber = 3;
  ::google::protobuf::uint32 duration_ms() const;
  void set_duration_ms(::google::protobuf::uint32 value);

  // optional bool enable_extra_guardrails = 4;
  bool has_enable_extra_guardrails() const;
  void clear_enable_extra_guardrails();
  static const int kEnableExtraGuardrailsFieldNumber = 4;
  bool enable_extra_guardrails() const;
  void set_enable_extra_guardrails(bool value);

  // optional .perfetto.protos.TraceConfig.LockdownModeOperation lockdown_mode = 5;
  bool has_lockdown_mode() const;
  void clear_lockdown_mode();
  static const int kLockdownModeFieldNumber = 5;
  ::perfetto::protos::TraceConfig_LockdownModeOperation lockdown_mode() const;
  void set_lockdown_mode(::perfetto::protos::TraceConfig_LockdownModeOperation value);

  // repeated .perfetto.protos.TraceConfig.ProducerConfig producers = 6;
  int producers_size() const;
  void clear_producers();
  static const int kProducersFieldNumber = 6;
  const ::perfetto::protos::TraceConfig_ProducerConfig& producers(int index) const;
  ::perfetto::protos::TraceConfig_ProducerConfig* mutable_producers(int index);
  ::perfetto::protos::TraceConfig_ProducerConfig* add_producers();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_ProducerConfig >*
      mutable_producers();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_ProducerConfig >&
      producers() const;

  // optional .perfetto.protos.TraceConfig.StatsdMetadata statsd_metadata = 7;
  bool has_statsd_metadata() const;
  void clear_statsd_metadata();
  static const int kStatsdMetadataFieldNumber = 7;
  const ::perfetto::protos::TraceConfig_StatsdMetadata& statsd_metadata() const;
  ::perfetto::protos::TraceConfig_StatsdMetadata* mutable_statsd_metadata();
  ::perfetto::protos::TraceConfig_StatsdMetadata* release_statsd_metadata();
  void set_allocated_statsd_metadata(::perfetto::protos::TraceConfig_StatsdMetadata* statsd_metadata);

  // optional bool write_into_file = 8;
  bool has_write_into_file() const;
  void clear_write_into_file();
  static const int kWriteIntoFileFieldNumber = 8;
  bool write_into_file() const;
  void set_write_into_file(bool value);

  // optional uint32 file_write_period_ms = 9;
  bool has_file_write_period_ms() const;
  void clear_file_write_period_ms();
  static const int kFileWritePeriodMsFieldNumber = 9;
  ::google::protobuf::uint32 file_write_period_ms() const;
  void set_file_write_period_ms(::google::protobuf::uint32 value);

  // optional uint64 max_file_size_bytes = 10;
  bool has_max_file_size_bytes() const;
  void clear_max_file_size_bytes();
  static const int kMaxFileSizeBytesFieldNumber = 10;
  ::google::protobuf::uint64 max_file_size_bytes() const;
  void set_max_file_size_bytes(::google::protobuf::uint64 value);

  // optional .perfetto.protos.TraceConfig.GuardrailOverrides guardrail_overrides = 11;
  bool has_guardrail_overrides() const;
  void clear_guardrail_overrides();
  static const int kGuardrailOverridesFieldNumber = 11;
  const ::perfetto::protos::TraceConfig_GuardrailOverrides& guardrail_overrides() const;
  ::perfetto::protos::TraceConfig_GuardrailOverrides* mutable_guardrail_overrides();
  ::perfetto::protos::TraceConfig_GuardrailOverrides* release_guardrail_overrides();
  void set_allocated_guardrail_overrides(::perfetto::protos::TraceConfig_GuardrailOverrides* guardrail_overrides);

  // optional bool deferred_start = 12;
  bool has_deferred_start() const;
  void clear_deferred_start();
  static const int kDeferredStartFieldNumber = 12;
  bool deferred_start() const;
  void set_deferred_start(bool value);

  // optional uint32 flush_period_ms = 13;
  bool has_flush_period_ms() const;
  void clear_flush_period_ms();
  static const int kFlushPeriodMsFieldNumber = 13;
  ::google::protobuf::uint32 flush_period_ms() const;
  void set_flush_period_ms(::google::protobuf::uint32 value);

  // optional uint32 flush_timeout_ms = 14;
  bool has_flush_timeout_ms() const;
  void clear_flush_timeout_ms();
  static const int kFlushTimeoutMsFieldNumber = 14;
  ::google::protobuf::uint32 flush_timeout_ms() const;
  void set_flush_timeout_ms(::google::protobuf::uint32 value);

  // optional uint32 data_source_stop_timeout_ms = 23;
  bool has_data_source_stop_timeout_ms() const;
  void clear_data_source_stop_timeout_ms();
  static const int kDataSourceStopTimeoutMsFieldNumber = 23;
  ::google::protobuf::uint32 data_source_stop_timeout_ms() const;
  void set_data_source_stop_timeout_ms(::google::protobuf::uint32 value);

  // optional bool notify_traceur = 16;
  bool has_notify_traceur() const;
  void clear_notify_traceur();
  static const int kNotifyTraceurFieldNumber = 16;
  bool notify_traceur() const;
  void set_notify_traceur(bool value);

  // optional .perfetto.protos.TraceConfig.TriggerConfig trigger_config = 17;
  bool has_trigger_config() const;
  void clear_trigger_config();
  static const int kTriggerConfigFieldNumber = 17;
  const ::perfetto::protos::TraceConfig_TriggerConfig& trigger_config() const;
  ::perfetto::protos::TraceConfig_TriggerConfig* mutable_trigger_config();
  ::perfetto::protos::TraceConfig_TriggerConfig* release_trigger_config();
  void set_allocated_trigger_config(::perfetto::protos::TraceConfig_TriggerConfig* trigger_config);

  // repeated string activate_triggers = 18;
  int activate_triggers_size() const;
  void clear_activate_triggers();
  static const int kActivateTriggersFieldNumber = 18;
  const ::std::string& activate_triggers(int index) const;
  ::std::string* mutable_activate_triggers(int index);
  void set_activate_triggers(int index, const ::std::string& value);
  void set_activate_triggers(int index, const char* value);
  void set_activate_triggers(int index, const char* value, size_t size);
  ::std::string* add_activate_triggers();
  void add_activate_triggers(const ::std::string& value);
  void add_activate_triggers(const char* value);
  void add_activate_triggers(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& activate_triggers() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_activate_triggers();

  // optional .perfetto.protos.TraceConfig.IncrementalStateConfig incremental_state_config = 21;
  bool has_incremental_state_config() const;
  void clear_incremental_state_config();
  static const int kIncrementalStateConfigFieldNumber = 21;
  const ::perfetto::protos::TraceConfig_IncrementalStateConfig& incremental_state_config() const;
  ::perfetto::protos::TraceConfig_IncrementalStateConfig* mutable_incremental_state_config();
  ::perfetto::protos::TraceConfig_IncrementalStateConfig* release_incremental_state_config();
  void set_allocated_incremental_state_config(::perfetto::protos::TraceConfig_IncrementalStateConfig* incremental_state_config);

  // optional bool allow_user_build_tracing = 19;
  bool has_allow_user_build_tracing() const;
  void clear_allow_user_build_tracing();
  static const int kAllowUserBuildTracingFieldNumber = 19;
  bool allow_user_build_tracing() const;
  void set_allow_user_build_tracing(bool value);

  // optional string unique_session_name = 22;
  bool has_unique_session_name() const;
  void clear_unique_session_name();
  static const int kUniqueSessionNameFieldNumber = 22;
  const ::std::string& unique_session_name() const;
  void set_unique_session_name(const ::std::string& value);
  void set_unique_session_name(const char* value);
  void set_unique_session_name(const char* value, size_t size);
  ::std::string* mutable_unique_session_name();
  ::std::string* release_unique_session_name();
  void set_allocated_unique_session_name(::std::string* unique_session_name);

  // optional .perfetto.protos.TraceConfig.CompressionType compression_type = 24;
  bool has_compression_type() const;
  void clear_compression_type();
  static const int kCompressionTypeFieldNumber = 24;
  ::perfetto::protos::TraceConfig_CompressionType compression_type() const;
  void set_compression_type(::perfetto::protos::TraceConfig_CompressionType value);

  // optional .perfetto.protos.TraceConfig.IncidentReportConfig incident_report_config = 25;
  bool has_incident_report_config() const;
  void clear_incident_report_config();
  static const int kIncidentReportConfigFieldNumber = 25;
  const ::perfetto::protos::TraceConfig_IncidentReportConfig& incident_report_config() const;
  ::perfetto::protos::TraceConfig_IncidentReportConfig* mutable_incident_report_config();
  ::perfetto::protos::TraceConfig_IncidentReportConfig* release_incident_report_config();
  void set_allocated_incident_report_config(::perfetto::protos::TraceConfig_IncidentReportConfig* incident_report_config);

  // @@protoc_insertion_point(class_scope:perfetto.protos.TraceConfig)
 private:
  inline void set_has_builtin_data_sources();
  inline void clear_has_builtin_data_sources();
  inline void set_has_duration_ms();
  inline void clear_has_duration_ms();
  inline void set_has_enable_extra_guardrails();
  inline void clear_has_enable_extra_guardrails();
  inline void set_has_lockdown_mode();
  inline void clear_has_lockdown_mode();
  inline void set_has_statsd_metadata();
  inline void clear_has_statsd_metadata();
  inline void set_has_write_into_file();
  inline void clear_has_write_into_file();
  inline void set_has_file_write_period_ms();
  inline void clear_has_file_write_period_ms();
  inline void set_has_max_file_size_bytes();
  inline void clear_has_max_file_size_bytes();
  inline void set_has_guardrail_overrides();
  inline void clear_has_guardrail_overrides();
  inline void set_has_deferred_start();
  inline void clear_has_deferred_start();
  inline void set_has_flush_period_ms();
  inline void clear_has_flush_period_ms();
  inline void set_has_flush_timeout_ms();
  inline void clear_has_flush_timeout_ms();
  inline void set_has_data_source_stop_timeout_ms();
  inline void clear_has_data_source_stop_timeout_ms();
  inline void set_has_notify_traceur();
  inline void clear_has_notify_traceur();
  inline void set_has_trigger_config();
  inline void clear_has_trigger_config();
  inline void set_has_incremental_state_config();
  inline void clear_has_incremental_state_config();
  inline void set_has_allow_user_build_tracing();
  inline void clear_has_allow_user_build_tracing();
  inline void set_has_unique_session_name();
  inline void clear_has_unique_session_name();
  inline void set_has_compression_type();
  inline void clear_has_compression_type();
  inline void set_has_incident_report_config();
  inline void clear_has_incident_report_config();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_BufferConfig > buffers_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_DataSource > data_sources_;
  ::perfetto::protos::TraceConfig_BuiltinDataSource* builtin_data_sources_;
  ::google::protobuf::uint32 duration_ms_;
  int lockdown_mode_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_ProducerConfig > producers_;
  ::perfetto::protos::TraceConfig_StatsdMetadata* statsd_metadata_;
  ::google::protobuf::uint32 file_write_period_ms_;
  bool enable_extra_guardrails_;
  bool write_into_file_;
  bool deferred_start_;
  bool notify_traceur_;
  ::google::protobuf::uint64 max_file_size_bytes_;
  ::perfetto::protos::TraceConfig_GuardrailOverrides* guardrail_overrides_;
  ::google::protobuf::uint32 flush_period_ms_;
  ::google::protobuf::uint32 flush_timeout_ms_;
  ::perfetto::protos::TraceConfig_TriggerConfig* trigger_config_;
  ::google::protobuf::uint32 data_source_stop_timeout_ms_;
  bool allow_user_build_tracing_;
  ::google::protobuf::RepeatedPtrField< ::std::string> activate_triggers_;
  ::perfetto::protos::TraceConfig_IncrementalStateConfig* incremental_state_config_;
  ::google::protobuf::internal::ArenaStringPtr unique_session_name_;
  ::perfetto::protos::TraceConfig_IncidentReportConfig* incident_report_config_;
  int compression_type_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fconfig_2ftrace_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static TraceConfig* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// TraceConfig_BufferConfig

// optional uint32 size_kb = 1;
inline bool TraceConfig_BufferConfig::has_size_kb() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TraceConfig_BufferConfig::set_has_size_kb() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TraceConfig_BufferConfig::clear_has_size_kb() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TraceConfig_BufferConfig::clear_size_kb() {
  size_kb_ = 0u;
  clear_has_size_kb();
}
inline ::google::protobuf::uint32 TraceConfig_BufferConfig::size_kb() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.BufferConfig.size_kb)
  return size_kb_;
}
inline void TraceConfig_BufferConfig::set_size_kb(::google::protobuf::uint32 value) {
  set_has_size_kb();
  size_kb_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.BufferConfig.size_kb)
}

// optional .perfetto.protos.TraceConfig.BufferConfig.FillPolicy fill_policy = 4;
inline bool TraceConfig_BufferConfig::has_fill_policy() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TraceConfig_BufferConfig::set_has_fill_policy() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TraceConfig_BufferConfig::clear_has_fill_policy() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TraceConfig_BufferConfig::clear_fill_policy() {
  fill_policy_ = 0;
  clear_has_fill_policy();
}
inline ::perfetto::protos::TraceConfig_BufferConfig_FillPolicy TraceConfig_BufferConfig::fill_policy() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.BufferConfig.fill_policy)
  return static_cast< ::perfetto::protos::TraceConfig_BufferConfig_FillPolicy >(fill_policy_);
}
inline void TraceConfig_BufferConfig::set_fill_policy(::perfetto::protos::TraceConfig_BufferConfig_FillPolicy value) {
  assert(::perfetto::protos::TraceConfig_BufferConfig_FillPolicy_IsValid(value));
  set_has_fill_policy();
  fill_policy_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.BufferConfig.fill_policy)
}

// -------------------------------------------------------------------

// TraceConfig_DataSource

// optional .perfetto.protos.DataSourceConfig config = 1;
inline bool TraceConfig_DataSource::has_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TraceConfig_DataSource::set_has_config() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TraceConfig_DataSource::clear_has_config() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TraceConfig_DataSource::clear_config() {
  if (config_ != NULL) config_->::perfetto::protos::DataSourceConfig::Clear();
  clear_has_config();
}
inline const ::perfetto::protos::DataSourceConfig& TraceConfig_DataSource::config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.DataSource.config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return config_ != NULL ? *config_ : *default_instance().config_;
#else
  return config_ != NULL ? *config_ : *default_instance_->config_;
#endif
}
inline ::perfetto::protos::DataSourceConfig* TraceConfig_DataSource::mutable_config() {
  set_has_config();
  if (config_ == NULL) {
    config_ = new ::perfetto::protos::DataSourceConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.DataSource.config)
  return config_;
}
inline ::perfetto::protos::DataSourceConfig* TraceConfig_DataSource::release_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.DataSource.config)
  clear_has_config();
  ::perfetto::protos::DataSourceConfig* temp = config_;
  config_ = NULL;
  return temp;
}
inline void TraceConfig_DataSource::set_allocated_config(::perfetto::protos::DataSourceConfig* config) {
  delete config_;
  config_ = config;
  if (config) {
    set_has_config();
  } else {
    clear_has_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.DataSource.config)
}

// repeated string producer_name_filter = 2;
inline int TraceConfig_DataSource::producer_name_filter_size() const {
  return producer_name_filter_.size();
}
inline void TraceConfig_DataSource::clear_producer_name_filter() {
  producer_name_filter_.Clear();
}
inline const ::std::string& TraceConfig_DataSource::producer_name_filter(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.DataSource.producer_name_filter)
  return producer_name_filter_.Get(index);
}
inline ::std::string* TraceConfig_DataSource::mutable_producer_name_filter(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.DataSource.producer_name_filter)
  return producer_name_filter_.Mutable(index);
}
inline void TraceConfig_DataSource::set_producer_name_filter(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.DataSource.producer_name_filter)
  producer_name_filter_.Mutable(index)->assign(value);
}
inline void TraceConfig_DataSource::set_producer_name_filter(int index, const char* value) {
  producer_name_filter_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.TraceConfig.DataSource.producer_name_filter)
}
inline void TraceConfig_DataSource::set_producer_name_filter(int index, const char* value, size_t size) {
  producer_name_filter_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.TraceConfig.DataSource.producer_name_filter)
}
inline ::std::string* TraceConfig_DataSource::add_producer_name_filter() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.TraceConfig.DataSource.producer_name_filter)
  return producer_name_filter_.Add();
}
inline void TraceConfig_DataSource::add_producer_name_filter(const ::std::string& value) {
  producer_name_filter_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.TraceConfig.DataSource.producer_name_filter)
}
inline void TraceConfig_DataSource::add_producer_name_filter(const char* value) {
  producer_name_filter_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.TraceConfig.DataSource.producer_name_filter)
}
inline void TraceConfig_DataSource::add_producer_name_filter(const char* value, size_t size) {
  producer_name_filter_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.TraceConfig.DataSource.producer_name_filter)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TraceConfig_DataSource::producer_name_filter() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.TraceConfig.DataSource.producer_name_filter)
  return producer_name_filter_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TraceConfig_DataSource::mutable_producer_name_filter() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.TraceConfig.DataSource.producer_name_filter)
  return &producer_name_filter_;
}

// -------------------------------------------------------------------

// TraceConfig_BuiltinDataSource

// optional bool disable_clock_snapshotting = 1;
inline bool TraceConfig_BuiltinDataSource::has_disable_clock_snapshotting() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TraceConfig_BuiltinDataSource::set_has_disable_clock_snapshotting() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TraceConfig_BuiltinDataSource::clear_has_disable_clock_snapshotting() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TraceConfig_BuiltinDataSource::clear_disable_clock_snapshotting() {
  disable_clock_snapshotting_ = false;
  clear_has_disable_clock_snapshotting();
}
inline bool TraceConfig_BuiltinDataSource::disable_clock_snapshotting() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.BuiltinDataSource.disable_clock_snapshotting)
  return disable_clock_snapshotting_;
}
inline void TraceConfig_BuiltinDataSource::set_disable_clock_snapshotting(bool value) {
  set_has_disable_clock_snapshotting();
  disable_clock_snapshotting_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.BuiltinDataSource.disable_clock_snapshotting)
}

// optional bool disable_trace_config = 2;
inline bool TraceConfig_BuiltinDataSource::has_disable_trace_config() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TraceConfig_BuiltinDataSource::set_has_disable_trace_config() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TraceConfig_BuiltinDataSource::clear_has_disable_trace_config() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TraceConfig_BuiltinDataSource::clear_disable_trace_config() {
  disable_trace_config_ = false;
  clear_has_disable_trace_config();
}
inline bool TraceConfig_BuiltinDataSource::disable_trace_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.BuiltinDataSource.disable_trace_config)
  return disable_trace_config_;
}
inline void TraceConfig_BuiltinDataSource::set_disable_trace_config(bool value) {
  set_has_disable_trace_config();
  disable_trace_config_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.BuiltinDataSource.disable_trace_config)
}

// optional bool disable_system_info = 3;
inline bool TraceConfig_BuiltinDataSource::has_disable_system_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TraceConfig_BuiltinDataSource::set_has_disable_system_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TraceConfig_BuiltinDataSource::clear_has_disable_system_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TraceConfig_BuiltinDataSource::clear_disable_system_info() {
  disable_system_info_ = false;
  clear_has_disable_system_info();
}
inline bool TraceConfig_BuiltinDataSource::disable_system_info() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.BuiltinDataSource.disable_system_info)
  return disable_system_info_;
}
inline void TraceConfig_BuiltinDataSource::set_disable_system_info(bool value) {
  set_has_disable_system_info();
  disable_system_info_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.BuiltinDataSource.disable_system_info)
}

// -------------------------------------------------------------------

// TraceConfig_ProducerConfig

// optional string producer_name = 1;
inline bool TraceConfig_ProducerConfig::has_producer_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TraceConfig_ProducerConfig::set_has_producer_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TraceConfig_ProducerConfig::clear_has_producer_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TraceConfig_ProducerConfig::clear_producer_name() {
  producer_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_producer_name();
}
inline const ::std::string& TraceConfig_ProducerConfig::producer_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.ProducerConfig.producer_name)
  return producer_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TraceConfig_ProducerConfig::set_producer_name(const ::std::string& value) {
  set_has_producer_name();
  producer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.ProducerConfig.producer_name)
}
inline void TraceConfig_ProducerConfig::set_producer_name(const char* value) {
  set_has_producer_name();
  producer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.TraceConfig.ProducerConfig.producer_name)
}
inline void TraceConfig_ProducerConfig::set_producer_name(const char* value, size_t size) {
  set_has_producer_name();
  producer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.TraceConfig.ProducerConfig.producer_name)
}
inline ::std::string* TraceConfig_ProducerConfig::mutable_producer_name() {
  set_has_producer_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.ProducerConfig.producer_name)
  return producer_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TraceConfig_ProducerConfig::release_producer_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.ProducerConfig.producer_name)
  clear_has_producer_name();
  return producer_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TraceConfig_ProducerConfig::set_allocated_producer_name(::std::string* producer_name) {
  if (producer_name != NULL) {
    set_has_producer_name();
  } else {
    clear_has_producer_name();
  }
  producer_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), producer_name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.ProducerConfig.producer_name)
}

// optional uint32 shm_size_kb = 2;
inline bool TraceConfig_ProducerConfig::has_shm_size_kb() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TraceConfig_ProducerConfig::set_has_shm_size_kb() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TraceConfig_ProducerConfig::clear_has_shm_size_kb() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TraceConfig_ProducerConfig::clear_shm_size_kb() {
  shm_size_kb_ = 0u;
  clear_has_shm_size_kb();
}
inline ::google::protobuf::uint32 TraceConfig_ProducerConfig::shm_size_kb() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.ProducerConfig.shm_size_kb)
  return shm_size_kb_;
}
inline void TraceConfig_ProducerConfig::set_shm_size_kb(::google::protobuf::uint32 value) {
  set_has_shm_size_kb();
  shm_size_kb_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.ProducerConfig.shm_size_kb)
}

// optional uint32 page_size_kb = 3;
inline bool TraceConfig_ProducerConfig::has_page_size_kb() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TraceConfig_ProducerConfig::set_has_page_size_kb() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TraceConfig_ProducerConfig::clear_has_page_size_kb() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TraceConfig_ProducerConfig::clear_page_size_kb() {
  page_size_kb_ = 0u;
  clear_has_page_size_kb();
}
inline ::google::protobuf::uint32 TraceConfig_ProducerConfig::page_size_kb() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.ProducerConfig.page_size_kb)
  return page_size_kb_;
}
inline void TraceConfig_ProducerConfig::set_page_size_kb(::google::protobuf::uint32 value) {
  set_has_page_size_kb();
  page_size_kb_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.ProducerConfig.page_size_kb)
}

// -------------------------------------------------------------------

// TraceConfig_StatsdMetadata

// optional int64 triggering_alert_id = 1;
inline bool TraceConfig_StatsdMetadata::has_triggering_alert_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TraceConfig_StatsdMetadata::set_has_triggering_alert_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TraceConfig_StatsdMetadata::clear_has_triggering_alert_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TraceConfig_StatsdMetadata::clear_triggering_alert_id() {
  triggering_alert_id_ = GOOGLE_LONGLONG(0);
  clear_has_triggering_alert_id();
}
inline ::google::protobuf::int64 TraceConfig_StatsdMetadata::triggering_alert_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.StatsdMetadata.triggering_alert_id)
  return triggering_alert_id_;
}
inline void TraceConfig_StatsdMetadata::set_triggering_alert_id(::google::protobuf::int64 value) {
  set_has_triggering_alert_id();
  triggering_alert_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.StatsdMetadata.triggering_alert_id)
}

// optional int32 triggering_config_uid = 2;
inline bool TraceConfig_StatsdMetadata::has_triggering_config_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TraceConfig_StatsdMetadata::set_has_triggering_config_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TraceConfig_StatsdMetadata::clear_has_triggering_config_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TraceConfig_StatsdMetadata::clear_triggering_config_uid() {
  triggering_config_uid_ = 0;
  clear_has_triggering_config_uid();
}
inline ::google::protobuf::int32 TraceConfig_StatsdMetadata::triggering_config_uid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.StatsdMetadata.triggering_config_uid)
  return triggering_config_uid_;
}
inline void TraceConfig_StatsdMetadata::set_triggering_config_uid(::google::protobuf::int32 value) {
  set_has_triggering_config_uid();
  triggering_config_uid_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.StatsdMetadata.triggering_config_uid)
}

// optional int64 triggering_config_id = 3;
inline bool TraceConfig_StatsdMetadata::has_triggering_config_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TraceConfig_StatsdMetadata::set_has_triggering_config_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TraceConfig_StatsdMetadata::clear_has_triggering_config_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TraceConfig_StatsdMetadata::clear_triggering_config_id() {
  triggering_config_id_ = GOOGLE_LONGLONG(0);
  clear_has_triggering_config_id();
}
inline ::google::protobuf::int64 TraceConfig_StatsdMetadata::triggering_config_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.StatsdMetadata.triggering_config_id)
  return triggering_config_id_;
}
inline void TraceConfig_StatsdMetadata::set_triggering_config_id(::google::protobuf::int64 value) {
  set_has_triggering_config_id();
  triggering_config_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.StatsdMetadata.triggering_config_id)
}

// optional int64 triggering_subscription_id = 4;
inline bool TraceConfig_StatsdMetadata::has_triggering_subscription_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TraceConfig_StatsdMetadata::set_has_triggering_subscription_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TraceConfig_StatsdMetadata::clear_has_triggering_subscription_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TraceConfig_StatsdMetadata::clear_triggering_subscription_id() {
  triggering_subscription_id_ = GOOGLE_LONGLONG(0);
  clear_has_triggering_subscription_id();
}
inline ::google::protobuf::int64 TraceConfig_StatsdMetadata::triggering_subscription_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.StatsdMetadata.triggering_subscription_id)
  return triggering_subscription_id_;
}
inline void TraceConfig_StatsdMetadata::set_triggering_subscription_id(::google::protobuf::int64 value) {
  set_has_triggering_subscription_id();
  triggering_subscription_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.StatsdMetadata.triggering_subscription_id)
}

// -------------------------------------------------------------------

// TraceConfig_GuardrailOverrides

// optional uint64 max_upload_per_day_bytes = 1;
inline bool TraceConfig_GuardrailOverrides::has_max_upload_per_day_bytes() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TraceConfig_GuardrailOverrides::set_has_max_upload_per_day_bytes() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TraceConfig_GuardrailOverrides::clear_has_max_upload_per_day_bytes() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TraceConfig_GuardrailOverrides::clear_max_upload_per_day_bytes() {
  max_upload_per_day_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_max_upload_per_day_bytes();
}
inline ::google::protobuf::uint64 TraceConfig_GuardrailOverrides::max_upload_per_day_bytes() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.GuardrailOverrides.max_upload_per_day_bytes)
  return max_upload_per_day_bytes_;
}
inline void TraceConfig_GuardrailOverrides::set_max_upload_per_day_bytes(::google::protobuf::uint64 value) {
  set_has_max_upload_per_day_bytes();
  max_upload_per_day_bytes_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.GuardrailOverrides.max_upload_per_day_bytes)
}

// -------------------------------------------------------------------

// TraceConfig_TriggerConfig_Trigger

// optional string name = 1;
inline bool TraceConfig_TriggerConfig_Trigger::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TraceConfig_TriggerConfig_Trigger::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TraceConfig_TriggerConfig_Trigger::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TraceConfig_TriggerConfig_Trigger::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& TraceConfig_TriggerConfig_Trigger::name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.TriggerConfig.Trigger.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TraceConfig_TriggerConfig_Trigger::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.TriggerConfig.Trigger.name)
}
inline void TraceConfig_TriggerConfig_Trigger::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.TraceConfig.TriggerConfig.Trigger.name)
}
inline void TraceConfig_TriggerConfig_Trigger::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.TraceConfig.TriggerConfig.Trigger.name)
}
inline ::std::string* TraceConfig_TriggerConfig_Trigger::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.TriggerConfig.Trigger.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TraceConfig_TriggerConfig_Trigger::release_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.TriggerConfig.Trigger.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TraceConfig_TriggerConfig_Trigger::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.TriggerConfig.Trigger.name)
}

// optional string producer_name_regex = 2;
inline bool TraceConfig_TriggerConfig_Trigger::has_producer_name_regex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TraceConfig_TriggerConfig_Trigger::set_has_producer_name_regex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TraceConfig_TriggerConfig_Trigger::clear_has_producer_name_regex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TraceConfig_TriggerConfig_Trigger::clear_producer_name_regex() {
  producer_name_regex_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_producer_name_regex();
}
inline const ::std::string& TraceConfig_TriggerConfig_Trigger::producer_name_regex() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.TriggerConfig.Trigger.producer_name_regex)
  return producer_name_regex_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TraceConfig_TriggerConfig_Trigger::set_producer_name_regex(const ::std::string& value) {
  set_has_producer_name_regex();
  producer_name_regex_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.TriggerConfig.Trigger.producer_name_regex)
}
inline void TraceConfig_TriggerConfig_Trigger::set_producer_name_regex(const char* value) {
  set_has_producer_name_regex();
  producer_name_regex_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.TraceConfig.TriggerConfig.Trigger.producer_name_regex)
}
inline void TraceConfig_TriggerConfig_Trigger::set_producer_name_regex(const char* value, size_t size) {
  set_has_producer_name_regex();
  producer_name_regex_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.TraceConfig.TriggerConfig.Trigger.producer_name_regex)
}
inline ::std::string* TraceConfig_TriggerConfig_Trigger::mutable_producer_name_regex() {
  set_has_producer_name_regex();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.TriggerConfig.Trigger.producer_name_regex)
  return producer_name_regex_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TraceConfig_TriggerConfig_Trigger::release_producer_name_regex() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.TriggerConfig.Trigger.producer_name_regex)
  clear_has_producer_name_regex();
  return producer_name_regex_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TraceConfig_TriggerConfig_Trigger::set_allocated_producer_name_regex(::std::string* producer_name_regex) {
  if (producer_name_regex != NULL) {
    set_has_producer_name_regex();
  } else {
    clear_has_producer_name_regex();
  }
  producer_name_regex_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), producer_name_regex);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.TriggerConfig.Trigger.producer_name_regex)
}

// optional uint32 stop_delay_ms = 3;
inline bool TraceConfig_TriggerConfig_Trigger::has_stop_delay_ms() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TraceConfig_TriggerConfig_Trigger::set_has_stop_delay_ms() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TraceConfig_TriggerConfig_Trigger::clear_has_stop_delay_ms() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TraceConfig_TriggerConfig_Trigger::clear_stop_delay_ms() {
  stop_delay_ms_ = 0u;
  clear_has_stop_delay_ms();
}
inline ::google::protobuf::uint32 TraceConfig_TriggerConfig_Trigger::stop_delay_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.TriggerConfig.Trigger.stop_delay_ms)
  return stop_delay_ms_;
}
inline void TraceConfig_TriggerConfig_Trigger::set_stop_delay_ms(::google::protobuf::uint32 value) {
  set_has_stop_delay_ms();
  stop_delay_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.TriggerConfig.Trigger.stop_delay_ms)
}

// -------------------------------------------------------------------

// TraceConfig_TriggerConfig

// optional .perfetto.protos.TraceConfig.TriggerConfig.TriggerMode trigger_mode = 1;
inline bool TraceConfig_TriggerConfig::has_trigger_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TraceConfig_TriggerConfig::set_has_trigger_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TraceConfig_TriggerConfig::clear_has_trigger_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TraceConfig_TriggerConfig::clear_trigger_mode() {
  trigger_mode_ = 0;
  clear_has_trigger_mode();
}
inline ::perfetto::protos::TraceConfig_TriggerConfig_TriggerMode TraceConfig_TriggerConfig::trigger_mode() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.TriggerConfig.trigger_mode)
  return static_cast< ::perfetto::protos::TraceConfig_TriggerConfig_TriggerMode >(trigger_mode_);
}
inline void TraceConfig_TriggerConfig::set_trigger_mode(::perfetto::protos::TraceConfig_TriggerConfig_TriggerMode value) {
  assert(::perfetto::protos::TraceConfig_TriggerConfig_TriggerMode_IsValid(value));
  set_has_trigger_mode();
  trigger_mode_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.TriggerConfig.trigger_mode)
}

// repeated .perfetto.protos.TraceConfig.TriggerConfig.Trigger triggers = 2;
inline int TraceConfig_TriggerConfig::triggers_size() const {
  return triggers_.size();
}
inline void TraceConfig_TriggerConfig::clear_triggers() {
  triggers_.Clear();
}
inline const ::perfetto::protos::TraceConfig_TriggerConfig_Trigger& TraceConfig_TriggerConfig::triggers(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.TriggerConfig.triggers)
  return triggers_.Get(index);
}
inline ::perfetto::protos::TraceConfig_TriggerConfig_Trigger* TraceConfig_TriggerConfig::mutable_triggers(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.TriggerConfig.triggers)
  return triggers_.Mutable(index);
}
inline ::perfetto::protos::TraceConfig_TriggerConfig_Trigger* TraceConfig_TriggerConfig::add_triggers() {
  // @@protoc_insertion_point(field_add:perfetto.protos.TraceConfig.TriggerConfig.triggers)
  return triggers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_TriggerConfig_Trigger >*
TraceConfig_TriggerConfig::mutable_triggers() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.TraceConfig.TriggerConfig.triggers)
  return &triggers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_TriggerConfig_Trigger >&
TraceConfig_TriggerConfig::triggers() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.TraceConfig.TriggerConfig.triggers)
  return triggers_;
}

// optional uint32 trigger_timeout_ms = 3;
inline bool TraceConfig_TriggerConfig::has_trigger_timeout_ms() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TraceConfig_TriggerConfig::set_has_trigger_timeout_ms() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TraceConfig_TriggerConfig::clear_has_trigger_timeout_ms() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TraceConfig_TriggerConfig::clear_trigger_timeout_ms() {
  trigger_timeout_ms_ = 0u;
  clear_has_trigger_timeout_ms();
}
inline ::google::protobuf::uint32 TraceConfig_TriggerConfig::trigger_timeout_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.TriggerConfig.trigger_timeout_ms)
  return trigger_timeout_ms_;
}
inline void TraceConfig_TriggerConfig::set_trigger_timeout_ms(::google::protobuf::uint32 value) {
  set_has_trigger_timeout_ms();
  trigger_timeout_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.TriggerConfig.trigger_timeout_ms)
}

// -------------------------------------------------------------------

// TraceConfig_IncrementalStateConfig

// optional uint32 clear_period_ms = 1;
inline bool TraceConfig_IncrementalStateConfig::has_clear_period_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TraceConfig_IncrementalStateConfig::set_has_clear_period_ms() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TraceConfig_IncrementalStateConfig::clear_has_clear_period_ms() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TraceConfig_IncrementalStateConfig::clear_clear_period_ms() {
  clear_period_ms_ = 0u;
  clear_has_clear_period_ms();
}
inline ::google::protobuf::uint32 TraceConfig_IncrementalStateConfig::clear_period_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.IncrementalStateConfig.clear_period_ms)
  return clear_period_ms_;
}
inline void TraceConfig_IncrementalStateConfig::set_clear_period_ms(::google::protobuf::uint32 value) {
  set_has_clear_period_ms();
  clear_period_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.IncrementalStateConfig.clear_period_ms)
}

// -------------------------------------------------------------------

// TraceConfig_IncidentReportConfig

// optional string destination_package = 1;
inline bool TraceConfig_IncidentReportConfig::has_destination_package() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TraceConfig_IncidentReportConfig::set_has_destination_package() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TraceConfig_IncidentReportConfig::clear_has_destination_package() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TraceConfig_IncidentReportConfig::clear_destination_package() {
  destination_package_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_destination_package();
}
inline const ::std::string& TraceConfig_IncidentReportConfig::destination_package() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.IncidentReportConfig.destination_package)
  return destination_package_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TraceConfig_IncidentReportConfig::set_destination_package(const ::std::string& value) {
  set_has_destination_package();
  destination_package_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.IncidentReportConfig.destination_package)
}
inline void TraceConfig_IncidentReportConfig::set_destination_package(const char* value) {
  set_has_destination_package();
  destination_package_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.TraceConfig.IncidentReportConfig.destination_package)
}
inline void TraceConfig_IncidentReportConfig::set_destination_package(const char* value, size_t size) {
  set_has_destination_package();
  destination_package_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.TraceConfig.IncidentReportConfig.destination_package)
}
inline ::std::string* TraceConfig_IncidentReportConfig::mutable_destination_package() {
  set_has_destination_package();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.IncidentReportConfig.destination_package)
  return destination_package_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TraceConfig_IncidentReportConfig::release_destination_package() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.IncidentReportConfig.destination_package)
  clear_has_destination_package();
  return destination_package_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TraceConfig_IncidentReportConfig::set_allocated_destination_package(::std::string* destination_package) {
  if (destination_package != NULL) {
    set_has_destination_package();
  } else {
    clear_has_destination_package();
  }
  destination_package_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), destination_package);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.IncidentReportConfig.destination_package)
}

// optional string destination_class = 2;
inline bool TraceConfig_IncidentReportConfig::has_destination_class() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TraceConfig_IncidentReportConfig::set_has_destination_class() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TraceConfig_IncidentReportConfig::clear_has_destination_class() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TraceConfig_IncidentReportConfig::clear_destination_class() {
  destination_class_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_destination_class();
}
inline const ::std::string& TraceConfig_IncidentReportConfig::destination_class() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.IncidentReportConfig.destination_class)
  return destination_class_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TraceConfig_IncidentReportConfig::set_destination_class(const ::std::string& value) {
  set_has_destination_class();
  destination_class_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.IncidentReportConfig.destination_class)
}
inline void TraceConfig_IncidentReportConfig::set_destination_class(const char* value) {
  set_has_destination_class();
  destination_class_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.TraceConfig.IncidentReportConfig.destination_class)
}
inline void TraceConfig_IncidentReportConfig::set_destination_class(const char* value, size_t size) {
  set_has_destination_class();
  destination_class_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.TraceConfig.IncidentReportConfig.destination_class)
}
inline ::std::string* TraceConfig_IncidentReportConfig::mutable_destination_class() {
  set_has_destination_class();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.IncidentReportConfig.destination_class)
  return destination_class_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TraceConfig_IncidentReportConfig::release_destination_class() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.IncidentReportConfig.destination_class)
  clear_has_destination_class();
  return destination_class_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TraceConfig_IncidentReportConfig::set_allocated_destination_class(::std::string* destination_class) {
  if (destination_class != NULL) {
    set_has_destination_class();
  } else {
    clear_has_destination_class();
  }
  destination_class_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), destination_class);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.IncidentReportConfig.destination_class)
}

// optional int32 privacy_level = 3;
inline bool TraceConfig_IncidentReportConfig::has_privacy_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TraceConfig_IncidentReportConfig::set_has_privacy_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TraceConfig_IncidentReportConfig::clear_has_privacy_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TraceConfig_IncidentReportConfig::clear_privacy_level() {
  privacy_level_ = 0;
  clear_has_privacy_level();
}
inline ::google::protobuf::int32 TraceConfig_IncidentReportConfig::privacy_level() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.IncidentReportConfig.privacy_level)
  return privacy_level_;
}
inline void TraceConfig_IncidentReportConfig::set_privacy_level(::google::protobuf::int32 value) {
  set_has_privacy_level();
  privacy_level_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.IncidentReportConfig.privacy_level)
}

// optional bool skip_dropbox = 4;
inline bool TraceConfig_IncidentReportConfig::has_skip_dropbox() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TraceConfig_IncidentReportConfig::set_has_skip_dropbox() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TraceConfig_IncidentReportConfig::clear_has_skip_dropbox() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TraceConfig_IncidentReportConfig::clear_skip_dropbox() {
  skip_dropbox_ = false;
  clear_has_skip_dropbox();
}
inline bool TraceConfig_IncidentReportConfig::skip_dropbox() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.IncidentReportConfig.skip_dropbox)
  return skip_dropbox_;
}
inline void TraceConfig_IncidentReportConfig::set_skip_dropbox(bool value) {
  set_has_skip_dropbox();
  skip_dropbox_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.IncidentReportConfig.skip_dropbox)
}

// -------------------------------------------------------------------

// TraceConfig

// repeated .perfetto.protos.TraceConfig.BufferConfig buffers = 1;
inline int TraceConfig::buffers_size() const {
  return buffers_.size();
}
inline void TraceConfig::clear_buffers() {
  buffers_.Clear();
}
inline const ::perfetto::protos::TraceConfig_BufferConfig& TraceConfig::buffers(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.buffers)
  return buffers_.Get(index);
}
inline ::perfetto::protos::TraceConfig_BufferConfig* TraceConfig::mutable_buffers(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.buffers)
  return buffers_.Mutable(index);
}
inline ::perfetto::protos::TraceConfig_BufferConfig* TraceConfig::add_buffers() {
  // @@protoc_insertion_point(field_add:perfetto.protos.TraceConfig.buffers)
  return buffers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_BufferConfig >*
TraceConfig::mutable_buffers() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.TraceConfig.buffers)
  return &buffers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_BufferConfig >&
TraceConfig::buffers() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.TraceConfig.buffers)
  return buffers_;
}

// repeated .perfetto.protos.TraceConfig.DataSource data_sources = 2;
inline int TraceConfig::data_sources_size() const {
  return data_sources_.size();
}
inline void TraceConfig::clear_data_sources() {
  data_sources_.Clear();
}
inline const ::perfetto::protos::TraceConfig_DataSource& TraceConfig::data_sources(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.data_sources)
  return data_sources_.Get(index);
}
inline ::perfetto::protos::TraceConfig_DataSource* TraceConfig::mutable_data_sources(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.data_sources)
  return data_sources_.Mutable(index);
}
inline ::perfetto::protos::TraceConfig_DataSource* TraceConfig::add_data_sources() {
  // @@protoc_insertion_point(field_add:perfetto.protos.TraceConfig.data_sources)
  return data_sources_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_DataSource >*
TraceConfig::mutable_data_sources() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.TraceConfig.data_sources)
  return &data_sources_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_DataSource >&
TraceConfig::data_sources() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.TraceConfig.data_sources)
  return data_sources_;
}

// optional .perfetto.protos.TraceConfig.BuiltinDataSource builtin_data_sources = 20;
inline bool TraceConfig::has_builtin_data_sources() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TraceConfig::set_has_builtin_data_sources() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TraceConfig::clear_has_builtin_data_sources() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TraceConfig::clear_builtin_data_sources() {
  if (builtin_data_sources_ != NULL) builtin_data_sources_->::perfetto::protos::TraceConfig_BuiltinDataSource::Clear();
  clear_has_builtin_data_sources();
}
inline const ::perfetto::protos::TraceConfig_BuiltinDataSource& TraceConfig::builtin_data_sources() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.builtin_data_sources)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return builtin_data_sources_ != NULL ? *builtin_data_sources_ : *default_instance().builtin_data_sources_;
#else
  return builtin_data_sources_ != NULL ? *builtin_data_sources_ : *default_instance_->builtin_data_sources_;
#endif
}
inline ::perfetto::protos::TraceConfig_BuiltinDataSource* TraceConfig::mutable_builtin_data_sources() {
  set_has_builtin_data_sources();
  if (builtin_data_sources_ == NULL) {
    builtin_data_sources_ = new ::perfetto::protos::TraceConfig_BuiltinDataSource;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.builtin_data_sources)
  return builtin_data_sources_;
}
inline ::perfetto::protos::TraceConfig_BuiltinDataSource* TraceConfig::release_builtin_data_sources() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.builtin_data_sources)
  clear_has_builtin_data_sources();
  ::perfetto::protos::TraceConfig_BuiltinDataSource* temp = builtin_data_sources_;
  builtin_data_sources_ = NULL;
  return temp;
}
inline void TraceConfig::set_allocated_builtin_data_sources(::perfetto::protos::TraceConfig_BuiltinDataSource* builtin_data_sources) {
  delete builtin_data_sources_;
  builtin_data_sources_ = builtin_data_sources;
  if (builtin_data_sources) {
    set_has_builtin_data_sources();
  } else {
    clear_has_builtin_data_sources();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.builtin_data_sources)
}

// optional uint32 duration_ms = 3;
inline bool TraceConfig::has_duration_ms() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TraceConfig::set_has_duration_ms() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TraceConfig::clear_has_duration_ms() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TraceConfig::clear_duration_ms() {
  duration_ms_ = 0u;
  clear_has_duration_ms();
}
inline ::google::protobuf::uint32 TraceConfig::duration_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.duration_ms)
  return duration_ms_;
}
inline void TraceConfig::set_duration_ms(::google::protobuf::uint32 value) {
  set_has_duration_ms();
  duration_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.duration_ms)
}

// optional bool enable_extra_guardrails = 4;
inline bool TraceConfig::has_enable_extra_guardrails() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TraceConfig::set_has_enable_extra_guardrails() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TraceConfig::clear_has_enable_extra_guardrails() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TraceConfig::clear_enable_extra_guardrails() {
  enable_extra_guardrails_ = false;
  clear_has_enable_extra_guardrails();
}
inline bool TraceConfig::enable_extra_guardrails() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.enable_extra_guardrails)
  return enable_extra_guardrails_;
}
inline void TraceConfig::set_enable_extra_guardrails(bool value) {
  set_has_enable_extra_guardrails();
  enable_extra_guardrails_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.enable_extra_guardrails)
}

// optional .perfetto.protos.TraceConfig.LockdownModeOperation lockdown_mode = 5;
inline bool TraceConfig::has_lockdown_mode() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TraceConfig::set_has_lockdown_mode() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TraceConfig::clear_has_lockdown_mode() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TraceConfig::clear_lockdown_mode() {
  lockdown_mode_ = 0;
  clear_has_lockdown_mode();
}
inline ::perfetto::protos::TraceConfig_LockdownModeOperation TraceConfig::lockdown_mode() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.lockdown_mode)
  return static_cast< ::perfetto::protos::TraceConfig_LockdownModeOperation >(lockdown_mode_);
}
inline void TraceConfig::set_lockdown_mode(::perfetto::protos::TraceConfig_LockdownModeOperation value) {
  assert(::perfetto::protos::TraceConfig_LockdownModeOperation_IsValid(value));
  set_has_lockdown_mode();
  lockdown_mode_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.lockdown_mode)
}

// repeated .perfetto.protos.TraceConfig.ProducerConfig producers = 6;
inline int TraceConfig::producers_size() const {
  return producers_.size();
}
inline void TraceConfig::clear_producers() {
  producers_.Clear();
}
inline const ::perfetto::protos::TraceConfig_ProducerConfig& TraceConfig::producers(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.producers)
  return producers_.Get(index);
}
inline ::perfetto::protos::TraceConfig_ProducerConfig* TraceConfig::mutable_producers(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.producers)
  return producers_.Mutable(index);
}
inline ::perfetto::protos::TraceConfig_ProducerConfig* TraceConfig::add_producers() {
  // @@protoc_insertion_point(field_add:perfetto.protos.TraceConfig.producers)
  return producers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_ProducerConfig >*
TraceConfig::mutable_producers() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.TraceConfig.producers)
  return &producers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_ProducerConfig >&
TraceConfig::producers() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.TraceConfig.producers)
  return producers_;
}

// optional .perfetto.protos.TraceConfig.StatsdMetadata statsd_metadata = 7;
inline bool TraceConfig::has_statsd_metadata() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TraceConfig::set_has_statsd_metadata() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TraceConfig::clear_has_statsd_metadata() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TraceConfig::clear_statsd_metadata() {
  if (statsd_metadata_ != NULL) statsd_metadata_->::perfetto::protos::TraceConfig_StatsdMetadata::Clear();
  clear_has_statsd_metadata();
}
inline const ::perfetto::protos::TraceConfig_StatsdMetadata& TraceConfig::statsd_metadata() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.statsd_metadata)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return statsd_metadata_ != NULL ? *statsd_metadata_ : *default_instance().statsd_metadata_;
#else
  return statsd_metadata_ != NULL ? *statsd_metadata_ : *default_instance_->statsd_metadata_;
#endif
}
inline ::perfetto::protos::TraceConfig_StatsdMetadata* TraceConfig::mutable_statsd_metadata() {
  set_has_statsd_metadata();
  if (statsd_metadata_ == NULL) {
    statsd_metadata_ = new ::perfetto::protos::TraceConfig_StatsdMetadata;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.statsd_metadata)
  return statsd_metadata_;
}
inline ::perfetto::protos::TraceConfig_StatsdMetadata* TraceConfig::release_statsd_metadata() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.statsd_metadata)
  clear_has_statsd_metadata();
  ::perfetto::protos::TraceConfig_StatsdMetadata* temp = statsd_metadata_;
  statsd_metadata_ = NULL;
  return temp;
}
inline void TraceConfig::set_allocated_statsd_metadata(::perfetto::protos::TraceConfig_StatsdMetadata* statsd_metadata) {
  delete statsd_metadata_;
  statsd_metadata_ = statsd_metadata;
  if (statsd_metadata) {
    set_has_statsd_metadata();
  } else {
    clear_has_statsd_metadata();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.statsd_metadata)
}

// optional bool write_into_file = 8;
inline bool TraceConfig::has_write_into_file() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TraceConfig::set_has_write_into_file() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TraceConfig::clear_has_write_into_file() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TraceConfig::clear_write_into_file() {
  write_into_file_ = false;
  clear_has_write_into_file();
}
inline bool TraceConfig::write_into_file() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.write_into_file)
  return write_into_file_;
}
inline void TraceConfig::set_write_into_file(bool value) {
  set_has_write_into_file();
  write_into_file_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.write_into_file)
}

// optional uint32 file_write_period_ms = 9;
inline bool TraceConfig::has_file_write_period_ms() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TraceConfig::set_has_file_write_period_ms() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TraceConfig::clear_has_file_write_period_ms() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TraceConfig::clear_file_write_period_ms() {
  file_write_period_ms_ = 0u;
  clear_has_file_write_period_ms();
}
inline ::google::protobuf::uint32 TraceConfig::file_write_period_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.file_write_period_ms)
  return file_write_period_ms_;
}
inline void TraceConfig::set_file_write_period_ms(::google::protobuf::uint32 value) {
  set_has_file_write_period_ms();
  file_write_period_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.file_write_period_ms)
}

// optional uint64 max_file_size_bytes = 10;
inline bool TraceConfig::has_max_file_size_bytes() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TraceConfig::set_has_max_file_size_bytes() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TraceConfig::clear_has_max_file_size_bytes() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TraceConfig::clear_max_file_size_bytes() {
  max_file_size_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_max_file_size_bytes();
}
inline ::google::protobuf::uint64 TraceConfig::max_file_size_bytes() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.max_file_size_bytes)
  return max_file_size_bytes_;
}
inline void TraceConfig::set_max_file_size_bytes(::google::protobuf::uint64 value) {
  set_has_max_file_size_bytes();
  max_file_size_bytes_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.max_file_size_bytes)
}

// optional .perfetto.protos.TraceConfig.GuardrailOverrides guardrail_overrides = 11;
inline bool TraceConfig::has_guardrail_overrides() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TraceConfig::set_has_guardrail_overrides() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TraceConfig::clear_has_guardrail_overrides() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TraceConfig::clear_guardrail_overrides() {
  if (guardrail_overrides_ != NULL) guardrail_overrides_->::perfetto::protos::TraceConfig_GuardrailOverrides::Clear();
  clear_has_guardrail_overrides();
}
inline const ::perfetto::protos::TraceConfig_GuardrailOverrides& TraceConfig::guardrail_overrides() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.guardrail_overrides)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return guardrail_overrides_ != NULL ? *guardrail_overrides_ : *default_instance().guardrail_overrides_;
#else
  return guardrail_overrides_ != NULL ? *guardrail_overrides_ : *default_instance_->guardrail_overrides_;
#endif
}
inline ::perfetto::protos::TraceConfig_GuardrailOverrides* TraceConfig::mutable_guardrail_overrides() {
  set_has_guardrail_overrides();
  if (guardrail_overrides_ == NULL) {
    guardrail_overrides_ = new ::perfetto::protos::TraceConfig_GuardrailOverrides;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.guardrail_overrides)
  return guardrail_overrides_;
}
inline ::perfetto::protos::TraceConfig_GuardrailOverrides* TraceConfig::release_guardrail_overrides() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.guardrail_overrides)
  clear_has_guardrail_overrides();
  ::perfetto::protos::TraceConfig_GuardrailOverrides* temp = guardrail_overrides_;
  guardrail_overrides_ = NULL;
  return temp;
}
inline void TraceConfig::set_allocated_guardrail_overrides(::perfetto::protos::TraceConfig_GuardrailOverrides* guardrail_overrides) {
  delete guardrail_overrides_;
  guardrail_overrides_ = guardrail_overrides;
  if (guardrail_overrides) {
    set_has_guardrail_overrides();
  } else {
    clear_has_guardrail_overrides();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.guardrail_overrides)
}

// optional bool deferred_start = 12;
inline bool TraceConfig::has_deferred_start() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TraceConfig::set_has_deferred_start() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TraceConfig::clear_has_deferred_start() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TraceConfig::clear_deferred_start() {
  deferred_start_ = false;
  clear_has_deferred_start();
}
inline bool TraceConfig::deferred_start() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.deferred_start)
  return deferred_start_;
}
inline void TraceConfig::set_deferred_start(bool value) {
  set_has_deferred_start();
  deferred_start_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.deferred_start)
}

// optional uint32 flush_period_ms = 13;
inline bool TraceConfig::has_flush_period_ms() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TraceConfig::set_has_flush_period_ms() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TraceConfig::clear_has_flush_period_ms() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TraceConfig::clear_flush_period_ms() {
  flush_period_ms_ = 0u;
  clear_has_flush_period_ms();
}
inline ::google::protobuf::uint32 TraceConfig::flush_period_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.flush_period_ms)
  return flush_period_ms_;
}
inline void TraceConfig::set_flush_period_ms(::google::protobuf::uint32 value) {
  set_has_flush_period_ms();
  flush_period_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.flush_period_ms)
}

// optional uint32 flush_timeout_ms = 14;
inline bool TraceConfig::has_flush_timeout_ms() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TraceConfig::set_has_flush_timeout_ms() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TraceConfig::clear_has_flush_timeout_ms() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TraceConfig::clear_flush_timeout_ms() {
  flush_timeout_ms_ = 0u;
  clear_has_flush_timeout_ms();
}
inline ::google::protobuf::uint32 TraceConfig::flush_timeout_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.flush_timeout_ms)
  return flush_timeout_ms_;
}
inline void TraceConfig::set_flush_timeout_ms(::google::protobuf::uint32 value) {
  set_has_flush_timeout_ms();
  flush_timeout_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.flush_timeout_ms)
}

// optional uint32 data_source_stop_timeout_ms = 23;
inline bool TraceConfig::has_data_source_stop_timeout_ms() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TraceConfig::set_has_data_source_stop_timeout_ms() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TraceConfig::clear_has_data_source_stop_timeout_ms() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TraceConfig::clear_data_source_stop_timeout_ms() {
  data_source_stop_timeout_ms_ = 0u;
  clear_has_data_source_stop_timeout_ms();
}
inline ::google::protobuf::uint32 TraceConfig::data_source_stop_timeout_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.data_source_stop_timeout_ms)
  return data_source_stop_timeout_ms_;
}
inline void TraceConfig::set_data_source_stop_timeout_ms(::google::protobuf::uint32 value) {
  set_has_data_source_stop_timeout_ms();
  data_source_stop_timeout_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.data_source_stop_timeout_ms)
}

// optional bool notify_traceur = 16;
inline bool TraceConfig::has_notify_traceur() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TraceConfig::set_has_notify_traceur() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TraceConfig::clear_has_notify_traceur() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TraceConfig::clear_notify_traceur() {
  notify_traceur_ = false;
  clear_has_notify_traceur();
}
inline bool TraceConfig::notify_traceur() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.notify_traceur)
  return notify_traceur_;
}
inline void TraceConfig::set_notify_traceur(bool value) {
  set_has_notify_traceur();
  notify_traceur_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.notify_traceur)
}

// optional .perfetto.protos.TraceConfig.TriggerConfig trigger_config = 17;
inline bool TraceConfig::has_trigger_config() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TraceConfig::set_has_trigger_config() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TraceConfig::clear_has_trigger_config() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TraceConfig::clear_trigger_config() {
  if (trigger_config_ != NULL) trigger_config_->::perfetto::protos::TraceConfig_TriggerConfig::Clear();
  clear_has_trigger_config();
}
inline const ::perfetto::protos::TraceConfig_TriggerConfig& TraceConfig::trigger_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.trigger_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return trigger_config_ != NULL ? *trigger_config_ : *default_instance().trigger_config_;
#else
  return trigger_config_ != NULL ? *trigger_config_ : *default_instance_->trigger_config_;
#endif
}
inline ::perfetto::protos::TraceConfig_TriggerConfig* TraceConfig::mutable_trigger_config() {
  set_has_trigger_config();
  if (trigger_config_ == NULL) {
    trigger_config_ = new ::perfetto::protos::TraceConfig_TriggerConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.trigger_config)
  return trigger_config_;
}
inline ::perfetto::protos::TraceConfig_TriggerConfig* TraceConfig::release_trigger_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.trigger_config)
  clear_has_trigger_config();
  ::perfetto::protos::TraceConfig_TriggerConfig* temp = trigger_config_;
  trigger_config_ = NULL;
  return temp;
}
inline void TraceConfig::set_allocated_trigger_config(::perfetto::protos::TraceConfig_TriggerConfig* trigger_config) {
  delete trigger_config_;
  trigger_config_ = trigger_config;
  if (trigger_config) {
    set_has_trigger_config();
  } else {
    clear_has_trigger_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.trigger_config)
}

// repeated string activate_triggers = 18;
inline int TraceConfig::activate_triggers_size() const {
  return activate_triggers_.size();
}
inline void TraceConfig::clear_activate_triggers() {
  activate_triggers_.Clear();
}
inline const ::std::string& TraceConfig::activate_triggers(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.activate_triggers)
  return activate_triggers_.Get(index);
}
inline ::std::string* TraceConfig::mutable_activate_triggers(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.activate_triggers)
  return activate_triggers_.Mutable(index);
}
inline void TraceConfig::set_activate_triggers(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.activate_triggers)
  activate_triggers_.Mutable(index)->assign(value);
}
inline void TraceConfig::set_activate_triggers(int index, const char* value) {
  activate_triggers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.TraceConfig.activate_triggers)
}
inline void TraceConfig::set_activate_triggers(int index, const char* value, size_t size) {
  activate_triggers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.TraceConfig.activate_triggers)
}
inline ::std::string* TraceConfig::add_activate_triggers() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.TraceConfig.activate_triggers)
  return activate_triggers_.Add();
}
inline void TraceConfig::add_activate_triggers(const ::std::string& value) {
  activate_triggers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.TraceConfig.activate_triggers)
}
inline void TraceConfig::add_activate_triggers(const char* value) {
  activate_triggers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.TraceConfig.activate_triggers)
}
inline void TraceConfig::add_activate_triggers(const char* value, size_t size) {
  activate_triggers_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.TraceConfig.activate_triggers)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TraceConfig::activate_triggers() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.TraceConfig.activate_triggers)
  return activate_triggers_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TraceConfig::mutable_activate_triggers() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.TraceConfig.activate_triggers)
  return &activate_triggers_;
}

// optional .perfetto.protos.TraceConfig.IncrementalStateConfig incremental_state_config = 21;
inline bool TraceConfig::has_incremental_state_config() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void TraceConfig::set_has_incremental_state_config() {
  _has_bits_[0] |= 0x00080000u;
}
inline void TraceConfig::clear_has_incremental_state_config() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void TraceConfig::clear_incremental_state_config() {
  if (incremental_state_config_ != NULL) incremental_state_config_->::perfetto::protos::TraceConfig_IncrementalStateConfig::Clear();
  clear_has_incremental_state_config();
}
inline const ::perfetto::protos::TraceConfig_IncrementalStateConfig& TraceConfig::incremental_state_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.incremental_state_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return incremental_state_config_ != NULL ? *incremental_state_config_ : *default_instance().incremental_state_config_;
#else
  return incremental_state_config_ != NULL ? *incremental_state_config_ : *default_instance_->incremental_state_config_;
#endif
}
inline ::perfetto::protos::TraceConfig_IncrementalStateConfig* TraceConfig::mutable_incremental_state_config() {
  set_has_incremental_state_config();
  if (incremental_state_config_ == NULL) {
    incremental_state_config_ = new ::perfetto::protos::TraceConfig_IncrementalStateConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.incremental_state_config)
  return incremental_state_config_;
}
inline ::perfetto::protos::TraceConfig_IncrementalStateConfig* TraceConfig::release_incremental_state_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.incremental_state_config)
  clear_has_incremental_state_config();
  ::perfetto::protos::TraceConfig_IncrementalStateConfig* temp = incremental_state_config_;
  incremental_state_config_ = NULL;
  return temp;
}
inline void TraceConfig::set_allocated_incremental_state_config(::perfetto::protos::TraceConfig_IncrementalStateConfig* incremental_state_config) {
  delete incremental_state_config_;
  incremental_state_config_ = incremental_state_config;
  if (incremental_state_config) {
    set_has_incremental_state_config();
  } else {
    clear_has_incremental_state_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.incremental_state_config)
}

// optional bool allow_user_build_tracing = 19;
inline bool TraceConfig::has_allow_user_build_tracing() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void TraceConfig::set_has_allow_user_build_tracing() {
  _has_bits_[0] |= 0x00100000u;
}
inline void TraceConfig::clear_has_allow_user_build_tracing() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void TraceConfig::clear_allow_user_build_tracing() {
  allow_user_build_tracing_ = false;
  clear_has_allow_user_build_tracing();
}
inline bool TraceConfig::allow_user_build_tracing() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.allow_user_build_tracing)
  return allow_user_build_tracing_;
}
inline void TraceConfig::set_allow_user_build_tracing(bool value) {
  set_has_allow_user_build_tracing();
  allow_user_build_tracing_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.allow_user_build_tracing)
}

// optional string unique_session_name = 22;
inline bool TraceConfig::has_unique_session_name() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void TraceConfig::set_has_unique_session_name() {
  _has_bits_[0] |= 0x00200000u;
}
inline void TraceConfig::clear_has_unique_session_name() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void TraceConfig::clear_unique_session_name() {
  unique_session_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_unique_session_name();
}
inline const ::std::string& TraceConfig::unique_session_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.unique_session_name)
  return unique_session_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TraceConfig::set_unique_session_name(const ::std::string& value) {
  set_has_unique_session_name();
  unique_session_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.unique_session_name)
}
inline void TraceConfig::set_unique_session_name(const char* value) {
  set_has_unique_session_name();
  unique_session_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.TraceConfig.unique_session_name)
}
inline void TraceConfig::set_unique_session_name(const char* value, size_t size) {
  set_has_unique_session_name();
  unique_session_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.TraceConfig.unique_session_name)
}
inline ::std::string* TraceConfig::mutable_unique_session_name() {
  set_has_unique_session_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.unique_session_name)
  return unique_session_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TraceConfig::release_unique_session_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.unique_session_name)
  clear_has_unique_session_name();
  return unique_session_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TraceConfig::set_allocated_unique_session_name(::std::string* unique_session_name) {
  if (unique_session_name != NULL) {
    set_has_unique_session_name();
  } else {
    clear_has_unique_session_name();
  }
  unique_session_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), unique_session_name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.unique_session_name)
}

// optional .perfetto.protos.TraceConfig.CompressionType compression_type = 24;
inline bool TraceConfig::has_compression_type() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void TraceConfig::set_has_compression_type() {
  _has_bits_[0] |= 0x00400000u;
}
inline void TraceConfig::clear_has_compression_type() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void TraceConfig::clear_compression_type() {
  compression_type_ = 0;
  clear_has_compression_type();
}
inline ::perfetto::protos::TraceConfig_CompressionType TraceConfig::compression_type() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.compression_type)
  return static_cast< ::perfetto::protos::TraceConfig_CompressionType >(compression_type_);
}
inline void TraceConfig::set_compression_type(::perfetto::protos::TraceConfig_CompressionType value) {
  assert(::perfetto::protos::TraceConfig_CompressionType_IsValid(value));
  set_has_compression_type();
  compression_type_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.compression_type)
}

// optional .perfetto.protos.TraceConfig.IncidentReportConfig incident_report_config = 25;
inline bool TraceConfig::has_incident_report_config() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void TraceConfig::set_has_incident_report_config() {
  _has_bits_[0] |= 0x00800000u;
}
inline void TraceConfig::clear_has_incident_report_config() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void TraceConfig::clear_incident_report_config() {
  if (incident_report_config_ != NULL) incident_report_config_->::perfetto::protos::TraceConfig_IncidentReportConfig::Clear();
  clear_has_incident_report_config();
}
inline const ::perfetto::protos::TraceConfig_IncidentReportConfig& TraceConfig::incident_report_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.incident_report_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return incident_report_config_ != NULL ? *incident_report_config_ : *default_instance().incident_report_config_;
#else
  return incident_report_config_ != NULL ? *incident_report_config_ : *default_instance_->incident_report_config_;
#endif
}
inline ::perfetto::protos::TraceConfig_IncidentReportConfig* TraceConfig::mutable_incident_report_config() {
  set_has_incident_report_config();
  if (incident_report_config_ == NULL) {
    incident_report_config_ = new ::perfetto::protos::TraceConfig_IncidentReportConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.incident_report_config)
  return incident_report_config_;
}
inline ::perfetto::protos::TraceConfig_IncidentReportConfig* TraceConfig::release_incident_report_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.incident_report_config)
  clear_has_incident_report_config();
  ::perfetto::protos::TraceConfig_IncidentReportConfig* temp = incident_report_config_;
  incident_report_config_ = NULL;
  return temp;
}
inline void TraceConfig::set_allocated_incident_report_config(::perfetto::protos::TraceConfig_IncidentReportConfig* incident_report_config) {
  delete incident_report_config_;
  incident_report_config_ = incident_report_config;
  if (incident_report_config) {
    set_has_incident_report_config();
  } else {
    clear_has_incident_report_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.incident_report_config)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::perfetto::protos::TraceConfig_BufferConfig_FillPolicy> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::perfetto::protos::TraceConfig_TriggerConfig_TriggerMode> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::perfetto::protos::TraceConfig_LockdownModeOperation> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::perfetto::protos::TraceConfig_CompressionType> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_perfetto_2fconfig_2ftrace_5fconfig_2eproto__INCLUDED
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/config/trace_config.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
// gen_amalgamated expanded: #include "perfetto/config/trace_config.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

void protobuf_ShutdownFile_perfetto_2fconfig_2ftrace_5fconfig_2eproto() {
  delete TraceConfig::default_instance_;
  delete TraceConfig_BufferConfig::default_instance_;
  delete TraceConfig_DataSource::default_instance_;
  delete TraceConfig_BuiltinDataSource::default_instance_;
  delete TraceConfig_ProducerConfig::default_instance_;
  delete TraceConfig_StatsdMetadata::default_instance_;
  delete TraceConfig_GuardrailOverrides::default_instance_;
  delete TraceConfig_TriggerConfig::default_instance_;
  delete TraceConfig_TriggerConfig_Trigger::default_instance_;
  delete TraceConfig_IncrementalStateConfig::default_instance_;
  delete TraceConfig_IncidentReportConfig::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::perfetto::protos::protobuf_AddDesc_perfetto_2fconfig_2fdata_5fsource_5fconfig_2eproto();
  TraceConfig::default_instance_ = new TraceConfig();
  TraceConfig_BufferConfig::default_instance_ = new TraceConfig_BufferConfig();
  TraceConfig_DataSource::default_instance_ = new TraceConfig_DataSource();
  TraceConfig_BuiltinDataSource::default_instance_ = new TraceConfig_BuiltinDataSource();
  TraceConfig_ProducerConfig::default_instance_ = new TraceConfig_ProducerConfig();
  TraceConfig_StatsdMetadata::default_instance_ = new TraceConfig_StatsdMetadata();
  TraceConfig_GuardrailOverrides::default_instance_ = new TraceConfig_GuardrailOverrides();
  TraceConfig_TriggerConfig::default_instance_ = new TraceConfig_TriggerConfig();
  TraceConfig_TriggerConfig_Trigger::default_instance_ = new TraceConfig_TriggerConfig_Trigger();
  TraceConfig_IncrementalStateConfig::default_instance_ = new TraceConfig_IncrementalStateConfig();
  TraceConfig_IncidentReportConfig::default_instance_ = new TraceConfig_IncidentReportConfig();
  TraceConfig::default_instance_->InitAsDefaultInstance();
  TraceConfig_BufferConfig::default_instance_->InitAsDefaultInstance();
  TraceConfig_DataSource::default_instance_->InitAsDefaultInstance();
  TraceConfig_BuiltinDataSource::default_instance_->InitAsDefaultInstance();
  TraceConfig_ProducerConfig::default_instance_->InitAsDefaultInstance();
  TraceConfig_StatsdMetadata::default_instance_->InitAsDefaultInstance();
  TraceConfig_GuardrailOverrides::default_instance_->InitAsDefaultInstance();
  TraceConfig_TriggerConfig::default_instance_->InitAsDefaultInstance();
  TraceConfig_TriggerConfig_Trigger::default_instance_->InitAsDefaultInstance();
  TraceConfig_IncrementalStateConfig::default_instance_->InitAsDefaultInstance();
  TraceConfig_IncidentReportConfig::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_perfetto_2fconfig_2ftrace_5fconfig_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto_once_);
void protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto_once_,
                 &protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_perfetto_2fconfig_2ftrace_5fconfig_2eproto {
  StaticDescriptorInitializer_perfetto_2fconfig_2ftrace_5fconfig_2eproto() {
    protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto();
  }
} static_descriptor_initializer_perfetto_2fconfig_2ftrace_5fconfig_2eproto_;
#endif

namespace {

static void trace_config_pb_MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
static void trace_config_pb_MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

static ::std::string* MutableUnknownFieldsForTraceConfig(
    TraceConfig* ptr) {
  return ptr->mutable_unknown_fields();
}

bool TraceConfig_LockdownModeOperation_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const TraceConfig_LockdownModeOperation TraceConfig::LOCKDOWN_UNCHANGED;
const TraceConfig_LockdownModeOperation TraceConfig::LOCKDOWN_CLEAR;
const TraceConfig_LockdownModeOperation TraceConfig::LOCKDOWN_SET;
const TraceConfig_LockdownModeOperation TraceConfig::LockdownModeOperation_MIN;
const TraceConfig_LockdownModeOperation TraceConfig::LockdownModeOperation_MAX;
const int TraceConfig::LockdownModeOperation_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
bool TraceConfig_CompressionType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const TraceConfig_CompressionType TraceConfig::COMPRESSION_TYPE_UNSPECIFIED;
const TraceConfig_CompressionType TraceConfig::COMPRESSION_TYPE_DEFLATE;
const TraceConfig_CompressionType TraceConfig::CompressionType_MIN;
const TraceConfig_CompressionType TraceConfig::CompressionType_MAX;
const int TraceConfig::CompressionType_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
static ::std::string* MutableUnknownFieldsForTraceConfig_BufferConfig(
    TraceConfig_BufferConfig* ptr) {
  return ptr->mutable_unknown_fields();
}

bool TraceConfig_BufferConfig_FillPolicy_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const TraceConfig_BufferConfig_FillPolicy TraceConfig_BufferConfig::UNSPECIFIED;
const TraceConfig_BufferConfig_FillPolicy TraceConfig_BufferConfig::RING_BUFFER;
const TraceConfig_BufferConfig_FillPolicy TraceConfig_BufferConfig::DISCARD;
const TraceConfig_BufferConfig_FillPolicy TraceConfig_BufferConfig::FillPolicy_MIN;
const TraceConfig_BufferConfig_FillPolicy TraceConfig_BufferConfig::FillPolicy_MAX;
const int TraceConfig_BufferConfig::FillPolicy_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TraceConfig_BufferConfig::kSizeKbFieldNumber;
const int TraceConfig_BufferConfig::kFillPolicyFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TraceConfig_BufferConfig::TraceConfig_BufferConfig()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.TraceConfig.BufferConfig)
}

void TraceConfig_BufferConfig::InitAsDefaultInstance() {
}

TraceConfig_BufferConfig::TraceConfig_BufferConfig(const TraceConfig_BufferConfig& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.TraceConfig.BufferConfig)
}

void TraceConfig_BufferConfig::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  size_kb_ = 0u;
  fill_policy_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TraceConfig_BufferConfig::~TraceConfig_BufferConfig() {
  // @@protoc_insertion_point(destructor:perfetto.protos.TraceConfig.BufferConfig)
  SharedDtor();
}

void TraceConfig_BufferConfig::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TraceConfig_BufferConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TraceConfig_BufferConfig& TraceConfig_BufferConfig::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto();
#endif
  return *default_instance_;
}

TraceConfig_BufferConfig* TraceConfig_BufferConfig::default_instance_ = NULL;

TraceConfig_BufferConfig* TraceConfig_BufferConfig::New(::google::protobuf::Arena* arena) const {
  TraceConfig_BufferConfig* n = new TraceConfig_BufferConfig;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TraceConfig_BufferConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.TraceConfig.BufferConfig)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(TraceConfig_BufferConfig, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<TraceConfig_BufferConfig*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(size_kb_, fill_policy_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool TraceConfig_BufferConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForTraceConfig_BufferConfig, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.TraceConfig.BufferConfig)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 size_kb = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &size_kb_)));
          set_has_size_kb();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_fill_policy;
        break;
      }

      // optional .perfetto.protos.TraceConfig.BufferConfig.FillPolicy fill_policy = 4;
      case 4: {
        if (tag == 32) {
         parse_fill_policy:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::perfetto::protos::TraceConfig_BufferConfig_FillPolicy_IsValid(value)) {
            set_fill_policy(static_cast< ::perfetto::protos::TraceConfig_BufferConfig_FillPolicy >(value));
          } else {
            unknown_fields_stream.WriteVarint32(32);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.TraceConfig.BufferConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.TraceConfig.BufferConfig)
  return false;
#undef DO_
}

void TraceConfig_BufferConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.TraceConfig.BufferConfig)
  // optional uint32 size_kb = 1;
  if (has_size_kb()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->size_kb(), output);
  }

  // optional .perfetto.protos.TraceConfig.BufferConfig.FillPolicy fill_policy = 4;
  if (has_fill_policy()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->fill_policy(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.TraceConfig.BufferConfig)
}

int TraceConfig_BufferConfig::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.TraceConfig.BufferConfig)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional uint32 size_kb = 1;
    if (has_size_kb()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->size_kb());
    }

    // optional .perfetto.protos.TraceConfig.BufferConfig.FillPolicy fill_policy = 4;
    if (has_fill_policy()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->fill_policy());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TraceConfig_BufferConfig::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TraceConfig_BufferConfig*>(&from));
}

void TraceConfig_BufferConfig::MergeFrom(const TraceConfig_BufferConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.TraceConfig.BufferConfig)
  if (GOOGLE_PREDICT_FALSE(&from == this)) trace_config_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_size_kb()) {
      set_size_kb(from.size_kb());
    }
    if (from.has_fill_policy()) {
      set_fill_policy(from.fill_policy());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void TraceConfig_BufferConfig::CopyFrom(const TraceConfig_BufferConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.TraceConfig.BufferConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TraceConfig_BufferConfig::IsInitialized() const {

  return true;
}

void TraceConfig_BufferConfig::Swap(TraceConfig_BufferConfig* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TraceConfig_BufferConfig::InternalSwap(TraceConfig_BufferConfig* other) {
  std::swap(size_kb_, other->size_kb_);
  std::swap(fill_policy_, other->fill_policy_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string TraceConfig_BufferConfig::GetTypeName() const {
  return "perfetto.protos.TraceConfig.BufferConfig";
}


// -------------------------------------------------------------------

static ::std::string* MutableUnknownFieldsForTraceConfig_DataSource(
    TraceConfig_DataSource* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TraceConfig_DataSource::kConfigFieldNumber;
const int TraceConfig_DataSource::kProducerNameFilterFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TraceConfig_DataSource::TraceConfig_DataSource()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.TraceConfig.DataSource)
}

void TraceConfig_DataSource::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  config_ = const_cast< ::perfetto::protos::DataSourceConfig*>(
      ::perfetto::protos::DataSourceConfig::internal_default_instance());
#else
  config_ = const_cast< ::perfetto::protos::DataSourceConfig*>(&::perfetto::protos::DataSourceConfig::default_instance());
#endif
}

TraceConfig_DataSource::TraceConfig_DataSource(const TraceConfig_DataSource& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.TraceConfig.DataSource)
}

void TraceConfig_DataSource::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  config_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TraceConfig_DataSource::~TraceConfig_DataSource() {
  // @@protoc_insertion_point(destructor:perfetto.protos.TraceConfig.DataSource)
  SharedDtor();
}

void TraceConfig_DataSource::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete config_;
  }
}

void TraceConfig_DataSource::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TraceConfig_DataSource& TraceConfig_DataSource::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto();
#endif
  return *default_instance_;
}

TraceConfig_DataSource* TraceConfig_DataSource::default_instance_ = NULL;

TraceConfig_DataSource* TraceConfig_DataSource::New(::google::protobuf::Arena* arena) const {
  TraceConfig_DataSource* n = new TraceConfig_DataSource;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TraceConfig_DataSource::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.TraceConfig.DataSource)
  if (has_config()) {
    if (config_ != NULL) config_->::perfetto::protos::DataSourceConfig::Clear();
  }
  producer_name_filter_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool TraceConfig_DataSource::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForTraceConfig_DataSource, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.TraceConfig.DataSource)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .perfetto.protos.DataSourceConfig config = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_config()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_producer_name_filter;
        break;
      }

      // repeated string producer_name_filter = 2;
      case 2: {
        if (tag == 18) {
         parse_producer_name_filter:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_producer_name_filter()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_producer_name_filter;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.TraceConfig.DataSource)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.TraceConfig.DataSource)
  return false;
#undef DO_
}

void TraceConfig_DataSource::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.TraceConfig.DataSource)
  // optional .perfetto.protos.DataSourceConfig config = 1;
  if (has_config()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->config_, output);
  }

  // repeated string producer_name_filter = 2;
  for (int i = 0; i < this->producer_name_filter_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->producer_name_filter(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.TraceConfig.DataSource)
}

int TraceConfig_DataSource::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.TraceConfig.DataSource)
  int total_size = 0;

  // optional .perfetto.protos.DataSourceConfig config = 1;
  if (has_config()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->config_);
  }

  // repeated string producer_name_filter = 2;
  total_size += 1 * this->producer_name_filter_size();
  for (int i = 0; i < this->producer_name_filter_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->producer_name_filter(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TraceConfig_DataSource::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TraceConfig_DataSource*>(&from));
}

void TraceConfig_DataSource::MergeFrom(const TraceConfig_DataSource& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.TraceConfig.DataSource)
  if (GOOGLE_PREDICT_FALSE(&from == this)) trace_config_pb_MergeFromFail(__LINE__);
  producer_name_filter_.MergeFrom(from.producer_name_filter_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_config()) {
      mutable_config()->::perfetto::protos::DataSourceConfig::MergeFrom(from.config());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void TraceConfig_DataSource::CopyFrom(const TraceConfig_DataSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.TraceConfig.DataSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TraceConfig_DataSource::IsInitialized() const {

  return true;
}

void TraceConfig_DataSource::Swap(TraceConfig_DataSource* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TraceConfig_DataSource::InternalSwap(TraceConfig_DataSource* other) {
  std::swap(config_, other->config_);
  producer_name_filter_.UnsafeArenaSwap(&other->producer_name_filter_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string TraceConfig_DataSource::GetTypeName() const {
  return "perfetto.protos.TraceConfig.DataSource";
}


// -------------------------------------------------------------------

static ::std::string* MutableUnknownFieldsForTraceConfig_BuiltinDataSource(
    TraceConfig_BuiltinDataSource* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TraceConfig_BuiltinDataSource::kDisableClockSnapshottingFieldNumber;
const int TraceConfig_BuiltinDataSource::kDisableTraceConfigFieldNumber;
const int TraceConfig_BuiltinDataSource::kDisableSystemInfoFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TraceConfig_BuiltinDataSource::TraceConfig_BuiltinDataSource()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.TraceConfig.BuiltinDataSource)
}

void TraceConfig_BuiltinDataSource::InitAsDefaultInstance() {
}

TraceConfig_BuiltinDataSource::TraceConfig_BuiltinDataSource(const TraceConfig_BuiltinDataSource& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.TraceConfig.BuiltinDataSource)
}

void TraceConfig_BuiltinDataSource::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  disable_clock_snapshotting_ = false;
  disable_trace_config_ = false;
  disable_system_info_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TraceConfig_BuiltinDataSource::~TraceConfig_BuiltinDataSource() {
  // @@protoc_insertion_point(destructor:perfetto.protos.TraceConfig.BuiltinDataSource)
  SharedDtor();
}

void TraceConfig_BuiltinDataSource::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TraceConfig_BuiltinDataSource::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TraceConfig_BuiltinDataSource& TraceConfig_BuiltinDataSource::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto();
#endif
  return *default_instance_;
}

TraceConfig_BuiltinDataSource* TraceConfig_BuiltinDataSource::default_instance_ = NULL;

TraceConfig_BuiltinDataSource* TraceConfig_BuiltinDataSource::New(::google::protobuf::Arena* arena) const {
  TraceConfig_BuiltinDataSource* n = new TraceConfig_BuiltinDataSource;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TraceConfig_BuiltinDataSource::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.TraceConfig.BuiltinDataSource)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(TraceConfig_BuiltinDataSource, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<TraceConfig_BuiltinDataSource*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(disable_clock_snapshotting_, disable_system_info_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool TraceConfig_BuiltinDataSource::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForTraceConfig_BuiltinDataSource, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.TraceConfig.BuiltinDataSource)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool disable_clock_snapshotting = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &disable_clock_snapshotting_)));
          set_has_disable_clock_snapshotting();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_disable_trace_config;
        break;
      }

      // optional bool disable_trace_config = 2;
      case 2: {
        if (tag == 16) {
         parse_disable_trace_config:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &disable_trace_config_)));
          set_has_disable_trace_config();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_disable_system_info;
        break;
      }

      // optional bool disable_system_info = 3;
      case 3: {
        if (tag == 24) {
         parse_disable_system_info:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &disable_system_info_)));
          set_has_disable_system_info();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.TraceConfig.BuiltinDataSource)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.TraceConfig.BuiltinDataSource)
  return false;
#undef DO_
}

void TraceConfig_BuiltinDataSource::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.TraceConfig.BuiltinDataSource)
  // optional bool disable_clock_snapshotting = 1;
  if (has_disable_clock_snapshotting()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->disable_clock_snapshotting(), output);
  }

  // optional bool disable_trace_config = 2;
  if (has_disable_trace_config()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->disable_trace_config(), output);
  }

  // optional bool disable_system_info = 3;
  if (has_disable_system_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->disable_system_info(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.TraceConfig.BuiltinDataSource)
}

int TraceConfig_BuiltinDataSource::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.TraceConfig.BuiltinDataSource)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 7u) {
    // optional bool disable_clock_snapshotting = 1;
    if (has_disable_clock_snapshotting()) {
      total_size += 1 + 1;
    }

    // optional bool disable_trace_config = 2;
    if (has_disable_trace_config()) {
      total_size += 1 + 1;
    }

    // optional bool disable_system_info = 3;
    if (has_disable_system_info()) {
      total_size += 1 + 1;
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TraceConfig_BuiltinDataSource::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TraceConfig_BuiltinDataSource*>(&from));
}

void TraceConfig_BuiltinDataSource::MergeFrom(const TraceConfig_BuiltinDataSource& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.TraceConfig.BuiltinDataSource)
  if (GOOGLE_PREDICT_FALSE(&from == this)) trace_config_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_disable_clock_snapshotting()) {
      set_disable_clock_snapshotting(from.disable_clock_snapshotting());
    }
    if (from.has_disable_trace_config()) {
      set_disable_trace_config(from.disable_trace_config());
    }
    if (from.has_disable_system_info()) {
      set_disable_system_info(from.disable_system_info());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void TraceConfig_BuiltinDataSource::CopyFrom(const TraceConfig_BuiltinDataSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.TraceConfig.BuiltinDataSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TraceConfig_BuiltinDataSource::IsInitialized() const {

  return true;
}

void TraceConfig_BuiltinDataSource::Swap(TraceConfig_BuiltinDataSource* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TraceConfig_BuiltinDataSource::InternalSwap(TraceConfig_BuiltinDataSource* other) {
  std::swap(disable_clock_snapshotting_, other->disable_clock_snapshotting_);
  std::swap(disable_trace_config_, other->disable_trace_config_);
  std::swap(disable_system_info_, other->disable_system_info_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string TraceConfig_BuiltinDataSource::GetTypeName() const {
  return "perfetto.protos.TraceConfig.BuiltinDataSource";
}


// -------------------------------------------------------------------

static ::std::string* MutableUnknownFieldsForTraceConfig_ProducerConfig(
    TraceConfig_ProducerConfig* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TraceConfig_ProducerConfig::kProducerNameFieldNumber;
const int TraceConfig_ProducerConfig::kShmSizeKbFieldNumber;
const int TraceConfig_ProducerConfig::kPageSizeKbFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TraceConfig_ProducerConfig::TraceConfig_ProducerConfig()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.TraceConfig.ProducerConfig)
}

void TraceConfig_ProducerConfig::InitAsDefaultInstance() {
}

TraceConfig_ProducerConfig::TraceConfig_ProducerConfig(const TraceConfig_ProducerConfig& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.TraceConfig.ProducerConfig)
}

void TraceConfig_ProducerConfig::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  producer_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  shm_size_kb_ = 0u;
  page_size_kb_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TraceConfig_ProducerConfig::~TraceConfig_ProducerConfig() {
  // @@protoc_insertion_point(destructor:perfetto.protos.TraceConfig.ProducerConfig)
  SharedDtor();
}

void TraceConfig_ProducerConfig::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  producer_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TraceConfig_ProducerConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TraceConfig_ProducerConfig& TraceConfig_ProducerConfig::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto();
#endif
  return *default_instance_;
}

TraceConfig_ProducerConfig* TraceConfig_ProducerConfig::default_instance_ = NULL;

TraceConfig_ProducerConfig* TraceConfig_ProducerConfig::New(::google::protobuf::Arena* arena) const {
  TraceConfig_ProducerConfig* n = new TraceConfig_ProducerConfig;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TraceConfig_ProducerConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.TraceConfig.ProducerConfig)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(TraceConfig_ProducerConfig, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<TraceConfig_ProducerConfig*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 7u) {
    ZR_(shm_size_kb_, page_size_kb_);
    if (has_producer_name()) {
      producer_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool TraceConfig_ProducerConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForTraceConfig_ProducerConfig, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.TraceConfig.ProducerConfig)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string producer_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_producer_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_shm_size_kb;
        break;
      }

      // optional uint32 shm_size_kb = 2;
      case 2: {
        if (tag == 16) {
         parse_shm_size_kb:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &shm_size_kb_)));
          set_has_shm_size_kb();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_page_size_kb;
        break;
      }

      // optional uint32 page_size_kb = 3;
      case 3: {
        if (tag == 24) {
         parse_page_size_kb:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &page_size_kb_)));
          set_has_page_size_kb();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.TraceConfig.ProducerConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.TraceConfig.ProducerConfig)
  return false;
#undef DO_
}

void TraceConfig_ProducerConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.TraceConfig.ProducerConfig)
  // optional string producer_name = 1;
  if (has_producer_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->producer_name(), output);
  }

  // optional uint32 shm_size_kb = 2;
  if (has_shm_size_kb()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->shm_size_kb(), output);
  }

  // optional uint32 page_size_kb = 3;
  if (has_page_size_kb()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->page_size_kb(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.TraceConfig.ProducerConfig)
}

int TraceConfig_ProducerConfig::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.TraceConfig.ProducerConfig)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 7u) {
    // optional string producer_name = 1;
    if (has_producer_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->producer_name());
    }

    // optional uint32 shm_size_kb = 2;
    if (has_shm_size_kb()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->shm_size_kb());
    }

    // optional uint32 page_size_kb = 3;
    if (has_page_size_kb()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->page_size_kb());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TraceConfig_ProducerConfig::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TraceConfig_ProducerConfig*>(&from));
}

void TraceConfig_ProducerConfig::MergeFrom(const TraceConfig_ProducerConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.TraceConfig.ProducerConfig)
  if (GOOGLE_PREDICT_FALSE(&from == this)) trace_config_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_producer_name()) {
      set_has_producer_name();
      producer_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.producer_name_);
    }
    if (from.has_shm_size_kb()) {
      set_shm_size_kb(from.shm_size_kb());
    }
    if (from.has_page_size_kb()) {
      set_page_size_kb(from.page_size_kb());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void TraceConfig_ProducerConfig::CopyFrom(const TraceConfig_ProducerConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.TraceConfig.ProducerConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TraceConfig_ProducerConfig::IsInitialized() const {

  return true;
}

void TraceConfig_ProducerConfig::Swap(TraceConfig_ProducerConfig* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TraceConfig_ProducerConfig::InternalSwap(TraceConfig_ProducerConfig* other) {
  producer_name_.Swap(&other->producer_name_);
  std::swap(shm_size_kb_, other->shm_size_kb_);
  std::swap(page_size_kb_, other->page_size_kb_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string TraceConfig_ProducerConfig::GetTypeName() const {
  return "perfetto.protos.TraceConfig.ProducerConfig";
}


// -------------------------------------------------------------------

static ::std::string* MutableUnknownFieldsForTraceConfig_StatsdMetadata(
    TraceConfig_StatsdMetadata* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TraceConfig_StatsdMetadata::kTriggeringAlertIdFieldNumber;
const int TraceConfig_StatsdMetadata::kTriggeringConfigUidFieldNumber;
const int TraceConfig_StatsdMetadata::kTriggeringConfigIdFieldNumber;
const int TraceConfig_StatsdMetadata::kTriggeringSubscriptionIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TraceConfig_StatsdMetadata::TraceConfig_StatsdMetadata()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.TraceConfig.StatsdMetadata)
}

void TraceConfig_StatsdMetadata::InitAsDefaultInstance() {
}

TraceConfig_StatsdMetadata::TraceConfig_StatsdMetadata(const TraceConfig_StatsdMetadata& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.TraceConfig.StatsdMetadata)
}

void TraceConfig_StatsdMetadata::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  triggering_alert_id_ = GOOGLE_LONGLONG(0);
  triggering_config_uid_ = 0;
  triggering_config_id_ = GOOGLE_LONGLONG(0);
  triggering_subscription_id_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TraceConfig_StatsdMetadata::~TraceConfig_StatsdMetadata() {
  // @@protoc_insertion_point(destructor:perfetto.protos.TraceConfig.StatsdMetadata)
  SharedDtor();
}

void TraceConfig_StatsdMetadata::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TraceConfig_StatsdMetadata::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TraceConfig_StatsdMetadata& TraceConfig_StatsdMetadata::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto();
#endif
  return *default_instance_;
}

TraceConfig_StatsdMetadata* TraceConfig_StatsdMetadata::default_instance_ = NULL;

TraceConfig_StatsdMetadata* TraceConfig_StatsdMetadata::New(::google::protobuf::Arena* arena) const {
  TraceConfig_StatsdMetadata* n = new TraceConfig_StatsdMetadata;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TraceConfig_StatsdMetadata::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.TraceConfig.StatsdMetadata)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(TraceConfig_StatsdMetadata, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<TraceConfig_StatsdMetadata*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(triggering_alert_id_, triggering_config_uid_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool TraceConfig_StatsdMetadata::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForTraceConfig_StatsdMetadata, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.TraceConfig.StatsdMetadata)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 triggering_alert_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &triggering_alert_id_)));
          set_has_triggering_alert_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_triggering_config_uid;
        break;
      }

      // optional int32 triggering_config_uid = 2;
      case 2: {
        if (tag == 16) {
         parse_triggering_config_uid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &triggering_config_uid_)));
          set_has_triggering_config_uid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_triggering_config_id;
        break;
      }

      // optional int64 triggering_config_id = 3;
      case 3: {
        if (tag == 24) {
         parse_triggering_config_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &triggering_config_id_)));
          set_has_triggering_config_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_triggering_subscription_id;
        break;
      }

      // optional int64 triggering_subscription_id = 4;
      case 4: {
        if (tag == 32) {
         parse_triggering_subscription_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &triggering_subscription_id_)));
          set_has_triggering_subscription_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.TraceConfig.StatsdMetadata)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.TraceConfig.StatsdMetadata)
  return false;
#undef DO_
}

void TraceConfig_StatsdMetadata::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.TraceConfig.StatsdMetadata)
  // optional int64 triggering_alert_id = 1;
  if (has_triggering_alert_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->triggering_alert_id(), output);
  }

  // optional int32 triggering_config_uid = 2;
  if (has_triggering_config_uid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->triggering_config_uid(), output);
  }

  // optional int64 triggering_config_id = 3;
  if (has_triggering_config_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->triggering_config_id(), output);
  }

  // optional int64 triggering_subscription_id = 4;
  if (has_triggering_subscription_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(4, this->triggering_subscription_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.TraceConfig.StatsdMetadata)
}

int TraceConfig_StatsdMetadata::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.TraceConfig.StatsdMetadata)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 15u) {
    // optional int64 triggering_alert_id = 1;
    if (has_triggering_alert_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->triggering_alert_id());
    }

    // optional int32 triggering_config_uid = 2;
    if (has_triggering_config_uid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->triggering_config_uid());
    }

    // optional int64 triggering_config_id = 3;
    if (has_triggering_config_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->triggering_config_id());
    }

    // optional int64 triggering_subscription_id = 4;
    if (has_triggering_subscription_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->triggering_subscription_id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TraceConfig_StatsdMetadata::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TraceConfig_StatsdMetadata*>(&from));
}

void TraceConfig_StatsdMetadata::MergeFrom(const TraceConfig_StatsdMetadata& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.TraceConfig.StatsdMetadata)
  if (GOOGLE_PREDICT_FALSE(&from == this)) trace_config_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_triggering_alert_id()) {
      set_triggering_alert_id(from.triggering_alert_id());
    }
    if (from.has_triggering_config_uid()) {
      set_triggering_config_uid(from.triggering_config_uid());
    }
    if (from.has_triggering_config_id()) {
      set_triggering_config_id(from.triggering_config_id());
    }
    if (from.has_triggering_subscription_id()) {
      set_triggering_subscription_id(from.triggering_subscription_id());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void TraceConfig_StatsdMetadata::CopyFrom(const TraceConfig_StatsdMetadata& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.TraceConfig.StatsdMetadata)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TraceConfig_StatsdMetadata::IsInitialized() const {

  return true;
}

void TraceConfig_StatsdMetadata::Swap(TraceConfig_StatsdMetadata* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TraceConfig_StatsdMetadata::InternalSwap(TraceConfig_StatsdMetadata* other) {
  std::swap(triggering_alert_id_, other->triggering_alert_id_);
  std::swap(triggering_config_uid_, other->triggering_config_uid_);
  std::swap(triggering_config_id_, other->triggering_config_id_);
  std::swap(triggering_subscription_id_, other->triggering_subscription_id_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string TraceConfig_StatsdMetadata::GetTypeName() const {
  return "perfetto.protos.TraceConfig.StatsdMetadata";
}


// -------------------------------------------------------------------

static ::std::string* MutableUnknownFieldsForTraceConfig_GuardrailOverrides(
    TraceConfig_GuardrailOverrides* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TraceConfig_GuardrailOverrides::kMaxUploadPerDayBytesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TraceConfig_GuardrailOverrides::TraceConfig_GuardrailOverrides()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.TraceConfig.GuardrailOverrides)
}

void TraceConfig_GuardrailOverrides::InitAsDefaultInstance() {
}

TraceConfig_GuardrailOverrides::TraceConfig_GuardrailOverrides(const TraceConfig_GuardrailOverrides& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.TraceConfig.GuardrailOverrides)
}

void TraceConfig_GuardrailOverrides::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  max_upload_per_day_bytes_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TraceConfig_GuardrailOverrides::~TraceConfig_GuardrailOverrides() {
  // @@protoc_insertion_point(destructor:perfetto.protos.TraceConfig.GuardrailOverrides)
  SharedDtor();
}

void TraceConfig_GuardrailOverrides::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TraceConfig_GuardrailOverrides::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TraceConfig_GuardrailOverrides& TraceConfig_GuardrailOverrides::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto();
#endif
  return *default_instance_;
}

TraceConfig_GuardrailOverrides* TraceConfig_GuardrailOverrides::default_instance_ = NULL;

TraceConfig_GuardrailOverrides* TraceConfig_GuardrailOverrides::New(::google::protobuf::Arena* arena) const {
  TraceConfig_GuardrailOverrides* n = new TraceConfig_GuardrailOverrides;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TraceConfig_GuardrailOverrides::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.TraceConfig.GuardrailOverrides)
  max_upload_per_day_bytes_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool TraceConfig_GuardrailOverrides::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForTraceConfig_GuardrailOverrides, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.TraceConfig.GuardrailOverrides)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 max_upload_per_day_bytes = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &max_upload_per_day_bytes_)));
          set_has_max_upload_per_day_bytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.TraceConfig.GuardrailOverrides)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.TraceConfig.GuardrailOverrides)
  return false;
#undef DO_
}

void TraceConfig_GuardrailOverrides::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.TraceConfig.GuardrailOverrides)
  // optional uint64 max_upload_per_day_bytes = 1;
  if (has_max_upload_per_day_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->max_upload_per_day_bytes(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.TraceConfig.GuardrailOverrides)
}

int TraceConfig_GuardrailOverrides::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.TraceConfig.GuardrailOverrides)
  int total_size = 0;

  // optional uint64 max_upload_per_day_bytes = 1;
  if (has_max_upload_per_day_bytes()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->max_upload_per_day_bytes());
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TraceConfig_GuardrailOverrides::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TraceConfig_GuardrailOverrides*>(&from));
}

void TraceConfig_GuardrailOverrides::MergeFrom(const TraceConfig_GuardrailOverrides& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.TraceConfig.GuardrailOverrides)
  if (GOOGLE_PREDICT_FALSE(&from == this)) trace_config_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_max_upload_per_day_bytes()) {
      set_max_upload_per_day_bytes(from.max_upload_per_day_bytes());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void TraceConfig_GuardrailOverrides::CopyFrom(const TraceConfig_GuardrailOverrides& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.TraceConfig.GuardrailOverrides)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TraceConfig_GuardrailOverrides::IsInitialized() const {

  return true;
}

void TraceConfig_GuardrailOverrides::Swap(TraceConfig_GuardrailOverrides* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TraceConfig_GuardrailOverrides::InternalSwap(TraceConfig_GuardrailOverrides* other) {
  std::swap(max_upload_per_day_bytes_, other->max_upload_per_day_bytes_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string TraceConfig_GuardrailOverrides::GetTypeName() const {
  return "perfetto.protos.TraceConfig.GuardrailOverrides";
}


// -------------------------------------------------------------------

static ::std::string* MutableUnknownFieldsForTraceConfig_TriggerConfig(
    TraceConfig_TriggerConfig* ptr) {
  return ptr->mutable_unknown_fields();
}

bool TraceConfig_TriggerConfig_TriggerMode_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const TraceConfig_TriggerConfig_TriggerMode TraceConfig_TriggerConfig::UNSPECIFIED;
const TraceConfig_TriggerConfig_TriggerMode TraceConfig_TriggerConfig::START_TRACING;
const TraceConfig_TriggerConfig_TriggerMode TraceConfig_TriggerConfig::STOP_TRACING;
const TraceConfig_TriggerConfig_TriggerMode TraceConfig_TriggerConfig::TriggerMode_MIN;
const TraceConfig_TriggerConfig_TriggerMode TraceConfig_TriggerConfig::TriggerMode_MAX;
const int TraceConfig_TriggerConfig::TriggerMode_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
static ::std::string* MutableUnknownFieldsForTraceConfig_TriggerConfig_Trigger(
    TraceConfig_TriggerConfig_Trigger* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TraceConfig_TriggerConfig_Trigger::kNameFieldNumber;
const int TraceConfig_TriggerConfig_Trigger::kProducerNameRegexFieldNumber;
const int TraceConfig_TriggerConfig_Trigger::kStopDelayMsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TraceConfig_TriggerConfig_Trigger::TraceConfig_TriggerConfig_Trigger()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.TraceConfig.TriggerConfig.Trigger)
}

void TraceConfig_TriggerConfig_Trigger::InitAsDefaultInstance() {
}

TraceConfig_TriggerConfig_Trigger::TraceConfig_TriggerConfig_Trigger(const TraceConfig_TriggerConfig_Trigger& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.TraceConfig.TriggerConfig.Trigger)
}

void TraceConfig_TriggerConfig_Trigger::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  producer_name_regex_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  stop_delay_ms_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TraceConfig_TriggerConfig_Trigger::~TraceConfig_TriggerConfig_Trigger() {
  // @@protoc_insertion_point(destructor:perfetto.protos.TraceConfig.TriggerConfig.Trigger)
  SharedDtor();
}

void TraceConfig_TriggerConfig_Trigger::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  producer_name_regex_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TraceConfig_TriggerConfig_Trigger::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TraceConfig_TriggerConfig_Trigger& TraceConfig_TriggerConfig_Trigger::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto();
#endif
  return *default_instance_;
}

TraceConfig_TriggerConfig_Trigger* TraceConfig_TriggerConfig_Trigger::default_instance_ = NULL;

TraceConfig_TriggerConfig_Trigger* TraceConfig_TriggerConfig_Trigger::New(::google::protobuf::Arena* arena) const {
  TraceConfig_TriggerConfig_Trigger* n = new TraceConfig_TriggerConfig_Trigger;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TraceConfig_TriggerConfig_Trigger::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.TraceConfig.TriggerConfig.Trigger)
  if (_has_bits_[0 / 32] & 7u) {
    if (has_name()) {
      name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_producer_name_regex()) {
      producer_name_regex_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    stop_delay_ms_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool TraceConfig_TriggerConfig_Trigger::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForTraceConfig_TriggerConfig_Trigger, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.TraceConfig.TriggerConfig.Trigger)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_producer_name_regex;
        break;
      }

      // optional string producer_name_regex = 2;
      case 2: {
        if (tag == 18) {
         parse_producer_name_regex:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_producer_name_regex()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_stop_delay_ms;
        break;
      }

      // optional uint32 stop_delay_ms = 3;
      case 3: {
        if (tag == 24) {
         parse_stop_delay_ms:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &stop_delay_ms_)));
          set_has_stop_delay_ms();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.TraceConfig.TriggerConfig.Trigger)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.TraceConfig.TriggerConfig.Trigger)
  return false;
#undef DO_
}

void TraceConfig_TriggerConfig_Trigger::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.TraceConfig.TriggerConfig.Trigger)
  // optional string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional string producer_name_regex = 2;
  if (has_producer_name_regex()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->producer_name_regex(), output);
  }

  // optional uint32 stop_delay_ms = 3;
  if (has_stop_delay_ms()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->stop_delay_ms(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.TraceConfig.TriggerConfig.Trigger)
}

int TraceConfig_TriggerConfig_Trigger::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.TraceConfig.TriggerConfig.Trigger)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 7u) {
    // optional string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional string producer_name_regex = 2;
    if (has_producer_name_regex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->producer_name_regex());
    }

    // optional uint32 stop_delay_ms = 3;
    if (has_stop_delay_ms()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->stop_delay_ms());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TraceConfig_TriggerConfig_Trigger::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TraceConfig_TriggerConfig_Trigger*>(&from));
}

void TraceConfig_TriggerConfig_Trigger::MergeFrom(const TraceConfig_TriggerConfig_Trigger& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.TraceConfig.TriggerConfig.Trigger)
  if (GOOGLE_PREDICT_FALSE(&from == this)) trace_config_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (from.has_producer_name_regex()) {
      set_has_producer_name_regex();
      producer_name_regex_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.producer_name_regex_);
    }
    if (from.has_stop_delay_ms()) {
      set_stop_delay_ms(from.stop_delay_ms());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void TraceConfig_TriggerConfig_Trigger::CopyFrom(const TraceConfig_TriggerConfig_Trigger& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.TraceConfig.TriggerConfig.Trigger)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TraceConfig_TriggerConfig_Trigger::IsInitialized() const {

  return true;
}

void TraceConfig_TriggerConfig_Trigger::Swap(TraceConfig_TriggerConfig_Trigger* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TraceConfig_TriggerConfig_Trigger::InternalSwap(TraceConfig_TriggerConfig_Trigger* other) {
  name_.Swap(&other->name_);
  producer_name_regex_.Swap(&other->producer_name_regex_);
  std::swap(stop_delay_ms_, other->stop_delay_ms_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string TraceConfig_TriggerConfig_Trigger::GetTypeName() const {
  return "perfetto.protos.TraceConfig.TriggerConfig.Trigger";
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TraceConfig_TriggerConfig::kTriggerModeFieldNumber;
const int TraceConfig_TriggerConfig::kTriggersFieldNumber;
const int TraceConfig_TriggerConfig::kTriggerTimeoutMsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TraceConfig_TriggerConfig::TraceConfig_TriggerConfig()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.TraceConfig.TriggerConfig)
}

void TraceConfig_TriggerConfig::InitAsDefaultInstance() {
}

TraceConfig_TriggerConfig::TraceConfig_TriggerConfig(const TraceConfig_TriggerConfig& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.TraceConfig.TriggerConfig)
}

void TraceConfig_TriggerConfig::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  trigger_mode_ = 0;
  trigger_timeout_ms_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TraceConfig_TriggerConfig::~TraceConfig_TriggerConfig() {
  // @@protoc_insertion_point(destructor:perfetto.protos.TraceConfig.TriggerConfig)
  SharedDtor();
}

void TraceConfig_TriggerConfig::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TraceConfig_TriggerConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TraceConfig_TriggerConfig& TraceConfig_TriggerConfig::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto();
#endif
  return *default_instance_;
}

TraceConfig_TriggerConfig* TraceConfig_TriggerConfig::default_instance_ = NULL;

TraceConfig_TriggerConfig* TraceConfig_TriggerConfig::New(::google::protobuf::Arena* arena) const {
  TraceConfig_TriggerConfig* n = new TraceConfig_TriggerConfig;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TraceConfig_TriggerConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.TraceConfig.TriggerConfig)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(TraceConfig_TriggerConfig, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<TraceConfig_TriggerConfig*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(trigger_mode_, trigger_timeout_ms_);

#undef ZR_HELPER_
#undef ZR_

  triggers_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool TraceConfig_TriggerConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForTraceConfig_TriggerConfig, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.TraceConfig.TriggerConfig)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .perfetto.protos.TraceConfig.TriggerConfig.TriggerMode trigger_mode = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::perfetto::protos::TraceConfig_TriggerConfig_TriggerMode_IsValid(value)) {
            set_trigger_mode(static_cast< ::perfetto::protos::TraceConfig_TriggerConfig_TriggerMode >(value));
          } else {
            unknown_fields_stream.WriteVarint32(8);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_triggers;
        break;
      }

      // repeated .perfetto.protos.TraceConfig.TriggerConfig.Trigger triggers = 2;
      case 2: {
        if (tag == 18) {
         parse_triggers:
          DO_(input->IncrementRecursionDepth());
         parse_loop_triggers:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_triggers()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_triggers;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(24)) goto parse_trigger_timeout_ms;
        break;
      }

      // optional uint32 trigger_timeout_ms = 3;
      case 3: {
        if (tag == 24) {
         parse_trigger_timeout_ms:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &trigger_timeout_ms_)));
          set_has_trigger_timeout_ms();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.TraceConfig.TriggerConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.TraceConfig.TriggerConfig)
  return false;
#undef DO_
}

void TraceConfig_TriggerConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.TraceConfig.TriggerConfig)
  // optional .perfetto.protos.TraceConfig.TriggerConfig.TriggerMode trigger_mode = 1;
  if (has_trigger_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->trigger_mode(), output);
  }

  // repeated .perfetto.protos.TraceConfig.TriggerConfig.Trigger triggers = 2;
  for (unsigned int i = 0, n = this->triggers_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->triggers(i), output);
  }

  // optional uint32 trigger_timeout_ms = 3;
  if (has_trigger_timeout_ms()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->trigger_timeout_ms(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.TraceConfig.TriggerConfig)
}

int TraceConfig_TriggerConfig::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.TraceConfig.TriggerConfig)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 5u) {
    // optional .perfetto.protos.TraceConfig.TriggerConfig.TriggerMode trigger_mode = 1;
    if (has_trigger_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->trigger_mode());
    }

    // optional uint32 trigger_timeout_ms = 3;
    if (has_trigger_timeout_ms()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->trigger_timeout_ms());
    }

  }
  // repeated .perfetto.protos.TraceConfig.TriggerConfig.Trigger triggers = 2;
  total_size += 1 * this->triggers_size();
  for (int i = 0; i < this->triggers_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->triggers(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TraceConfig_TriggerConfig::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TraceConfig_TriggerConfig*>(&from));
}

void TraceConfig_TriggerConfig::MergeFrom(const TraceConfig_TriggerConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.TraceConfig.TriggerConfig)
  if (GOOGLE_PREDICT_FALSE(&from == this)) trace_config_pb_MergeFromFail(__LINE__);
  triggers_.MergeFrom(from.triggers_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_trigger_mode()) {
      set_trigger_mode(from.trigger_mode());
    }
    if (from.has_trigger_timeout_ms()) {
      set_trigger_timeout_ms(from.trigger_timeout_ms());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void TraceConfig_TriggerConfig::CopyFrom(const TraceConfig_TriggerConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.TraceConfig.TriggerConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TraceConfig_TriggerConfig::IsInitialized() const {

  return true;
}

void TraceConfig_TriggerConfig::Swap(TraceConfig_TriggerConfig* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TraceConfig_TriggerConfig::InternalSwap(TraceConfig_TriggerConfig* other) {
  std::swap(trigger_mode_, other->trigger_mode_);
  triggers_.UnsafeArenaSwap(&other->triggers_);
  std::swap(trigger_timeout_ms_, other->trigger_timeout_ms_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string TraceConfig_TriggerConfig::GetTypeName() const {
  return "perfetto.protos.TraceConfig.TriggerConfig";
}


// -------------------------------------------------------------------

static ::std::string* MutableUnknownFieldsForTraceConfig_IncrementalStateConfig(
    TraceConfig_IncrementalStateConfig* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TraceConfig_IncrementalStateConfig::kClearPeriodMsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TraceConfig_IncrementalStateConfig::TraceConfig_IncrementalStateConfig()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.TraceConfig.IncrementalStateConfig)
}

void TraceConfig_IncrementalStateConfig::InitAsDefaultInstance() {
}

TraceConfig_IncrementalStateConfig::TraceConfig_IncrementalStateConfig(const TraceConfig_IncrementalStateConfig& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.TraceConfig.IncrementalStateConfig)
}

void TraceConfig_IncrementalStateConfig::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_period_ms_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TraceConfig_IncrementalStateConfig::~TraceConfig_IncrementalStateConfig() {
  // @@protoc_insertion_point(destructor:perfetto.protos.TraceConfig.IncrementalStateConfig)
  SharedDtor();
}

void TraceConfig_IncrementalStateConfig::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TraceConfig_IncrementalStateConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TraceConfig_IncrementalStateConfig& TraceConfig_IncrementalStateConfig::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto();
#endif
  return *default_instance_;
}

TraceConfig_IncrementalStateConfig* TraceConfig_IncrementalStateConfig::default_instance_ = NULL;

TraceConfig_IncrementalStateConfig* TraceConfig_IncrementalStateConfig::New(::google::protobuf::Arena* arena) const {
  TraceConfig_IncrementalStateConfig* n = new TraceConfig_IncrementalStateConfig;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TraceConfig_IncrementalStateConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.TraceConfig.IncrementalStateConfig)
  clear_period_ms_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool TraceConfig_IncrementalStateConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForTraceConfig_IncrementalStateConfig, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.TraceConfig.IncrementalStateConfig)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 clear_period_ms = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &clear_period_ms_)));
          set_has_clear_period_ms();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.TraceConfig.IncrementalStateConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.TraceConfig.IncrementalStateConfig)
  return false;
#undef DO_
}

void TraceConfig_IncrementalStateConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.TraceConfig.IncrementalStateConfig)
  // optional uint32 clear_period_ms = 1;
  if (has_clear_period_ms()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->clear_period_ms(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.TraceConfig.IncrementalStateConfig)
}

int TraceConfig_IncrementalStateConfig::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.TraceConfig.IncrementalStateConfig)
  int total_size = 0;

  // optional uint32 clear_period_ms = 1;
  if (has_clear_period_ms()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->clear_period_ms());
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TraceConfig_IncrementalStateConfig::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TraceConfig_IncrementalStateConfig*>(&from));
}

void TraceConfig_IncrementalStateConfig::MergeFrom(const TraceConfig_IncrementalStateConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.TraceConfig.IncrementalStateConfig)
  if (GOOGLE_PREDICT_FALSE(&from == this)) trace_config_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_clear_period_ms()) {
      set_clear_period_ms(from.clear_period_ms());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void TraceConfig_IncrementalStateConfig::CopyFrom(const TraceConfig_IncrementalStateConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.TraceConfig.IncrementalStateConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TraceConfig_IncrementalStateConfig::IsInitialized() const {

  return true;
}

void TraceConfig_IncrementalStateConfig::Swap(TraceConfig_IncrementalStateConfig* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TraceConfig_IncrementalStateConfig::InternalSwap(TraceConfig_IncrementalStateConfig* other) {
  std::swap(clear_period_ms_, other->clear_period_ms_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string TraceConfig_IncrementalStateConfig::GetTypeName() const {
  return "perfetto.protos.TraceConfig.IncrementalStateConfig";
}


// -------------------------------------------------------------------

static ::std::string* MutableUnknownFieldsForTraceConfig_IncidentReportConfig(
    TraceConfig_IncidentReportConfig* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TraceConfig_IncidentReportConfig::kDestinationPackageFieldNumber;
const int TraceConfig_IncidentReportConfig::kDestinationClassFieldNumber;
const int TraceConfig_IncidentReportConfig::kPrivacyLevelFieldNumber;
const int TraceConfig_IncidentReportConfig::kSkipDropboxFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TraceConfig_IncidentReportConfig::TraceConfig_IncidentReportConfig()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.TraceConfig.IncidentReportConfig)
}

void TraceConfig_IncidentReportConfig::InitAsDefaultInstance() {
}

TraceConfig_IncidentReportConfig::TraceConfig_IncidentReportConfig(const TraceConfig_IncidentReportConfig& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.TraceConfig.IncidentReportConfig)
}

void TraceConfig_IncidentReportConfig::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  destination_package_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  destination_class_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  privacy_level_ = 0;
  skip_dropbox_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TraceConfig_IncidentReportConfig::~TraceConfig_IncidentReportConfig() {
  // @@protoc_insertion_point(destructor:perfetto.protos.TraceConfig.IncidentReportConfig)
  SharedDtor();
}

void TraceConfig_IncidentReportConfig::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  destination_package_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  destination_class_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TraceConfig_IncidentReportConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TraceConfig_IncidentReportConfig& TraceConfig_IncidentReportConfig::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto();
#endif
  return *default_instance_;
}

TraceConfig_IncidentReportConfig* TraceConfig_IncidentReportConfig::default_instance_ = NULL;

TraceConfig_IncidentReportConfig* TraceConfig_IncidentReportConfig::New(::google::protobuf::Arena* arena) const {
  TraceConfig_IncidentReportConfig* n = new TraceConfig_IncidentReportConfig;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TraceConfig_IncidentReportConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.TraceConfig.IncidentReportConfig)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(TraceConfig_IncidentReportConfig, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<TraceConfig_IncidentReportConfig*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 15u) {
    ZR_(privacy_level_, skip_dropbox_);
    if (has_destination_package()) {
      destination_package_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_destination_class()) {
      destination_class_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool TraceConfig_IncidentReportConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForTraceConfig_IncidentReportConfig, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.TraceConfig.IncidentReportConfig)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string destination_package = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_destination_package()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_destination_class;
        break;
      }

      // optional string destination_class = 2;
      case 2: {
        if (tag == 18) {
         parse_destination_class:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_destination_class()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_privacy_level;
        break;
      }

      // optional int32 privacy_level = 3;
      case 3: {
        if (tag == 24) {
         parse_privacy_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &privacy_level_)));
          set_has_privacy_level();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_skip_dropbox;
        break;
      }

      // optional bool skip_dropbox = 4;
      case 4: {
        if (tag == 32) {
         parse_skip_dropbox:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &skip_dropbox_)));
          set_has_skip_dropbox();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.TraceConfig.IncidentReportConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.TraceConfig.IncidentReportConfig)
  return false;
#undef DO_
}

void TraceConfig_IncidentReportConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.TraceConfig.IncidentReportConfig)
  // optional string destination_package = 1;
  if (has_destination_package()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->destination_package(), output);
  }

  // optional string destination_class = 2;
  if (has_destination_class()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->destination_class(), output);
  }

  // optional int32 privacy_level = 3;
  if (has_privacy_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->privacy_level(), output);
  }

  // optional bool skip_dropbox = 4;
  if (has_skip_dropbox()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->skip_dropbox(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.TraceConfig.IncidentReportConfig)
}

int TraceConfig_IncidentReportConfig::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.TraceConfig.IncidentReportConfig)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 15u) {
    // optional string destination_package = 1;
    if (has_destination_package()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->destination_package());
    }

    // optional string destination_class = 2;
    if (has_destination_class()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->destination_class());
    }

    // optional int32 privacy_level = 3;
    if (has_privacy_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->privacy_level());
    }

    // optional bool skip_dropbox = 4;
    if (has_skip_dropbox()) {
      total_size += 1 + 1;
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TraceConfig_IncidentReportConfig::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TraceConfig_IncidentReportConfig*>(&from));
}

void TraceConfig_IncidentReportConfig::MergeFrom(const TraceConfig_IncidentReportConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.TraceConfig.IncidentReportConfig)
  if (GOOGLE_PREDICT_FALSE(&from == this)) trace_config_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_destination_package()) {
      set_has_destination_package();
      destination_package_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.destination_package_);
    }
    if (from.has_destination_class()) {
      set_has_destination_class();
      destination_class_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.destination_class_);
    }
    if (from.has_privacy_level()) {
      set_privacy_level(from.privacy_level());
    }
    if (from.has_skip_dropbox()) {
      set_skip_dropbox(from.skip_dropbox());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void TraceConfig_IncidentReportConfig::CopyFrom(const TraceConfig_IncidentReportConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.TraceConfig.IncidentReportConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TraceConfig_IncidentReportConfig::IsInitialized() const {

  return true;
}

void TraceConfig_IncidentReportConfig::Swap(TraceConfig_IncidentReportConfig* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TraceConfig_IncidentReportConfig::InternalSwap(TraceConfig_IncidentReportConfig* other) {
  destination_package_.Swap(&other->destination_package_);
  destination_class_.Swap(&other->destination_class_);
  std::swap(privacy_level_, other->privacy_level_);
  std::swap(skip_dropbox_, other->skip_dropbox_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string TraceConfig_IncidentReportConfig::GetTypeName() const {
  return "perfetto.protos.TraceConfig.IncidentReportConfig";
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TraceConfig::kBuffersFieldNumber;
const int TraceConfig::kDataSourcesFieldNumber;
const int TraceConfig::kBuiltinDataSourcesFieldNumber;
const int TraceConfig::kDurationMsFieldNumber;
const int TraceConfig::kEnableExtraGuardrailsFieldNumber;
const int TraceConfig::kLockdownModeFieldNumber;
const int TraceConfig::kProducersFieldNumber;
const int TraceConfig::kStatsdMetadataFieldNumber;
const int TraceConfig::kWriteIntoFileFieldNumber;
const int TraceConfig::kFileWritePeriodMsFieldNumber;
const int TraceConfig::kMaxFileSizeBytesFieldNumber;
const int TraceConfig::kGuardrailOverridesFieldNumber;
const int TraceConfig::kDeferredStartFieldNumber;
const int TraceConfig::kFlushPeriodMsFieldNumber;
const int TraceConfig::kFlushTimeoutMsFieldNumber;
const int TraceConfig::kDataSourceStopTimeoutMsFieldNumber;
const int TraceConfig::kNotifyTraceurFieldNumber;
const int TraceConfig::kTriggerConfigFieldNumber;
const int TraceConfig::kActivateTriggersFieldNumber;
const int TraceConfig::kIncrementalStateConfigFieldNumber;
const int TraceConfig::kAllowUserBuildTracingFieldNumber;
const int TraceConfig::kUniqueSessionNameFieldNumber;
const int TraceConfig::kCompressionTypeFieldNumber;
const int TraceConfig::kIncidentReportConfigFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TraceConfig::TraceConfig()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.TraceConfig)
}

void TraceConfig::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  builtin_data_sources_ = const_cast< ::perfetto::protos::TraceConfig_BuiltinDataSource*>(
      ::perfetto::protos::TraceConfig_BuiltinDataSource::internal_default_instance());
#else
  builtin_data_sources_ = const_cast< ::perfetto::protos::TraceConfig_BuiltinDataSource*>(&::perfetto::protos::TraceConfig_BuiltinDataSource::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  statsd_metadata_ = const_cast< ::perfetto::protos::TraceConfig_StatsdMetadata*>(
      ::perfetto::protos::TraceConfig_StatsdMetadata::internal_default_instance());
#else
  statsd_metadata_ = const_cast< ::perfetto::protos::TraceConfig_StatsdMetadata*>(&::perfetto::protos::TraceConfig_StatsdMetadata::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  guardrail_overrides_ = const_cast< ::perfetto::protos::TraceConfig_GuardrailOverrides*>(
      ::perfetto::protos::TraceConfig_GuardrailOverrides::internal_default_instance());
#else
  guardrail_overrides_ = const_cast< ::perfetto::protos::TraceConfig_GuardrailOverrides*>(&::perfetto::protos::TraceConfig_GuardrailOverrides::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  trigger_config_ = const_cast< ::perfetto::protos::TraceConfig_TriggerConfig*>(
      ::perfetto::protos::TraceConfig_TriggerConfig::internal_default_instance());
#else
  trigger_config_ = const_cast< ::perfetto::protos::TraceConfig_TriggerConfig*>(&::perfetto::protos::TraceConfig_TriggerConfig::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  incremental_state_config_ = const_cast< ::perfetto::protos::TraceConfig_IncrementalStateConfig*>(
      ::perfetto::protos::TraceConfig_IncrementalStateConfig::internal_default_instance());
#else
  incremental_state_config_ = const_cast< ::perfetto::protos::TraceConfig_IncrementalStateConfig*>(&::perfetto::protos::TraceConfig_IncrementalStateConfig::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  incident_report_config_ = const_cast< ::perfetto::protos::TraceConfig_IncidentReportConfig*>(
      ::perfetto::protos::TraceConfig_IncidentReportConfig::internal_default_instance());
#else
  incident_report_config_ = const_cast< ::perfetto::protos::TraceConfig_IncidentReportConfig*>(&::perfetto::protos::TraceConfig_IncidentReportConfig::default_instance());
#endif
}

TraceConfig::TraceConfig(const TraceConfig& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.TraceConfig)
}

void TraceConfig::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  builtin_data_sources_ = NULL;
  duration_ms_ = 0u;
  enable_extra_guardrails_ = false;
  lockdown_mode_ = 0;
  statsd_metadata_ = NULL;
  write_into_file_ = false;
  file_write_period_ms_ = 0u;
  max_file_size_bytes_ = GOOGLE_ULONGLONG(0);
  guardrail_overrides_ = NULL;
  deferred_start_ = false;
  flush_period_ms_ = 0u;
  flush_timeout_ms_ = 0u;
  data_source_stop_timeout_ms_ = 0u;
  notify_traceur_ = false;
  trigger_config_ = NULL;
  incremental_state_config_ = NULL;
  allow_user_build_tracing_ = false;
  unique_session_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  compression_type_ = 0;
  incident_report_config_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TraceConfig::~TraceConfig() {
  // @@protoc_insertion_point(destructor:perfetto.protos.TraceConfig)
  SharedDtor();
}

void TraceConfig::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  unique_session_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete builtin_data_sources_;
    delete statsd_metadata_;
    delete guardrail_overrides_;
    delete trigger_config_;
    delete incremental_state_config_;
    delete incident_report_config_;
  }
}

void TraceConfig::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TraceConfig& TraceConfig::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto();
#endif
  return *default_instance_;
}

TraceConfig* TraceConfig::default_instance_ = NULL;

TraceConfig* TraceConfig::New(::google::protobuf::Arena* arena) const {
  TraceConfig* n = new TraceConfig;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TraceConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.TraceConfig)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(TraceConfig, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<TraceConfig*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 188u) {
    ZR_(duration_ms_, lockdown_mode_);
    if (has_builtin_data_sources()) {
      if (builtin_data_sources_ != NULL) builtin_data_sources_->::perfetto::protos::TraceConfig_BuiltinDataSource::Clear();
    }
    enable_extra_guardrails_ = false;
    if (has_statsd_metadata()) {
      if (statsd_metadata_ != NULL) statsd_metadata_->::perfetto::protos::TraceConfig_StatsdMetadata::Clear();
    }
  }
  if (_has_bits_[8 / 32] & 65280u) {
    ZR_(write_into_file_, deferred_start_);
    ZR_(flush_period_ms_, flush_timeout_ms_);
    file_write_period_ms_ = 0u;
    max_file_size_bytes_ = GOOGLE_ULONGLONG(0);
    if (has_guardrail_overrides()) {
      if (guardrail_overrides_ != NULL) guardrail_overrides_->::perfetto::protos::TraceConfig_GuardrailOverrides::Clear();
    }
    data_source_stop_timeout_ms_ = 0u;
  }
  if (_has_bits_[16 / 32] & 16449536u) {
    notify_traceur_ = false;
    if (has_trigger_config()) {
      if (trigger_config_ != NULL) trigger_config_->::perfetto::protos::TraceConfig_TriggerConfig::Clear();
    }
    if (has_incremental_state_config()) {
      if (incremental_state_config_ != NULL) incremental_state_config_->::perfetto::protos::TraceConfig_IncrementalStateConfig::Clear();
    }
    allow_user_build_tracing_ = false;
    if (has_unique_session_name()) {
      unique_session_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    compression_type_ = 0;
    if (has_incident_report_config()) {
      if (incident_report_config_ != NULL) incident_report_config_->::perfetto::protos::TraceConfig_IncidentReportConfig::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  buffers_.Clear();
  data_sources_.Clear();
  producers_.Clear();
  activate_triggers_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool TraceConfig::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForTraceConfig, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.TraceConfig)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .perfetto.protos.TraceConfig.BufferConfig buffers = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_buffers:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_buffers()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_buffers;
        if (input->ExpectTag(18)) goto parse_loop_data_sources;
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // repeated .perfetto.protos.TraceConfig.DataSource data_sources = 2;
      case 2: {
        if (tag == 18) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_data_sources:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_data_sources()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_data_sources;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(24)) goto parse_duration_ms;
        break;
      }

      // optional uint32 duration_ms = 3;
      case 3: {
        if (tag == 24) {
         parse_duration_ms:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &duration_ms_)));
          set_has_duration_ms();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_enable_extra_guardrails;
        break;
      }

      // optional bool enable_extra_guardrails = 4;
      case 4: {
        if (tag == 32) {
         parse_enable_extra_guardrails:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &enable_extra_guardrails_)));
          set_has_enable_extra_guardrails();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_lockdown_mode;
        break;
      }

      // optional .perfetto.protos.TraceConfig.LockdownModeOperation lockdown_mode = 5;
      case 5: {
        if (tag == 40) {
         parse_lockdown_mode:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::perfetto::protos::TraceConfig_LockdownModeOperation_IsValid(value)) {
            set_lockdown_mode(static_cast< ::perfetto::protos::TraceConfig_LockdownModeOperation >(value));
          } else {
            unknown_fields_stream.WriteVarint32(40);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_producers;
        break;
      }

      // repeated .perfetto.protos.TraceConfig.ProducerConfig producers = 6;
      case 6: {
        if (tag == 50) {
         parse_producers:
          DO_(input->IncrementRecursionDepth());
         parse_loop_producers:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_producers()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_loop_producers;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(58)) goto parse_statsd_metadata;
        break;
      }

      // optional .perfetto.protos.TraceConfig.StatsdMetadata statsd_metadata = 7;
      case 7: {
        if (tag == 58) {
         parse_statsd_metadata:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_statsd_metadata()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_write_into_file;
        break;
      }

      // optional bool write_into_file = 8;
      case 8: {
        if (tag == 64) {
         parse_write_into_file:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &write_into_file_)));
          set_has_write_into_file();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_file_write_period_ms;
        break;
      }

      // optional uint32 file_write_period_ms = 9;
      case 9: {
        if (tag == 72) {
         parse_file_write_period_ms:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &file_write_period_ms_)));
          set_has_file_write_period_ms();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_max_file_size_bytes;
        break;
      }

      // optional uint64 max_file_size_bytes = 10;
      case 10: {
        if (tag == 80) {
         parse_max_file_size_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &max_file_size_bytes_)));
          set_has_max_file_size_bytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_guardrail_overrides;
        break;
      }

      // optional .perfetto.protos.TraceConfig.GuardrailOverrides guardrail_overrides = 11;
      case 11: {
        if (tag == 90) {
         parse_guardrail_overrides:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_guardrail_overrides()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_deferred_start;
        break;
      }

      // optional bool deferred_start = 12;
      case 12: {
        if (tag == 96) {
         parse_deferred_start:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &deferred_start_)));
          set_has_deferred_start();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(104)) goto parse_flush_period_ms;
        break;
      }

      // optional uint32 flush_period_ms = 13;
      case 13: {
        if (tag == 104) {
         parse_flush_period_ms:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &flush_period_ms_)));
          set_has_flush_period_ms();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(112)) goto parse_flush_timeout_ms;
        break;
      }

      // optional uint32 flush_timeout_ms = 14;
      case 14: {
        if (tag == 112) {
         parse_flush_timeout_ms:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &flush_timeout_ms_)));
          set_has_flush_timeout_ms();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(128)) goto parse_notify_traceur;
        break;
      }

      // optional bool notify_traceur = 16;
      case 16: {
        if (tag == 128) {
         parse_notify_traceur:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &notify_traceur_)));
          set_has_notify_traceur();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(138)) goto parse_trigger_config;
        break;
      }

      // optional .perfetto.protos.TraceConfig.TriggerConfig trigger_config = 17;
      case 17: {
        if (tag == 138) {
         parse_trigger_config:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_trigger_config()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(146)) goto parse_activate_triggers;
        break;
      }

      // repeated string activate_triggers = 18;
      case 18: {
        if (tag == 146) {
         parse_activate_triggers:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_activate_triggers()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(146)) goto parse_activate_triggers;
        if (input->ExpectTag(152)) goto parse_allow_user_build_tracing;
        break;
      }

      // optional bool allow_user_build_tracing = 19;
      case 19: {
        if (tag == 152) {
         parse_allow_user_build_tracing:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &allow_user_build_tracing_)));
          set_has_allow_user_build_tracing();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_builtin_data_sources;
        break;
      }

      // optional .perfetto.protos.TraceConfig.BuiltinDataSource builtin_data_sources = 20;
      case 20: {
        if (tag == 162) {
         parse_builtin_data_sources:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_builtin_data_sources()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(170)) goto parse_incremental_state_config;
        break;
      }

      // optional .perfetto.protos.TraceConfig.IncrementalStateConfig incremental_state_config = 21;
      case 21: {
        if (tag == 170) {
         parse_incremental_state_config:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_incremental_state_config()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(178)) goto parse_unique_session_name;
        break;
      }

      // optional string unique_session_name = 22;
      case 22: {
        if (tag == 178) {
         parse_unique_session_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_unique_session_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(184)) goto parse_data_source_stop_timeout_ms;
        break;
      }

      // optional uint32 data_source_stop_timeout_ms = 23;
      case 23: {
        if (tag == 184) {
         parse_data_source_stop_timeout_ms:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &data_source_stop_timeout_ms_)));
          set_has_data_source_stop_timeout_ms();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(192)) goto parse_compression_type;
        break;
      }

      // optional .perfetto.protos.TraceConfig.CompressionType compression_type = 24;
      case 24: {
        if (tag == 192) {
         parse_compression_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::perfetto::protos::TraceConfig_CompressionType_IsValid(value)) {
            set_compression_type(static_cast< ::perfetto::protos::TraceConfig_CompressionType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(192);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(202)) goto parse_incident_report_config;
        break;
      }

      // optional .perfetto.protos.TraceConfig.IncidentReportConfig incident_report_config = 25;
      case 25: {
        if (tag == 202) {
         parse_incident_report_config:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_incident_report_config()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.TraceConfig)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.TraceConfig)
  return false;
#undef DO_
}

void TraceConfig::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.TraceConfig)
  // repeated .perfetto.protos.TraceConfig.BufferConfig buffers = 1;
  for (unsigned int i = 0, n = this->buffers_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->buffers(i), output);
  }

  // repeated .perfetto.protos.TraceConfig.DataSource data_sources = 2;
  for (unsigned int i = 0, n = this->data_sources_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->data_sources(i), output);
  }

  // optional uint32 duration_ms = 3;
  if (has_duration_ms()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->duration_ms(), output);
  }

  // optional bool enable_extra_guardrails = 4;
  if (has_enable_extra_guardrails()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->enable_extra_guardrails(), output);
  }

  // optional .perfetto.protos.TraceConfig.LockdownModeOperation lockdown_mode = 5;
  if (has_lockdown_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->lockdown_mode(), output);
  }

  // repeated .perfetto.protos.TraceConfig.ProducerConfig producers = 6;
  for (unsigned int i = 0, n = this->producers_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, this->producers(i), output);
  }

  // optional .perfetto.protos.TraceConfig.StatsdMetadata statsd_metadata = 7;
  if (has_statsd_metadata()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, *this->statsd_metadata_, output);
  }

  // optional bool write_into_file = 8;
  if (has_write_into_file()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->write_into_file(), output);
  }

  // optional uint32 file_write_period_ms = 9;
  if (has_file_write_period_ms()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->file_write_period_ms(), output);
  }

  // optional uint64 max_file_size_bytes = 10;
  if (has_max_file_size_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(10, this->max_file_size_bytes(), output);
  }

  // optional .perfetto.protos.TraceConfig.GuardrailOverrides guardrail_overrides = 11;
  if (has_guardrail_overrides()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      11, *this->guardrail_overrides_, output);
  }

  // optional bool deferred_start = 12;
  if (has_deferred_start()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(12, this->deferred_start(), output);
  }

  // optional uint32 flush_period_ms = 13;
  if (has_flush_period_ms()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(13, this->flush_period_ms(), output);
  }

  // optional uint32 flush_timeout_ms = 14;
  if (has_flush_timeout_ms()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(14, this->flush_timeout_ms(), output);
  }

  // optional bool notify_traceur = 16;
  if (has_notify_traceur()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(16, this->notify_traceur(), output);
  }

  // optional .perfetto.protos.TraceConfig.TriggerConfig trigger_config = 17;
  if (has_trigger_config()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      17, *this->trigger_config_, output);
  }

  // repeated string activate_triggers = 18;
  for (int i = 0; i < this->activate_triggers_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      18, this->activate_triggers(i), output);
  }

  // optional bool allow_user_build_tracing = 19;
  if (has_allow_user_build_tracing()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(19, this->allow_user_build_tracing(), output);
  }

  // optional .perfetto.protos.TraceConfig.BuiltinDataSource builtin_data_sources = 20;
  if (has_builtin_data_sources()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      20, *this->builtin_data_sources_, output);
  }

  // optional .perfetto.protos.TraceConfig.IncrementalStateConfig incremental_state_config = 21;
  if (has_incremental_state_config()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      21, *this->incremental_state_config_, output);
  }

  // optional string unique_session_name = 22;
  if (has_unique_session_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      22, this->unique_session_name(), output);
  }

  // optional uint32 data_source_stop_timeout_ms = 23;
  if (has_data_source_stop_timeout_ms()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(23, this->data_source_stop_timeout_ms(), output);
  }

  // optional .perfetto.protos.TraceConfig.CompressionType compression_type = 24;
  if (has_compression_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      24, this->compression_type(), output);
  }

  // optional .perfetto.protos.TraceConfig.IncidentReportConfig incident_report_config = 25;
  if (has_incident_report_config()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      25, *this->incident_report_config_, output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.TraceConfig)
}

int TraceConfig::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.TraceConfig)
  int total_size = 0;

  if (_has_bits_[2 / 32] & 188u) {
    // optional .perfetto.protos.TraceConfig.BuiltinDataSource builtin_data_sources = 20;
    if (has_builtin_data_sources()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->builtin_data_sources_);
    }

    // optional uint32 duration_ms = 3;
    if (has_duration_ms()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->duration_ms());
    }

    // optional bool enable_extra_guardrails = 4;
    if (has_enable_extra_guardrails()) {
      total_size += 1 + 1;
    }

    // optional .perfetto.protos.TraceConfig.LockdownModeOperation lockdown_mode = 5;
    if (has_lockdown_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->lockdown_mode());
    }

    // optional .perfetto.protos.TraceConfig.StatsdMetadata statsd_metadata = 7;
    if (has_statsd_metadata()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->statsd_metadata_);
    }

  }
  if (_has_bits_[8 / 32] & 65280u) {
    // optional bool write_into_file = 8;
    if (has_write_into_file()) {
      total_size += 1 + 1;
    }

    // optional uint32 file_write_period_ms = 9;
    if (has_file_write_period_ms()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->file_write_period_ms());
    }

    // optional uint64 max_file_size_bytes = 10;
    if (has_max_file_size_bytes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->max_file_size_bytes());
    }

    // optional .perfetto.protos.TraceConfig.GuardrailOverrides guardrail_overrides = 11;
    if (has_guardrail_overrides()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->guardrail_overrides_);
    }

    // optional bool deferred_start = 12;
    if (has_deferred_start()) {
      total_size += 1 + 1;
    }

    // optional uint32 flush_period_ms = 13;
    if (has_flush_period_ms()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->flush_period_ms());
    }

    // optional uint32 flush_timeout_ms = 14;
    if (has_flush_timeout_ms()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->flush_timeout_ms());
    }

    // optional uint32 data_source_stop_timeout_ms = 23;
    if (has_data_source_stop_timeout_ms()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->data_source_stop_timeout_ms());
    }

  }
  if (_has_bits_[16 / 32] & 16449536u) {
    // optional bool notify_traceur = 16;
    if (has_notify_traceur()) {
      total_size += 2 + 1;
    }

    // optional .perfetto.protos.TraceConfig.TriggerConfig trigger_config = 17;
    if (has_trigger_config()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->trigger_config_);
    }

    // optional .perfetto.protos.TraceConfig.IncrementalStateConfig incremental_state_config = 21;
    if (has_incremental_state_config()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->incremental_state_config_);
    }

    // optional bool allow_user_build_tracing = 19;
    if (has_allow_user_build_tracing()) {
      total_size += 2 + 1;
    }

    // optional string unique_session_name = 22;
    if (has_unique_session_name()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->unique_session_name());
    }

    // optional .perfetto.protos.TraceConfig.CompressionType compression_type = 24;
    if (has_compression_type()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->compression_type());
    }

    // optional .perfetto.protos.TraceConfig.IncidentReportConfig incident_report_config = 25;
    if (has_incident_report_config()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->incident_report_config_);
    }

  }
  // repeated .perfetto.protos.TraceConfig.BufferConfig buffers = 1;
  total_size += 1 * this->buffers_size();
  for (int i = 0; i < this->buffers_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->buffers(i));
  }

  // repeated .perfetto.protos.TraceConfig.DataSource data_sources = 2;
  total_size += 1 * this->data_sources_size();
  for (int i = 0; i < this->data_sources_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->data_sources(i));
  }

  // repeated .perfetto.protos.TraceConfig.ProducerConfig producers = 6;
  total_size += 1 * this->producers_size();
  for (int i = 0; i < this->producers_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->producers(i));
  }

  // repeated string activate_triggers = 18;
  total_size += 2 * this->activate_triggers_size();
  for (int i = 0; i < this->activate_triggers_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->activate_triggers(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TraceConfig::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TraceConfig*>(&from));
}

void TraceConfig::MergeFrom(const TraceConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.TraceConfig)
  if (GOOGLE_PREDICT_FALSE(&from == this)) trace_config_pb_MergeFromFail(__LINE__);
  buffers_.MergeFrom(from.buffers_);
  data_sources_.MergeFrom(from.data_sources_);
  producers_.MergeFrom(from.producers_);
  activate_triggers_.MergeFrom(from.activate_triggers_);
  if (from._has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    if (from.has_builtin_data_sources()) {
      mutable_builtin_data_sources()->::perfetto::protos::TraceConfig_BuiltinDataSource::MergeFrom(from.builtin_data_sources());
    }
    if (from.has_duration_ms()) {
      set_duration_ms(from.duration_ms());
    }
    if (from.has_enable_extra_guardrails()) {
      set_enable_extra_guardrails(from.enable_extra_guardrails());
    }
    if (from.has_lockdown_mode()) {
      set_lockdown_mode(from.lockdown_mode());
    }
    if (from.has_statsd_metadata()) {
      mutable_statsd_metadata()->::perfetto::protos::TraceConfig_StatsdMetadata::MergeFrom(from.statsd_metadata());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_write_into_file()) {
      set_write_into_file(from.write_into_file());
    }
    if (from.has_file_write_period_ms()) {
      set_file_write_period_ms(from.file_write_period_ms());
    }
    if (from.has_max_file_size_bytes()) {
      set_max_file_size_bytes(from.max_file_size_bytes());
    }
    if (from.has_guardrail_overrides()) {
      mutable_guardrail_overrides()->::perfetto::protos::TraceConfig_GuardrailOverrides::MergeFrom(from.guardrail_overrides());
    }
    if (from.has_deferred_start()) {
      set_deferred_start(from.deferred_start());
    }
    if (from.has_flush_period_ms()) {
      set_flush_period_ms(from.flush_period_ms());
    }
    if (from.has_flush_timeout_ms()) {
      set_flush_timeout_ms(from.flush_timeout_ms());
    }
    if (from.has_data_source_stop_timeout_ms()) {
      set_data_source_stop_timeout_ms(from.data_source_stop_timeout_ms());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_notify_traceur()) {
      set_notify_traceur(from.notify_traceur());
    }
    if (from.has_trigger_config()) {
      mutable_trigger_config()->::perfetto::protos::TraceConfig_TriggerConfig::MergeFrom(from.trigger_config());
    }
    if (from.has_incremental_state_config()) {
      mutable_incremental_state_config()->::perfetto::protos::TraceConfig_IncrementalStateConfig::MergeFrom(from.incremental_state_config());
    }
    if (from.has_allow_user_build_tracing()) {
      set_allow_user_build_tracing(from.allow_user_build_tracing());
    }
    if (from.has_unique_session_name()) {
      set_has_unique_session_name();
      unique_session_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.unique_session_name_);
    }
    if (from.has_compression_type()) {
      set_compression_type(from.compression_type());
    }
    if (from.has_incident_report_config()) {
      mutable_incident_report_config()->::perfetto::protos::TraceConfig_IncidentReportConfig::MergeFrom(from.incident_report_config());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void TraceConfig::CopyFrom(const TraceConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.TraceConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TraceConfig::IsInitialized() const {

  return true;
}

void TraceConfig::Swap(TraceConfig* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TraceConfig::InternalSwap(TraceConfig* other) {
  buffers_.UnsafeArenaSwap(&other->buffers_);
  data_sources_.UnsafeArenaSwap(&other->data_sources_);
  std::swap(builtin_data_sources_, other->builtin_data_sources_);
  std::swap(duration_ms_, other->duration_ms_);
  std::swap(enable_extra_guardrails_, other->enable_extra_guardrails_);
  std::swap(lockdown_mode_, other->lockdown_mode_);
  producers_.UnsafeArenaSwap(&other->producers_);
  std::swap(statsd_metadata_, other->statsd_metadata_);
  std::swap(write_into_file_, other->write_into_file_);
  std::swap(file_write_period_ms_, other->file_write_period_ms_);
  std::swap(max_file_size_bytes_, other->max_file_size_bytes_);
  std::swap(guardrail_overrides_, other->guardrail_overrides_);
  std::swap(deferred_start_, other->deferred_start_);
  std::swap(flush_period_ms_, other->flush_period_ms_);
  std::swap(flush_timeout_ms_, other->flush_timeout_ms_);
  std::swap(data_source_stop_timeout_ms_, other->data_source_stop_timeout_ms_);
  std::swap(notify_traceur_, other->notify_traceur_);
  std::swap(trigger_config_, other->trigger_config_);
  activate_triggers_.UnsafeArenaSwap(&other->activate_triggers_);
  std::swap(incremental_state_config_, other->incremental_state_config_);
  std::swap(allow_user_build_tracing_, other->allow_user_build_tracing_);
  unique_session_name_.Swap(&other->unique_session_name_);
  std::swap(compression_type_, other->compression_type_);
  std::swap(incident_report_config_, other->incident_report_config_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string TraceConfig::GetTypeName() const {
  return "perfetto.protos.TraceConfig";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TraceConfig_BufferConfig

// optional uint32 size_kb = 1;
bool TraceConfig_BufferConfig::has_size_kb() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TraceConfig_BufferConfig::set_has_size_kb() {
  _has_bits_[0] |= 0x00000001u;
}
void TraceConfig_BufferConfig::clear_has_size_kb() {
  _has_bits_[0] &= ~0x00000001u;
}
void TraceConfig_BufferConfig::clear_size_kb() {
  size_kb_ = 0u;
  clear_has_size_kb();
}
 ::google::protobuf::uint32 TraceConfig_BufferConfig::size_kb() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.BufferConfig.size_kb)
  return size_kb_;
}
 void TraceConfig_BufferConfig::set_size_kb(::google::protobuf::uint32 value) {
  set_has_size_kb();
  size_kb_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.BufferConfig.size_kb)
}

// optional .perfetto.protos.TraceConfig.BufferConfig.FillPolicy fill_policy = 4;
bool TraceConfig_BufferConfig::has_fill_policy() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void TraceConfig_BufferConfig::set_has_fill_policy() {
  _has_bits_[0] |= 0x00000002u;
}
void TraceConfig_BufferConfig::clear_has_fill_policy() {
  _has_bits_[0] &= ~0x00000002u;
}
void TraceConfig_BufferConfig::clear_fill_policy() {
  fill_policy_ = 0;
  clear_has_fill_policy();
}
 ::perfetto::protos::TraceConfig_BufferConfig_FillPolicy TraceConfig_BufferConfig::fill_policy() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.BufferConfig.fill_policy)
  return static_cast< ::perfetto::protos::TraceConfig_BufferConfig_FillPolicy >(fill_policy_);
}
 void TraceConfig_BufferConfig::set_fill_policy(::perfetto::protos::TraceConfig_BufferConfig_FillPolicy value) {
  assert(::perfetto::protos::TraceConfig_BufferConfig_FillPolicy_IsValid(value));
  set_has_fill_policy();
  fill_policy_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.BufferConfig.fill_policy)
}

// -------------------------------------------------------------------

// TraceConfig_DataSource

// optional .perfetto.protos.DataSourceConfig config = 1;
bool TraceConfig_DataSource::has_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TraceConfig_DataSource::set_has_config() {
  _has_bits_[0] |= 0x00000001u;
}
void TraceConfig_DataSource::clear_has_config() {
  _has_bits_[0] &= ~0x00000001u;
}
void TraceConfig_DataSource::clear_config() {
  if (config_ != NULL) config_->::perfetto::protos::DataSourceConfig::Clear();
  clear_has_config();
}
const ::perfetto::protos::DataSourceConfig& TraceConfig_DataSource::config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.DataSource.config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return config_ != NULL ? *config_ : *default_instance().config_;
#else
  return config_ != NULL ? *config_ : *default_instance_->config_;
#endif
}
::perfetto::protos::DataSourceConfig* TraceConfig_DataSource::mutable_config() {
  set_has_config();
  if (config_ == NULL) {
    config_ = new ::perfetto::protos::DataSourceConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.DataSource.config)
  return config_;
}
::perfetto::protos::DataSourceConfig* TraceConfig_DataSource::release_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.DataSource.config)
  clear_has_config();
  ::perfetto::protos::DataSourceConfig* temp = config_;
  config_ = NULL;
  return temp;
}
void TraceConfig_DataSource::set_allocated_config(::perfetto::protos::DataSourceConfig* config) {
  delete config_;
  config_ = config;
  if (config) {
    set_has_config();
  } else {
    clear_has_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.DataSource.config)
}

// repeated string producer_name_filter = 2;
int TraceConfig_DataSource::producer_name_filter_size() const {
  return producer_name_filter_.size();
}
void TraceConfig_DataSource::clear_producer_name_filter() {
  producer_name_filter_.Clear();
}
 const ::std::string& TraceConfig_DataSource::producer_name_filter(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.DataSource.producer_name_filter)
  return producer_name_filter_.Get(index);
}
 ::std::string* TraceConfig_DataSource::mutable_producer_name_filter(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.DataSource.producer_name_filter)
  return producer_name_filter_.Mutable(index);
}
 void TraceConfig_DataSource::set_producer_name_filter(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.DataSource.producer_name_filter)
  producer_name_filter_.Mutable(index)->assign(value);
}
 void TraceConfig_DataSource::set_producer_name_filter(int index, const char* value) {
  producer_name_filter_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.TraceConfig.DataSource.producer_name_filter)
}
 void TraceConfig_DataSource::set_producer_name_filter(int index, const char* value, size_t size) {
  producer_name_filter_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.TraceConfig.DataSource.producer_name_filter)
}
 ::std::string* TraceConfig_DataSource::add_producer_name_filter() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.TraceConfig.DataSource.producer_name_filter)
  return producer_name_filter_.Add();
}
 void TraceConfig_DataSource::add_producer_name_filter(const ::std::string& value) {
  producer_name_filter_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.TraceConfig.DataSource.producer_name_filter)
}
 void TraceConfig_DataSource::add_producer_name_filter(const char* value) {
  producer_name_filter_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.TraceConfig.DataSource.producer_name_filter)
}
 void TraceConfig_DataSource::add_producer_name_filter(const char* value, size_t size) {
  producer_name_filter_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.TraceConfig.DataSource.producer_name_filter)
}
 const ::google::protobuf::RepeatedPtrField< ::std::string>&
TraceConfig_DataSource::producer_name_filter() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.TraceConfig.DataSource.producer_name_filter)
  return producer_name_filter_;
}
 ::google::protobuf::RepeatedPtrField< ::std::string>*
TraceConfig_DataSource::mutable_producer_name_filter() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.TraceConfig.DataSource.producer_name_filter)
  return &producer_name_filter_;
}

// -------------------------------------------------------------------

// TraceConfig_BuiltinDataSource

// optional bool disable_clock_snapshotting = 1;
bool TraceConfig_BuiltinDataSource::has_disable_clock_snapshotting() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TraceConfig_BuiltinDataSource::set_has_disable_clock_snapshotting() {
  _has_bits_[0] |= 0x00000001u;
}
void TraceConfig_BuiltinDataSource::clear_has_disable_clock_snapshotting() {
  _has_bits_[0] &= ~0x00000001u;
}
void TraceConfig_BuiltinDataSource::clear_disable_clock_snapshotting() {
  disable_clock_snapshotting_ = false;
  clear_has_disable_clock_snapshotting();
}
 bool TraceConfig_BuiltinDataSource::disable_clock_snapshotting() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.BuiltinDataSource.disable_clock_snapshotting)
  return disable_clock_snapshotting_;
}
 void TraceConfig_BuiltinDataSource::set_disable_clock_snapshotting(bool value) {
  set_has_disable_clock_snapshotting();
  disable_clock_snapshotting_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.BuiltinDataSource.disable_clock_snapshotting)
}

// optional bool disable_trace_config = 2;
bool TraceConfig_BuiltinDataSource::has_disable_trace_config() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void TraceConfig_BuiltinDataSource::set_has_disable_trace_config() {
  _has_bits_[0] |= 0x00000002u;
}
void TraceConfig_BuiltinDataSource::clear_has_disable_trace_config() {
  _has_bits_[0] &= ~0x00000002u;
}
void TraceConfig_BuiltinDataSource::clear_disable_trace_config() {
  disable_trace_config_ = false;
  clear_has_disable_trace_config();
}
 bool TraceConfig_BuiltinDataSource::disable_trace_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.BuiltinDataSource.disable_trace_config)
  return disable_trace_config_;
}
 void TraceConfig_BuiltinDataSource::set_disable_trace_config(bool value) {
  set_has_disable_trace_config();
  disable_trace_config_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.BuiltinDataSource.disable_trace_config)
}

// optional bool disable_system_info = 3;
bool TraceConfig_BuiltinDataSource::has_disable_system_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void TraceConfig_BuiltinDataSource::set_has_disable_system_info() {
  _has_bits_[0] |= 0x00000004u;
}
void TraceConfig_BuiltinDataSource::clear_has_disable_system_info() {
  _has_bits_[0] &= ~0x00000004u;
}
void TraceConfig_BuiltinDataSource::clear_disable_system_info() {
  disable_system_info_ = false;
  clear_has_disable_system_info();
}
 bool TraceConfig_BuiltinDataSource::disable_system_info() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.BuiltinDataSource.disable_system_info)
  return disable_system_info_;
}
 void TraceConfig_BuiltinDataSource::set_disable_system_info(bool value) {
  set_has_disable_system_info();
  disable_system_info_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.BuiltinDataSource.disable_system_info)
}

// -------------------------------------------------------------------

// TraceConfig_ProducerConfig

// optional string producer_name = 1;
bool TraceConfig_ProducerConfig::has_producer_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TraceConfig_ProducerConfig::set_has_producer_name() {
  _has_bits_[0] |= 0x00000001u;
}
void TraceConfig_ProducerConfig::clear_has_producer_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void TraceConfig_ProducerConfig::clear_producer_name() {
  producer_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_producer_name();
}
 const ::std::string& TraceConfig_ProducerConfig::producer_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.ProducerConfig.producer_name)
  return producer_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TraceConfig_ProducerConfig::set_producer_name(const ::std::string& value) {
  set_has_producer_name();
  producer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.ProducerConfig.producer_name)
}
 void TraceConfig_ProducerConfig::set_producer_name(const char* value) {
  set_has_producer_name();
  producer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.TraceConfig.ProducerConfig.producer_name)
}
 void TraceConfig_ProducerConfig::set_producer_name(const char* value, size_t size) {
  set_has_producer_name();
  producer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.TraceConfig.ProducerConfig.producer_name)
}
 ::std::string* TraceConfig_ProducerConfig::mutable_producer_name() {
  set_has_producer_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.ProducerConfig.producer_name)
  return producer_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* TraceConfig_ProducerConfig::release_producer_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.ProducerConfig.producer_name)
  clear_has_producer_name();
  return producer_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TraceConfig_ProducerConfig::set_allocated_producer_name(::std::string* producer_name) {
  if (producer_name != NULL) {
    set_has_producer_name();
  } else {
    clear_has_producer_name();
  }
  producer_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), producer_name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.ProducerConfig.producer_name)
}

// optional uint32 shm_size_kb = 2;
bool TraceConfig_ProducerConfig::has_shm_size_kb() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void TraceConfig_ProducerConfig::set_has_shm_size_kb() {
  _has_bits_[0] |= 0x00000002u;
}
void TraceConfig_ProducerConfig::clear_has_shm_size_kb() {
  _has_bits_[0] &= ~0x00000002u;
}
void TraceConfig_ProducerConfig::clear_shm_size_kb() {
  shm_size_kb_ = 0u;
  clear_has_shm_size_kb();
}
 ::google::protobuf::uint32 TraceConfig_ProducerConfig::shm_size_kb() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.ProducerConfig.shm_size_kb)
  return shm_size_kb_;
}
 void TraceConfig_ProducerConfig::set_shm_size_kb(::google::protobuf::uint32 value) {
  set_has_shm_size_kb();
  shm_size_kb_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.ProducerConfig.shm_size_kb)
}

// optional uint32 page_size_kb = 3;
bool TraceConfig_ProducerConfig::has_page_size_kb() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void TraceConfig_ProducerConfig::set_has_page_size_kb() {
  _has_bits_[0] |= 0x00000004u;
}
void TraceConfig_ProducerConfig::clear_has_page_size_kb() {
  _has_bits_[0] &= ~0x00000004u;
}
void TraceConfig_ProducerConfig::clear_page_size_kb() {
  page_size_kb_ = 0u;
  clear_has_page_size_kb();
}
 ::google::protobuf::uint32 TraceConfig_ProducerConfig::page_size_kb() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.ProducerConfig.page_size_kb)
  return page_size_kb_;
}
 void TraceConfig_ProducerConfig::set_page_size_kb(::google::protobuf::uint32 value) {
  set_has_page_size_kb();
  page_size_kb_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.ProducerConfig.page_size_kb)
}

// -------------------------------------------------------------------

// TraceConfig_StatsdMetadata

// optional int64 triggering_alert_id = 1;
bool TraceConfig_StatsdMetadata::has_triggering_alert_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TraceConfig_StatsdMetadata::set_has_triggering_alert_id() {
  _has_bits_[0] |= 0x00000001u;
}
void TraceConfig_StatsdMetadata::clear_has_triggering_alert_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void TraceConfig_StatsdMetadata::clear_triggering_alert_id() {
  triggering_alert_id_ = GOOGLE_LONGLONG(0);
  clear_has_triggering_alert_id();
}
 ::google::protobuf::int64 TraceConfig_StatsdMetadata::triggering_alert_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.StatsdMetadata.triggering_alert_id)
  return triggering_alert_id_;
}
 void TraceConfig_StatsdMetadata::set_triggering_alert_id(::google::protobuf::int64 value) {
  set_has_triggering_alert_id();
  triggering_alert_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.StatsdMetadata.triggering_alert_id)
}

// optional int32 triggering_config_uid = 2;
bool TraceConfig_StatsdMetadata::has_triggering_config_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void TraceConfig_StatsdMetadata::set_has_triggering_config_uid() {
  _has_bits_[0] |= 0x00000002u;
}
void TraceConfig_StatsdMetadata::clear_has_triggering_config_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
void TraceConfig_StatsdMetadata::clear_triggering_config_uid() {
  triggering_config_uid_ = 0;
  clear_has_triggering_config_uid();
}
 ::google::protobuf::int32 TraceConfig_StatsdMetadata::triggering_config_uid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.StatsdMetadata.triggering_config_uid)
  return triggering_config_uid_;
}
 void TraceConfig_StatsdMetadata::set_triggering_config_uid(::google::protobuf::int32 value) {
  set_has_triggering_config_uid();
  triggering_config_uid_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.StatsdMetadata.triggering_config_uid)
}

// optional int64 triggering_config_id = 3;
bool TraceConfig_StatsdMetadata::has_triggering_config_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void TraceConfig_StatsdMetadata::set_has_triggering_config_id() {
  _has_bits_[0] |= 0x00000004u;
}
void TraceConfig_StatsdMetadata::clear_has_triggering_config_id() {
  _has_bits_[0] &= ~0x00000004u;
}
void TraceConfig_StatsdMetadata::clear_triggering_config_id() {
  triggering_config_id_ = GOOGLE_LONGLONG(0);
  clear_has_triggering_config_id();
}
 ::google::protobuf::int64 TraceConfig_StatsdMetadata::triggering_config_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.StatsdMetadata.triggering_config_id)
  return triggering_config_id_;
}
 void TraceConfig_StatsdMetadata::set_triggering_config_id(::google::protobuf::int64 value) {
  set_has_triggering_config_id();
  triggering_config_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.StatsdMetadata.triggering_config_id)
}

// optional int64 triggering_subscription_id = 4;
bool TraceConfig_StatsdMetadata::has_triggering_subscription_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void TraceConfig_StatsdMetadata::set_has_triggering_subscription_id() {
  _has_bits_[0] |= 0x00000008u;
}
void TraceConfig_StatsdMetadata::clear_has_triggering_subscription_id() {
  _has_bits_[0] &= ~0x00000008u;
}
void TraceConfig_StatsdMetadata::clear_triggering_subscription_id() {
  triggering_subscription_id_ = GOOGLE_LONGLONG(0);
  clear_has_triggering_subscription_id();
}
 ::google::protobuf::int64 TraceConfig_StatsdMetadata::triggering_subscription_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.StatsdMetadata.triggering_subscription_id)
  return triggering_subscription_id_;
}
 void TraceConfig_StatsdMetadata::set_triggering_subscription_id(::google::protobuf::int64 value) {
  set_has_triggering_subscription_id();
  triggering_subscription_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.StatsdMetadata.triggering_subscription_id)
}

// -------------------------------------------------------------------

// TraceConfig_GuardrailOverrides

// optional uint64 max_upload_per_day_bytes = 1;
bool TraceConfig_GuardrailOverrides::has_max_upload_per_day_bytes() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TraceConfig_GuardrailOverrides::set_has_max_upload_per_day_bytes() {
  _has_bits_[0] |= 0x00000001u;
}
void TraceConfig_GuardrailOverrides::clear_has_max_upload_per_day_bytes() {
  _has_bits_[0] &= ~0x00000001u;
}
void TraceConfig_GuardrailOverrides::clear_max_upload_per_day_bytes() {
  max_upload_per_day_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_max_upload_per_day_bytes();
}
 ::google::protobuf::uint64 TraceConfig_GuardrailOverrides::max_upload_per_day_bytes() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.GuardrailOverrides.max_upload_per_day_bytes)
  return max_upload_per_day_bytes_;
}
 void TraceConfig_GuardrailOverrides::set_max_upload_per_day_bytes(::google::protobuf::uint64 value) {
  set_has_max_upload_per_day_bytes();
  max_upload_per_day_bytes_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.GuardrailOverrides.max_upload_per_day_bytes)
}

// -------------------------------------------------------------------

// TraceConfig_TriggerConfig_Trigger

// optional string name = 1;
bool TraceConfig_TriggerConfig_Trigger::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TraceConfig_TriggerConfig_Trigger::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
void TraceConfig_TriggerConfig_Trigger::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void TraceConfig_TriggerConfig_Trigger::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
 const ::std::string& TraceConfig_TriggerConfig_Trigger::name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.TriggerConfig.Trigger.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TraceConfig_TriggerConfig_Trigger::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.TriggerConfig.Trigger.name)
}
 void TraceConfig_TriggerConfig_Trigger::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.TraceConfig.TriggerConfig.Trigger.name)
}
 void TraceConfig_TriggerConfig_Trigger::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.TraceConfig.TriggerConfig.Trigger.name)
}
 ::std::string* TraceConfig_TriggerConfig_Trigger::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.TriggerConfig.Trigger.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* TraceConfig_TriggerConfig_Trigger::release_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.TriggerConfig.Trigger.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TraceConfig_TriggerConfig_Trigger::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.TriggerConfig.Trigger.name)
}

// optional string producer_name_regex = 2;
bool TraceConfig_TriggerConfig_Trigger::has_producer_name_regex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void TraceConfig_TriggerConfig_Trigger::set_has_producer_name_regex() {
  _has_bits_[0] |= 0x00000002u;
}
void TraceConfig_TriggerConfig_Trigger::clear_has_producer_name_regex() {
  _has_bits_[0] &= ~0x00000002u;
}
void TraceConfig_TriggerConfig_Trigger::clear_producer_name_regex() {
  producer_name_regex_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_producer_name_regex();
}
 const ::std::string& TraceConfig_TriggerConfig_Trigger::producer_name_regex() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.TriggerConfig.Trigger.producer_name_regex)
  return producer_name_regex_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TraceConfig_TriggerConfig_Trigger::set_producer_name_regex(const ::std::string& value) {
  set_has_producer_name_regex();
  producer_name_regex_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.TriggerConfig.Trigger.producer_name_regex)
}
 void TraceConfig_TriggerConfig_Trigger::set_producer_name_regex(const char* value) {
  set_has_producer_name_regex();
  producer_name_regex_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.TraceConfig.TriggerConfig.Trigger.producer_name_regex)
}
 void TraceConfig_TriggerConfig_Trigger::set_producer_name_regex(const char* value, size_t size) {
  set_has_producer_name_regex();
  producer_name_regex_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.TraceConfig.TriggerConfig.Trigger.producer_name_regex)
}
 ::std::string* TraceConfig_TriggerConfig_Trigger::mutable_producer_name_regex() {
  set_has_producer_name_regex();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.TriggerConfig.Trigger.producer_name_regex)
  return producer_name_regex_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* TraceConfig_TriggerConfig_Trigger::release_producer_name_regex() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.TriggerConfig.Trigger.producer_name_regex)
  clear_has_producer_name_regex();
  return producer_name_regex_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TraceConfig_TriggerConfig_Trigger::set_allocated_producer_name_regex(::std::string* producer_name_regex) {
  if (producer_name_regex != NULL) {
    set_has_producer_name_regex();
  } else {
    clear_has_producer_name_regex();
  }
  producer_name_regex_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), producer_name_regex);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.TriggerConfig.Trigger.producer_name_regex)
}

// optional uint32 stop_delay_ms = 3;
bool TraceConfig_TriggerConfig_Trigger::has_stop_delay_ms() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void TraceConfig_TriggerConfig_Trigger::set_has_stop_delay_ms() {
  _has_bits_[0] |= 0x00000004u;
}
void TraceConfig_TriggerConfig_Trigger::clear_has_stop_delay_ms() {
  _has_bits_[0] &= ~0x00000004u;
}
void TraceConfig_TriggerConfig_Trigger::clear_stop_delay_ms() {
  stop_delay_ms_ = 0u;
  clear_has_stop_delay_ms();
}
 ::google::protobuf::uint32 TraceConfig_TriggerConfig_Trigger::stop_delay_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.TriggerConfig.Trigger.stop_delay_ms)
  return stop_delay_ms_;
}
 void TraceConfig_TriggerConfig_Trigger::set_stop_delay_ms(::google::protobuf::uint32 value) {
  set_has_stop_delay_ms();
  stop_delay_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.TriggerConfig.Trigger.stop_delay_ms)
}

// -------------------------------------------------------------------

// TraceConfig_TriggerConfig

// optional .perfetto.protos.TraceConfig.TriggerConfig.TriggerMode trigger_mode = 1;
bool TraceConfig_TriggerConfig::has_trigger_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TraceConfig_TriggerConfig::set_has_trigger_mode() {
  _has_bits_[0] |= 0x00000001u;
}
void TraceConfig_TriggerConfig::clear_has_trigger_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
void TraceConfig_TriggerConfig::clear_trigger_mode() {
  trigger_mode_ = 0;
  clear_has_trigger_mode();
}
 ::perfetto::protos::TraceConfig_TriggerConfig_TriggerMode TraceConfig_TriggerConfig::trigger_mode() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.TriggerConfig.trigger_mode)
  return static_cast< ::perfetto::protos::TraceConfig_TriggerConfig_TriggerMode >(trigger_mode_);
}
 void TraceConfig_TriggerConfig::set_trigger_mode(::perfetto::protos::TraceConfig_TriggerConfig_TriggerMode value) {
  assert(::perfetto::protos::TraceConfig_TriggerConfig_TriggerMode_IsValid(value));
  set_has_trigger_mode();
  trigger_mode_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.TriggerConfig.trigger_mode)
}

// repeated .perfetto.protos.TraceConfig.TriggerConfig.Trigger triggers = 2;
int TraceConfig_TriggerConfig::triggers_size() const {
  return triggers_.size();
}
void TraceConfig_TriggerConfig::clear_triggers() {
  triggers_.Clear();
}
const ::perfetto::protos::TraceConfig_TriggerConfig_Trigger& TraceConfig_TriggerConfig::triggers(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.TriggerConfig.triggers)
  return triggers_.Get(index);
}
::perfetto::protos::TraceConfig_TriggerConfig_Trigger* TraceConfig_TriggerConfig::mutable_triggers(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.TriggerConfig.triggers)
  return triggers_.Mutable(index);
}
::perfetto::protos::TraceConfig_TriggerConfig_Trigger* TraceConfig_TriggerConfig::add_triggers() {
  // @@protoc_insertion_point(field_add:perfetto.protos.TraceConfig.TriggerConfig.triggers)
  return triggers_.Add();
}
::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_TriggerConfig_Trigger >*
TraceConfig_TriggerConfig::mutable_triggers() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.TraceConfig.TriggerConfig.triggers)
  return &triggers_;
}
const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_TriggerConfig_Trigger >&
TraceConfig_TriggerConfig::triggers() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.TraceConfig.TriggerConfig.triggers)
  return triggers_;
}

// optional uint32 trigger_timeout_ms = 3;
bool TraceConfig_TriggerConfig::has_trigger_timeout_ms() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void TraceConfig_TriggerConfig::set_has_trigger_timeout_ms() {
  _has_bits_[0] |= 0x00000004u;
}
void TraceConfig_TriggerConfig::clear_has_trigger_timeout_ms() {
  _has_bits_[0] &= ~0x00000004u;
}
void TraceConfig_TriggerConfig::clear_trigger_timeout_ms() {
  trigger_timeout_ms_ = 0u;
  clear_has_trigger_timeout_ms();
}
 ::google::protobuf::uint32 TraceConfig_TriggerConfig::trigger_timeout_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.TriggerConfig.trigger_timeout_ms)
  return trigger_timeout_ms_;
}
 void TraceConfig_TriggerConfig::set_trigger_timeout_ms(::google::protobuf::uint32 value) {
  set_has_trigger_timeout_ms();
  trigger_timeout_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.TriggerConfig.trigger_timeout_ms)
}

// -------------------------------------------------------------------

// TraceConfig_IncrementalStateConfig

// optional uint32 clear_period_ms = 1;
bool TraceConfig_IncrementalStateConfig::has_clear_period_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TraceConfig_IncrementalStateConfig::set_has_clear_period_ms() {
  _has_bits_[0] |= 0x00000001u;
}
void TraceConfig_IncrementalStateConfig::clear_has_clear_period_ms() {
  _has_bits_[0] &= ~0x00000001u;
}
void TraceConfig_IncrementalStateConfig::clear_clear_period_ms() {
  clear_period_ms_ = 0u;
  clear_has_clear_period_ms();
}
 ::google::protobuf::uint32 TraceConfig_IncrementalStateConfig::clear_period_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.IncrementalStateConfig.clear_period_ms)
  return clear_period_ms_;
}
 void TraceConfig_IncrementalStateConfig::set_clear_period_ms(::google::protobuf::uint32 value) {
  set_has_clear_period_ms();
  clear_period_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.IncrementalStateConfig.clear_period_ms)
}

// -------------------------------------------------------------------

// TraceConfig_IncidentReportConfig

// optional string destination_package = 1;
bool TraceConfig_IncidentReportConfig::has_destination_package() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TraceConfig_IncidentReportConfig::set_has_destination_package() {
  _has_bits_[0] |= 0x00000001u;
}
void TraceConfig_IncidentReportConfig::clear_has_destination_package() {
  _has_bits_[0] &= ~0x00000001u;
}
void TraceConfig_IncidentReportConfig::clear_destination_package() {
  destination_package_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_destination_package();
}
 const ::std::string& TraceConfig_IncidentReportConfig::destination_package() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.IncidentReportConfig.destination_package)
  return destination_package_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TraceConfig_IncidentReportConfig::set_destination_package(const ::std::string& value) {
  set_has_destination_package();
  destination_package_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.IncidentReportConfig.destination_package)
}
 void TraceConfig_IncidentReportConfig::set_destination_package(const char* value) {
  set_has_destination_package();
  destination_package_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.TraceConfig.IncidentReportConfig.destination_package)
}
 void TraceConfig_IncidentReportConfig::set_destination_package(const char* value, size_t size) {
  set_has_destination_package();
  destination_package_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.TraceConfig.IncidentReportConfig.destination_package)
}
 ::std::string* TraceConfig_IncidentReportConfig::mutable_destination_package() {
  set_has_destination_package();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.IncidentReportConfig.destination_package)
  return destination_package_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* TraceConfig_IncidentReportConfig::release_destination_package() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.IncidentReportConfig.destination_package)
  clear_has_destination_package();
  return destination_package_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TraceConfig_IncidentReportConfig::set_allocated_destination_package(::std::string* destination_package) {
  if (destination_package != NULL) {
    set_has_destination_package();
  } else {
    clear_has_destination_package();
  }
  destination_package_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), destination_package);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.IncidentReportConfig.destination_package)
}

// optional string destination_class = 2;
bool TraceConfig_IncidentReportConfig::has_destination_class() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void TraceConfig_IncidentReportConfig::set_has_destination_class() {
  _has_bits_[0] |= 0x00000002u;
}
void TraceConfig_IncidentReportConfig::clear_has_destination_class() {
  _has_bits_[0] &= ~0x00000002u;
}
void TraceConfig_IncidentReportConfig::clear_destination_class() {
  destination_class_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_destination_class();
}
 const ::std::string& TraceConfig_IncidentReportConfig::destination_class() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.IncidentReportConfig.destination_class)
  return destination_class_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TraceConfig_IncidentReportConfig::set_destination_class(const ::std::string& value) {
  set_has_destination_class();
  destination_class_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.IncidentReportConfig.destination_class)
}
 void TraceConfig_IncidentReportConfig::set_destination_class(const char* value) {
  set_has_destination_class();
  destination_class_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.TraceConfig.IncidentReportConfig.destination_class)
}
 void TraceConfig_IncidentReportConfig::set_destination_class(const char* value, size_t size) {
  set_has_destination_class();
  destination_class_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.TraceConfig.IncidentReportConfig.destination_class)
}
 ::std::string* TraceConfig_IncidentReportConfig::mutable_destination_class() {
  set_has_destination_class();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.IncidentReportConfig.destination_class)
  return destination_class_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* TraceConfig_IncidentReportConfig::release_destination_class() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.IncidentReportConfig.destination_class)
  clear_has_destination_class();
  return destination_class_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TraceConfig_IncidentReportConfig::set_allocated_destination_class(::std::string* destination_class) {
  if (destination_class != NULL) {
    set_has_destination_class();
  } else {
    clear_has_destination_class();
  }
  destination_class_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), destination_class);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.IncidentReportConfig.destination_class)
}

// optional int32 privacy_level = 3;
bool TraceConfig_IncidentReportConfig::has_privacy_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void TraceConfig_IncidentReportConfig::set_has_privacy_level() {
  _has_bits_[0] |= 0x00000004u;
}
void TraceConfig_IncidentReportConfig::clear_has_privacy_level() {
  _has_bits_[0] &= ~0x00000004u;
}
void TraceConfig_IncidentReportConfig::clear_privacy_level() {
  privacy_level_ = 0;
  clear_has_privacy_level();
}
 ::google::protobuf::int32 TraceConfig_IncidentReportConfig::privacy_level() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.IncidentReportConfig.privacy_level)
  return privacy_level_;
}
 void TraceConfig_IncidentReportConfig::set_privacy_level(::google::protobuf::int32 value) {
  set_has_privacy_level();
  privacy_level_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.IncidentReportConfig.privacy_level)
}

// optional bool skip_dropbox = 4;
bool TraceConfig_IncidentReportConfig::has_skip_dropbox() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void TraceConfig_IncidentReportConfig::set_has_skip_dropbox() {
  _has_bits_[0] |= 0x00000008u;
}
void TraceConfig_IncidentReportConfig::clear_has_skip_dropbox() {
  _has_bits_[0] &= ~0x00000008u;
}
void TraceConfig_IncidentReportConfig::clear_skip_dropbox() {
  skip_dropbox_ = false;
  clear_has_skip_dropbox();
}
 bool TraceConfig_IncidentReportConfig::skip_dropbox() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.IncidentReportConfig.skip_dropbox)
  return skip_dropbox_;
}
 void TraceConfig_IncidentReportConfig::set_skip_dropbox(bool value) {
  set_has_skip_dropbox();
  skip_dropbox_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.IncidentReportConfig.skip_dropbox)
}

// -------------------------------------------------------------------

// TraceConfig

// repeated .perfetto.protos.TraceConfig.BufferConfig buffers = 1;
int TraceConfig::buffers_size() const {
  return buffers_.size();
}
void TraceConfig::clear_buffers() {
  buffers_.Clear();
}
const ::perfetto::protos::TraceConfig_BufferConfig& TraceConfig::buffers(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.buffers)
  return buffers_.Get(index);
}
::perfetto::protos::TraceConfig_BufferConfig* TraceConfig::mutable_buffers(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.buffers)
  return buffers_.Mutable(index);
}
::perfetto::protos::TraceConfig_BufferConfig* TraceConfig::add_buffers() {
  // @@protoc_insertion_point(field_add:perfetto.protos.TraceConfig.buffers)
  return buffers_.Add();
}
::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_BufferConfig >*
TraceConfig::mutable_buffers() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.TraceConfig.buffers)
  return &buffers_;
}
const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_BufferConfig >&
TraceConfig::buffers() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.TraceConfig.buffers)
  return buffers_;
}

// repeated .perfetto.protos.TraceConfig.DataSource data_sources = 2;
int TraceConfig::data_sources_size() const {
  return data_sources_.size();
}
void TraceConfig::clear_data_sources() {
  data_sources_.Clear();
}
const ::perfetto::protos::TraceConfig_DataSource& TraceConfig::data_sources(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.data_sources)
  return data_sources_.Get(index);
}
::perfetto::protos::TraceConfig_DataSource* TraceConfig::mutable_data_sources(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.data_sources)
  return data_sources_.Mutable(index);
}
::perfetto::protos::TraceConfig_DataSource* TraceConfig::add_data_sources() {
  // @@protoc_insertion_point(field_add:perfetto.protos.TraceConfig.data_sources)
  return data_sources_.Add();
}
::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_DataSource >*
TraceConfig::mutable_data_sources() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.TraceConfig.data_sources)
  return &data_sources_;
}
const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_DataSource >&
TraceConfig::data_sources() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.TraceConfig.data_sources)
  return data_sources_;
}

// optional .perfetto.protos.TraceConfig.BuiltinDataSource builtin_data_sources = 20;
bool TraceConfig::has_builtin_data_sources() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void TraceConfig::set_has_builtin_data_sources() {
  _has_bits_[0] |= 0x00000004u;
}
void TraceConfig::clear_has_builtin_data_sources() {
  _has_bits_[0] &= ~0x00000004u;
}
void TraceConfig::clear_builtin_data_sources() {
  if (builtin_data_sources_ != NULL) builtin_data_sources_->::perfetto::protos::TraceConfig_BuiltinDataSource::Clear();
  clear_has_builtin_data_sources();
}
const ::perfetto::protos::TraceConfig_BuiltinDataSource& TraceConfig::builtin_data_sources() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.builtin_data_sources)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return builtin_data_sources_ != NULL ? *builtin_data_sources_ : *default_instance().builtin_data_sources_;
#else
  return builtin_data_sources_ != NULL ? *builtin_data_sources_ : *default_instance_->builtin_data_sources_;
#endif
}
::perfetto::protos::TraceConfig_BuiltinDataSource* TraceConfig::mutable_builtin_data_sources() {
  set_has_builtin_data_sources();
  if (builtin_data_sources_ == NULL) {
    builtin_data_sources_ = new ::perfetto::protos::TraceConfig_BuiltinDataSource;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.builtin_data_sources)
  return builtin_data_sources_;
}
::perfetto::protos::TraceConfig_BuiltinDataSource* TraceConfig::release_builtin_data_sources() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.builtin_data_sources)
  clear_has_builtin_data_sources();
  ::perfetto::protos::TraceConfig_BuiltinDataSource* temp = builtin_data_sources_;
  builtin_data_sources_ = NULL;
  return temp;
}
void TraceConfig::set_allocated_builtin_data_sources(::perfetto::protos::TraceConfig_BuiltinDataSource* builtin_data_sources) {
  delete builtin_data_sources_;
  builtin_data_sources_ = builtin_data_sources;
  if (builtin_data_sources) {
    set_has_builtin_data_sources();
  } else {
    clear_has_builtin_data_sources();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.builtin_data_sources)
}

// optional uint32 duration_ms = 3;
bool TraceConfig::has_duration_ms() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void TraceConfig::set_has_duration_ms() {
  _has_bits_[0] |= 0x00000008u;
}
void TraceConfig::clear_has_duration_ms() {
  _has_bits_[0] &= ~0x00000008u;
}
void TraceConfig::clear_duration_ms() {
  duration_ms_ = 0u;
  clear_has_duration_ms();
}
 ::google::protobuf::uint32 TraceConfig::duration_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.duration_ms)
  return duration_ms_;
}
 void TraceConfig::set_duration_ms(::google::protobuf::uint32 value) {
  set_has_duration_ms();
  duration_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.duration_ms)
}

// optional bool enable_extra_guardrails = 4;
bool TraceConfig::has_enable_extra_guardrails() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void TraceConfig::set_has_enable_extra_guardrails() {
  _has_bits_[0] |= 0x00000010u;
}
void TraceConfig::clear_has_enable_extra_guardrails() {
  _has_bits_[0] &= ~0x00000010u;
}
void TraceConfig::clear_enable_extra_guardrails() {
  enable_extra_guardrails_ = false;
  clear_has_enable_extra_guardrails();
}
 bool TraceConfig::enable_extra_guardrails() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.enable_extra_guardrails)
  return enable_extra_guardrails_;
}
 void TraceConfig::set_enable_extra_guardrails(bool value) {
  set_has_enable_extra_guardrails();
  enable_extra_guardrails_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.enable_extra_guardrails)
}

// optional .perfetto.protos.TraceConfig.LockdownModeOperation lockdown_mode = 5;
bool TraceConfig::has_lockdown_mode() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void TraceConfig::set_has_lockdown_mode() {
  _has_bits_[0] |= 0x00000020u;
}
void TraceConfig::clear_has_lockdown_mode() {
  _has_bits_[0] &= ~0x00000020u;
}
void TraceConfig::clear_lockdown_mode() {
  lockdown_mode_ = 0;
  clear_has_lockdown_mode();
}
 ::perfetto::protos::TraceConfig_LockdownModeOperation TraceConfig::lockdown_mode() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.lockdown_mode)
  return static_cast< ::perfetto::protos::TraceConfig_LockdownModeOperation >(lockdown_mode_);
}
 void TraceConfig::set_lockdown_mode(::perfetto::protos::TraceConfig_LockdownModeOperation value) {
  assert(::perfetto::protos::TraceConfig_LockdownModeOperation_IsValid(value));
  set_has_lockdown_mode();
  lockdown_mode_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.lockdown_mode)
}

// repeated .perfetto.protos.TraceConfig.ProducerConfig producers = 6;
int TraceConfig::producers_size() const {
  return producers_.size();
}
void TraceConfig::clear_producers() {
  producers_.Clear();
}
const ::perfetto::protos::TraceConfig_ProducerConfig& TraceConfig::producers(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.producers)
  return producers_.Get(index);
}
::perfetto::protos::TraceConfig_ProducerConfig* TraceConfig::mutable_producers(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.producers)
  return producers_.Mutable(index);
}
::perfetto::protos::TraceConfig_ProducerConfig* TraceConfig::add_producers() {
  // @@protoc_insertion_point(field_add:perfetto.protos.TraceConfig.producers)
  return producers_.Add();
}
::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_ProducerConfig >*
TraceConfig::mutable_producers() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.TraceConfig.producers)
  return &producers_;
}
const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::TraceConfig_ProducerConfig >&
TraceConfig::producers() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.TraceConfig.producers)
  return producers_;
}

// optional .perfetto.protos.TraceConfig.StatsdMetadata statsd_metadata = 7;
bool TraceConfig::has_statsd_metadata() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void TraceConfig::set_has_statsd_metadata() {
  _has_bits_[0] |= 0x00000080u;
}
void TraceConfig::clear_has_statsd_metadata() {
  _has_bits_[0] &= ~0x00000080u;
}
void TraceConfig::clear_statsd_metadata() {
  if (statsd_metadata_ != NULL) statsd_metadata_->::perfetto::protos::TraceConfig_StatsdMetadata::Clear();
  clear_has_statsd_metadata();
}
const ::perfetto::protos::TraceConfig_StatsdMetadata& TraceConfig::statsd_metadata() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.statsd_metadata)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return statsd_metadata_ != NULL ? *statsd_metadata_ : *default_instance().statsd_metadata_;
#else
  return statsd_metadata_ != NULL ? *statsd_metadata_ : *default_instance_->statsd_metadata_;
#endif
}
::perfetto::protos::TraceConfig_StatsdMetadata* TraceConfig::mutable_statsd_metadata() {
  set_has_statsd_metadata();
  if (statsd_metadata_ == NULL) {
    statsd_metadata_ = new ::perfetto::protos::TraceConfig_StatsdMetadata;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.statsd_metadata)
  return statsd_metadata_;
}
::perfetto::protos::TraceConfig_StatsdMetadata* TraceConfig::release_statsd_metadata() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.statsd_metadata)
  clear_has_statsd_metadata();
  ::perfetto::protos::TraceConfig_StatsdMetadata* temp = statsd_metadata_;
  statsd_metadata_ = NULL;
  return temp;
}
void TraceConfig::set_allocated_statsd_metadata(::perfetto::protos::TraceConfig_StatsdMetadata* statsd_metadata) {
  delete statsd_metadata_;
  statsd_metadata_ = statsd_metadata;
  if (statsd_metadata) {
    set_has_statsd_metadata();
  } else {
    clear_has_statsd_metadata();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.statsd_metadata)
}

// optional bool write_into_file = 8;
bool TraceConfig::has_write_into_file() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void TraceConfig::set_has_write_into_file() {
  _has_bits_[0] |= 0x00000100u;
}
void TraceConfig::clear_has_write_into_file() {
  _has_bits_[0] &= ~0x00000100u;
}
void TraceConfig::clear_write_into_file() {
  write_into_file_ = false;
  clear_has_write_into_file();
}
 bool TraceConfig::write_into_file() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.write_into_file)
  return write_into_file_;
}
 void TraceConfig::set_write_into_file(bool value) {
  set_has_write_into_file();
  write_into_file_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.write_into_file)
}

// optional uint32 file_write_period_ms = 9;
bool TraceConfig::has_file_write_period_ms() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void TraceConfig::set_has_file_write_period_ms() {
  _has_bits_[0] |= 0x00000200u;
}
void TraceConfig::clear_has_file_write_period_ms() {
  _has_bits_[0] &= ~0x00000200u;
}
void TraceConfig::clear_file_write_period_ms() {
  file_write_period_ms_ = 0u;
  clear_has_file_write_period_ms();
}
 ::google::protobuf::uint32 TraceConfig::file_write_period_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.file_write_period_ms)
  return file_write_period_ms_;
}
 void TraceConfig::set_file_write_period_ms(::google::protobuf::uint32 value) {
  set_has_file_write_period_ms();
  file_write_period_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.file_write_period_ms)
}

// optional uint64 max_file_size_bytes = 10;
bool TraceConfig::has_max_file_size_bytes() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
void TraceConfig::set_has_max_file_size_bytes() {
  _has_bits_[0] |= 0x00000400u;
}
void TraceConfig::clear_has_max_file_size_bytes() {
  _has_bits_[0] &= ~0x00000400u;
}
void TraceConfig::clear_max_file_size_bytes() {
  max_file_size_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_max_file_size_bytes();
}
 ::google::protobuf::uint64 TraceConfig::max_file_size_bytes() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.max_file_size_bytes)
  return max_file_size_bytes_;
}
 void TraceConfig::set_max_file_size_bytes(::google::protobuf::uint64 value) {
  set_has_max_file_size_bytes();
  max_file_size_bytes_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.max_file_size_bytes)
}

// optional .perfetto.protos.TraceConfig.GuardrailOverrides guardrail_overrides = 11;
bool TraceConfig::has_guardrail_overrides() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
void TraceConfig::set_has_guardrail_overrides() {
  _has_bits_[0] |= 0x00000800u;
}
void TraceConfig::clear_has_guardrail_overrides() {
  _has_bits_[0] &= ~0x00000800u;
}
void TraceConfig::clear_guardrail_overrides() {
  if (guardrail_overrides_ != NULL) guardrail_overrides_->::perfetto::protos::TraceConfig_GuardrailOverrides::Clear();
  clear_has_guardrail_overrides();
}
const ::perfetto::protos::TraceConfig_GuardrailOverrides& TraceConfig::guardrail_overrides() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.guardrail_overrides)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return guardrail_overrides_ != NULL ? *guardrail_overrides_ : *default_instance().guardrail_overrides_;
#else
  return guardrail_overrides_ != NULL ? *guardrail_overrides_ : *default_instance_->guardrail_overrides_;
#endif
}
::perfetto::protos::TraceConfig_GuardrailOverrides* TraceConfig::mutable_guardrail_overrides() {
  set_has_guardrail_overrides();
  if (guardrail_overrides_ == NULL) {
    guardrail_overrides_ = new ::perfetto::protos::TraceConfig_GuardrailOverrides;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.guardrail_overrides)
  return guardrail_overrides_;
}
::perfetto::protos::TraceConfig_GuardrailOverrides* TraceConfig::release_guardrail_overrides() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.guardrail_overrides)
  clear_has_guardrail_overrides();
  ::perfetto::protos::TraceConfig_GuardrailOverrides* temp = guardrail_overrides_;
  guardrail_overrides_ = NULL;
  return temp;
}
void TraceConfig::set_allocated_guardrail_overrides(::perfetto::protos::TraceConfig_GuardrailOverrides* guardrail_overrides) {
  delete guardrail_overrides_;
  guardrail_overrides_ = guardrail_overrides;
  if (guardrail_overrides) {
    set_has_guardrail_overrides();
  } else {
    clear_has_guardrail_overrides();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.guardrail_overrides)
}

// optional bool deferred_start = 12;
bool TraceConfig::has_deferred_start() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
void TraceConfig::set_has_deferred_start() {
  _has_bits_[0] |= 0x00001000u;
}
void TraceConfig::clear_has_deferred_start() {
  _has_bits_[0] &= ~0x00001000u;
}
void TraceConfig::clear_deferred_start() {
  deferred_start_ = false;
  clear_has_deferred_start();
}
 bool TraceConfig::deferred_start() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.deferred_start)
  return deferred_start_;
}
 void TraceConfig::set_deferred_start(bool value) {
  set_has_deferred_start();
  deferred_start_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.deferred_start)
}

// optional uint32 flush_period_ms = 13;
bool TraceConfig::has_flush_period_ms() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
void TraceConfig::set_has_flush_period_ms() {
  _has_bits_[0] |= 0x00002000u;
}
void TraceConfig::clear_has_flush_period_ms() {
  _has_bits_[0] &= ~0x00002000u;
}
void TraceConfig::clear_flush_period_ms() {
  flush_period_ms_ = 0u;
  clear_has_flush_period_ms();
}
 ::google::protobuf::uint32 TraceConfig::flush_period_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.flush_period_ms)
  return flush_period_ms_;
}
 void TraceConfig::set_flush_period_ms(::google::protobuf::uint32 value) {
  set_has_flush_period_ms();
  flush_period_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.flush_period_ms)
}

// optional uint32 flush_timeout_ms = 14;
bool TraceConfig::has_flush_timeout_ms() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
void TraceConfig::set_has_flush_timeout_ms() {
  _has_bits_[0] |= 0x00004000u;
}
void TraceConfig::clear_has_flush_timeout_ms() {
  _has_bits_[0] &= ~0x00004000u;
}
void TraceConfig::clear_flush_timeout_ms() {
  flush_timeout_ms_ = 0u;
  clear_has_flush_timeout_ms();
}
 ::google::protobuf::uint32 TraceConfig::flush_timeout_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.flush_timeout_ms)
  return flush_timeout_ms_;
}
 void TraceConfig::set_flush_timeout_ms(::google::protobuf::uint32 value) {
  set_has_flush_timeout_ms();
  flush_timeout_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.flush_timeout_ms)
}

// optional uint32 data_source_stop_timeout_ms = 23;
bool TraceConfig::has_data_source_stop_timeout_ms() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
void TraceConfig::set_has_data_source_stop_timeout_ms() {
  _has_bits_[0] |= 0x00008000u;
}
void TraceConfig::clear_has_data_source_stop_timeout_ms() {
  _has_bits_[0] &= ~0x00008000u;
}
void TraceConfig::clear_data_source_stop_timeout_ms() {
  data_source_stop_timeout_ms_ = 0u;
  clear_has_data_source_stop_timeout_ms();
}
 ::google::protobuf::uint32 TraceConfig::data_source_stop_timeout_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.data_source_stop_timeout_ms)
  return data_source_stop_timeout_ms_;
}
 void TraceConfig::set_data_source_stop_timeout_ms(::google::protobuf::uint32 value) {
  set_has_data_source_stop_timeout_ms();
  data_source_stop_timeout_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.data_source_stop_timeout_ms)
}

// optional bool notify_traceur = 16;
bool TraceConfig::has_notify_traceur() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
void TraceConfig::set_has_notify_traceur() {
  _has_bits_[0] |= 0x00010000u;
}
void TraceConfig::clear_has_notify_traceur() {
  _has_bits_[0] &= ~0x00010000u;
}
void TraceConfig::clear_notify_traceur() {
  notify_traceur_ = false;
  clear_has_notify_traceur();
}
 bool TraceConfig::notify_traceur() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.notify_traceur)
  return notify_traceur_;
}
 void TraceConfig::set_notify_traceur(bool value) {
  set_has_notify_traceur();
  notify_traceur_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.notify_traceur)
}

// optional .perfetto.protos.TraceConfig.TriggerConfig trigger_config = 17;
bool TraceConfig::has_trigger_config() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
void TraceConfig::set_has_trigger_config() {
  _has_bits_[0] |= 0x00020000u;
}
void TraceConfig::clear_has_trigger_config() {
  _has_bits_[0] &= ~0x00020000u;
}
void TraceConfig::clear_trigger_config() {
  if (trigger_config_ != NULL) trigger_config_->::perfetto::protos::TraceConfig_TriggerConfig::Clear();
  clear_has_trigger_config();
}
const ::perfetto::protos::TraceConfig_TriggerConfig& TraceConfig::trigger_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.trigger_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return trigger_config_ != NULL ? *trigger_config_ : *default_instance().trigger_config_;
#else
  return trigger_config_ != NULL ? *trigger_config_ : *default_instance_->trigger_config_;
#endif
}
::perfetto::protos::TraceConfig_TriggerConfig* TraceConfig::mutable_trigger_config() {
  set_has_trigger_config();
  if (trigger_config_ == NULL) {
    trigger_config_ = new ::perfetto::protos::TraceConfig_TriggerConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.trigger_config)
  return trigger_config_;
}
::perfetto::protos::TraceConfig_TriggerConfig* TraceConfig::release_trigger_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.trigger_config)
  clear_has_trigger_config();
  ::perfetto::protos::TraceConfig_TriggerConfig* temp = trigger_config_;
  trigger_config_ = NULL;
  return temp;
}
void TraceConfig::set_allocated_trigger_config(::perfetto::protos::TraceConfig_TriggerConfig* trigger_config) {
  delete trigger_config_;
  trigger_config_ = trigger_config;
  if (trigger_config) {
    set_has_trigger_config();
  } else {
    clear_has_trigger_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.trigger_config)
}

// repeated string activate_triggers = 18;
int TraceConfig::activate_triggers_size() const {
  return activate_triggers_.size();
}
void TraceConfig::clear_activate_triggers() {
  activate_triggers_.Clear();
}
 const ::std::string& TraceConfig::activate_triggers(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.activate_triggers)
  return activate_triggers_.Get(index);
}
 ::std::string* TraceConfig::mutable_activate_triggers(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.activate_triggers)
  return activate_triggers_.Mutable(index);
}
 void TraceConfig::set_activate_triggers(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.activate_triggers)
  activate_triggers_.Mutable(index)->assign(value);
}
 void TraceConfig::set_activate_triggers(int index, const char* value) {
  activate_triggers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.TraceConfig.activate_triggers)
}
 void TraceConfig::set_activate_triggers(int index, const char* value, size_t size) {
  activate_triggers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.TraceConfig.activate_triggers)
}
 ::std::string* TraceConfig::add_activate_triggers() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.TraceConfig.activate_triggers)
  return activate_triggers_.Add();
}
 void TraceConfig::add_activate_triggers(const ::std::string& value) {
  activate_triggers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.TraceConfig.activate_triggers)
}
 void TraceConfig::add_activate_triggers(const char* value) {
  activate_triggers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.TraceConfig.activate_triggers)
}
 void TraceConfig::add_activate_triggers(const char* value, size_t size) {
  activate_triggers_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.TraceConfig.activate_triggers)
}
 const ::google::protobuf::RepeatedPtrField< ::std::string>&
TraceConfig::activate_triggers() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.TraceConfig.activate_triggers)
  return activate_triggers_;
}
 ::google::protobuf::RepeatedPtrField< ::std::string>*
TraceConfig::mutable_activate_triggers() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.TraceConfig.activate_triggers)
  return &activate_triggers_;
}

// optional .perfetto.protos.TraceConfig.IncrementalStateConfig incremental_state_config = 21;
bool TraceConfig::has_incremental_state_config() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
void TraceConfig::set_has_incremental_state_config() {
  _has_bits_[0] |= 0x00080000u;
}
void TraceConfig::clear_has_incremental_state_config() {
  _has_bits_[0] &= ~0x00080000u;
}
void TraceConfig::clear_incremental_state_config() {
  if (incremental_state_config_ != NULL) incremental_state_config_->::perfetto::protos::TraceConfig_IncrementalStateConfig::Clear();
  clear_has_incremental_state_config();
}
const ::perfetto::protos::TraceConfig_IncrementalStateConfig& TraceConfig::incremental_state_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.incremental_state_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return incremental_state_config_ != NULL ? *incremental_state_config_ : *default_instance().incremental_state_config_;
#else
  return incremental_state_config_ != NULL ? *incremental_state_config_ : *default_instance_->incremental_state_config_;
#endif
}
::perfetto::protos::TraceConfig_IncrementalStateConfig* TraceConfig::mutable_incremental_state_config() {
  set_has_incremental_state_config();
  if (incremental_state_config_ == NULL) {
    incremental_state_config_ = new ::perfetto::protos::TraceConfig_IncrementalStateConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.incremental_state_config)
  return incremental_state_config_;
}
::perfetto::protos::TraceConfig_IncrementalStateConfig* TraceConfig::release_incremental_state_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.incremental_state_config)
  clear_has_incremental_state_config();
  ::perfetto::protos::TraceConfig_IncrementalStateConfig* temp = incremental_state_config_;
  incremental_state_config_ = NULL;
  return temp;
}
void TraceConfig::set_allocated_incremental_state_config(::perfetto::protos::TraceConfig_IncrementalStateConfig* incremental_state_config) {
  delete incremental_state_config_;
  incremental_state_config_ = incremental_state_config;
  if (incremental_state_config) {
    set_has_incremental_state_config();
  } else {
    clear_has_incremental_state_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.incremental_state_config)
}

// optional bool allow_user_build_tracing = 19;
bool TraceConfig::has_allow_user_build_tracing() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
void TraceConfig::set_has_allow_user_build_tracing() {
  _has_bits_[0] |= 0x00100000u;
}
void TraceConfig::clear_has_allow_user_build_tracing() {
  _has_bits_[0] &= ~0x00100000u;
}
void TraceConfig::clear_allow_user_build_tracing() {
  allow_user_build_tracing_ = false;
  clear_has_allow_user_build_tracing();
}
 bool TraceConfig::allow_user_build_tracing() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.allow_user_build_tracing)
  return allow_user_build_tracing_;
}
 void TraceConfig::set_allow_user_build_tracing(bool value) {
  set_has_allow_user_build_tracing();
  allow_user_build_tracing_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.allow_user_build_tracing)
}

// optional string unique_session_name = 22;
bool TraceConfig::has_unique_session_name() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
void TraceConfig::set_has_unique_session_name() {
  _has_bits_[0] |= 0x00200000u;
}
void TraceConfig::clear_has_unique_session_name() {
  _has_bits_[0] &= ~0x00200000u;
}
void TraceConfig::clear_unique_session_name() {
  unique_session_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_unique_session_name();
}
 const ::std::string& TraceConfig::unique_session_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.unique_session_name)
  return unique_session_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TraceConfig::set_unique_session_name(const ::std::string& value) {
  set_has_unique_session_name();
  unique_session_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.unique_session_name)
}
 void TraceConfig::set_unique_session_name(const char* value) {
  set_has_unique_session_name();
  unique_session_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.TraceConfig.unique_session_name)
}
 void TraceConfig::set_unique_session_name(const char* value, size_t size) {
  set_has_unique_session_name();
  unique_session_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.TraceConfig.unique_session_name)
}
 ::std::string* TraceConfig::mutable_unique_session_name() {
  set_has_unique_session_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.unique_session_name)
  return unique_session_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* TraceConfig::release_unique_session_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.unique_session_name)
  clear_has_unique_session_name();
  return unique_session_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TraceConfig::set_allocated_unique_session_name(::std::string* unique_session_name) {
  if (unique_session_name != NULL) {
    set_has_unique_session_name();
  } else {
    clear_has_unique_session_name();
  }
  unique_session_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), unique_session_name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.unique_session_name)
}

// optional .perfetto.protos.TraceConfig.CompressionType compression_type = 24;
bool TraceConfig::has_compression_type() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
void TraceConfig::set_has_compression_type() {
  _has_bits_[0] |= 0x00400000u;
}
void TraceConfig::clear_has_compression_type() {
  _has_bits_[0] &= ~0x00400000u;
}
void TraceConfig::clear_compression_type() {
  compression_type_ = 0;
  clear_has_compression_type();
}
 ::perfetto::protos::TraceConfig_CompressionType TraceConfig::compression_type() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.compression_type)
  return static_cast< ::perfetto::protos::TraceConfig_CompressionType >(compression_type_);
}
 void TraceConfig::set_compression_type(::perfetto::protos::TraceConfig_CompressionType value) {
  assert(::perfetto::protos::TraceConfig_CompressionType_IsValid(value));
  set_has_compression_type();
  compression_type_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TraceConfig.compression_type)
}

// optional .perfetto.protos.TraceConfig.IncidentReportConfig incident_report_config = 25;
bool TraceConfig::has_incident_report_config() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
void TraceConfig::set_has_incident_report_config() {
  _has_bits_[0] |= 0x00800000u;
}
void TraceConfig::clear_has_incident_report_config() {
  _has_bits_[0] &= ~0x00800000u;
}
void TraceConfig::clear_incident_report_config() {
  if (incident_report_config_ != NULL) incident_report_config_->::perfetto::protos::TraceConfig_IncidentReportConfig::Clear();
  clear_has_incident_report_config();
}
const ::perfetto::protos::TraceConfig_IncidentReportConfig& TraceConfig::incident_report_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TraceConfig.incident_report_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return incident_report_config_ != NULL ? *incident_report_config_ : *default_instance().incident_report_config_;
#else
  return incident_report_config_ != NULL ? *incident_report_config_ : *default_instance_->incident_report_config_;
#endif
}
::perfetto::protos::TraceConfig_IncidentReportConfig* TraceConfig::mutable_incident_report_config() {
  set_has_incident_report_config();
  if (incident_report_config_ == NULL) {
    incident_report_config_ = new ::perfetto::protos::TraceConfig_IncidentReportConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TraceConfig.incident_report_config)
  return incident_report_config_;
}
::perfetto::protos::TraceConfig_IncidentReportConfig* TraceConfig::release_incident_report_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TraceConfig.incident_report_config)
  clear_has_incident_report_config();
  ::perfetto::protos::TraceConfig_IncidentReportConfig* temp = incident_report_config_;
  incident_report_config_ = NULL;
  return temp;
}
void TraceConfig::set_allocated_incident_report_config(::perfetto::protos::TraceConfig_IncidentReportConfig* incident_report_config) {
  delete incident_report_config_;
  incident_report_config_ = incident_report_config;
  if (incident_report_config) {
    set_has_incident_report_config();
  } else {
    clear_has_incident_report_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TraceConfig.incident_report_config)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)
// gen_amalgamated begin source: src/base/unix_socket.cc
// gen_amalgamated begin header: include/perfetto/ext/base/unix_socket.h
// gen_amalgamated begin header: include/perfetto/ext/base/weak_ptr.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_BASE_WEAK_PTR_H_
#define INCLUDE_PERFETTO_EXT_BASE_WEAK_PTR_H_

// gen_amalgamated expanded: #include "perfetto/ext/base/thread_checker.h"

#include <memory>

namespace perfetto {
namespace base {

// A simple WeakPtr for single-threaded cases.
// Generally keep the WeakPtrFactory as last fields in classes: it makes the
// WeakPtr(s) invalidate as first thing in the class dtor.
// Usage:
// class MyClass {
//  MyClass() : weak_factory_(this) {}
//  WeakPtr<MyClass> GetWeakPtr() { return weak_factory_.GetWeakPtr(); }
//
// private:
//  WeakPtrFactory<MyClass> weak_factory_;
// }
//
// int main() {
//  std::unique_ptr<MyClass> foo(new MyClass);
//  auto wptr = foo.GetWeakPtr();
//  ASSERT_TRUE(wptr);
//  ASSERT_EQ(foo.get(), wptr->get());
//  foo.reset();
//  ASSERT_FALSE(wptr);
//  ASSERT_EQ(nullptr, wptr->get());
// }

template <typename T>
class WeakPtrFactory;  // Forward declaration, defined below.

template <typename T>
class WeakPtr {
 public:
  WeakPtr() {}
  WeakPtr(const WeakPtr&) = default;
  WeakPtr& operator=(const WeakPtr&) = default;
  WeakPtr(WeakPtr&&) = default;
  WeakPtr& operator=(WeakPtr&&) = default;

  T* get() const {
    PERFETTO_DCHECK_THREAD(thread_checker);
    return handle_ ? *handle_.get() : nullptr;
  }
  T* operator->() const { return get(); }
  T& operator*() const { return *get(); }

  explicit operator bool() const { return !!get(); }

 private:
  friend class WeakPtrFactory<T>;
  explicit WeakPtr(const std::shared_ptr<T*>& handle) : handle_(handle) {}

  std::shared_ptr<T*> handle_;
  PERFETTO_THREAD_CHECKER(thread_checker)
};

template <typename T>
class WeakPtrFactory {
 public:
  explicit WeakPtrFactory(T* owner)
      : weak_ptr_(std::shared_ptr<T*>(new T* {owner})) {
    PERFETTO_DCHECK_THREAD(thread_checker);
  }

  ~WeakPtrFactory() {
    PERFETTO_DCHECK_THREAD(thread_checker);
    *(weak_ptr_.handle_.get()) = nullptr;
  }

  // Can be safely called on any thread, since it simply copies |weak_ptr_|.
  // Note that any accesses to the returned pointer need to be made on the
  // thread that created the factory.
  WeakPtr<T> GetWeakPtr() const { return weak_ptr_; }

 private:
  WeakPtrFactory(const WeakPtrFactory&) = delete;
  WeakPtrFactory& operator=(const WeakPtrFactory&) = delete;

  WeakPtr<T> weak_ptr_;
  PERFETTO_THREAD_CHECKER(thread_checker)
};

}  // namespace base
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_BASE_WEAK_PTR_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_BASE_UNIX_SOCKET_H_
#define INCLUDE_PERFETTO_EXT_BASE_UNIX_SOCKET_H_

#include <stdint.h>
#include <sys/types.h>

#include <memory>
#include <string>

// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/scoped_file.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/utils.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/weak_ptr.h"

struct msghdr;

namespace perfetto {
namespace base {

class TaskRunner;

// Use arbitrarily high values to avoid that some code accidentally ends up
// assuming that these enum values match the sysroot's SOCK_xxx defines rather
// than using GetUnixSockType().
enum class SockType { kStream = 100, kDgram, kSeqPacket };

// UnixSocketRaw is a basic wrapper around UNIX sockets. It exposes wrapper
// methods that take care of most common pitfalls (e.g., marking fd as
// O_CLOEXEC, avoiding SIGPIPE, properly handling partial writes). It is used as
// a building block for the more sophisticated UnixSocket class.
class UnixSocketRaw {
 public:
  // Creates a new unconnected unix socket.
  static UnixSocketRaw CreateMayFail(SockType t) { return UnixSocketRaw(t); }

  // Crates a pair of connected sockets.
  static std::pair<UnixSocketRaw, UnixSocketRaw> CreatePair(SockType);

  // Creates an uninitialized unix socket.
  UnixSocketRaw();

  // Creates a unix socket adopting an existing file descriptor. This is
  // typically used to inherit fds from init via environment variables.
  UnixSocketRaw(ScopedFile, SockType);

  ~UnixSocketRaw() = default;
  UnixSocketRaw(UnixSocketRaw&&) noexcept = default;
  UnixSocketRaw& operator=(UnixSocketRaw&&) = default;

  bool Bind(const std::string& socket_name);
  bool Listen();
  bool Connect(const std::string& socket_name);
  bool SetTxTimeout(uint32_t timeout_ms);
  bool SetRxTimeout(uint32_t timeout_ms);
  void Shutdown();
  void SetBlocking(bool);
  bool IsBlocking() const;
  void RetainOnExec();
  SockType type() const { return type_; }
  int fd() const { return *fd_; }
  explicit operator bool() const { return !!fd_; }

  ScopedFile ReleaseFd() { return std::move(fd_); }

  ssize_t Send(const void* msg,
               size_t len,
               const int* send_fds = nullptr,
               size_t num_fds = 0);

  // Re-enter sendmsg until all the data has been sent or an error occurs.
  // TODO(fmayer): Figure out how to do timeouts here for heapprofd.
  ssize_t SendMsgAll(struct msghdr* msg);

  ssize_t Receive(void* msg,
                  size_t len,
                  ScopedFile* fd_vec = nullptr,
                  size_t max_files = 0);

  // Exposed for testing only.
  // Update msghdr so subsequent sendmsg will send data that remains after n
  // bytes have already been sent.
  static void ShiftMsgHdr(size_t n, struct msghdr* msg);

 private:
  explicit UnixSocketRaw(SockType);

  UnixSocketRaw(const UnixSocketRaw&) = delete;
  UnixSocketRaw& operator=(const UnixSocketRaw&) = delete;

  ScopedFile fd_;
  SockType type_{SockType::kStream};
};

// A non-blocking UNIX domain socket. Allows also to transfer file descriptors.
// None of the methods in this class are blocking.
// The main design goal is making strong guarantees on the EventListener
// callbacks, in order to avoid ending in some undefined state.
// In case of any error it will aggressively just shut down the socket and
// notify the failure with OnConnect(false) or OnDisconnect() depending on the
// state of the socket (see below).
// EventListener callbacks stop happening as soon as the instance is destroyed.
//
// Lifecycle of a client socket:
//
//                           Connect()
//                               |
//            +------------------+------------------+
//            | (success)                           | (failure or Shutdown())
//            V                                     V
//     OnConnect(true)                         OnConnect(false)
//            |
//            V
//    OnDataAvailable()
//            |
//            V
//     OnDisconnect()  (failure or shutdown)
//
//
// Lifecycle of a server socket:
//
//                          Listen()  --> returns false in case of errors.
//                             |
//                             V
//              OnNewIncomingConnection(new_socket)
//
//          (|new_socket| inherits the same EventListener)
//                             |
//                             V
//                     OnDataAvailable()
//                             | (failure or Shutdown())
//                             V
//                       OnDisconnect()
class UnixSocket {
 public:
  class EventListener {
   public:
    virtual ~EventListener();

    // After Listen().
    virtual void OnNewIncomingConnection(
        UnixSocket* self,
        std::unique_ptr<UnixSocket> new_connection);

    // After Connect(), whether successful or not.
    virtual void OnConnect(UnixSocket* self, bool connected);

    // After a successful Connect() or OnNewIncomingConnection(). Either the
    // other endpoint did disconnect or some other error happened.
    virtual void OnDisconnect(UnixSocket* self);

    // Whenever there is data available to Receive(). Note that spurious FD
    // watch events are possible, so it is possible that Receive() soon after
    // OnDataAvailable() returns 0 (just ignore those).
    virtual void OnDataAvailable(UnixSocket* self);
  };

  enum class State {
    kDisconnected = 0,  // Failed connection, peer disconnection or Shutdown().
    kConnecting,  // Soon after Connect(), before it either succeeds or fails.
    kConnected,   // After a successful Connect().
    kListening    // After Listen(), until Shutdown().
  };

  enum class BlockingMode { kNonBlocking, kBlocking };

  // Creates a Unix domain socket and starts listening. If |socket_name|
  // starts with a '@', an abstract socket will be created (Linux/Android only).
  // Returns always an instance. In case of failure (e.g., another socket
  // with the same name is  already listening) the returned socket will have
  // is_listening() == false and last_error() will contain the failure reason.
  static std::unique_ptr<UnixSocket> Listen(const std::string& socket_name,
                                            EventListener*,
                                            TaskRunner*,
                                            SockType = SockType::kStream);

  // Attaches to a pre-existing socket. The socket must have been created in
  // SOCK_STREAM mode and the caller must have called bind() on it.
  static std::unique_ptr<UnixSocket> Listen(ScopedFile,
                                            EventListener*,
                                            TaskRunner*,
                                            SockType = SockType::kStream);

  // Creates a Unix domain socket and connects to the listening endpoint.
  // Returns always an instance. EventListener::OnConnect(bool success) will
  // be called always, whether the connection succeeded or not.
  static std::unique_ptr<UnixSocket> Connect(const std::string& socket_name,
                                             EventListener*,
                                             TaskRunner*,
                                             SockType = SockType::kStream);

  // Constructs a UnixSocket using the given connected socket.
  static std::unique_ptr<UnixSocket> AdoptConnected(
      ScopedFile fd,
      EventListener* event_listener,
      TaskRunner* task_runner,
      SockType sock_type);

  UnixSocket(const UnixSocket&) = delete;
  UnixSocket& operator=(const UnixSocket&) = delete;
  // Cannot be easily moved because of tasks from the FileDescriptorWatch.
  UnixSocket(UnixSocket&&) = delete;
  UnixSocket& operator=(UnixSocket&&) = delete;

  // This class gives the hard guarantee that no callback is called on the
  // passed EventListener immediately after the object has been destroyed.
  // Any queued callback will be silently dropped.
  ~UnixSocket();

  // Shuts down the current connection, if any. If the socket was Listen()-ing,
  // stops listening. The socket goes back to kNotInitialized state, so it can
  // be reused with Listen() or Connect().
  void Shutdown(bool notify);

  // Returns true is the message was queued, false if there was no space in the
  // output buffer, in which case the client should retry or give up.
  // If any other error happens the socket will be shutdown and
  // EventListener::OnDisconnect() will be called.
  // If the socket is not connected, Send() will just return false.
  // Does not append a null string terminator to msg in any case.
  //
  // DO NOT PASS kNonBlocking, it is broken.
  bool Send(const void* msg,
            size_t len,
            const int* send_fds,
            size_t num_fds,
            BlockingMode blocking = BlockingMode::kNonBlocking);

  inline bool Send(const void* msg,
                   size_t len,
                   int send_fd = -1,
                   BlockingMode blocking = BlockingMode::kNonBlocking) {
    if (send_fd != -1)
      return Send(msg, len, &send_fd, 1, blocking);
    return Send(msg, len, nullptr, 0, blocking);
  }

  inline bool Send(const std::string& msg,
                   BlockingMode blocking = BlockingMode::kNonBlocking) {
    return Send(msg.c_str(), msg.size() + 1, -1, blocking);
  }

  // Returns the number of bytes (<= |len|) written in |msg| or 0 if there
  // is no data in the buffer to read or an error occurs (in which case a
  // EventListener::OnDisconnect() will follow).
  // If the ScopedFile pointer is not null and a FD is received, it moves the
  // received FD into that. If a FD is received but the ScopedFile pointer is
  // null, the FD will be automatically closed.
  size_t Receive(void* msg, size_t len, ScopedFile*, size_t max_files = 1);

  inline size_t Receive(void* msg, size_t len) {
    return Receive(msg, len, nullptr, 0);
  }

  // Only for tests. This is slower than Receive() as it requires a heap
  // allocation and a copy for the std::string. Guarantees that the returned
  // string is null terminated even if the underlying message sent by the peer
  // is not.
  std::string ReceiveString(size_t max_length = 1024);

  bool is_connected() const { return state_ == State::kConnected; }
  bool is_listening() const { return state_ == State::kListening; }
  int fd() const { return sock_raw_.fd(); }
  int last_error() const { return last_error_; }

  // User ID of the peer, as returned by the kernel. If the client disconnects
  // and the socket goes into the kDisconnected state, it retains the uid of
  // the last peer.
  uid_t peer_uid() const {
    PERFETTO_DCHECK(!is_listening() && peer_uid_ != kInvalidUid);
    return peer_uid_;
  }

#if PERFETTO_BUILDFLAG(PERFETTO_OS_LINUX) || \
    PERFETTO_BUILDFLAG(PERFETTO_OS_ANDROID)
  // Process ID of the peer, as returned by the kernel. If the client
  // disconnects and the socket goes into the kDisconnected state, it
  // retains the pid of the last peer.
  //
  // This is only available on Linux / Android.
  pid_t peer_pid() const {
    PERFETTO_DCHECK(!is_listening() && peer_pid_ != kInvalidPid);
    return peer_pid_;
  }
#endif

  // This makes the UnixSocket unusable.
  UnixSocketRaw ReleaseSocket();

 private:
  UnixSocket(EventListener*, TaskRunner*, SockType);
  UnixSocket(EventListener*, TaskRunner*, ScopedFile, State, SockType);

  // Called once by the corresponding public static factory methods.
  void DoConnect(const std::string& socket_name);
  void ReadPeerCredentials();

  void OnEvent();
  void NotifyConnectionState(bool success);

  UnixSocketRaw sock_raw_;
  State state_ = State::kDisconnected;
  int last_error_ = 0;
  uid_t peer_uid_ = kInvalidUid;
#if PERFETTO_BUILDFLAG(PERFETTO_OS_LINUX) || \
    PERFETTO_BUILDFLAG(PERFETTO_OS_ANDROID)
  pid_t peer_pid_ = kInvalidPid;
#endif
  EventListener* const event_listener_;
  TaskRunner* const task_runner_;
  WeakPtrFactory<UnixSocket> weak_ptr_factory_;  // Keep last.
};

}  // namespace base
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_BASE_UNIX_SOCKET_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "perfetto/ext/base/unix_socket.h"

#include <errno.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/un.h>
#include <unistd.h>

#include <algorithm>
#include <memory>

// gen_amalgamated expanded: #include "perfetto/base/build_config.h"
// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/base/task_runner.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/utils.h"

#if PERFETTO_BUILDFLAG(PERFETTO_OS_MACOSX)
#include <sys/ucred.h>
#endif

namespace perfetto {
namespace base {

// The CMSG_* macros use NULL instead of nullptr.
#pragma GCC diagnostic push
#if !PERFETTO_BUILDFLAG(PERFETTO_OS_MACOSX)
#pragma GCC diagnostic ignored "-Wzero-as-null-pointer-constant"
#endif

namespace {
// MSG_NOSIGNAL is not supported on Mac OS X, but in that case the socket is
// created with SO_NOSIGPIPE (See InitializeSocket()).
#if PERFETTO_BUILDFLAG(PERFETTO_OS_MACOSX)
constexpr int kNoSigPipe = 0;
#else
constexpr int kNoSigPipe = MSG_NOSIGNAL;
#endif

// Android takes an int instead of socklen_t for the control buffer size.
#if PERFETTO_BUILDFLAG(PERFETTO_OS_ANDROID)
using CBufLenType = size_t;
#else
using CBufLenType = socklen_t;
#endif

inline int GetUnixSockType(SockType type) {
  switch (type) {
    case SockType::kStream:
      return SOCK_STREAM;
    case SockType::kDgram:
      return SOCK_DGRAM;
    case SockType::kSeqPacket:
      return SOCK_SEQPACKET;
  }
  PERFETTO_CHECK(false);
}

bool MakeSockAddr(const std::string& socket_name,
                  sockaddr_un* addr,
                  socklen_t* addr_size) {
  memset(addr, 0, sizeof(*addr));
  const size_t name_len = socket_name.size();
  if (name_len >= sizeof(addr->sun_path)) {
    errno = ENAMETOOLONG;
    return false;
  }
  memcpy(addr->sun_path, socket_name.data(), name_len);
  if (addr->sun_path[0] == '@')
    addr->sun_path[0] = '\0';
  addr->sun_family = AF_UNIX;
  *addr_size = static_cast<socklen_t>(
      __builtin_offsetof(sockaddr_un, sun_path) + name_len + 1);
  return true;
}

}  // namespace

// +-----------------------+
// | UnixSocketRaw methods |
// +-----------------------+

// static
void UnixSocketRaw::ShiftMsgHdr(size_t n, struct msghdr* msg) {
  using LenType = decltype(msg->msg_iovlen);  // Mac and Linux don't agree.
  for (LenType i = 0; i < msg->msg_iovlen; ++i) {
    struct iovec* vec = &msg->msg_iov[i];
    if (n < vec->iov_len) {
      // We sent a part of this iovec.
      vec->iov_base = reinterpret_cast<char*>(vec->iov_base) + n;
      vec->iov_len -= n;
      msg->msg_iov = vec;
      msg->msg_iovlen -= i;
      return;
    }
    // We sent the whole iovec.
    n -= vec->iov_len;
  }
  // We sent all the iovecs.
  PERFETTO_CHECK(n == 0);
  msg->msg_iovlen = 0;
  msg->msg_iov = nullptr;
}

// static
std::pair<UnixSocketRaw, UnixSocketRaw> UnixSocketRaw::CreatePair(SockType t) {
  int fds[2];
  if (socketpair(AF_UNIX, GetUnixSockType(t), 0, fds) != 0)
    return std::make_pair(UnixSocketRaw(), UnixSocketRaw());

  return std::make_pair(UnixSocketRaw(ScopedFile(fds[0]), t),
                        UnixSocketRaw(ScopedFile(fds[1]), t));
}

UnixSocketRaw::UnixSocketRaw() = default;

UnixSocketRaw::UnixSocketRaw(SockType type)
    : UnixSocketRaw(ScopedFile(socket(AF_UNIX, GetUnixSockType(type), 0)),
                    type) {}

UnixSocketRaw::UnixSocketRaw(ScopedFile fd, SockType type)
    : fd_(std::move(fd)), type_(type) {
  PERFETTO_CHECK(fd_);
#if PERFETTO_BUILDFLAG(PERFETTO_OS_MACOSX)
  const int no_sigpipe = 1;
  setsockopt(*fd_, SOL_SOCKET, SO_NOSIGPIPE, &no_sigpipe, sizeof(no_sigpipe));
#endif

  // There is no reason why a socket should outlive the process in case of
  // exec() by default, this is just working around a broken unix design.
  int fcntl_res = fcntl(*fd_, F_SETFD, FD_CLOEXEC);
  PERFETTO_CHECK(fcntl_res == 0);
}

void UnixSocketRaw::SetBlocking(bool is_blocking) {
  PERFETTO_DCHECK(fd_);
  int flags = fcntl(*fd_, F_GETFL, 0);
  if (!is_blocking) {
    flags |= O_NONBLOCK;
  } else {
    flags &= ~static_cast<int>(O_NONBLOCK);
  }
  bool fcntl_res = fcntl(*fd_, F_SETFL, flags);
  PERFETTO_CHECK(fcntl_res == 0);
}

void UnixSocketRaw::RetainOnExec() {
  PERFETTO_DCHECK(fd_);
  int flags = fcntl(*fd_, F_GETFD, 0);
  flags &= ~static_cast<int>(FD_CLOEXEC);
  bool fcntl_res = fcntl(*fd_, F_SETFD, flags);
  PERFETTO_CHECK(fcntl_res == 0);
}

bool UnixSocketRaw::IsBlocking() const {
  PERFETTO_DCHECK(fd_);
  return (fcntl(*fd_, F_GETFL, 0) & O_NONBLOCK) == 0;
}

bool UnixSocketRaw::Bind(const std::string& socket_name) {
  PERFETTO_DCHECK(fd_);
  sockaddr_un addr;
  socklen_t addr_size;
  if (!MakeSockAddr(socket_name, &addr, &addr_size))
    return false;

  if (bind(*fd_, reinterpret_cast<sockaddr*>(&addr), addr_size)) {
    PERFETTO_DPLOG("bind(%s)", socket_name.c_str());
    return false;
  }

  return true;
}

bool UnixSocketRaw::Listen() {
  PERFETTO_DCHECK(fd_);
  PERFETTO_DCHECK(type_ == SockType::kStream || type_ == SockType::kSeqPacket);
  return listen(*fd_, SOMAXCONN) == 0;
}

bool UnixSocketRaw::Connect(const std::string& socket_name) {
  PERFETTO_DCHECK(fd_);
  sockaddr_un addr;
  socklen_t addr_size;
  if (!MakeSockAddr(socket_name, &addr, &addr_size))
    return false;

  int res = PERFETTO_EINTR(
      connect(*fd_, reinterpret_cast<sockaddr*>(&addr), addr_size));
  if (res && errno != EINPROGRESS)
    return false;

  return true;
}

void UnixSocketRaw::Shutdown() {
  shutdown(*fd_, SHUT_RDWR);
  fd_.reset();
}

// For the interested reader, Linux kernel dive to verify this is not only a
// theoretical possibility: sock_stream_sendmsg, if sock_alloc_send_pskb returns
// NULL [1] (which it does when it gets interrupted [2]), returns early with the
// amount of bytes already sent.
//
// [1]:
// https://elixir.bootlin.com/linux/v4.18.10/source/net/unix/af_unix.c#L1872
// [2]: https://elixir.bootlin.com/linux/v4.18.10/source/net/core/sock.c#L2101
ssize_t UnixSocketRaw::SendMsgAll(struct msghdr* msg) {
  // This does not make sense on non-blocking sockets.
  PERFETTO_DCHECK(fd_);

  ssize_t total_sent = 0;
  while (msg->msg_iov) {
    ssize_t sent = PERFETTO_EINTR(sendmsg(*fd_, msg, kNoSigPipe));
    if (sent <= 0) {
      if (sent == -1 && IsAgain(errno))
        return total_sent;
      return sent;
    }
    total_sent += sent;
    ShiftMsgHdr(static_cast<size_t>(sent), msg);
    // Only send the ancillary data with the first sendmsg call.
    msg->msg_control = nullptr;
    msg->msg_controllen = 0;
  }
  return total_sent;
}

ssize_t UnixSocketRaw::Send(const void* msg,
                            size_t len,
                            const int* send_fds,
                            size_t num_fds) {
  PERFETTO_DCHECK(fd_);
  msghdr msg_hdr = {};
  iovec iov = {const_cast<void*>(msg), len};
  msg_hdr.msg_iov = &iov;
  msg_hdr.msg_iovlen = 1;
  alignas(cmsghdr) char control_buf[256];

  if (num_fds > 0) {
    const auto raw_ctl_data_sz = num_fds * sizeof(int);
    const CBufLenType control_buf_len =
        static_cast<CBufLenType>(CMSG_SPACE(raw_ctl_data_sz));
    PERFETTO_CHECK(control_buf_len <= sizeof(control_buf));
    memset(control_buf, 0, sizeof(control_buf));
    msg_hdr.msg_control = control_buf;
    msg_hdr.msg_controllen = control_buf_len;  // used by CMSG_FIRSTHDR
    struct cmsghdr* cmsg = CMSG_FIRSTHDR(&msg_hdr);
    cmsg->cmsg_level = SOL_SOCKET;
    cmsg->cmsg_type = SCM_RIGHTS;
    cmsg->cmsg_len = static_cast<CBufLenType>(CMSG_LEN(raw_ctl_data_sz));
    memcpy(CMSG_DATA(cmsg), send_fds, num_fds * sizeof(int));
    // note: if we were to send multiple cmsghdr structures, then
    // msg_hdr.msg_controllen would need to be adjusted, see "man 3 cmsg".
  }

  return SendMsgAll(&msg_hdr);
}

ssize_t UnixSocketRaw::Receive(void* msg,
                               size_t len,
                               ScopedFile* fd_vec,
                               size_t max_files) {
  PERFETTO_DCHECK(fd_);
  msghdr msg_hdr = {};
  iovec iov = {msg, len};
  msg_hdr.msg_iov = &iov;
  msg_hdr.msg_iovlen = 1;
  alignas(cmsghdr) char control_buf[256];

  if (max_files > 0) {
    msg_hdr.msg_control = control_buf;
    msg_hdr.msg_controllen =
        static_cast<CBufLenType>(CMSG_SPACE(max_files * sizeof(int)));
    PERFETTO_CHECK(msg_hdr.msg_controllen <= sizeof(control_buf));
  }
  const ssize_t sz = PERFETTO_EINTR(recvmsg(*fd_, &msg_hdr, 0));
  if (sz <= 0) {
    return sz;
  }
  PERFETTO_CHECK(static_cast<size_t>(sz) <= len);

  int* fds = nullptr;
  uint32_t fds_len = 0;

  if (max_files > 0) {
    for (cmsghdr* cmsg = CMSG_FIRSTHDR(&msg_hdr); cmsg;
         cmsg = CMSG_NXTHDR(&msg_hdr, cmsg)) {
      const size_t payload_len = cmsg->cmsg_len - CMSG_LEN(0);
      if (cmsg->cmsg_level == SOL_SOCKET && cmsg->cmsg_type == SCM_RIGHTS) {
        PERFETTO_DCHECK(payload_len % sizeof(int) == 0u);
        PERFETTO_CHECK(fds == nullptr);
        fds = reinterpret_cast<int*>(CMSG_DATA(cmsg));
        fds_len = static_cast<uint32_t>(payload_len / sizeof(int));
      }
    }
  }

  if (msg_hdr.msg_flags & MSG_TRUNC || msg_hdr.msg_flags & MSG_CTRUNC) {
    for (size_t i = 0; fds && i < fds_len; ++i)
      close(fds[i]);
    errno = EMSGSIZE;
    return -1;
  }

  for (size_t i = 0; fds && i < fds_len; ++i) {
    if (i < max_files)
      fd_vec[i].reset(fds[i]);
    else
      close(fds[i]);
  }

  return sz;
}

bool UnixSocketRaw::SetTxTimeout(uint32_t timeout_ms) {
  PERFETTO_DCHECK(fd_);
  struct timeval timeout {};
  uint32_t timeout_sec = timeout_ms / 1000;
  timeout.tv_sec = static_cast<decltype(timeout.tv_sec)>(timeout_sec);
  timeout.tv_usec = static_cast<decltype(timeout.tv_usec)>(
      (timeout_ms - (timeout_sec * 1000)) * 1000);

  return setsockopt(*fd_, SOL_SOCKET, SO_SNDTIMEO,
                    reinterpret_cast<const char*>(&timeout),
                    sizeof(timeout)) == 0;
}

bool UnixSocketRaw::SetRxTimeout(uint32_t timeout_ms) {
  PERFETTO_DCHECK(fd_);
  struct timeval timeout {};
  uint32_t timeout_sec = timeout_ms / 1000;
  timeout.tv_sec = static_cast<decltype(timeout.tv_sec)>(timeout_sec);
  timeout.tv_usec = static_cast<decltype(timeout.tv_usec)>(
      (timeout_ms - (timeout_sec * 1000)) * 1000);

  return setsockopt(*fd_, SOL_SOCKET, SO_RCVTIMEO,
                    reinterpret_cast<const char*>(&timeout),
                    sizeof(timeout)) == 0;
}

#pragma GCC diagnostic pop

// +--------------------+
// | UnixSocket methods |
// +--------------------+

// TODO(primiano): Add ThreadChecker to methods of this class.

// static
std::unique_ptr<UnixSocket> UnixSocket::Listen(const std::string& socket_name,
                                               EventListener* event_listener,
                                               TaskRunner* task_runner,
                                               SockType sock_type) {
  auto sock_raw = UnixSocketRaw::CreateMayFail(sock_type);
  if (!sock_raw || !sock_raw.Bind(socket_name))
    return nullptr;

  // Forward the call to the Listen() overload below.
  return Listen(sock_raw.ReleaseFd(), event_listener, task_runner, sock_type);
}

// static
std::unique_ptr<UnixSocket> UnixSocket::Listen(ScopedFile fd,
                                               EventListener* event_listener,
                                               TaskRunner* task_runner,
                                               SockType sock_type) {
  return std::unique_ptr<UnixSocket>(
      new UnixSocket(event_listener, task_runner, std::move(fd),
                     State::kListening, sock_type));
}

// static
std::unique_ptr<UnixSocket> UnixSocket::Connect(const std::string& socket_name,
                                                EventListener* event_listener,
                                                TaskRunner* task_runner,
                                                SockType sock_type) {
  std::unique_ptr<UnixSocket> sock(
      new UnixSocket(event_listener, task_runner, sock_type));
  sock->DoConnect(socket_name);
  return sock;
}

// static
std::unique_ptr<UnixSocket> UnixSocket::AdoptConnected(
    ScopedFile fd,
    EventListener* event_listener,
    TaskRunner* task_runner,
    SockType sock_type) {
  return std::unique_ptr<UnixSocket>(
      new UnixSocket(event_listener, task_runner, std::move(fd),
                     State::kConnected, sock_type));
}

UnixSocket::UnixSocket(EventListener* event_listener,
                       TaskRunner* task_runner,
                       SockType sock_type)
    : UnixSocket(event_listener,
                 task_runner,
                 ScopedFile(),
                 State::kDisconnected,
                 sock_type) {}

UnixSocket::UnixSocket(EventListener* event_listener,
                       TaskRunner* task_runner,
                       ScopedFile adopt_fd,
                       State adopt_state,
                       SockType sock_type)
    : event_listener_(event_listener),
      task_runner_(task_runner),
      weak_ptr_factory_(this) {
  state_ = State::kDisconnected;
  if (adopt_state == State::kDisconnected) {
    PERFETTO_DCHECK(!adopt_fd);
    sock_raw_ = UnixSocketRaw::CreateMayFail(sock_type);
    if (!sock_raw_) {
      last_error_ = errno;
      return;
    }
  } else if (adopt_state == State::kConnected) {
    PERFETTO_DCHECK(adopt_fd);
    sock_raw_ = UnixSocketRaw(std::move(adopt_fd), sock_type);
    state_ = State::kConnected;
    ReadPeerCredentials();
  } else if (adopt_state == State::kListening) {
    // We get here from Listen().

    // |adopt_fd| might genuinely be invalid if the bind() failed.
    if (!adopt_fd) {
      last_error_ = errno;
      return;
    }

    sock_raw_ = UnixSocketRaw(std::move(adopt_fd), sock_type);
    if (!sock_raw_.Listen()) {
      last_error_ = errno;
      PERFETTO_DPLOG("listen()");
      return;
    }
    state_ = State::kListening;
  } else {
    PERFETTO_FATAL("Unexpected adopt_state");  // Unfeasible.
  }

  PERFETTO_CHECK(sock_raw_);
  last_error_ = 0;

  sock_raw_.SetBlocking(false);

  WeakPtr<UnixSocket> weak_ptr = weak_ptr_factory_.GetWeakPtr();
  task_runner_->AddFileDescriptorWatch(sock_raw_.fd(), [weak_ptr] {
    if (weak_ptr)
      weak_ptr->OnEvent();
  });
}

UnixSocket::~UnixSocket() {
  // The implicit dtor of |weak_ptr_factory_| will no-op pending callbacks.
  Shutdown(true);
}

UnixSocketRaw UnixSocket::ReleaseSocket() {
  // This will invalidate any pending calls to OnEvent.
  state_ = State::kDisconnected;
  if (sock_raw_)
    task_runner_->RemoveFileDescriptorWatch(sock_raw_.fd());

  return std::move(sock_raw_);
}

// Called only by the Connect() static constructor.
void UnixSocket::DoConnect(const std::string& socket_name) {
  PERFETTO_DCHECK(state_ == State::kDisconnected);

  // This is the only thing that can gracefully fail in the ctor.
  if (!sock_raw_)
    return NotifyConnectionState(false);

  if (!sock_raw_.Connect(socket_name)) {
    last_error_ = errno;
    return NotifyConnectionState(false);
  }

  // At this point either connect() succeeded or started asynchronously
  // (errno = EINPROGRESS).
  last_error_ = 0;
  state_ = State::kConnecting;

  // Even if the socket is non-blocking, connecting to a UNIX socket can be
  // acknowledged straight away rather than returning EINPROGRESS.
  // The decision here is to deal with the two cases uniformly, at the cost of
  // delaying the straight-away-connect() case by one task, to avoid depending
  // on implementation details of UNIX socket on the various OSes.
  // Posting the OnEvent() below emulates a wakeup of the FD watch. OnEvent(),
  // which knows how to deal with spurious wakeups, will poll the SO_ERROR and
  // evolve, if necessary, the state into either kConnected or kDisconnected.
  WeakPtr<UnixSocket> weak_ptr = weak_ptr_factory_.GetWeakPtr();
  task_runner_->PostTask([weak_ptr] {
    if (weak_ptr)
      weak_ptr->OnEvent();
  });
}

void UnixSocket::ReadPeerCredentials() {
#if PERFETTO_BUILDFLAG(PERFETTO_OS_LINUX) || \
    PERFETTO_BUILDFLAG(PERFETTO_OS_ANDROID)
  struct ucred user_cred;
  socklen_t len = sizeof(user_cred);
  int fd = sock_raw_.fd();
  int res = getsockopt(fd, SOL_SOCKET, SO_PEERCRED, &user_cred, &len);
  PERFETTO_CHECK(res == 0);
  peer_uid_ = user_cred.uid;
  peer_pid_ = user_cred.pid;
#else
  struct xucred user_cred;
  socklen_t len = sizeof(user_cred);
  int res = getsockopt(sock_raw_.fd(), 0, LOCAL_PEERCRED, &user_cred, &len);
  PERFETTO_CHECK(res == 0 && user_cred.cr_version == XUCRED_VERSION);
  peer_uid_ = static_cast<uid_t>(user_cred.cr_uid);
// There is no pid in the LOCAL_PEERCREDS for MacOS / FreeBSD.
#endif
}

void UnixSocket::OnEvent() {
  if (state_ == State::kDisconnected)
    return;  // Some spurious event, typically queued just before Shutdown().

  if (state_ == State::kConnected)
    return event_listener_->OnDataAvailable(this);

  if (state_ == State::kConnecting) {
    PERFETTO_DCHECK(sock_raw_);
    int sock_err = EINVAL;
    socklen_t err_len = sizeof(sock_err);
    int res =
        getsockopt(sock_raw_.fd(), SOL_SOCKET, SO_ERROR, &sock_err, &err_len);
    if (res == 0 && sock_err == EINPROGRESS)
      return;  // Not connected yet, just a spurious FD watch wakeup.
    if (res == 0 && sock_err == 0) {
      ReadPeerCredentials();
      state_ = State::kConnected;
      return event_listener_->OnConnect(this, true /* connected */);
    }
    last_error_ = sock_err;
    Shutdown(false);
    return event_listener_->OnConnect(this, false /* connected */);
  }

  // New incoming connection.
  if (state_ == State::kListening) {
    // There could be more than one incoming connection behind each FD watch
    // notification. Drain'em all.
    for (;;) {
      sockaddr_un cli_addr = {};
      socklen_t size = sizeof(cli_addr);
      ScopedFile new_fd(PERFETTO_EINTR(accept(
          sock_raw_.fd(), reinterpret_cast<sockaddr*>(&cli_addr), &size)));
      if (!new_fd)
        return;
      std::unique_ptr<UnixSocket> new_sock(
          new UnixSocket(event_listener_, task_runner_, std::move(new_fd),
                         State::kConnected, sock_raw_.type()));
      event_listener_->OnNewIncomingConnection(this, std::move(new_sock));
    }
  }
}

bool UnixSocket::Send(const void* msg,
                      size_t len,
                      const int* send_fds,
                      size_t num_fds,
                      BlockingMode blocking_mode) {
  // TODO(b/117139237): Non-blocking sends are broken because we do not
  // properly handle partial sends.
  PERFETTO_DCHECK(blocking_mode == BlockingMode::kBlocking);

  if (state_ != State::kConnected) {
    errno = last_error_ = ENOTCONN;
    return false;
  }

  if (blocking_mode == BlockingMode::kBlocking)
    sock_raw_.SetBlocking(true);
  const ssize_t sz = sock_raw_.Send(msg, len, send_fds, num_fds);
  int saved_errno = errno;
  if (blocking_mode == BlockingMode::kBlocking)
    sock_raw_.SetBlocking(false);

  if (sz == static_cast<ssize_t>(len)) {
    last_error_ = 0;
    return true;
  }

  // If sendmsg() succeds but the returned size is < |len| it means that the
  // endpoint disconnected in the middle of the read, and we managed to send
  // only a portion of the buffer. In this case we should just give up.

  if (sz < 0 && (saved_errno == EAGAIN || saved_errno == EWOULDBLOCK)) {
    // A genuine out-of-buffer. The client should retry or give up.
    // Man pages specify that EAGAIN and EWOULDBLOCK have the same semantic here
    // and clients should check for both.
    last_error_ = EAGAIN;
    return false;
  }

  // Either the other endpoint disconnected (ECONNRESET) or some other error
  // happened.
  last_error_ = saved_errno;
  PERFETTO_DPLOG("sendmsg() failed");
  Shutdown(true);
  return false;
}

void UnixSocket::Shutdown(bool notify) {
  WeakPtr<UnixSocket> weak_ptr = weak_ptr_factory_.GetWeakPtr();
  if (notify) {
    if (state_ == State::kConnected) {
      task_runner_->PostTask([weak_ptr] {
        if (weak_ptr)
          weak_ptr->event_listener_->OnDisconnect(weak_ptr.get());
      });
    } else if (state_ == State::kConnecting) {
      task_runner_->PostTask([weak_ptr] {
        if (weak_ptr)
          weak_ptr->event_listener_->OnConnect(weak_ptr.get(), false);
      });
    }
  }

  if (sock_raw_) {
    task_runner_->RemoveFileDescriptorWatch(sock_raw_.fd());
    sock_raw_.Shutdown();
  }
  state_ = State::kDisconnected;
}

size_t UnixSocket::Receive(void* msg,
                           size_t len,
                           ScopedFile* fd_vec,
                           size_t max_files) {
  if (state_ != State::kConnected) {
    last_error_ = ENOTCONN;
    return 0;
  }

  const ssize_t sz = sock_raw_.Receive(msg, len, fd_vec, max_files);
  if (sz < 0 && (errno == EAGAIN || errno == EWOULDBLOCK)) {
    last_error_ = EAGAIN;
    return 0;
  }
  if (sz <= 0) {
    last_error_ = errno;
    Shutdown(true);
    return 0;
  }
  PERFETTO_CHECK(static_cast<size_t>(sz) <= len);
  return static_cast<size_t>(sz);
}

std::string UnixSocket::ReceiveString(size_t max_length) {
  std::unique_ptr<char[]> buf(new char[max_length + 1]);
  size_t rsize = Receive(buf.get(), max_length);
  PERFETTO_CHECK(static_cast<size_t>(rsize) <= max_length);
  buf[static_cast<size_t>(rsize)] = '\0';
  return std::string(buf.get());
}

void UnixSocket::NotifyConnectionState(bool success) {
  if (!success)
    Shutdown(false);

  WeakPtr<UnixSocket> weak_ptr = weak_ptr_factory_.GetWeakPtr();
  task_runner_->PostTask([weak_ptr, success] {
    if (weak_ptr)
      weak_ptr->event_listener_->OnConnect(weak_ptr.get(), success);
  });
}

UnixSocket::EventListener::~EventListener() {}
void UnixSocket::EventListener::OnNewIncomingConnection(
    UnixSocket*,
    std::unique_ptr<UnixSocket>) {}
void UnixSocket::EventListener::OnConnect(UnixSocket*, bool) {}
void UnixSocket::EventListener::OnDisconnect(UnixSocket*) {}
void UnixSocket::EventListener::OnDataAvailable(UnixSocket*) {}

}  // namespace base
}  // namespace perfetto
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/src/ipc/wire_protocol.pb.cc
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/src/ipc/wire_protocol.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: src/ipc/wire_protocol.proto

#ifndef PROTOBUF_src_2fipc_2fwire_5fprotocol_2eproto__INCLUDED
#define PROTOBUF_src_2fipc_2fwire_5fprotocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace ipc {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_src_2fipc_2fwire_5fprotocol_2eproto();
void protobuf_AssignDesc_src_2fipc_2fwire_5fprotocol_2eproto();
void protobuf_ShutdownFile_src_2fipc_2fwire_5fprotocol_2eproto();

class Frame;
class Frame_BindService;
class Frame_BindServiceReply;
class Frame_BindServiceReply_MethodInfo;
class Frame_InvokeMethod;
class Frame_InvokeMethodReply;
class Frame_RequestError;

// ===================================================================

class Frame_BindService : public ::google::protobuf::MessageLite {
 public:
  Frame_BindService();
  virtual ~Frame_BindService();

  Frame_BindService(const Frame_BindService& from);

  inline Frame_BindService& operator=(const Frame_BindService& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Frame_BindService& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Frame_BindService* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Frame_BindService* other);

  // implements Message ----------------------------------------------

  inline Frame_BindService* New() const { return New(NULL); }

  Frame_BindService* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Frame_BindService& from);
  void MergeFrom(const Frame_BindService& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Frame_BindService* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string service_name = 1;
  bool has_service_name() const;
  void clear_service_name();
  static const int kServiceNameFieldNumber = 1;
  const ::std::string& service_name() const;
  void set_service_name(const ::std::string& value);
  void set_service_name(const char* value);
  void set_service_name(const char* value, size_t size);
  ::std::string* mutable_service_name();
  ::std::string* release_service_name();
  void set_allocated_service_name(::std::string* service_name);

  // @@protoc_insertion_point(class_scope:perfetto.ipc.Frame.BindService)
 private:
  inline void set_has_service_name();
  inline void clear_has_service_name();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr service_name_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_src_2fipc_2fwire_5fprotocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_src_2fipc_2fwire_5fprotocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_src_2fipc_2fwire_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_src_2fipc_2fwire_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static Frame_BindService* default_instance_;
};
// -------------------------------------------------------------------

class Frame_BindServiceReply_MethodInfo : public ::google::protobuf::MessageLite {
 public:
  Frame_BindServiceReply_MethodInfo();
  virtual ~Frame_BindServiceReply_MethodInfo();

  Frame_BindServiceReply_MethodInfo(const Frame_BindServiceReply_MethodInfo& from);

  inline Frame_BindServiceReply_MethodInfo& operator=(const Frame_BindServiceReply_MethodInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Frame_BindServiceReply_MethodInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Frame_BindServiceReply_MethodInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Frame_BindServiceReply_MethodInfo* other);

  // implements Message ----------------------------------------------

  inline Frame_BindServiceReply_MethodInfo* New() const { return New(NULL); }

  Frame_BindServiceReply_MethodInfo* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Frame_BindServiceReply_MethodInfo& from);
  void MergeFrom(const Frame_BindServiceReply_MethodInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Frame_BindServiceReply_MethodInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:perfetto.ipc.Frame.BindServiceReply.MethodInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint32 id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_src_2fipc_2fwire_5fprotocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_src_2fipc_2fwire_5fprotocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_src_2fipc_2fwire_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_src_2fipc_2fwire_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static Frame_BindServiceReply_MethodInfo* default_instance_;
};
// -------------------------------------------------------------------

class Frame_BindServiceReply : public ::google::protobuf::MessageLite {
 public:
  Frame_BindServiceReply();
  virtual ~Frame_BindServiceReply();

  Frame_BindServiceReply(const Frame_BindServiceReply& from);

  inline Frame_BindServiceReply& operator=(const Frame_BindServiceReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Frame_BindServiceReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Frame_BindServiceReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Frame_BindServiceReply* other);

  // implements Message ----------------------------------------------

  inline Frame_BindServiceReply* New() const { return New(NULL); }

  Frame_BindServiceReply* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Frame_BindServiceReply& from);
  void MergeFrom(const Frame_BindServiceReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Frame_BindServiceReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Frame_BindServiceReply_MethodInfo MethodInfo;

  // accessors -------------------------------------------------------

  // optional bool success = 1;
  bool has_success() const;
  void clear_success();
  static const int kSuccessFieldNumber = 1;
  bool success() const;
  void set_success(bool value);

  // optional uint32 service_id = 2;
  bool has_service_id() const;
  void clear_service_id();
  static const int kServiceIdFieldNumber = 2;
  ::google::protobuf::uint32 service_id() const;
  void set_service_id(::google::protobuf::uint32 value);

  // repeated .perfetto.ipc.Frame.BindServiceReply.MethodInfo methods = 3;
  int methods_size() const;
  void clear_methods();
  static const int kMethodsFieldNumber = 3;
  const ::perfetto::ipc::Frame_BindServiceReply_MethodInfo& methods(int index) const;
  ::perfetto::ipc::Frame_BindServiceReply_MethodInfo* mutable_methods(int index);
  ::perfetto::ipc::Frame_BindServiceReply_MethodInfo* add_methods();
  ::google::protobuf::RepeatedPtrField< ::perfetto::ipc::Frame_BindServiceReply_MethodInfo >*
      mutable_methods();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::ipc::Frame_BindServiceReply_MethodInfo >&
      methods() const;

  // @@protoc_insertion_point(class_scope:perfetto.ipc.Frame.BindServiceReply)
 private:
  inline void set_has_success();
  inline void clear_has_success();
  inline void set_has_service_id();
  inline void clear_has_service_id();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool success_;
  ::google::protobuf::uint32 service_id_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::ipc::Frame_BindServiceReply_MethodInfo > methods_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_src_2fipc_2fwire_5fprotocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_src_2fipc_2fwire_5fprotocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_src_2fipc_2fwire_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_src_2fipc_2fwire_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static Frame_BindServiceReply* default_instance_;
};
// -------------------------------------------------------------------

class Frame_InvokeMethod : public ::google::protobuf::MessageLite {
 public:
  Frame_InvokeMethod();
  virtual ~Frame_InvokeMethod();

  Frame_InvokeMethod(const Frame_InvokeMethod& from);

  inline Frame_InvokeMethod& operator=(const Frame_InvokeMethod& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Frame_InvokeMethod& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Frame_InvokeMethod* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Frame_InvokeMethod* other);

  // implements Message ----------------------------------------------

  inline Frame_InvokeMethod* New() const { return New(NULL); }

  Frame_InvokeMethod* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Frame_InvokeMethod& from);
  void MergeFrom(const Frame_InvokeMethod& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Frame_InvokeMethod* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 service_id = 1;
  bool has_service_id() const;
  void clear_service_id();
  static const int kServiceIdFieldNumber = 1;
  ::google::protobuf::uint32 service_id() const;
  void set_service_id(::google::protobuf::uint32 value);

  // optional uint32 method_id = 2;
  bool has_method_id() const;
  void clear_method_id();
  static const int kMethodIdFieldNumber = 2;
  ::google::protobuf::uint32 method_id() const;
  void set_method_id(::google::protobuf::uint32 value);

  // optional bytes args_proto = 3;
  bool has_args_proto() const;
  void clear_args_proto();
  static const int kArgsProtoFieldNumber = 3;
  const ::std::string& args_proto() const;
  void set_args_proto(const ::std::string& value);
  void set_args_proto(const char* value);
  void set_args_proto(const void* value, size_t size);
  ::std::string* mutable_args_proto();
  ::std::string* release_args_proto();
  void set_allocated_args_proto(::std::string* args_proto);

  // optional bool drop_reply = 4;
  bool has_drop_reply() const;
  void clear_drop_reply();
  static const int kDropReplyFieldNumber = 4;
  bool drop_reply() const;
  void set_drop_reply(bool value);

  // @@protoc_insertion_point(class_scope:perfetto.ipc.Frame.InvokeMethod)
 private:
  inline void set_has_service_id();
  inline void clear_has_service_id();
  inline void set_has_method_id();
  inline void clear_has_method_id();
  inline void set_has_args_proto();
  inline void clear_has_args_proto();
  inline void set_has_drop_reply();
  inline void clear_has_drop_reply();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 service_id_;
  ::google::protobuf::uint32 method_id_;
  ::google::protobuf::internal::ArenaStringPtr args_proto_;
  bool drop_reply_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_src_2fipc_2fwire_5fprotocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_src_2fipc_2fwire_5fprotocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_src_2fipc_2fwire_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_src_2fipc_2fwire_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static Frame_InvokeMethod* default_instance_;
};
// -------------------------------------------------------------------

class Frame_InvokeMethodReply : public ::google::protobuf::MessageLite {
 public:
  Frame_InvokeMethodReply();
  virtual ~Frame_InvokeMethodReply();

  Frame_InvokeMethodReply(const Frame_InvokeMethodReply& from);

  inline Frame_InvokeMethodReply& operator=(const Frame_InvokeMethodReply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Frame_InvokeMethodReply& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Frame_InvokeMethodReply* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Frame_InvokeMethodReply* other);

  // implements Message ----------------------------------------------

  inline Frame_InvokeMethodReply* New() const { return New(NULL); }

  Frame_InvokeMethodReply* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Frame_InvokeMethodReply& from);
  void MergeFrom(const Frame_InvokeMethodReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Frame_InvokeMethodReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool success = 1;
  bool has_success() const;
  void clear_success();
  static const int kSuccessFieldNumber = 1;
  bool success() const;
  void set_success(bool value);

  // optional bool has_more = 2;
  bool has_has_more() const;
  void clear_has_more();
  static const int kHasMoreFieldNumber = 2;
  bool has_more() const;
  void set_has_more(bool value);

  // optional bytes reply_proto = 3;
  bool has_reply_proto() const;
  void clear_reply_proto();
  static const int kReplyProtoFieldNumber = 3;
  const ::std::string& reply_proto() const;
  void set_reply_proto(const ::std::string& value);
  void set_reply_proto(const char* value);
  void set_reply_proto(const void* value, size_t size);
  ::std::string* mutable_reply_proto();
  ::std::string* release_reply_proto();
  void set_allocated_reply_proto(::std::string* reply_proto);

  // @@protoc_insertion_point(class_scope:perfetto.ipc.Frame.InvokeMethodReply)
 private:
  inline void set_has_success();
  inline void clear_has_success();
  inline void set_has_has_more();
  inline void clear_has_has_more();
  inline void set_has_reply_proto();
  inline void clear_has_reply_proto();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr reply_proto_;
  bool success_;
  bool has_more_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_src_2fipc_2fwire_5fprotocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_src_2fipc_2fwire_5fprotocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_src_2fipc_2fwire_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_src_2fipc_2fwire_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static Frame_InvokeMethodReply* default_instance_;
};
// -------------------------------------------------------------------

class Frame_RequestError : public ::google::protobuf::MessageLite {
 public:
  Frame_RequestError();
  virtual ~Frame_RequestError();

  Frame_RequestError(const Frame_RequestError& from);

  inline Frame_RequestError& operator=(const Frame_RequestError& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Frame_RequestError& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Frame_RequestError* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Frame_RequestError* other);

  // implements Message ----------------------------------------------

  inline Frame_RequestError* New() const { return New(NULL); }

  Frame_RequestError* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Frame_RequestError& from);
  void MergeFrom(const Frame_RequestError& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Frame_RequestError* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string error = 1;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // @@protoc_insertion_point(class_scope:perfetto.ipc.Frame.RequestError)
 private:
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_src_2fipc_2fwire_5fprotocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_src_2fipc_2fwire_5fprotocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_src_2fipc_2fwire_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_src_2fipc_2fwire_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static Frame_RequestError* default_instance_;
};
// -------------------------------------------------------------------

class Frame : public ::google::protobuf::MessageLite {
 public:
  Frame();
  virtual ~Frame();

  Frame(const Frame& from);

  inline Frame& operator=(const Frame& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Frame& default_instance();

  enum MsgCase {
    kMsgBindService = 3,
    kMsgBindServiceReply = 4,
    kMsgInvokeMethod = 5,
    kMsgInvokeMethodReply = 6,
    kMsgRequestError = 7,
    MSG_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Frame* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Frame* other);

  // implements Message ----------------------------------------------

  inline Frame* New() const { return New(NULL); }

  Frame* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Frame& from);
  void MergeFrom(const Frame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Frame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Frame_BindService BindService;
  typedef Frame_BindServiceReply BindServiceReply;
  typedef Frame_InvokeMethod InvokeMethod;
  typedef Frame_InvokeMethodReply InvokeMethodReply;
  typedef Frame_RequestError RequestError;

  // accessors -------------------------------------------------------

  // optional uint64 request_id = 2;
  bool has_request_id() const;
  void clear_request_id();
  static const int kRequestIdFieldNumber = 2;
  ::google::protobuf::uint64 request_id() const;
  void set_request_id(::google::protobuf::uint64 value);

  // optional .perfetto.ipc.Frame.BindService msg_bind_service = 3;
  bool has_msg_bind_service() const;
  void clear_msg_bind_service();
  static const int kMsgBindServiceFieldNumber = 3;
  const ::perfetto::ipc::Frame_BindService& msg_bind_service() const;
  ::perfetto::ipc::Frame_BindService* mutable_msg_bind_service();
  ::perfetto::ipc::Frame_BindService* release_msg_bind_service();
  void set_allocated_msg_bind_service(::perfetto::ipc::Frame_BindService* msg_bind_service);

  // optional .perfetto.ipc.Frame.BindServiceReply msg_bind_service_reply = 4;
  bool has_msg_bind_service_reply() const;
  void clear_msg_bind_service_reply();
  static const int kMsgBindServiceReplyFieldNumber = 4;
  const ::perfetto::ipc::Frame_BindServiceReply& msg_bind_service_reply() const;
  ::perfetto::ipc::Frame_BindServiceReply* mutable_msg_bind_service_reply();
  ::perfetto::ipc::Frame_BindServiceReply* release_msg_bind_service_reply();
  void set_allocated_msg_bind_service_reply(::perfetto::ipc::Frame_BindServiceReply* msg_bind_service_reply);

  // optional .perfetto.ipc.Frame.InvokeMethod msg_invoke_method = 5;
  bool has_msg_invoke_method() const;
  void clear_msg_invoke_method();
  static const int kMsgInvokeMethodFieldNumber = 5;
  const ::perfetto::ipc::Frame_InvokeMethod& msg_invoke_method() const;
  ::perfetto::ipc::Frame_InvokeMethod* mutable_msg_invoke_method();
  ::perfetto::ipc::Frame_InvokeMethod* release_msg_invoke_method();
  void set_allocated_msg_invoke_method(::perfetto::ipc::Frame_InvokeMethod* msg_invoke_method);

  // optional .perfetto.ipc.Frame.InvokeMethodReply msg_invoke_method_reply = 6;
  bool has_msg_invoke_method_reply() const;
  void clear_msg_invoke_method_reply();
  static const int kMsgInvokeMethodReplyFieldNumber = 6;
  const ::perfetto::ipc::Frame_InvokeMethodReply& msg_invoke_method_reply() const;
  ::perfetto::ipc::Frame_InvokeMethodReply* mutable_msg_invoke_method_reply();
  ::perfetto::ipc::Frame_InvokeMethodReply* release_msg_invoke_method_reply();
  void set_allocated_msg_invoke_method_reply(::perfetto::ipc::Frame_InvokeMethodReply* msg_invoke_method_reply);

  // optional .perfetto.ipc.Frame.RequestError msg_request_error = 7;
  bool has_msg_request_error() const;
  void clear_msg_request_error();
  static const int kMsgRequestErrorFieldNumber = 7;
  const ::perfetto::ipc::Frame_RequestError& msg_request_error() const;
  ::perfetto::ipc::Frame_RequestError* mutable_msg_request_error();
  ::perfetto::ipc::Frame_RequestError* release_msg_request_error();
  void set_allocated_msg_request_error(::perfetto::ipc::Frame_RequestError* msg_request_error);

  // repeated bytes data_for_testing = 1;
  int data_for_testing_size() const;
  void clear_data_for_testing();
  static const int kDataForTestingFieldNumber = 1;
  const ::std::string& data_for_testing(int index) const;
  ::std::string* mutable_data_for_testing(int index);
  void set_data_for_testing(int index, const ::std::string& value);
  void set_data_for_testing(int index, const char* value);
  void set_data_for_testing(int index, const void* value, size_t size);
  ::std::string* add_data_for_testing();
  void add_data_for_testing(const ::std::string& value);
  void add_data_for_testing(const char* value);
  void add_data_for_testing(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& data_for_testing() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_data_for_testing();

  MsgCase msg_case() const;
  // @@protoc_insertion_point(class_scope:perfetto.ipc.Frame)
 private:
  inline void set_has_request_id();
  inline void clear_has_request_id();
  inline void set_has_msg_bind_service();
  inline void set_has_msg_bind_service_reply();
  inline void set_has_msg_invoke_method();
  inline void set_has_msg_invoke_method_reply();
  inline void set_has_msg_request_error();

  inline bool has_msg() const;
  void clear_msg();
  inline void clear_has_msg();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 request_id_;
  ::google::protobuf::RepeatedPtrField< ::std::string> data_for_testing_;
  union MsgUnion {
    MsgUnion() {}
    ::perfetto::ipc::Frame_BindService* msg_bind_service_;
    ::perfetto::ipc::Frame_BindServiceReply* msg_bind_service_reply_;
    ::perfetto::ipc::Frame_InvokeMethod* msg_invoke_method_;
    ::perfetto::ipc::Frame_InvokeMethodReply* msg_invoke_method_reply_;
    ::perfetto::ipc::Frame_RequestError* msg_request_error_;
  } msg_;
  ::google::protobuf::uint32 _oneof_case_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_src_2fipc_2fwire_5fprotocol_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_src_2fipc_2fwire_5fprotocol_2eproto();
  #endif
  friend void protobuf_AssignDesc_src_2fipc_2fwire_5fprotocol_2eproto();
  friend void protobuf_ShutdownFile_src_2fipc_2fwire_5fprotocol_2eproto();

  void InitAsDefaultInstance();
  static Frame* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Frame_BindService

// optional string service_name = 1;
inline bool Frame_BindService::has_service_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Frame_BindService::set_has_service_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Frame_BindService::clear_has_service_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Frame_BindService::clear_service_name() {
  service_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_service_name();
}
inline const ::std::string& Frame_BindService::service_name() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.BindService.service_name)
  return service_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Frame_BindService::set_service_name(const ::std::string& value) {
  set_has_service_name();
  service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.ipc.Frame.BindService.service_name)
}
inline void Frame_BindService::set_service_name(const char* value) {
  set_has_service_name();
  service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.ipc.Frame.BindService.service_name)
}
inline void Frame_BindService::set_service_name(const char* value, size_t size) {
  set_has_service_name();
  service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.ipc.Frame.BindService.service_name)
}
inline ::std::string* Frame_BindService::mutable_service_name() {
  set_has_service_name();
  // @@protoc_insertion_point(field_mutable:perfetto.ipc.Frame.BindService.service_name)
  return service_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Frame_BindService::release_service_name() {
  // @@protoc_insertion_point(field_release:perfetto.ipc.Frame.BindService.service_name)
  clear_has_service_name();
  return service_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Frame_BindService::set_allocated_service_name(::std::string* service_name) {
  if (service_name != NULL) {
    set_has_service_name();
  } else {
    clear_has_service_name();
  }
  service_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), service_name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.ipc.Frame.BindService.service_name)
}

// -------------------------------------------------------------------

// Frame_BindServiceReply_MethodInfo

// optional uint32 id = 1;
inline bool Frame_BindServiceReply_MethodInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Frame_BindServiceReply_MethodInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Frame_BindServiceReply_MethodInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Frame_BindServiceReply_MethodInfo::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Frame_BindServiceReply_MethodInfo::id() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.BindServiceReply.MethodInfo.id)
  return id_;
}
inline void Frame_BindServiceReply_MethodInfo::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.ipc.Frame.BindServiceReply.MethodInfo.id)
}

// optional string name = 2;
inline bool Frame_BindServiceReply_MethodInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Frame_BindServiceReply_MethodInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Frame_BindServiceReply_MethodInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Frame_BindServiceReply_MethodInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Frame_BindServiceReply_MethodInfo::name() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.BindServiceReply.MethodInfo.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Frame_BindServiceReply_MethodInfo::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.ipc.Frame.BindServiceReply.MethodInfo.name)
}
inline void Frame_BindServiceReply_MethodInfo::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.ipc.Frame.BindServiceReply.MethodInfo.name)
}
inline void Frame_BindServiceReply_MethodInfo::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.ipc.Frame.BindServiceReply.MethodInfo.name)
}
inline ::std::string* Frame_BindServiceReply_MethodInfo::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:perfetto.ipc.Frame.BindServiceReply.MethodInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Frame_BindServiceReply_MethodInfo::release_name() {
  // @@protoc_insertion_point(field_release:perfetto.ipc.Frame.BindServiceReply.MethodInfo.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Frame_BindServiceReply_MethodInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.ipc.Frame.BindServiceReply.MethodInfo.name)
}

// -------------------------------------------------------------------

// Frame_BindServiceReply

// optional bool success = 1;
inline bool Frame_BindServiceReply::has_success() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Frame_BindServiceReply::set_has_success() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Frame_BindServiceReply::clear_has_success() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Frame_BindServiceReply::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool Frame_BindServiceReply::success() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.BindServiceReply.success)
  return success_;
}
inline void Frame_BindServiceReply::set_success(bool value) {
  set_has_success();
  success_ = value;
  // @@protoc_insertion_point(field_set:perfetto.ipc.Frame.BindServiceReply.success)
}

// optional uint32 service_id = 2;
inline bool Frame_BindServiceReply::has_service_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Frame_BindServiceReply::set_has_service_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Frame_BindServiceReply::clear_has_service_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Frame_BindServiceReply::clear_service_id() {
  service_id_ = 0u;
  clear_has_service_id();
}
inline ::google::protobuf::uint32 Frame_BindServiceReply::service_id() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.BindServiceReply.service_id)
  return service_id_;
}
inline void Frame_BindServiceReply::set_service_id(::google::protobuf::uint32 value) {
  set_has_service_id();
  service_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.ipc.Frame.BindServiceReply.service_id)
}

// repeated .perfetto.ipc.Frame.BindServiceReply.MethodInfo methods = 3;
inline int Frame_BindServiceReply::methods_size() const {
  return methods_.size();
}
inline void Frame_BindServiceReply::clear_methods() {
  methods_.Clear();
}
inline const ::perfetto::ipc::Frame_BindServiceReply_MethodInfo& Frame_BindServiceReply::methods(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.BindServiceReply.methods)
  return methods_.Get(index);
}
inline ::perfetto::ipc::Frame_BindServiceReply_MethodInfo* Frame_BindServiceReply::mutable_methods(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.ipc.Frame.BindServiceReply.methods)
  return methods_.Mutable(index);
}
inline ::perfetto::ipc::Frame_BindServiceReply_MethodInfo* Frame_BindServiceReply::add_methods() {
  // @@protoc_insertion_point(field_add:perfetto.ipc.Frame.BindServiceReply.methods)
  return methods_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::ipc::Frame_BindServiceReply_MethodInfo >*
Frame_BindServiceReply::mutable_methods() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.ipc.Frame.BindServiceReply.methods)
  return &methods_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::ipc::Frame_BindServiceReply_MethodInfo >&
Frame_BindServiceReply::methods() const {
  // @@protoc_insertion_point(field_list:perfetto.ipc.Frame.BindServiceReply.methods)
  return methods_;
}

// -------------------------------------------------------------------

// Frame_InvokeMethod

// optional uint32 service_id = 1;
inline bool Frame_InvokeMethod::has_service_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Frame_InvokeMethod::set_has_service_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Frame_InvokeMethod::clear_has_service_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Frame_InvokeMethod::clear_service_id() {
  service_id_ = 0u;
  clear_has_service_id();
}
inline ::google::protobuf::uint32 Frame_InvokeMethod::service_id() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.InvokeMethod.service_id)
  return service_id_;
}
inline void Frame_InvokeMethod::set_service_id(::google::protobuf::uint32 value) {
  set_has_service_id();
  service_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.ipc.Frame.InvokeMethod.service_id)
}

// optional uint32 method_id = 2;
inline bool Frame_InvokeMethod::has_method_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Frame_InvokeMethod::set_has_method_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Frame_InvokeMethod::clear_has_method_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Frame_InvokeMethod::clear_method_id() {
  method_id_ = 0u;
  clear_has_method_id();
}
inline ::google::protobuf::uint32 Frame_InvokeMethod::method_id() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.InvokeMethod.method_id)
  return method_id_;
}
inline void Frame_InvokeMethod::set_method_id(::google::protobuf::uint32 value) {
  set_has_method_id();
  method_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.ipc.Frame.InvokeMethod.method_id)
}

// optional bytes args_proto = 3;
inline bool Frame_InvokeMethod::has_args_proto() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Frame_InvokeMethod::set_has_args_proto() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Frame_InvokeMethod::clear_has_args_proto() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Frame_InvokeMethod::clear_args_proto() {
  args_proto_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_args_proto();
}
inline const ::std::string& Frame_InvokeMethod::args_proto() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.InvokeMethod.args_proto)
  return args_proto_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Frame_InvokeMethod::set_args_proto(const ::std::string& value) {
  set_has_args_proto();
  args_proto_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.ipc.Frame.InvokeMethod.args_proto)
}
inline void Frame_InvokeMethod::set_args_proto(const char* value) {
  set_has_args_proto();
  args_proto_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.ipc.Frame.InvokeMethod.args_proto)
}
inline void Frame_InvokeMethod::set_args_proto(const void* value, size_t size) {
  set_has_args_proto();
  args_proto_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.ipc.Frame.InvokeMethod.args_proto)
}
inline ::std::string* Frame_InvokeMethod::mutable_args_proto() {
  set_has_args_proto();
  // @@protoc_insertion_point(field_mutable:perfetto.ipc.Frame.InvokeMethod.args_proto)
  return args_proto_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Frame_InvokeMethod::release_args_proto() {
  // @@protoc_insertion_point(field_release:perfetto.ipc.Frame.InvokeMethod.args_proto)
  clear_has_args_proto();
  return args_proto_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Frame_InvokeMethod::set_allocated_args_proto(::std::string* args_proto) {
  if (args_proto != NULL) {
    set_has_args_proto();
  } else {
    clear_has_args_proto();
  }
  args_proto_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), args_proto);
  // @@protoc_insertion_point(field_set_allocated:perfetto.ipc.Frame.InvokeMethod.args_proto)
}

// optional bool drop_reply = 4;
inline bool Frame_InvokeMethod::has_drop_reply() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Frame_InvokeMethod::set_has_drop_reply() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Frame_InvokeMethod::clear_has_drop_reply() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Frame_InvokeMethod::clear_drop_reply() {
  drop_reply_ = false;
  clear_has_drop_reply();
}
inline bool Frame_InvokeMethod::drop_reply() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.InvokeMethod.drop_reply)
  return drop_reply_;
}
inline void Frame_InvokeMethod::set_drop_reply(bool value) {
  set_has_drop_reply();
  drop_reply_ = value;
  // @@protoc_insertion_point(field_set:perfetto.ipc.Frame.InvokeMethod.drop_reply)
}

// -------------------------------------------------------------------

// Frame_InvokeMethodReply

// optional bool success = 1;
inline bool Frame_InvokeMethodReply::has_success() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Frame_InvokeMethodReply::set_has_success() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Frame_InvokeMethodReply::clear_has_success() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Frame_InvokeMethodReply::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool Frame_InvokeMethodReply::success() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.InvokeMethodReply.success)
  return success_;
}
inline void Frame_InvokeMethodReply::set_success(bool value) {
  set_has_success();
  success_ = value;
  // @@protoc_insertion_point(field_set:perfetto.ipc.Frame.InvokeMethodReply.success)
}

// optional bool has_more = 2;
inline bool Frame_InvokeMethodReply::has_has_more() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Frame_InvokeMethodReply::set_has_has_more() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Frame_InvokeMethodReply::clear_has_has_more() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Frame_InvokeMethodReply::clear_has_more() {
  has_more_ = false;
  clear_has_has_more();
}
inline bool Frame_InvokeMethodReply::has_more() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.InvokeMethodReply.has_more)
  return has_more_;
}
inline void Frame_InvokeMethodReply::set_has_more(bool value) {
  set_has_has_more();
  has_more_ = value;
  // @@protoc_insertion_point(field_set:perfetto.ipc.Frame.InvokeMethodReply.has_more)
}

// optional bytes reply_proto = 3;
inline bool Frame_InvokeMethodReply::has_reply_proto() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Frame_InvokeMethodReply::set_has_reply_proto() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Frame_InvokeMethodReply::clear_has_reply_proto() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Frame_InvokeMethodReply::clear_reply_proto() {
  reply_proto_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_reply_proto();
}
inline const ::std::string& Frame_InvokeMethodReply::reply_proto() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.InvokeMethodReply.reply_proto)
  return reply_proto_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Frame_InvokeMethodReply::set_reply_proto(const ::std::string& value) {
  set_has_reply_proto();
  reply_proto_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.ipc.Frame.InvokeMethodReply.reply_proto)
}
inline void Frame_InvokeMethodReply::set_reply_proto(const char* value) {
  set_has_reply_proto();
  reply_proto_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.ipc.Frame.InvokeMethodReply.reply_proto)
}
inline void Frame_InvokeMethodReply::set_reply_proto(const void* value, size_t size) {
  set_has_reply_proto();
  reply_proto_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.ipc.Frame.InvokeMethodReply.reply_proto)
}
inline ::std::string* Frame_InvokeMethodReply::mutable_reply_proto() {
  set_has_reply_proto();
  // @@protoc_insertion_point(field_mutable:perfetto.ipc.Frame.InvokeMethodReply.reply_proto)
  return reply_proto_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Frame_InvokeMethodReply::release_reply_proto() {
  // @@protoc_insertion_point(field_release:perfetto.ipc.Frame.InvokeMethodReply.reply_proto)
  clear_has_reply_proto();
  return reply_proto_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Frame_InvokeMethodReply::set_allocated_reply_proto(::std::string* reply_proto) {
  if (reply_proto != NULL) {
    set_has_reply_proto();
  } else {
    clear_has_reply_proto();
  }
  reply_proto_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reply_proto);
  // @@protoc_insertion_point(field_set_allocated:perfetto.ipc.Frame.InvokeMethodReply.reply_proto)
}

// -------------------------------------------------------------------

// Frame_RequestError

// optional string error = 1;
inline bool Frame_RequestError::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Frame_RequestError::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Frame_RequestError::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Frame_RequestError::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error();
}
inline const ::std::string& Frame_RequestError::error() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.RequestError.error)
  return error_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Frame_RequestError::set_error(const ::std::string& value) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.ipc.Frame.RequestError.error)
}
inline void Frame_RequestError::set_error(const char* value) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.ipc.Frame.RequestError.error)
}
inline void Frame_RequestError::set_error(const char* value, size_t size) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.ipc.Frame.RequestError.error)
}
inline ::std::string* Frame_RequestError::mutable_error() {
  set_has_error();
  // @@protoc_insertion_point(field_mutable:perfetto.ipc.Frame.RequestError.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Frame_RequestError::release_error() {
  // @@protoc_insertion_point(field_release:perfetto.ipc.Frame.RequestError.error)
  clear_has_error();
  return error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Frame_RequestError::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    set_has_error();
  } else {
    clear_has_error();
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:perfetto.ipc.Frame.RequestError.error)
}

// -------------------------------------------------------------------

// Frame

// optional uint64 request_id = 2;
inline bool Frame::has_request_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Frame::set_has_request_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Frame::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Frame::clear_request_id() {
  request_id_ = GOOGLE_ULONGLONG(0);
  clear_has_request_id();
}
inline ::google::protobuf::uint64 Frame::request_id() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.request_id)
  return request_id_;
}
inline void Frame::set_request_id(::google::protobuf::uint64 value) {
  set_has_request_id();
  request_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.ipc.Frame.request_id)
}

// optional .perfetto.ipc.Frame.BindService msg_bind_service = 3;
inline bool Frame::has_msg_bind_service() const {
  return msg_case() == kMsgBindService;
}
inline void Frame::set_has_msg_bind_service() {
  _oneof_case_[0] = kMsgBindService;
}
inline void Frame::clear_msg_bind_service() {
  if (has_msg_bind_service()) {
    delete msg_.msg_bind_service_;
    clear_has_msg();
  }
}
inline  const ::perfetto::ipc::Frame_BindService& Frame::msg_bind_service() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.msg_bind_service)
  return has_msg_bind_service()
      ? *msg_.msg_bind_service_
      : ::perfetto::ipc::Frame_BindService::default_instance();
}
inline ::perfetto::ipc::Frame_BindService* Frame::mutable_msg_bind_service() {
  if (!has_msg_bind_service()) {
    clear_msg();
    set_has_msg_bind_service();
    msg_.msg_bind_service_ = new ::perfetto::ipc::Frame_BindService;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.ipc.Frame.msg_bind_service)
  return msg_.msg_bind_service_;
}
inline ::perfetto::ipc::Frame_BindService* Frame::release_msg_bind_service() {
  // @@protoc_insertion_point(field_release:perfetto.ipc.Frame.msg_bind_service)
  if (has_msg_bind_service()) {
    clear_has_msg();
    ::perfetto::ipc::Frame_BindService* temp = msg_.msg_bind_service_;
    msg_.msg_bind_service_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Frame::set_allocated_msg_bind_service(::perfetto::ipc::Frame_BindService* msg_bind_service) {
  clear_msg();
  if (msg_bind_service) {
    set_has_msg_bind_service();
    msg_.msg_bind_service_ = msg_bind_service;
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.ipc.Frame.msg_bind_service)
}

// optional .perfetto.ipc.Frame.BindServiceReply msg_bind_service_reply = 4;
inline bool Frame::has_msg_bind_service_reply() const {
  return msg_case() == kMsgBindServiceReply;
}
inline void Frame::set_has_msg_bind_service_reply() {
  _oneof_case_[0] = kMsgBindServiceReply;
}
inline void Frame::clear_msg_bind_service_reply() {
  if (has_msg_bind_service_reply()) {
    delete msg_.msg_bind_service_reply_;
    clear_has_msg();
  }
}
inline  const ::perfetto::ipc::Frame_BindServiceReply& Frame::msg_bind_service_reply() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.msg_bind_service_reply)
  return has_msg_bind_service_reply()
      ? *msg_.msg_bind_service_reply_
      : ::perfetto::ipc::Frame_BindServiceReply::default_instance();
}
inline ::perfetto::ipc::Frame_BindServiceReply* Frame::mutable_msg_bind_service_reply() {
  if (!has_msg_bind_service_reply()) {
    clear_msg();
    set_has_msg_bind_service_reply();
    msg_.msg_bind_service_reply_ = new ::perfetto::ipc::Frame_BindServiceReply;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.ipc.Frame.msg_bind_service_reply)
  return msg_.msg_bind_service_reply_;
}
inline ::perfetto::ipc::Frame_BindServiceReply* Frame::release_msg_bind_service_reply() {
  // @@protoc_insertion_point(field_release:perfetto.ipc.Frame.msg_bind_service_reply)
  if (has_msg_bind_service_reply()) {
    clear_has_msg();
    ::perfetto::ipc::Frame_BindServiceReply* temp = msg_.msg_bind_service_reply_;
    msg_.msg_bind_service_reply_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Frame::set_allocated_msg_bind_service_reply(::perfetto::ipc::Frame_BindServiceReply* msg_bind_service_reply) {
  clear_msg();
  if (msg_bind_service_reply) {
    set_has_msg_bind_service_reply();
    msg_.msg_bind_service_reply_ = msg_bind_service_reply;
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.ipc.Frame.msg_bind_service_reply)
}

// optional .perfetto.ipc.Frame.InvokeMethod msg_invoke_method = 5;
inline bool Frame::has_msg_invoke_method() const {
  return msg_case() == kMsgInvokeMethod;
}
inline void Frame::set_has_msg_invoke_method() {
  _oneof_case_[0] = kMsgInvokeMethod;
}
inline void Frame::clear_msg_invoke_method() {
  if (has_msg_invoke_method()) {
    delete msg_.msg_invoke_method_;
    clear_has_msg();
  }
}
inline  const ::perfetto::ipc::Frame_InvokeMethod& Frame::msg_invoke_method() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.msg_invoke_method)
  return has_msg_invoke_method()
      ? *msg_.msg_invoke_method_
      : ::perfetto::ipc::Frame_InvokeMethod::default_instance();
}
inline ::perfetto::ipc::Frame_InvokeMethod* Frame::mutable_msg_invoke_method() {
  if (!has_msg_invoke_method()) {
    clear_msg();
    set_has_msg_invoke_method();
    msg_.msg_invoke_method_ = new ::perfetto::ipc::Frame_InvokeMethod;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.ipc.Frame.msg_invoke_method)
  return msg_.msg_invoke_method_;
}
inline ::perfetto::ipc::Frame_InvokeMethod* Frame::release_msg_invoke_method() {
  // @@protoc_insertion_point(field_release:perfetto.ipc.Frame.msg_invoke_method)
  if (has_msg_invoke_method()) {
    clear_has_msg();
    ::perfetto::ipc::Frame_InvokeMethod* temp = msg_.msg_invoke_method_;
    msg_.msg_invoke_method_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Frame::set_allocated_msg_invoke_method(::perfetto::ipc::Frame_InvokeMethod* msg_invoke_method) {
  clear_msg();
  if (msg_invoke_method) {
    set_has_msg_invoke_method();
    msg_.msg_invoke_method_ = msg_invoke_method;
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.ipc.Frame.msg_invoke_method)
}

// optional .perfetto.ipc.Frame.InvokeMethodReply msg_invoke_method_reply = 6;
inline bool Frame::has_msg_invoke_method_reply() const {
  return msg_case() == kMsgInvokeMethodReply;
}
inline void Frame::set_has_msg_invoke_method_reply() {
  _oneof_case_[0] = kMsgInvokeMethodReply;
}
inline void Frame::clear_msg_invoke_method_reply() {
  if (has_msg_invoke_method_reply()) {
    delete msg_.msg_invoke_method_reply_;
    clear_has_msg();
  }
}
inline  const ::perfetto::ipc::Frame_InvokeMethodReply& Frame::msg_invoke_method_reply() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.msg_invoke_method_reply)
  return has_msg_invoke_method_reply()
      ? *msg_.msg_invoke_method_reply_
      : ::perfetto::ipc::Frame_InvokeMethodReply::default_instance();
}
inline ::perfetto::ipc::Frame_InvokeMethodReply* Frame::mutable_msg_invoke_method_reply() {
  if (!has_msg_invoke_method_reply()) {
    clear_msg();
    set_has_msg_invoke_method_reply();
    msg_.msg_invoke_method_reply_ = new ::perfetto::ipc::Frame_InvokeMethodReply;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.ipc.Frame.msg_invoke_method_reply)
  return msg_.msg_invoke_method_reply_;
}
inline ::perfetto::ipc::Frame_InvokeMethodReply* Frame::release_msg_invoke_method_reply() {
  // @@protoc_insertion_point(field_release:perfetto.ipc.Frame.msg_invoke_method_reply)
  if (has_msg_invoke_method_reply()) {
    clear_has_msg();
    ::perfetto::ipc::Frame_InvokeMethodReply* temp = msg_.msg_invoke_method_reply_;
    msg_.msg_invoke_method_reply_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Frame::set_allocated_msg_invoke_method_reply(::perfetto::ipc::Frame_InvokeMethodReply* msg_invoke_method_reply) {
  clear_msg();
  if (msg_invoke_method_reply) {
    set_has_msg_invoke_method_reply();
    msg_.msg_invoke_method_reply_ = msg_invoke_method_reply;
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.ipc.Frame.msg_invoke_method_reply)
}

// optional .perfetto.ipc.Frame.RequestError msg_request_error = 7;
inline bool Frame::has_msg_request_error() const {
  return msg_case() == kMsgRequestError;
}
inline void Frame::set_has_msg_request_error() {
  _oneof_case_[0] = kMsgRequestError;
}
inline void Frame::clear_msg_request_error() {
  if (has_msg_request_error()) {
    delete msg_.msg_request_error_;
    clear_has_msg();
  }
}
inline  const ::perfetto::ipc::Frame_RequestError& Frame::msg_request_error() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.msg_request_error)
  return has_msg_request_error()
      ? *msg_.msg_request_error_
      : ::perfetto::ipc::Frame_RequestError::default_instance();
}
inline ::perfetto::ipc::Frame_RequestError* Frame::mutable_msg_request_error() {
  if (!has_msg_request_error()) {
    clear_msg();
    set_has_msg_request_error();
    msg_.msg_request_error_ = new ::perfetto::ipc::Frame_RequestError;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.ipc.Frame.msg_request_error)
  return msg_.msg_request_error_;
}
inline ::perfetto::ipc::Frame_RequestError* Frame::release_msg_request_error() {
  // @@protoc_insertion_point(field_release:perfetto.ipc.Frame.msg_request_error)
  if (has_msg_request_error()) {
    clear_has_msg();
    ::perfetto::ipc::Frame_RequestError* temp = msg_.msg_request_error_;
    msg_.msg_request_error_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Frame::set_allocated_msg_request_error(::perfetto::ipc::Frame_RequestError* msg_request_error) {
  clear_msg();
  if (msg_request_error) {
    set_has_msg_request_error();
    msg_.msg_request_error_ = msg_request_error;
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.ipc.Frame.msg_request_error)
}

// repeated bytes data_for_testing = 1;
inline int Frame::data_for_testing_size() const {
  return data_for_testing_.size();
}
inline void Frame::clear_data_for_testing() {
  data_for_testing_.Clear();
}
inline const ::std::string& Frame::data_for_testing(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.data_for_testing)
  return data_for_testing_.Get(index);
}
inline ::std::string* Frame::mutable_data_for_testing(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.ipc.Frame.data_for_testing)
  return data_for_testing_.Mutable(index);
}
inline void Frame::set_data_for_testing(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.ipc.Frame.data_for_testing)
  data_for_testing_.Mutable(index)->assign(value);
}
inline void Frame::set_data_for_testing(int index, const char* value) {
  data_for_testing_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.ipc.Frame.data_for_testing)
}
inline void Frame::set_data_for_testing(int index, const void* value, size_t size) {
  data_for_testing_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.ipc.Frame.data_for_testing)
}
inline ::std::string* Frame::add_data_for_testing() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.ipc.Frame.data_for_testing)
  return data_for_testing_.Add();
}
inline void Frame::add_data_for_testing(const ::std::string& value) {
  data_for_testing_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.ipc.Frame.data_for_testing)
}
inline void Frame::add_data_for_testing(const char* value) {
  data_for_testing_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.ipc.Frame.data_for_testing)
}
inline void Frame::add_data_for_testing(const void* value, size_t size) {
  data_for_testing_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.ipc.Frame.data_for_testing)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Frame::data_for_testing() const {
  // @@protoc_insertion_point(field_list:perfetto.ipc.Frame.data_for_testing)
  return data_for_testing_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Frame::mutable_data_for_testing() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.ipc.Frame.data_for_testing)
  return &data_for_testing_;
}

inline bool Frame::has_msg() const {
  return msg_case() != MSG_NOT_SET;
}
inline void Frame::clear_has_msg() {
  _oneof_case_[0] = MSG_NOT_SET;
}
inline Frame::MsgCase Frame::msg_case() const {
  return Frame::MsgCase(_oneof_case_[0]);
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ipc
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_src_2fipc_2fwire_5fprotocol_2eproto__INCLUDED
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: src/ipc/wire_protocol.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
// gen_amalgamated expanded: #include "src/ipc/wire_protocol.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace ipc {

void protobuf_ShutdownFile_src_2fipc_2fwire_5fprotocol_2eproto() {
  delete Frame::default_instance_;
  delete Frame_BindService::default_instance_;
  delete Frame_BindServiceReply::default_instance_;
  delete Frame_BindServiceReply_MethodInfo::default_instance_;
  delete Frame_InvokeMethod::default_instance_;
  delete Frame_InvokeMethodReply::default_instance_;
  delete Frame_RequestError::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_src_2fipc_2fwire_5fprotocol_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_src_2fipc_2fwire_5fprotocol_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  Frame::default_instance_ = new Frame();
  Frame_BindService::default_instance_ = new Frame_BindService();
  Frame_BindServiceReply::default_instance_ = new Frame_BindServiceReply();
  Frame_BindServiceReply_MethodInfo::default_instance_ = new Frame_BindServiceReply_MethodInfo();
  Frame_InvokeMethod::default_instance_ = new Frame_InvokeMethod();
  Frame_InvokeMethodReply::default_instance_ = new Frame_InvokeMethodReply();
  Frame_RequestError::default_instance_ = new Frame_RequestError();
  Frame::default_instance_->InitAsDefaultInstance();
  Frame_BindService::default_instance_->InitAsDefaultInstance();
  Frame_BindServiceReply::default_instance_->InitAsDefaultInstance();
  Frame_BindServiceReply_MethodInfo::default_instance_->InitAsDefaultInstance();
  Frame_InvokeMethod::default_instance_->InitAsDefaultInstance();
  Frame_InvokeMethodReply::default_instance_->InitAsDefaultInstance();
  Frame_RequestError::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_src_2fipc_2fwire_5fprotocol_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_src_2fipc_2fwire_5fprotocol_2eproto_once_);
void protobuf_AddDesc_src_2fipc_2fwire_5fprotocol_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_src_2fipc_2fwire_5fprotocol_2eproto_once_,
                 &protobuf_AddDesc_src_2fipc_2fwire_5fprotocol_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_src_2fipc_2fwire_5fprotocol_2eproto {
  StaticDescriptorInitializer_src_2fipc_2fwire_5fprotocol_2eproto() {
    protobuf_AddDesc_src_2fipc_2fwire_5fprotocol_2eproto();
  }
} static_descriptor_initializer_src_2fipc_2fwire_5fprotocol_2eproto_;
#endif

namespace {

static void wire_protocol_pb_MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
static void wire_protocol_pb_MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

static ::std::string* MutableUnknownFieldsForFrame(
    Frame* ptr) {
  return ptr->mutable_unknown_fields();
}

static ::std::string* MutableUnknownFieldsForFrame_BindService(
    Frame_BindService* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Frame_BindService::kServiceNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Frame_BindService::Frame_BindService()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.ipc.Frame.BindService)
}

void Frame_BindService::InitAsDefaultInstance() {
}

Frame_BindService::Frame_BindService(const Frame_BindService& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.ipc.Frame.BindService)
}

void Frame_BindService::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  service_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Frame_BindService::~Frame_BindService() {
  // @@protoc_insertion_point(destructor:perfetto.ipc.Frame.BindService)
  SharedDtor();
}

void Frame_BindService::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  service_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Frame_BindService::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Frame_BindService& Frame_BindService::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_src_2fipc_2fwire_5fprotocol_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_src_2fipc_2fwire_5fprotocol_2eproto();
#endif
  return *default_instance_;
}

Frame_BindService* Frame_BindService::default_instance_ = NULL;

Frame_BindService* Frame_BindService::New(::google::protobuf::Arena* arena) const {
  Frame_BindService* n = new Frame_BindService;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Frame_BindService::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.ipc.Frame.BindService)
  if (has_service_name()) {
    service_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool Frame_BindService::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForFrame_BindService, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.ipc.Frame.BindService)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string service_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_service_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.ipc.Frame.BindService)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.ipc.Frame.BindService)
  return false;
#undef DO_
}

void Frame_BindService::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.ipc.Frame.BindService)
  // optional string service_name = 1;
  if (has_service_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->service_name(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.ipc.Frame.BindService)
}

int Frame_BindService::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.ipc.Frame.BindService)
  int total_size = 0;

  // optional string service_name = 1;
  if (has_service_name()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->service_name());
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Frame_BindService::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Frame_BindService*>(&from));
}

void Frame_BindService::MergeFrom(const Frame_BindService& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.ipc.Frame.BindService)
  if (GOOGLE_PREDICT_FALSE(&from == this)) wire_protocol_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_service_name()) {
      set_has_service_name();
      service_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.service_name_);
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void Frame_BindService::CopyFrom(const Frame_BindService& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.ipc.Frame.BindService)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Frame_BindService::IsInitialized() const {

  return true;
}

void Frame_BindService::Swap(Frame_BindService* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Frame_BindService::InternalSwap(Frame_BindService* other) {
  service_name_.Swap(&other->service_name_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Frame_BindService::GetTypeName() const {
  return "perfetto.ipc.Frame.BindService";
}


// -------------------------------------------------------------------

static ::std::string* MutableUnknownFieldsForFrame_BindServiceReply(
    Frame_BindServiceReply* ptr) {
  return ptr->mutable_unknown_fields();
}

static ::std::string* MutableUnknownFieldsForFrame_BindServiceReply_MethodInfo(
    Frame_BindServiceReply_MethodInfo* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Frame_BindServiceReply_MethodInfo::kIdFieldNumber;
const int Frame_BindServiceReply_MethodInfo::kNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Frame_BindServiceReply_MethodInfo::Frame_BindServiceReply_MethodInfo()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.ipc.Frame.BindServiceReply.MethodInfo)
}

void Frame_BindServiceReply_MethodInfo::InitAsDefaultInstance() {
}

Frame_BindServiceReply_MethodInfo::Frame_BindServiceReply_MethodInfo(const Frame_BindServiceReply_MethodInfo& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.ipc.Frame.BindServiceReply.MethodInfo)
}

void Frame_BindServiceReply_MethodInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  id_ = 0u;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Frame_BindServiceReply_MethodInfo::~Frame_BindServiceReply_MethodInfo() {
  // @@protoc_insertion_point(destructor:perfetto.ipc.Frame.BindServiceReply.MethodInfo)
  SharedDtor();
}

void Frame_BindServiceReply_MethodInfo::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Frame_BindServiceReply_MethodInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Frame_BindServiceReply_MethodInfo& Frame_BindServiceReply_MethodInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_src_2fipc_2fwire_5fprotocol_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_src_2fipc_2fwire_5fprotocol_2eproto();
#endif
  return *default_instance_;
}

Frame_BindServiceReply_MethodInfo* Frame_BindServiceReply_MethodInfo::default_instance_ = NULL;

Frame_BindServiceReply_MethodInfo* Frame_BindServiceReply_MethodInfo::New(::google::protobuf::Arena* arena) const {
  Frame_BindServiceReply_MethodInfo* n = new Frame_BindServiceReply_MethodInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Frame_BindServiceReply_MethodInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.ipc.Frame.BindServiceReply.MethodInfo)
  if (_has_bits_[0 / 32] & 3u) {
    id_ = 0u;
    if (has_name()) {
      name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool Frame_BindServiceReply_MethodInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForFrame_BindServiceReply_MethodInfo, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.ipc.Frame.BindServiceReply.MethodInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // optional string name = 2;
      case 2: {
        if (tag == 18) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.ipc.Frame.BindServiceReply.MethodInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.ipc.Frame.BindServiceReply.MethodInfo)
  return false;
#undef DO_
}

void Frame_BindServiceReply_MethodInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.ipc.Frame.BindServiceReply.MethodInfo)
  // optional uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->name(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.ipc.Frame.BindServiceReply.MethodInfo)
}

int Frame_BindServiceReply_MethodInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.ipc.Frame.BindServiceReply.MethodInfo)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // optional string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Frame_BindServiceReply_MethodInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Frame_BindServiceReply_MethodInfo*>(&from));
}

void Frame_BindServiceReply_MethodInfo::MergeFrom(const Frame_BindServiceReply_MethodInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.ipc.Frame.BindServiceReply.MethodInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) wire_protocol_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void Frame_BindServiceReply_MethodInfo::CopyFrom(const Frame_BindServiceReply_MethodInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.ipc.Frame.BindServiceReply.MethodInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Frame_BindServiceReply_MethodInfo::IsInitialized() const {

  return true;
}

void Frame_BindServiceReply_MethodInfo::Swap(Frame_BindServiceReply_MethodInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Frame_BindServiceReply_MethodInfo::InternalSwap(Frame_BindServiceReply_MethodInfo* other) {
  std::swap(id_, other->id_);
  name_.Swap(&other->name_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Frame_BindServiceReply_MethodInfo::GetTypeName() const {
  return "perfetto.ipc.Frame.BindServiceReply.MethodInfo";
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Frame_BindServiceReply::kSuccessFieldNumber;
const int Frame_BindServiceReply::kServiceIdFieldNumber;
const int Frame_BindServiceReply::kMethodsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Frame_BindServiceReply::Frame_BindServiceReply()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.ipc.Frame.BindServiceReply)
}

void Frame_BindServiceReply::InitAsDefaultInstance() {
}

Frame_BindServiceReply::Frame_BindServiceReply(const Frame_BindServiceReply& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.ipc.Frame.BindServiceReply)
}

void Frame_BindServiceReply::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  success_ = false;
  service_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Frame_BindServiceReply::~Frame_BindServiceReply() {
  // @@protoc_insertion_point(destructor:perfetto.ipc.Frame.BindServiceReply)
  SharedDtor();
}

void Frame_BindServiceReply::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Frame_BindServiceReply::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Frame_BindServiceReply& Frame_BindServiceReply::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_src_2fipc_2fwire_5fprotocol_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_src_2fipc_2fwire_5fprotocol_2eproto();
#endif
  return *default_instance_;
}

Frame_BindServiceReply* Frame_BindServiceReply::default_instance_ = NULL;

Frame_BindServiceReply* Frame_BindServiceReply::New(::google::protobuf::Arena* arena) const {
  Frame_BindServiceReply* n = new Frame_BindServiceReply;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Frame_BindServiceReply::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.ipc.Frame.BindServiceReply)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Frame_BindServiceReply, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Frame_BindServiceReply*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(success_, service_id_);

#undef ZR_HELPER_
#undef ZR_

  methods_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool Frame_BindServiceReply::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForFrame_BindServiceReply, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.ipc.Frame.BindServiceReply)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool success = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &success_)));
          set_has_success();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_service_id;
        break;
      }

      // optional uint32 service_id = 2;
      case 2: {
        if (tag == 16) {
         parse_service_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &service_id_)));
          set_has_service_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_methods;
        break;
      }

      // repeated .perfetto.ipc.Frame.BindServiceReply.MethodInfo methods = 3;
      case 3: {
        if (tag == 26) {
         parse_methods:
          DO_(input->IncrementRecursionDepth());
         parse_loop_methods:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_methods()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_loop_methods;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.ipc.Frame.BindServiceReply)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.ipc.Frame.BindServiceReply)
  return false;
#undef DO_
}

void Frame_BindServiceReply::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.ipc.Frame.BindServiceReply)
  // optional bool success = 1;
  if (has_success()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->success(), output);
  }

  // optional uint32 service_id = 2;
  if (has_service_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->service_id(), output);
  }

  // repeated .perfetto.ipc.Frame.BindServiceReply.MethodInfo methods = 3;
  for (unsigned int i = 0, n = this->methods_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->methods(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.ipc.Frame.BindServiceReply)
}

int Frame_BindServiceReply::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.ipc.Frame.BindServiceReply)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional bool success = 1;
    if (has_success()) {
      total_size += 1 + 1;
    }

    // optional uint32 service_id = 2;
    if (has_service_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->service_id());
    }

  }
  // repeated .perfetto.ipc.Frame.BindServiceReply.MethodInfo methods = 3;
  total_size += 1 * this->methods_size();
  for (int i = 0; i < this->methods_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->methods(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Frame_BindServiceReply::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Frame_BindServiceReply*>(&from));
}

void Frame_BindServiceReply::MergeFrom(const Frame_BindServiceReply& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.ipc.Frame.BindServiceReply)
  if (GOOGLE_PREDICT_FALSE(&from == this)) wire_protocol_pb_MergeFromFail(__LINE__);
  methods_.MergeFrom(from.methods_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_success()) {
      set_success(from.success());
    }
    if (from.has_service_id()) {
      set_service_id(from.service_id());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void Frame_BindServiceReply::CopyFrom(const Frame_BindServiceReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.ipc.Frame.BindServiceReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Frame_BindServiceReply::IsInitialized() const {

  return true;
}

void Frame_BindServiceReply::Swap(Frame_BindServiceReply* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Frame_BindServiceReply::InternalSwap(Frame_BindServiceReply* other) {
  std::swap(success_, other->success_);
  std::swap(service_id_, other->service_id_);
  methods_.UnsafeArenaSwap(&other->methods_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Frame_BindServiceReply::GetTypeName() const {
  return "perfetto.ipc.Frame.BindServiceReply";
}


// -------------------------------------------------------------------

static ::std::string* MutableUnknownFieldsForFrame_InvokeMethod(
    Frame_InvokeMethod* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Frame_InvokeMethod::kServiceIdFieldNumber;
const int Frame_InvokeMethod::kMethodIdFieldNumber;
const int Frame_InvokeMethod::kArgsProtoFieldNumber;
const int Frame_InvokeMethod::kDropReplyFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Frame_InvokeMethod::Frame_InvokeMethod()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.ipc.Frame.InvokeMethod)
}

void Frame_InvokeMethod::InitAsDefaultInstance() {
}

Frame_InvokeMethod::Frame_InvokeMethod(const Frame_InvokeMethod& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.ipc.Frame.InvokeMethod)
}

void Frame_InvokeMethod::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  service_id_ = 0u;
  method_id_ = 0u;
  args_proto_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  drop_reply_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Frame_InvokeMethod::~Frame_InvokeMethod() {
  // @@protoc_insertion_point(destructor:perfetto.ipc.Frame.InvokeMethod)
  SharedDtor();
}

void Frame_InvokeMethod::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  args_proto_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Frame_InvokeMethod::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Frame_InvokeMethod& Frame_InvokeMethod::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_src_2fipc_2fwire_5fprotocol_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_src_2fipc_2fwire_5fprotocol_2eproto();
#endif
  return *default_instance_;
}

Frame_InvokeMethod* Frame_InvokeMethod::default_instance_ = NULL;

Frame_InvokeMethod* Frame_InvokeMethod::New(::google::protobuf::Arena* arena) const {
  Frame_InvokeMethod* n = new Frame_InvokeMethod;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Frame_InvokeMethod::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.ipc.Frame.InvokeMethod)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Frame_InvokeMethod, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Frame_InvokeMethod*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 15u) {
    ZR_(service_id_, method_id_);
    if (has_args_proto()) {
      args_proto_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    drop_reply_ = false;
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool Frame_InvokeMethod::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForFrame_InvokeMethod, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.ipc.Frame.InvokeMethod)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 service_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &service_id_)));
          set_has_service_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_method_id;
        break;
      }

      // optional uint32 method_id = 2;
      case 2: {
        if (tag == 16) {
         parse_method_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &method_id_)));
          set_has_method_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_args_proto;
        break;
      }

      // optional bytes args_proto = 3;
      case 3: {
        if (tag == 26) {
         parse_args_proto:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_args_proto()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_drop_reply;
        break;
      }

      // optional bool drop_reply = 4;
      case 4: {
        if (tag == 32) {
         parse_drop_reply:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &drop_reply_)));
          set_has_drop_reply();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.ipc.Frame.InvokeMethod)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.ipc.Frame.InvokeMethod)
  return false;
#undef DO_
}

void Frame_InvokeMethod::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.ipc.Frame.InvokeMethod)
  // optional uint32 service_id = 1;
  if (has_service_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->service_id(), output);
  }

  // optional uint32 method_id = 2;
  if (has_method_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->method_id(), output);
  }

  // optional bytes args_proto = 3;
  if (has_args_proto()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->args_proto(), output);
  }

  // optional bool drop_reply = 4;
  if (has_drop_reply()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->drop_reply(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.ipc.Frame.InvokeMethod)
}

int Frame_InvokeMethod::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.ipc.Frame.InvokeMethod)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 15u) {
    // optional uint32 service_id = 1;
    if (has_service_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->service_id());
    }

    // optional uint32 method_id = 2;
    if (has_method_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->method_id());
    }

    // optional bytes args_proto = 3;
    if (has_args_proto()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->args_proto());
    }

    // optional bool drop_reply = 4;
    if (has_drop_reply()) {
      total_size += 1 + 1;
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Frame_InvokeMethod::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Frame_InvokeMethod*>(&from));
}

void Frame_InvokeMethod::MergeFrom(const Frame_InvokeMethod& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.ipc.Frame.InvokeMethod)
  if (GOOGLE_PREDICT_FALSE(&from == this)) wire_protocol_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_service_id()) {
      set_service_id(from.service_id());
    }
    if (from.has_method_id()) {
      set_method_id(from.method_id());
    }
    if (from.has_args_proto()) {
      set_has_args_proto();
      args_proto_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.args_proto_);
    }
    if (from.has_drop_reply()) {
      set_drop_reply(from.drop_reply());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void Frame_InvokeMethod::CopyFrom(const Frame_InvokeMethod& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.ipc.Frame.InvokeMethod)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Frame_InvokeMethod::IsInitialized() const {

  return true;
}

void Frame_InvokeMethod::Swap(Frame_InvokeMethod* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Frame_InvokeMethod::InternalSwap(Frame_InvokeMethod* other) {
  std::swap(service_id_, other->service_id_);
  std::swap(method_id_, other->method_id_);
  args_proto_.Swap(&other->args_proto_);
  std::swap(drop_reply_, other->drop_reply_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Frame_InvokeMethod::GetTypeName() const {
  return "perfetto.ipc.Frame.InvokeMethod";
}


// -------------------------------------------------------------------

static ::std::string* MutableUnknownFieldsForFrame_InvokeMethodReply(
    Frame_InvokeMethodReply* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Frame_InvokeMethodReply::kSuccessFieldNumber;
const int Frame_InvokeMethodReply::kHasMoreFieldNumber;
const int Frame_InvokeMethodReply::kReplyProtoFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Frame_InvokeMethodReply::Frame_InvokeMethodReply()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.ipc.Frame.InvokeMethodReply)
}

void Frame_InvokeMethodReply::InitAsDefaultInstance() {
}

Frame_InvokeMethodReply::Frame_InvokeMethodReply(const Frame_InvokeMethodReply& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.ipc.Frame.InvokeMethodReply)
}

void Frame_InvokeMethodReply::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  success_ = false;
  has_more_ = false;
  reply_proto_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Frame_InvokeMethodReply::~Frame_InvokeMethodReply() {
  // @@protoc_insertion_point(destructor:perfetto.ipc.Frame.InvokeMethodReply)
  SharedDtor();
}

void Frame_InvokeMethodReply::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  reply_proto_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Frame_InvokeMethodReply::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Frame_InvokeMethodReply& Frame_InvokeMethodReply::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_src_2fipc_2fwire_5fprotocol_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_src_2fipc_2fwire_5fprotocol_2eproto();
#endif
  return *default_instance_;
}

Frame_InvokeMethodReply* Frame_InvokeMethodReply::default_instance_ = NULL;

Frame_InvokeMethodReply* Frame_InvokeMethodReply::New(::google::protobuf::Arena* arena) const {
  Frame_InvokeMethodReply* n = new Frame_InvokeMethodReply;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Frame_InvokeMethodReply::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.ipc.Frame.InvokeMethodReply)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Frame_InvokeMethodReply, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Frame_InvokeMethodReply*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 7u) {
    ZR_(success_, has_more_);
    if (has_reply_proto()) {
      reply_proto_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool Frame_InvokeMethodReply::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForFrame_InvokeMethodReply, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.ipc.Frame.InvokeMethodReply)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool success = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &success_)));
          set_has_success();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_has_more;
        break;
      }

      // optional bool has_more = 2;
      case 2: {
        if (tag == 16) {
         parse_has_more:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_more_)));
          set_has_has_more();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_reply_proto;
        break;
      }

      // optional bytes reply_proto = 3;
      case 3: {
        if (tag == 26) {
         parse_reply_proto:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_reply_proto()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.ipc.Frame.InvokeMethodReply)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.ipc.Frame.InvokeMethodReply)
  return false;
#undef DO_
}

void Frame_InvokeMethodReply::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.ipc.Frame.InvokeMethodReply)
  // optional bool success = 1;
  if (has_success()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->success(), output);
  }

  // optional bool has_more = 2;
  if (has_has_more()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->has_more(), output);
  }

  // optional bytes reply_proto = 3;
  if (has_reply_proto()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->reply_proto(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.ipc.Frame.InvokeMethodReply)
}

int Frame_InvokeMethodReply::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.ipc.Frame.InvokeMethodReply)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 7u) {
    // optional bool success = 1;
    if (has_success()) {
      total_size += 1 + 1;
    }

    // optional bool has_more = 2;
    if (has_has_more()) {
      total_size += 1 + 1;
    }

    // optional bytes reply_proto = 3;
    if (has_reply_proto()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->reply_proto());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Frame_InvokeMethodReply::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Frame_InvokeMethodReply*>(&from));
}

void Frame_InvokeMethodReply::MergeFrom(const Frame_InvokeMethodReply& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.ipc.Frame.InvokeMethodReply)
  if (GOOGLE_PREDICT_FALSE(&from == this)) wire_protocol_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_success()) {
      set_success(from.success());
    }
    if (from.has_has_more()) {
      set_has_more(from.has_more());
    }
    if (from.has_reply_proto()) {
      set_has_reply_proto();
      reply_proto_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.reply_proto_);
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void Frame_InvokeMethodReply::CopyFrom(const Frame_InvokeMethodReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.ipc.Frame.InvokeMethodReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Frame_InvokeMethodReply::IsInitialized() const {

  return true;
}

void Frame_InvokeMethodReply::Swap(Frame_InvokeMethodReply* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Frame_InvokeMethodReply::InternalSwap(Frame_InvokeMethodReply* other) {
  std::swap(success_, other->success_);
  std::swap(has_more_, other->has_more_);
  reply_proto_.Swap(&other->reply_proto_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Frame_InvokeMethodReply::GetTypeName() const {
  return "perfetto.ipc.Frame.InvokeMethodReply";
}


// -------------------------------------------------------------------

static ::std::string* MutableUnknownFieldsForFrame_RequestError(
    Frame_RequestError* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Frame_RequestError::kErrorFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Frame_RequestError::Frame_RequestError()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.ipc.Frame.RequestError)
}

void Frame_RequestError::InitAsDefaultInstance() {
}

Frame_RequestError::Frame_RequestError(const Frame_RequestError& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.ipc.Frame.RequestError)
}

void Frame_RequestError::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  error_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Frame_RequestError::~Frame_RequestError() {
  // @@protoc_insertion_point(destructor:perfetto.ipc.Frame.RequestError)
  SharedDtor();
}

void Frame_RequestError::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  error_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Frame_RequestError::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Frame_RequestError& Frame_RequestError::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_src_2fipc_2fwire_5fprotocol_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_src_2fipc_2fwire_5fprotocol_2eproto();
#endif
  return *default_instance_;
}

Frame_RequestError* Frame_RequestError::default_instance_ = NULL;

Frame_RequestError* Frame_RequestError::New(::google::protobuf::Arena* arena) const {
  Frame_RequestError* n = new Frame_RequestError;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Frame_RequestError::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.ipc.Frame.RequestError)
  if (has_error()) {
    error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool Frame_RequestError::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForFrame_RequestError, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.ipc.Frame.RequestError)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string error = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_error()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.ipc.Frame.RequestError)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.ipc.Frame.RequestError)
  return false;
#undef DO_
}

void Frame_RequestError::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.ipc.Frame.RequestError)
  // optional string error = 1;
  if (has_error()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->error(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.ipc.Frame.RequestError)
}

int Frame_RequestError::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.ipc.Frame.RequestError)
  int total_size = 0;

  // optional string error = 1;
  if (has_error()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->error());
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Frame_RequestError::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Frame_RequestError*>(&from));
}

void Frame_RequestError::MergeFrom(const Frame_RequestError& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.ipc.Frame.RequestError)
  if (GOOGLE_PREDICT_FALSE(&from == this)) wire_protocol_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_error()) {
      set_has_error();
      error_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.error_);
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void Frame_RequestError::CopyFrom(const Frame_RequestError& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.ipc.Frame.RequestError)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Frame_RequestError::IsInitialized() const {

  return true;
}

void Frame_RequestError::Swap(Frame_RequestError* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Frame_RequestError::InternalSwap(Frame_RequestError* other) {
  error_.Swap(&other->error_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Frame_RequestError::GetTypeName() const {
  return "perfetto.ipc.Frame.RequestError";
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Frame::kRequestIdFieldNumber;
const int Frame::kMsgBindServiceFieldNumber;
const int Frame::kMsgBindServiceReplyFieldNumber;
const int Frame::kMsgInvokeMethodFieldNumber;
const int Frame::kMsgInvokeMethodReplyFieldNumber;
const int Frame::kMsgRequestErrorFieldNumber;
const int Frame::kDataForTestingFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Frame::Frame()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.ipc.Frame)
}

void Frame::InitAsDefaultInstance() {
}

Frame::Frame(const Frame& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.ipc.Frame)
}

void Frame::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  request_id_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  clear_has_msg();
}

Frame::~Frame() {
  // @@protoc_insertion_point(destructor:perfetto.ipc.Frame)
  SharedDtor();
}

void Frame::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (has_msg()) {
    clear_msg();
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Frame::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Frame& Frame::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_src_2fipc_2fwire_5fprotocol_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_src_2fipc_2fwire_5fprotocol_2eproto();
#endif
  return *default_instance_;
}

Frame* Frame::default_instance_ = NULL;

Frame* Frame::New(::google::protobuf::Arena* arena) const {
  Frame* n = new Frame;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Frame::clear_msg() {
// @@protoc_insertion_point(one_of_clear_start:perfetto.ipc.Frame)
  switch(msg_case()) {
    case kMsgBindService: {
      delete msg_.msg_bind_service_;
      break;
    }
    case kMsgBindServiceReply: {
      delete msg_.msg_bind_service_reply_;
      break;
    }
    case kMsgInvokeMethod: {
      delete msg_.msg_invoke_method_;
      break;
    }
    case kMsgInvokeMethodReply: {
      delete msg_.msg_invoke_method_reply_;
      break;
    }
    case kMsgRequestError: {
      delete msg_.msg_request_error_;
      break;
    }
    case MSG_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = MSG_NOT_SET;
}


void Frame::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.ipc.Frame)
  request_id_ = GOOGLE_ULONGLONG(0);
  data_for_testing_.Clear();
  clear_msg();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool Frame::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForFrame, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.ipc.Frame)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated bytes data_for_testing = 1;
      case 1: {
        if (tag == 10) {
         parse_data_for_testing:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_data_for_testing()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_data_for_testing;
        if (input->ExpectTag(16)) goto parse_request_id;
        break;
      }

      // optional uint64 request_id = 2;
      case 2: {
        if (tag == 16) {
         parse_request_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &request_id_)));
          set_has_request_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_msg_bind_service;
        break;
      }

      // optional .perfetto.ipc.Frame.BindService msg_bind_service = 3;
      case 3: {
        if (tag == 26) {
         parse_msg_bind_service:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_msg_bind_service()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_msg_bind_service_reply;
        break;
      }

      // optional .perfetto.ipc.Frame.BindServiceReply msg_bind_service_reply = 4;
      case 4: {
        if (tag == 34) {
         parse_msg_bind_service_reply:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_msg_bind_service_reply()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_msg_invoke_method;
        break;
      }

      // optional .perfetto.ipc.Frame.InvokeMethod msg_invoke_method = 5;
      case 5: {
        if (tag == 42) {
         parse_msg_invoke_method:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_msg_invoke_method()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_msg_invoke_method_reply;
        break;
      }

      // optional .perfetto.ipc.Frame.InvokeMethodReply msg_invoke_method_reply = 6;
      case 6: {
        if (tag == 50) {
         parse_msg_invoke_method_reply:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_msg_invoke_method_reply()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_msg_request_error;
        break;
      }

      // optional .perfetto.ipc.Frame.RequestError msg_request_error = 7;
      case 7: {
        if (tag == 58) {
         parse_msg_request_error:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_msg_request_error()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.ipc.Frame)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.ipc.Frame)
  return false;
#undef DO_
}

void Frame::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.ipc.Frame)
  // repeated bytes data_for_testing = 1;
  for (int i = 0; i < this->data_for_testing_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->data_for_testing(i), output);
  }

  // optional uint64 request_id = 2;
  if (has_request_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->request_id(), output);
  }

  // optional .perfetto.ipc.Frame.BindService msg_bind_service = 3;
  if (has_msg_bind_service()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *msg_.msg_bind_service_, output);
  }

  // optional .perfetto.ipc.Frame.BindServiceReply msg_bind_service_reply = 4;
  if (has_msg_bind_service_reply()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, *msg_.msg_bind_service_reply_, output);
  }

  // optional .perfetto.ipc.Frame.InvokeMethod msg_invoke_method = 5;
  if (has_msg_invoke_method()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, *msg_.msg_invoke_method_, output);
  }

  // optional .perfetto.ipc.Frame.InvokeMethodReply msg_invoke_method_reply = 6;
  if (has_msg_invoke_method_reply()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, *msg_.msg_invoke_method_reply_, output);
  }

  // optional .perfetto.ipc.Frame.RequestError msg_request_error = 7;
  if (has_msg_request_error()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, *msg_.msg_request_error_, output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.ipc.Frame)
}

int Frame::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.ipc.Frame)
  int total_size = 0;

  // optional uint64 request_id = 2;
  if (has_request_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->request_id());
  }

  // repeated bytes data_for_testing = 1;
  total_size += 1 * this->data_for_testing_size();
  for (int i = 0; i < this->data_for_testing_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->data_for_testing(i));
  }

  switch (msg_case()) {
    // optional .perfetto.ipc.Frame.BindService msg_bind_service = 3;
    case kMsgBindService: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *msg_.msg_bind_service_);
      break;
    }
    // optional .perfetto.ipc.Frame.BindServiceReply msg_bind_service_reply = 4;
    case kMsgBindServiceReply: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *msg_.msg_bind_service_reply_);
      break;
    }
    // optional .perfetto.ipc.Frame.InvokeMethod msg_invoke_method = 5;
    case kMsgInvokeMethod: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *msg_.msg_invoke_method_);
      break;
    }
    // optional .perfetto.ipc.Frame.InvokeMethodReply msg_invoke_method_reply = 6;
    case kMsgInvokeMethodReply: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *msg_.msg_invoke_method_reply_);
      break;
    }
    // optional .perfetto.ipc.Frame.RequestError msg_request_error = 7;
    case kMsgRequestError: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *msg_.msg_request_error_);
      break;
    }
    case MSG_NOT_SET: {
      break;
    }
  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Frame::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Frame*>(&from));
}

void Frame::MergeFrom(const Frame& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.ipc.Frame)
  if (GOOGLE_PREDICT_FALSE(&from == this)) wire_protocol_pb_MergeFromFail(__LINE__);
  data_for_testing_.MergeFrom(from.data_for_testing_);
  switch (from.msg_case()) {
    case kMsgBindService: {
      mutable_msg_bind_service()->::perfetto::ipc::Frame_BindService::MergeFrom(from.msg_bind_service());
      break;
    }
    case kMsgBindServiceReply: {
      mutable_msg_bind_service_reply()->::perfetto::ipc::Frame_BindServiceReply::MergeFrom(from.msg_bind_service_reply());
      break;
    }
    case kMsgInvokeMethod: {
      mutable_msg_invoke_method()->::perfetto::ipc::Frame_InvokeMethod::MergeFrom(from.msg_invoke_method());
      break;
    }
    case kMsgInvokeMethodReply: {
      mutable_msg_invoke_method_reply()->::perfetto::ipc::Frame_InvokeMethodReply::MergeFrom(from.msg_invoke_method_reply());
      break;
    }
    case kMsgRequestError: {
      mutable_msg_request_error()->::perfetto::ipc::Frame_RequestError::MergeFrom(from.msg_request_error());
      break;
    }
    case MSG_NOT_SET: {
      break;
    }
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_request_id()) {
      set_request_id(from.request_id());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void Frame::CopyFrom(const Frame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.ipc.Frame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Frame::IsInitialized() const {

  return true;
}

void Frame::Swap(Frame* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Frame::InternalSwap(Frame* other) {
  std::swap(request_id_, other->request_id_);
  data_for_testing_.UnsafeArenaSwap(&other->data_for_testing_);
  std::swap(msg_, other->msg_);
  std::swap(_oneof_case_[0], other->_oneof_case_[0]);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Frame::GetTypeName() const {
  return "perfetto.ipc.Frame";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Frame_BindService

// optional string service_name = 1;
bool Frame_BindService::has_service_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Frame_BindService::set_has_service_name() {
  _has_bits_[0] |= 0x00000001u;
}
void Frame_BindService::clear_has_service_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void Frame_BindService::clear_service_name() {
  service_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_service_name();
}
 const ::std::string& Frame_BindService::service_name() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.BindService.service_name)
  return service_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Frame_BindService::set_service_name(const ::std::string& value) {
  set_has_service_name();
  service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.ipc.Frame.BindService.service_name)
}
 void Frame_BindService::set_service_name(const char* value) {
  set_has_service_name();
  service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.ipc.Frame.BindService.service_name)
}
 void Frame_BindService::set_service_name(const char* value, size_t size) {
  set_has_service_name();
  service_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.ipc.Frame.BindService.service_name)
}
 ::std::string* Frame_BindService::mutable_service_name() {
  set_has_service_name();
  // @@protoc_insertion_point(field_mutable:perfetto.ipc.Frame.BindService.service_name)
  return service_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Frame_BindService::release_service_name() {
  // @@protoc_insertion_point(field_release:perfetto.ipc.Frame.BindService.service_name)
  clear_has_service_name();
  return service_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Frame_BindService::set_allocated_service_name(::std::string* service_name) {
  if (service_name != NULL) {
    set_has_service_name();
  } else {
    clear_has_service_name();
  }
  service_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), service_name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.ipc.Frame.BindService.service_name)
}

// -------------------------------------------------------------------

// Frame_BindServiceReply_MethodInfo

// optional uint32 id = 1;
bool Frame_BindServiceReply_MethodInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Frame_BindServiceReply_MethodInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
void Frame_BindServiceReply_MethodInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void Frame_BindServiceReply_MethodInfo::clear_id() {
  id_ = 0u;
  clear_has_id();
}
 ::google::protobuf::uint32 Frame_BindServiceReply_MethodInfo::id() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.BindServiceReply.MethodInfo.id)
  return id_;
}
 void Frame_BindServiceReply_MethodInfo::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.ipc.Frame.BindServiceReply.MethodInfo.id)
}

// optional string name = 2;
bool Frame_BindServiceReply_MethodInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Frame_BindServiceReply_MethodInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
void Frame_BindServiceReply_MethodInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
void Frame_BindServiceReply_MethodInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
 const ::std::string& Frame_BindServiceReply_MethodInfo::name() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.BindServiceReply.MethodInfo.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Frame_BindServiceReply_MethodInfo::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.ipc.Frame.BindServiceReply.MethodInfo.name)
}
 void Frame_BindServiceReply_MethodInfo::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.ipc.Frame.BindServiceReply.MethodInfo.name)
}
 void Frame_BindServiceReply_MethodInfo::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.ipc.Frame.BindServiceReply.MethodInfo.name)
}
 ::std::string* Frame_BindServiceReply_MethodInfo::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:perfetto.ipc.Frame.BindServiceReply.MethodInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Frame_BindServiceReply_MethodInfo::release_name() {
  // @@protoc_insertion_point(field_release:perfetto.ipc.Frame.BindServiceReply.MethodInfo.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Frame_BindServiceReply_MethodInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.ipc.Frame.BindServiceReply.MethodInfo.name)
}

// -------------------------------------------------------------------

// Frame_BindServiceReply

// optional bool success = 1;
bool Frame_BindServiceReply::has_success() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Frame_BindServiceReply::set_has_success() {
  _has_bits_[0] |= 0x00000001u;
}
void Frame_BindServiceReply::clear_has_success() {
  _has_bits_[0] &= ~0x00000001u;
}
void Frame_BindServiceReply::clear_success() {
  success_ = false;
  clear_has_success();
}
 bool Frame_BindServiceReply::success() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.BindServiceReply.success)
  return success_;
}
 void Frame_BindServiceReply::set_success(bool value) {
  set_has_success();
  success_ = value;
  // @@protoc_insertion_point(field_set:perfetto.ipc.Frame.BindServiceReply.success)
}

// optional uint32 service_id = 2;
bool Frame_BindServiceReply::has_service_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Frame_BindServiceReply::set_has_service_id() {
  _has_bits_[0] |= 0x00000002u;
}
void Frame_BindServiceReply::clear_has_service_id() {
  _has_bits_[0] &= ~0x00000002u;
}
void Frame_BindServiceReply::clear_service_id() {
  service_id_ = 0u;
  clear_has_service_id();
}
 ::google::protobuf::uint32 Frame_BindServiceReply::service_id() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.BindServiceReply.service_id)
  return service_id_;
}
 void Frame_BindServiceReply::set_service_id(::google::protobuf::uint32 value) {
  set_has_service_id();
  service_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.ipc.Frame.BindServiceReply.service_id)
}

// repeated .perfetto.ipc.Frame.BindServiceReply.MethodInfo methods = 3;
int Frame_BindServiceReply::methods_size() const {
  return methods_.size();
}
void Frame_BindServiceReply::clear_methods() {
  methods_.Clear();
}
const ::perfetto::ipc::Frame_BindServiceReply_MethodInfo& Frame_BindServiceReply::methods(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.BindServiceReply.methods)
  return methods_.Get(index);
}
::perfetto::ipc::Frame_BindServiceReply_MethodInfo* Frame_BindServiceReply::mutable_methods(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.ipc.Frame.BindServiceReply.methods)
  return methods_.Mutable(index);
}
::perfetto::ipc::Frame_BindServiceReply_MethodInfo* Frame_BindServiceReply::add_methods() {
  // @@protoc_insertion_point(field_add:perfetto.ipc.Frame.BindServiceReply.methods)
  return methods_.Add();
}
::google::protobuf::RepeatedPtrField< ::perfetto::ipc::Frame_BindServiceReply_MethodInfo >*
Frame_BindServiceReply::mutable_methods() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.ipc.Frame.BindServiceReply.methods)
  return &methods_;
}
const ::google::protobuf::RepeatedPtrField< ::perfetto::ipc::Frame_BindServiceReply_MethodInfo >&
Frame_BindServiceReply::methods() const {
  // @@protoc_insertion_point(field_list:perfetto.ipc.Frame.BindServiceReply.methods)
  return methods_;
}

// -------------------------------------------------------------------

// Frame_InvokeMethod

// optional uint32 service_id = 1;
bool Frame_InvokeMethod::has_service_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Frame_InvokeMethod::set_has_service_id() {
  _has_bits_[0] |= 0x00000001u;
}
void Frame_InvokeMethod::clear_has_service_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void Frame_InvokeMethod::clear_service_id() {
  service_id_ = 0u;
  clear_has_service_id();
}
 ::google::protobuf::uint32 Frame_InvokeMethod::service_id() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.InvokeMethod.service_id)
  return service_id_;
}
 void Frame_InvokeMethod::set_service_id(::google::protobuf::uint32 value) {
  set_has_service_id();
  service_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.ipc.Frame.InvokeMethod.service_id)
}

// optional uint32 method_id = 2;
bool Frame_InvokeMethod::has_method_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Frame_InvokeMethod::set_has_method_id() {
  _has_bits_[0] |= 0x00000002u;
}
void Frame_InvokeMethod::clear_has_method_id() {
  _has_bits_[0] &= ~0x00000002u;
}
void Frame_InvokeMethod::clear_method_id() {
  method_id_ = 0u;
  clear_has_method_id();
}
 ::google::protobuf::uint32 Frame_InvokeMethod::method_id() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.InvokeMethod.method_id)
  return method_id_;
}
 void Frame_InvokeMethod::set_method_id(::google::protobuf::uint32 value) {
  set_has_method_id();
  method_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.ipc.Frame.InvokeMethod.method_id)
}

// optional bytes args_proto = 3;
bool Frame_InvokeMethod::has_args_proto() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Frame_InvokeMethod::set_has_args_proto() {
  _has_bits_[0] |= 0x00000004u;
}
void Frame_InvokeMethod::clear_has_args_proto() {
  _has_bits_[0] &= ~0x00000004u;
}
void Frame_InvokeMethod::clear_args_proto() {
  args_proto_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_args_proto();
}
 const ::std::string& Frame_InvokeMethod::args_proto() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.InvokeMethod.args_proto)
  return args_proto_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Frame_InvokeMethod::set_args_proto(const ::std::string& value) {
  set_has_args_proto();
  args_proto_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.ipc.Frame.InvokeMethod.args_proto)
}
 void Frame_InvokeMethod::set_args_proto(const char* value) {
  set_has_args_proto();
  args_proto_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.ipc.Frame.InvokeMethod.args_proto)
}
 void Frame_InvokeMethod::set_args_proto(const void* value, size_t size) {
  set_has_args_proto();
  args_proto_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.ipc.Frame.InvokeMethod.args_proto)
}
 ::std::string* Frame_InvokeMethod::mutable_args_proto() {
  set_has_args_proto();
  // @@protoc_insertion_point(field_mutable:perfetto.ipc.Frame.InvokeMethod.args_proto)
  return args_proto_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Frame_InvokeMethod::release_args_proto() {
  // @@protoc_insertion_point(field_release:perfetto.ipc.Frame.InvokeMethod.args_proto)
  clear_has_args_proto();
  return args_proto_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Frame_InvokeMethod::set_allocated_args_proto(::std::string* args_proto) {
  if (args_proto != NULL) {
    set_has_args_proto();
  } else {
    clear_has_args_proto();
  }
  args_proto_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), args_proto);
  // @@protoc_insertion_point(field_set_allocated:perfetto.ipc.Frame.InvokeMethod.args_proto)
}

// optional bool drop_reply = 4;
bool Frame_InvokeMethod::has_drop_reply() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Frame_InvokeMethod::set_has_drop_reply() {
  _has_bits_[0] |= 0x00000008u;
}
void Frame_InvokeMethod::clear_has_drop_reply() {
  _has_bits_[0] &= ~0x00000008u;
}
void Frame_InvokeMethod::clear_drop_reply() {
  drop_reply_ = false;
  clear_has_drop_reply();
}
 bool Frame_InvokeMethod::drop_reply() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.InvokeMethod.drop_reply)
  return drop_reply_;
}
 void Frame_InvokeMethod::set_drop_reply(bool value) {
  set_has_drop_reply();
  drop_reply_ = value;
  // @@protoc_insertion_point(field_set:perfetto.ipc.Frame.InvokeMethod.drop_reply)
}

// -------------------------------------------------------------------

// Frame_InvokeMethodReply

// optional bool success = 1;
bool Frame_InvokeMethodReply::has_success() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Frame_InvokeMethodReply::set_has_success() {
  _has_bits_[0] |= 0x00000001u;
}
void Frame_InvokeMethodReply::clear_has_success() {
  _has_bits_[0] &= ~0x00000001u;
}
void Frame_InvokeMethodReply::clear_success() {
  success_ = false;
  clear_has_success();
}
 bool Frame_InvokeMethodReply::success() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.InvokeMethodReply.success)
  return success_;
}
 void Frame_InvokeMethodReply::set_success(bool value) {
  set_has_success();
  success_ = value;
  // @@protoc_insertion_point(field_set:perfetto.ipc.Frame.InvokeMethodReply.success)
}

// optional bool has_more = 2;
bool Frame_InvokeMethodReply::has_has_more() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Frame_InvokeMethodReply::set_has_has_more() {
  _has_bits_[0] |= 0x00000002u;
}
void Frame_InvokeMethodReply::clear_has_has_more() {
  _has_bits_[0] &= ~0x00000002u;
}
void Frame_InvokeMethodReply::clear_has_more() {
  has_more_ = false;
  clear_has_has_more();
}
 bool Frame_InvokeMethodReply::has_more() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.InvokeMethodReply.has_more)
  return has_more_;
}
 void Frame_InvokeMethodReply::set_has_more(bool value) {
  set_has_has_more();
  has_more_ = value;
  // @@protoc_insertion_point(field_set:perfetto.ipc.Frame.InvokeMethodReply.has_more)
}

// optional bytes reply_proto = 3;
bool Frame_InvokeMethodReply::has_reply_proto() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Frame_InvokeMethodReply::set_has_reply_proto() {
  _has_bits_[0] |= 0x00000004u;
}
void Frame_InvokeMethodReply::clear_has_reply_proto() {
  _has_bits_[0] &= ~0x00000004u;
}
void Frame_InvokeMethodReply::clear_reply_proto() {
  reply_proto_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_reply_proto();
}
 const ::std::string& Frame_InvokeMethodReply::reply_proto() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.InvokeMethodReply.reply_proto)
  return reply_proto_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Frame_InvokeMethodReply::set_reply_proto(const ::std::string& value) {
  set_has_reply_proto();
  reply_proto_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.ipc.Frame.InvokeMethodReply.reply_proto)
}
 void Frame_InvokeMethodReply::set_reply_proto(const char* value) {
  set_has_reply_proto();
  reply_proto_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.ipc.Frame.InvokeMethodReply.reply_proto)
}
 void Frame_InvokeMethodReply::set_reply_proto(const void* value, size_t size) {
  set_has_reply_proto();
  reply_proto_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.ipc.Frame.InvokeMethodReply.reply_proto)
}
 ::std::string* Frame_InvokeMethodReply::mutable_reply_proto() {
  set_has_reply_proto();
  // @@protoc_insertion_point(field_mutable:perfetto.ipc.Frame.InvokeMethodReply.reply_proto)
  return reply_proto_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Frame_InvokeMethodReply::release_reply_proto() {
  // @@protoc_insertion_point(field_release:perfetto.ipc.Frame.InvokeMethodReply.reply_proto)
  clear_has_reply_proto();
  return reply_proto_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Frame_InvokeMethodReply::set_allocated_reply_proto(::std::string* reply_proto) {
  if (reply_proto != NULL) {
    set_has_reply_proto();
  } else {
    clear_has_reply_proto();
  }
  reply_proto_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reply_proto);
  // @@protoc_insertion_point(field_set_allocated:perfetto.ipc.Frame.InvokeMethodReply.reply_proto)
}

// -------------------------------------------------------------------

// Frame_RequestError

// optional string error = 1;
bool Frame_RequestError::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Frame_RequestError::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
void Frame_RequestError::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
void Frame_RequestError::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error();
}
 const ::std::string& Frame_RequestError::error() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.RequestError.error)
  return error_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Frame_RequestError::set_error(const ::std::string& value) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.ipc.Frame.RequestError.error)
}
 void Frame_RequestError::set_error(const char* value) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.ipc.Frame.RequestError.error)
}
 void Frame_RequestError::set_error(const char* value, size_t size) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.ipc.Frame.RequestError.error)
}
 ::std::string* Frame_RequestError::mutable_error() {
  set_has_error();
  // @@protoc_insertion_point(field_mutable:perfetto.ipc.Frame.RequestError.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Frame_RequestError::release_error() {
  // @@protoc_insertion_point(field_release:perfetto.ipc.Frame.RequestError.error)
  clear_has_error();
  return error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Frame_RequestError::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    set_has_error();
  } else {
    clear_has_error();
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:perfetto.ipc.Frame.RequestError.error)
}

// -------------------------------------------------------------------

// Frame

// optional uint64 request_id = 2;
bool Frame::has_request_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Frame::set_has_request_id() {
  _has_bits_[0] |= 0x00000001u;
}
void Frame::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void Frame::clear_request_id() {
  request_id_ = GOOGLE_ULONGLONG(0);
  clear_has_request_id();
}
 ::google::protobuf::uint64 Frame::request_id() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.request_id)
  return request_id_;
}
 void Frame::set_request_id(::google::protobuf::uint64 value) {
  set_has_request_id();
  request_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.ipc.Frame.request_id)
}

// optional .perfetto.ipc.Frame.BindService msg_bind_service = 3;
bool Frame::has_msg_bind_service() const {
  return msg_case() == kMsgBindService;
}
void Frame::set_has_msg_bind_service() {
  _oneof_case_[0] = kMsgBindService;
}
void Frame::clear_msg_bind_service() {
  if (has_msg_bind_service()) {
    delete msg_.msg_bind_service_;
    clear_has_msg();
  }
}
 const ::perfetto::ipc::Frame_BindService& Frame::msg_bind_service() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.msg_bind_service)
  return has_msg_bind_service()
      ? *msg_.msg_bind_service_
      : ::perfetto::ipc::Frame_BindService::default_instance();
}
::perfetto::ipc::Frame_BindService* Frame::mutable_msg_bind_service() {
  if (!has_msg_bind_service()) {
    clear_msg();
    set_has_msg_bind_service();
    msg_.msg_bind_service_ = new ::perfetto::ipc::Frame_BindService;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.ipc.Frame.msg_bind_service)
  return msg_.msg_bind_service_;
}
::perfetto::ipc::Frame_BindService* Frame::release_msg_bind_service() {
  // @@protoc_insertion_point(field_release:perfetto.ipc.Frame.msg_bind_service)
  if (has_msg_bind_service()) {
    clear_has_msg();
    ::perfetto::ipc::Frame_BindService* temp = msg_.msg_bind_service_;
    msg_.msg_bind_service_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Frame::set_allocated_msg_bind_service(::perfetto::ipc::Frame_BindService* msg_bind_service) {
  clear_msg();
  if (msg_bind_service) {
    set_has_msg_bind_service();
    msg_.msg_bind_service_ = msg_bind_service;
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.ipc.Frame.msg_bind_service)
}

// optional .perfetto.ipc.Frame.BindServiceReply msg_bind_service_reply = 4;
bool Frame::has_msg_bind_service_reply() const {
  return msg_case() == kMsgBindServiceReply;
}
void Frame::set_has_msg_bind_service_reply() {
  _oneof_case_[0] = kMsgBindServiceReply;
}
void Frame::clear_msg_bind_service_reply() {
  if (has_msg_bind_service_reply()) {
    delete msg_.msg_bind_service_reply_;
    clear_has_msg();
  }
}
 const ::perfetto::ipc::Frame_BindServiceReply& Frame::msg_bind_service_reply() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.msg_bind_service_reply)
  return has_msg_bind_service_reply()
      ? *msg_.msg_bind_service_reply_
      : ::perfetto::ipc::Frame_BindServiceReply::default_instance();
}
::perfetto::ipc::Frame_BindServiceReply* Frame::mutable_msg_bind_service_reply() {
  if (!has_msg_bind_service_reply()) {
    clear_msg();
    set_has_msg_bind_service_reply();
    msg_.msg_bind_service_reply_ = new ::perfetto::ipc::Frame_BindServiceReply;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.ipc.Frame.msg_bind_service_reply)
  return msg_.msg_bind_service_reply_;
}
::perfetto::ipc::Frame_BindServiceReply* Frame::release_msg_bind_service_reply() {
  // @@protoc_insertion_point(field_release:perfetto.ipc.Frame.msg_bind_service_reply)
  if (has_msg_bind_service_reply()) {
    clear_has_msg();
    ::perfetto::ipc::Frame_BindServiceReply* temp = msg_.msg_bind_service_reply_;
    msg_.msg_bind_service_reply_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Frame::set_allocated_msg_bind_service_reply(::perfetto::ipc::Frame_BindServiceReply* msg_bind_service_reply) {
  clear_msg();
  if (msg_bind_service_reply) {
    set_has_msg_bind_service_reply();
    msg_.msg_bind_service_reply_ = msg_bind_service_reply;
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.ipc.Frame.msg_bind_service_reply)
}

// optional .perfetto.ipc.Frame.InvokeMethod msg_invoke_method = 5;
bool Frame::has_msg_invoke_method() const {
  return msg_case() == kMsgInvokeMethod;
}
void Frame::set_has_msg_invoke_method() {
  _oneof_case_[0] = kMsgInvokeMethod;
}
void Frame::clear_msg_invoke_method() {
  if (has_msg_invoke_method()) {
    delete msg_.msg_invoke_method_;
    clear_has_msg();
  }
}
 const ::perfetto::ipc::Frame_InvokeMethod& Frame::msg_invoke_method() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.msg_invoke_method)
  return has_msg_invoke_method()
      ? *msg_.msg_invoke_method_
      : ::perfetto::ipc::Frame_InvokeMethod::default_instance();
}
::perfetto::ipc::Frame_InvokeMethod* Frame::mutable_msg_invoke_method() {
  if (!has_msg_invoke_method()) {
    clear_msg();
    set_has_msg_invoke_method();
    msg_.msg_invoke_method_ = new ::perfetto::ipc::Frame_InvokeMethod;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.ipc.Frame.msg_invoke_method)
  return msg_.msg_invoke_method_;
}
::perfetto::ipc::Frame_InvokeMethod* Frame::release_msg_invoke_method() {
  // @@protoc_insertion_point(field_release:perfetto.ipc.Frame.msg_invoke_method)
  if (has_msg_invoke_method()) {
    clear_has_msg();
    ::perfetto::ipc::Frame_InvokeMethod* temp = msg_.msg_invoke_method_;
    msg_.msg_invoke_method_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Frame::set_allocated_msg_invoke_method(::perfetto::ipc::Frame_InvokeMethod* msg_invoke_method) {
  clear_msg();
  if (msg_invoke_method) {
    set_has_msg_invoke_method();
    msg_.msg_invoke_method_ = msg_invoke_method;
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.ipc.Frame.msg_invoke_method)
}

// optional .perfetto.ipc.Frame.InvokeMethodReply msg_invoke_method_reply = 6;
bool Frame::has_msg_invoke_method_reply() const {
  return msg_case() == kMsgInvokeMethodReply;
}
void Frame::set_has_msg_invoke_method_reply() {
  _oneof_case_[0] = kMsgInvokeMethodReply;
}
void Frame::clear_msg_invoke_method_reply() {
  if (has_msg_invoke_method_reply()) {
    delete msg_.msg_invoke_method_reply_;
    clear_has_msg();
  }
}
 const ::perfetto::ipc::Frame_InvokeMethodReply& Frame::msg_invoke_method_reply() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.msg_invoke_method_reply)
  return has_msg_invoke_method_reply()
      ? *msg_.msg_invoke_method_reply_
      : ::perfetto::ipc::Frame_InvokeMethodReply::default_instance();
}
::perfetto::ipc::Frame_InvokeMethodReply* Frame::mutable_msg_invoke_method_reply() {
  if (!has_msg_invoke_method_reply()) {
    clear_msg();
    set_has_msg_invoke_method_reply();
    msg_.msg_invoke_method_reply_ = new ::perfetto::ipc::Frame_InvokeMethodReply;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.ipc.Frame.msg_invoke_method_reply)
  return msg_.msg_invoke_method_reply_;
}
::perfetto::ipc::Frame_InvokeMethodReply* Frame::release_msg_invoke_method_reply() {
  // @@protoc_insertion_point(field_release:perfetto.ipc.Frame.msg_invoke_method_reply)
  if (has_msg_invoke_method_reply()) {
    clear_has_msg();
    ::perfetto::ipc::Frame_InvokeMethodReply* temp = msg_.msg_invoke_method_reply_;
    msg_.msg_invoke_method_reply_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Frame::set_allocated_msg_invoke_method_reply(::perfetto::ipc::Frame_InvokeMethodReply* msg_invoke_method_reply) {
  clear_msg();
  if (msg_invoke_method_reply) {
    set_has_msg_invoke_method_reply();
    msg_.msg_invoke_method_reply_ = msg_invoke_method_reply;
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.ipc.Frame.msg_invoke_method_reply)
}

// optional .perfetto.ipc.Frame.RequestError msg_request_error = 7;
bool Frame::has_msg_request_error() const {
  return msg_case() == kMsgRequestError;
}
void Frame::set_has_msg_request_error() {
  _oneof_case_[0] = kMsgRequestError;
}
void Frame::clear_msg_request_error() {
  if (has_msg_request_error()) {
    delete msg_.msg_request_error_;
    clear_has_msg();
  }
}
 const ::perfetto::ipc::Frame_RequestError& Frame::msg_request_error() const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.msg_request_error)
  return has_msg_request_error()
      ? *msg_.msg_request_error_
      : ::perfetto::ipc::Frame_RequestError::default_instance();
}
::perfetto::ipc::Frame_RequestError* Frame::mutable_msg_request_error() {
  if (!has_msg_request_error()) {
    clear_msg();
    set_has_msg_request_error();
    msg_.msg_request_error_ = new ::perfetto::ipc::Frame_RequestError;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.ipc.Frame.msg_request_error)
  return msg_.msg_request_error_;
}
::perfetto::ipc::Frame_RequestError* Frame::release_msg_request_error() {
  // @@protoc_insertion_point(field_release:perfetto.ipc.Frame.msg_request_error)
  if (has_msg_request_error()) {
    clear_has_msg();
    ::perfetto::ipc::Frame_RequestError* temp = msg_.msg_request_error_;
    msg_.msg_request_error_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Frame::set_allocated_msg_request_error(::perfetto::ipc::Frame_RequestError* msg_request_error) {
  clear_msg();
  if (msg_request_error) {
    set_has_msg_request_error();
    msg_.msg_request_error_ = msg_request_error;
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.ipc.Frame.msg_request_error)
}

// repeated bytes data_for_testing = 1;
int Frame::data_for_testing_size() const {
  return data_for_testing_.size();
}
void Frame::clear_data_for_testing() {
  data_for_testing_.Clear();
}
 const ::std::string& Frame::data_for_testing(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.ipc.Frame.data_for_testing)
  return data_for_testing_.Get(index);
}
 ::std::string* Frame::mutable_data_for_testing(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.ipc.Frame.data_for_testing)
  return data_for_testing_.Mutable(index);
}
 void Frame::set_data_for_testing(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.ipc.Frame.data_for_testing)
  data_for_testing_.Mutable(index)->assign(value);
}
 void Frame::set_data_for_testing(int index, const char* value) {
  data_for_testing_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.ipc.Frame.data_for_testing)
}
 void Frame::set_data_for_testing(int index, const void* value, size_t size) {
  data_for_testing_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.ipc.Frame.data_for_testing)
}
 ::std::string* Frame::add_data_for_testing() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.ipc.Frame.data_for_testing)
  return data_for_testing_.Add();
}
 void Frame::add_data_for_testing(const ::std::string& value) {
  data_for_testing_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.ipc.Frame.data_for_testing)
}
 void Frame::add_data_for_testing(const char* value) {
  data_for_testing_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.ipc.Frame.data_for_testing)
}
 void Frame::add_data_for_testing(const void* value, size_t size) {
  data_for_testing_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.ipc.Frame.data_for_testing)
}
 const ::google::protobuf::RepeatedPtrField< ::std::string>&
Frame::data_for_testing() const {
  // @@protoc_insertion_point(field_list:perfetto.ipc.Frame.data_for_testing)
  return data_for_testing_;
}
 ::google::protobuf::RepeatedPtrField< ::std::string>*
Frame::mutable_data_for_testing() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.ipc.Frame.data_for_testing)
  return &data_for_testing_;
}

bool Frame::has_msg() const {
  return msg_case() != MSG_NOT_SET;
}
void Frame::clear_has_msg() {
  _oneof_case_[0] = MSG_NOT_SET;
}
Frame::MsgCase Frame::msg_case() const {
  return Frame::MsgCase(_oneof_case_[0]);
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace ipc
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)
// gen_amalgamated begin source: src/ipc/buffered_frame_deserializer.cc
// gen_amalgamated begin header: src/ipc/buffered_frame_deserializer.h
// gen_amalgamated begin header: include/perfetto/ext/ipc/basic_types.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_IPC_BASIC_TYPES_H_
#define INCLUDE_PERFETTO_EXT_IPC_BASIC_TYPES_H_

#include <stddef.h>
#include <stdint.h>
#include <sys/types.h>

namespace google {
namespace protobuf {
class MessageLite;
}  // namespace protobuf
}  // namespace google

namespace perfetto {
namespace ipc {

using ProtoMessage = ::google::protobuf::MessageLite;
using ServiceID = uint32_t;
using MethodID = uint32_t;
using ClientID = uint64_t;
using RequestID = uint64_t;

// This determines the maximum size allowed for an IPC message. Trying to send
// or receive a larger message will hit DCHECK(s) and auto-disconnect.
constexpr size_t kIPCBufferSize = 128 * 1024;

constexpr uid_t kInvalidUid = static_cast<uid_t>(-1);
constexpr pid_t kInvalidPid = static_cast<pid_t>(-1);

}  // namespace ipc
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_IPC_BASIC_TYPES_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef SRC_IPC_BUFFERED_FRAME_DESERIALIZER_H_
#define SRC_IPC_BUFFERED_FRAME_DESERIALIZER_H_

#include <stddef.h>

#include <list>
#include <memory>

#include <sys/mman.h>

// gen_amalgamated expanded: #include "perfetto/ext/base/paged_memory.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/utils.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/basic_types.h"

namespace perfetto {
namespace ipc {

class Frame;  // Defined in the protobuf autogenerated wire_protocol.pb.h.

// Deserializes incoming frames, taking care of buffering and tokenization.
// Used by both host and client to decode incoming frames.
//
// Which problem does it solve?
// ----------------------------
// The wire protocol is as follows:
// [32-bit frame size][proto-encoded Frame], e.g:
// [06 00 00 00][00 11 22 33 44 55 66]
// [02 00 00 00][AA BB]
// [04 00 00 00][CC DD EE FF]
// However, given that the socket works in SOCK_STREAM mode, the recv() calls
// might see the following:
// 06 00 00
// 00 00 11 22 33 44 55
// 66 02 00 00 00 ...
// This class takes care of buffering efficiently the data received, without
// making any assumption on how the incoming data will be chunked by the socket.
// For instance, it is possible that a recv() doesn't produce any frame (because
// it received only a part of the frame) or produces more than one frame.
//
// Usage
// -----
// Both host and client use this as follows:
//
// auto buf = rpc_frame_decoder.BeginReceive();
// size_t rsize = socket.recv(buf.first, buf.second);
// rpc_frame_decoder.EndReceive(rsize);
// while (Frame frame = rpc_frame_decoder.PopNextFrame()) {
//   ... process |frame|
// }
//
// Design goals:
// -------------
// - Optimize for the realistic case of each recv() receiving one or more
//   whole frames. In this case no memmove is performed.
// - Guarantee that frames lay in a virtually contiguous memory area.
//   This allows to use the protobuf-lite deserialization API (scattered
//   deserialization is supported only by libprotobuf-full).
// - Put a hard boundary to the size of the incoming buffer. This is to prevent
//   that a malicious sends an abnormally large frame and OOMs us.
// - Simplicity: just use a linear mmap region. No reallocations or scattering.
//   Takes care of madvise()-ing unused memory.

class BufferedFrameDeserializer {
 public:
  struct ReceiveBuffer {
    char* data;
    size_t size;
  };

  // |max_capacity| is overridable only for tests.
  explicit BufferedFrameDeserializer(size_t max_capacity = kIPCBufferSize);
  ~BufferedFrameDeserializer();

  // This function doesn't really belong here as it does Serialization, unlike
  // the rest of this class. However it is so small and has so many dependencies
  // in common that doesn't justify having its own class.
  static std::string Serialize(const Frame&);

  // Returns a buffer that can be passed to recv(). The buffer is deliberately
  // not initialized.
  ReceiveBuffer BeginReceive();

  // Must be called soon after BeginReceive().
  // |recv_size| is the number of valid bytes that have been written into the
  // buffer previously returned by BeginReceive() (the return value of recv()).
  // Returns false if a header > |max_capacity| is received, in which case the
  // caller is expected to shutdown the socket and terminate the ipc.
  bool EndReceive(size_t recv_size) PERFETTO_WARN_UNUSED_RESULT;

  // Decodes and returns the next decoded frame in the buffer if any, nullptr
  // if no further frames have been decoded.
  std::unique_ptr<Frame> PopNextFrame();

  size_t capacity() const { return capacity_; }
  size_t size() const { return size_; }

 private:
  BufferedFrameDeserializer(const BufferedFrameDeserializer&) = delete;
  BufferedFrameDeserializer& operator=(const BufferedFrameDeserializer&) =
      delete;

  // If a valid frame is decoded it is added to |decoded_frames_|.
  void DecodeFrame(const char*, size_t);

  char* buf() { return reinterpret_cast<char*>(buf_.Get()); }

  base::PagedMemory buf_;
  const size_t capacity_ = 0;  // sizeof(|buf_|).

  // THe number of bytes in |buf_| that contain valid data (as a result of
  // EndReceive()). This is always <= |capacity_|.
  size_t size_ = 0;

  std::list<std::unique_ptr<Frame>> decoded_frames_;
};

}  // namespace ipc
}  // namespace perfetto

#endif  // SRC_IPC_BUFFERED_FRAME_DESERIALIZER_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "src/ipc/buffered_frame_deserializer.h"

#include <inttypes.h>

#include <algorithm>
#include <type_traits>
#include <utility>

#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/utils.h"

// gen_amalgamated expanded: #include "src/ipc/wire_protocol.pb.h"

namespace perfetto {
namespace ipc {

namespace {

// The header is just the number of bytes of the Frame protobuf message.
constexpr size_t kHeaderSize = sizeof(uint32_t);
}  // namespace

BufferedFrameDeserializer::BufferedFrameDeserializer(size_t max_capacity)
    : capacity_(max_capacity) {
  PERFETTO_CHECK(max_capacity % base::kPageSize == 0);
  PERFETTO_CHECK(max_capacity > base::kPageSize);
}

BufferedFrameDeserializer::~BufferedFrameDeserializer() = default;

BufferedFrameDeserializer::ReceiveBuffer
BufferedFrameDeserializer::BeginReceive() {
  // Upon the first recv initialize the buffer to the max message size but
  // release the physical memory for all but the first page. The kernel will
  // automatically give us physical pages back as soon as we page-fault on them.
  if (!buf_.IsValid()) {
    PERFETTO_DCHECK(size_ == 0);
    // TODO(eseckler): Don't commit all of the buffer at once on Windows.
    buf_ = base::PagedMemory::Allocate(capacity_);

    // Surely we are going to use at least the first page, but we may not need
    // the rest for a bit.
    buf_.AdviseDontNeed(buf() + base::kPageSize, capacity_ - base::kPageSize);
  }

  PERFETTO_CHECK(capacity_ > size_);
  return ReceiveBuffer{buf() + size_, capacity_ - size_};
}

bool BufferedFrameDeserializer::EndReceive(size_t recv_size) {
  PERFETTO_CHECK(recv_size + size_ <= capacity_);
  size_ += recv_size;

  // At this point the contents buf_ can contain:
  // A) Only a fragment of the header (the size of the frame). E.g.,
  //    03 00 00 (the header is 4 bytes, one is missing).
  //
  // B) A header and a part of the frame. E.g.,
  //     05 00 00 00         11 22 33
  //    [ header, size=5 ]  [ Partial frame ]
  //
  // C) One or more complete header+frame. E.g.,
  //     05 00 00 00         11 22 33 44 55   03 00 00 00        AA BB CC
  //    [ header, size=5 ]  [ Whole frame ]  [ header, size=3 ] [ Whole frame ]
  //
  // D) Some complete header+frame(s) and a partial header or frame (C + A/B).
  //
  // C Is the more likely case and the one we are optimizing for. A, B, D can
  // happen because of the streaming nature of the socket.
  // The invariant of this function is that, when it returns, buf_ is either
  // empty (we drained all the complete frames) or starts with the header of the
  // next, still incomplete, frame.

  size_t consumed_size = 0;
  for (;;) {
    if (size_ < consumed_size + kHeaderSize)
      break;  // Case A, not enough data to read even the header.

    // Read the header into |payload_size|.
    uint32_t payload_size = 0;
    const char* rd_ptr = buf() + consumed_size;
    memcpy(base::AssumeLittleEndian(&payload_size), rd_ptr, kHeaderSize);

    // Saturate the |payload_size| to prevent overflows. The > capacity_ check
    // below will abort the parsing.
    size_t next_frame_size =
        std::min(static_cast<size_t>(payload_size), capacity_);
    next_frame_size += kHeaderSize;
    rd_ptr += kHeaderSize;

    if (size_ < consumed_size + next_frame_size) {
      // Case B. We got the header but not the whole frame.
      if (next_frame_size > capacity_) {
        // The caller is expected to shut down the socket and give up at this
        // point. If it doesn't do that and insists going on at some point it
        // will hit the capacity check in BeginReceive().
        PERFETTO_DLOG("Frame too large (size %zu)", next_frame_size);
        return false;
      }
      break;
    }

    // Case C. We got at least one header and whole frame.
    DecodeFrame(rd_ptr, payload_size);
    consumed_size += next_frame_size;
  }

  PERFETTO_DCHECK(consumed_size <= size_);
  if (consumed_size > 0) {
    // Shift out the consumed data from the buffer. In the typical case (C)
    // there is nothing to shift really, just setting size_ = 0 is enough.
    // Shifting is only for the (unlikely) case D.
    size_ -= consumed_size;
    if (size_ > 0) {
      // Case D. We consumed some frames but there is a leftover at the end of
      // the buffer. Shift out the consumed bytes, so that on the next round
      // |buf_| starts with the header of the next unconsumed frame.
      const char* move_begin = buf() + consumed_size;
      PERFETTO_CHECK(move_begin > buf());
      PERFETTO_CHECK(move_begin + size_ <= buf() + capacity_);
      memmove(buf(), move_begin, size_);
    }
    // If we just finished decoding a large frame that used more than one page,
    // release the extra memory in the buffer. Large frames should be quite
    // rare.
    if (consumed_size > base::kPageSize) {
      size_t size_rounded_up = (size_ / base::kPageSize + 1) * base::kPageSize;
      if (size_rounded_up < capacity_) {
        char* madvise_begin = buf() + size_rounded_up;
        const size_t madvise_size = capacity_ - size_rounded_up;
        PERFETTO_CHECK(madvise_begin > buf() + size_);
        PERFETTO_CHECK(madvise_begin + madvise_size <= buf() + capacity_);
        buf_.AdviseDontNeed(madvise_begin, madvise_size);
      }
    }
  }
  // At this point |size_| == 0 for case C, > 0 for cases A, B, D.
  return true;
}

std::unique_ptr<Frame> BufferedFrameDeserializer::PopNextFrame() {
  if (decoded_frames_.empty())
    return nullptr;
  std::unique_ptr<Frame> frame = std::move(decoded_frames_.front());
  decoded_frames_.pop_front();
  return frame;
}

void BufferedFrameDeserializer::DecodeFrame(const char* data, size_t size) {
  if (size == 0)
    return;
  std::unique_ptr<Frame> frame(new Frame);
  const int sz = static_cast<int>(size);
  ::google::protobuf::io::ArrayInputStream stream(data, sz);
  if (frame->ParseFromBoundedZeroCopyStream(&stream, sz))
    decoded_frames_.push_back(std::move(frame));
}

// static
std::string BufferedFrameDeserializer::Serialize(const Frame& frame) {
  std::string buf;
  buf.reserve(1024);  // Just an educated guess to avoid trivial expansions.
  buf.insert(0, kHeaderSize, 0);  // Reserve the space for the header.
  frame.AppendToString(&buf);
  const uint32_t payload_size = static_cast<uint32_t>(buf.size() - kHeaderSize);
  PERFETTO_DCHECK(payload_size == static_cast<uint32_t>(frame.GetCachedSize()));
  // Don't send messages larger than what the receiver can handle.
  PERFETTO_DCHECK(kHeaderSize + payload_size <= kIPCBufferSize);
  char header[kHeaderSize];
  memcpy(header, base::AssumeLittleEndian(&payload_size), kHeaderSize);
  buf.replace(0, kHeaderSize, header, kHeaderSize);
  return buf;
}

}  // namespace ipc
}  // namespace perfetto
// gen_amalgamated begin source: src/ipc/client_impl.cc
// gen_amalgamated begin header: src/ipc/client_impl.h
// gen_amalgamated begin header: include/perfetto/ext/ipc/client.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_IPC_CLIENT_H_
#define INCLUDE_PERFETTO_EXT_IPC_CLIENT_H_

#include <functional>
#include <memory>

// gen_amalgamated expanded: #include "perfetto/ext/base/scoped_file.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/weak_ptr.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/basic_types.h"

namespace perfetto {

namespace base {
class TaskRunner;
}  // namespace base

namespace ipc {
class ServiceProxy;

// The client-side class that talks to the host over the socket and multiplexes
// requests coming from the various autogenerated ServiceProxy stubs.
// This is meant to be used by the user code as follows:
// auto client = Client::CreateInstance("socket_name", task_runner);
// std::unique_ptr<GreeterService> svc(new GreeterService());
// client.BindService(svc);
// svc.OnConnect([] () {
//    svc.SayHello(..., ...);
// });
class Client {
 public:
  static std::unique_ptr<Client> CreateInstance(const char* socket_name,
                                                base::TaskRunner*);
  virtual ~Client();

  virtual void BindService(base::WeakPtr<ServiceProxy>) = 0;

  // There is no need to call this method explicitly. Destroying the
  // ServiceProxy instance is sufficient and will automatically unbind it. This
  // method is exposed only for the ServiceProxy destructor.
  virtual void UnbindService(ServiceID) = 0;

  // Returns (with move semantics) the last file descriptor received on the IPC
  // channel. No buffering is performed: if a service sends two file descriptors
  // and the caller doesn't read them immediately, the first one will be
  // automatically closed when the second is received (and will hit a DCHECK in
  // debug builds).
  virtual base::ScopedFile TakeReceivedFD() = 0;
};

}  // namespace ipc
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_IPC_CLIENT_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef SRC_IPC_CLIENT_IMPL_H_
#define SRC_IPC_CLIENT_IMPL_H_

// gen_amalgamated expanded: #include "perfetto/base/task_runner.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/scoped_file.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/unix_socket.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/client.h"
// gen_amalgamated expanded: #include "src/ipc/buffered_frame_deserializer.h"

// gen_amalgamated expanded: #include "src/ipc/wire_protocol.pb.h"

#include <list>
#include <map>
#include <memory>

namespace perfetto {

namespace base {
class TaskRunner;
}  // namespace base

namespace ipc {

class ServiceDescriptor;

class ClientImpl : public Client, public base::UnixSocket::EventListener {
 public:
  ClientImpl(const char* socket_name, base::TaskRunner*);
  ~ClientImpl() override;

  // Client implementation.
  void BindService(base::WeakPtr<ServiceProxy>) override;
  void UnbindService(ServiceID) override;
  base::ScopedFile TakeReceivedFD() override;

  // base::UnixSocket::EventListener implementation.
  void OnConnect(base::UnixSocket*, bool connected) override;
  void OnDisconnect(base::UnixSocket*) override;
  void OnDataAvailable(base::UnixSocket*) override;

  RequestID BeginInvoke(ServiceID,
                        const std::string& method_name,
                        MethodID remote_method_id,
                        const ProtoMessage& method_args,
                        bool drop_reply,
                        base::WeakPtr<ServiceProxy>,
                        int fd = -1);

 private:
  struct QueuedRequest {
    QueuedRequest();
    int type = 0;  // From Frame::msg_case(), see wire_protocol.proto.
    RequestID request_id = 0;
    base::WeakPtr<ServiceProxy> service_proxy;

    // Only for type == kMsgInvokeMethod.
    std::string method_name;
  };

  ClientImpl(const ClientImpl&) = delete;
  ClientImpl& operator=(const ClientImpl&) = delete;

  bool SendFrame(const Frame&, int fd = -1);
  void OnFrameReceived(const Frame&);
  void OnBindServiceReply(QueuedRequest, const Frame::BindServiceReply&);
  void OnInvokeMethodReply(QueuedRequest, const Frame::InvokeMethodReply&);

  bool invoking_method_reply_ = false;
  std::unique_ptr<base::UnixSocket> sock_;
  base::TaskRunner* const task_runner_;
  RequestID last_request_id_ = 0;
  BufferedFrameDeserializer frame_deserializer_;
  base::ScopedFile received_fd_;
  std::map<RequestID, QueuedRequest> queued_requests_;
  std::map<ServiceID, base::WeakPtr<ServiceProxy>> service_bindings_;

  // Queue of calls to BindService() that happened before the socket connected.
  std::list<base::WeakPtr<ServiceProxy>> queued_bindings_;

  base::WeakPtrFactory<Client> weak_ptr_factory_;  // Keep last.
};

}  // namespace ipc
}  // namespace perfetto

#endif  // SRC_IPC_CLIENT_IMPL_H_
// gen_amalgamated begin header: include/perfetto/ext/ipc/service_descriptor.h
// gen_amalgamated begin header: include/perfetto/ext/ipc/deferred.h
// gen_amalgamated begin header: include/perfetto/ext/ipc/async_result.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_IPC_ASYNC_RESULT_H_
#define INCLUDE_PERFETTO_EXT_IPC_ASYNC_RESULT_H_

#include <memory>
#include <type_traits>
#include <utility>

// gen_amalgamated expanded: #include "perfetto/ext/ipc/basic_types.h"

namespace perfetto {
namespace ipc {

// Wraps the result of an asynchronous invocation. This is the equivalent of a
// std::pair<unique_ptr<T>, bool> with syntactic sugar. It is used as callback
// argument by Deferred<T>.
template <typename T = ProtoMessage>
class AsyncResult {
 public:
  static AsyncResult Create() {
    return AsyncResult(std::unique_ptr<T>(new T()));
  }

  AsyncResult(std::unique_ptr<T> msg = nullptr,
              bool has_more = false,
              int fd = -1)
      : msg_(std::move(msg)), has_more_(has_more), fd_(fd) {
    static_assert(std::is_base_of<ProtoMessage, T>::value, "T->ProtoMessage");
  }
  AsyncResult(AsyncResult&&) noexcept = default;
  AsyncResult& operator=(AsyncResult&&) = default;

  bool success() const { return !!msg_; }
  explicit operator bool() const { return success(); }

  bool has_more() const { return has_more_; }
  void set_has_more(bool has_more) { has_more_ = has_more; }

  void set_msg(std::unique_ptr<T> msg) { msg_ = std::move(msg); }
  T* release_msg() { return msg_.release(); }
  T* operator->() { return msg_.get(); }
  T& operator*() { return *msg_; }

  void set_fd(int fd) { fd_ = fd; }
  int fd() const { return fd_; }

 private:
  std::unique_ptr<T> msg_;
  bool has_more_ = false;

  // Optional. Only for messages that convey a file descriptor, for sharing
  // memory across processes.
  int fd_ = -1;
};

}  // namespace ipc
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_IPC_ASYNC_RESULT_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_IPC_DEFERRED_H_
#define INCLUDE_PERFETTO_EXT_IPC_DEFERRED_H_

#include <functional>
#include <memory>
#include <utility>

// gen_amalgamated expanded: #include "perfetto/ext/ipc/async_result.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/basic_types.h"

namespace perfetto {
namespace ipc {

// This class is a wrapper for a callback handling async results.
// The problem this is solving is the following: For each result argument of the
// methods generated from the .proto file:
// - The client wants to see something on which it can Bind() a callback, which
//   is invoked asynchronously once reply is received from the host.
// - The host wants to expose something to user code that implements the IPC
//   methods to allow them to provide an asynchronous reply back to the client.
//   Eventually even more than once, for the case streaming replies.
//
// In both cases we want to make sure that callbacks don't get lost along the
// way. To address this, this class will automatically reject the callbacks
// if they are not resolved at destructor time (or the object is std::move()'d).
//
// The client is supposed to use this class as follows:
//   class GreeterProxy {
//      void SayHello(const HelloRequest&, Deferred<HelloReply> reply)
//   }
//  ...
//  Deferred<HelloReply> reply;
//  reply.Bind([] (AsyncResult<HelloReply> reply) {
//    std::cout << reply.success() ? reply->message : "failure";
//  });
//  host_proxy_instance.SayHello(req, std::move(reply));
//
// The host instead is supposed to use this as follows:
//   class GreeterImpl : public Greeter {
//     void SayHello(const HelloRequest& req, Deferred<HelloReply> reply) {
//        AsyncResult<HelloReply> reply = AsyncResult<HelloReply>::Create();
//        reply->set_greeting("Hello " + req.name)
//        reply.Resolve(std::move(reply));
//     }
//   }
// Or for more complex cases, the deferred object can be std::move()'d outside
// and the reply can continue asynchronously later.

template <typename T>
class Deferred;

class DeferredBase {
 public:
  explicit DeferredBase(
      std::function<void(AsyncResult<ProtoMessage>)> callback = nullptr);

  template <typename T>
  explicit DeferredBase(Deferred<T> other)
      : callback_(std::move(other.callback_)) {}

  ~DeferredBase();
  DeferredBase(DeferredBase&&) noexcept;
  DeferredBase& operator=(DeferredBase&&);
  void Bind(std::function<void(AsyncResult<ProtoMessage>)> callback);
  bool IsBound() const;
  void Resolve(AsyncResult<ProtoMessage>);
  void Reject();

 protected:
  template <typename T>
  friend class Deferred;
  void Move(DeferredBase&);

  std::function<void(AsyncResult<ProtoMessage>)> callback_;
};

template <typename T = ProtoMessage>
class Deferred : public DeferredBase {
 public:
  explicit Deferred(std::function<void(AsyncResult<T>)> callback = nullptr) {
    Bind(std::move(callback));
  }

  // This move constructor (and the similar one in DeferredBase) is meant to be
  // called only by the autogenerated code. The caller has to guarantee that the
  // moved-from and moved-to types match. The behavior is otherwise undefined.
  explicit Deferred(DeferredBase&& other) {
    callback_ = std::move(other.callback_);
    other.callback_ = nullptr;
  }

  void Bind(std::function<void(AsyncResult<T>)> callback) {
    if (!callback)
      return;

    // Here we need a callback adapter to downcast the callback to a generic
    // callback that takes an AsyncResult<ProtoMessage>, so that it can be
    // stored in the base class |callback_|.
    auto callback_adapter = [callback](
                                AsyncResult<ProtoMessage> async_result_base) {
      // Upcast the async_result from <ProtoMessage> -> <T : ProtoMessage>.
      static_assert(std::is_base_of<ProtoMessage, T>::value, "T:ProtoMessage");
      AsyncResult<T> async_result(
          std::unique_ptr<T>(static_cast<T*>(async_result_base.release_msg())),
          async_result_base.has_more(), async_result_base.fd());
      callback(std::move(async_result));
    };
    DeferredBase::Bind(callback_adapter);
  }

  // If no more messages are expected, |callback_| is released.
  void Resolve(AsyncResult<T> async_result) {
    // Convert the |async_result| to the generic base one (T -> ProtoMessage).
    AsyncResult<ProtoMessage> async_result_base(
        std::unique_ptr<ProtoMessage>(async_result.release_msg()),
        async_result.has_more(), async_result.fd());
    DeferredBase::Resolve(std::move(async_result_base));
  }
};

}  // namespace ipc
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_IPC_DEFERRED_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_IPC_SERVICE_DESCRIPTOR_H_
#define INCLUDE_PERFETTO_EXT_IPC_SERVICE_DESCRIPTOR_H_

#include <functional>
#include <string>
#include <utility>
#include <vector>

// gen_amalgamated expanded: #include "perfetto/ext/ipc/basic_types.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/deferred.h"

namespace perfetto {
namespace ipc {

class Service;

// This is a pure data structure which holds factory methods and strings for the
// services and their methods that get generated in the .h/.cc files.
// Each autogenerated class has a GetDescriptor() method that returns one
// instance of these and allows both client and hosts to map service and method
// names to IDs and provide function pointers to the protobuf decoder fuctions.
class ServiceDescriptor {
 public:
  struct Method {
    const char* name;

    // DecoderFunc is pointer to a function that takes a string in input
    // containing protobuf encoded data and returns a decoded protobuf message.
    using DecoderFunc = std::unique_ptr<ProtoMessage> (*)(const std::string&);

    // Function pointer to decode the request argument of the method.
    DecoderFunc request_proto_decoder;

    // Function pointer to decoded the reply argument of the method.
    DecoderFunc reply_proto_decoder;

    // Function pointer that dispatches the generic request to the corresponding
    // method implementation.
    using InvokerFunc = void (*)(Service*,
                                 const ProtoMessage& /* request_args */,
                                 DeferredBase /* deferred_reply */);
    InvokerFunc invoker;
  };

  const char* service_name = nullptr;

  // Note that methods order is not stable. Client and Host might have different
  // method indexes, depending on their versions. The Client can't just rely
  // on the indexes and has to keep a [string -> remote index] translation map.
  std::vector<Method> methods;
};

}  // namespace ipc
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_IPC_SERVICE_DESCRIPTOR_H_
// gen_amalgamated begin header: include/perfetto/ext/ipc/service_proxy.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_IPC_SERVICE_PROXY_H_
#define INCLUDE_PERFETTO_EXT_IPC_SERVICE_PROXY_H_

// gen_amalgamated expanded: #include "perfetto/ext/ipc/basic_types.h"

#include <assert.h>

#include <functional>
#include <map>
#include <memory>
#include <string>

// gen_amalgamated expanded: #include "perfetto/ext/base/weak_ptr.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/deferred.h"

namespace perfetto {
namespace ipc {

class Client;
class ServiceDescriptor;

// The base class for the client-side autogenerated stubs that forward method
// invocations to the host. All the methods of this class are meant to be called
// only by the autogenerated code.
class ServiceProxy {
 public:
  class EventListener {
   public:
    virtual ~EventListener();

    // Called once after Client::BindService() if the ServiceProxy has been
    // successfully bound to the host. It is possible to start sending IPC
    // requests soon after this.
    virtual void OnConnect() {}

    // Called if the connection fails to be established or drops after having
    // been established.
    virtual void OnDisconnect() {}
  };

  // Guarantees that no callback will happen after this object has been
  // destroyed. The caller has to guarantee that the |event_listener| stays
  // alive at least as long as the ServiceProxy instance.
  explicit ServiceProxy(EventListener*);
  virtual ~ServiceProxy();

  void InitializeBinding(base::WeakPtr<Client>,
                         ServiceID,
                         std::map<std::string, MethodID>);

  // Called by the IPC methods in the autogenerated classes.
  void BeginInvoke(const std::string& method_name,
                   const ProtoMessage& request,
                   DeferredBase reply,
                   int fd = -1);

  // Called by ClientImpl.
  // |reply_args| == nullptr means request failure.
  void EndInvoke(RequestID,
                 std::unique_ptr<ProtoMessage> reply_arg,
                 bool has_more);

  // Called by ClientImpl.
  void OnConnect(bool success);
  void OnDisconnect();
  bool connected() const { return service_id_ != 0; }

  base::WeakPtr<ServiceProxy> GetWeakPtr() const;

  // Implemented by the autogenerated class.
  virtual const ServiceDescriptor& GetDescriptor() = 0;

 private:
  base::WeakPtr<Client> client_;
  ServiceID service_id_ = 0;
  std::map<std::string, MethodID> remote_method_ids_;
  std::map<RequestID, DeferredBase> pending_callbacks_;
  EventListener* const event_listener_;
  base::WeakPtrFactory<ServiceProxy> weak_ptr_factory_;  // Keep last.
};

}  // namespace ipc
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_IPC_SERVICE_PROXY_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "src/ipc/client_impl.h"

#include <fcntl.h>
#include <inttypes.h>
#include <unistd.h>

#include <utility>

// gen_amalgamated expanded: #include "perfetto/base/task_runner.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/utils.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/service_descriptor.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/service_proxy.h"

// TODO(primiano): Add ThreadChecker everywhere.

// TODO(primiano): Add timeouts.

namespace perfetto {
namespace ipc {

// static
std::unique_ptr<Client> Client::CreateInstance(const char* socket_name,
                                               base::TaskRunner* task_runner) {
  std::unique_ptr<Client> client(new ClientImpl(socket_name, task_runner));
  return client;
}

ClientImpl::ClientImpl(const char* socket_name, base::TaskRunner* task_runner)
    : task_runner_(task_runner), weak_ptr_factory_(this) {
  GOOGLE_PROTOBUF_VERIFY_VERSION;
  sock_ = base::UnixSocket::Connect(socket_name, this, task_runner);
}

ClientImpl::~ClientImpl() {
  // Ensure we are not destroyed in the middle of invoking a reply.
  PERFETTO_DCHECK(!invoking_method_reply_);
  OnDisconnect(
      nullptr);  // The base::UnixSocket* ptr is not used in OnDisconnect().
}

void ClientImpl::BindService(base::WeakPtr<ServiceProxy> service_proxy) {
  if (!service_proxy)
    return;
  if (!sock_->is_connected()) {
    queued_bindings_.emplace_back(service_proxy);
    return;
  }
  RequestID request_id = ++last_request_id_;
  Frame frame;
  frame.set_request_id(request_id);
  Frame::BindService* req = frame.mutable_msg_bind_service();
  const char* const service_name = service_proxy->GetDescriptor().service_name;
  req->set_service_name(service_name);
  if (!SendFrame(frame)) {
    PERFETTO_DLOG("BindService(%s) failed", service_name);
    return service_proxy->OnConnect(false /* success */);
  }
  QueuedRequest qr;
  qr.type = Frame::kMsgBindService;
  qr.request_id = request_id;
  qr.service_proxy = service_proxy;
  queued_requests_.emplace(request_id, std::move(qr));
}

void ClientImpl::UnbindService(ServiceID service_id) {
  service_bindings_.erase(service_id);
}

RequestID ClientImpl::BeginInvoke(ServiceID service_id,
                                  const std::string& method_name,
                                  MethodID remote_method_id,
                                  const ProtoMessage& method_args,
                                  bool drop_reply,
                                  base::WeakPtr<ServiceProxy> service_proxy,
                                  int fd) {
  std::string args_proto;
  RequestID request_id = ++last_request_id_;
  Frame frame;
  frame.set_request_id(request_id);
  Frame::InvokeMethod* req = frame.mutable_msg_invoke_method();
  req->set_service_id(service_id);
  req->set_method_id(remote_method_id);
  req->set_drop_reply(drop_reply);
  bool did_serialize = method_args.SerializeToString(&args_proto);
  req->set_args_proto(args_proto);
  if (!did_serialize || !SendFrame(frame, fd)) {
    PERFETTO_DLOG("BeginInvoke() failed while sending the frame");
    return 0;
  }
  if (drop_reply)
    return 0;
  QueuedRequest qr;
  qr.type = Frame::kMsgInvokeMethod;
  qr.request_id = request_id;
  qr.method_name = method_name;
  qr.service_proxy = std::move(service_proxy);
  queued_requests_.emplace(request_id, std::move(qr));
  return request_id;
}

bool ClientImpl::SendFrame(const Frame& frame, int fd) {
  // Serialize the frame into protobuf, add the size header, and send it.
  std::string buf = BufferedFrameDeserializer::Serialize(frame);

  // TODO(primiano): this should do non-blocking I/O. But then what if the
  // socket buffer is full? We might want to either drop the request or throttle
  // the send and PostTask the reply later? Right now we are making Send()
  // blocking as a workaround. Propagate bakpressure to the caller instead.
  bool res = sock_->Send(buf.data(), buf.size(), fd,
                         base::UnixSocket::BlockingMode::kBlocking);
  PERFETTO_CHECK(res || !sock_->is_connected());
  return res;
}

void ClientImpl::OnConnect(base::UnixSocket*, bool connected) {
  // Drain the BindService() calls that were queued before establishig the
  // connection with the host.
  for (base::WeakPtr<ServiceProxy>& service_proxy : queued_bindings_) {
    if (connected) {
      BindService(service_proxy);
    } else if (service_proxy) {
      service_proxy->OnConnect(false /* success */);
    }
  }
  queued_bindings_.clear();
}

void ClientImpl::OnDisconnect(base::UnixSocket*) {
  for (auto it : service_bindings_) {
    base::WeakPtr<ServiceProxy>& service_proxy = it.second;
    task_runner_->PostTask([service_proxy] {
      if (service_proxy)
        service_proxy->OnDisconnect();
    });
  }
  service_bindings_.clear();
  queued_bindings_.clear();
}

void ClientImpl::OnDataAvailable(base::UnixSocket*) {
  size_t rsize;
  do {
    auto buf = frame_deserializer_.BeginReceive();
    base::ScopedFile fd;
    rsize = sock_->Receive(buf.data, buf.size, &fd);
    if (fd) {
      PERFETTO_DCHECK(!received_fd_);
      int res = fcntl(*fd, F_SETFD, FD_CLOEXEC);
      PERFETTO_DCHECK(res == 0);
      received_fd_ = std::move(fd);
    }
    if (!frame_deserializer_.EndReceive(rsize)) {
      // The endpoint tried to send a frame that is way too large.
      return sock_->Shutdown(true);  // In turn will trigger an OnDisconnect().
      // TODO(fmayer): check this.
    }
  } while (rsize > 0);

  while (std::unique_ptr<Frame> frame = frame_deserializer_.PopNextFrame())
    OnFrameReceived(*frame);
}

void ClientImpl::OnFrameReceived(const Frame& frame) {
  auto queued_requests_it = queued_requests_.find(frame.request_id());
  if (queued_requests_it == queued_requests_.end()) {
    PERFETTO_DLOG("OnFrameReceived(): got invalid request_id=%" PRIu64,
                  static_cast<uint64_t>(frame.request_id()));
    return;
  }
  QueuedRequest req = std::move(queued_requests_it->second);
  queued_requests_.erase(queued_requests_it);

  if (req.type == Frame::kMsgBindService &&
      frame.msg_case() == Frame::kMsgBindServiceReply) {
    return OnBindServiceReply(std::move(req), frame.msg_bind_service_reply());
  }
  if (req.type == Frame::kMsgInvokeMethod &&
      frame.msg_case() == Frame::kMsgInvokeMethodReply) {
    return OnInvokeMethodReply(std::move(req), frame.msg_invoke_method_reply());
  }
  if (frame.msg_case() == Frame::kMsgRequestError) {
    PERFETTO_DLOG("Host error: %s", frame.msg_request_error().error().c_str());
    return;
  }

  PERFETTO_DLOG(
      "OnFrameReceived() request msg_type=%d, received msg_type=%d in reply to "
      "request_id=%" PRIu64,
      req.type, frame.msg_case(), static_cast<uint64_t>(frame.request_id()));
}

void ClientImpl::OnBindServiceReply(QueuedRequest req,
                                    const Frame::BindServiceReply& reply) {
  base::WeakPtr<ServiceProxy>& service_proxy = req.service_proxy;
  if (!service_proxy)
    return;
  const char* svc_name = service_proxy->GetDescriptor().service_name;
  if (!reply.success()) {
    PERFETTO_DLOG("BindService(): unknown service_name=\"%s\"", svc_name);
    return service_proxy->OnConnect(false /* success */);
  }

  auto prev_service = service_bindings_.find(reply.service_id());
  if (prev_service != service_bindings_.end() && prev_service->second.get()) {
    PERFETTO_DLOG(
        "BindService(): Trying to bind service \"%s\" but another service "
        "named \"%s\" is already bound with the same ID.",
        svc_name, prev_service->second->GetDescriptor().service_name);
    return service_proxy->OnConnect(false /* success */);
  }

  // Build the method [name] -> [remote_id] map.
  std::map<std::string, MethodID> methods;
  for (const auto& method : reply.methods()) {
    if (method.name().empty() || method.id() <= 0) {
      PERFETTO_DLOG("OnBindServiceReply(): invalid method \"%s\" -> %" PRIu64,
                    method.name().c_str(), static_cast<uint64_t>(method.id()));
      continue;
    }
    methods[method.name()] = method.id();
  }
  service_proxy->InitializeBinding(weak_ptr_factory_.GetWeakPtr(),
                                   reply.service_id(), std::move(methods));
  service_bindings_[reply.service_id()] = service_proxy;
  service_proxy->OnConnect(true /* success */);
}

void ClientImpl::OnInvokeMethodReply(QueuedRequest req,
                                     const Frame::InvokeMethodReply& reply) {
  base::WeakPtr<ServiceProxy> service_proxy = req.service_proxy;
  if (!service_proxy)
    return;
  std::unique_ptr<ProtoMessage> decoded_reply;
  if (reply.success()) {
    // If this becomes a hotspot, optimize by maintaining a dedicated hashtable.
    for (const auto& method : service_proxy->GetDescriptor().methods) {
      if (req.method_name == method.name) {
        decoded_reply = method.reply_proto_decoder(reply.reply_proto());
        break;
      }
    }
  }
  const RequestID request_id = req.request_id;
  invoking_method_reply_ = true;
  service_proxy->EndInvoke(request_id, std::move(decoded_reply),
                           reply.has_more());
  invoking_method_reply_ = false;

  // If this is a streaming method and future replies will be resolved, put back
  // the |req| with the callback into the set of active requests.
  if (reply.has_more())
    queued_requests_.emplace(request_id, std::move(req));
}

ClientImpl::QueuedRequest::QueuedRequest() = default;

base::ScopedFile ClientImpl::TakeReceivedFD() {
  return std::move(received_fd_);
}

}  // namespace ipc
}  // namespace perfetto
// gen_amalgamated begin source: src/ipc/deferred.cc
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "perfetto/ext/ipc/deferred.h"

#include <google/protobuf/message_lite.h>

// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/utils.h"

namespace perfetto {
namespace ipc {

DeferredBase::DeferredBase(
    std::function<void(AsyncResult<ProtoMessage>)> callback)
    : callback_(std::move(callback)) {}

DeferredBase::~DeferredBase() {
  if (callback_)
    Reject();
}

// Can't just use "= default" here because the default move operator for
// std::function doesn't necessarily swap and hence can leave a copy of the
// bind state around, which is undesirable.
DeferredBase::DeferredBase(DeferredBase&& other) noexcept {
  Move(other);
}

DeferredBase& DeferredBase::operator=(DeferredBase&& other) {
  if (callback_)
    Reject();
  Move(other);
  return *this;
}

void DeferredBase::Move(DeferredBase& other) {
  callback_ = std::move(other.callback_);
  other.callback_ = nullptr;
}

void DeferredBase::Bind(
    std::function<void(AsyncResult<ProtoMessage>)> callback) {
  callback_ = std::move(callback);
}

bool DeferredBase::IsBound() const {
  return !!callback_;
}

void DeferredBase::Resolve(AsyncResult<ProtoMessage> async_result) {
  if (!callback_) {
    PERFETTO_DFATAL("No callback set.");
    return;
  }
  bool has_more = async_result.has_more();
  callback_(std::move(async_result));
  if (!has_more)
    callback_ = nullptr;
}

// Resolves with a nullptr |msg_|, signalling failure to |callback_|.
void DeferredBase::Reject() {
  Resolve(AsyncResult<ProtoMessage>());
}

}  // namespace ipc
}  // namespace perfetto
// gen_amalgamated begin source: src/ipc/host_impl.cc
// gen_amalgamated begin header: src/ipc/host_impl.h
// gen_amalgamated begin header: include/perfetto/ext/ipc/host.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_IPC_HOST_H_
#define INCLUDE_PERFETTO_EXT_IPC_HOST_H_

#include <memory>

// gen_amalgamated expanded: #include "perfetto/ext/base/scoped_file.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/basic_types.h"

namespace perfetto {

namespace base {
class TaskRunner;
}  // namespace base

namespace ipc {

class Service;

// The host-side of the IPC layer. This class acts as a registry and request
// dispatcher. It listen on the UnixSocket |socket_name| for incoming requests
// (coming Client instances) and dispatches their requests to the various
// Services exposed.
class Host {
 public:
  // Creates an instance and starts listening on the given |socket_name|.
  // Returns nullptr if listening on the socket fails.
  static std::unique_ptr<Host> CreateInstance(const char* socket_name,
                                              base::TaskRunner*);

  // Like the above but takes a file descriptor to a pre-bound unix socket.
  // Returns nullptr if listening on the socket fails.
  static std::unique_ptr<Host> CreateInstance(base::ScopedFile socket_fd,
                                              base::TaskRunner*);

  virtual ~Host();

  // Registers a new service and makes it available to remote IPC peers.
  // All the exposed Service instances will be destroyed when destroying the
  // Host instance if ExposeService suceeds and returns true, or immediately
  // after the call in case of failure.
  // Returns true if the register has been succesfully registered, false in case
  // of errors (e.g., another service with the same name is already registered).
  virtual bool ExposeService(std::unique_ptr<Service>) = 0;
};

}  // namespace ipc
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_IPC_HOST_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef SRC_IPC_HOST_IMPL_H_
#define SRC_IPC_HOST_IMPL_H_

#include <map>
#include <set>
#include <string>
#include <vector>

// gen_amalgamated expanded: #include "perfetto/base/task_runner.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/thread_checker.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/unix_socket.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/deferred.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/host.h"
// gen_amalgamated expanded: #include "src/ipc/buffered_frame_deserializer.h"

namespace perfetto {
namespace ipc {

class Frame;

class HostImpl : public Host, public base::UnixSocket::EventListener {
 public:
  HostImpl(const char* socket_name, base::TaskRunner*);
  HostImpl(base::ScopedFile socket_fd, base::TaskRunner*);
  ~HostImpl() override;

  // Host implementation.
  bool ExposeService(std::unique_ptr<Service>) override;

  // base::UnixSocket::EventListener implementation.
  void OnNewIncomingConnection(base::UnixSocket*,
                               std::unique_ptr<base::UnixSocket>) override;
  void OnDisconnect(base::UnixSocket*) override;
  void OnDataAvailable(base::UnixSocket*) override;

  const base::UnixSocket* sock() const { return sock_.get(); }

 private:
  // Owns the per-client receive buffer (BufferedFrameDeserializer).
  struct ClientConnection {
    ~ClientConnection();
    ClientID id;
    std::unique_ptr<base::UnixSocket> sock;
    BufferedFrameDeserializer frame_deserializer;
    base::ScopedFile received_fd;
  };
  struct ExposedService {
    ExposedService(ServiceID, const std::string&, std::unique_ptr<Service>);
    ~ExposedService();
    ExposedService(ExposedService&&) noexcept;
    ExposedService& operator=(ExposedService&&);

    ServiceID id;
    std::string name;
    std::unique_ptr<Service> instance;
  };

  HostImpl(const HostImpl&) = delete;
  HostImpl& operator=(const HostImpl&) = delete;

  bool Initialize(const char* socket_name);
  void OnReceivedFrame(ClientConnection*, const Frame&);
  void OnBindService(ClientConnection*, const Frame&);
  void OnInvokeMethod(ClientConnection*, const Frame&);
  void ReplyToMethodInvocation(ClientID, RequestID, AsyncResult<ProtoMessage>);
  const ExposedService* GetServiceByName(const std::string&);

  static void SendFrame(ClientConnection*, const Frame&, int fd = -1);

  base::TaskRunner* const task_runner_;
  std::map<ServiceID, ExposedService> services_;
  std::unique_ptr<base::UnixSocket> sock_;  // The listening socket.
  std::map<ClientID, std::unique_ptr<ClientConnection>> clients_;
  std::map<base::UnixSocket*, ClientConnection*> clients_by_socket_;
  ServiceID last_service_id_ = 0;
  ClientID last_client_id_ = 0;
  PERFETTO_THREAD_CHECKER(thread_checker_)
  base::WeakPtrFactory<HostImpl> weak_ptr_factory_;  // Keep last.
};

}  // namespace ipc
}  // namespace perfetto

#endif  // SRC_IPC_HOST_IMPL_H_
// gen_amalgamated begin header: include/perfetto/ext/ipc/service.h
// gen_amalgamated begin header: include/perfetto/ext/ipc/client_info.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_IPC_CLIENT_INFO_H_
#define INCLUDE_PERFETTO_EXT_IPC_CLIENT_INFO_H_

#include <unistd.h>

// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/basic_types.h"

namespace perfetto {
namespace ipc {

// Passed to Service(s) to identify remote clients.
class ClientInfo {
 public:
  ClientInfo() = default;
  ClientInfo(ClientID client_id, uid_t uid)
      : client_id_(client_id), uid_(uid) {}

  bool operator==(const ClientInfo& other) const {
    return (client_id_ == other.client_id_ && uid_ == other.uid_);
  }
  bool operator!=(const ClientInfo& other) const { return !(*this == other); }

  // For map<> and other sorted containers.
  bool operator<(const ClientInfo& other) const {
    PERFETTO_DCHECK(client_id_ != other.client_id_ || *this == other);
    return client_id_ < other.client_id_;
  }

  bool is_valid() const { return client_id_ != 0; }

  // A monotonic counter.
  ClientID client_id() const { return client_id_; }

  // Posix User ID. Comes from the kernel, can be trusted.
  uid_t uid() const { return uid_; }

 private:
  ClientID client_id_ = 0;
  uid_t uid_ = kInvalidUid;
};

}  // namespace ipc
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_IPC_CLIENT_INFO_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_IPC_SERVICE_H_
#define INCLUDE_PERFETTO_EXT_IPC_SERVICE_H_

// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/scoped_file.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/client_info.h"

namespace perfetto {
namespace ipc {

class ServiceDescriptor;

// The base class for all the autogenerated host-side service interfaces.
class Service {
 public:
  virtual ~Service();

  // Overridden by the auto-generated class. Provides the list of methods and
  // the protobuf (de)serialization functions for their arguments.
  virtual const ServiceDescriptor& GetDescriptor() = 0;

  // Invoked when a remote client disconnects. Use client_info() to obtain
  // details about the client that disconnected.
  virtual void OnClientDisconnected() {}

  // Returns the ClientInfo for the current IPC request. Returns an invalid
  // ClientInfo if called outside the scope of an IPC method.
  const ClientInfo& client_info() {
    PERFETTO_DCHECK(client_info_.is_valid());
    return client_info_;
  }

  base::ScopedFile TakeReceivedFD() {
    if (received_fd_)
      return std::move(*received_fd_);
    return base::ScopedFile();
  }

 private:
  friend class HostImpl;
  ClientInfo client_info_;
  // This is a pointer because the received fd needs to remain owned by the
  // ClientConnection, as we will provide it to all method invocations
  // for that client until one of them calls Service::TakeReceivedFD.
  //
  // Different clients might have sent different FDs so this cannot be owned
  // here.
  //
  // Note that this means that there can always only be one outstanding
  // invocation per client that supplies an FD and the client needs to
  // wait for this one to return before calling another one.
  base::ScopedFile* received_fd_;
};

}  // namespace ipc
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_IPC_SERVICE_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "src/ipc/host_impl.h"

#include <inttypes.h>

#include <algorithm>
#include <utility>

// gen_amalgamated expanded: #include "perfetto/base/task_runner.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/utils.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/service.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/service_descriptor.h"

// gen_amalgamated expanded: #include "src/ipc/wire_protocol.pb.h"

// TODO(primiano): put limits on #connections/uid and req. queue (b/69093705).

namespace perfetto {
namespace ipc {

// static
std::unique_ptr<Host> Host::CreateInstance(const char* socket_name,
                                           base::TaskRunner* task_runner) {
  std::unique_ptr<HostImpl> host(new HostImpl(socket_name, task_runner));
  if (!host->sock() || !host->sock()->is_listening())
    return nullptr;
  return std::move(host);
}

// static
std::unique_ptr<Host> Host::CreateInstance(base::ScopedFile socket_fd,
                                           base::TaskRunner* task_runner) {
  std::unique_ptr<HostImpl> host(
      new HostImpl(std::move(socket_fd), task_runner));
  if (!host->sock() || !host->sock()->is_listening())
    return nullptr;
  return std::move(host);
}

HostImpl::HostImpl(base::ScopedFile socket_fd, base::TaskRunner* task_runner)
    : task_runner_(task_runner), weak_ptr_factory_(this) {
  GOOGLE_PROTOBUF_VERIFY_VERSION;
  PERFETTO_DCHECK_THREAD(thread_checker_);
  sock_ = base::UnixSocket::Listen(std::move(socket_fd), this, task_runner_);
}

HostImpl::HostImpl(const char* socket_name, base::TaskRunner* task_runner)
    : task_runner_(task_runner), weak_ptr_factory_(this) {
  GOOGLE_PROTOBUF_VERIFY_VERSION;
  PERFETTO_DCHECK_THREAD(thread_checker_);
  sock_ = base::UnixSocket::Listen(socket_name, this, task_runner_);
}

HostImpl::~HostImpl() = default;

bool HostImpl::ExposeService(std::unique_ptr<Service> service) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  const std::string& service_name = service->GetDescriptor().service_name;
  if (GetServiceByName(service_name)) {
    PERFETTO_DLOG("Duplicate ExposeService(): %s", service_name.c_str());
    return false;
  }
  ServiceID sid = ++last_service_id_;
  ExposedService exposed_service(sid, service_name, std::move(service));
  services_.emplace(sid, std::move(exposed_service));
  return true;
}

void HostImpl::OnNewIncomingConnection(
    base::UnixSocket*,
    std::unique_ptr<base::UnixSocket> new_conn) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  std::unique_ptr<ClientConnection> client(new ClientConnection());
  ClientID client_id = ++last_client_id_;
  clients_by_socket_[new_conn.get()] = client.get();
  client->id = client_id;
  client->sock = std::move(new_conn);
  clients_[client_id] = std::move(client);
}

void HostImpl::OnDataAvailable(base::UnixSocket* sock) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  auto it = clients_by_socket_.find(sock);
  if (it == clients_by_socket_.end())
    return;
  ClientConnection* client = it->second;
  BufferedFrameDeserializer& frame_deserializer = client->frame_deserializer;

  size_t rsize;
  do {
    auto buf = frame_deserializer.BeginReceive();
    base::ScopedFile fd;
    rsize = client->sock->Receive(buf.data, buf.size, &fd);
    if (fd) {
      PERFETTO_DCHECK(!client->received_fd);
      client->received_fd = std::move(fd);
    }
    if (!frame_deserializer.EndReceive(rsize))
      return OnDisconnect(client->sock.get());
  } while (rsize > 0);

  for (;;) {
    std::unique_ptr<Frame> frame = frame_deserializer.PopNextFrame();
    if (!frame)
      break;
    OnReceivedFrame(client, *frame);
  }
}

void HostImpl::OnReceivedFrame(ClientConnection* client,
                               const Frame& req_frame) {
  if (req_frame.msg_case() == Frame::kMsgBindService)
    return OnBindService(client, req_frame);
  if (req_frame.msg_case() == Frame::kMsgInvokeMethod)
    return OnInvokeMethod(client, req_frame);

  PERFETTO_DLOG("Received invalid RPC frame %u from client %" PRIu64,
                req_frame.msg_case(), client->id);
  Frame reply_frame;
  reply_frame.set_request_id(req_frame.request_id());
  reply_frame.mutable_msg_request_error()->set_error("unknown request");
  SendFrame(client, reply_frame);
}

void HostImpl::OnBindService(ClientConnection* client, const Frame& req_frame) {
  // Binding a service doesn't do anything major. It just returns back the
  // service id and its method map.
  const Frame::BindService& req = req_frame.msg_bind_service();
  Frame reply_frame;
  reply_frame.set_request_id(req_frame.request_id());
  auto* reply = reply_frame.mutable_msg_bind_service_reply();
  const ExposedService* service = GetServiceByName(req.service_name());
  if (service) {
    reply->set_success(true);
    reply->set_service_id(service->id);
    uint32_t method_id = 1;  // method ids start at index 1.
    for (const auto& desc_method : service->instance->GetDescriptor().methods) {
      Frame::BindServiceReply::MethodInfo* method_info = reply->add_methods();
      method_info->set_name(desc_method.name);
      method_info->set_id(method_id++);
    }
  }
  SendFrame(client, reply_frame);
}

void HostImpl::OnInvokeMethod(ClientConnection* client,
                              const Frame& req_frame) {
  const Frame::InvokeMethod& req = req_frame.msg_invoke_method();
  Frame reply_frame;
  RequestID request_id = req_frame.request_id();
  reply_frame.set_request_id(request_id);
  reply_frame.mutable_msg_invoke_method_reply()->set_success(false);
  auto svc_it = services_.find(req.service_id());
  if (svc_it == services_.end())
    return SendFrame(client, reply_frame);  // |success| == false by default.

  Service* service = svc_it->second.instance.get();
  const ServiceDescriptor& svc = service->GetDescriptor();
  const auto& methods = svc.methods;
  const uint32_t method_id = req.method_id();
  if (method_id == 0 || method_id > methods.size())
    return SendFrame(client, reply_frame);

  const ServiceDescriptor::Method& method = methods[method_id - 1];
  std::unique_ptr<ProtoMessage> decoded_req_args(
      method.request_proto_decoder(req.args_proto()));
  if (!decoded_req_args)
    return SendFrame(client, reply_frame);

  Deferred<ProtoMessage> deferred_reply;
  base::WeakPtr<HostImpl> host_weak_ptr = weak_ptr_factory_.GetWeakPtr();
  ClientID client_id = client->id;

  if (!req.drop_reply()) {
    deferred_reply.Bind([host_weak_ptr, client_id,
                         request_id](AsyncResult<ProtoMessage> reply) {
      if (!host_weak_ptr)
        return;  // The reply came too late, the HostImpl has gone.
      host_weak_ptr->ReplyToMethodInvocation(client_id, request_id,
                                             std::move(reply));
    });
  }

  service->client_info_ = ClientInfo(client->id, client->sock->peer_uid());
  service->received_fd_ = &client->received_fd;
  method.invoker(service, *decoded_req_args, std::move(deferred_reply));
  service->received_fd_ = nullptr;
  service->client_info_ = ClientInfo();
}

void HostImpl::ReplyToMethodInvocation(ClientID client_id,
                                       RequestID request_id,
                                       AsyncResult<ProtoMessage> reply) {
  auto client_iter = clients_.find(client_id);
  if (client_iter == clients_.end())
    return;  // client has disconnected by the time we got the async reply.

  ClientConnection* client = client_iter->second.get();
  Frame reply_frame;
  reply_frame.set_request_id(request_id);

  // TODO(fmayer): add a test to guarantee that the reply is consumed within the
  // same call stack and not kept around. ConsumerIPCService::OnTraceData()
  // relies on this behavior.
  auto* reply_frame_data = reply_frame.mutable_msg_invoke_method_reply();
  reply_frame_data->set_has_more(reply.has_more());
  if (reply.success()) {
    std::string reply_proto;
    if (reply->SerializeToString(&reply_proto)) {
      reply_frame_data->set_reply_proto(reply_proto);
      reply_frame_data->set_success(true);
    }
  }
  SendFrame(client, reply_frame, reply.fd());
}

// static
void HostImpl::SendFrame(ClientConnection* client, const Frame& frame, int fd) {
  std::string buf = BufferedFrameDeserializer::Serialize(frame);

  // TODO(primiano): this should do non-blocking I/O. But then what if the
  // socket buffer is full? We might want to either drop the request or throttle
  // the send and PostTask the reply later? Right now we are making Send()
  // blocking as a workaround. Propagate bakpressure to the caller instead.
  bool res = client->sock->Send(buf.data(), buf.size(), fd,
                                base::UnixSocket::BlockingMode::kBlocking);
  PERFETTO_CHECK(res || !client->sock->is_connected());
}

void HostImpl::OnDisconnect(base::UnixSocket* sock) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  auto it = clients_by_socket_.find(sock);
  if (it == clients_by_socket_.end())
    return;
  ClientID client_id = it->second->id;
  ClientInfo client_info(client_id, sock->peer_uid());
  clients_by_socket_.erase(it);
  PERFETTO_DCHECK(clients_.count(client_id));
  clients_.erase(client_id);

  for (const auto& service_it : services_) {
    Service& service = *service_it.second.instance;
    service.client_info_ = client_info;
    service.OnClientDisconnected();
    service.client_info_ = ClientInfo();
  }
}

const HostImpl::ExposedService* HostImpl::GetServiceByName(
    const std::string& name) {
  // This could be optimized by using another map<name,ServiceID>. However this
  // is used only by Bind/ExposeService that are quite rare (once per client
  // connection and once per service instance), not worth it.
  for (const auto& it : services_) {
    if (it.second.name == name)
      return &it.second;
  }
  return nullptr;
}

HostImpl::ExposedService::ExposedService(ServiceID id_,
                                         const std::string& name_,
                                         std::unique_ptr<Service> instance_)
    : id(id_), name(name_), instance(std::move(instance_)) {}

HostImpl::ExposedService::ExposedService(ExposedService&&) noexcept = default;
HostImpl::ExposedService& HostImpl::ExposedService::operator=(
    HostImpl::ExposedService&&) = default;
HostImpl::ExposedService::~ExposedService() = default;

HostImpl::ClientConnection::~ClientConnection() = default;

}  // namespace ipc
}  // namespace perfetto
// gen_amalgamated begin source: src/ipc/service_proxy.cc
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "perfetto/ext/ipc/service_proxy.h"

#include <utility>

#include <google/protobuf/message_lite.h>
// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/weak_ptr.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/service_descriptor.h"
// gen_amalgamated expanded: #include "src/ipc/client_impl.h"

namespace perfetto {
namespace ipc {

ServiceProxy::ServiceProxy(EventListener* event_listener)
    : event_listener_(event_listener), weak_ptr_factory_(this) {}

ServiceProxy::~ServiceProxy() {
  if (client_ && connected())
    client_->UnbindService(service_id_);
}

void ServiceProxy::InitializeBinding(
    base::WeakPtr<Client> client,
    ServiceID service_id,
    std::map<std::string, MethodID> remote_method_ids) {
  client_ = std::move(client);
  service_id_ = service_id;
  remote_method_ids_ = std::move(remote_method_ids);
}

void ServiceProxy::BeginInvoke(const std::string& method_name,
                               const ProtoMessage& request,
                               DeferredBase reply,
                               int fd) {
  // |reply| will auto-resolve if it gets out of scope early.
  if (!connected()) {
    PERFETTO_DFATAL("Not connected.");
    return;
  }
  if (!client_)
    return;  // The Client object has been destroyed in the meantime.

  auto remote_method_it = remote_method_ids_.find(method_name);
  RequestID request_id = 0;
  const bool drop_reply = !reply.IsBound();
  if (remote_method_it != remote_method_ids_.end()) {
    request_id =
        static_cast<ClientImpl*>(client_.get())
            ->BeginInvoke(service_id_, method_name, remote_method_it->second,
                          request, drop_reply, weak_ptr_factory_.GetWeakPtr(),
                          fd);
  } else {
    PERFETTO_DLOG("Cannot find method \"%s\" on the host", method_name.c_str());
  }

  // When passing |drop_reply| == true, the returned |request_id| should be 0.
  PERFETTO_DCHECK(!drop_reply || !request_id);

  if (!request_id)
    return;
  PERFETTO_DCHECK(pending_callbacks_.count(request_id) == 0);
  pending_callbacks_.emplace(request_id, std::move(reply));
}

void ServiceProxy::EndInvoke(RequestID request_id,
                             std::unique_ptr<ProtoMessage> result,
                             bool has_more) {
  auto callback_it = pending_callbacks_.find(request_id);
  if (callback_it == pending_callbacks_.end()) {
    // Either we are getting a reply for a method we never invoked, or we are
    // getting a reply to a method marked drop_reply (that has been invoked
    // without binding any callback in the Defererd response object).
    PERFETTO_DFATAL("Unexpected reply received.");
    return;
  }
  DeferredBase& reply_callback = callback_it->second;
  AsyncResult<ProtoMessage> reply(std::move(result), has_more);
  reply_callback.Resolve(std::move(reply));
  if (!has_more)
    pending_callbacks_.erase(callback_it);
}

void ServiceProxy::OnConnect(bool success) {
  if (success) {
    PERFETTO_DCHECK(service_id_);
    return event_listener_->OnConnect();
  }
  return event_listener_->OnDisconnect();
}

void ServiceProxy::OnDisconnect() {
  pending_callbacks_.clear();  // Will Reject() all the pending callbacks.
  event_listener_->OnDisconnect();
}

base::WeakPtr<ServiceProxy> ServiceProxy::GetWeakPtr() const {
  return weak_ptr_factory_.GetWeakPtr();
}

}  // namespace ipc
}  // namespace perfetto
// gen_amalgamated begin source: src/ipc/virtual_destructors.cc
/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "perfetto/ext/ipc/client.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/host.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/service.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/service_proxy.h"

// This translation unit contains the definitions for the destructor of pure
// virtual interfaces for the current build target. The alternative would be
// introducing a one-liner .cc file for each pure virtual interface, which is
// overkill. This is for compliance with -Wweak-vtables.

namespace perfetto {
namespace ipc {

Client::~Client() = default;
Host::~Host() = default;
Service::~Service() = default;
ServiceProxy::EventListener::~EventListener() = default;

}  // namespace ipc
}  // namespace perfetto
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/ipc/consumer_port.pb.cc
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/ipc/consumer_port.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/ipc/consumer_port.proto

#ifndef PROTOBUF_perfetto_2fipc_2fconsumer_5fport_2eproto__INCLUDED
#define PROTOBUF_perfetto_2fipc_2fconsumer_5fport_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// gen_amalgamated expanded: #include "perfetto/common/observable_events.pb.h"
// gen_amalgamated expanded: #include "perfetto/common/tracing_service_state.pb.h"
// gen_amalgamated expanded: #include "perfetto/common/trace_stats.pb.h"
// gen_amalgamated expanded: #include "perfetto/config/trace_config.pb.h"
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
void protobuf_AssignDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
void protobuf_ShutdownFile_perfetto_2fipc_2fconsumer_5fport_2eproto();

class AttachRequest;
class AttachResponse;
class ChangeTraceConfigRequest;
class ChangeTraceConfigResponse;
class DetachRequest;
class DetachResponse;
class DisableTracingRequest;
class DisableTracingResponse;
class EnableTracingRequest;
class EnableTracingResponse;
class FlushRequest;
class FlushResponse;
class FreeBuffersRequest;
class FreeBuffersResponse;
class GetTraceStatsRequest;
class GetTraceStatsResponse;
class ObserveEventsRequest;
class ObserveEventsResponse;
class QueryServiceStateRequest;
class QueryServiceStateResponse;
class ReadBuffersRequest;
class ReadBuffersResponse;
class ReadBuffersResponse_Slice;
class StartTracingRequest;
class StartTracingResponse;

// ===================================================================

class EnableTracingRequest : public ::google::protobuf::MessageLite {
 public:
  EnableTracingRequest();
  virtual ~EnableTracingRequest();

  EnableTracingRequest(const EnableTracingRequest& from);

  inline EnableTracingRequest& operator=(const EnableTracingRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const EnableTracingRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EnableTracingRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EnableTracingRequest* other);

  // implements Message ----------------------------------------------

  inline EnableTracingRequest* New() const { return New(NULL); }

  EnableTracingRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EnableTracingRequest& from);
  void MergeFrom(const EnableTracingRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EnableTracingRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .perfetto.protos.TraceConfig trace_config = 1;
  bool has_trace_config() const;
  void clear_trace_config();
  static const int kTraceConfigFieldNumber = 1;
  const ::perfetto::protos::TraceConfig& trace_config() const;
  ::perfetto::protos::TraceConfig* mutable_trace_config();
  ::perfetto::protos::TraceConfig* release_trace_config();
  void set_allocated_trace_config(::perfetto::protos::TraceConfig* trace_config);

  // optional bool attach_notification_only = 2;
  bool has_attach_notification_only() const;
  void clear_attach_notification_only();
  static const int kAttachNotificationOnlyFieldNumber = 2;
  bool attach_notification_only() const;
  void set_attach_notification_only(bool value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.EnableTracingRequest)
 private:
  inline void set_has_trace_config();
  inline void clear_has_trace_config();
  inline void set_has_attach_notification_only();
  inline void clear_has_attach_notification_only();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::perfetto::protos::TraceConfig* trace_config_;
  bool attach_notification_only_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static EnableTracingRequest* default_instance_;
};
// -------------------------------------------------------------------

class EnableTracingResponse : public ::google::protobuf::MessageLite {
 public:
  EnableTracingResponse();
  virtual ~EnableTracingResponse();

  EnableTracingResponse(const EnableTracingResponse& from);

  inline EnableTracingResponse& operator=(const EnableTracingResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const EnableTracingResponse& default_instance();

  enum StateCase {
    kDisabled = 1,
    STATE_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EnableTracingResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EnableTracingResponse* other);

  // implements Message ----------------------------------------------

  inline EnableTracingResponse* New() const { return New(NULL); }

  EnableTracingResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EnableTracingResponse& from);
  void MergeFrom(const EnableTracingResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EnableTracingResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool disabled = 1;
  bool has_disabled() const;
  void clear_disabled();
  static const int kDisabledFieldNumber = 1;
  bool disabled() const;
  void set_disabled(bool value);

  StateCase state_case() const;
  // @@protoc_insertion_point(class_scope:perfetto.protos.EnableTracingResponse)
 private:
  inline void set_has_disabled();

  inline bool has_state() const;
  void clear_state();
  inline void clear_has_state();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union StateUnion {
    StateUnion() {}
    bool disabled_;
  } state_;
  ::google::protobuf::uint32 _oneof_case_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static EnableTracingResponse* default_instance_;
};
// -------------------------------------------------------------------

class StartTracingRequest : public ::google::protobuf::MessageLite {
 public:
  StartTracingRequest();
  virtual ~StartTracingRequest();

  StartTracingRequest(const StartTracingRequest& from);

  inline StartTracingRequest& operator=(const StartTracingRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const StartTracingRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StartTracingRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StartTracingRequest* other);

  // implements Message ----------------------------------------------

  inline StartTracingRequest* New() const { return New(NULL); }

  StartTracingRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StartTracingRequest& from);
  void MergeFrom(const StartTracingRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StartTracingRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.StartTracingRequest)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static StartTracingRequest* default_instance_;
};
// -------------------------------------------------------------------

class StartTracingResponse : public ::google::protobuf::MessageLite {
 public:
  StartTracingResponse();
  virtual ~StartTracingResponse();

  StartTracingResponse(const StartTracingResponse& from);

  inline StartTracingResponse& operator=(const StartTracingResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const StartTracingResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const StartTracingResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(StartTracingResponse* other);

  // implements Message ----------------------------------------------

  inline StartTracingResponse* New() const { return New(NULL); }

  StartTracingResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const StartTracingResponse& from);
  void MergeFrom(const StartTracingResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StartTracingResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.StartTracingResponse)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static StartTracingResponse* default_instance_;
};
// -------------------------------------------------------------------

class ChangeTraceConfigRequest : public ::google::protobuf::MessageLite {
 public:
  ChangeTraceConfigRequest();
  virtual ~ChangeTraceConfigRequest();

  ChangeTraceConfigRequest(const ChangeTraceConfigRequest& from);

  inline ChangeTraceConfigRequest& operator=(const ChangeTraceConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ChangeTraceConfigRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ChangeTraceConfigRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ChangeTraceConfigRequest* other);

  // implements Message ----------------------------------------------

  inline ChangeTraceConfigRequest* New() const { return New(NULL); }

  ChangeTraceConfigRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChangeTraceConfigRequest& from);
  void MergeFrom(const ChangeTraceConfigRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChangeTraceConfigRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .perfetto.protos.TraceConfig trace_config = 1;
  bool has_trace_config() const;
  void clear_trace_config();
  static const int kTraceConfigFieldNumber = 1;
  const ::perfetto::protos::TraceConfig& trace_config() const;
  ::perfetto::protos::TraceConfig* mutable_trace_config();
  ::perfetto::protos::TraceConfig* release_trace_config();
  void set_allocated_trace_config(::perfetto::protos::TraceConfig* trace_config);

  // @@protoc_insertion_point(class_scope:perfetto.protos.ChangeTraceConfigRequest)
 private:
  inline void set_has_trace_config();
  inline void clear_has_trace_config();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::perfetto::protos::TraceConfig* trace_config_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static ChangeTraceConfigRequest* default_instance_;
};
// -------------------------------------------------------------------

class ChangeTraceConfigResponse : public ::google::protobuf::MessageLite {
 public:
  ChangeTraceConfigResponse();
  virtual ~ChangeTraceConfigResponse();

  ChangeTraceConfigResponse(const ChangeTraceConfigResponse& from);

  inline ChangeTraceConfigResponse& operator=(const ChangeTraceConfigResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ChangeTraceConfigResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ChangeTraceConfigResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ChangeTraceConfigResponse* other);

  // implements Message ----------------------------------------------

  inline ChangeTraceConfigResponse* New() const { return New(NULL); }

  ChangeTraceConfigResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChangeTraceConfigResponse& from);
  void MergeFrom(const ChangeTraceConfigResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChangeTraceConfigResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.ChangeTraceConfigResponse)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static ChangeTraceConfigResponse* default_instance_;
};
// -------------------------------------------------------------------

class DisableTracingRequest : public ::google::protobuf::MessageLite {
 public:
  DisableTracingRequest();
  virtual ~DisableTracingRequest();

  DisableTracingRequest(const DisableTracingRequest& from);

  inline DisableTracingRequest& operator=(const DisableTracingRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const DisableTracingRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DisableTracingRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DisableTracingRequest* other);

  // implements Message ----------------------------------------------

  inline DisableTracingRequest* New() const { return New(NULL); }

  DisableTracingRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DisableTracingRequest& from);
  void MergeFrom(const DisableTracingRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DisableTracingRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.DisableTracingRequest)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static DisableTracingRequest* default_instance_;
};
// -------------------------------------------------------------------

class DisableTracingResponse : public ::google::protobuf::MessageLite {
 public:
  DisableTracingResponse();
  virtual ~DisableTracingResponse();

  DisableTracingResponse(const DisableTracingResponse& from);

  inline DisableTracingResponse& operator=(const DisableTracingResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const DisableTracingResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DisableTracingResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DisableTracingResponse* other);

  // implements Message ----------------------------------------------

  inline DisableTracingResponse* New() const { return New(NULL); }

  DisableTracingResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DisableTracingResponse& from);
  void MergeFrom(const DisableTracingResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DisableTracingResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.DisableTracingResponse)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static DisableTracingResponse* default_instance_;
};
// -------------------------------------------------------------------

class ReadBuffersRequest : public ::google::protobuf::MessageLite {
 public:
  ReadBuffersRequest();
  virtual ~ReadBuffersRequest();

  ReadBuffersRequest(const ReadBuffersRequest& from);

  inline ReadBuffersRequest& operator=(const ReadBuffersRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ReadBuffersRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReadBuffersRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReadBuffersRequest* other);

  // implements Message ----------------------------------------------

  inline ReadBuffersRequest* New() const { return New(NULL); }

  ReadBuffersRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReadBuffersRequest& from);
  void MergeFrom(const ReadBuffersRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReadBuffersRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.ReadBuffersRequest)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static ReadBuffersRequest* default_instance_;
};
// -------------------------------------------------------------------

class ReadBuffersResponse_Slice : public ::google::protobuf::MessageLite {
 public:
  ReadBuffersResponse_Slice();
  virtual ~ReadBuffersResponse_Slice();

  ReadBuffersResponse_Slice(const ReadBuffersResponse_Slice& from);

  inline ReadBuffersResponse_Slice& operator=(const ReadBuffersResponse_Slice& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ReadBuffersResponse_Slice& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReadBuffersResponse_Slice* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReadBuffersResponse_Slice* other);

  // implements Message ----------------------------------------------

  inline ReadBuffersResponse_Slice* New() const { return New(NULL); }

  ReadBuffersResponse_Slice* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReadBuffersResponse_Slice& from);
  void MergeFrom(const ReadBuffersResponse_Slice& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReadBuffersResponse_Slice* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes data = 1;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 1;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // optional bool last_slice_for_packet = 2;
  bool has_last_slice_for_packet() const;
  void clear_last_slice_for_packet();
  static const int kLastSliceForPacketFieldNumber = 2;
  bool last_slice_for_packet() const;
  void set_last_slice_for_packet(bool value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.ReadBuffersResponse.Slice)
 private:
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_last_slice_for_packet();
  inline void clear_has_last_slice_for_packet();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  bool last_slice_for_packet_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static ReadBuffersResponse_Slice* default_instance_;
};
// -------------------------------------------------------------------

class ReadBuffersResponse : public ::google::protobuf::MessageLite {
 public:
  ReadBuffersResponse();
  virtual ~ReadBuffersResponse();

  ReadBuffersResponse(const ReadBuffersResponse& from);

  inline ReadBuffersResponse& operator=(const ReadBuffersResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ReadBuffersResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReadBuffersResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReadBuffersResponse* other);

  // implements Message ----------------------------------------------

  inline ReadBuffersResponse* New() const { return New(NULL); }

  ReadBuffersResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReadBuffersResponse& from);
  void MergeFrom(const ReadBuffersResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReadBuffersResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ReadBuffersResponse_Slice Slice;

  // accessors -------------------------------------------------------

  // repeated .perfetto.protos.ReadBuffersResponse.Slice slices = 2;
  int slices_size() const;
  void clear_slices();
  static const int kSlicesFieldNumber = 2;
  const ::perfetto::protos::ReadBuffersResponse_Slice& slices(int index) const;
  ::perfetto::protos::ReadBuffersResponse_Slice* mutable_slices(int index);
  ::perfetto::protos::ReadBuffersResponse_Slice* add_slices();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::ReadBuffersResponse_Slice >*
      mutable_slices();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::ReadBuffersResponse_Slice >&
      slices() const;

  // @@protoc_insertion_point(class_scope:perfetto.protos.ReadBuffersResponse)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::ReadBuffersResponse_Slice > slices_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static ReadBuffersResponse* default_instance_;
};
// -------------------------------------------------------------------

class FreeBuffersRequest : public ::google::protobuf::MessageLite {
 public:
  FreeBuffersRequest();
  virtual ~FreeBuffersRequest();

  FreeBuffersRequest(const FreeBuffersRequest& from);

  inline FreeBuffersRequest& operator=(const FreeBuffersRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const FreeBuffersRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FreeBuffersRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FreeBuffersRequest* other);

  // implements Message ----------------------------------------------

  inline FreeBuffersRequest* New() const { return New(NULL); }

  FreeBuffersRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FreeBuffersRequest& from);
  void MergeFrom(const FreeBuffersRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FreeBuffersRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 buffer_ids = 1;
  int buffer_ids_size() const;
  void clear_buffer_ids();
  static const int kBufferIdsFieldNumber = 1;
  ::google::protobuf::uint32 buffer_ids(int index) const;
  void set_buffer_ids(int index, ::google::protobuf::uint32 value);
  void add_buffer_ids(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      buffer_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_buffer_ids();

  // @@protoc_insertion_point(class_scope:perfetto.protos.FreeBuffersRequest)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > buffer_ids_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static FreeBuffersRequest* default_instance_;
};
// -------------------------------------------------------------------

class FreeBuffersResponse : public ::google::protobuf::MessageLite {
 public:
  FreeBuffersResponse();
  virtual ~FreeBuffersResponse();

  FreeBuffersResponse(const FreeBuffersResponse& from);

  inline FreeBuffersResponse& operator=(const FreeBuffersResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const FreeBuffersResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FreeBuffersResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FreeBuffersResponse* other);

  // implements Message ----------------------------------------------

  inline FreeBuffersResponse* New() const { return New(NULL); }

  FreeBuffersResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FreeBuffersResponse& from);
  void MergeFrom(const FreeBuffersResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FreeBuffersResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.FreeBuffersResponse)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static FreeBuffersResponse* default_instance_;
};
// -------------------------------------------------------------------

class FlushRequest : public ::google::protobuf::MessageLite {
 public:
  FlushRequest();
  virtual ~FlushRequest();

  FlushRequest(const FlushRequest& from);

  inline FlushRequest& operator=(const FlushRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const FlushRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FlushRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FlushRequest* other);

  // implements Message ----------------------------------------------

  inline FlushRequest* New() const { return New(NULL); }

  FlushRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FlushRequest& from);
  void MergeFrom(const FlushRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FlushRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 timeout_ms = 1;
  bool has_timeout_ms() const;
  void clear_timeout_ms();
  static const int kTimeoutMsFieldNumber = 1;
  ::google::protobuf::uint32 timeout_ms() const;
  void set_timeout_ms(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.FlushRequest)
 private:
  inline void set_has_timeout_ms();
  inline void clear_has_timeout_ms();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 timeout_ms_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static FlushRequest* default_instance_;
};
// -------------------------------------------------------------------

class FlushResponse : public ::google::protobuf::MessageLite {
 public:
  FlushResponse();
  virtual ~FlushResponse();

  FlushResponse(const FlushResponse& from);

  inline FlushResponse& operator=(const FlushResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const FlushResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FlushResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FlushResponse* other);

  // implements Message ----------------------------------------------

  inline FlushResponse* New() const { return New(NULL); }

  FlushResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FlushResponse& from);
  void MergeFrom(const FlushResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FlushResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.FlushResponse)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static FlushResponse* default_instance_;
};
// -------------------------------------------------------------------

class DetachRequest : public ::google::protobuf::MessageLite {
 public:
  DetachRequest();
  virtual ~DetachRequest();

  DetachRequest(const DetachRequest& from);

  inline DetachRequest& operator=(const DetachRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const DetachRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DetachRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DetachRequest* other);

  // implements Message ----------------------------------------------

  inline DetachRequest* New() const { return New(NULL); }

  DetachRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DetachRequest& from);
  void MergeFrom(const DetachRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DetachRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:perfetto.protos.DetachRequest)
 private:
  inline void set_has_key();
  inline void clear_has_key();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static DetachRequest* default_instance_;
};
// -------------------------------------------------------------------

class DetachResponse : public ::google::protobuf::MessageLite {
 public:
  DetachResponse();
  virtual ~DetachResponse();

  DetachResponse(const DetachResponse& from);

  inline DetachResponse& operator=(const DetachResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const DetachResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DetachResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DetachResponse* other);

  // implements Message ----------------------------------------------

  inline DetachResponse* New() const { return New(NULL); }

  DetachResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DetachResponse& from);
  void MergeFrom(const DetachResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DetachResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.DetachResponse)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static DetachResponse* default_instance_;
};
// -------------------------------------------------------------------

class AttachRequest : public ::google::protobuf::MessageLite {
 public:
  AttachRequest();
  virtual ~AttachRequest();

  AttachRequest(const AttachRequest& from);

  inline AttachRequest& operator=(const AttachRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const AttachRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AttachRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AttachRequest* other);

  // implements Message ----------------------------------------------

  inline AttachRequest* New() const { return New(NULL); }

  AttachRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AttachRequest& from);
  void MergeFrom(const AttachRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AttachRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:perfetto.protos.AttachRequest)
 private:
  inline void set_has_key();
  inline void clear_has_key();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static AttachRequest* default_instance_;
};
// -------------------------------------------------------------------

class AttachResponse : public ::google::protobuf::MessageLite {
 public:
  AttachResponse();
  virtual ~AttachResponse();

  AttachResponse(const AttachResponse& from);

  inline AttachResponse& operator=(const AttachResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const AttachResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AttachResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AttachResponse* other);

  // implements Message ----------------------------------------------

  inline AttachResponse* New() const { return New(NULL); }

  AttachResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AttachResponse& from);
  void MergeFrom(const AttachResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AttachResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .perfetto.protos.TraceConfig trace_config = 1;
  bool has_trace_config() const;
  void clear_trace_config();
  static const int kTraceConfigFieldNumber = 1;
  const ::perfetto::protos::TraceConfig& trace_config() const;
  ::perfetto::protos::TraceConfig* mutable_trace_config();
  ::perfetto::protos::TraceConfig* release_trace_config();
  void set_allocated_trace_config(::perfetto::protos::TraceConfig* trace_config);

  // @@protoc_insertion_point(class_scope:perfetto.protos.AttachResponse)
 private:
  inline void set_has_trace_config();
  inline void clear_has_trace_config();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::perfetto::protos::TraceConfig* trace_config_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static AttachResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetTraceStatsRequest : public ::google::protobuf::MessageLite {
 public:
  GetTraceStatsRequest();
  virtual ~GetTraceStatsRequest();

  GetTraceStatsRequest(const GetTraceStatsRequest& from);

  inline GetTraceStatsRequest& operator=(const GetTraceStatsRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const GetTraceStatsRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetTraceStatsRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetTraceStatsRequest* other);

  // implements Message ----------------------------------------------

  inline GetTraceStatsRequest* New() const { return New(NULL); }

  GetTraceStatsRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetTraceStatsRequest& from);
  void MergeFrom(const GetTraceStatsRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetTraceStatsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.GetTraceStatsRequest)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static GetTraceStatsRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetTraceStatsResponse : public ::google::protobuf::MessageLite {
 public:
  GetTraceStatsResponse();
  virtual ~GetTraceStatsResponse();

  GetTraceStatsResponse(const GetTraceStatsResponse& from);

  inline GetTraceStatsResponse& operator=(const GetTraceStatsResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const GetTraceStatsResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetTraceStatsResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetTraceStatsResponse* other);

  // implements Message ----------------------------------------------

  inline GetTraceStatsResponse* New() const { return New(NULL); }

  GetTraceStatsResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetTraceStatsResponse& from);
  void MergeFrom(const GetTraceStatsResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetTraceStatsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .perfetto.protos.TraceStats trace_stats = 1;
  bool has_trace_stats() const;
  void clear_trace_stats();
  static const int kTraceStatsFieldNumber = 1;
  const ::perfetto::protos::TraceStats& trace_stats() const;
  ::perfetto::protos::TraceStats* mutable_trace_stats();
  ::perfetto::protos::TraceStats* release_trace_stats();
  void set_allocated_trace_stats(::perfetto::protos::TraceStats* trace_stats);

  // @@protoc_insertion_point(class_scope:perfetto.protos.GetTraceStatsResponse)
 private:
  inline void set_has_trace_stats();
  inline void clear_has_trace_stats();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::perfetto::protos::TraceStats* trace_stats_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static GetTraceStatsResponse* default_instance_;
};
// -------------------------------------------------------------------

class ObserveEventsRequest : public ::google::protobuf::MessageLite {
 public:
  ObserveEventsRequest();
  virtual ~ObserveEventsRequest();

  ObserveEventsRequest(const ObserveEventsRequest& from);

  inline ObserveEventsRequest& operator=(const ObserveEventsRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ObserveEventsRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ObserveEventsRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ObserveEventsRequest* other);

  // implements Message ----------------------------------------------

  inline ObserveEventsRequest* New() const { return New(NULL); }

  ObserveEventsRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ObserveEventsRequest& from);
  void MergeFrom(const ObserveEventsRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ObserveEventsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .perfetto.protos.ObservableEvents.Type events_to_observe = 1;
  int events_to_observe_size() const;
  void clear_events_to_observe();
  static const int kEventsToObserveFieldNumber = 1;
  ::perfetto::protos::ObservableEvents_Type events_to_observe(int index) const;
  void set_events_to_observe(int index, ::perfetto::protos::ObservableEvents_Type value);
  void add_events_to_observe(::perfetto::protos::ObservableEvents_Type value);
  const ::google::protobuf::RepeatedField<int>& events_to_observe() const;
  ::google::protobuf::RepeatedField<int>* mutable_events_to_observe();

  // @@protoc_insertion_point(class_scope:perfetto.protos.ObserveEventsRequest)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField<int> events_to_observe_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static ObserveEventsRequest* default_instance_;
};
// -------------------------------------------------------------------

class ObserveEventsResponse : public ::google::protobuf::MessageLite {
 public:
  ObserveEventsResponse();
  virtual ~ObserveEventsResponse();

  ObserveEventsResponse(const ObserveEventsResponse& from);

  inline ObserveEventsResponse& operator=(const ObserveEventsResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ObserveEventsResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ObserveEventsResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ObserveEventsResponse* other);

  // implements Message ----------------------------------------------

  inline ObserveEventsResponse* New() const { return New(NULL); }

  ObserveEventsResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ObserveEventsResponse& from);
  void MergeFrom(const ObserveEventsResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ObserveEventsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .perfetto.protos.ObservableEvents events = 1;
  bool has_events() const;
  void clear_events();
  static const int kEventsFieldNumber = 1;
  const ::perfetto::protos::ObservableEvents& events() const;
  ::perfetto::protos::ObservableEvents* mutable_events();
  ::perfetto::protos::ObservableEvents* release_events();
  void set_allocated_events(::perfetto::protos::ObservableEvents* events);

  // @@protoc_insertion_point(class_scope:perfetto.protos.ObserveEventsResponse)
 private:
  inline void set_has_events();
  inline void clear_has_events();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::perfetto::protos::ObservableEvents* events_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static ObserveEventsResponse* default_instance_;
};
// -------------------------------------------------------------------

class QueryServiceStateRequest : public ::google::protobuf::MessageLite {
 public:
  QueryServiceStateRequest();
  virtual ~QueryServiceStateRequest();

  QueryServiceStateRequest(const QueryServiceStateRequest& from);

  inline QueryServiceStateRequest& operator=(const QueryServiceStateRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const QueryServiceStateRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const QueryServiceStateRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(QueryServiceStateRequest* other);

  // implements Message ----------------------------------------------

  inline QueryServiceStateRequest* New() const { return New(NULL); }

  QueryServiceStateRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const QueryServiceStateRequest& from);
  void MergeFrom(const QueryServiceStateRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(QueryServiceStateRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.QueryServiceStateRequest)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static QueryServiceStateRequest* default_instance_;
};
// -------------------------------------------------------------------

class QueryServiceStateResponse : public ::google::protobuf::MessageLite {
 public:
  QueryServiceStateResponse();
  virtual ~QueryServiceStateResponse();

  QueryServiceStateResponse(const QueryServiceStateResponse& from);

  inline QueryServiceStateResponse& operator=(const QueryServiceStateResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const QueryServiceStateResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const QueryServiceStateResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(QueryServiceStateResponse* other);

  // implements Message ----------------------------------------------

  inline QueryServiceStateResponse* New() const { return New(NULL); }

  QueryServiceStateResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const QueryServiceStateResponse& from);
  void MergeFrom(const QueryServiceStateResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(QueryServiceStateResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .perfetto.protos.TracingServiceState service_state = 1;
  bool has_service_state() const;
  void clear_service_state();
  static const int kServiceStateFieldNumber = 1;
  const ::perfetto::protos::TracingServiceState& service_state() const;
  ::perfetto::protos::TracingServiceState* mutable_service_state();
  ::perfetto::protos::TracingServiceState* release_service_state();
  void set_allocated_service_state(::perfetto::protos::TracingServiceState* service_state);

  // @@protoc_insertion_point(class_scope:perfetto.protos.QueryServiceStateResponse)
 private:
  inline void set_has_service_state();
  inline void clear_has_service_state();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::perfetto::protos::TracingServiceState* service_state_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fipc_2fconsumer_5fport_2eproto();

  void InitAsDefaultInstance();
  static QueryServiceStateResponse* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// EnableTracingRequest

// optional .perfetto.protos.TraceConfig trace_config = 1;
inline bool EnableTracingRequest::has_trace_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnableTracingRequest::set_has_trace_config() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnableTracingRequest::clear_has_trace_config() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnableTracingRequest::clear_trace_config() {
  if (trace_config_ != NULL) trace_config_->::perfetto::protos::TraceConfig::Clear();
  clear_has_trace_config();
}
inline const ::perfetto::protos::TraceConfig& EnableTracingRequest::trace_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.EnableTracingRequest.trace_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return trace_config_ != NULL ? *trace_config_ : *default_instance().trace_config_;
#else
  return trace_config_ != NULL ? *trace_config_ : *default_instance_->trace_config_;
#endif
}
inline ::perfetto::protos::TraceConfig* EnableTracingRequest::mutable_trace_config() {
  set_has_trace_config();
  if (trace_config_ == NULL) {
    trace_config_ = new ::perfetto::protos::TraceConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.EnableTracingRequest.trace_config)
  return trace_config_;
}
inline ::perfetto::protos::TraceConfig* EnableTracingRequest::release_trace_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.EnableTracingRequest.trace_config)
  clear_has_trace_config();
  ::perfetto::protos::TraceConfig* temp = trace_config_;
  trace_config_ = NULL;
  return temp;
}
inline void EnableTracingRequest::set_allocated_trace_config(::perfetto::protos::TraceConfig* trace_config) {
  delete trace_config_;
  trace_config_ = trace_config;
  if (trace_config) {
    set_has_trace_config();
  } else {
    clear_has_trace_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.EnableTracingRequest.trace_config)
}

// optional bool attach_notification_only = 2;
inline bool EnableTracingRequest::has_attach_notification_only() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnableTracingRequest::set_has_attach_notification_only() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnableTracingRequest::clear_has_attach_notification_only() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnableTracingRequest::clear_attach_notification_only() {
  attach_notification_only_ = false;
  clear_has_attach_notification_only();
}
inline bool EnableTracingRequest::attach_notification_only() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.EnableTracingRequest.attach_notification_only)
  return attach_notification_only_;
}
inline void EnableTracingRequest::set_attach_notification_only(bool value) {
  set_has_attach_notification_only();
  attach_notification_only_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.EnableTracingRequest.attach_notification_only)
}

// -------------------------------------------------------------------

// EnableTracingResponse

// optional bool disabled = 1;
inline bool EnableTracingResponse::has_disabled() const {
  return state_case() == kDisabled;
}
inline void EnableTracingResponse::set_has_disabled() {
  _oneof_case_[0] = kDisabled;
}
inline void EnableTracingResponse::clear_disabled() {
  if (has_disabled()) {
    state_.disabled_ = false;
    clear_has_state();
  }
}
inline bool EnableTracingResponse::disabled() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.EnableTracingResponse.disabled)
  if (has_disabled()) {
    return state_.disabled_;
  }
  return false;
}
inline void EnableTracingResponse::set_disabled(bool value) {
  if (!has_disabled()) {
    clear_state();
    set_has_disabled();
  }
  state_.disabled_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.EnableTracingResponse.disabled)
}

inline bool EnableTracingResponse::has_state() const {
  return state_case() != STATE_NOT_SET;
}
inline void EnableTracingResponse::clear_has_state() {
  _oneof_case_[0] = STATE_NOT_SET;
}
inline EnableTracingResponse::StateCase EnableTracingResponse::state_case() const {
  return EnableTracingResponse::StateCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// StartTracingRequest

// -------------------------------------------------------------------

// StartTracingResponse

// -------------------------------------------------------------------

// ChangeTraceConfigRequest

// optional .perfetto.protos.TraceConfig trace_config = 1;
inline bool ChangeTraceConfigRequest::has_trace_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangeTraceConfigRequest::set_has_trace_config() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangeTraceConfigRequest::clear_has_trace_config() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangeTraceConfigRequest::clear_trace_config() {
  if (trace_config_ != NULL) trace_config_->::perfetto::protos::TraceConfig::Clear();
  clear_has_trace_config();
}
inline const ::perfetto::protos::TraceConfig& ChangeTraceConfigRequest::trace_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ChangeTraceConfigRequest.trace_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return trace_config_ != NULL ? *trace_config_ : *default_instance().trace_config_;
#else
  return trace_config_ != NULL ? *trace_config_ : *default_instance_->trace_config_;
#endif
}
inline ::perfetto::protos::TraceConfig* ChangeTraceConfigRequest::mutable_trace_config() {
  set_has_trace_config();
  if (trace_config_ == NULL) {
    trace_config_ = new ::perfetto::protos::TraceConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.ChangeTraceConfigRequest.trace_config)
  return trace_config_;
}
inline ::perfetto::protos::TraceConfig* ChangeTraceConfigRequest::release_trace_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.ChangeTraceConfigRequest.trace_config)
  clear_has_trace_config();
  ::perfetto::protos::TraceConfig* temp = trace_config_;
  trace_config_ = NULL;
  return temp;
}
inline void ChangeTraceConfigRequest::set_allocated_trace_config(::perfetto::protos::TraceConfig* trace_config) {
  delete trace_config_;
  trace_config_ = trace_config;
  if (trace_config) {
    set_has_trace_config();
  } else {
    clear_has_trace_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.ChangeTraceConfigRequest.trace_config)
}

// -------------------------------------------------------------------

// ChangeTraceConfigResponse

// -------------------------------------------------------------------

// DisableTracingRequest

// -------------------------------------------------------------------

// DisableTracingResponse

// -------------------------------------------------------------------

// ReadBuffersRequest

// -------------------------------------------------------------------

// ReadBuffersResponse_Slice

// optional bytes data = 1;
inline bool ReadBuffersResponse_Slice::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReadBuffersResponse_Slice::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReadBuffersResponse_Slice::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReadBuffersResponse_Slice::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
inline const ::std::string& ReadBuffersResponse_Slice::data() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ReadBuffersResponse.Slice.data)
  return data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReadBuffersResponse_Slice::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.ReadBuffersResponse.Slice.data)
}
inline void ReadBuffersResponse_Slice::set_data(const char* value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.ReadBuffersResponse.Slice.data)
}
inline void ReadBuffersResponse_Slice::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.ReadBuffersResponse.Slice.data)
}
inline ::std::string* ReadBuffersResponse_Slice::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.ReadBuffersResponse.Slice.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReadBuffersResponse_Slice::release_data() {
  // @@protoc_insertion_point(field_release:perfetto.protos.ReadBuffersResponse.Slice.data)
  clear_has_data();
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReadBuffersResponse_Slice::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.ReadBuffersResponse.Slice.data)
}

// optional bool last_slice_for_packet = 2;
inline bool ReadBuffersResponse_Slice::has_last_slice_for_packet() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReadBuffersResponse_Slice::set_has_last_slice_for_packet() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReadBuffersResponse_Slice::clear_has_last_slice_for_packet() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReadBuffersResponse_Slice::clear_last_slice_for_packet() {
  last_slice_for_packet_ = false;
  clear_has_last_slice_for_packet();
}
inline bool ReadBuffersResponse_Slice::last_slice_for_packet() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ReadBuffersResponse.Slice.last_slice_for_packet)
  return last_slice_for_packet_;
}
inline void ReadBuffersResponse_Slice::set_last_slice_for_packet(bool value) {
  set_has_last_slice_for_packet();
  last_slice_for_packet_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.ReadBuffersResponse.Slice.last_slice_for_packet)
}

// -------------------------------------------------------------------

// ReadBuffersResponse

// repeated .perfetto.protos.ReadBuffersResponse.Slice slices = 2;
inline int ReadBuffersResponse::slices_size() const {
  return slices_.size();
}
inline void ReadBuffersResponse::clear_slices() {
  slices_.Clear();
}
inline const ::perfetto::protos::ReadBuffersResponse_Slice& ReadBuffersResponse::slices(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ReadBuffersResponse.slices)
  return slices_.Get(index);
}
inline ::perfetto::protos::ReadBuffersResponse_Slice* ReadBuffersResponse::mutable_slices(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.ReadBuffersResponse.slices)
  return slices_.Mutable(index);
}
inline ::perfetto::protos::ReadBuffersResponse_Slice* ReadBuffersResponse::add_slices() {
  // @@protoc_insertion_point(field_add:perfetto.protos.ReadBuffersResponse.slices)
  return slices_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::ReadBuffersResponse_Slice >*
ReadBuffersResponse::mutable_slices() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.ReadBuffersResponse.slices)
  return &slices_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::ReadBuffersResponse_Slice >&
ReadBuffersResponse::slices() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.ReadBuffersResponse.slices)
  return slices_;
}

// -------------------------------------------------------------------

// FreeBuffersRequest

// repeated uint32 buffer_ids = 1;
inline int FreeBuffersRequest::buffer_ids_size() const {
  return buffer_ids_.size();
}
inline void FreeBuffersRequest::clear_buffer_ids() {
  buffer_ids_.Clear();
}
inline ::google::protobuf::uint32 FreeBuffersRequest::buffer_ids(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FreeBuffersRequest.buffer_ids)
  return buffer_ids_.Get(index);
}
inline void FreeBuffersRequest::set_buffer_ids(int index, ::google::protobuf::uint32 value) {
  buffer_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.FreeBuffersRequest.buffer_ids)
}
inline void FreeBuffersRequest::add_buffer_ids(::google::protobuf::uint32 value) {
  buffer_ids_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.FreeBuffersRequest.buffer_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
FreeBuffersRequest::buffer_ids() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.FreeBuffersRequest.buffer_ids)
  return buffer_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
FreeBuffersRequest::mutable_buffer_ids() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.FreeBuffersRequest.buffer_ids)
  return &buffer_ids_;
}

// -------------------------------------------------------------------

// FreeBuffersResponse

// -------------------------------------------------------------------

// FlushRequest

// optional uint32 timeout_ms = 1;
inline bool FlushRequest::has_timeout_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FlushRequest::set_has_timeout_ms() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FlushRequest::clear_has_timeout_ms() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FlushRequest::clear_timeout_ms() {
  timeout_ms_ = 0u;
  clear_has_timeout_ms();
}
inline ::google::protobuf::uint32 FlushRequest::timeout_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FlushRequest.timeout_ms)
  return timeout_ms_;
}
inline void FlushRequest::set_timeout_ms(::google::protobuf::uint32 value) {
  set_has_timeout_ms();
  timeout_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.FlushRequest.timeout_ms)
}

// -------------------------------------------------------------------

// FlushResponse

// -------------------------------------------------------------------

// DetachRequest

// optional string key = 1;
inline bool DetachRequest::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DetachRequest::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DetachRequest::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DetachRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& DetachRequest::key() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DetachRequest.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DetachRequest::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.DetachRequest.key)
}
inline void DetachRequest::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.DetachRequest.key)
}
inline void DetachRequest::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.DetachRequest.key)
}
inline ::std::string* DetachRequest::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DetachRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DetachRequest::release_key() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DetachRequest.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DetachRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DetachRequest.key)
}

// -------------------------------------------------------------------

// DetachResponse

// -------------------------------------------------------------------

// AttachRequest

// optional string key = 1;
inline bool AttachRequest::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AttachRequest::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AttachRequest::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AttachRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& AttachRequest::key() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AttachRequest.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AttachRequest::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.AttachRequest.key)
}
inline void AttachRequest::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.AttachRequest.key)
}
inline void AttachRequest::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.AttachRequest.key)
}
inline ::std::string* AttachRequest::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.AttachRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AttachRequest::release_key() {
  // @@protoc_insertion_point(field_release:perfetto.protos.AttachRequest.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AttachRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.AttachRequest.key)
}

// -------------------------------------------------------------------

// AttachResponse

// optional .perfetto.protos.TraceConfig trace_config = 1;
inline bool AttachResponse::has_trace_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AttachResponse::set_has_trace_config() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AttachResponse::clear_has_trace_config() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AttachResponse::clear_trace_config() {
  if (trace_config_ != NULL) trace_config_->::perfetto::protos::TraceConfig::Clear();
  clear_has_trace_config();
}
inline const ::perfetto::protos::TraceConfig& AttachResponse::trace_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AttachResponse.trace_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return trace_config_ != NULL ? *trace_config_ : *default_instance().trace_config_;
#else
  return trace_config_ != NULL ? *trace_config_ : *default_instance_->trace_config_;
#endif
}
inline ::perfetto::protos::TraceConfig* AttachResponse::mutable_trace_config() {
  set_has_trace_config();
  if (trace_config_ == NULL) {
    trace_config_ = new ::perfetto::protos::TraceConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.AttachResponse.trace_config)
  return trace_config_;
}
inline ::perfetto::protos::TraceConfig* AttachResponse::release_trace_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.AttachResponse.trace_config)
  clear_has_trace_config();
  ::perfetto::protos::TraceConfig* temp = trace_config_;
  trace_config_ = NULL;
  return temp;
}
inline void AttachResponse::set_allocated_trace_config(::perfetto::protos::TraceConfig* trace_config) {
  delete trace_config_;
  trace_config_ = trace_config;
  if (trace_config) {
    set_has_trace_config();
  } else {
    clear_has_trace_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.AttachResponse.trace_config)
}

// -------------------------------------------------------------------

// GetTraceStatsRequest

// -------------------------------------------------------------------

// GetTraceStatsResponse

// optional .perfetto.protos.TraceStats trace_stats = 1;
inline bool GetTraceStatsResponse::has_trace_stats() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetTraceStatsResponse::set_has_trace_stats() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetTraceStatsResponse::clear_has_trace_stats() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetTraceStatsResponse::clear_trace_stats() {
  if (trace_stats_ != NULL) trace_stats_->::perfetto::protos::TraceStats::Clear();
  clear_has_trace_stats();
}
inline const ::perfetto::protos::TraceStats& GetTraceStatsResponse::trace_stats() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetTraceStatsResponse.trace_stats)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return trace_stats_ != NULL ? *trace_stats_ : *default_instance().trace_stats_;
#else
  return trace_stats_ != NULL ? *trace_stats_ : *default_instance_->trace_stats_;
#endif
}
inline ::perfetto::protos::TraceStats* GetTraceStatsResponse::mutable_trace_stats() {
  set_has_trace_stats();
  if (trace_stats_ == NULL) {
    trace_stats_ = new ::perfetto::protos::TraceStats;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GetTraceStatsResponse.trace_stats)
  return trace_stats_;
}
inline ::perfetto::protos::TraceStats* GetTraceStatsResponse::release_trace_stats() {
  // @@protoc_insertion_point(field_release:perfetto.protos.GetTraceStatsResponse.trace_stats)
  clear_has_trace_stats();
  ::perfetto::protos::TraceStats* temp = trace_stats_;
  trace_stats_ = NULL;
  return temp;
}
inline void GetTraceStatsResponse::set_allocated_trace_stats(::perfetto::protos::TraceStats* trace_stats) {
  delete trace_stats_;
  trace_stats_ = trace_stats;
  if (trace_stats) {
    set_has_trace_stats();
  } else {
    clear_has_trace_stats();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.GetTraceStatsResponse.trace_stats)
}

// -------------------------------------------------------------------

// ObserveEventsRequest

// repeated .perfetto.protos.ObservableEvents.Type events_to_observe = 1;
inline int ObserveEventsRequest::events_to_observe_size() const {
  return events_to_observe_.size();
}
inline void ObserveEventsRequest::clear_events_to_observe() {
  events_to_observe_.Clear();
}
inline ::perfetto::protos::ObservableEvents_Type ObserveEventsRequest::events_to_observe(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ObserveEventsRequest.events_to_observe)
  return static_cast< ::perfetto::protos::ObservableEvents_Type >(events_to_observe_.Get(index));
}
inline void ObserveEventsRequest::set_events_to_observe(int index, ::perfetto::protos::ObservableEvents_Type value) {
  assert(::perfetto::protos::ObservableEvents_Type_IsValid(value));
  events_to_observe_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.ObserveEventsRequest.events_to_observe)
}
inline void ObserveEventsRequest::add_events_to_observe(::perfetto::protos::ObservableEvents_Type value) {
  assert(::perfetto::protos::ObservableEvents_Type_IsValid(value));
  events_to_observe_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.ObserveEventsRequest.events_to_observe)
}
inline const ::google::protobuf::RepeatedField<int>&
ObserveEventsRequest::events_to_observe() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.ObserveEventsRequest.events_to_observe)
  return events_to_observe_;
}
inline ::google::protobuf::RepeatedField<int>*
ObserveEventsRequest::mutable_events_to_observe() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.ObserveEventsRequest.events_to_observe)
  return &events_to_observe_;
}

// -------------------------------------------------------------------

// ObserveEventsResponse

// optional .perfetto.protos.ObservableEvents events = 1;
inline bool ObserveEventsResponse::has_events() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObserveEventsResponse::set_has_events() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ObserveEventsResponse::clear_has_events() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ObserveEventsResponse::clear_events() {
  if (events_ != NULL) events_->::perfetto::protos::ObservableEvents::Clear();
  clear_has_events();
}
inline const ::perfetto::protos::ObservableEvents& ObserveEventsResponse::events() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ObserveEventsResponse.events)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return events_ != NULL ? *events_ : *default_instance().events_;
#else
  return events_ != NULL ? *events_ : *default_instance_->events_;
#endif
}
inline ::perfetto::protos::ObservableEvents* ObserveEventsResponse::mutable_events() {
  set_has_events();
  if (events_ == NULL) {
    events_ = new ::perfetto::protos::ObservableEvents;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.ObserveEventsResponse.events)
  return events_;
}
inline ::perfetto::protos::ObservableEvents* ObserveEventsResponse::release_events() {
  // @@protoc_insertion_point(field_release:perfetto.protos.ObserveEventsResponse.events)
  clear_has_events();
  ::perfetto::protos::ObservableEvents* temp = events_;
  events_ = NULL;
  return temp;
}
inline void ObserveEventsResponse::set_allocated_events(::perfetto::protos::ObservableEvents* events) {
  delete events_;
  events_ = events;
  if (events) {
    set_has_events();
  } else {
    clear_has_events();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.ObserveEventsResponse.events)
}

// -------------------------------------------------------------------

// QueryServiceStateRequest

// -------------------------------------------------------------------

// QueryServiceStateResponse

// optional .perfetto.protos.TracingServiceState service_state = 1;
inline bool QueryServiceStateResponse::has_service_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryServiceStateResponse::set_has_service_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryServiceStateResponse::clear_has_service_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryServiceStateResponse::clear_service_state() {
  if (service_state_ != NULL) service_state_->::perfetto::protos::TracingServiceState::Clear();
  clear_has_service_state();
}
inline const ::perfetto::protos::TracingServiceState& QueryServiceStateResponse::service_state() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.QueryServiceStateResponse.service_state)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return service_state_ != NULL ? *service_state_ : *default_instance().service_state_;
#else
  return service_state_ != NULL ? *service_state_ : *default_instance_->service_state_;
#endif
}
inline ::perfetto::protos::TracingServiceState* QueryServiceStateResponse::mutable_service_state() {
  set_has_service_state();
  if (service_state_ == NULL) {
    service_state_ = new ::perfetto::protos::TracingServiceState;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.QueryServiceStateResponse.service_state)
  return service_state_;
}
inline ::perfetto::protos::TracingServiceState* QueryServiceStateResponse::release_service_state() {
  // @@protoc_insertion_point(field_release:perfetto.protos.QueryServiceStateResponse.service_state)
  clear_has_service_state();
  ::perfetto::protos::TracingServiceState* temp = service_state_;
  service_state_ = NULL;
  return temp;
}
inline void QueryServiceStateResponse::set_allocated_service_state(::perfetto::protos::TracingServiceState* service_state) {
  delete service_state_;
  service_state_ = service_state;
  if (service_state) {
    set_has_service_state();
  } else {
    clear_has_service_state();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.QueryServiceStateResponse.service_state)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_perfetto_2fipc_2fconsumer_5fport_2eproto__INCLUDED
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/ipc/consumer_port.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
// gen_amalgamated expanded: #include "perfetto/ipc/consumer_port.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

void protobuf_ShutdownFile_perfetto_2fipc_2fconsumer_5fport_2eproto() {
  delete EnableTracingRequest::default_instance_;
  delete EnableTracingResponse::default_instance_;
  delete StartTracingRequest::default_instance_;
  delete StartTracingResponse::default_instance_;
  delete ChangeTraceConfigRequest::default_instance_;
  delete ChangeTraceConfigResponse::default_instance_;
  delete DisableTracingRequest::default_instance_;
  delete DisableTracingResponse::default_instance_;
  delete ReadBuffersRequest::default_instance_;
  delete ReadBuffersResponse::default_instance_;
  delete ReadBuffersResponse_Slice::default_instance_;
  delete FreeBuffersRequest::default_instance_;
  delete FreeBuffersResponse::default_instance_;
  delete FlushRequest::default_instance_;
  delete FlushResponse::default_instance_;
  delete DetachRequest::default_instance_;
  delete DetachResponse::default_instance_;
  delete AttachRequest::default_instance_;
  delete AttachResponse::default_instance_;
  delete GetTraceStatsRequest::default_instance_;
  delete GetTraceStatsResponse::default_instance_;
  delete ObserveEventsRequest::default_instance_;
  delete ObserveEventsResponse::default_instance_;
  delete QueryServiceStateRequest::default_instance_;
  delete QueryServiceStateResponse::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::perfetto::protos::protobuf_AddDesc_perfetto_2fcommon_2fobservable_5fevents_2eproto();
  ::perfetto::protos::protobuf_AddDesc_perfetto_2fcommon_2ftracing_5fservice_5fstate_2eproto();
  ::perfetto::protos::protobuf_AddDesc_perfetto_2fcommon_2ftrace_5fstats_2eproto();
  ::perfetto::protos::protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto();
  EnableTracingRequest::default_instance_ = new EnableTracingRequest();
  EnableTracingResponse::default_instance_ = new EnableTracingResponse();
  StartTracingRequest::default_instance_ = new StartTracingRequest();
  StartTracingResponse::default_instance_ = new StartTracingResponse();
  ChangeTraceConfigRequest::default_instance_ = new ChangeTraceConfigRequest();
  ChangeTraceConfigResponse::default_instance_ = new ChangeTraceConfigResponse();
  DisableTracingRequest::default_instance_ = new DisableTracingRequest();
  DisableTracingResponse::default_instance_ = new DisableTracingResponse();
  ReadBuffersRequest::default_instance_ = new ReadBuffersRequest();
  ReadBuffersResponse::default_instance_ = new ReadBuffersResponse();
  ReadBuffersResponse_Slice::default_instance_ = new ReadBuffersResponse_Slice();
  FreeBuffersRequest::default_instance_ = new FreeBuffersRequest();
  FreeBuffersResponse::default_instance_ = new FreeBuffersResponse();
  FlushRequest::default_instance_ = new FlushRequest();
  FlushResponse::default_instance_ = new FlushResponse();
  DetachRequest::default_instance_ = new DetachRequest();
  DetachResponse::default_instance_ = new DetachResponse();
  AttachRequest::default_instance_ = new AttachRequest();
  AttachResponse::default_instance_ = new AttachResponse();
  GetTraceStatsRequest::default_instance_ = new GetTraceStatsRequest();
  GetTraceStatsResponse::default_instance_ = new GetTraceStatsResponse();
  ObserveEventsRequest::default_instance_ = new ObserveEventsRequest();
  ObserveEventsResponse::default_instance_ = new ObserveEventsResponse();
  QueryServiceStateRequest::default_instance_ = new QueryServiceStateRequest();
  QueryServiceStateResponse::default_instance_ = new QueryServiceStateResponse();
  EnableTracingRequest::default_instance_->InitAsDefaultInstance();
  EnableTracingResponse::default_instance_->InitAsDefaultInstance();
  StartTracingRequest::default_instance_->InitAsDefaultInstance();
  StartTracingResponse::default_instance_->InitAsDefaultInstance();
  ChangeTraceConfigRequest::default_instance_->InitAsDefaultInstance();
  ChangeTraceConfigResponse::default_instance_->InitAsDefaultInstance();
  DisableTracingRequest::default_instance_->InitAsDefaultInstance();
  DisableTracingResponse::default_instance_->InitAsDefaultInstance();
  ReadBuffersRequest::default_instance_->InitAsDefaultInstance();
  ReadBuffersResponse::default_instance_->InitAsDefaultInstance();
  ReadBuffersResponse_Slice::default_instance_->InitAsDefaultInstance();
  FreeBuffersRequest::default_instance_->InitAsDefaultInstance();
  FreeBuffersResponse::default_instance_->InitAsDefaultInstance();
  FlushRequest::default_instance_->InitAsDefaultInstance();
  FlushResponse::default_instance_->InitAsDefaultInstance();
  DetachRequest::default_instance_->InitAsDefaultInstance();
  DetachResponse::default_instance_->InitAsDefaultInstance();
  AttachRequest::default_instance_->InitAsDefaultInstance();
  AttachResponse::default_instance_->InitAsDefaultInstance();
  GetTraceStatsRequest::default_instance_->InitAsDefaultInstance();
  GetTraceStatsResponse::default_instance_->InitAsDefaultInstance();
  ObserveEventsRequest::default_instance_->InitAsDefaultInstance();
  ObserveEventsResponse::default_instance_->InitAsDefaultInstance();
  QueryServiceStateRequest::default_instance_->InitAsDefaultInstance();
  QueryServiceStateResponse::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_perfetto_2fipc_2fconsumer_5fport_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto_once_);
void protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto_once_,
                 &protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_perfetto_2fipc_2fconsumer_5fport_2eproto {
  StaticDescriptorInitializer_perfetto_2fipc_2fconsumer_5fport_2eproto() {
    protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
  }
} static_descriptor_initializer_perfetto_2fipc_2fconsumer_5fport_2eproto_;
#endif

namespace {

static void consumer_port_pb_MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
static void consumer_port_pb_MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

static ::std::string* MutableUnknownFieldsForEnableTracingRequest(
    EnableTracingRequest* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EnableTracingRequest::kTraceConfigFieldNumber;
const int EnableTracingRequest::kAttachNotificationOnlyFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EnableTracingRequest::EnableTracingRequest()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.EnableTracingRequest)
}

void EnableTracingRequest::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  trace_config_ = const_cast< ::perfetto::protos::TraceConfig*>(
      ::perfetto::protos::TraceConfig::internal_default_instance());
#else
  trace_config_ = const_cast< ::perfetto::protos::TraceConfig*>(&::perfetto::protos::TraceConfig::default_instance());
#endif
}

EnableTracingRequest::EnableTracingRequest(const EnableTracingRequest& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.EnableTracingRequest)
}

void EnableTracingRequest::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  trace_config_ = NULL;
  attach_notification_only_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EnableTracingRequest::~EnableTracingRequest() {
  // @@protoc_insertion_point(destructor:perfetto.protos.EnableTracingRequest)
  SharedDtor();
}

void EnableTracingRequest::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete trace_config_;
  }
}

void EnableTracingRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const EnableTracingRequest& EnableTracingRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
#endif
  return *default_instance_;
}

EnableTracingRequest* EnableTracingRequest::default_instance_ = NULL;

EnableTracingRequest* EnableTracingRequest::New(::google::protobuf::Arena* arena) const {
  EnableTracingRequest* n = new EnableTracingRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void EnableTracingRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.EnableTracingRequest)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_trace_config()) {
      if (trace_config_ != NULL) trace_config_->::perfetto::protos::TraceConfig::Clear();
    }
    attach_notification_only_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool EnableTracingRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForEnableTracingRequest, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.EnableTracingRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .perfetto.protos.TraceConfig trace_config = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_trace_config()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_attach_notification_only;
        break;
      }

      // optional bool attach_notification_only = 2;
      case 2: {
        if (tag == 16) {
         parse_attach_notification_only:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &attach_notification_only_)));
          set_has_attach_notification_only();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.EnableTracingRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.EnableTracingRequest)
  return false;
#undef DO_
}

void EnableTracingRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.EnableTracingRequest)
  // optional .perfetto.protos.TraceConfig trace_config = 1;
  if (has_trace_config()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->trace_config_, output);
  }

  // optional bool attach_notification_only = 2;
  if (has_attach_notification_only()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->attach_notification_only(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.EnableTracingRequest)
}

int EnableTracingRequest::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.EnableTracingRequest)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional .perfetto.protos.TraceConfig trace_config = 1;
    if (has_trace_config()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->trace_config_);
    }

    // optional bool attach_notification_only = 2;
    if (has_attach_notification_only()) {
      total_size += 1 + 1;
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EnableTracingRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const EnableTracingRequest*>(&from));
}

void EnableTracingRequest::MergeFrom(const EnableTracingRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.EnableTracingRequest)
  if (GOOGLE_PREDICT_FALSE(&from == this)) consumer_port_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_trace_config()) {
      mutable_trace_config()->::perfetto::protos::TraceConfig::MergeFrom(from.trace_config());
    }
    if (from.has_attach_notification_only()) {
      set_attach_notification_only(from.attach_notification_only());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void EnableTracingRequest::CopyFrom(const EnableTracingRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.EnableTracingRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EnableTracingRequest::IsInitialized() const {

  return true;
}

void EnableTracingRequest::Swap(EnableTracingRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EnableTracingRequest::InternalSwap(EnableTracingRequest* other) {
  std::swap(trace_config_, other->trace_config_);
  std::swap(attach_notification_only_, other->attach_notification_only_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string EnableTracingRequest::GetTypeName() const {
  return "perfetto.protos.EnableTracingRequest";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// EnableTracingRequest

// optional .perfetto.protos.TraceConfig trace_config = 1;
bool EnableTracingRequest::has_trace_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void EnableTracingRequest::set_has_trace_config() {
  _has_bits_[0] |= 0x00000001u;
}
void EnableTracingRequest::clear_has_trace_config() {
  _has_bits_[0] &= ~0x00000001u;
}
void EnableTracingRequest::clear_trace_config() {
  if (trace_config_ != NULL) trace_config_->::perfetto::protos::TraceConfig::Clear();
  clear_has_trace_config();
}
const ::perfetto::protos::TraceConfig& EnableTracingRequest::trace_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.EnableTracingRequest.trace_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return trace_config_ != NULL ? *trace_config_ : *default_instance().trace_config_;
#else
  return trace_config_ != NULL ? *trace_config_ : *default_instance_->trace_config_;
#endif
}
::perfetto::protos::TraceConfig* EnableTracingRequest::mutable_trace_config() {
  set_has_trace_config();
  if (trace_config_ == NULL) {
    trace_config_ = new ::perfetto::protos::TraceConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.EnableTracingRequest.trace_config)
  return trace_config_;
}
::perfetto::protos::TraceConfig* EnableTracingRequest::release_trace_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.EnableTracingRequest.trace_config)
  clear_has_trace_config();
  ::perfetto::protos::TraceConfig* temp = trace_config_;
  trace_config_ = NULL;
  return temp;
}
void EnableTracingRequest::set_allocated_trace_config(::perfetto::protos::TraceConfig* trace_config) {
  delete trace_config_;
  trace_config_ = trace_config;
  if (trace_config) {
    set_has_trace_config();
  } else {
    clear_has_trace_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.EnableTracingRequest.trace_config)
}

// optional bool attach_notification_only = 2;
bool EnableTracingRequest::has_attach_notification_only() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void EnableTracingRequest::set_has_attach_notification_only() {
  _has_bits_[0] |= 0x00000002u;
}
void EnableTracingRequest::clear_has_attach_notification_only() {
  _has_bits_[0] &= ~0x00000002u;
}
void EnableTracingRequest::clear_attach_notification_only() {
  attach_notification_only_ = false;
  clear_has_attach_notification_only();
}
 bool EnableTracingRequest::attach_notification_only() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.EnableTracingRequest.attach_notification_only)
  return attach_notification_only_;
}
 void EnableTracingRequest::set_attach_notification_only(bool value) {
  set_has_attach_notification_only();
  attach_notification_only_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.EnableTracingRequest.attach_notification_only)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForEnableTracingResponse(
    EnableTracingResponse* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EnableTracingResponse::kDisabledFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EnableTracingResponse::EnableTracingResponse()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.EnableTracingResponse)
}

void EnableTracingResponse::InitAsDefaultInstance() {
}

EnableTracingResponse::EnableTracingResponse(const EnableTracingResponse& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.EnableTracingResponse)
}

void EnableTracingResponse::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  clear_has_state();
}

EnableTracingResponse::~EnableTracingResponse() {
  // @@protoc_insertion_point(destructor:perfetto.protos.EnableTracingResponse)
  SharedDtor();
}

void EnableTracingResponse::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (has_state()) {
    clear_state();
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void EnableTracingResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const EnableTracingResponse& EnableTracingResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
#endif
  return *default_instance_;
}

EnableTracingResponse* EnableTracingResponse::default_instance_ = NULL;

EnableTracingResponse* EnableTracingResponse::New(::google::protobuf::Arena* arena) const {
  EnableTracingResponse* n = new EnableTracingResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void EnableTracingResponse::clear_state() {
// @@protoc_insertion_point(one_of_clear_start:perfetto.protos.EnableTracingResponse)
  switch(state_case()) {
    case kDisabled: {
      // No need to clear
      break;
    }
    case STATE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = STATE_NOT_SET;
}


void EnableTracingResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.EnableTracingResponse)
  clear_state();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool EnableTracingResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForEnableTracingResponse, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.EnableTracingResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool disabled = 1;
      case 1: {
        if (tag == 8) {
          clear_state();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &state_.disabled_)));
          set_has_disabled();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.EnableTracingResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.EnableTracingResponse)
  return false;
#undef DO_
}

void EnableTracingResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.EnableTracingResponse)
  // optional bool disabled = 1;
  if (has_disabled()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->disabled(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.EnableTracingResponse)
}

int EnableTracingResponse::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.EnableTracingResponse)
  int total_size = 0;

  switch (state_case()) {
    // optional bool disabled = 1;
    case kDisabled: {
      total_size += 1 + 1;
      break;
    }
    case STATE_NOT_SET: {
      break;
    }
  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EnableTracingResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const EnableTracingResponse*>(&from));
}

void EnableTracingResponse::MergeFrom(const EnableTracingResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.EnableTracingResponse)
  if (GOOGLE_PREDICT_FALSE(&from == this)) consumer_port_pb_MergeFromFail(__LINE__);
  switch (from.state_case()) {
    case kDisabled: {
      set_disabled(from.disabled());
      break;
    }
    case STATE_NOT_SET: {
      break;
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void EnableTracingResponse::CopyFrom(const EnableTracingResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.EnableTracingResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EnableTracingResponse::IsInitialized() const {

  return true;
}

void EnableTracingResponse::Swap(EnableTracingResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EnableTracingResponse::InternalSwap(EnableTracingResponse* other) {
  std::swap(state_, other->state_);
  std::swap(_oneof_case_[0], other->_oneof_case_[0]);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string EnableTracingResponse::GetTypeName() const {
  return "perfetto.protos.EnableTracingResponse";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// EnableTracingResponse

// optional bool disabled = 1;
bool EnableTracingResponse::has_disabled() const {
  return state_case() == kDisabled;
}
void EnableTracingResponse::set_has_disabled() {
  _oneof_case_[0] = kDisabled;
}
void EnableTracingResponse::clear_disabled() {
  if (has_disabled()) {
    state_.disabled_ = false;
    clear_has_state();
  }
}
 bool EnableTracingResponse::disabled() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.EnableTracingResponse.disabled)
  if (has_disabled()) {
    return state_.disabled_;
  }
  return false;
}
 void EnableTracingResponse::set_disabled(bool value) {
  if (!has_disabled()) {
    clear_state();
    set_has_disabled();
  }
  state_.disabled_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.EnableTracingResponse.disabled)
}

bool EnableTracingResponse::has_state() const {
  return state_case() != STATE_NOT_SET;
}
void EnableTracingResponse::clear_has_state() {
  _oneof_case_[0] = STATE_NOT_SET;
}
EnableTracingResponse::StateCase EnableTracingResponse::state_case() const {
  return EnableTracingResponse::StateCase(_oneof_case_[0]);
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForStartTracingRequest(
    StartTracingRequest* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

StartTracingRequest::StartTracingRequest()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.StartTracingRequest)
}

void StartTracingRequest::InitAsDefaultInstance() {
}

StartTracingRequest::StartTracingRequest(const StartTracingRequest& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.StartTracingRequest)
}

void StartTracingRequest::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StartTracingRequest::~StartTracingRequest() {
  // @@protoc_insertion_point(destructor:perfetto.protos.StartTracingRequest)
  SharedDtor();
}

void StartTracingRequest::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void StartTracingRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StartTracingRequest& StartTracingRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
#endif
  return *default_instance_;
}

StartTracingRequest* StartTracingRequest::default_instance_ = NULL;

StartTracingRequest* StartTracingRequest::New(::google::protobuf::Arena* arena) const {
  StartTracingRequest* n = new StartTracingRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void StartTracingRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.StartTracingRequest)
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool StartTracingRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForStartTracingRequest, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.StartTracingRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.StartTracingRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.StartTracingRequest)
  return false;
#undef DO_
}

void StartTracingRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.StartTracingRequest)
  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.StartTracingRequest)
}

int StartTracingRequest::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.StartTracingRequest)
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StartTracingRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StartTracingRequest*>(&from));
}

void StartTracingRequest::MergeFrom(const StartTracingRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.StartTracingRequest)
  if (GOOGLE_PREDICT_FALSE(&from == this)) consumer_port_pb_MergeFromFail(__LINE__);
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void StartTracingRequest::CopyFrom(const StartTracingRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.StartTracingRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StartTracingRequest::IsInitialized() const {

  return true;
}

void StartTracingRequest::Swap(StartTracingRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void StartTracingRequest::InternalSwap(StartTracingRequest* other) {
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string StartTracingRequest::GetTypeName() const {
  return "perfetto.protos.StartTracingRequest";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// StartTracingRequest

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForStartTracingResponse(
    StartTracingResponse* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

StartTracingResponse::StartTracingResponse()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.StartTracingResponse)
}

void StartTracingResponse::InitAsDefaultInstance() {
}

StartTracingResponse::StartTracingResponse(const StartTracingResponse& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.StartTracingResponse)
}

void StartTracingResponse::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StartTracingResponse::~StartTracingResponse() {
  // @@protoc_insertion_point(destructor:perfetto.protos.StartTracingResponse)
  SharedDtor();
}

void StartTracingResponse::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void StartTracingResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const StartTracingResponse& StartTracingResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
#endif
  return *default_instance_;
}

StartTracingResponse* StartTracingResponse::default_instance_ = NULL;

StartTracingResponse* StartTracingResponse::New(::google::protobuf::Arena* arena) const {
  StartTracingResponse* n = new StartTracingResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void StartTracingResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.StartTracingResponse)
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool StartTracingResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForStartTracingResponse, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.StartTracingResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.StartTracingResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.StartTracingResponse)
  return false;
#undef DO_
}

void StartTracingResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.StartTracingResponse)
  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.StartTracingResponse)
}

int StartTracingResponse::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.StartTracingResponse)
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StartTracingResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const StartTracingResponse*>(&from));
}

void StartTracingResponse::MergeFrom(const StartTracingResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.StartTracingResponse)
  if (GOOGLE_PREDICT_FALSE(&from == this)) consumer_port_pb_MergeFromFail(__LINE__);
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void StartTracingResponse::CopyFrom(const StartTracingResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.StartTracingResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StartTracingResponse::IsInitialized() const {

  return true;
}

void StartTracingResponse::Swap(StartTracingResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void StartTracingResponse::InternalSwap(StartTracingResponse* other) {
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string StartTracingResponse::GetTypeName() const {
  return "perfetto.protos.StartTracingResponse";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// StartTracingResponse

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForChangeTraceConfigRequest(
    ChangeTraceConfigRequest* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ChangeTraceConfigRequest::kTraceConfigFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ChangeTraceConfigRequest::ChangeTraceConfigRequest()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.ChangeTraceConfigRequest)
}

void ChangeTraceConfigRequest::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  trace_config_ = const_cast< ::perfetto::protos::TraceConfig*>(
      ::perfetto::protos::TraceConfig::internal_default_instance());
#else
  trace_config_ = const_cast< ::perfetto::protos::TraceConfig*>(&::perfetto::protos::TraceConfig::default_instance());
#endif
}

ChangeTraceConfigRequest::ChangeTraceConfigRequest(const ChangeTraceConfigRequest& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.ChangeTraceConfigRequest)
}

void ChangeTraceConfigRequest::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  trace_config_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChangeTraceConfigRequest::~ChangeTraceConfigRequest() {
  // @@protoc_insertion_point(destructor:perfetto.protos.ChangeTraceConfigRequest)
  SharedDtor();
}

void ChangeTraceConfigRequest::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete trace_config_;
  }
}

void ChangeTraceConfigRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ChangeTraceConfigRequest& ChangeTraceConfigRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
#endif
  return *default_instance_;
}

ChangeTraceConfigRequest* ChangeTraceConfigRequest::default_instance_ = NULL;

ChangeTraceConfigRequest* ChangeTraceConfigRequest::New(::google::protobuf::Arena* arena) const {
  ChangeTraceConfigRequest* n = new ChangeTraceConfigRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ChangeTraceConfigRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.ChangeTraceConfigRequest)
  if (has_trace_config()) {
    if (trace_config_ != NULL) trace_config_->::perfetto::protos::TraceConfig::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool ChangeTraceConfigRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForChangeTraceConfigRequest, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.ChangeTraceConfigRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .perfetto.protos.TraceConfig trace_config = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_trace_config()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.ChangeTraceConfigRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.ChangeTraceConfigRequest)
  return false;
#undef DO_
}

void ChangeTraceConfigRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.ChangeTraceConfigRequest)
  // optional .perfetto.protos.TraceConfig trace_config = 1;
  if (has_trace_config()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->trace_config_, output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.ChangeTraceConfigRequest)
}

int ChangeTraceConfigRequest::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.ChangeTraceConfigRequest)
  int total_size = 0;

  // optional .perfetto.protos.TraceConfig trace_config = 1;
  if (has_trace_config()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->trace_config_);
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChangeTraceConfigRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ChangeTraceConfigRequest*>(&from));
}

void ChangeTraceConfigRequest::MergeFrom(const ChangeTraceConfigRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.ChangeTraceConfigRequest)
  if (GOOGLE_PREDICT_FALSE(&from == this)) consumer_port_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_trace_config()) {
      mutable_trace_config()->::perfetto::protos::TraceConfig::MergeFrom(from.trace_config());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void ChangeTraceConfigRequest::CopyFrom(const ChangeTraceConfigRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.ChangeTraceConfigRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChangeTraceConfigRequest::IsInitialized() const {

  return true;
}

void ChangeTraceConfigRequest::Swap(ChangeTraceConfigRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ChangeTraceConfigRequest::InternalSwap(ChangeTraceConfigRequest* other) {
  std::swap(trace_config_, other->trace_config_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ChangeTraceConfigRequest::GetTypeName() const {
  return "perfetto.protos.ChangeTraceConfigRequest";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ChangeTraceConfigRequest

// optional .perfetto.protos.TraceConfig trace_config = 1;
bool ChangeTraceConfigRequest::has_trace_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ChangeTraceConfigRequest::set_has_trace_config() {
  _has_bits_[0] |= 0x00000001u;
}
void ChangeTraceConfigRequest::clear_has_trace_config() {
  _has_bits_[0] &= ~0x00000001u;
}
void ChangeTraceConfigRequest::clear_trace_config() {
  if (trace_config_ != NULL) trace_config_->::perfetto::protos::TraceConfig::Clear();
  clear_has_trace_config();
}
const ::perfetto::protos::TraceConfig& ChangeTraceConfigRequest::trace_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ChangeTraceConfigRequest.trace_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return trace_config_ != NULL ? *trace_config_ : *default_instance().trace_config_;
#else
  return trace_config_ != NULL ? *trace_config_ : *default_instance_->trace_config_;
#endif
}
::perfetto::protos::TraceConfig* ChangeTraceConfigRequest::mutable_trace_config() {
  set_has_trace_config();
  if (trace_config_ == NULL) {
    trace_config_ = new ::perfetto::protos::TraceConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.ChangeTraceConfigRequest.trace_config)
  return trace_config_;
}
::perfetto::protos::TraceConfig* ChangeTraceConfigRequest::release_trace_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.ChangeTraceConfigRequest.trace_config)
  clear_has_trace_config();
  ::perfetto::protos::TraceConfig* temp = trace_config_;
  trace_config_ = NULL;
  return temp;
}
void ChangeTraceConfigRequest::set_allocated_trace_config(::perfetto::protos::TraceConfig* trace_config) {
  delete trace_config_;
  trace_config_ = trace_config;
  if (trace_config) {
    set_has_trace_config();
  } else {
    clear_has_trace_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.ChangeTraceConfigRequest.trace_config)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForChangeTraceConfigResponse(
    ChangeTraceConfigResponse* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ChangeTraceConfigResponse::ChangeTraceConfigResponse()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.ChangeTraceConfigResponse)
}

void ChangeTraceConfigResponse::InitAsDefaultInstance() {
}

ChangeTraceConfigResponse::ChangeTraceConfigResponse(const ChangeTraceConfigResponse& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.ChangeTraceConfigResponse)
}

void ChangeTraceConfigResponse::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ChangeTraceConfigResponse::~ChangeTraceConfigResponse() {
  // @@protoc_insertion_point(destructor:perfetto.protos.ChangeTraceConfigResponse)
  SharedDtor();
}

void ChangeTraceConfigResponse::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ChangeTraceConfigResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ChangeTraceConfigResponse& ChangeTraceConfigResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
#endif
  return *default_instance_;
}

ChangeTraceConfigResponse* ChangeTraceConfigResponse::default_instance_ = NULL;

ChangeTraceConfigResponse* ChangeTraceConfigResponse::New(::google::protobuf::Arena* arena) const {
  ChangeTraceConfigResponse* n = new ChangeTraceConfigResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ChangeTraceConfigResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.ChangeTraceConfigResponse)
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool ChangeTraceConfigResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForChangeTraceConfigResponse, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.ChangeTraceConfigResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.ChangeTraceConfigResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.ChangeTraceConfigResponse)
  return false;
#undef DO_
}

void ChangeTraceConfigResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.ChangeTraceConfigResponse)
  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.ChangeTraceConfigResponse)
}

int ChangeTraceConfigResponse::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.ChangeTraceConfigResponse)
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ChangeTraceConfigResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ChangeTraceConfigResponse*>(&from));
}

void ChangeTraceConfigResponse::MergeFrom(const ChangeTraceConfigResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.ChangeTraceConfigResponse)
  if (GOOGLE_PREDICT_FALSE(&from == this)) consumer_port_pb_MergeFromFail(__LINE__);
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void ChangeTraceConfigResponse::CopyFrom(const ChangeTraceConfigResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.ChangeTraceConfigResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChangeTraceConfigResponse::IsInitialized() const {

  return true;
}

void ChangeTraceConfigResponse::Swap(ChangeTraceConfigResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ChangeTraceConfigResponse::InternalSwap(ChangeTraceConfigResponse* other) {
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ChangeTraceConfigResponse::GetTypeName() const {
  return "perfetto.protos.ChangeTraceConfigResponse";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ChangeTraceConfigResponse

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForDisableTracingRequest(
    DisableTracingRequest* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DisableTracingRequest::DisableTracingRequest()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.DisableTracingRequest)
}

void DisableTracingRequest::InitAsDefaultInstance() {
}

DisableTracingRequest::DisableTracingRequest(const DisableTracingRequest& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.DisableTracingRequest)
}

void DisableTracingRequest::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DisableTracingRequest::~DisableTracingRequest() {
  // @@protoc_insertion_point(destructor:perfetto.protos.DisableTracingRequest)
  SharedDtor();
}

void DisableTracingRequest::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DisableTracingRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DisableTracingRequest& DisableTracingRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
#endif
  return *default_instance_;
}

DisableTracingRequest* DisableTracingRequest::default_instance_ = NULL;

DisableTracingRequest* DisableTracingRequest::New(::google::protobuf::Arena* arena) const {
  DisableTracingRequest* n = new DisableTracingRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DisableTracingRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.DisableTracingRequest)
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool DisableTracingRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForDisableTracingRequest, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.DisableTracingRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.DisableTracingRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.DisableTracingRequest)
  return false;
#undef DO_
}

void DisableTracingRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.DisableTracingRequest)
  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.DisableTracingRequest)
}

int DisableTracingRequest::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.DisableTracingRequest)
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DisableTracingRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DisableTracingRequest*>(&from));
}

void DisableTracingRequest::MergeFrom(const DisableTracingRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.DisableTracingRequest)
  if (GOOGLE_PREDICT_FALSE(&from == this)) consumer_port_pb_MergeFromFail(__LINE__);
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void DisableTracingRequest::CopyFrom(const DisableTracingRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.DisableTracingRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DisableTracingRequest::IsInitialized() const {

  return true;
}

void DisableTracingRequest::Swap(DisableTracingRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DisableTracingRequest::InternalSwap(DisableTracingRequest* other) {
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string DisableTracingRequest::GetTypeName() const {
  return "perfetto.protos.DisableTracingRequest";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DisableTracingRequest

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForDisableTracingResponse(
    DisableTracingResponse* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DisableTracingResponse::DisableTracingResponse()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.DisableTracingResponse)
}

void DisableTracingResponse::InitAsDefaultInstance() {
}

DisableTracingResponse::DisableTracingResponse(const DisableTracingResponse& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.DisableTracingResponse)
}

void DisableTracingResponse::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DisableTracingResponse::~DisableTracingResponse() {
  // @@protoc_insertion_point(destructor:perfetto.protos.DisableTracingResponse)
  SharedDtor();
}

void DisableTracingResponse::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DisableTracingResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DisableTracingResponse& DisableTracingResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
#endif
  return *default_instance_;
}

DisableTracingResponse* DisableTracingResponse::default_instance_ = NULL;

DisableTracingResponse* DisableTracingResponse::New(::google::protobuf::Arena* arena) const {
  DisableTracingResponse* n = new DisableTracingResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DisableTracingResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.DisableTracingResponse)
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool DisableTracingResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForDisableTracingResponse, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.DisableTracingResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.DisableTracingResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.DisableTracingResponse)
  return false;
#undef DO_
}

void DisableTracingResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.DisableTracingResponse)
  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.DisableTracingResponse)
}

int DisableTracingResponse::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.DisableTracingResponse)
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DisableTracingResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DisableTracingResponse*>(&from));
}

void DisableTracingResponse::MergeFrom(const DisableTracingResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.DisableTracingResponse)
  if (GOOGLE_PREDICT_FALSE(&from == this)) consumer_port_pb_MergeFromFail(__LINE__);
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void DisableTracingResponse::CopyFrom(const DisableTracingResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.DisableTracingResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DisableTracingResponse::IsInitialized() const {

  return true;
}

void DisableTracingResponse::Swap(DisableTracingResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DisableTracingResponse::InternalSwap(DisableTracingResponse* other) {
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string DisableTracingResponse::GetTypeName() const {
  return "perfetto.protos.DisableTracingResponse";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DisableTracingResponse

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForReadBuffersRequest(
    ReadBuffersRequest* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ReadBuffersRequest::ReadBuffersRequest()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.ReadBuffersRequest)
}

void ReadBuffersRequest::InitAsDefaultInstance() {
}

ReadBuffersRequest::ReadBuffersRequest(const ReadBuffersRequest& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.ReadBuffersRequest)
}

void ReadBuffersRequest::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReadBuffersRequest::~ReadBuffersRequest() {
  // @@protoc_insertion_point(destructor:perfetto.protos.ReadBuffersRequest)
  SharedDtor();
}

void ReadBuffersRequest::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReadBuffersRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReadBuffersRequest& ReadBuffersRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
#endif
  return *default_instance_;
}

ReadBuffersRequest* ReadBuffersRequest::default_instance_ = NULL;

ReadBuffersRequest* ReadBuffersRequest::New(::google::protobuf::Arena* arena) const {
  ReadBuffersRequest* n = new ReadBuffersRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ReadBuffersRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.ReadBuffersRequest)
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool ReadBuffersRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForReadBuffersRequest, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.ReadBuffersRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.ReadBuffersRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.ReadBuffersRequest)
  return false;
#undef DO_
}

void ReadBuffersRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.ReadBuffersRequest)
  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.ReadBuffersRequest)
}

int ReadBuffersRequest::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.ReadBuffersRequest)
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReadBuffersRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReadBuffersRequest*>(&from));
}

void ReadBuffersRequest::MergeFrom(const ReadBuffersRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.ReadBuffersRequest)
  if (GOOGLE_PREDICT_FALSE(&from == this)) consumer_port_pb_MergeFromFail(__LINE__);
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void ReadBuffersRequest::CopyFrom(const ReadBuffersRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.ReadBuffersRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReadBuffersRequest::IsInitialized() const {

  return true;
}

void ReadBuffersRequest::Swap(ReadBuffersRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ReadBuffersRequest::InternalSwap(ReadBuffersRequest* other) {
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ReadBuffersRequest::GetTypeName() const {
  return "perfetto.protos.ReadBuffersRequest";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ReadBuffersRequest

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForReadBuffersResponse(
    ReadBuffersResponse* ptr) {
  return ptr->mutable_unknown_fields();
}

static ::std::string* MutableUnknownFieldsForReadBuffersResponse_Slice(
    ReadBuffersResponse_Slice* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ReadBuffersResponse_Slice::kDataFieldNumber;
const int ReadBuffersResponse_Slice::kLastSliceForPacketFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ReadBuffersResponse_Slice::ReadBuffersResponse_Slice()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.ReadBuffersResponse.Slice)
}

void ReadBuffersResponse_Slice::InitAsDefaultInstance() {
}

ReadBuffersResponse_Slice::ReadBuffersResponse_Slice(const ReadBuffersResponse_Slice& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.ReadBuffersResponse.Slice)
}

void ReadBuffersResponse_Slice::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  last_slice_for_packet_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReadBuffersResponse_Slice::~ReadBuffersResponse_Slice() {
  // @@protoc_insertion_point(destructor:perfetto.protos.ReadBuffersResponse.Slice)
  SharedDtor();
}

void ReadBuffersResponse_Slice::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReadBuffersResponse_Slice::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReadBuffersResponse_Slice& ReadBuffersResponse_Slice::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
#endif
  return *default_instance_;
}

ReadBuffersResponse_Slice* ReadBuffersResponse_Slice::default_instance_ = NULL;

ReadBuffersResponse_Slice* ReadBuffersResponse_Slice::New(::google::protobuf::Arena* arena) const {
  ReadBuffersResponse_Slice* n = new ReadBuffersResponse_Slice;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ReadBuffersResponse_Slice::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.ReadBuffersResponse.Slice)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_data()) {
      data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    last_slice_for_packet_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool ReadBuffersResponse_Slice::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForReadBuffersResponse_Slice, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.ReadBuffersResponse.Slice)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes data = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_last_slice_for_packet;
        break;
      }

      // optional bool last_slice_for_packet = 2;
      case 2: {
        if (tag == 16) {
         parse_last_slice_for_packet:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &last_slice_for_packet_)));
          set_has_last_slice_for_packet();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.ReadBuffersResponse.Slice)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.ReadBuffersResponse.Slice)
  return false;
#undef DO_
}

void ReadBuffersResponse_Slice::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.ReadBuffersResponse.Slice)
  // optional bytes data = 1;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->data(), output);
  }

  // optional bool last_slice_for_packet = 2;
  if (has_last_slice_for_packet()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->last_slice_for_packet(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.ReadBuffersResponse.Slice)
}

int ReadBuffersResponse_Slice::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.ReadBuffersResponse.Slice)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional bytes data = 1;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }

    // optional bool last_slice_for_packet = 2;
    if (has_last_slice_for_packet()) {
      total_size += 1 + 1;
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReadBuffersResponse_Slice::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReadBuffersResponse_Slice*>(&from));
}

void ReadBuffersResponse_Slice::MergeFrom(const ReadBuffersResponse_Slice& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.ReadBuffersResponse.Slice)
  if (GOOGLE_PREDICT_FALSE(&from == this)) consumer_port_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_data()) {
      set_has_data();
      data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.data_);
    }
    if (from.has_last_slice_for_packet()) {
      set_last_slice_for_packet(from.last_slice_for_packet());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void ReadBuffersResponse_Slice::CopyFrom(const ReadBuffersResponse_Slice& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.ReadBuffersResponse.Slice)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReadBuffersResponse_Slice::IsInitialized() const {

  return true;
}

void ReadBuffersResponse_Slice::Swap(ReadBuffersResponse_Slice* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ReadBuffersResponse_Slice::InternalSwap(ReadBuffersResponse_Slice* other) {
  data_.Swap(&other->data_);
  std::swap(last_slice_for_packet_, other->last_slice_for_packet_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ReadBuffersResponse_Slice::GetTypeName() const {
  return "perfetto.protos.ReadBuffersResponse.Slice";
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ReadBuffersResponse::kSlicesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ReadBuffersResponse::ReadBuffersResponse()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.ReadBuffersResponse)
}

void ReadBuffersResponse::InitAsDefaultInstance() {
}

ReadBuffersResponse::ReadBuffersResponse(const ReadBuffersResponse& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.ReadBuffersResponse)
}

void ReadBuffersResponse::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReadBuffersResponse::~ReadBuffersResponse() {
  // @@protoc_insertion_point(destructor:perfetto.protos.ReadBuffersResponse)
  SharedDtor();
}

void ReadBuffersResponse::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ReadBuffersResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ReadBuffersResponse& ReadBuffersResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
#endif
  return *default_instance_;
}

ReadBuffersResponse* ReadBuffersResponse::default_instance_ = NULL;

ReadBuffersResponse* ReadBuffersResponse::New(::google::protobuf::Arena* arena) const {
  ReadBuffersResponse* n = new ReadBuffersResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ReadBuffersResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.ReadBuffersResponse)
  slices_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool ReadBuffersResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForReadBuffersResponse, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.ReadBuffersResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .perfetto.protos.ReadBuffersResponse.Slice slices = 2;
      case 2: {
        if (tag == 18) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_slices:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_slices()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_slices;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.ReadBuffersResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.ReadBuffersResponse)
  return false;
#undef DO_
}

void ReadBuffersResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.ReadBuffersResponse)
  // repeated .perfetto.protos.ReadBuffersResponse.Slice slices = 2;
  for (unsigned int i = 0, n = this->slices_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->slices(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.ReadBuffersResponse)
}

int ReadBuffersResponse::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.ReadBuffersResponse)
  int total_size = 0;

  // repeated .perfetto.protos.ReadBuffersResponse.Slice slices = 2;
  total_size += 1 * this->slices_size();
  for (int i = 0; i < this->slices_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->slices(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReadBuffersResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ReadBuffersResponse*>(&from));
}

void ReadBuffersResponse::MergeFrom(const ReadBuffersResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.ReadBuffersResponse)
  if (GOOGLE_PREDICT_FALSE(&from == this)) consumer_port_pb_MergeFromFail(__LINE__);
  slices_.MergeFrom(from.slices_);
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void ReadBuffersResponse::CopyFrom(const ReadBuffersResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.ReadBuffersResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReadBuffersResponse::IsInitialized() const {

  return true;
}

void ReadBuffersResponse::Swap(ReadBuffersResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ReadBuffersResponse::InternalSwap(ReadBuffersResponse* other) {
  slices_.UnsafeArenaSwap(&other->slices_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ReadBuffersResponse::GetTypeName() const {
  return "perfetto.protos.ReadBuffersResponse";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ReadBuffersResponse_Slice

// optional bytes data = 1;
bool ReadBuffersResponse_Slice::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ReadBuffersResponse_Slice::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
void ReadBuffersResponse_Slice::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
void ReadBuffersResponse_Slice::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
 const ::std::string& ReadBuffersResponse_Slice::data() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ReadBuffersResponse.Slice.data)
  return data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ReadBuffersResponse_Slice::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.ReadBuffersResponse.Slice.data)
}
 void ReadBuffersResponse_Slice::set_data(const char* value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.ReadBuffersResponse.Slice.data)
}
 void ReadBuffersResponse_Slice::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.ReadBuffersResponse.Slice.data)
}
 ::std::string* ReadBuffersResponse_Slice::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.ReadBuffersResponse.Slice.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ReadBuffersResponse_Slice::release_data() {
  // @@protoc_insertion_point(field_release:perfetto.protos.ReadBuffersResponse.Slice.data)
  clear_has_data();
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ReadBuffersResponse_Slice::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.ReadBuffersResponse.Slice.data)
}

// optional bool last_slice_for_packet = 2;
bool ReadBuffersResponse_Slice::has_last_slice_for_packet() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ReadBuffersResponse_Slice::set_has_last_slice_for_packet() {
  _has_bits_[0] |= 0x00000002u;
}
void ReadBuffersResponse_Slice::clear_has_last_slice_for_packet() {
  _has_bits_[0] &= ~0x00000002u;
}
void ReadBuffersResponse_Slice::clear_last_slice_for_packet() {
  last_slice_for_packet_ = false;
  clear_has_last_slice_for_packet();
}
 bool ReadBuffersResponse_Slice::last_slice_for_packet() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ReadBuffersResponse.Slice.last_slice_for_packet)
  return last_slice_for_packet_;
}
 void ReadBuffersResponse_Slice::set_last_slice_for_packet(bool value) {
  set_has_last_slice_for_packet();
  last_slice_for_packet_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.ReadBuffersResponse.Slice.last_slice_for_packet)
}

// -------------------------------------------------------------------

// ReadBuffersResponse

// repeated .perfetto.protos.ReadBuffersResponse.Slice slices = 2;
int ReadBuffersResponse::slices_size() const {
  return slices_.size();
}
void ReadBuffersResponse::clear_slices() {
  slices_.Clear();
}
const ::perfetto::protos::ReadBuffersResponse_Slice& ReadBuffersResponse::slices(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ReadBuffersResponse.slices)
  return slices_.Get(index);
}
::perfetto::protos::ReadBuffersResponse_Slice* ReadBuffersResponse::mutable_slices(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.ReadBuffersResponse.slices)
  return slices_.Mutable(index);
}
::perfetto::protos::ReadBuffersResponse_Slice* ReadBuffersResponse::add_slices() {
  // @@protoc_insertion_point(field_add:perfetto.protos.ReadBuffersResponse.slices)
  return slices_.Add();
}
::google::protobuf::RepeatedPtrField< ::perfetto::protos::ReadBuffersResponse_Slice >*
ReadBuffersResponse::mutable_slices() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.ReadBuffersResponse.slices)
  return &slices_;
}
const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::ReadBuffersResponse_Slice >&
ReadBuffersResponse::slices() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.ReadBuffersResponse.slices)
  return slices_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForFreeBuffersRequest(
    FreeBuffersRequest* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FreeBuffersRequest::kBufferIdsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

FreeBuffersRequest::FreeBuffersRequest()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.FreeBuffersRequest)
}

void FreeBuffersRequest::InitAsDefaultInstance() {
}

FreeBuffersRequest::FreeBuffersRequest(const FreeBuffersRequest& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.FreeBuffersRequest)
}

void FreeBuffersRequest::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FreeBuffersRequest::~FreeBuffersRequest() {
  // @@protoc_insertion_point(destructor:perfetto.protos.FreeBuffersRequest)
  SharedDtor();
}

void FreeBuffersRequest::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void FreeBuffersRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FreeBuffersRequest& FreeBuffersRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
#endif
  return *default_instance_;
}

FreeBuffersRequest* FreeBuffersRequest::default_instance_ = NULL;

FreeBuffersRequest* FreeBuffersRequest::New(::google::protobuf::Arena* arena) const {
  FreeBuffersRequest* n = new FreeBuffersRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void FreeBuffersRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.FreeBuffersRequest)
  buffer_ids_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool FreeBuffersRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForFreeBuffersRequest, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.FreeBuffersRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 buffer_ids = 1;
      case 1: {
        if (tag == 8) {
         parse_buffer_ids:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_buffer_ids())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_buffer_ids())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(8)) goto parse_buffer_ids;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.FreeBuffersRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.FreeBuffersRequest)
  return false;
#undef DO_
}

void FreeBuffersRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.FreeBuffersRequest)
  // repeated uint32 buffer_ids = 1;
  for (int i = 0; i < this->buffer_ids_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->buffer_ids(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.FreeBuffersRequest)
}

int FreeBuffersRequest::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.FreeBuffersRequest)
  int total_size = 0;

  // repeated uint32 buffer_ids = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->buffer_ids_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->buffer_ids(i));
    }
    total_size += 1 * this->buffer_ids_size() + data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FreeBuffersRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FreeBuffersRequest*>(&from));
}

void FreeBuffersRequest::MergeFrom(const FreeBuffersRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.FreeBuffersRequest)
  if (GOOGLE_PREDICT_FALSE(&from == this)) consumer_port_pb_MergeFromFail(__LINE__);
  buffer_ids_.MergeFrom(from.buffer_ids_);
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void FreeBuffersRequest::CopyFrom(const FreeBuffersRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.FreeBuffersRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FreeBuffersRequest::IsInitialized() const {

  return true;
}

void FreeBuffersRequest::Swap(FreeBuffersRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void FreeBuffersRequest::InternalSwap(FreeBuffersRequest* other) {
  buffer_ids_.UnsafeArenaSwap(&other->buffer_ids_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string FreeBuffersRequest::GetTypeName() const {
  return "perfetto.protos.FreeBuffersRequest";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// FreeBuffersRequest

// repeated uint32 buffer_ids = 1;
int FreeBuffersRequest::buffer_ids_size() const {
  return buffer_ids_.size();
}
void FreeBuffersRequest::clear_buffer_ids() {
  buffer_ids_.Clear();
}
 ::google::protobuf::uint32 FreeBuffersRequest::buffer_ids(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FreeBuffersRequest.buffer_ids)
  return buffer_ids_.Get(index);
}
 void FreeBuffersRequest::set_buffer_ids(int index, ::google::protobuf::uint32 value) {
  buffer_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.FreeBuffersRequest.buffer_ids)
}
 void FreeBuffersRequest::add_buffer_ids(::google::protobuf::uint32 value) {
  buffer_ids_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.FreeBuffersRequest.buffer_ids)
}
 const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
FreeBuffersRequest::buffer_ids() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.FreeBuffersRequest.buffer_ids)
  return buffer_ids_;
}
 ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
FreeBuffersRequest::mutable_buffer_ids() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.FreeBuffersRequest.buffer_ids)
  return &buffer_ids_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForFreeBuffersResponse(
    FreeBuffersResponse* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

FreeBuffersResponse::FreeBuffersResponse()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.FreeBuffersResponse)
}

void FreeBuffersResponse::InitAsDefaultInstance() {
}

FreeBuffersResponse::FreeBuffersResponse(const FreeBuffersResponse& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.FreeBuffersResponse)
}

void FreeBuffersResponse::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FreeBuffersResponse::~FreeBuffersResponse() {
  // @@protoc_insertion_point(destructor:perfetto.protos.FreeBuffersResponse)
  SharedDtor();
}

void FreeBuffersResponse::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void FreeBuffersResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FreeBuffersResponse& FreeBuffersResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
#endif
  return *default_instance_;
}

FreeBuffersResponse* FreeBuffersResponse::default_instance_ = NULL;

FreeBuffersResponse* FreeBuffersResponse::New(::google::protobuf::Arena* arena) const {
  FreeBuffersResponse* n = new FreeBuffersResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void FreeBuffersResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.FreeBuffersResponse)
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool FreeBuffersResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForFreeBuffersResponse, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.FreeBuffersResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.FreeBuffersResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.FreeBuffersResponse)
  return false;
#undef DO_
}

void FreeBuffersResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.FreeBuffersResponse)
  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.FreeBuffersResponse)
}

int FreeBuffersResponse::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.FreeBuffersResponse)
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FreeBuffersResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FreeBuffersResponse*>(&from));
}

void FreeBuffersResponse::MergeFrom(const FreeBuffersResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.FreeBuffersResponse)
  if (GOOGLE_PREDICT_FALSE(&from == this)) consumer_port_pb_MergeFromFail(__LINE__);
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void FreeBuffersResponse::CopyFrom(const FreeBuffersResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.FreeBuffersResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FreeBuffersResponse::IsInitialized() const {

  return true;
}

void FreeBuffersResponse::Swap(FreeBuffersResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void FreeBuffersResponse::InternalSwap(FreeBuffersResponse* other) {
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string FreeBuffersResponse::GetTypeName() const {
  return "perfetto.protos.FreeBuffersResponse";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// FreeBuffersResponse

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForFlushRequest(
    FlushRequest* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FlushRequest::kTimeoutMsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

FlushRequest::FlushRequest()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.FlushRequest)
}

void FlushRequest::InitAsDefaultInstance() {
}

FlushRequest::FlushRequest(const FlushRequest& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.FlushRequest)
}

void FlushRequest::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  timeout_ms_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FlushRequest::~FlushRequest() {
  // @@protoc_insertion_point(destructor:perfetto.protos.FlushRequest)
  SharedDtor();
}

void FlushRequest::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void FlushRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FlushRequest& FlushRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
#endif
  return *default_instance_;
}

FlushRequest* FlushRequest::default_instance_ = NULL;

FlushRequest* FlushRequest::New(::google::protobuf::Arena* arena) const {
  FlushRequest* n = new FlushRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void FlushRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.FlushRequest)
  timeout_ms_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool FlushRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForFlushRequest, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.FlushRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 timeout_ms = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &timeout_ms_)));
          set_has_timeout_ms();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.FlushRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.FlushRequest)
  return false;
#undef DO_
}

void FlushRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.FlushRequest)
  // optional uint32 timeout_ms = 1;
  if (has_timeout_ms()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->timeout_ms(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.FlushRequest)
}

int FlushRequest::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.FlushRequest)
  int total_size = 0;

  // optional uint32 timeout_ms = 1;
  if (has_timeout_ms()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->timeout_ms());
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FlushRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FlushRequest*>(&from));
}

void FlushRequest::MergeFrom(const FlushRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.FlushRequest)
  if (GOOGLE_PREDICT_FALSE(&from == this)) consumer_port_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_timeout_ms()) {
      set_timeout_ms(from.timeout_ms());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void FlushRequest::CopyFrom(const FlushRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.FlushRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FlushRequest::IsInitialized() const {

  return true;
}

void FlushRequest::Swap(FlushRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void FlushRequest::InternalSwap(FlushRequest* other) {
  std::swap(timeout_ms_, other->timeout_ms_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string FlushRequest::GetTypeName() const {
  return "perfetto.protos.FlushRequest";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// FlushRequest

// optional uint32 timeout_ms = 1;
bool FlushRequest::has_timeout_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void FlushRequest::set_has_timeout_ms() {
  _has_bits_[0] |= 0x00000001u;
}
void FlushRequest::clear_has_timeout_ms() {
  _has_bits_[0] &= ~0x00000001u;
}
void FlushRequest::clear_timeout_ms() {
  timeout_ms_ = 0u;
  clear_has_timeout_ms();
}
 ::google::protobuf::uint32 FlushRequest::timeout_ms() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.FlushRequest.timeout_ms)
  return timeout_ms_;
}
 void FlushRequest::set_timeout_ms(::google::protobuf::uint32 value) {
  set_has_timeout_ms();
  timeout_ms_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.FlushRequest.timeout_ms)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForFlushResponse(
    FlushResponse* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

FlushResponse::FlushResponse()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.FlushResponse)
}

void FlushResponse::InitAsDefaultInstance() {
}

FlushResponse::FlushResponse(const FlushResponse& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.FlushResponse)
}

void FlushResponse::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FlushResponse::~FlushResponse() {
  // @@protoc_insertion_point(destructor:perfetto.protos.FlushResponse)
  SharedDtor();
}

void FlushResponse::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void FlushResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FlushResponse& FlushResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
#endif
  return *default_instance_;
}

FlushResponse* FlushResponse::default_instance_ = NULL;

FlushResponse* FlushResponse::New(::google::protobuf::Arena* arena) const {
  FlushResponse* n = new FlushResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void FlushResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.FlushResponse)
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool FlushResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForFlushResponse, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.FlushResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.FlushResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.FlushResponse)
  return false;
#undef DO_
}

void FlushResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.FlushResponse)
  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.FlushResponse)
}

int FlushResponse::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.FlushResponse)
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FlushResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FlushResponse*>(&from));
}

void FlushResponse::MergeFrom(const FlushResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.FlushResponse)
  if (GOOGLE_PREDICT_FALSE(&from == this)) consumer_port_pb_MergeFromFail(__LINE__);
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void FlushResponse::CopyFrom(const FlushResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.FlushResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FlushResponse::IsInitialized() const {

  return true;
}

void FlushResponse::Swap(FlushResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void FlushResponse::InternalSwap(FlushResponse* other) {
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string FlushResponse::GetTypeName() const {
  return "perfetto.protos.FlushResponse";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// FlushResponse

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForDetachRequest(
    DetachRequest* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DetachRequest::kKeyFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DetachRequest::DetachRequest()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.DetachRequest)
}

void DetachRequest::InitAsDefaultInstance() {
}

DetachRequest::DetachRequest(const DetachRequest& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.DetachRequest)
}

void DetachRequest::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DetachRequest::~DetachRequest() {
  // @@protoc_insertion_point(destructor:perfetto.protos.DetachRequest)
  SharedDtor();
}

void DetachRequest::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DetachRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DetachRequest& DetachRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
#endif
  return *default_instance_;
}

DetachRequest* DetachRequest::default_instance_ = NULL;

DetachRequest* DetachRequest::New(::google::protobuf::Arena* arena) const {
  DetachRequest* n = new DetachRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DetachRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.DetachRequest)
  if (has_key()) {
    key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool DetachRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForDetachRequest, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.DetachRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string key = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_key()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.DetachRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.DetachRequest)
  return false;
#undef DO_
}

void DetachRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.DetachRequest)
  // optional string key = 1;
  if (has_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->key(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.DetachRequest)
}

int DetachRequest::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.DetachRequest)
  int total_size = 0;

  // optional string key = 1;
  if (has_key()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->key());
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DetachRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DetachRequest*>(&from));
}

void DetachRequest::MergeFrom(const DetachRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.DetachRequest)
  if (GOOGLE_PREDICT_FALSE(&from == this)) consumer_port_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_key()) {
      set_has_key();
      key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.key_);
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void DetachRequest::CopyFrom(const DetachRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.DetachRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DetachRequest::IsInitialized() const {

  return true;
}

void DetachRequest::Swap(DetachRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DetachRequest::InternalSwap(DetachRequest* other) {
  key_.Swap(&other->key_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string DetachRequest::GetTypeName() const {
  return "perfetto.protos.DetachRequest";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DetachRequest

// optional string key = 1;
bool DetachRequest::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void DetachRequest::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
void DetachRequest::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
void DetachRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
 const ::std::string& DetachRequest::key() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.DetachRequest.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DetachRequest::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.DetachRequest.key)
}
 void DetachRequest::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.DetachRequest.key)
}
 void DetachRequest::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.DetachRequest.key)
}
 ::std::string* DetachRequest::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.DetachRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* DetachRequest::release_key() {
  // @@protoc_insertion_point(field_release:perfetto.protos.DetachRequest.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DetachRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.DetachRequest.key)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForDetachResponse(
    DetachResponse* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DetachResponse::DetachResponse()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.DetachResponse)
}

void DetachResponse::InitAsDefaultInstance() {
}

DetachResponse::DetachResponse(const DetachResponse& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.DetachResponse)
}

void DetachResponse::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DetachResponse::~DetachResponse() {
  // @@protoc_insertion_point(destructor:perfetto.protos.DetachResponse)
  SharedDtor();
}

void DetachResponse::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void DetachResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const DetachResponse& DetachResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
#endif
  return *default_instance_;
}

DetachResponse* DetachResponse::default_instance_ = NULL;

DetachResponse* DetachResponse::New(::google::protobuf::Arena* arena) const {
  DetachResponse* n = new DetachResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DetachResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.DetachResponse)
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool DetachResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForDetachResponse, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.DetachResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.DetachResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.DetachResponse)
  return false;
#undef DO_
}

void DetachResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.DetachResponse)
  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.DetachResponse)
}

int DetachResponse::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.DetachResponse)
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DetachResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const DetachResponse*>(&from));
}

void DetachResponse::MergeFrom(const DetachResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.DetachResponse)
  if (GOOGLE_PREDICT_FALSE(&from == this)) consumer_port_pb_MergeFromFail(__LINE__);
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void DetachResponse::CopyFrom(const DetachResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.DetachResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DetachResponse::IsInitialized() const {

  return true;
}

void DetachResponse::Swap(DetachResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DetachResponse::InternalSwap(DetachResponse* other) {
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string DetachResponse::GetTypeName() const {
  return "perfetto.protos.DetachResponse";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DetachResponse

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForAttachRequest(
    AttachRequest* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int AttachRequest::kKeyFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

AttachRequest::AttachRequest()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.AttachRequest)
}

void AttachRequest::InitAsDefaultInstance() {
}

AttachRequest::AttachRequest(const AttachRequest& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.AttachRequest)
}

void AttachRequest::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AttachRequest::~AttachRequest() {
  // @@protoc_insertion_point(destructor:perfetto.protos.AttachRequest)
  SharedDtor();
}

void AttachRequest::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void AttachRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AttachRequest& AttachRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
#endif
  return *default_instance_;
}

AttachRequest* AttachRequest::default_instance_ = NULL;

AttachRequest* AttachRequest::New(::google::protobuf::Arena* arena) const {
  AttachRequest* n = new AttachRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void AttachRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.AttachRequest)
  if (has_key()) {
    key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool AttachRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForAttachRequest, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.AttachRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string key = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_key()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.AttachRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.AttachRequest)
  return false;
#undef DO_
}

void AttachRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.AttachRequest)
  // optional string key = 1;
  if (has_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->key(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.AttachRequest)
}

int AttachRequest::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.AttachRequest)
  int total_size = 0;

  // optional string key = 1;
  if (has_key()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->key());
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AttachRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AttachRequest*>(&from));
}

void AttachRequest::MergeFrom(const AttachRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.AttachRequest)
  if (GOOGLE_PREDICT_FALSE(&from == this)) consumer_port_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_key()) {
      set_has_key();
      key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.key_);
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void AttachRequest::CopyFrom(const AttachRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.AttachRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AttachRequest::IsInitialized() const {

  return true;
}

void AttachRequest::Swap(AttachRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void AttachRequest::InternalSwap(AttachRequest* other) {
  key_.Swap(&other->key_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string AttachRequest::GetTypeName() const {
  return "perfetto.protos.AttachRequest";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// AttachRequest

// optional string key = 1;
bool AttachRequest::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void AttachRequest::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
void AttachRequest::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
void AttachRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
 const ::std::string& AttachRequest::key() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AttachRequest.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void AttachRequest::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.AttachRequest.key)
}
 void AttachRequest::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.AttachRequest.key)
}
 void AttachRequest::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.AttachRequest.key)
}
 ::std::string* AttachRequest::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.AttachRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* AttachRequest::release_key() {
  // @@protoc_insertion_point(field_release:perfetto.protos.AttachRequest.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void AttachRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.AttachRequest.key)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForAttachResponse(
    AttachResponse* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int AttachResponse::kTraceConfigFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

AttachResponse::AttachResponse()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.AttachResponse)
}

void AttachResponse::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  trace_config_ = const_cast< ::perfetto::protos::TraceConfig*>(
      ::perfetto::protos::TraceConfig::internal_default_instance());
#else
  trace_config_ = const_cast< ::perfetto::protos::TraceConfig*>(&::perfetto::protos::TraceConfig::default_instance());
#endif
}

AttachResponse::AttachResponse(const AttachResponse& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.AttachResponse)
}

void AttachResponse::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  trace_config_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AttachResponse::~AttachResponse() {
  // @@protoc_insertion_point(destructor:perfetto.protos.AttachResponse)
  SharedDtor();
}

void AttachResponse::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete trace_config_;
  }
}

void AttachResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const AttachResponse& AttachResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
#endif
  return *default_instance_;
}

AttachResponse* AttachResponse::default_instance_ = NULL;

AttachResponse* AttachResponse::New(::google::protobuf::Arena* arena) const {
  AttachResponse* n = new AttachResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void AttachResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.AttachResponse)
  if (has_trace_config()) {
    if (trace_config_ != NULL) trace_config_->::perfetto::protos::TraceConfig::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool AttachResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForAttachResponse, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.AttachResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .perfetto.protos.TraceConfig trace_config = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_trace_config()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.AttachResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.AttachResponse)
  return false;
#undef DO_
}

void AttachResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.AttachResponse)
  // optional .perfetto.protos.TraceConfig trace_config = 1;
  if (has_trace_config()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->trace_config_, output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.AttachResponse)
}

int AttachResponse::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.AttachResponse)
  int total_size = 0;

  // optional .perfetto.protos.TraceConfig trace_config = 1;
  if (has_trace_config()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->trace_config_);
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AttachResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const AttachResponse*>(&from));
}

void AttachResponse::MergeFrom(const AttachResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.AttachResponse)
  if (GOOGLE_PREDICT_FALSE(&from == this)) consumer_port_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_trace_config()) {
      mutable_trace_config()->::perfetto::protos::TraceConfig::MergeFrom(from.trace_config());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void AttachResponse::CopyFrom(const AttachResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.AttachResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AttachResponse::IsInitialized() const {

  return true;
}

void AttachResponse::Swap(AttachResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void AttachResponse::InternalSwap(AttachResponse* other) {
  std::swap(trace_config_, other->trace_config_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string AttachResponse::GetTypeName() const {
  return "perfetto.protos.AttachResponse";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// AttachResponse

// optional .perfetto.protos.TraceConfig trace_config = 1;
bool AttachResponse::has_trace_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void AttachResponse::set_has_trace_config() {
  _has_bits_[0] |= 0x00000001u;
}
void AttachResponse::clear_has_trace_config() {
  _has_bits_[0] &= ~0x00000001u;
}
void AttachResponse::clear_trace_config() {
  if (trace_config_ != NULL) trace_config_->::perfetto::protos::TraceConfig::Clear();
  clear_has_trace_config();
}
const ::perfetto::protos::TraceConfig& AttachResponse::trace_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.AttachResponse.trace_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return trace_config_ != NULL ? *trace_config_ : *default_instance().trace_config_;
#else
  return trace_config_ != NULL ? *trace_config_ : *default_instance_->trace_config_;
#endif
}
::perfetto::protos::TraceConfig* AttachResponse::mutable_trace_config() {
  set_has_trace_config();
  if (trace_config_ == NULL) {
    trace_config_ = new ::perfetto::protos::TraceConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.AttachResponse.trace_config)
  return trace_config_;
}
::perfetto::protos::TraceConfig* AttachResponse::release_trace_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.AttachResponse.trace_config)
  clear_has_trace_config();
  ::perfetto::protos::TraceConfig* temp = trace_config_;
  trace_config_ = NULL;
  return temp;
}
void AttachResponse::set_allocated_trace_config(::perfetto::protos::TraceConfig* trace_config) {
  delete trace_config_;
  trace_config_ = trace_config;
  if (trace_config) {
    set_has_trace_config();
  } else {
    clear_has_trace_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.AttachResponse.trace_config)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForGetTraceStatsRequest(
    GetTraceStatsRequest* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GetTraceStatsRequest::GetTraceStatsRequest()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.GetTraceStatsRequest)
}

void GetTraceStatsRequest::InitAsDefaultInstance() {
}

GetTraceStatsRequest::GetTraceStatsRequest(const GetTraceStatsRequest& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.GetTraceStatsRequest)
}

void GetTraceStatsRequest::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetTraceStatsRequest::~GetTraceStatsRequest() {
  // @@protoc_insertion_point(destructor:perfetto.protos.GetTraceStatsRequest)
  SharedDtor();
}

void GetTraceStatsRequest::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetTraceStatsRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetTraceStatsRequest& GetTraceStatsRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
#endif
  return *default_instance_;
}

GetTraceStatsRequest* GetTraceStatsRequest::default_instance_ = NULL;

GetTraceStatsRequest* GetTraceStatsRequest::New(::google::protobuf::Arena* arena) const {
  GetTraceStatsRequest* n = new GetTraceStatsRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GetTraceStatsRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.GetTraceStatsRequest)
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool GetTraceStatsRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForGetTraceStatsRequest, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.GetTraceStatsRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.GetTraceStatsRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.GetTraceStatsRequest)
  return false;
#undef DO_
}

void GetTraceStatsRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.GetTraceStatsRequest)
  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.GetTraceStatsRequest)
}

int GetTraceStatsRequest::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.GetTraceStatsRequest)
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetTraceStatsRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetTraceStatsRequest*>(&from));
}

void GetTraceStatsRequest::MergeFrom(const GetTraceStatsRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.GetTraceStatsRequest)
  if (GOOGLE_PREDICT_FALSE(&from == this)) consumer_port_pb_MergeFromFail(__LINE__);
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void GetTraceStatsRequest::CopyFrom(const GetTraceStatsRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.GetTraceStatsRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetTraceStatsRequest::IsInitialized() const {

  return true;
}

void GetTraceStatsRequest::Swap(GetTraceStatsRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GetTraceStatsRequest::InternalSwap(GetTraceStatsRequest* other) {
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string GetTraceStatsRequest::GetTypeName() const {
  return "perfetto.protos.GetTraceStatsRequest";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// GetTraceStatsRequest

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForGetTraceStatsResponse(
    GetTraceStatsResponse* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GetTraceStatsResponse::kTraceStatsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GetTraceStatsResponse::GetTraceStatsResponse()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.GetTraceStatsResponse)
}

void GetTraceStatsResponse::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  trace_stats_ = const_cast< ::perfetto::protos::TraceStats*>(
      ::perfetto::protos::TraceStats::internal_default_instance());
#else
  trace_stats_ = const_cast< ::perfetto::protos::TraceStats*>(&::perfetto::protos::TraceStats::default_instance());
#endif
}

GetTraceStatsResponse::GetTraceStatsResponse(const GetTraceStatsResponse& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.GetTraceStatsResponse)
}

void GetTraceStatsResponse::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  trace_stats_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetTraceStatsResponse::~GetTraceStatsResponse() {
  // @@protoc_insertion_point(destructor:perfetto.protos.GetTraceStatsResponse)
  SharedDtor();
}

void GetTraceStatsResponse::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete trace_stats_;
  }
}

void GetTraceStatsResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetTraceStatsResponse& GetTraceStatsResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
#endif
  return *default_instance_;
}

GetTraceStatsResponse* GetTraceStatsResponse::default_instance_ = NULL;

GetTraceStatsResponse* GetTraceStatsResponse::New(::google::protobuf::Arena* arena) const {
  GetTraceStatsResponse* n = new GetTraceStatsResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GetTraceStatsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.GetTraceStatsResponse)
  if (has_trace_stats()) {
    if (trace_stats_ != NULL) trace_stats_->::perfetto::protos::TraceStats::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool GetTraceStatsResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForGetTraceStatsResponse, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.GetTraceStatsResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .perfetto.protos.TraceStats trace_stats = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_trace_stats()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.GetTraceStatsResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.GetTraceStatsResponse)
  return false;
#undef DO_
}

void GetTraceStatsResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.GetTraceStatsResponse)
  // optional .perfetto.protos.TraceStats trace_stats = 1;
  if (has_trace_stats()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->trace_stats_, output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.GetTraceStatsResponse)
}

int GetTraceStatsResponse::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.GetTraceStatsResponse)
  int total_size = 0;

  // optional .perfetto.protos.TraceStats trace_stats = 1;
  if (has_trace_stats()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->trace_stats_);
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetTraceStatsResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetTraceStatsResponse*>(&from));
}

void GetTraceStatsResponse::MergeFrom(const GetTraceStatsResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.GetTraceStatsResponse)
  if (GOOGLE_PREDICT_FALSE(&from == this)) consumer_port_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_trace_stats()) {
      mutable_trace_stats()->::perfetto::protos::TraceStats::MergeFrom(from.trace_stats());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void GetTraceStatsResponse::CopyFrom(const GetTraceStatsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.GetTraceStatsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetTraceStatsResponse::IsInitialized() const {

  return true;
}

void GetTraceStatsResponse::Swap(GetTraceStatsResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GetTraceStatsResponse::InternalSwap(GetTraceStatsResponse* other) {
  std::swap(trace_stats_, other->trace_stats_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string GetTraceStatsResponse::GetTypeName() const {
  return "perfetto.protos.GetTraceStatsResponse";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// GetTraceStatsResponse

// optional .perfetto.protos.TraceStats trace_stats = 1;
bool GetTraceStatsResponse::has_trace_stats() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void GetTraceStatsResponse::set_has_trace_stats() {
  _has_bits_[0] |= 0x00000001u;
}
void GetTraceStatsResponse::clear_has_trace_stats() {
  _has_bits_[0] &= ~0x00000001u;
}
void GetTraceStatsResponse::clear_trace_stats() {
  if (trace_stats_ != NULL) trace_stats_->::perfetto::protos::TraceStats::Clear();
  clear_has_trace_stats();
}
const ::perfetto::protos::TraceStats& GetTraceStatsResponse::trace_stats() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetTraceStatsResponse.trace_stats)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return trace_stats_ != NULL ? *trace_stats_ : *default_instance().trace_stats_;
#else
  return trace_stats_ != NULL ? *trace_stats_ : *default_instance_->trace_stats_;
#endif
}
::perfetto::protos::TraceStats* GetTraceStatsResponse::mutable_trace_stats() {
  set_has_trace_stats();
  if (trace_stats_ == NULL) {
    trace_stats_ = new ::perfetto::protos::TraceStats;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GetTraceStatsResponse.trace_stats)
  return trace_stats_;
}
::perfetto::protos::TraceStats* GetTraceStatsResponse::release_trace_stats() {
  // @@protoc_insertion_point(field_release:perfetto.protos.GetTraceStatsResponse.trace_stats)
  clear_has_trace_stats();
  ::perfetto::protos::TraceStats* temp = trace_stats_;
  trace_stats_ = NULL;
  return temp;
}
void GetTraceStatsResponse::set_allocated_trace_stats(::perfetto::protos::TraceStats* trace_stats) {
  delete trace_stats_;
  trace_stats_ = trace_stats;
  if (trace_stats) {
    set_has_trace_stats();
  } else {
    clear_has_trace_stats();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.GetTraceStatsResponse.trace_stats)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForObserveEventsRequest(
    ObserveEventsRequest* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ObserveEventsRequest::kEventsToObserveFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ObserveEventsRequest::ObserveEventsRequest()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.ObserveEventsRequest)
}

void ObserveEventsRequest::InitAsDefaultInstance() {
}

ObserveEventsRequest::ObserveEventsRequest(const ObserveEventsRequest& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.ObserveEventsRequest)
}

void ObserveEventsRequest::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ObserveEventsRequest::~ObserveEventsRequest() {
  // @@protoc_insertion_point(destructor:perfetto.protos.ObserveEventsRequest)
  SharedDtor();
}

void ObserveEventsRequest::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ObserveEventsRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ObserveEventsRequest& ObserveEventsRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
#endif
  return *default_instance_;
}

ObserveEventsRequest* ObserveEventsRequest::default_instance_ = NULL;

ObserveEventsRequest* ObserveEventsRequest::New(::google::protobuf::Arena* arena) const {
  ObserveEventsRequest* n = new ObserveEventsRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ObserveEventsRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.ObserveEventsRequest)
  events_to_observe_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool ObserveEventsRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForObserveEventsRequest, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.ObserveEventsRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .perfetto.protos.ObservableEvents.Type events_to_observe = 1;
      case 1: {
        if (tag == 8) {
         parse_events_to_observe:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::perfetto::protos::ObservableEvents_Type_IsValid(value)) {
            add_events_to_observe(static_cast< ::perfetto::protos::ObservableEvents_Type >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedEnumPreserveUnknowns(
                 input,
                 1,
                 ::perfetto::protos::ObservableEvents_Type_IsValid,
                 &unknown_fields_stream,
                 this->mutable_events_to_observe())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(8)) goto parse_events_to_observe;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.ObserveEventsRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.ObserveEventsRequest)
  return false;
#undef DO_
}

void ObserveEventsRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.ObserveEventsRequest)
  // repeated .perfetto.protos.ObservableEvents.Type events_to_observe = 1;
  for (int i = 0; i < this->events_to_observe_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->events_to_observe(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.ObserveEventsRequest)
}

int ObserveEventsRequest::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.ObserveEventsRequest)
  int total_size = 0;

  // repeated .perfetto.protos.ObservableEvents.Type events_to_observe = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->events_to_observe_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::EnumSize(
        this->events_to_observe(i));
    }
    total_size += 1 * this->events_to_observe_size() + data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ObserveEventsRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ObserveEventsRequest*>(&from));
}

void ObserveEventsRequest::MergeFrom(const ObserveEventsRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.ObserveEventsRequest)
  if (GOOGLE_PREDICT_FALSE(&from == this)) consumer_port_pb_MergeFromFail(__LINE__);
  events_to_observe_.MergeFrom(from.events_to_observe_);
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void ObserveEventsRequest::CopyFrom(const ObserveEventsRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.ObserveEventsRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObserveEventsRequest::IsInitialized() const {

  return true;
}

void ObserveEventsRequest::Swap(ObserveEventsRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ObserveEventsRequest::InternalSwap(ObserveEventsRequest* other) {
  events_to_observe_.UnsafeArenaSwap(&other->events_to_observe_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ObserveEventsRequest::GetTypeName() const {
  return "perfetto.protos.ObserveEventsRequest";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ObserveEventsRequest

// repeated .perfetto.protos.ObservableEvents.Type events_to_observe = 1;
int ObserveEventsRequest::events_to_observe_size() const {
  return events_to_observe_.size();
}
void ObserveEventsRequest::clear_events_to_observe() {
  events_to_observe_.Clear();
}
 ::perfetto::protos::ObservableEvents_Type ObserveEventsRequest::events_to_observe(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ObserveEventsRequest.events_to_observe)
  return static_cast< ::perfetto::protos::ObservableEvents_Type >(events_to_observe_.Get(index));
}
 void ObserveEventsRequest::set_events_to_observe(int index, ::perfetto::protos::ObservableEvents_Type value) {
  assert(::perfetto::protos::ObservableEvents_Type_IsValid(value));
  events_to_observe_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.ObserveEventsRequest.events_to_observe)
}
 void ObserveEventsRequest::add_events_to_observe(::perfetto::protos::ObservableEvents_Type value) {
  assert(::perfetto::protos::ObservableEvents_Type_IsValid(value));
  events_to_observe_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.ObserveEventsRequest.events_to_observe)
}
 const ::google::protobuf::RepeatedField<int>&
ObserveEventsRequest::events_to_observe() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.ObserveEventsRequest.events_to_observe)
  return events_to_observe_;
}
 ::google::protobuf::RepeatedField<int>*
ObserveEventsRequest::mutable_events_to_observe() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.ObserveEventsRequest.events_to_observe)
  return &events_to_observe_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForObserveEventsResponse(
    ObserveEventsResponse* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ObserveEventsResponse::kEventsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ObserveEventsResponse::ObserveEventsResponse()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.ObserveEventsResponse)
}

void ObserveEventsResponse::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  events_ = const_cast< ::perfetto::protos::ObservableEvents*>(
      ::perfetto::protos::ObservableEvents::internal_default_instance());
#else
  events_ = const_cast< ::perfetto::protos::ObservableEvents*>(&::perfetto::protos::ObservableEvents::default_instance());
#endif
}

ObserveEventsResponse::ObserveEventsResponse(const ObserveEventsResponse& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.ObserveEventsResponse)
}

void ObserveEventsResponse::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  events_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ObserveEventsResponse::~ObserveEventsResponse() {
  // @@protoc_insertion_point(destructor:perfetto.protos.ObserveEventsResponse)
  SharedDtor();
}

void ObserveEventsResponse::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete events_;
  }
}

void ObserveEventsResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ObserveEventsResponse& ObserveEventsResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
#endif
  return *default_instance_;
}

ObserveEventsResponse* ObserveEventsResponse::default_instance_ = NULL;

ObserveEventsResponse* ObserveEventsResponse::New(::google::protobuf::Arena* arena) const {
  ObserveEventsResponse* n = new ObserveEventsResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ObserveEventsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.ObserveEventsResponse)
  if (has_events()) {
    if (events_ != NULL) events_->::perfetto::protos::ObservableEvents::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool ObserveEventsResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForObserveEventsResponse, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.ObserveEventsResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .perfetto.protos.ObservableEvents events = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_events()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.ObserveEventsResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.ObserveEventsResponse)
  return false;
#undef DO_
}

void ObserveEventsResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.ObserveEventsResponse)
  // optional .perfetto.protos.ObservableEvents events = 1;
  if (has_events()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->events_, output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.ObserveEventsResponse)
}

int ObserveEventsResponse::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.ObserveEventsResponse)
  int total_size = 0;

  // optional .perfetto.protos.ObservableEvents events = 1;
  if (has_events()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->events_);
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ObserveEventsResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ObserveEventsResponse*>(&from));
}

void ObserveEventsResponse::MergeFrom(const ObserveEventsResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.ObserveEventsResponse)
  if (GOOGLE_PREDICT_FALSE(&from == this)) consumer_port_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_events()) {
      mutable_events()->::perfetto::protos::ObservableEvents::MergeFrom(from.events());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void ObserveEventsResponse::CopyFrom(const ObserveEventsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.ObserveEventsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ObserveEventsResponse::IsInitialized() const {

  return true;
}

void ObserveEventsResponse::Swap(ObserveEventsResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ObserveEventsResponse::InternalSwap(ObserveEventsResponse* other) {
  std::swap(events_, other->events_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ObserveEventsResponse::GetTypeName() const {
  return "perfetto.protos.ObserveEventsResponse";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ObserveEventsResponse

// optional .perfetto.protos.ObservableEvents events = 1;
bool ObserveEventsResponse::has_events() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ObserveEventsResponse::set_has_events() {
  _has_bits_[0] |= 0x00000001u;
}
void ObserveEventsResponse::clear_has_events() {
  _has_bits_[0] &= ~0x00000001u;
}
void ObserveEventsResponse::clear_events() {
  if (events_ != NULL) events_->::perfetto::protos::ObservableEvents::Clear();
  clear_has_events();
}
const ::perfetto::protos::ObservableEvents& ObserveEventsResponse::events() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ObserveEventsResponse.events)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return events_ != NULL ? *events_ : *default_instance().events_;
#else
  return events_ != NULL ? *events_ : *default_instance_->events_;
#endif
}
::perfetto::protos::ObservableEvents* ObserveEventsResponse::mutable_events() {
  set_has_events();
  if (events_ == NULL) {
    events_ = new ::perfetto::protos::ObservableEvents;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.ObserveEventsResponse.events)
  return events_;
}
::perfetto::protos::ObservableEvents* ObserveEventsResponse::release_events() {
  // @@protoc_insertion_point(field_release:perfetto.protos.ObserveEventsResponse.events)
  clear_has_events();
  ::perfetto::protos::ObservableEvents* temp = events_;
  events_ = NULL;
  return temp;
}
void ObserveEventsResponse::set_allocated_events(::perfetto::protos::ObservableEvents* events) {
  delete events_;
  events_ = events;
  if (events) {
    set_has_events();
  } else {
    clear_has_events();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.ObserveEventsResponse.events)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForQueryServiceStateRequest(
    QueryServiceStateRequest* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

QueryServiceStateRequest::QueryServiceStateRequest()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.QueryServiceStateRequest)
}

void QueryServiceStateRequest::InitAsDefaultInstance() {
}

QueryServiceStateRequest::QueryServiceStateRequest(const QueryServiceStateRequest& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.QueryServiceStateRequest)
}

void QueryServiceStateRequest::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

QueryServiceStateRequest::~QueryServiceStateRequest() {
  // @@protoc_insertion_point(destructor:perfetto.protos.QueryServiceStateRequest)
  SharedDtor();
}

void QueryServiceStateRequest::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void QueryServiceStateRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const QueryServiceStateRequest& QueryServiceStateRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
#endif
  return *default_instance_;
}

QueryServiceStateRequest* QueryServiceStateRequest::default_instance_ = NULL;

QueryServiceStateRequest* QueryServiceStateRequest::New(::google::protobuf::Arena* arena) const {
  QueryServiceStateRequest* n = new QueryServiceStateRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void QueryServiceStateRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.QueryServiceStateRequest)
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool QueryServiceStateRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForQueryServiceStateRequest, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.QueryServiceStateRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.QueryServiceStateRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.QueryServiceStateRequest)
  return false;
#undef DO_
}

void QueryServiceStateRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.QueryServiceStateRequest)
  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.QueryServiceStateRequest)
}

int QueryServiceStateRequest::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.QueryServiceStateRequest)
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void QueryServiceStateRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const QueryServiceStateRequest*>(&from));
}

void QueryServiceStateRequest::MergeFrom(const QueryServiceStateRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.QueryServiceStateRequest)
  if (GOOGLE_PREDICT_FALSE(&from == this)) consumer_port_pb_MergeFromFail(__LINE__);
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void QueryServiceStateRequest::CopyFrom(const QueryServiceStateRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.QueryServiceStateRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QueryServiceStateRequest::IsInitialized() const {

  return true;
}

void QueryServiceStateRequest::Swap(QueryServiceStateRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void QueryServiceStateRequest::InternalSwap(QueryServiceStateRequest* other) {
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string QueryServiceStateRequest::GetTypeName() const {
  return "perfetto.protos.QueryServiceStateRequest";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// QueryServiceStateRequest

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForQueryServiceStateResponse(
    QueryServiceStateResponse* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int QueryServiceStateResponse::kServiceStateFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

QueryServiceStateResponse::QueryServiceStateResponse()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.QueryServiceStateResponse)
}

void QueryServiceStateResponse::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  service_state_ = const_cast< ::perfetto::protos::TracingServiceState*>(
      ::perfetto::protos::TracingServiceState::internal_default_instance());
#else
  service_state_ = const_cast< ::perfetto::protos::TracingServiceState*>(&::perfetto::protos::TracingServiceState::default_instance());
#endif
}

QueryServiceStateResponse::QueryServiceStateResponse(const QueryServiceStateResponse& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.QueryServiceStateResponse)
}

void QueryServiceStateResponse::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  service_state_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

QueryServiceStateResponse::~QueryServiceStateResponse() {
  // @@protoc_insertion_point(destructor:perfetto.protos.QueryServiceStateResponse)
  SharedDtor();
}

void QueryServiceStateResponse::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete service_state_;
  }
}

void QueryServiceStateResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const QueryServiceStateResponse& QueryServiceStateResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fipc_2fconsumer_5fport_2eproto();
#endif
  return *default_instance_;
}

QueryServiceStateResponse* QueryServiceStateResponse::default_instance_ = NULL;

QueryServiceStateResponse* QueryServiceStateResponse::New(::google::protobuf::Arena* arena) const {
  QueryServiceStateResponse* n = new QueryServiceStateResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void QueryServiceStateResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.QueryServiceStateResponse)
  if (has_service_state()) {
    if (service_state_ != NULL) service_state_->::perfetto::protos::TracingServiceState::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool QueryServiceStateResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForQueryServiceStateResponse, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.QueryServiceStateResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .perfetto.protos.TracingServiceState service_state = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_service_state()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.QueryServiceStateResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.QueryServiceStateResponse)
  return false;
#undef DO_
}

void QueryServiceStateResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.QueryServiceStateResponse)
  // optional .perfetto.protos.TracingServiceState service_state = 1;
  if (has_service_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->service_state_, output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.QueryServiceStateResponse)
}

int QueryServiceStateResponse::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.QueryServiceStateResponse)
  int total_size = 0;

  // optional .perfetto.protos.TracingServiceState service_state = 1;
  if (has_service_state()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->service_state_);
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void QueryServiceStateResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const QueryServiceStateResponse*>(&from));
}

void QueryServiceStateResponse::MergeFrom(const QueryServiceStateResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.QueryServiceStateResponse)
  if (GOOGLE_PREDICT_FALSE(&from == this)) consumer_port_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_service_state()) {
      mutable_service_state()->::perfetto::protos::TracingServiceState::MergeFrom(from.service_state());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void QueryServiceStateResponse::CopyFrom(const QueryServiceStateResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.QueryServiceStateResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QueryServiceStateResponse::IsInitialized() const {

  return true;
}

void QueryServiceStateResponse::Swap(QueryServiceStateResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void QueryServiceStateResponse::InternalSwap(QueryServiceStateResponse* other) {
  std::swap(service_state_, other->service_state_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string QueryServiceStateResponse::GetTypeName() const {
  return "perfetto.protos.QueryServiceStateResponse";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// QueryServiceStateResponse

// optional .perfetto.protos.TracingServiceState service_state = 1;
bool QueryServiceStateResponse::has_service_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void QueryServiceStateResponse::set_has_service_state() {
  _has_bits_[0] |= 0x00000001u;
}
void QueryServiceStateResponse::clear_has_service_state() {
  _has_bits_[0] &= ~0x00000001u;
}
void QueryServiceStateResponse::clear_service_state() {
  if (service_state_ != NULL) service_state_->::perfetto::protos::TracingServiceState::Clear();
  clear_has_service_state();
}
const ::perfetto::protos::TracingServiceState& QueryServiceStateResponse::service_state() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.QueryServiceStateResponse.service_state)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return service_state_ != NULL ? *service_state_ : *default_instance().service_state_;
#else
  return service_state_ != NULL ? *service_state_ : *default_instance_->service_state_;
#endif
}
::perfetto::protos::TracingServiceState* QueryServiceStateResponse::mutable_service_state() {
  set_has_service_state();
  if (service_state_ == NULL) {
    service_state_ = new ::perfetto::protos::TracingServiceState;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.QueryServiceStateResponse.service_state)
  return service_state_;
}
::perfetto::protos::TracingServiceState* QueryServiceStateResponse::release_service_state() {
  // @@protoc_insertion_point(field_release:perfetto.protos.QueryServiceStateResponse.service_state)
  clear_has_service_state();
  ::perfetto::protos::TracingServiceState* temp = service_state_;
  service_state_ = NULL;
  return temp;
}
void QueryServiceStateResponse::set_allocated_service_state(::perfetto::protos::TracingServiceState* service_state) {
  delete service_state_;
  service_state_ = service_state;
  if (service_state) {
    set_has_service_state();
  } else {
    clear_has_service_state();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.QueryServiceStateResponse.service_state)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/ipc/consumer_port.ipc.cc
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/ipc/consumer_port.ipc.h
// DO NOT EDIT. Autogenerated by Perfetto IPC
#ifndef PERFETTO_PROTOS_PERFETTO_IPC_CONSUMER_PORT_PROTO_H_
#define PERFETTO_PROTOS_PERFETTO_IPC_CONSUMER_PORT_PROTO_H_

// gen_amalgamated expanded: #include "perfetto/ipc/consumer_port.pb.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/deferred.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/service.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/service_descriptor.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/service_proxy.h"


namespace perfetto {
namespace protos {

class ConsumerPort : public ::perfetto::ipc::Service {
 private:
  static ::perfetto::ipc::ServiceDescriptor* NewDescriptor();

 public:
  ~ConsumerPort() override;

  static const ::perfetto::ipc::ServiceDescriptor& GetDescriptorStatic();

  // Service implementation.
  const ::perfetto::ipc::ServiceDescriptor& GetDescriptor() override;

  // Methods from the .proto file
  using DeferredEnableTracingResponse = ::perfetto::ipc::Deferred<EnableTracingResponse>;
  virtual void EnableTracing(const EnableTracingRequest&, DeferredEnableTracingResponse) = 0;

  using DeferredDisableTracingResponse = ::perfetto::ipc::Deferred<DisableTracingResponse>;
  virtual void DisableTracing(const DisableTracingRequest&, DeferredDisableTracingResponse) = 0;

  using DeferredReadBuffersResponse = ::perfetto::ipc::Deferred<ReadBuffersResponse>;
  virtual void ReadBuffers(const ReadBuffersRequest&, DeferredReadBuffersResponse) = 0;

  using DeferredFreeBuffersResponse = ::perfetto::ipc::Deferred<FreeBuffersResponse>;
  virtual void FreeBuffers(const FreeBuffersRequest&, DeferredFreeBuffersResponse) = 0;

  using DeferredFlushResponse = ::perfetto::ipc::Deferred<FlushResponse>;
  virtual void Flush(const FlushRequest&, DeferredFlushResponse) = 0;

  using DeferredStartTracingResponse = ::perfetto::ipc::Deferred<StartTracingResponse>;
  virtual void StartTracing(const StartTracingRequest&, DeferredStartTracingResponse) = 0;

  using DeferredChangeTraceConfigResponse = ::perfetto::ipc::Deferred<ChangeTraceConfigResponse>;
  virtual void ChangeTraceConfig(const ChangeTraceConfigRequest&, DeferredChangeTraceConfigResponse) = 0;

  using DeferredDetachResponse = ::perfetto::ipc::Deferred<DetachResponse>;
  virtual void Detach(const DetachRequest&, DeferredDetachResponse) = 0;

  using DeferredAttachResponse = ::perfetto::ipc::Deferred<AttachResponse>;
  virtual void Attach(const AttachRequest&, DeferredAttachResponse) = 0;

  using DeferredGetTraceStatsResponse = ::perfetto::ipc::Deferred<GetTraceStatsResponse>;
  virtual void GetTraceStats(const GetTraceStatsRequest&, DeferredGetTraceStatsResponse) = 0;

  using DeferredObserveEventsResponse = ::perfetto::ipc::Deferred<ObserveEventsResponse>;
  virtual void ObserveEvents(const ObserveEventsRequest&, DeferredObserveEventsResponse) = 0;

  using DeferredQueryServiceStateResponse = ::perfetto::ipc::Deferred<QueryServiceStateResponse>;
  virtual void QueryServiceState(const QueryServiceStateRequest&, DeferredQueryServiceStateResponse) = 0;

};


class ConsumerPortProxy : public ::perfetto::ipc::ServiceProxy {
 public:
   explicit ConsumerPortProxy(::perfetto::ipc::ServiceProxy::EventListener*);
   ~ConsumerPortProxy() override;

  // ServiceProxy implementation.
  const ::perfetto::ipc::ServiceDescriptor& GetDescriptor() override;

  // Methods from the .proto file
  using DeferredEnableTracingResponse = ::perfetto::ipc::Deferred<EnableTracingResponse>;
  void EnableTracing(const EnableTracingRequest&, DeferredEnableTracingResponse, int fd = -1);

  using DeferredDisableTracingResponse = ::perfetto::ipc::Deferred<DisableTracingResponse>;
  void DisableTracing(const DisableTracingRequest&, DeferredDisableTracingResponse, int fd = -1);

  using DeferredReadBuffersResponse = ::perfetto::ipc::Deferred<ReadBuffersResponse>;
  void ReadBuffers(const ReadBuffersRequest&, DeferredReadBuffersResponse, int fd = -1);

  using DeferredFreeBuffersResponse = ::perfetto::ipc::Deferred<FreeBuffersResponse>;
  void FreeBuffers(const FreeBuffersRequest&, DeferredFreeBuffersResponse, int fd = -1);

  using DeferredFlushResponse = ::perfetto::ipc::Deferred<FlushResponse>;
  void Flush(const FlushRequest&, DeferredFlushResponse, int fd = -1);

  using DeferredStartTracingResponse = ::perfetto::ipc::Deferred<StartTracingResponse>;
  void StartTracing(const StartTracingRequest&, DeferredStartTracingResponse, int fd = -1);

  using DeferredChangeTraceConfigResponse = ::perfetto::ipc::Deferred<ChangeTraceConfigResponse>;
  void ChangeTraceConfig(const ChangeTraceConfigRequest&, DeferredChangeTraceConfigResponse, int fd = -1);

  using DeferredDetachResponse = ::perfetto::ipc::Deferred<DetachResponse>;
  void Detach(const DetachRequest&, DeferredDetachResponse, int fd = -1);

  using DeferredAttachResponse = ::perfetto::ipc::Deferred<AttachResponse>;
  void Attach(const AttachRequest&, DeferredAttachResponse, int fd = -1);

  using DeferredGetTraceStatsResponse = ::perfetto::ipc::Deferred<GetTraceStatsResponse>;
  void GetTraceStats(const GetTraceStatsRequest&, DeferredGetTraceStatsResponse, int fd = -1);

  using DeferredObserveEventsResponse = ::perfetto::ipc::Deferred<ObserveEventsResponse>;
  void ObserveEvents(const ObserveEventsRequest&, DeferredObserveEventsResponse, int fd = -1);

  using DeferredQueryServiceStateResponse = ::perfetto::ipc::Deferred<QueryServiceStateResponse>;
  void QueryServiceState(const QueryServiceStateRequest&, DeferredQueryServiceStateResponse, int fd = -1);

};

}  // namespace protos
}  // namespace perfetto

#endif  // PERFETTO_PROTOS_PERFETTO_IPC_CONSUMER_PORT_PROTO_H_
// gen_amalgamated begin header: include/perfetto/ext/ipc/codegen_helpers.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// This file is only meant to be included in autogenerated .cc files.

#ifndef INCLUDE_PERFETTO_EXT_IPC_CODEGEN_HELPERS_H_
#define INCLUDE_PERFETTO_EXT_IPC_CODEGEN_HELPERS_H_

// A templated protobuf message decoder. Returns nullptr in case of failure.
template <typename T>
::std::unique_ptr<::perfetto::ipc::ProtoMessage> _IPC_Decoder(
    const std::string& proto_data) {
  ::std::unique_ptr<::perfetto::ipc::ProtoMessage> msg(new T());
  if (msg->ParseFromString(proto_data))
    return msg;
  return nullptr;
}

// Templated method dispatcher. Used to obtain a function pointer to a given
// IPC method (Method) of a given service (TSvc) that can be invoked by the
// host-side machinery starting from a generic Service pointer and a generic
// ProtoMessage request argument.
template <typename TSvc,    // Type of the actual Service subclass.
          typename TReq,    // Type of the request argument.
          typename TReply,  // Type of the reply argument.
          void (TSvc::*Method)(const TReq&, ::perfetto::ipc::Deferred<TReply>)>
void _IPC_Invoker(::perfetto::ipc::Service* s,
                  const ::perfetto::ipc::ProtoMessage& req,
                  ::perfetto::ipc::DeferredBase reply) {
  (*static_cast<TSvc*>(s).*Method)(
      static_cast<const TReq&>(req),
      ::perfetto::ipc::Deferred<TReply>(::std::move(reply)));
}

#endif  // INCLUDE_PERFETTO_EXT_IPC_CODEGEN_HELPERS_H_
// DO NOT EDIT. Autogenerated by Perfetto IPC
// gen_amalgamated expanded: #include "perfetto/ipc/consumer_port.ipc.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/codegen_helpers.h"

#include <memory>

namespace perfetto {
namespace protos {
::perfetto::ipc::ServiceDescriptor* ConsumerPort::NewDescriptor() {
  auto* desc = new ::perfetto::ipc::ServiceDescriptor();
  desc->service_name = "ConsumerPort";

  desc->methods.emplace_back(::perfetto::ipc::ServiceDescriptor::Method{
     "EnableTracing",
     &_IPC_Decoder<EnableTracingRequest>,
     &_IPC_Decoder<EnableTracingResponse>,
     &_IPC_Invoker<ConsumerPort, EnableTracingRequest, EnableTracingResponse, &ConsumerPort::EnableTracing>});

  desc->methods.emplace_back(::perfetto::ipc::ServiceDescriptor::Method{
     "DisableTracing",
     &_IPC_Decoder<DisableTracingRequest>,
     &_IPC_Decoder<DisableTracingResponse>,
     &_IPC_Invoker<ConsumerPort, DisableTracingRequest, DisableTracingResponse, &ConsumerPort::DisableTracing>});

  desc->methods.emplace_back(::perfetto::ipc::ServiceDescriptor::Method{
     "ReadBuffers",
     &_IPC_Decoder<ReadBuffersRequest>,
     &_IPC_Decoder<ReadBuffersResponse>,
     &_IPC_Invoker<ConsumerPort, ReadBuffersRequest, ReadBuffersResponse, &ConsumerPort::ReadBuffers>});

  desc->methods.emplace_back(::perfetto::ipc::ServiceDescriptor::Method{
     "FreeBuffers",
     &_IPC_Decoder<FreeBuffersRequest>,
     &_IPC_Decoder<FreeBuffersResponse>,
     &_IPC_Invoker<ConsumerPort, FreeBuffersRequest, FreeBuffersResponse, &ConsumerPort::FreeBuffers>});

  desc->methods.emplace_back(::perfetto::ipc::ServiceDescriptor::Method{
     "Flush",
     &_IPC_Decoder<FlushRequest>,
     &_IPC_Decoder<FlushResponse>,
     &_IPC_Invoker<ConsumerPort, FlushRequest, FlushResponse, &ConsumerPort::Flush>});

  desc->methods.emplace_back(::perfetto::ipc::ServiceDescriptor::Method{
     "StartTracing",
     &_IPC_Decoder<StartTracingRequest>,
     &_IPC_Decoder<StartTracingResponse>,
     &_IPC_Invoker<ConsumerPort, StartTracingRequest, StartTracingResponse, &ConsumerPort::StartTracing>});

  desc->methods.emplace_back(::perfetto::ipc::ServiceDescriptor::Method{
     "ChangeTraceConfig",
     &_IPC_Decoder<ChangeTraceConfigRequest>,
     &_IPC_Decoder<ChangeTraceConfigResponse>,
     &_IPC_Invoker<ConsumerPort, ChangeTraceConfigRequest, ChangeTraceConfigResponse, &ConsumerPort::ChangeTraceConfig>});

  desc->methods.emplace_back(::perfetto::ipc::ServiceDescriptor::Method{
     "Detach",
     &_IPC_Decoder<DetachRequest>,
     &_IPC_Decoder<DetachResponse>,
     &_IPC_Invoker<ConsumerPort, DetachRequest, DetachResponse, &ConsumerPort::Detach>});

  desc->methods.emplace_back(::perfetto::ipc::ServiceDescriptor::Method{
     "Attach",
     &_IPC_Decoder<AttachRequest>,
     &_IPC_Decoder<AttachResponse>,
     &_IPC_Invoker<ConsumerPort, AttachRequest, AttachResponse, &ConsumerPort::Attach>});

  desc->methods.emplace_back(::perfetto::ipc::ServiceDescriptor::Method{
     "GetTraceStats",
     &_IPC_Decoder<GetTraceStatsRequest>,
     &_IPC_Decoder<GetTraceStatsResponse>,
     &_IPC_Invoker<ConsumerPort, GetTraceStatsRequest, GetTraceStatsResponse, &ConsumerPort::GetTraceStats>});

  desc->methods.emplace_back(::perfetto::ipc::ServiceDescriptor::Method{
     "ObserveEvents",
     &_IPC_Decoder<ObserveEventsRequest>,
     &_IPC_Decoder<ObserveEventsResponse>,
     &_IPC_Invoker<ConsumerPort, ObserveEventsRequest, ObserveEventsResponse, &ConsumerPort::ObserveEvents>});

  desc->methods.emplace_back(::perfetto::ipc::ServiceDescriptor::Method{
     "QueryServiceState",
     &_IPC_Decoder<QueryServiceStateRequest>,
     &_IPC_Decoder<QueryServiceStateResponse>,
     &_IPC_Invoker<ConsumerPort, QueryServiceStateRequest, QueryServiceStateResponse, &ConsumerPort::QueryServiceState>});
  desc->methods.shrink_to_fit();
  return desc;
}


const ::perfetto::ipc::ServiceDescriptor& ConsumerPort::GetDescriptorStatic() {
  static auto* instance = NewDescriptor();
  return *instance;
}

// Host-side definitions.
ConsumerPort::~ConsumerPort() = default;

const ::perfetto::ipc::ServiceDescriptor& ConsumerPort::GetDescriptor() {
  return GetDescriptorStatic();
}

// Client-side definitions.
ConsumerPortProxy::ConsumerPortProxy(::perfetto::ipc::ServiceProxy::EventListener* event_listener)
    : ::perfetto::ipc::ServiceProxy(event_listener) {}

ConsumerPortProxy::~ConsumerPortProxy() = default;

const ::perfetto::ipc::ServiceDescriptor& ConsumerPortProxy::GetDescriptor() {
  return ConsumerPort::GetDescriptorStatic();
}

void ConsumerPortProxy::EnableTracing(const EnableTracingRequest& request, DeferredEnableTracingResponse reply, int fd) {
  BeginInvoke("EnableTracing", request, ::perfetto::ipc::DeferredBase(std::move(reply)),
              fd);
}

void ConsumerPortProxy::DisableTracing(const DisableTracingRequest& request, DeferredDisableTracingResponse reply, int fd) {
  BeginInvoke("DisableTracing", request, ::perfetto::ipc::DeferredBase(std::move(reply)),
              fd);
}

void ConsumerPortProxy::ReadBuffers(const ReadBuffersRequest& request, DeferredReadBuffersResponse reply, int fd) {
  BeginInvoke("ReadBuffers", request, ::perfetto::ipc::DeferredBase(std::move(reply)),
              fd);
}

void ConsumerPortProxy::FreeBuffers(const FreeBuffersRequest& request, DeferredFreeBuffersResponse reply, int fd) {
  BeginInvoke("FreeBuffers", request, ::perfetto::ipc::DeferredBase(std::move(reply)),
              fd);
}

void ConsumerPortProxy::Flush(const FlushRequest& request, DeferredFlushResponse reply, int fd) {
  BeginInvoke("Flush", request, ::perfetto::ipc::DeferredBase(std::move(reply)),
              fd);
}

void ConsumerPortProxy::StartTracing(const StartTracingRequest& request, DeferredStartTracingResponse reply, int fd) {
  BeginInvoke("StartTracing", request, ::perfetto::ipc::DeferredBase(std::move(reply)),
              fd);
}

void ConsumerPortProxy::ChangeTraceConfig(const ChangeTraceConfigRequest& request, DeferredChangeTraceConfigResponse reply, int fd) {
  BeginInvoke("ChangeTraceConfig", request, ::perfetto::ipc::DeferredBase(std::move(reply)),
              fd);
}

void ConsumerPortProxy::Detach(const DetachRequest& request, DeferredDetachResponse reply, int fd) {
  BeginInvoke("Detach", request, ::perfetto::ipc::DeferredBase(std::move(reply)),
              fd);
}

void ConsumerPortProxy::Attach(const AttachRequest& request, DeferredAttachResponse reply, int fd) {
  BeginInvoke("Attach", request, ::perfetto::ipc::DeferredBase(std::move(reply)),
              fd);
}

void ConsumerPortProxy::GetTraceStats(const GetTraceStatsRequest& request, DeferredGetTraceStatsResponse reply, int fd) {
  BeginInvoke("GetTraceStats", request, ::perfetto::ipc::DeferredBase(std::move(reply)),
              fd);
}

void ConsumerPortProxy::ObserveEvents(const ObserveEventsRequest& request, DeferredObserveEventsResponse reply, int fd) {
  BeginInvoke("ObserveEvents", request, ::perfetto::ipc::DeferredBase(std::move(reply)),
              fd);
}

void ConsumerPortProxy::QueryServiceState(const QueryServiceStateRequest& request, DeferredQueryServiceStateResponse reply, int fd) {
  BeginInvoke("QueryServiceState", request, ::perfetto::ipc::DeferredBase(std::move(reply)),
              fd);
}
}  // namespace protos
}  // namespace perfetto
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/ipc/producer_port.pb.cc
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/ipc/producer_port.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/ipc/producer_port.proto

#ifndef PROTOBUF_perfetto_2fipc_2fproducer_5fport_2eproto__INCLUDED
#define PROTOBUF_perfetto_2fipc_2fproducer_5fport_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
// gen_amalgamated expanded: #include "perfetto/common/commit_data_request.pb.h"
// gen_amalgamated expanded: #include "perfetto/config/data_source_config.pb.h"
// gen_amalgamated expanded: #include "perfetto/common/data_source_descriptor.pb.h"
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
void protobuf_AssignDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
void protobuf_ShutdownFile_perfetto_2fipc_2fproducer_5fport_2eproto();

class ActivateTriggersRequest;
class ActivateTriggersResponse;
class CommitDataResponse;
class GetAsyncCommandRequest;
class GetAsyncCommandResponse;
class GetAsyncCommandResponse_ClearIncrementalState;
class GetAsyncCommandResponse_Flush;
class GetAsyncCommandResponse_SetupDataSource;
class GetAsyncCommandResponse_SetupTracing;
class GetAsyncCommandResponse_StartDataSource;
class GetAsyncCommandResponse_StopDataSource;
class InitializeConnectionRequest;
class InitializeConnectionResponse;
class NotifyDataSourceStartedRequest;
class NotifyDataSourceStartedResponse;
class NotifyDataSourceStoppedRequest;
class NotifyDataSourceStoppedResponse;
class RegisterDataSourceRequest;
class RegisterDataSourceResponse;
class RegisterTraceWriterRequest;
class RegisterTraceWriterResponse;
class UnregisterDataSourceRequest;
class UnregisterDataSourceResponse;
class UnregisterTraceWriterRequest;
class UnregisterTraceWriterResponse;

enum InitializeConnectionRequest_ProducerSMBScrapingMode {
  InitializeConnectionRequest_ProducerSMBScrapingMode_SMB_SCRAPING_UNSPECIFIED = 0,
  InitializeConnectionRequest_ProducerSMBScrapingMode_SMB_SCRAPING_ENABLED = 1,
  InitializeConnectionRequest_ProducerSMBScrapingMode_SMB_SCRAPING_DISABLED = 2
};
bool InitializeConnectionRequest_ProducerSMBScrapingMode_IsValid(int value);
const InitializeConnectionRequest_ProducerSMBScrapingMode InitializeConnectionRequest_ProducerSMBScrapingMode_ProducerSMBScrapingMode_MIN = InitializeConnectionRequest_ProducerSMBScrapingMode_SMB_SCRAPING_UNSPECIFIED;
const InitializeConnectionRequest_ProducerSMBScrapingMode InitializeConnectionRequest_ProducerSMBScrapingMode_ProducerSMBScrapingMode_MAX = InitializeConnectionRequest_ProducerSMBScrapingMode_SMB_SCRAPING_DISABLED;
const int InitializeConnectionRequest_ProducerSMBScrapingMode_ProducerSMBScrapingMode_ARRAYSIZE = InitializeConnectionRequest_ProducerSMBScrapingMode_ProducerSMBScrapingMode_MAX + 1;

// ===================================================================

class InitializeConnectionRequest : public ::google::protobuf::MessageLite {
 public:
  InitializeConnectionRequest();
  virtual ~InitializeConnectionRequest();

  InitializeConnectionRequest(const InitializeConnectionRequest& from);

  inline InitializeConnectionRequest& operator=(const InitializeConnectionRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const InitializeConnectionRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const InitializeConnectionRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(InitializeConnectionRequest* other);

  // implements Message ----------------------------------------------

  inline InitializeConnectionRequest* New() const { return New(NULL); }

  InitializeConnectionRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const InitializeConnectionRequest& from);
  void MergeFrom(const InitializeConnectionRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InitializeConnectionRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef InitializeConnectionRequest_ProducerSMBScrapingMode ProducerSMBScrapingMode;
  static const ProducerSMBScrapingMode SMB_SCRAPING_UNSPECIFIED =
    InitializeConnectionRequest_ProducerSMBScrapingMode_SMB_SCRAPING_UNSPECIFIED;
  static const ProducerSMBScrapingMode SMB_SCRAPING_ENABLED =
    InitializeConnectionRequest_ProducerSMBScrapingMode_SMB_SCRAPING_ENABLED;
  static const ProducerSMBScrapingMode SMB_SCRAPING_DISABLED =
    InitializeConnectionRequest_ProducerSMBScrapingMode_SMB_SCRAPING_DISABLED;
  static inline bool ProducerSMBScrapingMode_IsValid(int value) {
    return InitializeConnectionRequest_ProducerSMBScrapingMode_IsValid(value);
  }
  static const ProducerSMBScrapingMode ProducerSMBScrapingMode_MIN =
    InitializeConnectionRequest_ProducerSMBScrapingMode_ProducerSMBScrapingMode_MIN;
  static const ProducerSMBScrapingMode ProducerSMBScrapingMode_MAX =
    InitializeConnectionRequest_ProducerSMBScrapingMode_ProducerSMBScrapingMode_MAX;
  static const int ProducerSMBScrapingMode_ARRAYSIZE =
    InitializeConnectionRequest_ProducerSMBScrapingMode_ProducerSMBScrapingMode_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional uint32 shared_buffer_page_size_bytes = 1;
  bool has_shared_buffer_page_size_bytes() const;
  void clear_shared_buffer_page_size_bytes();
  static const int kSharedBufferPageSizeBytesFieldNumber = 1;
  ::google::protobuf::uint32 shared_buffer_page_size_bytes() const;
  void set_shared_buffer_page_size_bytes(::google::protobuf::uint32 value);

  // optional uint32 shared_memory_size_hint_bytes = 2;
  bool has_shared_memory_size_hint_bytes() const;
  void clear_shared_memory_size_hint_bytes();
  static const int kSharedMemorySizeHintBytesFieldNumber = 2;
  ::google::protobuf::uint32 shared_memory_size_hint_bytes() const;
  void set_shared_memory_size_hint_bytes(::google::protobuf::uint32 value);

  // optional string producer_name = 3;
  bool has_producer_name() const;
  void clear_producer_name();
  static const int kProducerNameFieldNumber = 3;
  const ::std::string& producer_name() const;
  void set_producer_name(const ::std::string& value);
  void set_producer_name(const char* value);
  void set_producer_name(const char* value, size_t size);
  ::std::string* mutable_producer_name();
  ::std::string* release_producer_name();
  void set_allocated_producer_name(::std::string* producer_name);

  // optional .perfetto.protos.InitializeConnectionRequest.ProducerSMBScrapingMode smb_scraping_mode = 4;
  bool has_smb_scraping_mode() const;
  void clear_smb_scraping_mode();
  static const int kSmbScrapingModeFieldNumber = 4;
  ::perfetto::protos::InitializeConnectionRequest_ProducerSMBScrapingMode smb_scraping_mode() const;
  void set_smb_scraping_mode(::perfetto::protos::InitializeConnectionRequest_ProducerSMBScrapingMode value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.InitializeConnectionRequest)
 private:
  inline void set_has_shared_buffer_page_size_bytes();
  inline void clear_has_shared_buffer_page_size_bytes();
  inline void set_has_shared_memory_size_hint_bytes();
  inline void clear_has_shared_memory_size_hint_bytes();
  inline void set_has_producer_name();
  inline void clear_has_producer_name();
  inline void set_has_smb_scraping_mode();
  inline void clear_has_smb_scraping_mode();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 shared_buffer_page_size_bytes_;
  ::google::protobuf::uint32 shared_memory_size_hint_bytes_;
  ::google::protobuf::internal::ArenaStringPtr producer_name_;
  int smb_scraping_mode_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static InitializeConnectionRequest* default_instance_;
};
// -------------------------------------------------------------------

class InitializeConnectionResponse : public ::google::protobuf::MessageLite {
 public:
  InitializeConnectionResponse();
  virtual ~InitializeConnectionResponse();

  InitializeConnectionResponse(const InitializeConnectionResponse& from);

  inline InitializeConnectionResponse& operator=(const InitializeConnectionResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const InitializeConnectionResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const InitializeConnectionResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(InitializeConnectionResponse* other);

  // implements Message ----------------------------------------------

  inline InitializeConnectionResponse* New() const { return New(NULL); }

  InitializeConnectionResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const InitializeConnectionResponse& from);
  void MergeFrom(const InitializeConnectionResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InitializeConnectionResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.InitializeConnectionResponse)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static InitializeConnectionResponse* default_instance_;
};
// -------------------------------------------------------------------

class RegisterDataSourceRequest : public ::google::protobuf::MessageLite {
 public:
  RegisterDataSourceRequest();
  virtual ~RegisterDataSourceRequest();

  RegisterDataSourceRequest(const RegisterDataSourceRequest& from);

  inline RegisterDataSourceRequest& operator=(const RegisterDataSourceRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const RegisterDataSourceRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RegisterDataSourceRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RegisterDataSourceRequest* other);

  // implements Message ----------------------------------------------

  inline RegisterDataSourceRequest* New() const { return New(NULL); }

  RegisterDataSourceRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RegisterDataSourceRequest& from);
  void MergeFrom(const RegisterDataSourceRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RegisterDataSourceRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .perfetto.protos.DataSourceDescriptor data_source_descriptor = 1;
  bool has_data_source_descriptor() const;
  void clear_data_source_descriptor();
  static const int kDataSourceDescriptorFieldNumber = 1;
  const ::perfetto::protos::DataSourceDescriptor& data_source_descriptor() const;
  ::perfetto::protos::DataSourceDescriptor* mutable_data_source_descriptor();
  ::perfetto::protos::DataSourceDescriptor* release_data_source_descriptor();
  void set_allocated_data_source_descriptor(::perfetto::protos::DataSourceDescriptor* data_source_descriptor);

  // @@protoc_insertion_point(class_scope:perfetto.protos.RegisterDataSourceRequest)
 private:
  inline void set_has_data_source_descriptor();
  inline void clear_has_data_source_descriptor();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::perfetto::protos::DataSourceDescriptor* data_source_descriptor_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static RegisterDataSourceRequest* default_instance_;
};
// -------------------------------------------------------------------

class RegisterDataSourceResponse : public ::google::protobuf::MessageLite {
 public:
  RegisterDataSourceResponse();
  virtual ~RegisterDataSourceResponse();

  RegisterDataSourceResponse(const RegisterDataSourceResponse& from);

  inline RegisterDataSourceResponse& operator=(const RegisterDataSourceResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const RegisterDataSourceResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RegisterDataSourceResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RegisterDataSourceResponse* other);

  // implements Message ----------------------------------------------

  inline RegisterDataSourceResponse* New() const { return New(NULL); }

  RegisterDataSourceResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RegisterDataSourceResponse& from);
  void MergeFrom(const RegisterDataSourceResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RegisterDataSourceResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string error = 1;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // @@protoc_insertion_point(class_scope:perfetto.protos.RegisterDataSourceResponse)
 private:
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static RegisterDataSourceResponse* default_instance_;
};
// -------------------------------------------------------------------

class UnregisterDataSourceRequest : public ::google::protobuf::MessageLite {
 public:
  UnregisterDataSourceRequest();
  virtual ~UnregisterDataSourceRequest();

  UnregisterDataSourceRequest(const UnregisterDataSourceRequest& from);

  inline UnregisterDataSourceRequest& operator=(const UnregisterDataSourceRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const UnregisterDataSourceRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UnregisterDataSourceRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UnregisterDataSourceRequest* other);

  // implements Message ----------------------------------------------

  inline UnregisterDataSourceRequest* New() const { return New(NULL); }

  UnregisterDataSourceRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UnregisterDataSourceRequest& from);
  void MergeFrom(const UnregisterDataSourceRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UnregisterDataSourceRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string data_source_name = 1;
  bool has_data_source_name() const;
  void clear_data_source_name();
  static const int kDataSourceNameFieldNumber = 1;
  const ::std::string& data_source_name() const;
  void set_data_source_name(const ::std::string& value);
  void set_data_source_name(const char* value);
  void set_data_source_name(const char* value, size_t size);
  ::std::string* mutable_data_source_name();
  ::std::string* release_data_source_name();
  void set_allocated_data_source_name(::std::string* data_source_name);

  // @@protoc_insertion_point(class_scope:perfetto.protos.UnregisterDataSourceRequest)
 private:
  inline void set_has_data_source_name();
  inline void clear_has_data_source_name();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_source_name_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static UnregisterDataSourceRequest* default_instance_;
};
// -------------------------------------------------------------------

class UnregisterDataSourceResponse : public ::google::protobuf::MessageLite {
 public:
  UnregisterDataSourceResponse();
  virtual ~UnregisterDataSourceResponse();

  UnregisterDataSourceResponse(const UnregisterDataSourceResponse& from);

  inline UnregisterDataSourceResponse& operator=(const UnregisterDataSourceResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const UnregisterDataSourceResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UnregisterDataSourceResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UnregisterDataSourceResponse* other);

  // implements Message ----------------------------------------------

  inline UnregisterDataSourceResponse* New() const { return New(NULL); }

  UnregisterDataSourceResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UnregisterDataSourceResponse& from);
  void MergeFrom(const UnregisterDataSourceResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UnregisterDataSourceResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.UnregisterDataSourceResponse)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static UnregisterDataSourceResponse* default_instance_;
};
// -------------------------------------------------------------------

class RegisterTraceWriterRequest : public ::google::protobuf::MessageLite {
 public:
  RegisterTraceWriterRequest();
  virtual ~RegisterTraceWriterRequest();

  RegisterTraceWriterRequest(const RegisterTraceWriterRequest& from);

  inline RegisterTraceWriterRequest& operator=(const RegisterTraceWriterRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const RegisterTraceWriterRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RegisterTraceWriterRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RegisterTraceWriterRequest* other);

  // implements Message ----------------------------------------------

  inline RegisterTraceWriterRequest* New() const { return New(NULL); }

  RegisterTraceWriterRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RegisterTraceWriterRequest& from);
  void MergeFrom(const RegisterTraceWriterRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RegisterTraceWriterRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 trace_writer_id = 1;
  bool has_trace_writer_id() const;
  void clear_trace_writer_id();
  static const int kTraceWriterIdFieldNumber = 1;
  ::google::protobuf::uint32 trace_writer_id() const;
  void set_trace_writer_id(::google::protobuf::uint32 value);

  // optional uint32 target_buffer = 2;
  bool has_target_buffer() const;
  void clear_target_buffer();
  static const int kTargetBufferFieldNumber = 2;
  ::google::protobuf::uint32 target_buffer() const;
  void set_target_buffer(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.RegisterTraceWriterRequest)
 private:
  inline void set_has_trace_writer_id();
  inline void clear_has_trace_writer_id();
  inline void set_has_target_buffer();
  inline void clear_has_target_buffer();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 trace_writer_id_;
  ::google::protobuf::uint32 target_buffer_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static RegisterTraceWriterRequest* default_instance_;
};
// -------------------------------------------------------------------

class RegisterTraceWriterResponse : public ::google::protobuf::MessageLite {
 public:
  RegisterTraceWriterResponse();
  virtual ~RegisterTraceWriterResponse();

  RegisterTraceWriterResponse(const RegisterTraceWriterResponse& from);

  inline RegisterTraceWriterResponse& operator=(const RegisterTraceWriterResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const RegisterTraceWriterResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RegisterTraceWriterResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RegisterTraceWriterResponse* other);

  // implements Message ----------------------------------------------

  inline RegisterTraceWriterResponse* New() const { return New(NULL); }

  RegisterTraceWriterResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RegisterTraceWriterResponse& from);
  void MergeFrom(const RegisterTraceWriterResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RegisterTraceWriterResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.RegisterTraceWriterResponse)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static RegisterTraceWriterResponse* default_instance_;
};
// -------------------------------------------------------------------

class UnregisterTraceWriterRequest : public ::google::protobuf::MessageLite {
 public:
  UnregisterTraceWriterRequest();
  virtual ~UnregisterTraceWriterRequest();

  UnregisterTraceWriterRequest(const UnregisterTraceWriterRequest& from);

  inline UnregisterTraceWriterRequest& operator=(const UnregisterTraceWriterRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const UnregisterTraceWriterRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UnregisterTraceWriterRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UnregisterTraceWriterRequest* other);

  // implements Message ----------------------------------------------

  inline UnregisterTraceWriterRequest* New() const { return New(NULL); }

  UnregisterTraceWriterRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UnregisterTraceWriterRequest& from);
  void MergeFrom(const UnregisterTraceWriterRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UnregisterTraceWriterRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 trace_writer_id = 1;
  bool has_trace_writer_id() const;
  void clear_trace_writer_id();
  static const int kTraceWriterIdFieldNumber = 1;
  ::google::protobuf::uint32 trace_writer_id() const;
  void set_trace_writer_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.UnregisterTraceWriterRequest)
 private:
  inline void set_has_trace_writer_id();
  inline void clear_has_trace_writer_id();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 trace_writer_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static UnregisterTraceWriterRequest* default_instance_;
};
// -------------------------------------------------------------------

class UnregisterTraceWriterResponse : public ::google::protobuf::MessageLite {
 public:
  UnregisterTraceWriterResponse();
  virtual ~UnregisterTraceWriterResponse();

  UnregisterTraceWriterResponse(const UnregisterTraceWriterResponse& from);

  inline UnregisterTraceWriterResponse& operator=(const UnregisterTraceWriterResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const UnregisterTraceWriterResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UnregisterTraceWriterResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UnregisterTraceWriterResponse* other);

  // implements Message ----------------------------------------------

  inline UnregisterTraceWriterResponse* New() const { return New(NULL); }

  UnregisterTraceWriterResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UnregisterTraceWriterResponse& from);
  void MergeFrom(const UnregisterTraceWriterResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UnregisterTraceWriterResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.UnregisterTraceWriterResponse)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static UnregisterTraceWriterResponse* default_instance_;
};
// -------------------------------------------------------------------

class CommitDataResponse : public ::google::protobuf::MessageLite {
 public:
  CommitDataResponse();
  virtual ~CommitDataResponse();

  CommitDataResponse(const CommitDataResponse& from);

  inline CommitDataResponse& operator=(const CommitDataResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const CommitDataResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommitDataResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommitDataResponse* other);

  // implements Message ----------------------------------------------

  inline CommitDataResponse* New() const { return New(NULL); }

  CommitDataResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommitDataResponse& from);
  void MergeFrom(const CommitDataResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommitDataResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.CommitDataResponse)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static CommitDataResponse* default_instance_;
};
// -------------------------------------------------------------------

class NotifyDataSourceStartedRequest : public ::google::protobuf::MessageLite {
 public:
  NotifyDataSourceStartedRequest();
  virtual ~NotifyDataSourceStartedRequest();

  NotifyDataSourceStartedRequest(const NotifyDataSourceStartedRequest& from);

  inline NotifyDataSourceStartedRequest& operator=(const NotifyDataSourceStartedRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const NotifyDataSourceStartedRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotifyDataSourceStartedRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotifyDataSourceStartedRequest* other);

  // implements Message ----------------------------------------------

  inline NotifyDataSourceStartedRequest* New() const { return New(NULL); }

  NotifyDataSourceStartedRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotifyDataSourceStartedRequest& from);
  void MergeFrom(const NotifyDataSourceStartedRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NotifyDataSourceStartedRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 data_source_id = 1;
  bool has_data_source_id() const;
  void clear_data_source_id();
  static const int kDataSourceIdFieldNumber = 1;
  ::google::protobuf::uint64 data_source_id() const;
  void set_data_source_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.NotifyDataSourceStartedRequest)
 private:
  inline void set_has_data_source_id();
  inline void clear_has_data_source_id();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 data_source_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static NotifyDataSourceStartedRequest* default_instance_;
};
// -------------------------------------------------------------------

class NotifyDataSourceStartedResponse : public ::google::protobuf::MessageLite {
 public:
  NotifyDataSourceStartedResponse();
  virtual ~NotifyDataSourceStartedResponse();

  NotifyDataSourceStartedResponse(const NotifyDataSourceStartedResponse& from);

  inline NotifyDataSourceStartedResponse& operator=(const NotifyDataSourceStartedResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const NotifyDataSourceStartedResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotifyDataSourceStartedResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotifyDataSourceStartedResponse* other);

  // implements Message ----------------------------------------------

  inline NotifyDataSourceStartedResponse* New() const { return New(NULL); }

  NotifyDataSourceStartedResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotifyDataSourceStartedResponse& from);
  void MergeFrom(const NotifyDataSourceStartedResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NotifyDataSourceStartedResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.NotifyDataSourceStartedResponse)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static NotifyDataSourceStartedResponse* default_instance_;
};
// -------------------------------------------------------------------

class NotifyDataSourceStoppedRequest : public ::google::protobuf::MessageLite {
 public:
  NotifyDataSourceStoppedRequest();
  virtual ~NotifyDataSourceStoppedRequest();

  NotifyDataSourceStoppedRequest(const NotifyDataSourceStoppedRequest& from);

  inline NotifyDataSourceStoppedRequest& operator=(const NotifyDataSourceStoppedRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const NotifyDataSourceStoppedRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotifyDataSourceStoppedRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotifyDataSourceStoppedRequest* other);

  // implements Message ----------------------------------------------

  inline NotifyDataSourceStoppedRequest* New() const { return New(NULL); }

  NotifyDataSourceStoppedRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotifyDataSourceStoppedRequest& from);
  void MergeFrom(const NotifyDataSourceStoppedRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NotifyDataSourceStoppedRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 data_source_id = 1;
  bool has_data_source_id() const;
  void clear_data_source_id();
  static const int kDataSourceIdFieldNumber = 1;
  ::google::protobuf::uint64 data_source_id() const;
  void set_data_source_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.NotifyDataSourceStoppedRequest)
 private:
  inline void set_has_data_source_id();
  inline void clear_has_data_source_id();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 data_source_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static NotifyDataSourceStoppedRequest* default_instance_;
};
// -------------------------------------------------------------------

class NotifyDataSourceStoppedResponse : public ::google::protobuf::MessageLite {
 public:
  NotifyDataSourceStoppedResponse();
  virtual ~NotifyDataSourceStoppedResponse();

  NotifyDataSourceStoppedResponse(const NotifyDataSourceStoppedResponse& from);

  inline NotifyDataSourceStoppedResponse& operator=(const NotifyDataSourceStoppedResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const NotifyDataSourceStoppedResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotifyDataSourceStoppedResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotifyDataSourceStoppedResponse* other);

  // implements Message ----------------------------------------------

  inline NotifyDataSourceStoppedResponse* New() const { return New(NULL); }

  NotifyDataSourceStoppedResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotifyDataSourceStoppedResponse& from);
  void MergeFrom(const NotifyDataSourceStoppedResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NotifyDataSourceStoppedResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.NotifyDataSourceStoppedResponse)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static NotifyDataSourceStoppedResponse* default_instance_;
};
// -------------------------------------------------------------------

class ActivateTriggersRequest : public ::google::protobuf::MessageLite {
 public:
  ActivateTriggersRequest();
  virtual ~ActivateTriggersRequest();

  ActivateTriggersRequest(const ActivateTriggersRequest& from);

  inline ActivateTriggersRequest& operator=(const ActivateTriggersRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ActivateTriggersRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ActivateTriggersRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ActivateTriggersRequest* other);

  // implements Message ----------------------------------------------

  inline ActivateTriggersRequest* New() const { return New(NULL); }

  ActivateTriggersRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ActivateTriggersRequest& from);
  void MergeFrom(const ActivateTriggersRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActivateTriggersRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string trigger_names = 1;
  int trigger_names_size() const;
  void clear_trigger_names();
  static const int kTriggerNamesFieldNumber = 1;
  const ::std::string& trigger_names(int index) const;
  ::std::string* mutable_trigger_names(int index);
  void set_trigger_names(int index, const ::std::string& value);
  void set_trigger_names(int index, const char* value);
  void set_trigger_names(int index, const char* value, size_t size);
  ::std::string* add_trigger_names();
  void add_trigger_names(const ::std::string& value);
  void add_trigger_names(const char* value);
  void add_trigger_names(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& trigger_names() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_trigger_names();

  // @@protoc_insertion_point(class_scope:perfetto.protos.ActivateTriggersRequest)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> trigger_names_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static ActivateTriggersRequest* default_instance_;
};
// -------------------------------------------------------------------

class ActivateTriggersResponse : public ::google::protobuf::MessageLite {
 public:
  ActivateTriggersResponse();
  virtual ~ActivateTriggersResponse();

  ActivateTriggersResponse(const ActivateTriggersResponse& from);

  inline ActivateTriggersResponse& operator=(const ActivateTriggersResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ActivateTriggersResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ActivateTriggersResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ActivateTriggersResponse* other);

  // implements Message ----------------------------------------------

  inline ActivateTriggersResponse* New() const { return New(NULL); }

  ActivateTriggersResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ActivateTriggersResponse& from);
  void MergeFrom(const ActivateTriggersResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActivateTriggersResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.ActivateTriggersResponse)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static ActivateTriggersResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetAsyncCommandRequest : public ::google::protobuf::MessageLite {
 public:
  GetAsyncCommandRequest();
  virtual ~GetAsyncCommandRequest();

  GetAsyncCommandRequest(const GetAsyncCommandRequest& from);

  inline GetAsyncCommandRequest& operator=(const GetAsyncCommandRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const GetAsyncCommandRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetAsyncCommandRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetAsyncCommandRequest* other);

  // implements Message ----------------------------------------------

  inline GetAsyncCommandRequest* New() const { return New(NULL); }

  GetAsyncCommandRequest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetAsyncCommandRequest& from);
  void MergeFrom(const GetAsyncCommandRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetAsyncCommandRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:perfetto.protos.GetAsyncCommandRequest)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static GetAsyncCommandRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetAsyncCommandResponse_SetupDataSource : public ::google::protobuf::MessageLite {
 public:
  GetAsyncCommandResponse_SetupDataSource();
  virtual ~GetAsyncCommandResponse_SetupDataSource();

  GetAsyncCommandResponse_SetupDataSource(const GetAsyncCommandResponse_SetupDataSource& from);

  inline GetAsyncCommandResponse_SetupDataSource& operator=(const GetAsyncCommandResponse_SetupDataSource& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const GetAsyncCommandResponse_SetupDataSource& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetAsyncCommandResponse_SetupDataSource* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetAsyncCommandResponse_SetupDataSource* other);

  // implements Message ----------------------------------------------

  inline GetAsyncCommandResponse_SetupDataSource* New() const { return New(NULL); }

  GetAsyncCommandResponse_SetupDataSource* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetAsyncCommandResponse_SetupDataSource& from);
  void MergeFrom(const GetAsyncCommandResponse_SetupDataSource& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetAsyncCommandResponse_SetupDataSource* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 new_instance_id = 1;
  bool has_new_instance_id() const;
  void clear_new_instance_id();
  static const int kNewInstanceIdFieldNumber = 1;
  ::google::protobuf::uint64 new_instance_id() const;
  void set_new_instance_id(::google::protobuf::uint64 value);

  // optional .perfetto.protos.DataSourceConfig config = 2;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 2;
  const ::perfetto::protos::DataSourceConfig& config() const;
  ::perfetto::protos::DataSourceConfig* mutable_config();
  ::perfetto::protos::DataSourceConfig* release_config();
  void set_allocated_config(::perfetto::protos::DataSourceConfig* config);

  // @@protoc_insertion_point(class_scope:perfetto.protos.GetAsyncCommandResponse.SetupDataSource)
 private:
  inline void set_has_new_instance_id();
  inline void clear_has_new_instance_id();
  inline void set_has_config();
  inline void clear_has_config();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 new_instance_id_;
  ::perfetto::protos::DataSourceConfig* config_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static GetAsyncCommandResponse_SetupDataSource* default_instance_;
};
// -------------------------------------------------------------------

class GetAsyncCommandResponse_StartDataSource : public ::google::protobuf::MessageLite {
 public:
  GetAsyncCommandResponse_StartDataSource();
  virtual ~GetAsyncCommandResponse_StartDataSource();

  GetAsyncCommandResponse_StartDataSource(const GetAsyncCommandResponse_StartDataSource& from);

  inline GetAsyncCommandResponse_StartDataSource& operator=(const GetAsyncCommandResponse_StartDataSource& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const GetAsyncCommandResponse_StartDataSource& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetAsyncCommandResponse_StartDataSource* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetAsyncCommandResponse_StartDataSource* other);

  // implements Message ----------------------------------------------

  inline GetAsyncCommandResponse_StartDataSource* New() const { return New(NULL); }

  GetAsyncCommandResponse_StartDataSource* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetAsyncCommandResponse_StartDataSource& from);
  void MergeFrom(const GetAsyncCommandResponse_StartDataSource& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetAsyncCommandResponse_StartDataSource* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 new_instance_id = 1;
  bool has_new_instance_id() const;
  void clear_new_instance_id();
  static const int kNewInstanceIdFieldNumber = 1;
  ::google::protobuf::uint64 new_instance_id() const;
  void set_new_instance_id(::google::protobuf::uint64 value);

  // optional .perfetto.protos.DataSourceConfig config = 2;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 2;
  const ::perfetto::protos::DataSourceConfig& config() const;
  ::perfetto::protos::DataSourceConfig* mutable_config();
  ::perfetto::protos::DataSourceConfig* release_config();
  void set_allocated_config(::perfetto::protos::DataSourceConfig* config);

  // @@protoc_insertion_point(class_scope:perfetto.protos.GetAsyncCommandResponse.StartDataSource)
 private:
  inline void set_has_new_instance_id();
  inline void clear_has_new_instance_id();
  inline void set_has_config();
  inline void clear_has_config();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 new_instance_id_;
  ::perfetto::protos::DataSourceConfig* config_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static GetAsyncCommandResponse_StartDataSource* default_instance_;
};
// -------------------------------------------------------------------

class GetAsyncCommandResponse_StopDataSource : public ::google::protobuf::MessageLite {
 public:
  GetAsyncCommandResponse_StopDataSource();
  virtual ~GetAsyncCommandResponse_StopDataSource();

  GetAsyncCommandResponse_StopDataSource(const GetAsyncCommandResponse_StopDataSource& from);

  inline GetAsyncCommandResponse_StopDataSource& operator=(const GetAsyncCommandResponse_StopDataSource& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const GetAsyncCommandResponse_StopDataSource& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetAsyncCommandResponse_StopDataSource* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetAsyncCommandResponse_StopDataSource* other);

  // implements Message ----------------------------------------------

  inline GetAsyncCommandResponse_StopDataSource* New() const { return New(NULL); }

  GetAsyncCommandResponse_StopDataSource* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetAsyncCommandResponse_StopDataSource& from);
  void MergeFrom(const GetAsyncCommandResponse_StopDataSource& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetAsyncCommandResponse_StopDataSource* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 instance_id = 1;
  bool has_instance_id() const;
  void clear_instance_id();
  static const int kInstanceIdFieldNumber = 1;
  ::google::protobuf::uint64 instance_id() const;
  void set_instance_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.GetAsyncCommandResponse.StopDataSource)
 private:
  inline void set_has_instance_id();
  inline void clear_has_instance_id();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 instance_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static GetAsyncCommandResponse_StopDataSource* default_instance_;
};
// -------------------------------------------------------------------

class GetAsyncCommandResponse_SetupTracing : public ::google::protobuf::MessageLite {
 public:
  GetAsyncCommandResponse_SetupTracing();
  virtual ~GetAsyncCommandResponse_SetupTracing();

  GetAsyncCommandResponse_SetupTracing(const GetAsyncCommandResponse_SetupTracing& from);

  inline GetAsyncCommandResponse_SetupTracing& operator=(const GetAsyncCommandResponse_SetupTracing& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const GetAsyncCommandResponse_SetupTracing& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetAsyncCommandResponse_SetupTracing* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetAsyncCommandResponse_SetupTracing* other);

  // implements Message ----------------------------------------------

  inline GetAsyncCommandResponse_SetupTracing* New() const { return New(NULL); }

  GetAsyncCommandResponse_SetupTracing* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetAsyncCommandResponse_SetupTracing& from);
  void MergeFrom(const GetAsyncCommandResponse_SetupTracing& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetAsyncCommandResponse_SetupTracing* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 shared_buffer_page_size_kb = 1;
  bool has_shared_buffer_page_size_kb() const;
  void clear_shared_buffer_page_size_kb();
  static const int kSharedBufferPageSizeKbFieldNumber = 1;
  ::google::protobuf::uint32 shared_buffer_page_size_kb() const;
  void set_shared_buffer_page_size_kb(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.GetAsyncCommandResponse.SetupTracing)
 private:
  inline void set_has_shared_buffer_page_size_kb();
  inline void clear_has_shared_buffer_page_size_kb();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 shared_buffer_page_size_kb_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static GetAsyncCommandResponse_SetupTracing* default_instance_;
};
// -------------------------------------------------------------------

class GetAsyncCommandResponse_Flush : public ::google::protobuf::MessageLite {
 public:
  GetAsyncCommandResponse_Flush();
  virtual ~GetAsyncCommandResponse_Flush();

  GetAsyncCommandResponse_Flush(const GetAsyncCommandResponse_Flush& from);

  inline GetAsyncCommandResponse_Flush& operator=(const GetAsyncCommandResponse_Flush& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const GetAsyncCommandResponse_Flush& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetAsyncCommandResponse_Flush* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetAsyncCommandResponse_Flush* other);

  // implements Message ----------------------------------------------

  inline GetAsyncCommandResponse_Flush* New() const { return New(NULL); }

  GetAsyncCommandResponse_Flush* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetAsyncCommandResponse_Flush& from);
  void MergeFrom(const GetAsyncCommandResponse_Flush& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetAsyncCommandResponse_Flush* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 data_source_ids = 1;
  int data_source_ids_size() const;
  void clear_data_source_ids();
  static const int kDataSourceIdsFieldNumber = 1;
  ::google::protobuf::uint64 data_source_ids(int index) const;
  void set_data_source_ids(int index, ::google::protobuf::uint64 value);
  void add_data_source_ids(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      data_source_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_data_source_ids();

  // optional uint64 request_id = 2;
  bool has_request_id() const;
  void clear_request_id();
  static const int kRequestIdFieldNumber = 2;
  ::google::protobuf::uint64 request_id() const;
  void set_request_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.GetAsyncCommandResponse.Flush)
 private:
  inline void set_has_request_id();
  inline void clear_has_request_id();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > data_source_ids_;
  ::google::protobuf::uint64 request_id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static GetAsyncCommandResponse_Flush* default_instance_;
};
// -------------------------------------------------------------------

class GetAsyncCommandResponse_ClearIncrementalState : public ::google::protobuf::MessageLite {
 public:
  GetAsyncCommandResponse_ClearIncrementalState();
  virtual ~GetAsyncCommandResponse_ClearIncrementalState();

  GetAsyncCommandResponse_ClearIncrementalState(const GetAsyncCommandResponse_ClearIncrementalState& from);

  inline GetAsyncCommandResponse_ClearIncrementalState& operator=(const GetAsyncCommandResponse_ClearIncrementalState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const GetAsyncCommandResponse_ClearIncrementalState& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetAsyncCommandResponse_ClearIncrementalState* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetAsyncCommandResponse_ClearIncrementalState* other);

  // implements Message ----------------------------------------------

  inline GetAsyncCommandResponse_ClearIncrementalState* New() const { return New(NULL); }

  GetAsyncCommandResponse_ClearIncrementalState* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetAsyncCommandResponse_ClearIncrementalState& from);
  void MergeFrom(const GetAsyncCommandResponse_ClearIncrementalState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetAsyncCommandResponse_ClearIncrementalState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 data_source_ids = 1;
  int data_source_ids_size() const;
  void clear_data_source_ids();
  static const int kDataSourceIdsFieldNumber = 1;
  ::google::protobuf::uint64 data_source_ids(int index) const;
  void set_data_source_ids(int index, ::google::protobuf::uint64 value);
  void add_data_source_ids(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      data_source_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_data_source_ids();

  // @@protoc_insertion_point(class_scope:perfetto.protos.GetAsyncCommandResponse.ClearIncrementalState)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > data_source_ids_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static GetAsyncCommandResponse_ClearIncrementalState* default_instance_;
};
// -------------------------------------------------------------------

class GetAsyncCommandResponse : public ::google::protobuf::MessageLite {
 public:
  GetAsyncCommandResponse();
  virtual ~GetAsyncCommandResponse();

  GetAsyncCommandResponse(const GetAsyncCommandResponse& from);

  inline GetAsyncCommandResponse& operator=(const GetAsyncCommandResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const GetAsyncCommandResponse& default_instance();

  enum CmdCase {
    kSetupTracing = 3,
    kSetupDataSource = 6,
    kStartDataSource = 1,
    kStopDataSource = 2,
    kFlush = 5,
    kClearIncrementalState = 7,
    CMD_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetAsyncCommandResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetAsyncCommandResponse* other);

  // implements Message ----------------------------------------------

  inline GetAsyncCommandResponse* New() const { return New(NULL); }

  GetAsyncCommandResponse* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetAsyncCommandResponse& from);
  void MergeFrom(const GetAsyncCommandResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetAsyncCommandResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef GetAsyncCommandResponse_SetupDataSource SetupDataSource;
  typedef GetAsyncCommandResponse_StartDataSource StartDataSource;
  typedef GetAsyncCommandResponse_StopDataSource StopDataSource;
  typedef GetAsyncCommandResponse_SetupTracing SetupTracing;
  typedef GetAsyncCommandResponse_Flush Flush;
  typedef GetAsyncCommandResponse_ClearIncrementalState ClearIncrementalState;

  // accessors -------------------------------------------------------

  // optional .perfetto.protos.GetAsyncCommandResponse.SetupTracing setup_tracing = 3;
  bool has_setup_tracing() const;
  void clear_setup_tracing();
  static const int kSetupTracingFieldNumber = 3;
  const ::perfetto::protos::GetAsyncCommandResponse_SetupTracing& setup_tracing() const;
  ::perfetto::protos::GetAsyncCommandResponse_SetupTracing* mutable_setup_tracing();
  ::perfetto::protos::GetAsyncCommandResponse_SetupTracing* release_setup_tracing();
  void set_allocated_setup_tracing(::perfetto::protos::GetAsyncCommandResponse_SetupTracing* setup_tracing);

  // optional .perfetto.protos.GetAsyncCommandResponse.SetupDataSource setup_data_source = 6;
  bool has_setup_data_source() const;
  void clear_setup_data_source();
  static const int kSetupDataSourceFieldNumber = 6;
  const ::perfetto::protos::GetAsyncCommandResponse_SetupDataSource& setup_data_source() const;
  ::perfetto::protos::GetAsyncCommandResponse_SetupDataSource* mutable_setup_data_source();
  ::perfetto::protos::GetAsyncCommandResponse_SetupDataSource* release_setup_data_source();
  void set_allocated_setup_data_source(::perfetto::protos::GetAsyncCommandResponse_SetupDataSource* setup_data_source);

  // optional .perfetto.protos.GetAsyncCommandResponse.StartDataSource start_data_source = 1;
  bool has_start_data_source() const;
  void clear_start_data_source();
  static const int kStartDataSourceFieldNumber = 1;
  const ::perfetto::protos::GetAsyncCommandResponse_StartDataSource& start_data_source() const;
  ::perfetto::protos::GetAsyncCommandResponse_StartDataSource* mutable_start_data_source();
  ::perfetto::protos::GetAsyncCommandResponse_StartDataSource* release_start_data_source();
  void set_allocated_start_data_source(::perfetto::protos::GetAsyncCommandResponse_StartDataSource* start_data_source);

  // optional .perfetto.protos.GetAsyncCommandResponse.StopDataSource stop_data_source = 2;
  bool has_stop_data_source() const;
  void clear_stop_data_source();
  static const int kStopDataSourceFieldNumber = 2;
  const ::perfetto::protos::GetAsyncCommandResponse_StopDataSource& stop_data_source() const;
  ::perfetto::protos::GetAsyncCommandResponse_StopDataSource* mutable_stop_data_source();
  ::perfetto::protos::GetAsyncCommandResponse_StopDataSource* release_stop_data_source();
  void set_allocated_stop_data_source(::perfetto::protos::GetAsyncCommandResponse_StopDataSource* stop_data_source);

  // optional .perfetto.protos.GetAsyncCommandResponse.Flush flush = 5;
  bool has_flush() const;
  void clear_flush();
  static const int kFlushFieldNumber = 5;
  const ::perfetto::protos::GetAsyncCommandResponse_Flush& flush() const;
  ::perfetto::protos::GetAsyncCommandResponse_Flush* mutable_flush();
  ::perfetto::protos::GetAsyncCommandResponse_Flush* release_flush();
  void set_allocated_flush(::perfetto::protos::GetAsyncCommandResponse_Flush* flush);

  // optional .perfetto.protos.GetAsyncCommandResponse.ClearIncrementalState clear_incremental_state = 7;
  bool has_clear_incremental_state() const;
  void clear_clear_incremental_state();
  static const int kClearIncrementalStateFieldNumber = 7;
  const ::perfetto::protos::GetAsyncCommandResponse_ClearIncrementalState& clear_incremental_state() const;
  ::perfetto::protos::GetAsyncCommandResponse_ClearIncrementalState* mutable_clear_incremental_state();
  ::perfetto::protos::GetAsyncCommandResponse_ClearIncrementalState* release_clear_incremental_state();
  void set_allocated_clear_incremental_state(::perfetto::protos::GetAsyncCommandResponse_ClearIncrementalState* clear_incremental_state);

  CmdCase cmd_case() const;
  // @@protoc_insertion_point(class_scope:perfetto.protos.GetAsyncCommandResponse)
 private:
  inline void set_has_setup_tracing();
  inline void set_has_setup_data_source();
  inline void set_has_start_data_source();
  inline void set_has_stop_data_source();
  inline void set_has_flush();
  inline void set_has_clear_incremental_state();

  inline bool has_cmd() const;
  void clear_cmd();
  inline void clear_has_cmd();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  union CmdUnion {
    CmdUnion() {}
    ::perfetto::protos::GetAsyncCommandResponse_SetupTracing* setup_tracing_;
    ::perfetto::protos::GetAsyncCommandResponse_SetupDataSource* setup_data_source_;
    ::perfetto::protos::GetAsyncCommandResponse_StartDataSource* start_data_source_;
    ::perfetto::protos::GetAsyncCommandResponse_StopDataSource* stop_data_source_;
    ::perfetto::protos::GetAsyncCommandResponse_Flush* flush_;
    ::perfetto::protos::GetAsyncCommandResponse_ClearIncrementalState* clear_incremental_state_;
  } cmd_;
  ::google::protobuf::uint32 _oneof_case_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2fipc_2fproducer_5fport_2eproto();

  void InitAsDefaultInstance();
  static GetAsyncCommandResponse* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// InitializeConnectionRequest

// optional uint32 shared_buffer_page_size_bytes = 1;
inline bool InitializeConnectionRequest::has_shared_buffer_page_size_bytes() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InitializeConnectionRequest::set_has_shared_buffer_page_size_bytes() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InitializeConnectionRequest::clear_has_shared_buffer_page_size_bytes() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InitializeConnectionRequest::clear_shared_buffer_page_size_bytes() {
  shared_buffer_page_size_bytes_ = 0u;
  clear_has_shared_buffer_page_size_bytes();
}
inline ::google::protobuf::uint32 InitializeConnectionRequest::shared_buffer_page_size_bytes() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InitializeConnectionRequest.shared_buffer_page_size_bytes)
  return shared_buffer_page_size_bytes_;
}
inline void InitializeConnectionRequest::set_shared_buffer_page_size_bytes(::google::protobuf::uint32 value) {
  set_has_shared_buffer_page_size_bytes();
  shared_buffer_page_size_bytes_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.InitializeConnectionRequest.shared_buffer_page_size_bytes)
}

// optional uint32 shared_memory_size_hint_bytes = 2;
inline bool InitializeConnectionRequest::has_shared_memory_size_hint_bytes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InitializeConnectionRequest::set_has_shared_memory_size_hint_bytes() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InitializeConnectionRequest::clear_has_shared_memory_size_hint_bytes() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InitializeConnectionRequest::clear_shared_memory_size_hint_bytes() {
  shared_memory_size_hint_bytes_ = 0u;
  clear_has_shared_memory_size_hint_bytes();
}
inline ::google::protobuf::uint32 InitializeConnectionRequest::shared_memory_size_hint_bytes() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InitializeConnectionRequest.shared_memory_size_hint_bytes)
  return shared_memory_size_hint_bytes_;
}
inline void InitializeConnectionRequest::set_shared_memory_size_hint_bytes(::google::protobuf::uint32 value) {
  set_has_shared_memory_size_hint_bytes();
  shared_memory_size_hint_bytes_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.InitializeConnectionRequest.shared_memory_size_hint_bytes)
}

// optional string producer_name = 3;
inline bool InitializeConnectionRequest::has_producer_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InitializeConnectionRequest::set_has_producer_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InitializeConnectionRequest::clear_has_producer_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InitializeConnectionRequest::clear_producer_name() {
  producer_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_producer_name();
}
inline const ::std::string& InitializeConnectionRequest::producer_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InitializeConnectionRequest.producer_name)
  return producer_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InitializeConnectionRequest::set_producer_name(const ::std::string& value) {
  set_has_producer_name();
  producer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.InitializeConnectionRequest.producer_name)
}
inline void InitializeConnectionRequest::set_producer_name(const char* value) {
  set_has_producer_name();
  producer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.InitializeConnectionRequest.producer_name)
}
inline void InitializeConnectionRequest::set_producer_name(const char* value, size_t size) {
  set_has_producer_name();
  producer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.InitializeConnectionRequest.producer_name)
}
inline ::std::string* InitializeConnectionRequest::mutable_producer_name() {
  set_has_producer_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.InitializeConnectionRequest.producer_name)
  return producer_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InitializeConnectionRequest::release_producer_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.InitializeConnectionRequest.producer_name)
  clear_has_producer_name();
  return producer_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InitializeConnectionRequest::set_allocated_producer_name(::std::string* producer_name) {
  if (producer_name != NULL) {
    set_has_producer_name();
  } else {
    clear_has_producer_name();
  }
  producer_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), producer_name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.InitializeConnectionRequest.producer_name)
}

// optional .perfetto.protos.InitializeConnectionRequest.ProducerSMBScrapingMode smb_scraping_mode = 4;
inline bool InitializeConnectionRequest::has_smb_scraping_mode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InitializeConnectionRequest::set_has_smb_scraping_mode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InitializeConnectionRequest::clear_has_smb_scraping_mode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InitializeConnectionRequest::clear_smb_scraping_mode() {
  smb_scraping_mode_ = 0;
  clear_has_smb_scraping_mode();
}
inline ::perfetto::protos::InitializeConnectionRequest_ProducerSMBScrapingMode InitializeConnectionRequest::smb_scraping_mode() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InitializeConnectionRequest.smb_scraping_mode)
  return static_cast< ::perfetto::protos::InitializeConnectionRequest_ProducerSMBScrapingMode >(smb_scraping_mode_);
}
inline void InitializeConnectionRequest::set_smb_scraping_mode(::perfetto::protos::InitializeConnectionRequest_ProducerSMBScrapingMode value) {
  assert(::perfetto::protos::InitializeConnectionRequest_ProducerSMBScrapingMode_IsValid(value));
  set_has_smb_scraping_mode();
  smb_scraping_mode_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.InitializeConnectionRequest.smb_scraping_mode)
}

// -------------------------------------------------------------------

// InitializeConnectionResponse

// -------------------------------------------------------------------

// RegisterDataSourceRequest

// optional .perfetto.protos.DataSourceDescriptor data_source_descriptor = 1;
inline bool RegisterDataSourceRequest::has_data_source_descriptor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterDataSourceRequest::set_has_data_source_descriptor() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterDataSourceRequest::clear_has_data_source_descriptor() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterDataSourceRequest::clear_data_source_descriptor() {
  if (data_source_descriptor_ != NULL) data_source_descriptor_->::perfetto::protos::DataSourceDescriptor::Clear();
  clear_has_data_source_descriptor();
}
inline const ::perfetto::protos::DataSourceDescriptor& RegisterDataSourceRequest::data_source_descriptor() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.RegisterDataSourceRequest.data_source_descriptor)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return data_source_descriptor_ != NULL ? *data_source_descriptor_ : *default_instance().data_source_descriptor_;
#else
  return data_source_descriptor_ != NULL ? *data_source_descriptor_ : *default_instance_->data_source_descriptor_;
#endif
}
inline ::perfetto::protos::DataSourceDescriptor* RegisterDataSourceRequest::mutable_data_source_descriptor() {
  set_has_data_source_descriptor();
  if (data_source_descriptor_ == NULL) {
    data_source_descriptor_ = new ::perfetto::protos::DataSourceDescriptor;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.RegisterDataSourceRequest.data_source_descriptor)
  return data_source_descriptor_;
}
inline ::perfetto::protos::DataSourceDescriptor* RegisterDataSourceRequest::release_data_source_descriptor() {
  // @@protoc_insertion_point(field_release:perfetto.protos.RegisterDataSourceRequest.data_source_descriptor)
  clear_has_data_source_descriptor();
  ::perfetto::protos::DataSourceDescriptor* temp = data_source_descriptor_;
  data_source_descriptor_ = NULL;
  return temp;
}
inline void RegisterDataSourceRequest::set_allocated_data_source_descriptor(::perfetto::protos::DataSourceDescriptor* data_source_descriptor) {
  delete data_source_descriptor_;
  data_source_descriptor_ = data_source_descriptor;
  if (data_source_descriptor) {
    set_has_data_source_descriptor();
  } else {
    clear_has_data_source_descriptor();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.RegisterDataSourceRequest.data_source_descriptor)
}

// -------------------------------------------------------------------

// RegisterDataSourceResponse

// optional string error = 1;
inline bool RegisterDataSourceResponse::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterDataSourceResponse::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterDataSourceResponse::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterDataSourceResponse::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error();
}
inline const ::std::string& RegisterDataSourceResponse::error() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.RegisterDataSourceResponse.error)
  return error_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterDataSourceResponse::set_error(const ::std::string& value) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.RegisterDataSourceResponse.error)
}
inline void RegisterDataSourceResponse::set_error(const char* value) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.RegisterDataSourceResponse.error)
}
inline void RegisterDataSourceResponse::set_error(const char* value, size_t size) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.RegisterDataSourceResponse.error)
}
inline ::std::string* RegisterDataSourceResponse::mutable_error() {
  set_has_error();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.RegisterDataSourceResponse.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegisterDataSourceResponse::release_error() {
  // @@protoc_insertion_point(field_release:perfetto.protos.RegisterDataSourceResponse.error)
  clear_has_error();
  return error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterDataSourceResponse::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    set_has_error();
  } else {
    clear_has_error();
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.RegisterDataSourceResponse.error)
}

// -------------------------------------------------------------------

// UnregisterDataSourceRequest

// optional string data_source_name = 1;
inline bool UnregisterDataSourceRequest::has_data_source_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnregisterDataSourceRequest::set_has_data_source_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnregisterDataSourceRequest::clear_has_data_source_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnregisterDataSourceRequest::clear_data_source_name() {
  data_source_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data_source_name();
}
inline const ::std::string& UnregisterDataSourceRequest::data_source_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.UnregisterDataSourceRequest.data_source_name)
  return data_source_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UnregisterDataSourceRequest::set_data_source_name(const ::std::string& value) {
  set_has_data_source_name();
  data_source_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.UnregisterDataSourceRequest.data_source_name)
}
inline void UnregisterDataSourceRequest::set_data_source_name(const char* value) {
  set_has_data_source_name();
  data_source_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.UnregisterDataSourceRequest.data_source_name)
}
inline void UnregisterDataSourceRequest::set_data_source_name(const char* value, size_t size) {
  set_has_data_source_name();
  data_source_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.UnregisterDataSourceRequest.data_source_name)
}
inline ::std::string* UnregisterDataSourceRequest::mutable_data_source_name() {
  set_has_data_source_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.UnregisterDataSourceRequest.data_source_name)
  return data_source_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UnregisterDataSourceRequest::release_data_source_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.UnregisterDataSourceRequest.data_source_name)
  clear_has_data_source_name();
  return data_source_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UnregisterDataSourceRequest::set_allocated_data_source_name(::std::string* data_source_name) {
  if (data_source_name != NULL) {
    set_has_data_source_name();
  } else {
    clear_has_data_source_name();
  }
  data_source_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data_source_name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.UnregisterDataSourceRequest.data_source_name)
}

// -------------------------------------------------------------------

// UnregisterDataSourceResponse

// -------------------------------------------------------------------

// RegisterTraceWriterRequest

// optional uint32 trace_writer_id = 1;
inline bool RegisterTraceWriterRequest::has_trace_writer_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterTraceWriterRequest::set_has_trace_writer_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterTraceWriterRequest::clear_has_trace_writer_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterTraceWriterRequest::clear_trace_writer_id() {
  trace_writer_id_ = 0u;
  clear_has_trace_writer_id();
}
inline ::google::protobuf::uint32 RegisterTraceWriterRequest::trace_writer_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.RegisterTraceWriterRequest.trace_writer_id)
  return trace_writer_id_;
}
inline void RegisterTraceWriterRequest::set_trace_writer_id(::google::protobuf::uint32 value) {
  set_has_trace_writer_id();
  trace_writer_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.RegisterTraceWriterRequest.trace_writer_id)
}

// optional uint32 target_buffer = 2;
inline bool RegisterTraceWriterRequest::has_target_buffer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegisterTraceWriterRequest::set_has_target_buffer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegisterTraceWriterRequest::clear_has_target_buffer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegisterTraceWriterRequest::clear_target_buffer() {
  target_buffer_ = 0u;
  clear_has_target_buffer();
}
inline ::google::protobuf::uint32 RegisterTraceWriterRequest::target_buffer() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.RegisterTraceWriterRequest.target_buffer)
  return target_buffer_;
}
inline void RegisterTraceWriterRequest::set_target_buffer(::google::protobuf::uint32 value) {
  set_has_target_buffer();
  target_buffer_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.RegisterTraceWriterRequest.target_buffer)
}

// -------------------------------------------------------------------

// RegisterTraceWriterResponse

// -------------------------------------------------------------------

// UnregisterTraceWriterRequest

// optional uint32 trace_writer_id = 1;
inline bool UnregisterTraceWriterRequest::has_trace_writer_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnregisterTraceWriterRequest::set_has_trace_writer_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnregisterTraceWriterRequest::clear_has_trace_writer_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnregisterTraceWriterRequest::clear_trace_writer_id() {
  trace_writer_id_ = 0u;
  clear_has_trace_writer_id();
}
inline ::google::protobuf::uint32 UnregisterTraceWriterRequest::trace_writer_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.UnregisterTraceWriterRequest.trace_writer_id)
  return trace_writer_id_;
}
inline void UnregisterTraceWriterRequest::set_trace_writer_id(::google::protobuf::uint32 value) {
  set_has_trace_writer_id();
  trace_writer_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.UnregisterTraceWriterRequest.trace_writer_id)
}

// -------------------------------------------------------------------

// UnregisterTraceWriterResponse

// -------------------------------------------------------------------

// CommitDataResponse

// -------------------------------------------------------------------

// NotifyDataSourceStartedRequest

// optional uint64 data_source_id = 1;
inline bool NotifyDataSourceStartedRequest::has_data_source_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NotifyDataSourceStartedRequest::set_has_data_source_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NotifyDataSourceStartedRequest::clear_has_data_source_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NotifyDataSourceStartedRequest::clear_data_source_id() {
  data_source_id_ = GOOGLE_ULONGLONG(0);
  clear_has_data_source_id();
}
inline ::google::protobuf::uint64 NotifyDataSourceStartedRequest::data_source_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.NotifyDataSourceStartedRequest.data_source_id)
  return data_source_id_;
}
inline void NotifyDataSourceStartedRequest::set_data_source_id(::google::protobuf::uint64 value) {
  set_has_data_source_id();
  data_source_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.NotifyDataSourceStartedRequest.data_source_id)
}

// -------------------------------------------------------------------

// NotifyDataSourceStartedResponse

// -------------------------------------------------------------------

// NotifyDataSourceStoppedRequest

// optional uint64 data_source_id = 1;
inline bool NotifyDataSourceStoppedRequest::has_data_source_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NotifyDataSourceStoppedRequest::set_has_data_source_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NotifyDataSourceStoppedRequest::clear_has_data_source_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NotifyDataSourceStoppedRequest::clear_data_source_id() {
  data_source_id_ = GOOGLE_ULONGLONG(0);
  clear_has_data_source_id();
}
inline ::google::protobuf::uint64 NotifyDataSourceStoppedRequest::data_source_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.NotifyDataSourceStoppedRequest.data_source_id)
  return data_source_id_;
}
inline void NotifyDataSourceStoppedRequest::set_data_source_id(::google::protobuf::uint64 value) {
  set_has_data_source_id();
  data_source_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.NotifyDataSourceStoppedRequest.data_source_id)
}

// -------------------------------------------------------------------

// NotifyDataSourceStoppedResponse

// -------------------------------------------------------------------

// ActivateTriggersRequest

// repeated string trigger_names = 1;
inline int ActivateTriggersRequest::trigger_names_size() const {
  return trigger_names_.size();
}
inline void ActivateTriggersRequest::clear_trigger_names() {
  trigger_names_.Clear();
}
inline const ::std::string& ActivateTriggersRequest::trigger_names(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ActivateTriggersRequest.trigger_names)
  return trigger_names_.Get(index);
}
inline ::std::string* ActivateTriggersRequest::mutable_trigger_names(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.ActivateTriggersRequest.trigger_names)
  return trigger_names_.Mutable(index);
}
inline void ActivateTriggersRequest::set_trigger_names(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.ActivateTriggersRequest.trigger_names)
  trigger_names_.Mutable(index)->assign(value);
}
inline void ActivateTriggersRequest::set_trigger_names(int index, const char* value) {
  trigger_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.ActivateTriggersRequest.trigger_names)
}
inline void ActivateTriggersRequest::set_trigger_names(int index, const char* value, size_t size) {
  trigger_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.ActivateTriggersRequest.trigger_names)
}
inline ::std::string* ActivateTriggersRequest::add_trigger_names() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.ActivateTriggersRequest.trigger_names)
  return trigger_names_.Add();
}
inline void ActivateTriggersRequest::add_trigger_names(const ::std::string& value) {
  trigger_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.ActivateTriggersRequest.trigger_names)
}
inline void ActivateTriggersRequest::add_trigger_names(const char* value) {
  trigger_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.ActivateTriggersRequest.trigger_names)
}
inline void ActivateTriggersRequest::add_trigger_names(const char* value, size_t size) {
  trigger_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.ActivateTriggersRequest.trigger_names)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ActivateTriggersRequest::trigger_names() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.ActivateTriggersRequest.trigger_names)
  return trigger_names_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ActivateTriggersRequest::mutable_trigger_names() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.ActivateTriggersRequest.trigger_names)
  return &trigger_names_;
}

// -------------------------------------------------------------------

// ActivateTriggersResponse

// -------------------------------------------------------------------

// GetAsyncCommandRequest

// -------------------------------------------------------------------

// GetAsyncCommandResponse_SetupDataSource

// optional uint64 new_instance_id = 1;
inline bool GetAsyncCommandResponse_SetupDataSource::has_new_instance_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetAsyncCommandResponse_SetupDataSource::set_has_new_instance_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetAsyncCommandResponse_SetupDataSource::clear_has_new_instance_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetAsyncCommandResponse_SetupDataSource::clear_new_instance_id() {
  new_instance_id_ = GOOGLE_ULONGLONG(0);
  clear_has_new_instance_id();
}
inline ::google::protobuf::uint64 GetAsyncCommandResponse_SetupDataSource::new_instance_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.SetupDataSource.new_instance_id)
  return new_instance_id_;
}
inline void GetAsyncCommandResponse_SetupDataSource::set_new_instance_id(::google::protobuf::uint64 value) {
  set_has_new_instance_id();
  new_instance_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.GetAsyncCommandResponse.SetupDataSource.new_instance_id)
}

// optional .perfetto.protos.DataSourceConfig config = 2;
inline bool GetAsyncCommandResponse_SetupDataSource::has_config() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetAsyncCommandResponse_SetupDataSource::set_has_config() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetAsyncCommandResponse_SetupDataSource::clear_has_config() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetAsyncCommandResponse_SetupDataSource::clear_config() {
  if (config_ != NULL) config_->::perfetto::protos::DataSourceConfig::Clear();
  clear_has_config();
}
inline const ::perfetto::protos::DataSourceConfig& GetAsyncCommandResponse_SetupDataSource::config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.SetupDataSource.config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return config_ != NULL ? *config_ : *default_instance().config_;
#else
  return config_ != NULL ? *config_ : *default_instance_->config_;
#endif
}
inline ::perfetto::protos::DataSourceConfig* GetAsyncCommandResponse_SetupDataSource::mutable_config() {
  set_has_config();
  if (config_ == NULL) {
    config_ = new ::perfetto::protos::DataSourceConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GetAsyncCommandResponse.SetupDataSource.config)
  return config_;
}
inline ::perfetto::protos::DataSourceConfig* GetAsyncCommandResponse_SetupDataSource::release_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.GetAsyncCommandResponse.SetupDataSource.config)
  clear_has_config();
  ::perfetto::protos::DataSourceConfig* temp = config_;
  config_ = NULL;
  return temp;
}
inline void GetAsyncCommandResponse_SetupDataSource::set_allocated_config(::perfetto::protos::DataSourceConfig* config) {
  delete config_;
  config_ = config;
  if (config) {
    set_has_config();
  } else {
    clear_has_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.GetAsyncCommandResponse.SetupDataSource.config)
}

// -------------------------------------------------------------------

// GetAsyncCommandResponse_StartDataSource

// optional uint64 new_instance_id = 1;
inline bool GetAsyncCommandResponse_StartDataSource::has_new_instance_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetAsyncCommandResponse_StartDataSource::set_has_new_instance_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetAsyncCommandResponse_StartDataSource::clear_has_new_instance_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetAsyncCommandResponse_StartDataSource::clear_new_instance_id() {
  new_instance_id_ = GOOGLE_ULONGLONG(0);
  clear_has_new_instance_id();
}
inline ::google::protobuf::uint64 GetAsyncCommandResponse_StartDataSource::new_instance_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.StartDataSource.new_instance_id)
  return new_instance_id_;
}
inline void GetAsyncCommandResponse_StartDataSource::set_new_instance_id(::google::protobuf::uint64 value) {
  set_has_new_instance_id();
  new_instance_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.GetAsyncCommandResponse.StartDataSource.new_instance_id)
}

// optional .perfetto.protos.DataSourceConfig config = 2;
inline bool GetAsyncCommandResponse_StartDataSource::has_config() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetAsyncCommandResponse_StartDataSource::set_has_config() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetAsyncCommandResponse_StartDataSource::clear_has_config() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetAsyncCommandResponse_StartDataSource::clear_config() {
  if (config_ != NULL) config_->::perfetto::protos::DataSourceConfig::Clear();
  clear_has_config();
}
inline const ::perfetto::protos::DataSourceConfig& GetAsyncCommandResponse_StartDataSource::config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.StartDataSource.config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return config_ != NULL ? *config_ : *default_instance().config_;
#else
  return config_ != NULL ? *config_ : *default_instance_->config_;
#endif
}
inline ::perfetto::protos::DataSourceConfig* GetAsyncCommandResponse_StartDataSource::mutable_config() {
  set_has_config();
  if (config_ == NULL) {
    config_ = new ::perfetto::protos::DataSourceConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GetAsyncCommandResponse.StartDataSource.config)
  return config_;
}
inline ::perfetto::protos::DataSourceConfig* GetAsyncCommandResponse_StartDataSource::release_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.GetAsyncCommandResponse.StartDataSource.config)
  clear_has_config();
  ::perfetto::protos::DataSourceConfig* temp = config_;
  config_ = NULL;
  return temp;
}
inline void GetAsyncCommandResponse_StartDataSource::set_allocated_config(::perfetto::protos::DataSourceConfig* config) {
  delete config_;
  config_ = config;
  if (config) {
    set_has_config();
  } else {
    clear_has_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.GetAsyncCommandResponse.StartDataSource.config)
}

// -------------------------------------------------------------------

// GetAsyncCommandResponse_StopDataSource

// optional uint64 instance_id = 1;
inline bool GetAsyncCommandResponse_StopDataSource::has_instance_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetAsyncCommandResponse_StopDataSource::set_has_instance_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetAsyncCommandResponse_StopDataSource::clear_has_instance_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetAsyncCommandResponse_StopDataSource::clear_instance_id() {
  instance_id_ = GOOGLE_ULONGLONG(0);
  clear_has_instance_id();
}
inline ::google::protobuf::uint64 GetAsyncCommandResponse_StopDataSource::instance_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.StopDataSource.instance_id)
  return instance_id_;
}
inline void GetAsyncCommandResponse_StopDataSource::set_instance_id(::google::protobuf::uint64 value) {
  set_has_instance_id();
  instance_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.GetAsyncCommandResponse.StopDataSource.instance_id)
}

// -------------------------------------------------------------------

// GetAsyncCommandResponse_SetupTracing

// optional uint32 shared_buffer_page_size_kb = 1;
inline bool GetAsyncCommandResponse_SetupTracing::has_shared_buffer_page_size_kb() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetAsyncCommandResponse_SetupTracing::set_has_shared_buffer_page_size_kb() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetAsyncCommandResponse_SetupTracing::clear_has_shared_buffer_page_size_kb() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetAsyncCommandResponse_SetupTracing::clear_shared_buffer_page_size_kb() {
  shared_buffer_page_size_kb_ = 0u;
  clear_has_shared_buffer_page_size_kb();
}
inline ::google::protobuf::uint32 GetAsyncCommandResponse_SetupTracing::shared_buffer_page_size_kb() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.SetupTracing.shared_buffer_page_size_kb)
  return shared_buffer_page_size_kb_;
}
inline void GetAsyncCommandResponse_SetupTracing::set_shared_buffer_page_size_kb(::google::protobuf::uint32 value) {
  set_has_shared_buffer_page_size_kb();
  shared_buffer_page_size_kb_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.GetAsyncCommandResponse.SetupTracing.shared_buffer_page_size_kb)
}

// -------------------------------------------------------------------

// GetAsyncCommandResponse_Flush

// repeated uint64 data_source_ids = 1;
inline int GetAsyncCommandResponse_Flush::data_source_ids_size() const {
  return data_source_ids_.size();
}
inline void GetAsyncCommandResponse_Flush::clear_data_source_ids() {
  data_source_ids_.Clear();
}
inline ::google::protobuf::uint64 GetAsyncCommandResponse_Flush::data_source_ids(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.Flush.data_source_ids)
  return data_source_ids_.Get(index);
}
inline void GetAsyncCommandResponse_Flush::set_data_source_ids(int index, ::google::protobuf::uint64 value) {
  data_source_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.GetAsyncCommandResponse.Flush.data_source_ids)
}
inline void GetAsyncCommandResponse_Flush::add_data_source_ids(::google::protobuf::uint64 value) {
  data_source_ids_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.GetAsyncCommandResponse.Flush.data_source_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
GetAsyncCommandResponse_Flush::data_source_ids() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.GetAsyncCommandResponse.Flush.data_source_ids)
  return data_source_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
GetAsyncCommandResponse_Flush::mutable_data_source_ids() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.GetAsyncCommandResponse.Flush.data_source_ids)
  return &data_source_ids_;
}

// optional uint64 request_id = 2;
inline bool GetAsyncCommandResponse_Flush::has_request_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetAsyncCommandResponse_Flush::set_has_request_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetAsyncCommandResponse_Flush::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetAsyncCommandResponse_Flush::clear_request_id() {
  request_id_ = GOOGLE_ULONGLONG(0);
  clear_has_request_id();
}
inline ::google::protobuf::uint64 GetAsyncCommandResponse_Flush::request_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.Flush.request_id)
  return request_id_;
}
inline void GetAsyncCommandResponse_Flush::set_request_id(::google::protobuf::uint64 value) {
  set_has_request_id();
  request_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.GetAsyncCommandResponse.Flush.request_id)
}

// -------------------------------------------------------------------

// GetAsyncCommandResponse_ClearIncrementalState

// repeated uint64 data_source_ids = 1;
inline int GetAsyncCommandResponse_ClearIncrementalState::data_source_ids_size() const {
  return data_source_ids_.size();
}
inline void GetAsyncCommandResponse_ClearIncrementalState::clear_data_source_ids() {
  data_source_ids_.Clear();
}
inline ::google::protobuf::uint64 GetAsyncCommandResponse_ClearIncrementalState::data_source_ids(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.ClearIncrementalState.data_source_ids)
  return data_source_ids_.Get(index);
}
inline void GetAsyncCommandResponse_ClearIncrementalState::set_data_source_ids(int index, ::google::protobuf::uint64 value) {
  data_source_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.GetAsyncCommandResponse.ClearIncrementalState.data_source_ids)
}
inline void GetAsyncCommandResponse_ClearIncrementalState::add_data_source_ids(::google::protobuf::uint64 value) {
  data_source_ids_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.GetAsyncCommandResponse.ClearIncrementalState.data_source_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
GetAsyncCommandResponse_ClearIncrementalState::data_source_ids() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.GetAsyncCommandResponse.ClearIncrementalState.data_source_ids)
  return data_source_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
GetAsyncCommandResponse_ClearIncrementalState::mutable_data_source_ids() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.GetAsyncCommandResponse.ClearIncrementalState.data_source_ids)
  return &data_source_ids_;
}

// -------------------------------------------------------------------

// GetAsyncCommandResponse

// optional .perfetto.protos.GetAsyncCommandResponse.SetupTracing setup_tracing = 3;
inline bool GetAsyncCommandResponse::has_setup_tracing() const {
  return cmd_case() == kSetupTracing;
}
inline void GetAsyncCommandResponse::set_has_setup_tracing() {
  _oneof_case_[0] = kSetupTracing;
}
inline void GetAsyncCommandResponse::clear_setup_tracing() {
  if (has_setup_tracing()) {
    delete cmd_.setup_tracing_;
    clear_has_cmd();
  }
}
inline  const ::perfetto::protos::GetAsyncCommandResponse_SetupTracing& GetAsyncCommandResponse::setup_tracing() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.setup_tracing)
  return has_setup_tracing()
      ? *cmd_.setup_tracing_
      : ::perfetto::protos::GetAsyncCommandResponse_SetupTracing::default_instance();
}
inline ::perfetto::protos::GetAsyncCommandResponse_SetupTracing* GetAsyncCommandResponse::mutable_setup_tracing() {
  if (!has_setup_tracing()) {
    clear_cmd();
    set_has_setup_tracing();
    cmd_.setup_tracing_ = new ::perfetto::protos::GetAsyncCommandResponse_SetupTracing;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GetAsyncCommandResponse.setup_tracing)
  return cmd_.setup_tracing_;
}
inline ::perfetto::protos::GetAsyncCommandResponse_SetupTracing* GetAsyncCommandResponse::release_setup_tracing() {
  // @@protoc_insertion_point(field_release:perfetto.protos.GetAsyncCommandResponse.setup_tracing)
  if (has_setup_tracing()) {
    clear_has_cmd();
    ::perfetto::protos::GetAsyncCommandResponse_SetupTracing* temp = cmd_.setup_tracing_;
    cmd_.setup_tracing_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GetAsyncCommandResponse::set_allocated_setup_tracing(::perfetto::protos::GetAsyncCommandResponse_SetupTracing* setup_tracing) {
  clear_cmd();
  if (setup_tracing) {
    set_has_setup_tracing();
    cmd_.setup_tracing_ = setup_tracing;
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.GetAsyncCommandResponse.setup_tracing)
}

// optional .perfetto.protos.GetAsyncCommandResponse.SetupDataSource setup_data_source = 6;
inline bool GetAsyncCommandResponse::has_setup_data_source() const {
  return cmd_case() == kSetupDataSource;
}
inline void GetAsyncCommandResponse::set_has_setup_data_source() {
  _oneof_case_[0] = kSetupDataSource;
}
inline void GetAsyncCommandResponse::clear_setup_data_source() {
  if (has_setup_data_source()) {
    delete cmd_.setup_data_source_;
    clear_has_cmd();
  }
}
inline  const ::perfetto::protos::GetAsyncCommandResponse_SetupDataSource& GetAsyncCommandResponse::setup_data_source() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.setup_data_source)
  return has_setup_data_source()
      ? *cmd_.setup_data_source_
      : ::perfetto::protos::GetAsyncCommandResponse_SetupDataSource::default_instance();
}
inline ::perfetto::protos::GetAsyncCommandResponse_SetupDataSource* GetAsyncCommandResponse::mutable_setup_data_source() {
  if (!has_setup_data_source()) {
    clear_cmd();
    set_has_setup_data_source();
    cmd_.setup_data_source_ = new ::perfetto::protos::GetAsyncCommandResponse_SetupDataSource;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GetAsyncCommandResponse.setup_data_source)
  return cmd_.setup_data_source_;
}
inline ::perfetto::protos::GetAsyncCommandResponse_SetupDataSource* GetAsyncCommandResponse::release_setup_data_source() {
  // @@protoc_insertion_point(field_release:perfetto.protos.GetAsyncCommandResponse.setup_data_source)
  if (has_setup_data_source()) {
    clear_has_cmd();
    ::perfetto::protos::GetAsyncCommandResponse_SetupDataSource* temp = cmd_.setup_data_source_;
    cmd_.setup_data_source_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GetAsyncCommandResponse::set_allocated_setup_data_source(::perfetto::protos::GetAsyncCommandResponse_SetupDataSource* setup_data_source) {
  clear_cmd();
  if (setup_data_source) {
    set_has_setup_data_source();
    cmd_.setup_data_source_ = setup_data_source;
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.GetAsyncCommandResponse.setup_data_source)
}

// optional .perfetto.protos.GetAsyncCommandResponse.StartDataSource start_data_source = 1;
inline bool GetAsyncCommandResponse::has_start_data_source() const {
  return cmd_case() == kStartDataSource;
}
inline void GetAsyncCommandResponse::set_has_start_data_source() {
  _oneof_case_[0] = kStartDataSource;
}
inline void GetAsyncCommandResponse::clear_start_data_source() {
  if (has_start_data_source()) {
    delete cmd_.start_data_source_;
    clear_has_cmd();
  }
}
inline  const ::perfetto::protos::GetAsyncCommandResponse_StartDataSource& GetAsyncCommandResponse::start_data_source() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.start_data_source)
  return has_start_data_source()
      ? *cmd_.start_data_source_
      : ::perfetto::protos::GetAsyncCommandResponse_StartDataSource::default_instance();
}
inline ::perfetto::protos::GetAsyncCommandResponse_StartDataSource* GetAsyncCommandResponse::mutable_start_data_source() {
  if (!has_start_data_source()) {
    clear_cmd();
    set_has_start_data_source();
    cmd_.start_data_source_ = new ::perfetto::protos::GetAsyncCommandResponse_StartDataSource;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GetAsyncCommandResponse.start_data_source)
  return cmd_.start_data_source_;
}
inline ::perfetto::protos::GetAsyncCommandResponse_StartDataSource* GetAsyncCommandResponse::release_start_data_source() {
  // @@protoc_insertion_point(field_release:perfetto.protos.GetAsyncCommandResponse.start_data_source)
  if (has_start_data_source()) {
    clear_has_cmd();
    ::perfetto::protos::GetAsyncCommandResponse_StartDataSource* temp = cmd_.start_data_source_;
    cmd_.start_data_source_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GetAsyncCommandResponse::set_allocated_start_data_source(::perfetto::protos::GetAsyncCommandResponse_StartDataSource* start_data_source) {
  clear_cmd();
  if (start_data_source) {
    set_has_start_data_source();
    cmd_.start_data_source_ = start_data_source;
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.GetAsyncCommandResponse.start_data_source)
}

// optional .perfetto.protos.GetAsyncCommandResponse.StopDataSource stop_data_source = 2;
inline bool GetAsyncCommandResponse::has_stop_data_source() const {
  return cmd_case() == kStopDataSource;
}
inline void GetAsyncCommandResponse::set_has_stop_data_source() {
  _oneof_case_[0] = kStopDataSource;
}
inline void GetAsyncCommandResponse::clear_stop_data_source() {
  if (has_stop_data_source()) {
    delete cmd_.stop_data_source_;
    clear_has_cmd();
  }
}
inline  const ::perfetto::protos::GetAsyncCommandResponse_StopDataSource& GetAsyncCommandResponse::stop_data_source() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.stop_data_source)
  return has_stop_data_source()
      ? *cmd_.stop_data_source_
      : ::perfetto::protos::GetAsyncCommandResponse_StopDataSource::default_instance();
}
inline ::perfetto::protos::GetAsyncCommandResponse_StopDataSource* GetAsyncCommandResponse::mutable_stop_data_source() {
  if (!has_stop_data_source()) {
    clear_cmd();
    set_has_stop_data_source();
    cmd_.stop_data_source_ = new ::perfetto::protos::GetAsyncCommandResponse_StopDataSource;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GetAsyncCommandResponse.stop_data_source)
  return cmd_.stop_data_source_;
}
inline ::perfetto::protos::GetAsyncCommandResponse_StopDataSource* GetAsyncCommandResponse::release_stop_data_source() {
  // @@protoc_insertion_point(field_release:perfetto.protos.GetAsyncCommandResponse.stop_data_source)
  if (has_stop_data_source()) {
    clear_has_cmd();
    ::perfetto::protos::GetAsyncCommandResponse_StopDataSource* temp = cmd_.stop_data_source_;
    cmd_.stop_data_source_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GetAsyncCommandResponse::set_allocated_stop_data_source(::perfetto::protos::GetAsyncCommandResponse_StopDataSource* stop_data_source) {
  clear_cmd();
  if (stop_data_source) {
    set_has_stop_data_source();
    cmd_.stop_data_source_ = stop_data_source;
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.GetAsyncCommandResponse.stop_data_source)
}

// optional .perfetto.protos.GetAsyncCommandResponse.Flush flush = 5;
inline bool GetAsyncCommandResponse::has_flush() const {
  return cmd_case() == kFlush;
}
inline void GetAsyncCommandResponse::set_has_flush() {
  _oneof_case_[0] = kFlush;
}
inline void GetAsyncCommandResponse::clear_flush() {
  if (has_flush()) {
    delete cmd_.flush_;
    clear_has_cmd();
  }
}
inline  const ::perfetto::protos::GetAsyncCommandResponse_Flush& GetAsyncCommandResponse::flush() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.flush)
  return has_flush()
      ? *cmd_.flush_
      : ::perfetto::protos::GetAsyncCommandResponse_Flush::default_instance();
}
inline ::perfetto::protos::GetAsyncCommandResponse_Flush* GetAsyncCommandResponse::mutable_flush() {
  if (!has_flush()) {
    clear_cmd();
    set_has_flush();
    cmd_.flush_ = new ::perfetto::protos::GetAsyncCommandResponse_Flush;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GetAsyncCommandResponse.flush)
  return cmd_.flush_;
}
inline ::perfetto::protos::GetAsyncCommandResponse_Flush* GetAsyncCommandResponse::release_flush() {
  // @@protoc_insertion_point(field_release:perfetto.protos.GetAsyncCommandResponse.flush)
  if (has_flush()) {
    clear_has_cmd();
    ::perfetto::protos::GetAsyncCommandResponse_Flush* temp = cmd_.flush_;
    cmd_.flush_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GetAsyncCommandResponse::set_allocated_flush(::perfetto::protos::GetAsyncCommandResponse_Flush* flush) {
  clear_cmd();
  if (flush) {
    set_has_flush();
    cmd_.flush_ = flush;
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.GetAsyncCommandResponse.flush)
}

// optional .perfetto.protos.GetAsyncCommandResponse.ClearIncrementalState clear_incremental_state = 7;
inline bool GetAsyncCommandResponse::has_clear_incremental_state() const {
  return cmd_case() == kClearIncrementalState;
}
inline void GetAsyncCommandResponse::set_has_clear_incremental_state() {
  _oneof_case_[0] = kClearIncrementalState;
}
inline void GetAsyncCommandResponse::clear_clear_incremental_state() {
  if (has_clear_incremental_state()) {
    delete cmd_.clear_incremental_state_;
    clear_has_cmd();
  }
}
inline  const ::perfetto::protos::GetAsyncCommandResponse_ClearIncrementalState& GetAsyncCommandResponse::clear_incremental_state() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.clear_incremental_state)
  return has_clear_incremental_state()
      ? *cmd_.clear_incremental_state_
      : ::perfetto::protos::GetAsyncCommandResponse_ClearIncrementalState::default_instance();
}
inline ::perfetto::protos::GetAsyncCommandResponse_ClearIncrementalState* GetAsyncCommandResponse::mutable_clear_incremental_state() {
  if (!has_clear_incremental_state()) {
    clear_cmd();
    set_has_clear_incremental_state();
    cmd_.clear_incremental_state_ = new ::perfetto::protos::GetAsyncCommandResponse_ClearIncrementalState;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GetAsyncCommandResponse.clear_incremental_state)
  return cmd_.clear_incremental_state_;
}
inline ::perfetto::protos::GetAsyncCommandResponse_ClearIncrementalState* GetAsyncCommandResponse::release_clear_incremental_state() {
  // @@protoc_insertion_point(field_release:perfetto.protos.GetAsyncCommandResponse.clear_incremental_state)
  if (has_clear_incremental_state()) {
    clear_has_cmd();
    ::perfetto::protos::GetAsyncCommandResponse_ClearIncrementalState* temp = cmd_.clear_incremental_state_;
    cmd_.clear_incremental_state_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GetAsyncCommandResponse::set_allocated_clear_incremental_state(::perfetto::protos::GetAsyncCommandResponse_ClearIncrementalState* clear_incremental_state) {
  clear_cmd();
  if (clear_incremental_state) {
    set_has_clear_incremental_state();
    cmd_.clear_incremental_state_ = clear_incremental_state;
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.GetAsyncCommandResponse.clear_incremental_state)
}

inline bool GetAsyncCommandResponse::has_cmd() const {
  return cmd_case() != CMD_NOT_SET;
}
inline void GetAsyncCommandResponse::clear_has_cmd() {
  _oneof_case_[0] = CMD_NOT_SET;
}
inline GetAsyncCommandResponse::CmdCase GetAsyncCommandResponse::cmd_case() const {
  return GetAsyncCommandResponse::CmdCase(_oneof_case_[0]);
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::perfetto::protos::InitializeConnectionRequest_ProducerSMBScrapingMode> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_perfetto_2fipc_2fproducer_5fport_2eproto__INCLUDED
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/ipc/producer_port.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
// gen_amalgamated expanded: #include "perfetto/ipc/producer_port.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

void protobuf_ShutdownFile_perfetto_2fipc_2fproducer_5fport_2eproto() {
  delete InitializeConnectionRequest::default_instance_;
  delete InitializeConnectionResponse::default_instance_;
  delete RegisterDataSourceRequest::default_instance_;
  delete RegisterDataSourceResponse::default_instance_;
  delete UnregisterDataSourceRequest::default_instance_;
  delete UnregisterDataSourceResponse::default_instance_;
  delete RegisterTraceWriterRequest::default_instance_;
  delete RegisterTraceWriterResponse::default_instance_;
  delete UnregisterTraceWriterRequest::default_instance_;
  delete UnregisterTraceWriterResponse::default_instance_;
  delete CommitDataResponse::default_instance_;
  delete NotifyDataSourceStartedRequest::default_instance_;
  delete NotifyDataSourceStartedResponse::default_instance_;
  delete NotifyDataSourceStoppedRequest::default_instance_;
  delete NotifyDataSourceStoppedResponse::default_instance_;
  delete ActivateTriggersRequest::default_instance_;
  delete ActivateTriggersResponse::default_instance_;
  delete GetAsyncCommandRequest::default_instance_;
  delete GetAsyncCommandResponse::default_instance_;
  delete GetAsyncCommandResponse_SetupDataSource::default_instance_;
  delete GetAsyncCommandResponse_StartDataSource::default_instance_;
  delete GetAsyncCommandResponse_StopDataSource::default_instance_;
  delete GetAsyncCommandResponse_SetupTracing::default_instance_;
  delete GetAsyncCommandResponse_Flush::default_instance_;
  delete GetAsyncCommandResponse_ClearIncrementalState::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::perfetto::protos::protobuf_AddDesc_perfetto_2fcommon_2fcommit_5fdata_5frequest_2eproto();
  ::perfetto::protos::protobuf_AddDesc_perfetto_2fconfig_2fdata_5fsource_5fconfig_2eproto();
  ::perfetto::protos::protobuf_AddDesc_perfetto_2fcommon_2fdata_5fsource_5fdescriptor_2eproto();
  InitializeConnectionRequest::default_instance_ = new InitializeConnectionRequest();
  InitializeConnectionResponse::default_instance_ = new InitializeConnectionResponse();
  RegisterDataSourceRequest::default_instance_ = new RegisterDataSourceRequest();
  RegisterDataSourceResponse::default_instance_ = new RegisterDataSourceResponse();
  UnregisterDataSourceRequest::default_instance_ = new UnregisterDataSourceRequest();
  UnregisterDataSourceResponse::default_instance_ = new UnregisterDataSourceResponse();
  RegisterTraceWriterRequest::default_instance_ = new RegisterTraceWriterRequest();
  RegisterTraceWriterResponse::default_instance_ = new RegisterTraceWriterResponse();
  UnregisterTraceWriterRequest::default_instance_ = new UnregisterTraceWriterRequest();
  UnregisterTraceWriterResponse::default_instance_ = new UnregisterTraceWriterResponse();
  CommitDataResponse::default_instance_ = new CommitDataResponse();
  NotifyDataSourceStartedRequest::default_instance_ = new NotifyDataSourceStartedRequest();
  NotifyDataSourceStartedResponse::default_instance_ = new NotifyDataSourceStartedResponse();
  NotifyDataSourceStoppedRequest::default_instance_ = new NotifyDataSourceStoppedRequest();
  NotifyDataSourceStoppedResponse::default_instance_ = new NotifyDataSourceStoppedResponse();
  ActivateTriggersRequest::default_instance_ = new ActivateTriggersRequest();
  ActivateTriggersResponse::default_instance_ = new ActivateTriggersResponse();
  GetAsyncCommandRequest::default_instance_ = new GetAsyncCommandRequest();
  GetAsyncCommandResponse::default_instance_ = new GetAsyncCommandResponse();
  GetAsyncCommandResponse_SetupDataSource::default_instance_ = new GetAsyncCommandResponse_SetupDataSource();
  GetAsyncCommandResponse_StartDataSource::default_instance_ = new GetAsyncCommandResponse_StartDataSource();
  GetAsyncCommandResponse_StopDataSource::default_instance_ = new GetAsyncCommandResponse_StopDataSource();
  GetAsyncCommandResponse_SetupTracing::default_instance_ = new GetAsyncCommandResponse_SetupTracing();
  GetAsyncCommandResponse_Flush::default_instance_ = new GetAsyncCommandResponse_Flush();
  GetAsyncCommandResponse_ClearIncrementalState::default_instance_ = new GetAsyncCommandResponse_ClearIncrementalState();
  InitializeConnectionRequest::default_instance_->InitAsDefaultInstance();
  InitializeConnectionResponse::default_instance_->InitAsDefaultInstance();
  RegisterDataSourceRequest::default_instance_->InitAsDefaultInstance();
  RegisterDataSourceResponse::default_instance_->InitAsDefaultInstance();
  UnregisterDataSourceRequest::default_instance_->InitAsDefaultInstance();
  UnregisterDataSourceResponse::default_instance_->InitAsDefaultInstance();
  RegisterTraceWriterRequest::default_instance_->InitAsDefaultInstance();
  RegisterTraceWriterResponse::default_instance_->InitAsDefaultInstance();
  UnregisterTraceWriterRequest::default_instance_->InitAsDefaultInstance();
  UnregisterTraceWriterResponse::default_instance_->InitAsDefaultInstance();
  CommitDataResponse::default_instance_->InitAsDefaultInstance();
  NotifyDataSourceStartedRequest::default_instance_->InitAsDefaultInstance();
  NotifyDataSourceStartedResponse::default_instance_->InitAsDefaultInstance();
  NotifyDataSourceStoppedRequest::default_instance_->InitAsDefaultInstance();
  NotifyDataSourceStoppedResponse::default_instance_->InitAsDefaultInstance();
  ActivateTriggersRequest::default_instance_->InitAsDefaultInstance();
  ActivateTriggersResponse::default_instance_->InitAsDefaultInstance();
  GetAsyncCommandRequest::default_instance_->InitAsDefaultInstance();
  GetAsyncCommandResponse::default_instance_->InitAsDefaultInstance();
  GetAsyncCommandResponse_SetupDataSource::default_instance_->InitAsDefaultInstance();
  GetAsyncCommandResponse_StartDataSource::default_instance_->InitAsDefaultInstance();
  GetAsyncCommandResponse_StopDataSource::default_instance_->InitAsDefaultInstance();
  GetAsyncCommandResponse_SetupTracing::default_instance_->InitAsDefaultInstance();
  GetAsyncCommandResponse_Flush::default_instance_->InitAsDefaultInstance();
  GetAsyncCommandResponse_ClearIncrementalState::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_perfetto_2fipc_2fproducer_5fport_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto_once_);
void protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto_once_,
                 &protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_perfetto_2fipc_2fproducer_5fport_2eproto {
  StaticDescriptorInitializer_perfetto_2fipc_2fproducer_5fport_2eproto() {
    protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
  }
} static_descriptor_initializer_perfetto_2fipc_2fproducer_5fport_2eproto_;
#endif

namespace {

static void producer_port_pb_MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
static void producer_port_pb_MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

static ::std::string* MutableUnknownFieldsForInitializeConnectionRequest(
    InitializeConnectionRequest* ptr) {
  return ptr->mutable_unknown_fields();
}

bool InitializeConnectionRequest_ProducerSMBScrapingMode_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const InitializeConnectionRequest_ProducerSMBScrapingMode InitializeConnectionRequest::SMB_SCRAPING_UNSPECIFIED;
const InitializeConnectionRequest_ProducerSMBScrapingMode InitializeConnectionRequest::SMB_SCRAPING_ENABLED;
const InitializeConnectionRequest_ProducerSMBScrapingMode InitializeConnectionRequest::SMB_SCRAPING_DISABLED;
const InitializeConnectionRequest_ProducerSMBScrapingMode InitializeConnectionRequest::ProducerSMBScrapingMode_MIN;
const InitializeConnectionRequest_ProducerSMBScrapingMode InitializeConnectionRequest::ProducerSMBScrapingMode_MAX;
const int InitializeConnectionRequest::ProducerSMBScrapingMode_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int InitializeConnectionRequest::kSharedBufferPageSizeBytesFieldNumber;
const int InitializeConnectionRequest::kSharedMemorySizeHintBytesFieldNumber;
const int InitializeConnectionRequest::kProducerNameFieldNumber;
const int InitializeConnectionRequest::kSmbScrapingModeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

InitializeConnectionRequest::InitializeConnectionRequest()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.InitializeConnectionRequest)
}

void InitializeConnectionRequest::InitAsDefaultInstance() {
}

InitializeConnectionRequest::InitializeConnectionRequest(const InitializeConnectionRequest& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.InitializeConnectionRequest)
}

void InitializeConnectionRequest::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  shared_buffer_page_size_bytes_ = 0u;
  shared_memory_size_hint_bytes_ = 0u;
  producer_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  smb_scraping_mode_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

InitializeConnectionRequest::~InitializeConnectionRequest() {
  // @@protoc_insertion_point(destructor:perfetto.protos.InitializeConnectionRequest)
  SharedDtor();
}

void InitializeConnectionRequest::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  producer_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void InitializeConnectionRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const InitializeConnectionRequest& InitializeConnectionRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
#endif
  return *default_instance_;
}

InitializeConnectionRequest* InitializeConnectionRequest::default_instance_ = NULL;

InitializeConnectionRequest* InitializeConnectionRequest::New(::google::protobuf::Arena* arena) const {
  InitializeConnectionRequest* n = new InitializeConnectionRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void InitializeConnectionRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.InitializeConnectionRequest)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(InitializeConnectionRequest, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<InitializeConnectionRequest*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 15u) {
    ZR_(shared_buffer_page_size_bytes_, shared_memory_size_hint_bytes_);
    if (has_producer_name()) {
      producer_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    smb_scraping_mode_ = 0;
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool InitializeConnectionRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForInitializeConnectionRequest, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.InitializeConnectionRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 shared_buffer_page_size_bytes = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &shared_buffer_page_size_bytes_)));
          set_has_shared_buffer_page_size_bytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_shared_memory_size_hint_bytes;
        break;
      }

      // optional uint32 shared_memory_size_hint_bytes = 2;
      case 2: {
        if (tag == 16) {
         parse_shared_memory_size_hint_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &shared_memory_size_hint_bytes_)));
          set_has_shared_memory_size_hint_bytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_producer_name;
        break;
      }

      // optional string producer_name = 3;
      case 3: {
        if (tag == 26) {
         parse_producer_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_producer_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_smb_scraping_mode;
        break;
      }

      // optional .perfetto.protos.InitializeConnectionRequest.ProducerSMBScrapingMode smb_scraping_mode = 4;
      case 4: {
        if (tag == 32) {
         parse_smb_scraping_mode:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::perfetto::protos::InitializeConnectionRequest_ProducerSMBScrapingMode_IsValid(value)) {
            set_smb_scraping_mode(static_cast< ::perfetto::protos::InitializeConnectionRequest_ProducerSMBScrapingMode >(value));
          } else {
            unknown_fields_stream.WriteVarint32(32);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.InitializeConnectionRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.InitializeConnectionRequest)
  return false;
#undef DO_
}

void InitializeConnectionRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.InitializeConnectionRequest)
  // optional uint32 shared_buffer_page_size_bytes = 1;
  if (has_shared_buffer_page_size_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->shared_buffer_page_size_bytes(), output);
  }

  // optional uint32 shared_memory_size_hint_bytes = 2;
  if (has_shared_memory_size_hint_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->shared_memory_size_hint_bytes(), output);
  }

  // optional string producer_name = 3;
  if (has_producer_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->producer_name(), output);
  }

  // optional .perfetto.protos.InitializeConnectionRequest.ProducerSMBScrapingMode smb_scraping_mode = 4;
  if (has_smb_scraping_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->smb_scraping_mode(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.InitializeConnectionRequest)
}

int InitializeConnectionRequest::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.InitializeConnectionRequest)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 15u) {
    // optional uint32 shared_buffer_page_size_bytes = 1;
    if (has_shared_buffer_page_size_bytes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->shared_buffer_page_size_bytes());
    }

    // optional uint32 shared_memory_size_hint_bytes = 2;
    if (has_shared_memory_size_hint_bytes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->shared_memory_size_hint_bytes());
    }

    // optional string producer_name = 3;
    if (has_producer_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->producer_name());
    }

    // optional .perfetto.protos.InitializeConnectionRequest.ProducerSMBScrapingMode smb_scraping_mode = 4;
    if (has_smb_scraping_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->smb_scraping_mode());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void InitializeConnectionRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const InitializeConnectionRequest*>(&from));
}

void InitializeConnectionRequest::MergeFrom(const InitializeConnectionRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.InitializeConnectionRequest)
  if (GOOGLE_PREDICT_FALSE(&from == this)) producer_port_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_shared_buffer_page_size_bytes()) {
      set_shared_buffer_page_size_bytes(from.shared_buffer_page_size_bytes());
    }
    if (from.has_shared_memory_size_hint_bytes()) {
      set_shared_memory_size_hint_bytes(from.shared_memory_size_hint_bytes());
    }
    if (from.has_producer_name()) {
      set_has_producer_name();
      producer_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.producer_name_);
    }
    if (from.has_smb_scraping_mode()) {
      set_smb_scraping_mode(from.smb_scraping_mode());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void InitializeConnectionRequest::CopyFrom(const InitializeConnectionRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.InitializeConnectionRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InitializeConnectionRequest::IsInitialized() const {

  return true;
}

void InitializeConnectionRequest::Swap(InitializeConnectionRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void InitializeConnectionRequest::InternalSwap(InitializeConnectionRequest* other) {
  std::swap(shared_buffer_page_size_bytes_, other->shared_buffer_page_size_bytes_);
  std::swap(shared_memory_size_hint_bytes_, other->shared_memory_size_hint_bytes_);
  producer_name_.Swap(&other->producer_name_);
  std::swap(smb_scraping_mode_, other->smb_scraping_mode_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string InitializeConnectionRequest::GetTypeName() const {
  return "perfetto.protos.InitializeConnectionRequest";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// InitializeConnectionRequest

// optional uint32 shared_buffer_page_size_bytes = 1;
bool InitializeConnectionRequest::has_shared_buffer_page_size_bytes() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void InitializeConnectionRequest::set_has_shared_buffer_page_size_bytes() {
  _has_bits_[0] |= 0x00000001u;
}
void InitializeConnectionRequest::clear_has_shared_buffer_page_size_bytes() {
  _has_bits_[0] &= ~0x00000001u;
}
void InitializeConnectionRequest::clear_shared_buffer_page_size_bytes() {
  shared_buffer_page_size_bytes_ = 0u;
  clear_has_shared_buffer_page_size_bytes();
}
 ::google::protobuf::uint32 InitializeConnectionRequest::shared_buffer_page_size_bytes() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InitializeConnectionRequest.shared_buffer_page_size_bytes)
  return shared_buffer_page_size_bytes_;
}
 void InitializeConnectionRequest::set_shared_buffer_page_size_bytes(::google::protobuf::uint32 value) {
  set_has_shared_buffer_page_size_bytes();
  shared_buffer_page_size_bytes_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.InitializeConnectionRequest.shared_buffer_page_size_bytes)
}

// optional uint32 shared_memory_size_hint_bytes = 2;
bool InitializeConnectionRequest::has_shared_memory_size_hint_bytes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void InitializeConnectionRequest::set_has_shared_memory_size_hint_bytes() {
  _has_bits_[0] |= 0x00000002u;
}
void InitializeConnectionRequest::clear_has_shared_memory_size_hint_bytes() {
  _has_bits_[0] &= ~0x00000002u;
}
void InitializeConnectionRequest::clear_shared_memory_size_hint_bytes() {
  shared_memory_size_hint_bytes_ = 0u;
  clear_has_shared_memory_size_hint_bytes();
}
 ::google::protobuf::uint32 InitializeConnectionRequest::shared_memory_size_hint_bytes() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InitializeConnectionRequest.shared_memory_size_hint_bytes)
  return shared_memory_size_hint_bytes_;
}
 void InitializeConnectionRequest::set_shared_memory_size_hint_bytes(::google::protobuf::uint32 value) {
  set_has_shared_memory_size_hint_bytes();
  shared_memory_size_hint_bytes_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.InitializeConnectionRequest.shared_memory_size_hint_bytes)
}

// optional string producer_name = 3;
bool InitializeConnectionRequest::has_producer_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void InitializeConnectionRequest::set_has_producer_name() {
  _has_bits_[0] |= 0x00000004u;
}
void InitializeConnectionRequest::clear_has_producer_name() {
  _has_bits_[0] &= ~0x00000004u;
}
void InitializeConnectionRequest::clear_producer_name() {
  producer_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_producer_name();
}
 const ::std::string& InitializeConnectionRequest::producer_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InitializeConnectionRequest.producer_name)
  return producer_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void InitializeConnectionRequest::set_producer_name(const ::std::string& value) {
  set_has_producer_name();
  producer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.InitializeConnectionRequest.producer_name)
}
 void InitializeConnectionRequest::set_producer_name(const char* value) {
  set_has_producer_name();
  producer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.InitializeConnectionRequest.producer_name)
}
 void InitializeConnectionRequest::set_producer_name(const char* value, size_t size) {
  set_has_producer_name();
  producer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.InitializeConnectionRequest.producer_name)
}
 ::std::string* InitializeConnectionRequest::mutable_producer_name() {
  set_has_producer_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.InitializeConnectionRequest.producer_name)
  return producer_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* InitializeConnectionRequest::release_producer_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.InitializeConnectionRequest.producer_name)
  clear_has_producer_name();
  return producer_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void InitializeConnectionRequest::set_allocated_producer_name(::std::string* producer_name) {
  if (producer_name != NULL) {
    set_has_producer_name();
  } else {
    clear_has_producer_name();
  }
  producer_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), producer_name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.InitializeConnectionRequest.producer_name)
}

// optional .perfetto.protos.InitializeConnectionRequest.ProducerSMBScrapingMode smb_scraping_mode = 4;
bool InitializeConnectionRequest::has_smb_scraping_mode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void InitializeConnectionRequest::set_has_smb_scraping_mode() {
  _has_bits_[0] |= 0x00000008u;
}
void InitializeConnectionRequest::clear_has_smb_scraping_mode() {
  _has_bits_[0] &= ~0x00000008u;
}
void InitializeConnectionRequest::clear_smb_scraping_mode() {
  smb_scraping_mode_ = 0;
  clear_has_smb_scraping_mode();
}
 ::perfetto::protos::InitializeConnectionRequest_ProducerSMBScrapingMode InitializeConnectionRequest::smb_scraping_mode() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.InitializeConnectionRequest.smb_scraping_mode)
  return static_cast< ::perfetto::protos::InitializeConnectionRequest_ProducerSMBScrapingMode >(smb_scraping_mode_);
}
 void InitializeConnectionRequest::set_smb_scraping_mode(::perfetto::protos::InitializeConnectionRequest_ProducerSMBScrapingMode value) {
  assert(::perfetto::protos::InitializeConnectionRequest_ProducerSMBScrapingMode_IsValid(value));
  set_has_smb_scraping_mode();
  smb_scraping_mode_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.InitializeConnectionRequest.smb_scraping_mode)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForInitializeConnectionResponse(
    InitializeConnectionResponse* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

InitializeConnectionResponse::InitializeConnectionResponse()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.InitializeConnectionResponse)
}

void InitializeConnectionResponse::InitAsDefaultInstance() {
}

InitializeConnectionResponse::InitializeConnectionResponse(const InitializeConnectionResponse& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.InitializeConnectionResponse)
}

void InitializeConnectionResponse::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

InitializeConnectionResponse::~InitializeConnectionResponse() {
  // @@protoc_insertion_point(destructor:perfetto.protos.InitializeConnectionResponse)
  SharedDtor();
}

void InitializeConnectionResponse::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void InitializeConnectionResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const InitializeConnectionResponse& InitializeConnectionResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
#endif
  return *default_instance_;
}

InitializeConnectionResponse* InitializeConnectionResponse::default_instance_ = NULL;

InitializeConnectionResponse* InitializeConnectionResponse::New(::google::protobuf::Arena* arena) const {
  InitializeConnectionResponse* n = new InitializeConnectionResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void InitializeConnectionResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.InitializeConnectionResponse)
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool InitializeConnectionResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForInitializeConnectionResponse, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.InitializeConnectionResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.InitializeConnectionResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.InitializeConnectionResponse)
  return false;
#undef DO_
}

void InitializeConnectionResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.InitializeConnectionResponse)
  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.InitializeConnectionResponse)
}

int InitializeConnectionResponse::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.InitializeConnectionResponse)
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void InitializeConnectionResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const InitializeConnectionResponse*>(&from));
}

void InitializeConnectionResponse::MergeFrom(const InitializeConnectionResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.InitializeConnectionResponse)
  if (GOOGLE_PREDICT_FALSE(&from == this)) producer_port_pb_MergeFromFail(__LINE__);
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void InitializeConnectionResponse::CopyFrom(const InitializeConnectionResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.InitializeConnectionResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InitializeConnectionResponse::IsInitialized() const {

  return true;
}

void InitializeConnectionResponse::Swap(InitializeConnectionResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void InitializeConnectionResponse::InternalSwap(InitializeConnectionResponse* other) {
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string InitializeConnectionResponse::GetTypeName() const {
  return "perfetto.protos.InitializeConnectionResponse";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// InitializeConnectionResponse

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForRegisterDataSourceRequest(
    RegisterDataSourceRequest* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RegisterDataSourceRequest::kDataSourceDescriptorFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RegisterDataSourceRequest::RegisterDataSourceRequest()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.RegisterDataSourceRequest)
}

void RegisterDataSourceRequest::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  data_source_descriptor_ = const_cast< ::perfetto::protos::DataSourceDescriptor*>(
      ::perfetto::protos::DataSourceDescriptor::internal_default_instance());
#else
  data_source_descriptor_ = const_cast< ::perfetto::protos::DataSourceDescriptor*>(&::perfetto::protos::DataSourceDescriptor::default_instance());
#endif
}

RegisterDataSourceRequest::RegisterDataSourceRequest(const RegisterDataSourceRequest& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.RegisterDataSourceRequest)
}

void RegisterDataSourceRequest::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  data_source_descriptor_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RegisterDataSourceRequest::~RegisterDataSourceRequest() {
  // @@protoc_insertion_point(destructor:perfetto.protos.RegisterDataSourceRequest)
  SharedDtor();
}

void RegisterDataSourceRequest::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete data_source_descriptor_;
  }
}

void RegisterDataSourceRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RegisterDataSourceRequest& RegisterDataSourceRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
#endif
  return *default_instance_;
}

RegisterDataSourceRequest* RegisterDataSourceRequest::default_instance_ = NULL;

RegisterDataSourceRequest* RegisterDataSourceRequest::New(::google::protobuf::Arena* arena) const {
  RegisterDataSourceRequest* n = new RegisterDataSourceRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RegisterDataSourceRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.RegisterDataSourceRequest)
  if (has_data_source_descriptor()) {
    if (data_source_descriptor_ != NULL) data_source_descriptor_->::perfetto::protos::DataSourceDescriptor::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool RegisterDataSourceRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForRegisterDataSourceRequest, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.RegisterDataSourceRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .perfetto.protos.DataSourceDescriptor data_source_descriptor = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_data_source_descriptor()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.RegisterDataSourceRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.RegisterDataSourceRequest)
  return false;
#undef DO_
}

void RegisterDataSourceRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.RegisterDataSourceRequest)
  // optional .perfetto.protos.DataSourceDescriptor data_source_descriptor = 1;
  if (has_data_source_descriptor()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->data_source_descriptor_, output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.RegisterDataSourceRequest)
}

int RegisterDataSourceRequest::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.RegisterDataSourceRequest)
  int total_size = 0;

  // optional .perfetto.protos.DataSourceDescriptor data_source_descriptor = 1;
  if (has_data_source_descriptor()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->data_source_descriptor_);
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RegisterDataSourceRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RegisterDataSourceRequest*>(&from));
}

void RegisterDataSourceRequest::MergeFrom(const RegisterDataSourceRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.RegisterDataSourceRequest)
  if (GOOGLE_PREDICT_FALSE(&from == this)) producer_port_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_data_source_descriptor()) {
      mutable_data_source_descriptor()->::perfetto::protos::DataSourceDescriptor::MergeFrom(from.data_source_descriptor());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void RegisterDataSourceRequest::CopyFrom(const RegisterDataSourceRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.RegisterDataSourceRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegisterDataSourceRequest::IsInitialized() const {

  return true;
}

void RegisterDataSourceRequest::Swap(RegisterDataSourceRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RegisterDataSourceRequest::InternalSwap(RegisterDataSourceRequest* other) {
  std::swap(data_source_descriptor_, other->data_source_descriptor_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string RegisterDataSourceRequest::GetTypeName() const {
  return "perfetto.protos.RegisterDataSourceRequest";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RegisterDataSourceRequest

// optional .perfetto.protos.DataSourceDescriptor data_source_descriptor = 1;
bool RegisterDataSourceRequest::has_data_source_descriptor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RegisterDataSourceRequest::set_has_data_source_descriptor() {
  _has_bits_[0] |= 0x00000001u;
}
void RegisterDataSourceRequest::clear_has_data_source_descriptor() {
  _has_bits_[0] &= ~0x00000001u;
}
void RegisterDataSourceRequest::clear_data_source_descriptor() {
  if (data_source_descriptor_ != NULL) data_source_descriptor_->::perfetto::protos::DataSourceDescriptor::Clear();
  clear_has_data_source_descriptor();
}
const ::perfetto::protos::DataSourceDescriptor& RegisterDataSourceRequest::data_source_descriptor() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.RegisterDataSourceRequest.data_source_descriptor)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return data_source_descriptor_ != NULL ? *data_source_descriptor_ : *default_instance().data_source_descriptor_;
#else
  return data_source_descriptor_ != NULL ? *data_source_descriptor_ : *default_instance_->data_source_descriptor_;
#endif
}
::perfetto::protos::DataSourceDescriptor* RegisterDataSourceRequest::mutable_data_source_descriptor() {
  set_has_data_source_descriptor();
  if (data_source_descriptor_ == NULL) {
    data_source_descriptor_ = new ::perfetto::protos::DataSourceDescriptor;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.RegisterDataSourceRequest.data_source_descriptor)
  return data_source_descriptor_;
}
::perfetto::protos::DataSourceDescriptor* RegisterDataSourceRequest::release_data_source_descriptor() {
  // @@protoc_insertion_point(field_release:perfetto.protos.RegisterDataSourceRequest.data_source_descriptor)
  clear_has_data_source_descriptor();
  ::perfetto::protos::DataSourceDescriptor* temp = data_source_descriptor_;
  data_source_descriptor_ = NULL;
  return temp;
}
void RegisterDataSourceRequest::set_allocated_data_source_descriptor(::perfetto::protos::DataSourceDescriptor* data_source_descriptor) {
  delete data_source_descriptor_;
  data_source_descriptor_ = data_source_descriptor;
  if (data_source_descriptor) {
    set_has_data_source_descriptor();
  } else {
    clear_has_data_source_descriptor();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.RegisterDataSourceRequest.data_source_descriptor)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForRegisterDataSourceResponse(
    RegisterDataSourceResponse* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RegisterDataSourceResponse::kErrorFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RegisterDataSourceResponse::RegisterDataSourceResponse()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.RegisterDataSourceResponse)
}

void RegisterDataSourceResponse::InitAsDefaultInstance() {
}

RegisterDataSourceResponse::RegisterDataSourceResponse(const RegisterDataSourceResponse& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.RegisterDataSourceResponse)
}

void RegisterDataSourceResponse::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  error_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RegisterDataSourceResponse::~RegisterDataSourceResponse() {
  // @@protoc_insertion_point(destructor:perfetto.protos.RegisterDataSourceResponse)
  SharedDtor();
}

void RegisterDataSourceResponse::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  error_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RegisterDataSourceResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RegisterDataSourceResponse& RegisterDataSourceResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
#endif
  return *default_instance_;
}

RegisterDataSourceResponse* RegisterDataSourceResponse::default_instance_ = NULL;

RegisterDataSourceResponse* RegisterDataSourceResponse::New(::google::protobuf::Arena* arena) const {
  RegisterDataSourceResponse* n = new RegisterDataSourceResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RegisterDataSourceResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.RegisterDataSourceResponse)
  if (has_error()) {
    error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool RegisterDataSourceResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForRegisterDataSourceResponse, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.RegisterDataSourceResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string error = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_error()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.RegisterDataSourceResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.RegisterDataSourceResponse)
  return false;
#undef DO_
}

void RegisterDataSourceResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.RegisterDataSourceResponse)
  // optional string error = 1;
  if (has_error()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->error(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.RegisterDataSourceResponse)
}

int RegisterDataSourceResponse::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.RegisterDataSourceResponse)
  int total_size = 0;

  // optional string error = 1;
  if (has_error()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->error());
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RegisterDataSourceResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RegisterDataSourceResponse*>(&from));
}

void RegisterDataSourceResponse::MergeFrom(const RegisterDataSourceResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.RegisterDataSourceResponse)
  if (GOOGLE_PREDICT_FALSE(&from == this)) producer_port_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_error()) {
      set_has_error();
      error_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.error_);
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void RegisterDataSourceResponse::CopyFrom(const RegisterDataSourceResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.RegisterDataSourceResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegisterDataSourceResponse::IsInitialized() const {

  return true;
}

void RegisterDataSourceResponse::Swap(RegisterDataSourceResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RegisterDataSourceResponse::InternalSwap(RegisterDataSourceResponse* other) {
  error_.Swap(&other->error_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string RegisterDataSourceResponse::GetTypeName() const {
  return "perfetto.protos.RegisterDataSourceResponse";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RegisterDataSourceResponse

// optional string error = 1;
bool RegisterDataSourceResponse::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RegisterDataSourceResponse::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
void RegisterDataSourceResponse::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
void RegisterDataSourceResponse::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_error();
}
 const ::std::string& RegisterDataSourceResponse::error() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.RegisterDataSourceResponse.error)
  return error_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RegisterDataSourceResponse::set_error(const ::std::string& value) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.RegisterDataSourceResponse.error)
}
 void RegisterDataSourceResponse::set_error(const char* value) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.RegisterDataSourceResponse.error)
}
 void RegisterDataSourceResponse::set_error(const char* value, size_t size) {
  set_has_error();
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.RegisterDataSourceResponse.error)
}
 ::std::string* RegisterDataSourceResponse::mutable_error() {
  set_has_error();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.RegisterDataSourceResponse.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* RegisterDataSourceResponse::release_error() {
  // @@protoc_insertion_point(field_release:perfetto.protos.RegisterDataSourceResponse.error)
  clear_has_error();
  return error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RegisterDataSourceResponse::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    set_has_error();
  } else {
    clear_has_error();
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.RegisterDataSourceResponse.error)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForUnregisterDataSourceRequest(
    UnregisterDataSourceRequest* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int UnregisterDataSourceRequest::kDataSourceNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

UnregisterDataSourceRequest::UnregisterDataSourceRequest()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.UnregisterDataSourceRequest)
}

void UnregisterDataSourceRequest::InitAsDefaultInstance() {
}

UnregisterDataSourceRequest::UnregisterDataSourceRequest(const UnregisterDataSourceRequest& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.UnregisterDataSourceRequest)
}

void UnregisterDataSourceRequest::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  data_source_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UnregisterDataSourceRequest::~UnregisterDataSourceRequest() {
  // @@protoc_insertion_point(destructor:perfetto.protos.UnregisterDataSourceRequest)
  SharedDtor();
}

void UnregisterDataSourceRequest::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  data_source_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void UnregisterDataSourceRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UnregisterDataSourceRequest& UnregisterDataSourceRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
#endif
  return *default_instance_;
}

UnregisterDataSourceRequest* UnregisterDataSourceRequest::default_instance_ = NULL;

UnregisterDataSourceRequest* UnregisterDataSourceRequest::New(::google::protobuf::Arena* arena) const {
  UnregisterDataSourceRequest* n = new UnregisterDataSourceRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void UnregisterDataSourceRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.UnregisterDataSourceRequest)
  if (has_data_source_name()) {
    data_source_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool UnregisterDataSourceRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForUnregisterDataSourceRequest, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.UnregisterDataSourceRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string data_source_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_data_source_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.UnregisterDataSourceRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.UnregisterDataSourceRequest)
  return false;
#undef DO_
}

void UnregisterDataSourceRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.UnregisterDataSourceRequest)
  // optional string data_source_name = 1;
  if (has_data_source_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->data_source_name(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.UnregisterDataSourceRequest)
}

int UnregisterDataSourceRequest::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.UnregisterDataSourceRequest)
  int total_size = 0;

  // optional string data_source_name = 1;
  if (has_data_source_name()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->data_source_name());
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UnregisterDataSourceRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UnregisterDataSourceRequest*>(&from));
}

void UnregisterDataSourceRequest::MergeFrom(const UnregisterDataSourceRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.UnregisterDataSourceRequest)
  if (GOOGLE_PREDICT_FALSE(&from == this)) producer_port_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_data_source_name()) {
      set_has_data_source_name();
      data_source_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.data_source_name_);
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void UnregisterDataSourceRequest::CopyFrom(const UnregisterDataSourceRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.UnregisterDataSourceRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UnregisterDataSourceRequest::IsInitialized() const {

  return true;
}

void UnregisterDataSourceRequest::Swap(UnregisterDataSourceRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void UnregisterDataSourceRequest::InternalSwap(UnregisterDataSourceRequest* other) {
  data_source_name_.Swap(&other->data_source_name_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string UnregisterDataSourceRequest::GetTypeName() const {
  return "perfetto.protos.UnregisterDataSourceRequest";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// UnregisterDataSourceRequest

// optional string data_source_name = 1;
bool UnregisterDataSourceRequest::has_data_source_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void UnregisterDataSourceRequest::set_has_data_source_name() {
  _has_bits_[0] |= 0x00000001u;
}
void UnregisterDataSourceRequest::clear_has_data_source_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void UnregisterDataSourceRequest::clear_data_source_name() {
  data_source_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data_source_name();
}
 const ::std::string& UnregisterDataSourceRequest::data_source_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.UnregisterDataSourceRequest.data_source_name)
  return data_source_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void UnregisterDataSourceRequest::set_data_source_name(const ::std::string& value) {
  set_has_data_source_name();
  data_source_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.UnregisterDataSourceRequest.data_source_name)
}
 void UnregisterDataSourceRequest::set_data_source_name(const char* value) {
  set_has_data_source_name();
  data_source_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.UnregisterDataSourceRequest.data_source_name)
}
 void UnregisterDataSourceRequest::set_data_source_name(const char* value, size_t size) {
  set_has_data_source_name();
  data_source_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.UnregisterDataSourceRequest.data_source_name)
}
 ::std::string* UnregisterDataSourceRequest::mutable_data_source_name() {
  set_has_data_source_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.UnregisterDataSourceRequest.data_source_name)
  return data_source_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* UnregisterDataSourceRequest::release_data_source_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.UnregisterDataSourceRequest.data_source_name)
  clear_has_data_source_name();
  return data_source_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void UnregisterDataSourceRequest::set_allocated_data_source_name(::std::string* data_source_name) {
  if (data_source_name != NULL) {
    set_has_data_source_name();
  } else {
    clear_has_data_source_name();
  }
  data_source_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data_source_name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.UnregisterDataSourceRequest.data_source_name)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForUnregisterDataSourceResponse(
    UnregisterDataSourceResponse* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

UnregisterDataSourceResponse::UnregisterDataSourceResponse()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.UnregisterDataSourceResponse)
}

void UnregisterDataSourceResponse::InitAsDefaultInstance() {
}

UnregisterDataSourceResponse::UnregisterDataSourceResponse(const UnregisterDataSourceResponse& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.UnregisterDataSourceResponse)
}

void UnregisterDataSourceResponse::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UnregisterDataSourceResponse::~UnregisterDataSourceResponse() {
  // @@protoc_insertion_point(destructor:perfetto.protos.UnregisterDataSourceResponse)
  SharedDtor();
}

void UnregisterDataSourceResponse::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void UnregisterDataSourceResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UnregisterDataSourceResponse& UnregisterDataSourceResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
#endif
  return *default_instance_;
}

UnregisterDataSourceResponse* UnregisterDataSourceResponse::default_instance_ = NULL;

UnregisterDataSourceResponse* UnregisterDataSourceResponse::New(::google::protobuf::Arena* arena) const {
  UnregisterDataSourceResponse* n = new UnregisterDataSourceResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void UnregisterDataSourceResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.UnregisterDataSourceResponse)
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool UnregisterDataSourceResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForUnregisterDataSourceResponse, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.UnregisterDataSourceResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.UnregisterDataSourceResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.UnregisterDataSourceResponse)
  return false;
#undef DO_
}

void UnregisterDataSourceResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.UnregisterDataSourceResponse)
  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.UnregisterDataSourceResponse)
}

int UnregisterDataSourceResponse::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.UnregisterDataSourceResponse)
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UnregisterDataSourceResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UnregisterDataSourceResponse*>(&from));
}

void UnregisterDataSourceResponse::MergeFrom(const UnregisterDataSourceResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.UnregisterDataSourceResponse)
  if (GOOGLE_PREDICT_FALSE(&from == this)) producer_port_pb_MergeFromFail(__LINE__);
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void UnregisterDataSourceResponse::CopyFrom(const UnregisterDataSourceResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.UnregisterDataSourceResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UnregisterDataSourceResponse::IsInitialized() const {

  return true;
}

void UnregisterDataSourceResponse::Swap(UnregisterDataSourceResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void UnregisterDataSourceResponse::InternalSwap(UnregisterDataSourceResponse* other) {
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string UnregisterDataSourceResponse::GetTypeName() const {
  return "perfetto.protos.UnregisterDataSourceResponse";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// UnregisterDataSourceResponse

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForRegisterTraceWriterRequest(
    RegisterTraceWriterRequest* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RegisterTraceWriterRequest::kTraceWriterIdFieldNumber;
const int RegisterTraceWriterRequest::kTargetBufferFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RegisterTraceWriterRequest::RegisterTraceWriterRequest()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.RegisterTraceWriterRequest)
}

void RegisterTraceWriterRequest::InitAsDefaultInstance() {
}

RegisterTraceWriterRequest::RegisterTraceWriterRequest(const RegisterTraceWriterRequest& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.RegisterTraceWriterRequest)
}

void RegisterTraceWriterRequest::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  trace_writer_id_ = 0u;
  target_buffer_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RegisterTraceWriterRequest::~RegisterTraceWriterRequest() {
  // @@protoc_insertion_point(destructor:perfetto.protos.RegisterTraceWriterRequest)
  SharedDtor();
}

void RegisterTraceWriterRequest::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RegisterTraceWriterRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RegisterTraceWriterRequest& RegisterTraceWriterRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
#endif
  return *default_instance_;
}

RegisterTraceWriterRequest* RegisterTraceWriterRequest::default_instance_ = NULL;

RegisterTraceWriterRequest* RegisterTraceWriterRequest::New(::google::protobuf::Arena* arena) const {
  RegisterTraceWriterRequest* n = new RegisterTraceWriterRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RegisterTraceWriterRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.RegisterTraceWriterRequest)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(RegisterTraceWriterRequest, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<RegisterTraceWriterRequest*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(trace_writer_id_, target_buffer_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool RegisterTraceWriterRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForRegisterTraceWriterRequest, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.RegisterTraceWriterRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 trace_writer_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &trace_writer_id_)));
          set_has_trace_writer_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_target_buffer;
        break;
      }

      // optional uint32 target_buffer = 2;
      case 2: {
        if (tag == 16) {
         parse_target_buffer:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &target_buffer_)));
          set_has_target_buffer();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.RegisterTraceWriterRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.RegisterTraceWriterRequest)
  return false;
#undef DO_
}

void RegisterTraceWriterRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.RegisterTraceWriterRequest)
  // optional uint32 trace_writer_id = 1;
  if (has_trace_writer_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->trace_writer_id(), output);
  }

  // optional uint32 target_buffer = 2;
  if (has_target_buffer()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->target_buffer(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.RegisterTraceWriterRequest)
}

int RegisterTraceWriterRequest::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.RegisterTraceWriterRequest)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional uint32 trace_writer_id = 1;
    if (has_trace_writer_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->trace_writer_id());
    }

    // optional uint32 target_buffer = 2;
    if (has_target_buffer()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->target_buffer());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RegisterTraceWriterRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RegisterTraceWriterRequest*>(&from));
}

void RegisterTraceWriterRequest::MergeFrom(const RegisterTraceWriterRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.RegisterTraceWriterRequest)
  if (GOOGLE_PREDICT_FALSE(&from == this)) producer_port_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_trace_writer_id()) {
      set_trace_writer_id(from.trace_writer_id());
    }
    if (from.has_target_buffer()) {
      set_target_buffer(from.target_buffer());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void RegisterTraceWriterRequest::CopyFrom(const RegisterTraceWriterRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.RegisterTraceWriterRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegisterTraceWriterRequest::IsInitialized() const {

  return true;
}

void RegisterTraceWriterRequest::Swap(RegisterTraceWriterRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RegisterTraceWriterRequest::InternalSwap(RegisterTraceWriterRequest* other) {
  std::swap(trace_writer_id_, other->trace_writer_id_);
  std::swap(target_buffer_, other->target_buffer_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string RegisterTraceWriterRequest::GetTypeName() const {
  return "perfetto.protos.RegisterTraceWriterRequest";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RegisterTraceWriterRequest

// optional uint32 trace_writer_id = 1;
bool RegisterTraceWriterRequest::has_trace_writer_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RegisterTraceWriterRequest::set_has_trace_writer_id() {
  _has_bits_[0] |= 0x00000001u;
}
void RegisterTraceWriterRequest::clear_has_trace_writer_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void RegisterTraceWriterRequest::clear_trace_writer_id() {
  trace_writer_id_ = 0u;
  clear_has_trace_writer_id();
}
 ::google::protobuf::uint32 RegisterTraceWriterRequest::trace_writer_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.RegisterTraceWriterRequest.trace_writer_id)
  return trace_writer_id_;
}
 void RegisterTraceWriterRequest::set_trace_writer_id(::google::protobuf::uint32 value) {
  set_has_trace_writer_id();
  trace_writer_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.RegisterTraceWriterRequest.trace_writer_id)
}

// optional uint32 target_buffer = 2;
bool RegisterTraceWriterRequest::has_target_buffer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void RegisterTraceWriterRequest::set_has_target_buffer() {
  _has_bits_[0] |= 0x00000002u;
}
void RegisterTraceWriterRequest::clear_has_target_buffer() {
  _has_bits_[0] &= ~0x00000002u;
}
void RegisterTraceWriterRequest::clear_target_buffer() {
  target_buffer_ = 0u;
  clear_has_target_buffer();
}
 ::google::protobuf::uint32 RegisterTraceWriterRequest::target_buffer() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.RegisterTraceWriterRequest.target_buffer)
  return target_buffer_;
}
 void RegisterTraceWriterRequest::set_target_buffer(::google::protobuf::uint32 value) {
  set_has_target_buffer();
  target_buffer_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.RegisterTraceWriterRequest.target_buffer)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForRegisterTraceWriterResponse(
    RegisterTraceWriterResponse* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RegisterTraceWriterResponse::RegisterTraceWriterResponse()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.RegisterTraceWriterResponse)
}

void RegisterTraceWriterResponse::InitAsDefaultInstance() {
}

RegisterTraceWriterResponse::RegisterTraceWriterResponse(const RegisterTraceWriterResponse& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.RegisterTraceWriterResponse)
}

void RegisterTraceWriterResponse::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RegisterTraceWriterResponse::~RegisterTraceWriterResponse() {
  // @@protoc_insertion_point(destructor:perfetto.protos.RegisterTraceWriterResponse)
  SharedDtor();
}

void RegisterTraceWriterResponse::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void RegisterTraceWriterResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const RegisterTraceWriterResponse& RegisterTraceWriterResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
#endif
  return *default_instance_;
}

RegisterTraceWriterResponse* RegisterTraceWriterResponse::default_instance_ = NULL;

RegisterTraceWriterResponse* RegisterTraceWriterResponse::New(::google::protobuf::Arena* arena) const {
  RegisterTraceWriterResponse* n = new RegisterTraceWriterResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RegisterTraceWriterResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.RegisterTraceWriterResponse)
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool RegisterTraceWriterResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForRegisterTraceWriterResponse, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.RegisterTraceWriterResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.RegisterTraceWriterResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.RegisterTraceWriterResponse)
  return false;
#undef DO_
}

void RegisterTraceWriterResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.RegisterTraceWriterResponse)
  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.RegisterTraceWriterResponse)
}

int RegisterTraceWriterResponse::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.RegisterTraceWriterResponse)
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RegisterTraceWriterResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const RegisterTraceWriterResponse*>(&from));
}

void RegisterTraceWriterResponse::MergeFrom(const RegisterTraceWriterResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.RegisterTraceWriterResponse)
  if (GOOGLE_PREDICT_FALSE(&from == this)) producer_port_pb_MergeFromFail(__LINE__);
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void RegisterTraceWriterResponse::CopyFrom(const RegisterTraceWriterResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.RegisterTraceWriterResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RegisterTraceWriterResponse::IsInitialized() const {

  return true;
}

void RegisterTraceWriterResponse::Swap(RegisterTraceWriterResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RegisterTraceWriterResponse::InternalSwap(RegisterTraceWriterResponse* other) {
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string RegisterTraceWriterResponse::GetTypeName() const {
  return "perfetto.protos.RegisterTraceWriterResponse";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RegisterTraceWriterResponse

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForUnregisterTraceWriterRequest(
    UnregisterTraceWriterRequest* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int UnregisterTraceWriterRequest::kTraceWriterIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

UnregisterTraceWriterRequest::UnregisterTraceWriterRequest()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.UnregisterTraceWriterRequest)
}

void UnregisterTraceWriterRequest::InitAsDefaultInstance() {
}

UnregisterTraceWriterRequest::UnregisterTraceWriterRequest(const UnregisterTraceWriterRequest& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.UnregisterTraceWriterRequest)
}

void UnregisterTraceWriterRequest::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  trace_writer_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UnregisterTraceWriterRequest::~UnregisterTraceWriterRequest() {
  // @@protoc_insertion_point(destructor:perfetto.protos.UnregisterTraceWriterRequest)
  SharedDtor();
}

void UnregisterTraceWriterRequest::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void UnregisterTraceWriterRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UnregisterTraceWriterRequest& UnregisterTraceWriterRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
#endif
  return *default_instance_;
}

UnregisterTraceWriterRequest* UnregisterTraceWriterRequest::default_instance_ = NULL;

UnregisterTraceWriterRequest* UnregisterTraceWriterRequest::New(::google::protobuf::Arena* arena) const {
  UnregisterTraceWriterRequest* n = new UnregisterTraceWriterRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void UnregisterTraceWriterRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.UnregisterTraceWriterRequest)
  trace_writer_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool UnregisterTraceWriterRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForUnregisterTraceWriterRequest, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.UnregisterTraceWriterRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 trace_writer_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &trace_writer_id_)));
          set_has_trace_writer_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.UnregisterTraceWriterRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.UnregisterTraceWriterRequest)
  return false;
#undef DO_
}

void UnregisterTraceWriterRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.UnregisterTraceWriterRequest)
  // optional uint32 trace_writer_id = 1;
  if (has_trace_writer_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->trace_writer_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.UnregisterTraceWriterRequest)
}

int UnregisterTraceWriterRequest::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.UnregisterTraceWriterRequest)
  int total_size = 0;

  // optional uint32 trace_writer_id = 1;
  if (has_trace_writer_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->trace_writer_id());
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UnregisterTraceWriterRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UnregisterTraceWriterRequest*>(&from));
}

void UnregisterTraceWriterRequest::MergeFrom(const UnregisterTraceWriterRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.UnregisterTraceWriterRequest)
  if (GOOGLE_PREDICT_FALSE(&from == this)) producer_port_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_trace_writer_id()) {
      set_trace_writer_id(from.trace_writer_id());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void UnregisterTraceWriterRequest::CopyFrom(const UnregisterTraceWriterRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.UnregisterTraceWriterRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UnregisterTraceWriterRequest::IsInitialized() const {

  return true;
}

void UnregisterTraceWriterRequest::Swap(UnregisterTraceWriterRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void UnregisterTraceWriterRequest::InternalSwap(UnregisterTraceWriterRequest* other) {
  std::swap(trace_writer_id_, other->trace_writer_id_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string UnregisterTraceWriterRequest::GetTypeName() const {
  return "perfetto.protos.UnregisterTraceWriterRequest";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// UnregisterTraceWriterRequest

// optional uint32 trace_writer_id = 1;
bool UnregisterTraceWriterRequest::has_trace_writer_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void UnregisterTraceWriterRequest::set_has_trace_writer_id() {
  _has_bits_[0] |= 0x00000001u;
}
void UnregisterTraceWriterRequest::clear_has_trace_writer_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void UnregisterTraceWriterRequest::clear_trace_writer_id() {
  trace_writer_id_ = 0u;
  clear_has_trace_writer_id();
}
 ::google::protobuf::uint32 UnregisterTraceWriterRequest::trace_writer_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.UnregisterTraceWriterRequest.trace_writer_id)
  return trace_writer_id_;
}
 void UnregisterTraceWriterRequest::set_trace_writer_id(::google::protobuf::uint32 value) {
  set_has_trace_writer_id();
  trace_writer_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.UnregisterTraceWriterRequest.trace_writer_id)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForUnregisterTraceWriterResponse(
    UnregisterTraceWriterResponse* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

UnregisterTraceWriterResponse::UnregisterTraceWriterResponse()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.UnregisterTraceWriterResponse)
}

void UnregisterTraceWriterResponse::InitAsDefaultInstance() {
}

UnregisterTraceWriterResponse::UnregisterTraceWriterResponse(const UnregisterTraceWriterResponse& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.UnregisterTraceWriterResponse)
}

void UnregisterTraceWriterResponse::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UnregisterTraceWriterResponse::~UnregisterTraceWriterResponse() {
  // @@protoc_insertion_point(destructor:perfetto.protos.UnregisterTraceWriterResponse)
  SharedDtor();
}

void UnregisterTraceWriterResponse::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void UnregisterTraceWriterResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UnregisterTraceWriterResponse& UnregisterTraceWriterResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
#endif
  return *default_instance_;
}

UnregisterTraceWriterResponse* UnregisterTraceWriterResponse::default_instance_ = NULL;

UnregisterTraceWriterResponse* UnregisterTraceWriterResponse::New(::google::protobuf::Arena* arena) const {
  UnregisterTraceWriterResponse* n = new UnregisterTraceWriterResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void UnregisterTraceWriterResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.UnregisterTraceWriterResponse)
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool UnregisterTraceWriterResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForUnregisterTraceWriterResponse, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.UnregisterTraceWriterResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.UnregisterTraceWriterResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.UnregisterTraceWriterResponse)
  return false;
#undef DO_
}

void UnregisterTraceWriterResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.UnregisterTraceWriterResponse)
  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.UnregisterTraceWriterResponse)
}

int UnregisterTraceWriterResponse::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.UnregisterTraceWriterResponse)
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UnregisterTraceWriterResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UnregisterTraceWriterResponse*>(&from));
}

void UnregisterTraceWriterResponse::MergeFrom(const UnregisterTraceWriterResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.UnregisterTraceWriterResponse)
  if (GOOGLE_PREDICT_FALSE(&from == this)) producer_port_pb_MergeFromFail(__LINE__);
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void UnregisterTraceWriterResponse::CopyFrom(const UnregisterTraceWriterResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.UnregisterTraceWriterResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UnregisterTraceWriterResponse::IsInitialized() const {

  return true;
}

void UnregisterTraceWriterResponse::Swap(UnregisterTraceWriterResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void UnregisterTraceWriterResponse::InternalSwap(UnregisterTraceWriterResponse* other) {
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string UnregisterTraceWriterResponse::GetTypeName() const {
  return "perfetto.protos.UnregisterTraceWriterResponse";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// UnregisterTraceWriterResponse

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForCommitDataResponse(
    CommitDataResponse* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CommitDataResponse::CommitDataResponse()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.CommitDataResponse)
}

void CommitDataResponse::InitAsDefaultInstance() {
}

CommitDataResponse::CommitDataResponse(const CommitDataResponse& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.CommitDataResponse)
}

void CommitDataResponse::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CommitDataResponse::~CommitDataResponse() {
  // @@protoc_insertion_point(destructor:perfetto.protos.CommitDataResponse)
  SharedDtor();
}

void CommitDataResponse::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CommitDataResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CommitDataResponse& CommitDataResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
#endif
  return *default_instance_;
}

CommitDataResponse* CommitDataResponse::default_instance_ = NULL;

CommitDataResponse* CommitDataResponse::New(::google::protobuf::Arena* arena) const {
  CommitDataResponse* n = new CommitDataResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CommitDataResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.CommitDataResponse)
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool CommitDataResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForCommitDataResponse, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.CommitDataResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.CommitDataResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.CommitDataResponse)
  return false;
#undef DO_
}

void CommitDataResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.CommitDataResponse)
  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.CommitDataResponse)
}

int CommitDataResponse::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.CommitDataResponse)
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CommitDataResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CommitDataResponse*>(&from));
}

void CommitDataResponse::MergeFrom(const CommitDataResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.CommitDataResponse)
  if (GOOGLE_PREDICT_FALSE(&from == this)) producer_port_pb_MergeFromFail(__LINE__);
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void CommitDataResponse::CopyFrom(const CommitDataResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.CommitDataResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommitDataResponse::IsInitialized() const {

  return true;
}

void CommitDataResponse::Swap(CommitDataResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CommitDataResponse::InternalSwap(CommitDataResponse* other) {
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string CommitDataResponse::GetTypeName() const {
  return "perfetto.protos.CommitDataResponse";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CommitDataResponse

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForNotifyDataSourceStartedRequest(
    NotifyDataSourceStartedRequest* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int NotifyDataSourceStartedRequest::kDataSourceIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

NotifyDataSourceStartedRequest::NotifyDataSourceStartedRequest()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.NotifyDataSourceStartedRequest)
}

void NotifyDataSourceStartedRequest::InitAsDefaultInstance() {
}

NotifyDataSourceStartedRequest::NotifyDataSourceStartedRequest(const NotifyDataSourceStartedRequest& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.NotifyDataSourceStartedRequest)
}

void NotifyDataSourceStartedRequest::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  data_source_id_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyDataSourceStartedRequest::~NotifyDataSourceStartedRequest() {
  // @@protoc_insertion_point(destructor:perfetto.protos.NotifyDataSourceStartedRequest)
  SharedDtor();
}

void NotifyDataSourceStartedRequest::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NotifyDataSourceStartedRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NotifyDataSourceStartedRequest& NotifyDataSourceStartedRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
#endif
  return *default_instance_;
}

NotifyDataSourceStartedRequest* NotifyDataSourceStartedRequest::default_instance_ = NULL;

NotifyDataSourceStartedRequest* NotifyDataSourceStartedRequest::New(::google::protobuf::Arena* arena) const {
  NotifyDataSourceStartedRequest* n = new NotifyDataSourceStartedRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void NotifyDataSourceStartedRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.NotifyDataSourceStartedRequest)
  data_source_id_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool NotifyDataSourceStartedRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForNotifyDataSourceStartedRequest, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.NotifyDataSourceStartedRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 data_source_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &data_source_id_)));
          set_has_data_source_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.NotifyDataSourceStartedRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.NotifyDataSourceStartedRequest)
  return false;
#undef DO_
}

void NotifyDataSourceStartedRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.NotifyDataSourceStartedRequest)
  // optional uint64 data_source_id = 1;
  if (has_data_source_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->data_source_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.NotifyDataSourceStartedRequest)
}

int NotifyDataSourceStartedRequest::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.NotifyDataSourceStartedRequest)
  int total_size = 0;

  // optional uint64 data_source_id = 1;
  if (has_data_source_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->data_source_id());
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyDataSourceStartedRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NotifyDataSourceStartedRequest*>(&from));
}

void NotifyDataSourceStartedRequest::MergeFrom(const NotifyDataSourceStartedRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.NotifyDataSourceStartedRequest)
  if (GOOGLE_PREDICT_FALSE(&from == this)) producer_port_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_data_source_id()) {
      set_data_source_id(from.data_source_id());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void NotifyDataSourceStartedRequest::CopyFrom(const NotifyDataSourceStartedRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.NotifyDataSourceStartedRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyDataSourceStartedRequest::IsInitialized() const {

  return true;
}

void NotifyDataSourceStartedRequest::Swap(NotifyDataSourceStartedRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void NotifyDataSourceStartedRequest::InternalSwap(NotifyDataSourceStartedRequest* other) {
  std::swap(data_source_id_, other->data_source_id_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string NotifyDataSourceStartedRequest::GetTypeName() const {
  return "perfetto.protos.NotifyDataSourceStartedRequest";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// NotifyDataSourceStartedRequest

// optional uint64 data_source_id = 1;
bool NotifyDataSourceStartedRequest::has_data_source_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void NotifyDataSourceStartedRequest::set_has_data_source_id() {
  _has_bits_[0] |= 0x00000001u;
}
void NotifyDataSourceStartedRequest::clear_has_data_source_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void NotifyDataSourceStartedRequest::clear_data_source_id() {
  data_source_id_ = GOOGLE_ULONGLONG(0);
  clear_has_data_source_id();
}
 ::google::protobuf::uint64 NotifyDataSourceStartedRequest::data_source_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.NotifyDataSourceStartedRequest.data_source_id)
  return data_source_id_;
}
 void NotifyDataSourceStartedRequest::set_data_source_id(::google::protobuf::uint64 value) {
  set_has_data_source_id();
  data_source_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.NotifyDataSourceStartedRequest.data_source_id)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForNotifyDataSourceStartedResponse(
    NotifyDataSourceStartedResponse* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

NotifyDataSourceStartedResponse::NotifyDataSourceStartedResponse()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.NotifyDataSourceStartedResponse)
}

void NotifyDataSourceStartedResponse::InitAsDefaultInstance() {
}

NotifyDataSourceStartedResponse::NotifyDataSourceStartedResponse(const NotifyDataSourceStartedResponse& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.NotifyDataSourceStartedResponse)
}

void NotifyDataSourceStartedResponse::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyDataSourceStartedResponse::~NotifyDataSourceStartedResponse() {
  // @@protoc_insertion_point(destructor:perfetto.protos.NotifyDataSourceStartedResponse)
  SharedDtor();
}

void NotifyDataSourceStartedResponse::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NotifyDataSourceStartedResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NotifyDataSourceStartedResponse& NotifyDataSourceStartedResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
#endif
  return *default_instance_;
}

NotifyDataSourceStartedResponse* NotifyDataSourceStartedResponse::default_instance_ = NULL;

NotifyDataSourceStartedResponse* NotifyDataSourceStartedResponse::New(::google::protobuf::Arena* arena) const {
  NotifyDataSourceStartedResponse* n = new NotifyDataSourceStartedResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void NotifyDataSourceStartedResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.NotifyDataSourceStartedResponse)
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool NotifyDataSourceStartedResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForNotifyDataSourceStartedResponse, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.NotifyDataSourceStartedResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.NotifyDataSourceStartedResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.NotifyDataSourceStartedResponse)
  return false;
#undef DO_
}

void NotifyDataSourceStartedResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.NotifyDataSourceStartedResponse)
  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.NotifyDataSourceStartedResponse)
}

int NotifyDataSourceStartedResponse::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.NotifyDataSourceStartedResponse)
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyDataSourceStartedResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NotifyDataSourceStartedResponse*>(&from));
}

void NotifyDataSourceStartedResponse::MergeFrom(const NotifyDataSourceStartedResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.NotifyDataSourceStartedResponse)
  if (GOOGLE_PREDICT_FALSE(&from == this)) producer_port_pb_MergeFromFail(__LINE__);
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void NotifyDataSourceStartedResponse::CopyFrom(const NotifyDataSourceStartedResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.NotifyDataSourceStartedResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyDataSourceStartedResponse::IsInitialized() const {

  return true;
}

void NotifyDataSourceStartedResponse::Swap(NotifyDataSourceStartedResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void NotifyDataSourceStartedResponse::InternalSwap(NotifyDataSourceStartedResponse* other) {
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string NotifyDataSourceStartedResponse::GetTypeName() const {
  return "perfetto.protos.NotifyDataSourceStartedResponse";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// NotifyDataSourceStartedResponse

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForNotifyDataSourceStoppedRequest(
    NotifyDataSourceStoppedRequest* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int NotifyDataSourceStoppedRequest::kDataSourceIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

NotifyDataSourceStoppedRequest::NotifyDataSourceStoppedRequest()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.NotifyDataSourceStoppedRequest)
}

void NotifyDataSourceStoppedRequest::InitAsDefaultInstance() {
}

NotifyDataSourceStoppedRequest::NotifyDataSourceStoppedRequest(const NotifyDataSourceStoppedRequest& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.NotifyDataSourceStoppedRequest)
}

void NotifyDataSourceStoppedRequest::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  data_source_id_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyDataSourceStoppedRequest::~NotifyDataSourceStoppedRequest() {
  // @@protoc_insertion_point(destructor:perfetto.protos.NotifyDataSourceStoppedRequest)
  SharedDtor();
}

void NotifyDataSourceStoppedRequest::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NotifyDataSourceStoppedRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NotifyDataSourceStoppedRequest& NotifyDataSourceStoppedRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
#endif
  return *default_instance_;
}

NotifyDataSourceStoppedRequest* NotifyDataSourceStoppedRequest::default_instance_ = NULL;

NotifyDataSourceStoppedRequest* NotifyDataSourceStoppedRequest::New(::google::protobuf::Arena* arena) const {
  NotifyDataSourceStoppedRequest* n = new NotifyDataSourceStoppedRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void NotifyDataSourceStoppedRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.NotifyDataSourceStoppedRequest)
  data_source_id_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool NotifyDataSourceStoppedRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForNotifyDataSourceStoppedRequest, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.NotifyDataSourceStoppedRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 data_source_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &data_source_id_)));
          set_has_data_source_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.NotifyDataSourceStoppedRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.NotifyDataSourceStoppedRequest)
  return false;
#undef DO_
}

void NotifyDataSourceStoppedRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.NotifyDataSourceStoppedRequest)
  // optional uint64 data_source_id = 1;
  if (has_data_source_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->data_source_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.NotifyDataSourceStoppedRequest)
}

int NotifyDataSourceStoppedRequest::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.NotifyDataSourceStoppedRequest)
  int total_size = 0;

  // optional uint64 data_source_id = 1;
  if (has_data_source_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->data_source_id());
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyDataSourceStoppedRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NotifyDataSourceStoppedRequest*>(&from));
}

void NotifyDataSourceStoppedRequest::MergeFrom(const NotifyDataSourceStoppedRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.NotifyDataSourceStoppedRequest)
  if (GOOGLE_PREDICT_FALSE(&from == this)) producer_port_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_data_source_id()) {
      set_data_source_id(from.data_source_id());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void NotifyDataSourceStoppedRequest::CopyFrom(const NotifyDataSourceStoppedRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.NotifyDataSourceStoppedRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyDataSourceStoppedRequest::IsInitialized() const {

  return true;
}

void NotifyDataSourceStoppedRequest::Swap(NotifyDataSourceStoppedRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void NotifyDataSourceStoppedRequest::InternalSwap(NotifyDataSourceStoppedRequest* other) {
  std::swap(data_source_id_, other->data_source_id_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string NotifyDataSourceStoppedRequest::GetTypeName() const {
  return "perfetto.protos.NotifyDataSourceStoppedRequest";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// NotifyDataSourceStoppedRequest

// optional uint64 data_source_id = 1;
bool NotifyDataSourceStoppedRequest::has_data_source_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void NotifyDataSourceStoppedRequest::set_has_data_source_id() {
  _has_bits_[0] |= 0x00000001u;
}
void NotifyDataSourceStoppedRequest::clear_has_data_source_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void NotifyDataSourceStoppedRequest::clear_data_source_id() {
  data_source_id_ = GOOGLE_ULONGLONG(0);
  clear_has_data_source_id();
}
 ::google::protobuf::uint64 NotifyDataSourceStoppedRequest::data_source_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.NotifyDataSourceStoppedRequest.data_source_id)
  return data_source_id_;
}
 void NotifyDataSourceStoppedRequest::set_data_source_id(::google::protobuf::uint64 value) {
  set_has_data_source_id();
  data_source_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.NotifyDataSourceStoppedRequest.data_source_id)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForNotifyDataSourceStoppedResponse(
    NotifyDataSourceStoppedResponse* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

NotifyDataSourceStoppedResponse::NotifyDataSourceStoppedResponse()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.NotifyDataSourceStoppedResponse)
}

void NotifyDataSourceStoppedResponse::InitAsDefaultInstance() {
}

NotifyDataSourceStoppedResponse::NotifyDataSourceStoppedResponse(const NotifyDataSourceStoppedResponse& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.NotifyDataSourceStoppedResponse)
}

void NotifyDataSourceStoppedResponse::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyDataSourceStoppedResponse::~NotifyDataSourceStoppedResponse() {
  // @@protoc_insertion_point(destructor:perfetto.protos.NotifyDataSourceStoppedResponse)
  SharedDtor();
}

void NotifyDataSourceStoppedResponse::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NotifyDataSourceStoppedResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NotifyDataSourceStoppedResponse& NotifyDataSourceStoppedResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
#endif
  return *default_instance_;
}

NotifyDataSourceStoppedResponse* NotifyDataSourceStoppedResponse::default_instance_ = NULL;

NotifyDataSourceStoppedResponse* NotifyDataSourceStoppedResponse::New(::google::protobuf::Arena* arena) const {
  NotifyDataSourceStoppedResponse* n = new NotifyDataSourceStoppedResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void NotifyDataSourceStoppedResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.NotifyDataSourceStoppedResponse)
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool NotifyDataSourceStoppedResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForNotifyDataSourceStoppedResponse, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.NotifyDataSourceStoppedResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.NotifyDataSourceStoppedResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.NotifyDataSourceStoppedResponse)
  return false;
#undef DO_
}

void NotifyDataSourceStoppedResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.NotifyDataSourceStoppedResponse)
  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.NotifyDataSourceStoppedResponse)
}

int NotifyDataSourceStoppedResponse::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.NotifyDataSourceStoppedResponse)
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyDataSourceStoppedResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NotifyDataSourceStoppedResponse*>(&from));
}

void NotifyDataSourceStoppedResponse::MergeFrom(const NotifyDataSourceStoppedResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.NotifyDataSourceStoppedResponse)
  if (GOOGLE_PREDICT_FALSE(&from == this)) producer_port_pb_MergeFromFail(__LINE__);
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void NotifyDataSourceStoppedResponse::CopyFrom(const NotifyDataSourceStoppedResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.NotifyDataSourceStoppedResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyDataSourceStoppedResponse::IsInitialized() const {

  return true;
}

void NotifyDataSourceStoppedResponse::Swap(NotifyDataSourceStoppedResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void NotifyDataSourceStoppedResponse::InternalSwap(NotifyDataSourceStoppedResponse* other) {
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string NotifyDataSourceStoppedResponse::GetTypeName() const {
  return "perfetto.protos.NotifyDataSourceStoppedResponse";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// NotifyDataSourceStoppedResponse

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForActivateTriggersRequest(
    ActivateTriggersRequest* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ActivateTriggersRequest::kTriggerNamesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ActivateTriggersRequest::ActivateTriggersRequest()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.ActivateTriggersRequest)
}

void ActivateTriggersRequest::InitAsDefaultInstance() {
}

ActivateTriggersRequest::ActivateTriggersRequest(const ActivateTriggersRequest& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.ActivateTriggersRequest)
}

void ActivateTriggersRequest::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ActivateTriggersRequest::~ActivateTriggersRequest() {
  // @@protoc_insertion_point(destructor:perfetto.protos.ActivateTriggersRequest)
  SharedDtor();
}

void ActivateTriggersRequest::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ActivateTriggersRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ActivateTriggersRequest& ActivateTriggersRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
#endif
  return *default_instance_;
}

ActivateTriggersRequest* ActivateTriggersRequest::default_instance_ = NULL;

ActivateTriggersRequest* ActivateTriggersRequest::New(::google::protobuf::Arena* arena) const {
  ActivateTriggersRequest* n = new ActivateTriggersRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ActivateTriggersRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.ActivateTriggersRequest)
  trigger_names_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool ActivateTriggersRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForActivateTriggersRequest, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.ActivateTriggersRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated string trigger_names = 1;
      case 1: {
        if (tag == 10) {
         parse_trigger_names:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_trigger_names()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_trigger_names;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.ActivateTriggersRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.ActivateTriggersRequest)
  return false;
#undef DO_
}

void ActivateTriggersRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.ActivateTriggersRequest)
  // repeated string trigger_names = 1;
  for (int i = 0; i < this->trigger_names_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->trigger_names(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.ActivateTriggersRequest)
}

int ActivateTriggersRequest::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.ActivateTriggersRequest)
  int total_size = 0;

  // repeated string trigger_names = 1;
  total_size += 1 * this->trigger_names_size();
  for (int i = 0; i < this->trigger_names_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->trigger_names(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ActivateTriggersRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ActivateTriggersRequest*>(&from));
}

void ActivateTriggersRequest::MergeFrom(const ActivateTriggersRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.ActivateTriggersRequest)
  if (GOOGLE_PREDICT_FALSE(&from == this)) producer_port_pb_MergeFromFail(__LINE__);
  trigger_names_.MergeFrom(from.trigger_names_);
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void ActivateTriggersRequest::CopyFrom(const ActivateTriggersRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.ActivateTriggersRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActivateTriggersRequest::IsInitialized() const {

  return true;
}

void ActivateTriggersRequest::Swap(ActivateTriggersRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ActivateTriggersRequest::InternalSwap(ActivateTriggersRequest* other) {
  trigger_names_.UnsafeArenaSwap(&other->trigger_names_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ActivateTriggersRequest::GetTypeName() const {
  return "perfetto.protos.ActivateTriggersRequest";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ActivateTriggersRequest

// repeated string trigger_names = 1;
int ActivateTriggersRequest::trigger_names_size() const {
  return trigger_names_.size();
}
void ActivateTriggersRequest::clear_trigger_names() {
  trigger_names_.Clear();
}
 const ::std::string& ActivateTriggersRequest::trigger_names(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ActivateTriggersRequest.trigger_names)
  return trigger_names_.Get(index);
}
 ::std::string* ActivateTriggersRequest::mutable_trigger_names(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.ActivateTriggersRequest.trigger_names)
  return trigger_names_.Mutable(index);
}
 void ActivateTriggersRequest::set_trigger_names(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:perfetto.protos.ActivateTriggersRequest.trigger_names)
  trigger_names_.Mutable(index)->assign(value);
}
 void ActivateTriggersRequest::set_trigger_names(int index, const char* value) {
  trigger_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:perfetto.protos.ActivateTriggersRequest.trigger_names)
}
 void ActivateTriggersRequest::set_trigger_names(int index, const char* value, size_t size) {
  trigger_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.ActivateTriggersRequest.trigger_names)
}
 ::std::string* ActivateTriggersRequest::add_trigger_names() {
  // @@protoc_insertion_point(field_add_mutable:perfetto.protos.ActivateTriggersRequest.trigger_names)
  return trigger_names_.Add();
}
 void ActivateTriggersRequest::add_trigger_names(const ::std::string& value) {
  trigger_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.ActivateTriggersRequest.trigger_names)
}
 void ActivateTriggersRequest::add_trigger_names(const char* value) {
  trigger_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:perfetto.protos.ActivateTriggersRequest.trigger_names)
}
 void ActivateTriggersRequest::add_trigger_names(const char* value, size_t size) {
  trigger_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:perfetto.protos.ActivateTriggersRequest.trigger_names)
}
 const ::google::protobuf::RepeatedPtrField< ::std::string>&
ActivateTriggersRequest::trigger_names() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.ActivateTriggersRequest.trigger_names)
  return trigger_names_;
}
 ::google::protobuf::RepeatedPtrField< ::std::string>*
ActivateTriggersRequest::mutable_trigger_names() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.ActivateTriggersRequest.trigger_names)
  return &trigger_names_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForActivateTriggersResponse(
    ActivateTriggersResponse* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ActivateTriggersResponse::ActivateTriggersResponse()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.ActivateTriggersResponse)
}

void ActivateTriggersResponse::InitAsDefaultInstance() {
}

ActivateTriggersResponse::ActivateTriggersResponse(const ActivateTriggersResponse& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.ActivateTriggersResponse)
}

void ActivateTriggersResponse::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ActivateTriggersResponse::~ActivateTriggersResponse() {
  // @@protoc_insertion_point(destructor:perfetto.protos.ActivateTriggersResponse)
  SharedDtor();
}

void ActivateTriggersResponse::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ActivateTriggersResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ActivateTriggersResponse& ActivateTriggersResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
#endif
  return *default_instance_;
}

ActivateTriggersResponse* ActivateTriggersResponse::default_instance_ = NULL;

ActivateTriggersResponse* ActivateTriggersResponse::New(::google::protobuf::Arena* arena) const {
  ActivateTriggersResponse* n = new ActivateTriggersResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ActivateTriggersResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.ActivateTriggersResponse)
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool ActivateTriggersResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForActivateTriggersResponse, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.ActivateTriggersResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.ActivateTriggersResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.ActivateTriggersResponse)
  return false;
#undef DO_
}

void ActivateTriggersResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.ActivateTriggersResponse)
  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.ActivateTriggersResponse)
}

int ActivateTriggersResponse::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.ActivateTriggersResponse)
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ActivateTriggersResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ActivateTriggersResponse*>(&from));
}

void ActivateTriggersResponse::MergeFrom(const ActivateTriggersResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.ActivateTriggersResponse)
  if (GOOGLE_PREDICT_FALSE(&from == this)) producer_port_pb_MergeFromFail(__LINE__);
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void ActivateTriggersResponse::CopyFrom(const ActivateTriggersResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.ActivateTriggersResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ActivateTriggersResponse::IsInitialized() const {

  return true;
}

void ActivateTriggersResponse::Swap(ActivateTriggersResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ActivateTriggersResponse::InternalSwap(ActivateTriggersResponse* other) {
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ActivateTriggersResponse::GetTypeName() const {
  return "perfetto.protos.ActivateTriggersResponse";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ActivateTriggersResponse

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForGetAsyncCommandRequest(
    GetAsyncCommandRequest* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GetAsyncCommandRequest::GetAsyncCommandRequest()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.GetAsyncCommandRequest)
}

void GetAsyncCommandRequest::InitAsDefaultInstance() {
}

GetAsyncCommandRequest::GetAsyncCommandRequest(const GetAsyncCommandRequest& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.GetAsyncCommandRequest)
}

void GetAsyncCommandRequest::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetAsyncCommandRequest::~GetAsyncCommandRequest() {
  // @@protoc_insertion_point(destructor:perfetto.protos.GetAsyncCommandRequest)
  SharedDtor();
}

void GetAsyncCommandRequest::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetAsyncCommandRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetAsyncCommandRequest& GetAsyncCommandRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
#endif
  return *default_instance_;
}

GetAsyncCommandRequest* GetAsyncCommandRequest::default_instance_ = NULL;

GetAsyncCommandRequest* GetAsyncCommandRequest::New(::google::protobuf::Arena* arena) const {
  GetAsyncCommandRequest* n = new GetAsyncCommandRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GetAsyncCommandRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.GetAsyncCommandRequest)
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool GetAsyncCommandRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForGetAsyncCommandRequest, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.GetAsyncCommandRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.GetAsyncCommandRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.GetAsyncCommandRequest)
  return false;
#undef DO_
}

void GetAsyncCommandRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.GetAsyncCommandRequest)
  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.GetAsyncCommandRequest)
}

int GetAsyncCommandRequest::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.GetAsyncCommandRequest)
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetAsyncCommandRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetAsyncCommandRequest*>(&from));
}

void GetAsyncCommandRequest::MergeFrom(const GetAsyncCommandRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.GetAsyncCommandRequest)
  if (GOOGLE_PREDICT_FALSE(&from == this)) producer_port_pb_MergeFromFail(__LINE__);
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void GetAsyncCommandRequest::CopyFrom(const GetAsyncCommandRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.GetAsyncCommandRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetAsyncCommandRequest::IsInitialized() const {

  return true;
}

void GetAsyncCommandRequest::Swap(GetAsyncCommandRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GetAsyncCommandRequest::InternalSwap(GetAsyncCommandRequest* other) {
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string GetAsyncCommandRequest::GetTypeName() const {
  return "perfetto.protos.GetAsyncCommandRequest";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// GetAsyncCommandRequest

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForGetAsyncCommandResponse(
    GetAsyncCommandResponse* ptr) {
  return ptr->mutable_unknown_fields();
}

static ::std::string* MutableUnknownFieldsForGetAsyncCommandResponse_SetupDataSource(
    GetAsyncCommandResponse_SetupDataSource* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GetAsyncCommandResponse_SetupDataSource::kNewInstanceIdFieldNumber;
const int GetAsyncCommandResponse_SetupDataSource::kConfigFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GetAsyncCommandResponse_SetupDataSource::GetAsyncCommandResponse_SetupDataSource()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.GetAsyncCommandResponse.SetupDataSource)
}

void GetAsyncCommandResponse_SetupDataSource::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  config_ = const_cast< ::perfetto::protos::DataSourceConfig*>(
      ::perfetto::protos::DataSourceConfig::internal_default_instance());
#else
  config_ = const_cast< ::perfetto::protos::DataSourceConfig*>(&::perfetto::protos::DataSourceConfig::default_instance());
#endif
}

GetAsyncCommandResponse_SetupDataSource::GetAsyncCommandResponse_SetupDataSource(const GetAsyncCommandResponse_SetupDataSource& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.GetAsyncCommandResponse.SetupDataSource)
}

void GetAsyncCommandResponse_SetupDataSource::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  new_instance_id_ = GOOGLE_ULONGLONG(0);
  config_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetAsyncCommandResponse_SetupDataSource::~GetAsyncCommandResponse_SetupDataSource() {
  // @@protoc_insertion_point(destructor:perfetto.protos.GetAsyncCommandResponse.SetupDataSource)
  SharedDtor();
}

void GetAsyncCommandResponse_SetupDataSource::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete config_;
  }
}

void GetAsyncCommandResponse_SetupDataSource::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetAsyncCommandResponse_SetupDataSource& GetAsyncCommandResponse_SetupDataSource::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
#endif
  return *default_instance_;
}

GetAsyncCommandResponse_SetupDataSource* GetAsyncCommandResponse_SetupDataSource::default_instance_ = NULL;

GetAsyncCommandResponse_SetupDataSource* GetAsyncCommandResponse_SetupDataSource::New(::google::protobuf::Arena* arena) const {
  GetAsyncCommandResponse_SetupDataSource* n = new GetAsyncCommandResponse_SetupDataSource;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GetAsyncCommandResponse_SetupDataSource::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.GetAsyncCommandResponse.SetupDataSource)
  if (_has_bits_[0 / 32] & 3u) {
    new_instance_id_ = GOOGLE_ULONGLONG(0);
    if (has_config()) {
      if (config_ != NULL) config_->::perfetto::protos::DataSourceConfig::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool GetAsyncCommandResponse_SetupDataSource::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForGetAsyncCommandResponse_SetupDataSource, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.GetAsyncCommandResponse.SetupDataSource)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 new_instance_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &new_instance_id_)));
          set_has_new_instance_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_config;
        break;
      }

      // optional .perfetto.protos.DataSourceConfig config = 2;
      case 2: {
        if (tag == 18) {
         parse_config:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_config()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.GetAsyncCommandResponse.SetupDataSource)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.GetAsyncCommandResponse.SetupDataSource)
  return false;
#undef DO_
}

void GetAsyncCommandResponse_SetupDataSource::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.GetAsyncCommandResponse.SetupDataSource)
  // optional uint64 new_instance_id = 1;
  if (has_new_instance_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->new_instance_id(), output);
  }

  // optional .perfetto.protos.DataSourceConfig config = 2;
  if (has_config()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *this->config_, output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.GetAsyncCommandResponse.SetupDataSource)
}

int GetAsyncCommandResponse_SetupDataSource::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.GetAsyncCommandResponse.SetupDataSource)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional uint64 new_instance_id = 1;
    if (has_new_instance_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->new_instance_id());
    }

    // optional .perfetto.protos.DataSourceConfig config = 2;
    if (has_config()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->config_);
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetAsyncCommandResponse_SetupDataSource::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetAsyncCommandResponse_SetupDataSource*>(&from));
}

void GetAsyncCommandResponse_SetupDataSource::MergeFrom(const GetAsyncCommandResponse_SetupDataSource& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.GetAsyncCommandResponse.SetupDataSource)
  if (GOOGLE_PREDICT_FALSE(&from == this)) producer_port_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_new_instance_id()) {
      set_new_instance_id(from.new_instance_id());
    }
    if (from.has_config()) {
      mutable_config()->::perfetto::protos::DataSourceConfig::MergeFrom(from.config());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void GetAsyncCommandResponse_SetupDataSource::CopyFrom(const GetAsyncCommandResponse_SetupDataSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.GetAsyncCommandResponse.SetupDataSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetAsyncCommandResponse_SetupDataSource::IsInitialized() const {

  return true;
}

void GetAsyncCommandResponse_SetupDataSource::Swap(GetAsyncCommandResponse_SetupDataSource* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GetAsyncCommandResponse_SetupDataSource::InternalSwap(GetAsyncCommandResponse_SetupDataSource* other) {
  std::swap(new_instance_id_, other->new_instance_id_);
  std::swap(config_, other->config_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string GetAsyncCommandResponse_SetupDataSource::GetTypeName() const {
  return "perfetto.protos.GetAsyncCommandResponse.SetupDataSource";
}


// -------------------------------------------------------------------

static ::std::string* MutableUnknownFieldsForGetAsyncCommandResponse_StartDataSource(
    GetAsyncCommandResponse_StartDataSource* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GetAsyncCommandResponse_StartDataSource::kNewInstanceIdFieldNumber;
const int GetAsyncCommandResponse_StartDataSource::kConfigFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GetAsyncCommandResponse_StartDataSource::GetAsyncCommandResponse_StartDataSource()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.GetAsyncCommandResponse.StartDataSource)
}

void GetAsyncCommandResponse_StartDataSource::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  config_ = const_cast< ::perfetto::protos::DataSourceConfig*>(
      ::perfetto::protos::DataSourceConfig::internal_default_instance());
#else
  config_ = const_cast< ::perfetto::protos::DataSourceConfig*>(&::perfetto::protos::DataSourceConfig::default_instance());
#endif
}

GetAsyncCommandResponse_StartDataSource::GetAsyncCommandResponse_StartDataSource(const GetAsyncCommandResponse_StartDataSource& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.GetAsyncCommandResponse.StartDataSource)
}

void GetAsyncCommandResponse_StartDataSource::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  new_instance_id_ = GOOGLE_ULONGLONG(0);
  config_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetAsyncCommandResponse_StartDataSource::~GetAsyncCommandResponse_StartDataSource() {
  // @@protoc_insertion_point(destructor:perfetto.protos.GetAsyncCommandResponse.StartDataSource)
  SharedDtor();
}

void GetAsyncCommandResponse_StartDataSource::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete config_;
  }
}

void GetAsyncCommandResponse_StartDataSource::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetAsyncCommandResponse_StartDataSource& GetAsyncCommandResponse_StartDataSource::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
#endif
  return *default_instance_;
}

GetAsyncCommandResponse_StartDataSource* GetAsyncCommandResponse_StartDataSource::default_instance_ = NULL;

GetAsyncCommandResponse_StartDataSource* GetAsyncCommandResponse_StartDataSource::New(::google::protobuf::Arena* arena) const {
  GetAsyncCommandResponse_StartDataSource* n = new GetAsyncCommandResponse_StartDataSource;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GetAsyncCommandResponse_StartDataSource::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.GetAsyncCommandResponse.StartDataSource)
  if (_has_bits_[0 / 32] & 3u) {
    new_instance_id_ = GOOGLE_ULONGLONG(0);
    if (has_config()) {
      if (config_ != NULL) config_->::perfetto::protos::DataSourceConfig::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool GetAsyncCommandResponse_StartDataSource::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForGetAsyncCommandResponse_StartDataSource, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.GetAsyncCommandResponse.StartDataSource)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 new_instance_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &new_instance_id_)));
          set_has_new_instance_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_config;
        break;
      }

      // optional .perfetto.protos.DataSourceConfig config = 2;
      case 2: {
        if (tag == 18) {
         parse_config:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_config()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.GetAsyncCommandResponse.StartDataSource)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.GetAsyncCommandResponse.StartDataSource)
  return false;
#undef DO_
}

void GetAsyncCommandResponse_StartDataSource::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.GetAsyncCommandResponse.StartDataSource)
  // optional uint64 new_instance_id = 1;
  if (has_new_instance_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->new_instance_id(), output);
  }

  // optional .perfetto.protos.DataSourceConfig config = 2;
  if (has_config()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *this->config_, output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.GetAsyncCommandResponse.StartDataSource)
}

int GetAsyncCommandResponse_StartDataSource::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.GetAsyncCommandResponse.StartDataSource)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional uint64 new_instance_id = 1;
    if (has_new_instance_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->new_instance_id());
    }

    // optional .perfetto.protos.DataSourceConfig config = 2;
    if (has_config()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->config_);
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetAsyncCommandResponse_StartDataSource::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetAsyncCommandResponse_StartDataSource*>(&from));
}

void GetAsyncCommandResponse_StartDataSource::MergeFrom(const GetAsyncCommandResponse_StartDataSource& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.GetAsyncCommandResponse.StartDataSource)
  if (GOOGLE_PREDICT_FALSE(&from == this)) producer_port_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_new_instance_id()) {
      set_new_instance_id(from.new_instance_id());
    }
    if (from.has_config()) {
      mutable_config()->::perfetto::protos::DataSourceConfig::MergeFrom(from.config());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void GetAsyncCommandResponse_StartDataSource::CopyFrom(const GetAsyncCommandResponse_StartDataSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.GetAsyncCommandResponse.StartDataSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetAsyncCommandResponse_StartDataSource::IsInitialized() const {

  return true;
}

void GetAsyncCommandResponse_StartDataSource::Swap(GetAsyncCommandResponse_StartDataSource* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GetAsyncCommandResponse_StartDataSource::InternalSwap(GetAsyncCommandResponse_StartDataSource* other) {
  std::swap(new_instance_id_, other->new_instance_id_);
  std::swap(config_, other->config_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string GetAsyncCommandResponse_StartDataSource::GetTypeName() const {
  return "perfetto.protos.GetAsyncCommandResponse.StartDataSource";
}


// -------------------------------------------------------------------

static ::std::string* MutableUnknownFieldsForGetAsyncCommandResponse_StopDataSource(
    GetAsyncCommandResponse_StopDataSource* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GetAsyncCommandResponse_StopDataSource::kInstanceIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GetAsyncCommandResponse_StopDataSource::GetAsyncCommandResponse_StopDataSource()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.GetAsyncCommandResponse.StopDataSource)
}

void GetAsyncCommandResponse_StopDataSource::InitAsDefaultInstance() {
}

GetAsyncCommandResponse_StopDataSource::GetAsyncCommandResponse_StopDataSource(const GetAsyncCommandResponse_StopDataSource& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.GetAsyncCommandResponse.StopDataSource)
}

void GetAsyncCommandResponse_StopDataSource::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  instance_id_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetAsyncCommandResponse_StopDataSource::~GetAsyncCommandResponse_StopDataSource() {
  // @@protoc_insertion_point(destructor:perfetto.protos.GetAsyncCommandResponse.StopDataSource)
  SharedDtor();
}

void GetAsyncCommandResponse_StopDataSource::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetAsyncCommandResponse_StopDataSource::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetAsyncCommandResponse_StopDataSource& GetAsyncCommandResponse_StopDataSource::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
#endif
  return *default_instance_;
}

GetAsyncCommandResponse_StopDataSource* GetAsyncCommandResponse_StopDataSource::default_instance_ = NULL;

GetAsyncCommandResponse_StopDataSource* GetAsyncCommandResponse_StopDataSource::New(::google::protobuf::Arena* arena) const {
  GetAsyncCommandResponse_StopDataSource* n = new GetAsyncCommandResponse_StopDataSource;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GetAsyncCommandResponse_StopDataSource::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.GetAsyncCommandResponse.StopDataSource)
  instance_id_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool GetAsyncCommandResponse_StopDataSource::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForGetAsyncCommandResponse_StopDataSource, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.GetAsyncCommandResponse.StopDataSource)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 instance_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &instance_id_)));
          set_has_instance_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.GetAsyncCommandResponse.StopDataSource)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.GetAsyncCommandResponse.StopDataSource)
  return false;
#undef DO_
}

void GetAsyncCommandResponse_StopDataSource::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.GetAsyncCommandResponse.StopDataSource)
  // optional uint64 instance_id = 1;
  if (has_instance_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->instance_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.GetAsyncCommandResponse.StopDataSource)
}

int GetAsyncCommandResponse_StopDataSource::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.GetAsyncCommandResponse.StopDataSource)
  int total_size = 0;

  // optional uint64 instance_id = 1;
  if (has_instance_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->instance_id());
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetAsyncCommandResponse_StopDataSource::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetAsyncCommandResponse_StopDataSource*>(&from));
}

void GetAsyncCommandResponse_StopDataSource::MergeFrom(const GetAsyncCommandResponse_StopDataSource& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.GetAsyncCommandResponse.StopDataSource)
  if (GOOGLE_PREDICT_FALSE(&from == this)) producer_port_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_instance_id()) {
      set_instance_id(from.instance_id());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void GetAsyncCommandResponse_StopDataSource::CopyFrom(const GetAsyncCommandResponse_StopDataSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.GetAsyncCommandResponse.StopDataSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetAsyncCommandResponse_StopDataSource::IsInitialized() const {

  return true;
}

void GetAsyncCommandResponse_StopDataSource::Swap(GetAsyncCommandResponse_StopDataSource* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GetAsyncCommandResponse_StopDataSource::InternalSwap(GetAsyncCommandResponse_StopDataSource* other) {
  std::swap(instance_id_, other->instance_id_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string GetAsyncCommandResponse_StopDataSource::GetTypeName() const {
  return "perfetto.protos.GetAsyncCommandResponse.StopDataSource";
}


// -------------------------------------------------------------------

static ::std::string* MutableUnknownFieldsForGetAsyncCommandResponse_SetupTracing(
    GetAsyncCommandResponse_SetupTracing* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GetAsyncCommandResponse_SetupTracing::kSharedBufferPageSizeKbFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GetAsyncCommandResponse_SetupTracing::GetAsyncCommandResponse_SetupTracing()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.GetAsyncCommandResponse.SetupTracing)
}

void GetAsyncCommandResponse_SetupTracing::InitAsDefaultInstance() {
}

GetAsyncCommandResponse_SetupTracing::GetAsyncCommandResponse_SetupTracing(const GetAsyncCommandResponse_SetupTracing& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.GetAsyncCommandResponse.SetupTracing)
}

void GetAsyncCommandResponse_SetupTracing::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  shared_buffer_page_size_kb_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetAsyncCommandResponse_SetupTracing::~GetAsyncCommandResponse_SetupTracing() {
  // @@protoc_insertion_point(destructor:perfetto.protos.GetAsyncCommandResponse.SetupTracing)
  SharedDtor();
}

void GetAsyncCommandResponse_SetupTracing::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetAsyncCommandResponse_SetupTracing::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetAsyncCommandResponse_SetupTracing& GetAsyncCommandResponse_SetupTracing::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
#endif
  return *default_instance_;
}

GetAsyncCommandResponse_SetupTracing* GetAsyncCommandResponse_SetupTracing::default_instance_ = NULL;

GetAsyncCommandResponse_SetupTracing* GetAsyncCommandResponse_SetupTracing::New(::google::protobuf::Arena* arena) const {
  GetAsyncCommandResponse_SetupTracing* n = new GetAsyncCommandResponse_SetupTracing;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GetAsyncCommandResponse_SetupTracing::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.GetAsyncCommandResponse.SetupTracing)
  shared_buffer_page_size_kb_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool GetAsyncCommandResponse_SetupTracing::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForGetAsyncCommandResponse_SetupTracing, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.GetAsyncCommandResponse.SetupTracing)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 shared_buffer_page_size_kb = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &shared_buffer_page_size_kb_)));
          set_has_shared_buffer_page_size_kb();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.GetAsyncCommandResponse.SetupTracing)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.GetAsyncCommandResponse.SetupTracing)
  return false;
#undef DO_
}

void GetAsyncCommandResponse_SetupTracing::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.GetAsyncCommandResponse.SetupTracing)
  // optional uint32 shared_buffer_page_size_kb = 1;
  if (has_shared_buffer_page_size_kb()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->shared_buffer_page_size_kb(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.GetAsyncCommandResponse.SetupTracing)
}

int GetAsyncCommandResponse_SetupTracing::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.GetAsyncCommandResponse.SetupTracing)
  int total_size = 0;

  // optional uint32 shared_buffer_page_size_kb = 1;
  if (has_shared_buffer_page_size_kb()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->shared_buffer_page_size_kb());
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetAsyncCommandResponse_SetupTracing::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetAsyncCommandResponse_SetupTracing*>(&from));
}

void GetAsyncCommandResponse_SetupTracing::MergeFrom(const GetAsyncCommandResponse_SetupTracing& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.GetAsyncCommandResponse.SetupTracing)
  if (GOOGLE_PREDICT_FALSE(&from == this)) producer_port_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_shared_buffer_page_size_kb()) {
      set_shared_buffer_page_size_kb(from.shared_buffer_page_size_kb());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void GetAsyncCommandResponse_SetupTracing::CopyFrom(const GetAsyncCommandResponse_SetupTracing& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.GetAsyncCommandResponse.SetupTracing)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetAsyncCommandResponse_SetupTracing::IsInitialized() const {

  return true;
}

void GetAsyncCommandResponse_SetupTracing::Swap(GetAsyncCommandResponse_SetupTracing* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GetAsyncCommandResponse_SetupTracing::InternalSwap(GetAsyncCommandResponse_SetupTracing* other) {
  std::swap(shared_buffer_page_size_kb_, other->shared_buffer_page_size_kb_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string GetAsyncCommandResponse_SetupTracing::GetTypeName() const {
  return "perfetto.protos.GetAsyncCommandResponse.SetupTracing";
}


// -------------------------------------------------------------------

static ::std::string* MutableUnknownFieldsForGetAsyncCommandResponse_Flush(
    GetAsyncCommandResponse_Flush* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GetAsyncCommandResponse_Flush::kDataSourceIdsFieldNumber;
const int GetAsyncCommandResponse_Flush::kRequestIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GetAsyncCommandResponse_Flush::GetAsyncCommandResponse_Flush()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.GetAsyncCommandResponse.Flush)
}

void GetAsyncCommandResponse_Flush::InitAsDefaultInstance() {
}

GetAsyncCommandResponse_Flush::GetAsyncCommandResponse_Flush(const GetAsyncCommandResponse_Flush& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.GetAsyncCommandResponse.Flush)
}

void GetAsyncCommandResponse_Flush::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  request_id_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetAsyncCommandResponse_Flush::~GetAsyncCommandResponse_Flush() {
  // @@protoc_insertion_point(destructor:perfetto.protos.GetAsyncCommandResponse.Flush)
  SharedDtor();
}

void GetAsyncCommandResponse_Flush::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetAsyncCommandResponse_Flush::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetAsyncCommandResponse_Flush& GetAsyncCommandResponse_Flush::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
#endif
  return *default_instance_;
}

GetAsyncCommandResponse_Flush* GetAsyncCommandResponse_Flush::default_instance_ = NULL;

GetAsyncCommandResponse_Flush* GetAsyncCommandResponse_Flush::New(::google::protobuf::Arena* arena) const {
  GetAsyncCommandResponse_Flush* n = new GetAsyncCommandResponse_Flush;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GetAsyncCommandResponse_Flush::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.GetAsyncCommandResponse.Flush)
  request_id_ = GOOGLE_ULONGLONG(0);
  data_source_ids_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool GetAsyncCommandResponse_Flush::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForGetAsyncCommandResponse_Flush, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.GetAsyncCommandResponse.Flush)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint64 data_source_ids = 1;
      case 1: {
        if (tag == 8) {
         parse_data_source_ids:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 1, 8, input, this->mutable_data_source_ids())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, this->mutable_data_source_ids())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(8)) goto parse_data_source_ids;
        if (input->ExpectTag(16)) goto parse_request_id;
        break;
      }

      // optional uint64 request_id = 2;
      case 2: {
        if (tag == 16) {
         parse_request_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &request_id_)));
          set_has_request_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.GetAsyncCommandResponse.Flush)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.GetAsyncCommandResponse.Flush)
  return false;
#undef DO_
}

void GetAsyncCommandResponse_Flush::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.GetAsyncCommandResponse.Flush)
  // repeated uint64 data_source_ids = 1;
  for (int i = 0; i < this->data_source_ids_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(
      1, this->data_source_ids(i), output);
  }

  // optional uint64 request_id = 2;
  if (has_request_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->request_id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.GetAsyncCommandResponse.Flush)
}

int GetAsyncCommandResponse_Flush::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.GetAsyncCommandResponse.Flush)
  int total_size = 0;

  // optional uint64 request_id = 2;
  if (has_request_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->request_id());
  }

  // repeated uint64 data_source_ids = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->data_source_ids_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt64Size(this->data_source_ids(i));
    }
    total_size += 1 * this->data_source_ids_size() + data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetAsyncCommandResponse_Flush::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetAsyncCommandResponse_Flush*>(&from));
}

void GetAsyncCommandResponse_Flush::MergeFrom(const GetAsyncCommandResponse_Flush& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.GetAsyncCommandResponse.Flush)
  if (GOOGLE_PREDICT_FALSE(&from == this)) producer_port_pb_MergeFromFail(__LINE__);
  data_source_ids_.MergeFrom(from.data_source_ids_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_request_id()) {
      set_request_id(from.request_id());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void GetAsyncCommandResponse_Flush::CopyFrom(const GetAsyncCommandResponse_Flush& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.GetAsyncCommandResponse.Flush)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetAsyncCommandResponse_Flush::IsInitialized() const {

  return true;
}

void GetAsyncCommandResponse_Flush::Swap(GetAsyncCommandResponse_Flush* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GetAsyncCommandResponse_Flush::InternalSwap(GetAsyncCommandResponse_Flush* other) {
  data_source_ids_.UnsafeArenaSwap(&other->data_source_ids_);
  std::swap(request_id_, other->request_id_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string GetAsyncCommandResponse_Flush::GetTypeName() const {
  return "perfetto.protos.GetAsyncCommandResponse.Flush";
}


// -------------------------------------------------------------------

static ::std::string* MutableUnknownFieldsForGetAsyncCommandResponse_ClearIncrementalState(
    GetAsyncCommandResponse_ClearIncrementalState* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GetAsyncCommandResponse_ClearIncrementalState::kDataSourceIdsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GetAsyncCommandResponse_ClearIncrementalState::GetAsyncCommandResponse_ClearIncrementalState()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.GetAsyncCommandResponse.ClearIncrementalState)
}

void GetAsyncCommandResponse_ClearIncrementalState::InitAsDefaultInstance() {
}

GetAsyncCommandResponse_ClearIncrementalState::GetAsyncCommandResponse_ClearIncrementalState(const GetAsyncCommandResponse_ClearIncrementalState& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.GetAsyncCommandResponse.ClearIncrementalState)
}

void GetAsyncCommandResponse_ClearIncrementalState::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetAsyncCommandResponse_ClearIncrementalState::~GetAsyncCommandResponse_ClearIncrementalState() {
  // @@protoc_insertion_point(destructor:perfetto.protos.GetAsyncCommandResponse.ClearIncrementalState)
  SharedDtor();
}

void GetAsyncCommandResponse_ClearIncrementalState::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetAsyncCommandResponse_ClearIncrementalState::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetAsyncCommandResponse_ClearIncrementalState& GetAsyncCommandResponse_ClearIncrementalState::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
#endif
  return *default_instance_;
}

GetAsyncCommandResponse_ClearIncrementalState* GetAsyncCommandResponse_ClearIncrementalState::default_instance_ = NULL;

GetAsyncCommandResponse_ClearIncrementalState* GetAsyncCommandResponse_ClearIncrementalState::New(::google::protobuf::Arena* arena) const {
  GetAsyncCommandResponse_ClearIncrementalState* n = new GetAsyncCommandResponse_ClearIncrementalState;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GetAsyncCommandResponse_ClearIncrementalState::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.GetAsyncCommandResponse.ClearIncrementalState)
  data_source_ids_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool GetAsyncCommandResponse_ClearIncrementalState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForGetAsyncCommandResponse_ClearIncrementalState, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.GetAsyncCommandResponse.ClearIncrementalState)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint64 data_source_ids = 1;
      case 1: {
        if (tag == 8) {
         parse_data_source_ids:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 1, 8, input, this->mutable_data_source_ids())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, this->mutable_data_source_ids())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(8)) goto parse_data_source_ids;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.GetAsyncCommandResponse.ClearIncrementalState)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.GetAsyncCommandResponse.ClearIncrementalState)
  return false;
#undef DO_
}

void GetAsyncCommandResponse_ClearIncrementalState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.GetAsyncCommandResponse.ClearIncrementalState)
  // repeated uint64 data_source_ids = 1;
  for (int i = 0; i < this->data_source_ids_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(
      1, this->data_source_ids(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.GetAsyncCommandResponse.ClearIncrementalState)
}

int GetAsyncCommandResponse_ClearIncrementalState::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.GetAsyncCommandResponse.ClearIncrementalState)
  int total_size = 0;

  // repeated uint64 data_source_ids = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->data_source_ids_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt64Size(this->data_source_ids(i));
    }
    total_size += 1 * this->data_source_ids_size() + data_size;
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetAsyncCommandResponse_ClearIncrementalState::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetAsyncCommandResponse_ClearIncrementalState*>(&from));
}

void GetAsyncCommandResponse_ClearIncrementalState::MergeFrom(const GetAsyncCommandResponse_ClearIncrementalState& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.GetAsyncCommandResponse.ClearIncrementalState)
  if (GOOGLE_PREDICT_FALSE(&from == this)) producer_port_pb_MergeFromFail(__LINE__);
  data_source_ids_.MergeFrom(from.data_source_ids_);
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void GetAsyncCommandResponse_ClearIncrementalState::CopyFrom(const GetAsyncCommandResponse_ClearIncrementalState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.GetAsyncCommandResponse.ClearIncrementalState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetAsyncCommandResponse_ClearIncrementalState::IsInitialized() const {

  return true;
}

void GetAsyncCommandResponse_ClearIncrementalState::Swap(GetAsyncCommandResponse_ClearIncrementalState* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GetAsyncCommandResponse_ClearIncrementalState::InternalSwap(GetAsyncCommandResponse_ClearIncrementalState* other) {
  data_source_ids_.UnsafeArenaSwap(&other->data_source_ids_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string GetAsyncCommandResponse_ClearIncrementalState::GetTypeName() const {
  return "perfetto.protos.GetAsyncCommandResponse.ClearIncrementalState";
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GetAsyncCommandResponse::kSetupTracingFieldNumber;
const int GetAsyncCommandResponse::kSetupDataSourceFieldNumber;
const int GetAsyncCommandResponse::kStartDataSourceFieldNumber;
const int GetAsyncCommandResponse::kStopDataSourceFieldNumber;
const int GetAsyncCommandResponse::kFlushFieldNumber;
const int GetAsyncCommandResponse::kClearIncrementalStateFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GetAsyncCommandResponse::GetAsyncCommandResponse()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.GetAsyncCommandResponse)
}

void GetAsyncCommandResponse::InitAsDefaultInstance() {
}

GetAsyncCommandResponse::GetAsyncCommandResponse(const GetAsyncCommandResponse& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.GetAsyncCommandResponse)
}

void GetAsyncCommandResponse::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  clear_has_cmd();
}

GetAsyncCommandResponse::~GetAsyncCommandResponse() {
  // @@protoc_insertion_point(destructor:perfetto.protos.GetAsyncCommandResponse)
  SharedDtor();
}

void GetAsyncCommandResponse::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (has_cmd()) {
    clear_cmd();
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetAsyncCommandResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetAsyncCommandResponse& GetAsyncCommandResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2fipc_2fproducer_5fport_2eproto();
#endif
  return *default_instance_;
}

GetAsyncCommandResponse* GetAsyncCommandResponse::default_instance_ = NULL;

GetAsyncCommandResponse* GetAsyncCommandResponse::New(::google::protobuf::Arena* arena) const {
  GetAsyncCommandResponse* n = new GetAsyncCommandResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void GetAsyncCommandResponse::clear_cmd() {
// @@protoc_insertion_point(one_of_clear_start:perfetto.protos.GetAsyncCommandResponse)
  switch(cmd_case()) {
    case kSetupTracing: {
      delete cmd_.setup_tracing_;
      break;
    }
    case kSetupDataSource: {
      delete cmd_.setup_data_source_;
      break;
    }
    case kStartDataSource: {
      delete cmd_.start_data_source_;
      break;
    }
    case kStopDataSource: {
      delete cmd_.stop_data_source_;
      break;
    }
    case kFlush: {
      delete cmd_.flush_;
      break;
    }
    case kClearIncrementalState: {
      delete cmd_.clear_incremental_state_;
      break;
    }
    case CMD_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = CMD_NOT_SET;
}


void GetAsyncCommandResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.GetAsyncCommandResponse)
  clear_cmd();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool GetAsyncCommandResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForGetAsyncCommandResponse, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.GetAsyncCommandResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .perfetto.protos.GetAsyncCommandResponse.StartDataSource start_data_source = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_start_data_source()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_stop_data_source;
        break;
      }

      // optional .perfetto.protos.GetAsyncCommandResponse.StopDataSource stop_data_source = 2;
      case 2: {
        if (tag == 18) {
         parse_stop_data_source:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_stop_data_source()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_setup_tracing;
        break;
      }

      // optional .perfetto.protos.GetAsyncCommandResponse.SetupTracing setup_tracing = 3;
      case 3: {
        if (tag == 26) {
         parse_setup_tracing:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_setup_tracing()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_flush;
        break;
      }

      // optional .perfetto.protos.GetAsyncCommandResponse.Flush flush = 5;
      case 5: {
        if (tag == 42) {
         parse_flush:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_flush()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_setup_data_source;
        break;
      }

      // optional .perfetto.protos.GetAsyncCommandResponse.SetupDataSource setup_data_source = 6;
      case 6: {
        if (tag == 50) {
         parse_setup_data_source:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_setup_data_source()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_clear_incremental_state;
        break;
      }

      // optional .perfetto.protos.GetAsyncCommandResponse.ClearIncrementalState clear_incremental_state = 7;
      case 7: {
        if (tag == 58) {
         parse_clear_incremental_state:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_clear_incremental_state()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.GetAsyncCommandResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.GetAsyncCommandResponse)
  return false;
#undef DO_
}

void GetAsyncCommandResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.GetAsyncCommandResponse)
  // optional .perfetto.protos.GetAsyncCommandResponse.StartDataSource start_data_source = 1;
  if (has_start_data_source()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *cmd_.start_data_source_, output);
  }

  // optional .perfetto.protos.GetAsyncCommandResponse.StopDataSource stop_data_source = 2;
  if (has_stop_data_source()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *cmd_.stop_data_source_, output);
  }

  // optional .perfetto.protos.GetAsyncCommandResponse.SetupTracing setup_tracing = 3;
  if (has_setup_tracing()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *cmd_.setup_tracing_, output);
  }

  // optional .perfetto.protos.GetAsyncCommandResponse.Flush flush = 5;
  if (has_flush()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, *cmd_.flush_, output);
  }

  // optional .perfetto.protos.GetAsyncCommandResponse.SetupDataSource setup_data_source = 6;
  if (has_setup_data_source()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, *cmd_.setup_data_source_, output);
  }

  // optional .perfetto.protos.GetAsyncCommandResponse.ClearIncrementalState clear_incremental_state = 7;
  if (has_clear_incremental_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, *cmd_.clear_incremental_state_, output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.GetAsyncCommandResponse)
}

int GetAsyncCommandResponse::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.GetAsyncCommandResponse)
  int total_size = 0;

  switch (cmd_case()) {
    // optional .perfetto.protos.GetAsyncCommandResponse.SetupTracing setup_tracing = 3;
    case kSetupTracing: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *cmd_.setup_tracing_);
      break;
    }
    // optional .perfetto.protos.GetAsyncCommandResponse.SetupDataSource setup_data_source = 6;
    case kSetupDataSource: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *cmd_.setup_data_source_);
      break;
    }
    // optional .perfetto.protos.GetAsyncCommandResponse.StartDataSource start_data_source = 1;
    case kStartDataSource: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *cmd_.start_data_source_);
      break;
    }
    // optional .perfetto.protos.GetAsyncCommandResponse.StopDataSource stop_data_source = 2;
    case kStopDataSource: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *cmd_.stop_data_source_);
      break;
    }
    // optional .perfetto.protos.GetAsyncCommandResponse.Flush flush = 5;
    case kFlush: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *cmd_.flush_);
      break;
    }
    // optional .perfetto.protos.GetAsyncCommandResponse.ClearIncrementalState clear_incremental_state = 7;
    case kClearIncrementalState: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *cmd_.clear_incremental_state_);
      break;
    }
    case CMD_NOT_SET: {
      break;
    }
  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetAsyncCommandResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetAsyncCommandResponse*>(&from));
}

void GetAsyncCommandResponse::MergeFrom(const GetAsyncCommandResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.GetAsyncCommandResponse)
  if (GOOGLE_PREDICT_FALSE(&from == this)) producer_port_pb_MergeFromFail(__LINE__);
  switch (from.cmd_case()) {
    case kSetupTracing: {
      mutable_setup_tracing()->::perfetto::protos::GetAsyncCommandResponse_SetupTracing::MergeFrom(from.setup_tracing());
      break;
    }
    case kSetupDataSource: {
      mutable_setup_data_source()->::perfetto::protos::GetAsyncCommandResponse_SetupDataSource::MergeFrom(from.setup_data_source());
      break;
    }
    case kStartDataSource: {
      mutable_start_data_source()->::perfetto::protos::GetAsyncCommandResponse_StartDataSource::MergeFrom(from.start_data_source());
      break;
    }
    case kStopDataSource: {
      mutable_stop_data_source()->::perfetto::protos::GetAsyncCommandResponse_StopDataSource::MergeFrom(from.stop_data_source());
      break;
    }
    case kFlush: {
      mutable_flush()->::perfetto::protos::GetAsyncCommandResponse_Flush::MergeFrom(from.flush());
      break;
    }
    case kClearIncrementalState: {
      mutable_clear_incremental_state()->::perfetto::protos::GetAsyncCommandResponse_ClearIncrementalState::MergeFrom(from.clear_incremental_state());
      break;
    }
    case CMD_NOT_SET: {
      break;
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void GetAsyncCommandResponse::CopyFrom(const GetAsyncCommandResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.GetAsyncCommandResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetAsyncCommandResponse::IsInitialized() const {

  return true;
}

void GetAsyncCommandResponse::Swap(GetAsyncCommandResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GetAsyncCommandResponse::InternalSwap(GetAsyncCommandResponse* other) {
  std::swap(cmd_, other->cmd_);
  std::swap(_oneof_case_[0], other->_oneof_case_[0]);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string GetAsyncCommandResponse::GetTypeName() const {
  return "perfetto.protos.GetAsyncCommandResponse";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// GetAsyncCommandResponse_SetupDataSource

// optional uint64 new_instance_id = 1;
bool GetAsyncCommandResponse_SetupDataSource::has_new_instance_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void GetAsyncCommandResponse_SetupDataSource::set_has_new_instance_id() {
  _has_bits_[0] |= 0x00000001u;
}
void GetAsyncCommandResponse_SetupDataSource::clear_has_new_instance_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void GetAsyncCommandResponse_SetupDataSource::clear_new_instance_id() {
  new_instance_id_ = GOOGLE_ULONGLONG(0);
  clear_has_new_instance_id();
}
 ::google::protobuf::uint64 GetAsyncCommandResponse_SetupDataSource::new_instance_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.SetupDataSource.new_instance_id)
  return new_instance_id_;
}
 void GetAsyncCommandResponse_SetupDataSource::set_new_instance_id(::google::protobuf::uint64 value) {
  set_has_new_instance_id();
  new_instance_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.GetAsyncCommandResponse.SetupDataSource.new_instance_id)
}

// optional .perfetto.protos.DataSourceConfig config = 2;
bool GetAsyncCommandResponse_SetupDataSource::has_config() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void GetAsyncCommandResponse_SetupDataSource::set_has_config() {
  _has_bits_[0] |= 0x00000002u;
}
void GetAsyncCommandResponse_SetupDataSource::clear_has_config() {
  _has_bits_[0] &= ~0x00000002u;
}
void GetAsyncCommandResponse_SetupDataSource::clear_config() {
  if (config_ != NULL) config_->::perfetto::protos::DataSourceConfig::Clear();
  clear_has_config();
}
const ::perfetto::protos::DataSourceConfig& GetAsyncCommandResponse_SetupDataSource::config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.SetupDataSource.config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return config_ != NULL ? *config_ : *default_instance().config_;
#else
  return config_ != NULL ? *config_ : *default_instance_->config_;
#endif
}
::perfetto::protos::DataSourceConfig* GetAsyncCommandResponse_SetupDataSource::mutable_config() {
  set_has_config();
  if (config_ == NULL) {
    config_ = new ::perfetto::protos::DataSourceConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GetAsyncCommandResponse.SetupDataSource.config)
  return config_;
}
::perfetto::protos::DataSourceConfig* GetAsyncCommandResponse_SetupDataSource::release_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.GetAsyncCommandResponse.SetupDataSource.config)
  clear_has_config();
  ::perfetto::protos::DataSourceConfig* temp = config_;
  config_ = NULL;
  return temp;
}
void GetAsyncCommandResponse_SetupDataSource::set_allocated_config(::perfetto::protos::DataSourceConfig* config) {
  delete config_;
  config_ = config;
  if (config) {
    set_has_config();
  } else {
    clear_has_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.GetAsyncCommandResponse.SetupDataSource.config)
}

// -------------------------------------------------------------------

// GetAsyncCommandResponse_StartDataSource

// optional uint64 new_instance_id = 1;
bool GetAsyncCommandResponse_StartDataSource::has_new_instance_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void GetAsyncCommandResponse_StartDataSource::set_has_new_instance_id() {
  _has_bits_[0] |= 0x00000001u;
}
void GetAsyncCommandResponse_StartDataSource::clear_has_new_instance_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void GetAsyncCommandResponse_StartDataSource::clear_new_instance_id() {
  new_instance_id_ = GOOGLE_ULONGLONG(0);
  clear_has_new_instance_id();
}
 ::google::protobuf::uint64 GetAsyncCommandResponse_StartDataSource::new_instance_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.StartDataSource.new_instance_id)
  return new_instance_id_;
}
 void GetAsyncCommandResponse_StartDataSource::set_new_instance_id(::google::protobuf::uint64 value) {
  set_has_new_instance_id();
  new_instance_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.GetAsyncCommandResponse.StartDataSource.new_instance_id)
}

// optional .perfetto.protos.DataSourceConfig config = 2;
bool GetAsyncCommandResponse_StartDataSource::has_config() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void GetAsyncCommandResponse_StartDataSource::set_has_config() {
  _has_bits_[0] |= 0x00000002u;
}
void GetAsyncCommandResponse_StartDataSource::clear_has_config() {
  _has_bits_[0] &= ~0x00000002u;
}
void GetAsyncCommandResponse_StartDataSource::clear_config() {
  if (config_ != NULL) config_->::perfetto::protos::DataSourceConfig::Clear();
  clear_has_config();
}
const ::perfetto::protos::DataSourceConfig& GetAsyncCommandResponse_StartDataSource::config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.StartDataSource.config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return config_ != NULL ? *config_ : *default_instance().config_;
#else
  return config_ != NULL ? *config_ : *default_instance_->config_;
#endif
}
::perfetto::protos::DataSourceConfig* GetAsyncCommandResponse_StartDataSource::mutable_config() {
  set_has_config();
  if (config_ == NULL) {
    config_ = new ::perfetto::protos::DataSourceConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GetAsyncCommandResponse.StartDataSource.config)
  return config_;
}
::perfetto::protos::DataSourceConfig* GetAsyncCommandResponse_StartDataSource::release_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.GetAsyncCommandResponse.StartDataSource.config)
  clear_has_config();
  ::perfetto::protos::DataSourceConfig* temp = config_;
  config_ = NULL;
  return temp;
}
void GetAsyncCommandResponse_StartDataSource::set_allocated_config(::perfetto::protos::DataSourceConfig* config) {
  delete config_;
  config_ = config;
  if (config) {
    set_has_config();
  } else {
    clear_has_config();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.GetAsyncCommandResponse.StartDataSource.config)
}

// -------------------------------------------------------------------

// GetAsyncCommandResponse_StopDataSource

// optional uint64 instance_id = 1;
bool GetAsyncCommandResponse_StopDataSource::has_instance_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void GetAsyncCommandResponse_StopDataSource::set_has_instance_id() {
  _has_bits_[0] |= 0x00000001u;
}
void GetAsyncCommandResponse_StopDataSource::clear_has_instance_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void GetAsyncCommandResponse_StopDataSource::clear_instance_id() {
  instance_id_ = GOOGLE_ULONGLONG(0);
  clear_has_instance_id();
}
 ::google::protobuf::uint64 GetAsyncCommandResponse_StopDataSource::instance_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.StopDataSource.instance_id)
  return instance_id_;
}
 void GetAsyncCommandResponse_StopDataSource::set_instance_id(::google::protobuf::uint64 value) {
  set_has_instance_id();
  instance_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.GetAsyncCommandResponse.StopDataSource.instance_id)
}

// -------------------------------------------------------------------

// GetAsyncCommandResponse_SetupTracing

// optional uint32 shared_buffer_page_size_kb = 1;
bool GetAsyncCommandResponse_SetupTracing::has_shared_buffer_page_size_kb() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void GetAsyncCommandResponse_SetupTracing::set_has_shared_buffer_page_size_kb() {
  _has_bits_[0] |= 0x00000001u;
}
void GetAsyncCommandResponse_SetupTracing::clear_has_shared_buffer_page_size_kb() {
  _has_bits_[0] &= ~0x00000001u;
}
void GetAsyncCommandResponse_SetupTracing::clear_shared_buffer_page_size_kb() {
  shared_buffer_page_size_kb_ = 0u;
  clear_has_shared_buffer_page_size_kb();
}
 ::google::protobuf::uint32 GetAsyncCommandResponse_SetupTracing::shared_buffer_page_size_kb() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.SetupTracing.shared_buffer_page_size_kb)
  return shared_buffer_page_size_kb_;
}
 void GetAsyncCommandResponse_SetupTracing::set_shared_buffer_page_size_kb(::google::protobuf::uint32 value) {
  set_has_shared_buffer_page_size_kb();
  shared_buffer_page_size_kb_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.GetAsyncCommandResponse.SetupTracing.shared_buffer_page_size_kb)
}

// -------------------------------------------------------------------

// GetAsyncCommandResponse_Flush

// repeated uint64 data_source_ids = 1;
int GetAsyncCommandResponse_Flush::data_source_ids_size() const {
  return data_source_ids_.size();
}
void GetAsyncCommandResponse_Flush::clear_data_source_ids() {
  data_source_ids_.Clear();
}
 ::google::protobuf::uint64 GetAsyncCommandResponse_Flush::data_source_ids(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.Flush.data_source_ids)
  return data_source_ids_.Get(index);
}
 void GetAsyncCommandResponse_Flush::set_data_source_ids(int index, ::google::protobuf::uint64 value) {
  data_source_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.GetAsyncCommandResponse.Flush.data_source_ids)
}
 void GetAsyncCommandResponse_Flush::add_data_source_ids(::google::protobuf::uint64 value) {
  data_source_ids_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.GetAsyncCommandResponse.Flush.data_source_ids)
}
 const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
GetAsyncCommandResponse_Flush::data_source_ids() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.GetAsyncCommandResponse.Flush.data_source_ids)
  return data_source_ids_;
}
 ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
GetAsyncCommandResponse_Flush::mutable_data_source_ids() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.GetAsyncCommandResponse.Flush.data_source_ids)
  return &data_source_ids_;
}

// optional uint64 request_id = 2;
bool GetAsyncCommandResponse_Flush::has_request_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void GetAsyncCommandResponse_Flush::set_has_request_id() {
  _has_bits_[0] |= 0x00000002u;
}
void GetAsyncCommandResponse_Flush::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000002u;
}
void GetAsyncCommandResponse_Flush::clear_request_id() {
  request_id_ = GOOGLE_ULONGLONG(0);
  clear_has_request_id();
}
 ::google::protobuf::uint64 GetAsyncCommandResponse_Flush::request_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.Flush.request_id)
  return request_id_;
}
 void GetAsyncCommandResponse_Flush::set_request_id(::google::protobuf::uint64 value) {
  set_has_request_id();
  request_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.GetAsyncCommandResponse.Flush.request_id)
}

// -------------------------------------------------------------------

// GetAsyncCommandResponse_ClearIncrementalState

// repeated uint64 data_source_ids = 1;
int GetAsyncCommandResponse_ClearIncrementalState::data_source_ids_size() const {
  return data_source_ids_.size();
}
void GetAsyncCommandResponse_ClearIncrementalState::clear_data_source_ids() {
  data_source_ids_.Clear();
}
 ::google::protobuf::uint64 GetAsyncCommandResponse_ClearIncrementalState::data_source_ids(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.ClearIncrementalState.data_source_ids)
  return data_source_ids_.Get(index);
}
 void GetAsyncCommandResponse_ClearIncrementalState::set_data_source_ids(int index, ::google::protobuf::uint64 value) {
  data_source_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:perfetto.protos.GetAsyncCommandResponse.ClearIncrementalState.data_source_ids)
}
 void GetAsyncCommandResponse_ClearIncrementalState::add_data_source_ids(::google::protobuf::uint64 value) {
  data_source_ids_.Add(value);
  // @@protoc_insertion_point(field_add:perfetto.protos.GetAsyncCommandResponse.ClearIncrementalState.data_source_ids)
}
 const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
GetAsyncCommandResponse_ClearIncrementalState::data_source_ids() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.GetAsyncCommandResponse.ClearIncrementalState.data_source_ids)
  return data_source_ids_;
}
 ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
GetAsyncCommandResponse_ClearIncrementalState::mutable_data_source_ids() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.GetAsyncCommandResponse.ClearIncrementalState.data_source_ids)
  return &data_source_ids_;
}

// -------------------------------------------------------------------

// GetAsyncCommandResponse

// optional .perfetto.protos.GetAsyncCommandResponse.SetupTracing setup_tracing = 3;
bool GetAsyncCommandResponse::has_setup_tracing() const {
  return cmd_case() == kSetupTracing;
}
void GetAsyncCommandResponse::set_has_setup_tracing() {
  _oneof_case_[0] = kSetupTracing;
}
void GetAsyncCommandResponse::clear_setup_tracing() {
  if (has_setup_tracing()) {
    delete cmd_.setup_tracing_;
    clear_has_cmd();
  }
}
 const ::perfetto::protos::GetAsyncCommandResponse_SetupTracing& GetAsyncCommandResponse::setup_tracing() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.setup_tracing)
  return has_setup_tracing()
      ? *cmd_.setup_tracing_
      : ::perfetto::protos::GetAsyncCommandResponse_SetupTracing::default_instance();
}
::perfetto::protos::GetAsyncCommandResponse_SetupTracing* GetAsyncCommandResponse::mutable_setup_tracing() {
  if (!has_setup_tracing()) {
    clear_cmd();
    set_has_setup_tracing();
    cmd_.setup_tracing_ = new ::perfetto::protos::GetAsyncCommandResponse_SetupTracing;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GetAsyncCommandResponse.setup_tracing)
  return cmd_.setup_tracing_;
}
::perfetto::protos::GetAsyncCommandResponse_SetupTracing* GetAsyncCommandResponse::release_setup_tracing() {
  // @@protoc_insertion_point(field_release:perfetto.protos.GetAsyncCommandResponse.setup_tracing)
  if (has_setup_tracing()) {
    clear_has_cmd();
    ::perfetto::protos::GetAsyncCommandResponse_SetupTracing* temp = cmd_.setup_tracing_;
    cmd_.setup_tracing_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void GetAsyncCommandResponse::set_allocated_setup_tracing(::perfetto::protos::GetAsyncCommandResponse_SetupTracing* setup_tracing) {
  clear_cmd();
  if (setup_tracing) {
    set_has_setup_tracing();
    cmd_.setup_tracing_ = setup_tracing;
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.GetAsyncCommandResponse.setup_tracing)
}

// optional .perfetto.protos.GetAsyncCommandResponse.SetupDataSource setup_data_source = 6;
bool GetAsyncCommandResponse::has_setup_data_source() const {
  return cmd_case() == kSetupDataSource;
}
void GetAsyncCommandResponse::set_has_setup_data_source() {
  _oneof_case_[0] = kSetupDataSource;
}
void GetAsyncCommandResponse::clear_setup_data_source() {
  if (has_setup_data_source()) {
    delete cmd_.setup_data_source_;
    clear_has_cmd();
  }
}
 const ::perfetto::protos::GetAsyncCommandResponse_SetupDataSource& GetAsyncCommandResponse::setup_data_source() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.setup_data_source)
  return has_setup_data_source()
      ? *cmd_.setup_data_source_
      : ::perfetto::protos::GetAsyncCommandResponse_SetupDataSource::default_instance();
}
::perfetto::protos::GetAsyncCommandResponse_SetupDataSource* GetAsyncCommandResponse::mutable_setup_data_source() {
  if (!has_setup_data_source()) {
    clear_cmd();
    set_has_setup_data_source();
    cmd_.setup_data_source_ = new ::perfetto::protos::GetAsyncCommandResponse_SetupDataSource;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GetAsyncCommandResponse.setup_data_source)
  return cmd_.setup_data_source_;
}
::perfetto::protos::GetAsyncCommandResponse_SetupDataSource* GetAsyncCommandResponse::release_setup_data_source() {
  // @@protoc_insertion_point(field_release:perfetto.protos.GetAsyncCommandResponse.setup_data_source)
  if (has_setup_data_source()) {
    clear_has_cmd();
    ::perfetto::protos::GetAsyncCommandResponse_SetupDataSource* temp = cmd_.setup_data_source_;
    cmd_.setup_data_source_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void GetAsyncCommandResponse::set_allocated_setup_data_source(::perfetto::protos::GetAsyncCommandResponse_SetupDataSource* setup_data_source) {
  clear_cmd();
  if (setup_data_source) {
    set_has_setup_data_source();
    cmd_.setup_data_source_ = setup_data_source;
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.GetAsyncCommandResponse.setup_data_source)
}

// optional .perfetto.protos.GetAsyncCommandResponse.StartDataSource start_data_source = 1;
bool GetAsyncCommandResponse::has_start_data_source() const {
  return cmd_case() == kStartDataSource;
}
void GetAsyncCommandResponse::set_has_start_data_source() {
  _oneof_case_[0] = kStartDataSource;
}
void GetAsyncCommandResponse::clear_start_data_source() {
  if (has_start_data_source()) {
    delete cmd_.start_data_source_;
    clear_has_cmd();
  }
}
 const ::perfetto::protos::GetAsyncCommandResponse_StartDataSource& GetAsyncCommandResponse::start_data_source() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.start_data_source)
  return has_start_data_source()
      ? *cmd_.start_data_source_
      : ::perfetto::protos::GetAsyncCommandResponse_StartDataSource::default_instance();
}
::perfetto::protos::GetAsyncCommandResponse_StartDataSource* GetAsyncCommandResponse::mutable_start_data_source() {
  if (!has_start_data_source()) {
    clear_cmd();
    set_has_start_data_source();
    cmd_.start_data_source_ = new ::perfetto::protos::GetAsyncCommandResponse_StartDataSource;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GetAsyncCommandResponse.start_data_source)
  return cmd_.start_data_source_;
}
::perfetto::protos::GetAsyncCommandResponse_StartDataSource* GetAsyncCommandResponse::release_start_data_source() {
  // @@protoc_insertion_point(field_release:perfetto.protos.GetAsyncCommandResponse.start_data_source)
  if (has_start_data_source()) {
    clear_has_cmd();
    ::perfetto::protos::GetAsyncCommandResponse_StartDataSource* temp = cmd_.start_data_source_;
    cmd_.start_data_source_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void GetAsyncCommandResponse::set_allocated_start_data_source(::perfetto::protos::GetAsyncCommandResponse_StartDataSource* start_data_source) {
  clear_cmd();
  if (start_data_source) {
    set_has_start_data_source();
    cmd_.start_data_source_ = start_data_source;
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.GetAsyncCommandResponse.start_data_source)
}

// optional .perfetto.protos.GetAsyncCommandResponse.StopDataSource stop_data_source = 2;
bool GetAsyncCommandResponse::has_stop_data_source() const {
  return cmd_case() == kStopDataSource;
}
void GetAsyncCommandResponse::set_has_stop_data_source() {
  _oneof_case_[0] = kStopDataSource;
}
void GetAsyncCommandResponse::clear_stop_data_source() {
  if (has_stop_data_source()) {
    delete cmd_.stop_data_source_;
    clear_has_cmd();
  }
}
 const ::perfetto::protos::GetAsyncCommandResponse_StopDataSource& GetAsyncCommandResponse::stop_data_source() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.stop_data_source)
  return has_stop_data_source()
      ? *cmd_.stop_data_source_
      : ::perfetto::protos::GetAsyncCommandResponse_StopDataSource::default_instance();
}
::perfetto::protos::GetAsyncCommandResponse_StopDataSource* GetAsyncCommandResponse::mutable_stop_data_source() {
  if (!has_stop_data_source()) {
    clear_cmd();
    set_has_stop_data_source();
    cmd_.stop_data_source_ = new ::perfetto::protos::GetAsyncCommandResponse_StopDataSource;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GetAsyncCommandResponse.stop_data_source)
  return cmd_.stop_data_source_;
}
::perfetto::protos::GetAsyncCommandResponse_StopDataSource* GetAsyncCommandResponse::release_stop_data_source() {
  // @@protoc_insertion_point(field_release:perfetto.protos.GetAsyncCommandResponse.stop_data_source)
  if (has_stop_data_source()) {
    clear_has_cmd();
    ::perfetto::protos::GetAsyncCommandResponse_StopDataSource* temp = cmd_.stop_data_source_;
    cmd_.stop_data_source_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void GetAsyncCommandResponse::set_allocated_stop_data_source(::perfetto::protos::GetAsyncCommandResponse_StopDataSource* stop_data_source) {
  clear_cmd();
  if (stop_data_source) {
    set_has_stop_data_source();
    cmd_.stop_data_source_ = stop_data_source;
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.GetAsyncCommandResponse.stop_data_source)
}

// optional .perfetto.protos.GetAsyncCommandResponse.Flush flush = 5;
bool GetAsyncCommandResponse::has_flush() const {
  return cmd_case() == kFlush;
}
void GetAsyncCommandResponse::set_has_flush() {
  _oneof_case_[0] = kFlush;
}
void GetAsyncCommandResponse::clear_flush() {
  if (has_flush()) {
    delete cmd_.flush_;
    clear_has_cmd();
  }
}
 const ::perfetto::protos::GetAsyncCommandResponse_Flush& GetAsyncCommandResponse::flush() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.flush)
  return has_flush()
      ? *cmd_.flush_
      : ::perfetto::protos::GetAsyncCommandResponse_Flush::default_instance();
}
::perfetto::protos::GetAsyncCommandResponse_Flush* GetAsyncCommandResponse::mutable_flush() {
  if (!has_flush()) {
    clear_cmd();
    set_has_flush();
    cmd_.flush_ = new ::perfetto::protos::GetAsyncCommandResponse_Flush;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GetAsyncCommandResponse.flush)
  return cmd_.flush_;
}
::perfetto::protos::GetAsyncCommandResponse_Flush* GetAsyncCommandResponse::release_flush() {
  // @@protoc_insertion_point(field_release:perfetto.protos.GetAsyncCommandResponse.flush)
  if (has_flush()) {
    clear_has_cmd();
    ::perfetto::protos::GetAsyncCommandResponse_Flush* temp = cmd_.flush_;
    cmd_.flush_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void GetAsyncCommandResponse::set_allocated_flush(::perfetto::protos::GetAsyncCommandResponse_Flush* flush) {
  clear_cmd();
  if (flush) {
    set_has_flush();
    cmd_.flush_ = flush;
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.GetAsyncCommandResponse.flush)
}

// optional .perfetto.protos.GetAsyncCommandResponse.ClearIncrementalState clear_incremental_state = 7;
bool GetAsyncCommandResponse::has_clear_incremental_state() const {
  return cmd_case() == kClearIncrementalState;
}
void GetAsyncCommandResponse::set_has_clear_incremental_state() {
  _oneof_case_[0] = kClearIncrementalState;
}
void GetAsyncCommandResponse::clear_clear_incremental_state() {
  if (has_clear_incremental_state()) {
    delete cmd_.clear_incremental_state_;
    clear_has_cmd();
  }
}
 const ::perfetto::protos::GetAsyncCommandResponse_ClearIncrementalState& GetAsyncCommandResponse::clear_incremental_state() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.GetAsyncCommandResponse.clear_incremental_state)
  return has_clear_incremental_state()
      ? *cmd_.clear_incremental_state_
      : ::perfetto::protos::GetAsyncCommandResponse_ClearIncrementalState::default_instance();
}
::perfetto::protos::GetAsyncCommandResponse_ClearIncrementalState* GetAsyncCommandResponse::mutable_clear_incremental_state() {
  if (!has_clear_incremental_state()) {
    clear_cmd();
    set_has_clear_incremental_state();
    cmd_.clear_incremental_state_ = new ::perfetto::protos::GetAsyncCommandResponse_ClearIncrementalState;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.GetAsyncCommandResponse.clear_incremental_state)
  return cmd_.clear_incremental_state_;
}
::perfetto::protos::GetAsyncCommandResponse_ClearIncrementalState* GetAsyncCommandResponse::release_clear_incremental_state() {
  // @@protoc_insertion_point(field_release:perfetto.protos.GetAsyncCommandResponse.clear_incremental_state)
  if (has_clear_incremental_state()) {
    clear_has_cmd();
    ::perfetto::protos::GetAsyncCommandResponse_ClearIncrementalState* temp = cmd_.clear_incremental_state_;
    cmd_.clear_incremental_state_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void GetAsyncCommandResponse::set_allocated_clear_incremental_state(::perfetto::protos::GetAsyncCommandResponse_ClearIncrementalState* clear_incremental_state) {
  clear_cmd();
  if (clear_incremental_state) {
    set_has_clear_incremental_state();
    cmd_.clear_incremental_state_ = clear_incremental_state;
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.GetAsyncCommandResponse.clear_incremental_state)
}

bool GetAsyncCommandResponse::has_cmd() const {
  return cmd_case() != CMD_NOT_SET;
}
void GetAsyncCommandResponse::clear_has_cmd() {
  _oneof_case_[0] = CMD_NOT_SET;
}
GetAsyncCommandResponse::CmdCase GetAsyncCommandResponse::cmd_case() const {
  return GetAsyncCommandResponse::CmdCase(_oneof_case_[0]);
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/ipc/producer_port.ipc.cc
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/ipc/producer_port.ipc.h
// DO NOT EDIT. Autogenerated by Perfetto IPC
#ifndef PERFETTO_PROTOS_PERFETTO_IPC_PRODUCER_PORT_PROTO_H_
#define PERFETTO_PROTOS_PERFETTO_IPC_PRODUCER_PORT_PROTO_H_

// gen_amalgamated expanded: #include "perfetto/ipc/producer_port.pb.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/deferred.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/service.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/service_descriptor.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/service_proxy.h"


namespace perfetto {
namespace protos {

class ProducerPort : public ::perfetto::ipc::Service {
 private:
  static ::perfetto::ipc::ServiceDescriptor* NewDescriptor();

 public:
  ~ProducerPort() override;

  static const ::perfetto::ipc::ServiceDescriptor& GetDescriptorStatic();

  // Service implementation.
  const ::perfetto::ipc::ServiceDescriptor& GetDescriptor() override;

  // Methods from the .proto file
  using DeferredInitializeConnectionResponse = ::perfetto::ipc::Deferred<InitializeConnectionResponse>;
  virtual void InitializeConnection(const InitializeConnectionRequest&, DeferredInitializeConnectionResponse) = 0;

  using DeferredRegisterDataSourceResponse = ::perfetto::ipc::Deferred<RegisterDataSourceResponse>;
  virtual void RegisterDataSource(const RegisterDataSourceRequest&, DeferredRegisterDataSourceResponse) = 0;

  using DeferredUnregisterDataSourceResponse = ::perfetto::ipc::Deferred<UnregisterDataSourceResponse>;
  virtual void UnregisterDataSource(const UnregisterDataSourceRequest&, DeferredUnregisterDataSourceResponse) = 0;

  using DeferredCommitDataResponse = ::perfetto::ipc::Deferred<CommitDataResponse>;
  virtual void CommitData(const CommitDataRequest&, DeferredCommitDataResponse) = 0;

  using DeferredGetAsyncCommandResponse = ::perfetto::ipc::Deferred<GetAsyncCommandResponse>;
  virtual void GetAsyncCommand(const GetAsyncCommandRequest&, DeferredGetAsyncCommandResponse) = 0;

  using DeferredRegisterTraceWriterResponse = ::perfetto::ipc::Deferred<RegisterTraceWriterResponse>;
  virtual void RegisterTraceWriter(const RegisterTraceWriterRequest&, DeferredRegisterTraceWriterResponse) = 0;

  using DeferredUnregisterTraceWriterResponse = ::perfetto::ipc::Deferred<UnregisterTraceWriterResponse>;
  virtual void UnregisterTraceWriter(const UnregisterTraceWriterRequest&, DeferredUnregisterTraceWriterResponse) = 0;

  using DeferredNotifyDataSourceStartedResponse = ::perfetto::ipc::Deferred<NotifyDataSourceStartedResponse>;
  virtual void NotifyDataSourceStarted(const NotifyDataSourceStartedRequest&, DeferredNotifyDataSourceStartedResponse) = 0;

  using DeferredNotifyDataSourceStoppedResponse = ::perfetto::ipc::Deferred<NotifyDataSourceStoppedResponse>;
  virtual void NotifyDataSourceStopped(const NotifyDataSourceStoppedRequest&, DeferredNotifyDataSourceStoppedResponse) = 0;

  using DeferredActivateTriggersResponse = ::perfetto::ipc::Deferred<ActivateTriggersResponse>;
  virtual void ActivateTriggers(const ActivateTriggersRequest&, DeferredActivateTriggersResponse) = 0;

};


class ProducerPortProxy : public ::perfetto::ipc::ServiceProxy {
 public:
   explicit ProducerPortProxy(::perfetto::ipc::ServiceProxy::EventListener*);
   ~ProducerPortProxy() override;

  // ServiceProxy implementation.
  const ::perfetto::ipc::ServiceDescriptor& GetDescriptor() override;

  // Methods from the .proto file
  using DeferredInitializeConnectionResponse = ::perfetto::ipc::Deferred<InitializeConnectionResponse>;
  void InitializeConnection(const InitializeConnectionRequest&, DeferredInitializeConnectionResponse, int fd = -1);

  using DeferredRegisterDataSourceResponse = ::perfetto::ipc::Deferred<RegisterDataSourceResponse>;
  void RegisterDataSource(const RegisterDataSourceRequest&, DeferredRegisterDataSourceResponse, int fd = -1);

  using DeferredUnregisterDataSourceResponse = ::perfetto::ipc::Deferred<UnregisterDataSourceResponse>;
  void UnregisterDataSource(const UnregisterDataSourceRequest&, DeferredUnregisterDataSourceResponse, int fd = -1);

  using DeferredCommitDataResponse = ::perfetto::ipc::Deferred<CommitDataResponse>;
  void CommitData(const CommitDataRequest&, DeferredCommitDataResponse, int fd = -1);

  using DeferredGetAsyncCommandResponse = ::perfetto::ipc::Deferred<GetAsyncCommandResponse>;
  void GetAsyncCommand(const GetAsyncCommandRequest&, DeferredGetAsyncCommandResponse, int fd = -1);

  using DeferredRegisterTraceWriterResponse = ::perfetto::ipc::Deferred<RegisterTraceWriterResponse>;
  void RegisterTraceWriter(const RegisterTraceWriterRequest&, DeferredRegisterTraceWriterResponse, int fd = -1);

  using DeferredUnregisterTraceWriterResponse = ::perfetto::ipc::Deferred<UnregisterTraceWriterResponse>;
  void UnregisterTraceWriter(const UnregisterTraceWriterRequest&, DeferredUnregisterTraceWriterResponse, int fd = -1);

  using DeferredNotifyDataSourceStartedResponse = ::perfetto::ipc::Deferred<NotifyDataSourceStartedResponse>;
  void NotifyDataSourceStarted(const NotifyDataSourceStartedRequest&, DeferredNotifyDataSourceStartedResponse, int fd = -1);

  using DeferredNotifyDataSourceStoppedResponse = ::perfetto::ipc::Deferred<NotifyDataSourceStoppedResponse>;
  void NotifyDataSourceStopped(const NotifyDataSourceStoppedRequest&, DeferredNotifyDataSourceStoppedResponse, int fd = -1);

  using DeferredActivateTriggersResponse = ::perfetto::ipc::Deferred<ActivateTriggersResponse>;
  void ActivateTriggers(const ActivateTriggersRequest&, DeferredActivateTriggersResponse, int fd = -1);

};

}  // namespace protos
}  // namespace perfetto

#endif  // PERFETTO_PROTOS_PERFETTO_IPC_PRODUCER_PORT_PROTO_H_
// DO NOT EDIT. Autogenerated by Perfetto IPC
// gen_amalgamated expanded: #include "perfetto/ipc/producer_port.ipc.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/codegen_helpers.h"

#include <memory>

namespace perfetto {
namespace protos {
::perfetto::ipc::ServiceDescriptor* ProducerPort::NewDescriptor() {
  auto* desc = new ::perfetto::ipc::ServiceDescriptor();
  desc->service_name = "ProducerPort";

  desc->methods.emplace_back(::perfetto::ipc::ServiceDescriptor::Method{
     "InitializeConnection",
     &_IPC_Decoder<InitializeConnectionRequest>,
     &_IPC_Decoder<InitializeConnectionResponse>,
     &_IPC_Invoker<ProducerPort, InitializeConnectionRequest, InitializeConnectionResponse, &ProducerPort::InitializeConnection>});

  desc->methods.emplace_back(::perfetto::ipc::ServiceDescriptor::Method{
     "RegisterDataSource",
     &_IPC_Decoder<RegisterDataSourceRequest>,
     &_IPC_Decoder<RegisterDataSourceResponse>,
     &_IPC_Invoker<ProducerPort, RegisterDataSourceRequest, RegisterDataSourceResponse, &ProducerPort::RegisterDataSource>});

  desc->methods.emplace_back(::perfetto::ipc::ServiceDescriptor::Method{
     "UnregisterDataSource",
     &_IPC_Decoder<UnregisterDataSourceRequest>,
     &_IPC_Decoder<UnregisterDataSourceResponse>,
     &_IPC_Invoker<ProducerPort, UnregisterDataSourceRequest, UnregisterDataSourceResponse, &ProducerPort::UnregisterDataSource>});

  desc->methods.emplace_back(::perfetto::ipc::ServiceDescriptor::Method{
     "CommitData",
     &_IPC_Decoder<CommitDataRequest>,
     &_IPC_Decoder<CommitDataResponse>,
     &_IPC_Invoker<ProducerPort, CommitDataRequest, CommitDataResponse, &ProducerPort::CommitData>});

  desc->methods.emplace_back(::perfetto::ipc::ServiceDescriptor::Method{
     "GetAsyncCommand",
     &_IPC_Decoder<GetAsyncCommandRequest>,
     &_IPC_Decoder<GetAsyncCommandResponse>,
     &_IPC_Invoker<ProducerPort, GetAsyncCommandRequest, GetAsyncCommandResponse, &ProducerPort::GetAsyncCommand>});

  desc->methods.emplace_back(::perfetto::ipc::ServiceDescriptor::Method{
     "RegisterTraceWriter",
     &_IPC_Decoder<RegisterTraceWriterRequest>,
     &_IPC_Decoder<RegisterTraceWriterResponse>,
     &_IPC_Invoker<ProducerPort, RegisterTraceWriterRequest, RegisterTraceWriterResponse, &ProducerPort::RegisterTraceWriter>});

  desc->methods.emplace_back(::perfetto::ipc::ServiceDescriptor::Method{
     "UnregisterTraceWriter",
     &_IPC_Decoder<UnregisterTraceWriterRequest>,
     &_IPC_Decoder<UnregisterTraceWriterResponse>,
     &_IPC_Invoker<ProducerPort, UnregisterTraceWriterRequest, UnregisterTraceWriterResponse, &ProducerPort::UnregisterTraceWriter>});

  desc->methods.emplace_back(::perfetto::ipc::ServiceDescriptor::Method{
     "NotifyDataSourceStarted",
     &_IPC_Decoder<NotifyDataSourceStartedRequest>,
     &_IPC_Decoder<NotifyDataSourceStartedResponse>,
     &_IPC_Invoker<ProducerPort, NotifyDataSourceStartedRequest, NotifyDataSourceStartedResponse, &ProducerPort::NotifyDataSourceStarted>});

  desc->methods.emplace_back(::perfetto::ipc::ServiceDescriptor::Method{
     "NotifyDataSourceStopped",
     &_IPC_Decoder<NotifyDataSourceStoppedRequest>,
     &_IPC_Decoder<NotifyDataSourceStoppedResponse>,
     &_IPC_Invoker<ProducerPort, NotifyDataSourceStoppedRequest, NotifyDataSourceStoppedResponse, &ProducerPort::NotifyDataSourceStopped>});

  desc->methods.emplace_back(::perfetto::ipc::ServiceDescriptor::Method{
     "ActivateTriggers",
     &_IPC_Decoder<ActivateTriggersRequest>,
     &_IPC_Decoder<ActivateTriggersResponse>,
     &_IPC_Invoker<ProducerPort, ActivateTriggersRequest, ActivateTriggersResponse, &ProducerPort::ActivateTriggers>});
  desc->methods.shrink_to_fit();
  return desc;
}


const ::perfetto::ipc::ServiceDescriptor& ProducerPort::GetDescriptorStatic() {
  static auto* instance = NewDescriptor();
  return *instance;
}

// Host-side definitions.
ProducerPort::~ProducerPort() = default;

const ::perfetto::ipc::ServiceDescriptor& ProducerPort::GetDescriptor() {
  return GetDescriptorStatic();
}

// Client-side definitions.
ProducerPortProxy::ProducerPortProxy(::perfetto::ipc::ServiceProxy::EventListener* event_listener)
    : ::perfetto::ipc::ServiceProxy(event_listener) {}

ProducerPortProxy::~ProducerPortProxy() = default;

const ::perfetto::ipc::ServiceDescriptor& ProducerPortProxy::GetDescriptor() {
  return ProducerPort::GetDescriptorStatic();
}

void ProducerPortProxy::InitializeConnection(const InitializeConnectionRequest& request, DeferredInitializeConnectionResponse reply, int fd) {
  BeginInvoke("InitializeConnection", request, ::perfetto::ipc::DeferredBase(std::move(reply)),
              fd);
}

void ProducerPortProxy::RegisterDataSource(const RegisterDataSourceRequest& request, DeferredRegisterDataSourceResponse reply, int fd) {
  BeginInvoke("RegisterDataSource", request, ::perfetto::ipc::DeferredBase(std::move(reply)),
              fd);
}

void ProducerPortProxy::UnregisterDataSource(const UnregisterDataSourceRequest& request, DeferredUnregisterDataSourceResponse reply, int fd) {
  BeginInvoke("UnregisterDataSource", request, ::perfetto::ipc::DeferredBase(std::move(reply)),
              fd);
}

void ProducerPortProxy::CommitData(const CommitDataRequest& request, DeferredCommitDataResponse reply, int fd) {
  BeginInvoke("CommitData", request, ::perfetto::ipc::DeferredBase(std::move(reply)),
              fd);
}

void ProducerPortProxy::GetAsyncCommand(const GetAsyncCommandRequest& request, DeferredGetAsyncCommandResponse reply, int fd) {
  BeginInvoke("GetAsyncCommand", request, ::perfetto::ipc::DeferredBase(std::move(reply)),
              fd);
}

void ProducerPortProxy::RegisterTraceWriter(const RegisterTraceWriterRequest& request, DeferredRegisterTraceWriterResponse reply, int fd) {
  BeginInvoke("RegisterTraceWriter", request, ::perfetto::ipc::DeferredBase(std::move(reply)),
              fd);
}

void ProducerPortProxy::UnregisterTraceWriter(const UnregisterTraceWriterRequest& request, DeferredUnregisterTraceWriterResponse reply, int fd) {
  BeginInvoke("UnregisterTraceWriter", request, ::perfetto::ipc::DeferredBase(std::move(reply)),
              fd);
}

void ProducerPortProxy::NotifyDataSourceStarted(const NotifyDataSourceStartedRequest& request, DeferredNotifyDataSourceStartedResponse reply, int fd) {
  BeginInvoke("NotifyDataSourceStarted", request, ::perfetto::ipc::DeferredBase(std::move(reply)),
              fd);
}

void ProducerPortProxy::NotifyDataSourceStopped(const NotifyDataSourceStoppedRequest& request, DeferredNotifyDataSourceStoppedResponse reply, int fd) {
  BeginInvoke("NotifyDataSourceStopped", request, ::perfetto::ipc::DeferredBase(std::move(reply)),
              fd);
}

void ProducerPortProxy::ActivateTriggers(const ActivateTriggersRequest& request, DeferredActivateTriggersResponse reply, int fd) {
  BeginInvoke("ActivateTriggers", request, ::perfetto::ipc::DeferredBase(std::move(reply)),
              fd);
}
}  // namespace protos
}  // namespace perfetto
// gen_amalgamated begin source: src/protozero/message.cc
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"

#include <type_traits>

// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/protozero/message_handle.h"

#if __BYTE_ORDER__ != __ORDER_LITTLE_ENDIAN__
// The memcpy() for float and double below needs to be adjusted if we want to
// support big endian CPUs. There doesn't seem to be a compelling need today.
#error Unimplemented for big endian archs.
#endif

namespace protozero {

// static
constexpr uint32_t Message::kMaxNestingDepth;

// Do NOT put any code in the constructor or use default initialization.
// Use the Reset() method below instead. See the header for the reason why.

// This method is called to initialize both root and nested messages.
void Message::Reset(ScatteredStreamWriter* stream_writer) {
// Older versions of libstdcxx don't have is_trivially_constructible.
#if !defined(__GLIBCXX__) || __GLIBCXX__ >= 20170516
  static_assert(std::is_trivially_constructible<Message>::value,
                "Message must be trivially constructible");
#endif

  static_assert(std::is_trivially_destructible<Message>::value,
                "Message must be trivially destructible");

  static_assert(
      sizeof(Message::nested_messages_arena_) >=
          kMaxNestingDepth *
              (sizeof(Message) - sizeof(Message::nested_messages_arena_)),
      "Message::nested_messages_arena_ is too small");

  stream_writer_ = stream_writer;
  size_ = 0;
  size_field_ = nullptr;
  size_already_written_ = 0;
  nested_message_ = nullptr;
  nesting_depth_ = 0;
  finalized_ = false;
#if PERFETTO_DCHECK_IS_ON()
  handle_ = nullptr;
  generation_++;
#endif
}

void Message::AppendString(uint32_t field_id, const char* str) {
  AppendBytes(field_id, str, strlen(str));
}

void Message::AppendBytes(uint32_t field_id, const void* src, size_t size) {
  if (nested_message_)
    EndNestedMessage();

  PERFETTO_DCHECK(size < proto_utils::kMaxMessageLength);
  // Write the proto preamble (field id, type and length of the field).
  uint8_t buffer[proto_utils::kMaxSimpleFieldEncodedSize];
  uint8_t* pos = buffer;
  pos = proto_utils::WriteVarInt(proto_utils::MakeTagLengthDelimited(field_id),
                                 pos);
  pos = proto_utils::WriteVarInt(static_cast<uint32_t>(size), pos);
  WriteToStream(buffer, pos);

  const uint8_t* src_u8 = reinterpret_cast<const uint8_t*>(src);
  WriteToStream(src_u8, src_u8 + size);
}

size_t Message::AppendScatteredBytes(uint32_t field_id,
                                     ContiguousMemoryRange* ranges,
                                     size_t num_ranges) {
  size_t size = 0;
  for (size_t i = 0; i < num_ranges; ++i) {
    size += ranges[i].size();
  }

  PERFETTO_DCHECK(size < proto_utils::kMaxMessageLength);

  uint8_t buffer[proto_utils::kMaxSimpleFieldEncodedSize];
  uint8_t* pos = buffer;
  pos = proto_utils::WriteVarInt(proto_utils::MakeTagLengthDelimited(field_id),
                                 pos);
  pos = proto_utils::WriteVarInt(static_cast<uint32_t>(size), pos);
  WriteToStream(buffer, pos);

  for (size_t i = 0; i < num_ranges; ++i) {
    auto& range = ranges[i];
    WriteToStream(range.begin, range.end);
  }

  return size;
}

uint32_t Message::Finalize() {
  if (finalized_)
    return size_;

  if (nested_message_)
    EndNestedMessage();

  // Write the length of the nested message a posteriori, using a leading-zero
  // redundant varint encoding.
  if (size_field_) {
    PERFETTO_DCHECK(!finalized_);
    PERFETTO_DCHECK(size_ < proto_utils::kMaxMessageLength);
    PERFETTO_DCHECK(size_ >= size_already_written_);
    proto_utils::WriteRedundantVarInt(size_ - size_already_written_,
                                      size_field_);
    size_field_ = nullptr;
  }

  finalized_ = true;
#if PERFETTO_DCHECK_IS_ON()
  if (handle_)
    handle_->reset_message();
#endif

  return size_;
}

void Message::BeginNestedMessageInternal(uint32_t field_id, Message* message) {
  if (nested_message_)
    EndNestedMessage();

  // Write the proto preamble for the nested message.
  uint8_t data[proto_utils::kMaxTagEncodedSize];
  uint8_t* data_end = proto_utils::WriteVarInt(
      proto_utils::MakeTagLengthDelimited(field_id), data);
  WriteToStream(data, data_end);

  message->Reset(stream_writer_);
  PERFETTO_CHECK(nesting_depth_ < kMaxNestingDepth);
  message->nesting_depth_ = nesting_depth_ + 1;

  // The length of the nested message cannot be known upfront. So right now
  // just reserve the bytes to encode the size after the nested message is done.
  message->set_size_field(
      stream_writer_->ReserveBytes(proto_utils::kMessageLengthFieldSize));
  size_ += proto_utils::kMessageLengthFieldSize;
  nested_message_ = message;
}

void Message::EndNestedMessage() {
  size_ += nested_message_->Finalize();
  nested_message_ = nullptr;
}

}  // namespace protozero
// gen_amalgamated begin source: src/protozero/message_handle.cc
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "perfetto/protozero/message_handle.h"

#include <utility>

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"

namespace protozero {

MessageHandleBase::FinalizationListener::~FinalizationListener() {}

MessageHandleBase::MessageHandleBase(Message* message) : message_(message) {
#if PERFETTO_DCHECK_IS_ON()
  generation_ = message_ ? message->generation_ : 0;
  if (message_)
    message_->set_handle(this);
#endif
}

MessageHandleBase::~MessageHandleBase() {
  if (message_) {
#if PERFETTO_DCHECK_IS_ON()
    PERFETTO_DCHECK(generation_ == message_->generation_);
#endif
    FinalizeMessage();
  }
}

MessageHandleBase::MessageHandleBase(MessageHandleBase&& other) noexcept {
  Move(std::move(other));
}

MessageHandleBase& MessageHandleBase::operator=(MessageHandleBase&& other) {
  // If the current handle was pointing to a message and is being reset to a new
  // one, finalize the old message. However, if the other message is the same as
  // the one we point to, don't finalize.
  if (message_ && message_ != other.message_)
    FinalizeMessage();
  Move(std::move(other));
  return *this;
}

void MessageHandleBase::Move(MessageHandleBase&& other) {
  message_ = other.message_;
  other.message_ = nullptr;
  listener_ = other.listener_;
  other.listener_ = nullptr;
#if PERFETTO_DCHECK_IS_ON()
  if (message_) {
    generation_ = message_->generation_;
    message_->set_handle(this);
  }
#endif
}

}  // namespace protozero
// gen_amalgamated begin source: src/protozero/proto_decoder.cc
// gen_amalgamated begin header: include/perfetto/protozero/proto_decoder.h
// gen_amalgamated begin header: include/perfetto/protozero/field.h
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_PROTOZERO_FIELD_H_
#define INCLUDE_PERFETTO_PROTOZERO_FIELD_H_

#include <stdint.h>

#include <string>

// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/protozero/contiguous_memory_range.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace protozero {

struct ConstBytes {
  const uint8_t* data;
  size_t size;
};

struct ConstChars {
  // Allow implicit conversion to perfetto's base::StringView without depending
  // on perfetto/base or viceversa.
  static constexpr bool kConvertibleToStringView = true;
  std::string ToStdString() const { return std::string(data, size); }

  const char* data;
  size_t size;
};

// A protobuf field decoded by the protozero proto decoders. It exposes
// convenience accessors with minimal debug checks.
// This class is used both by the iterator-based ProtoDecoder and by the
// one-shot TypedProtoDecoder.
// If the field is not valid the accessors consistently return zero-integers or
// null strings.
class Field {
 public:
  inline bool valid() const { return id_ != 0; }
  inline uint16_t id() const { return id_; }
  explicit inline operator bool() const { return valid(); }

  inline proto_utils::ProtoWireType type() const {
    auto res = static_cast<proto_utils::ProtoWireType>(type_);
    PERFETTO_DCHECK(res == proto_utils::ProtoWireType::kVarInt ||
                    res == proto_utils::ProtoWireType::kLengthDelimited ||
                    res == proto_utils::ProtoWireType::kFixed32 ||
                    res == proto_utils::ProtoWireType::kFixed64);
    return res;
  }

  inline bool as_bool() const {
    PERFETTO_DCHECK(!valid() || type() == proto_utils::ProtoWireType::kVarInt);
    return static_cast<bool>(int_value_);
  }

  inline uint32_t as_uint32() const {
    PERFETTO_DCHECK(!valid() || type() == proto_utils::ProtoWireType::kVarInt ||
                    type() == proto_utils::ProtoWireType::kFixed32);
    return static_cast<uint32_t>(int_value_);
  }

  inline int32_t as_int32() const {
    PERFETTO_DCHECK(!valid() || type() == proto_utils::ProtoWireType::kVarInt ||
                    type() == proto_utils::ProtoWireType::kFixed32);
    return static_cast<int32_t>(int_value_);
  }

  inline uint64_t as_uint64() const {
    PERFETTO_DCHECK(!valid() || type() == proto_utils::ProtoWireType::kVarInt ||
                    type() == proto_utils::ProtoWireType::kFixed32 ||
                    type() == proto_utils::ProtoWireType::kFixed64);
    return int_value_;
  }

  inline int64_t as_int64() const {
    PERFETTO_DCHECK(!valid() || type() == proto_utils::ProtoWireType::kVarInt ||
                    type() == proto_utils::ProtoWireType::kFixed32 ||
                    type() == proto_utils::ProtoWireType::kFixed64);
    return static_cast<int64_t>(int_value_);
  }

  inline float as_float() const {
    PERFETTO_DCHECK(!valid() || type() == proto_utils::ProtoWireType::kFixed32);
    float res;
    uint32_t value32 = static_cast<uint32_t>(int_value_);
    memcpy(&res, &value32, sizeof(res));
    return res;
  }

  inline double as_double() const {
    PERFETTO_DCHECK(!valid() || type() == proto_utils::ProtoWireType::kFixed64);
    double res;
    memcpy(&res, &int_value_, sizeof(res));
    return res;
  }

  inline ConstChars as_string() const {
    PERFETTO_DCHECK(!valid() ||
                    type() == proto_utils::ProtoWireType::kLengthDelimited);
    return ConstChars{reinterpret_cast<const char*>(data()), size_};
  }

  inline std::string as_std_string() const { return as_string().ToStdString(); }

  inline ConstBytes as_bytes() const {
    PERFETTO_DCHECK(!valid() ||
                    type() == proto_utils::ProtoWireType::kLengthDelimited);
    return ConstBytes{data(), size_};
  }

  inline const uint8_t* data() const {
    PERFETTO_DCHECK(!valid() ||
                    type() == proto_utils::ProtoWireType::kLengthDelimited);
    return reinterpret_cast<const uint8_t*>(int_value_);
  }

  inline size_t size() const {
    PERFETTO_DCHECK(!valid() ||
                    type() == proto_utils::ProtoWireType::kLengthDelimited);
    return size_;
  }

  inline uint64_t raw_int_value() const { return int_value_; }

  inline void initialize(uint16_t id,
                         uint8_t type,
                         uint64_t int_value,
                         uint32_t size) {
    id_ = id;
    type_ = type;
    int_value_ = int_value;
    size_ = size;
  }

 private:
  // Fields are deliberately not initialized to keep the class trivially
  // constructible. It makes a large perf difference for ProtoDecoder.

  uint64_t int_value_;  // In kLengthDelimited this contains the data() addr.
  uint32_t size_;       // Only valid when when type == kLengthDelimited.
  uint16_t id_;         // Proto field ordinal.
  uint8_t type_;        // proto_utils::ProtoWireType.
};

// The Field struct is used in a lot of perf-sensitive contexts.
static_assert(sizeof(Field) == 16, "Field struct too big");

}  // namespace protozero

#endif  // INCLUDE_PERFETTO_PROTOZERO_FIELD_H_
/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_PROTOZERO_PROTO_DECODER_H_
#define INCLUDE_PERFETTO_PROTOZERO_PROTO_DECODER_H_

#include <stdint.h>
#include <array>
#include <memory>
#include <vector>

// gen_amalgamated expanded: #include "perfetto/base/compiler.h"
// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/protozero/field.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace protozero {

// A generic protobuf decoder. Doesn't require any knowledge about the proto
// schema. It tokenizes fields, retrieves their ID and type and exposes
// accessors to retrieve its values.
// It does NOT recurse in nested submessages, instead it just computes their
// boundaries, recursion is left to the caller.
// This class is designed to be used in perf-sensitive contexts. It does not
// allocate and does not perform any proto semantic checks (e.g. repeated /
// required / optional). It's supposedly safe wrt out-of-bounds memory accesses
// (see proto_decoder_fuzzer.cc).
// This class serves also as a building block for TypedProtoDecoder, used when
// the schema is known at compile time.
class ProtoDecoder {
 public:
  // Creates a ProtoDecoder using the given |buffer| with size |length| bytes.
  inline ProtoDecoder(const uint8_t* buffer, size_t length)
      : begin_(buffer), end_(buffer + length), read_ptr_(buffer) {}

  // Reads the next field from the buffer and advances the read cursor. If a
  // full field cannot be read, the returned Field will be invalid (i.e.
  // field.valid() == false).
  Field ReadField();

  // Finds the first field with the given id. Doesn't affect the read cursor.
  Field FindField(uint32_t field_id);

  // Resets the read cursor to the start of the buffer.
  inline void Reset() { read_ptr_ = begin_; }

  // Resets the read cursor to the given position (must be within the buffer).
  inline void Reset(const uint8_t* pos) {
    PERFETTO_DCHECK(pos >= begin_ && pos < end_);
    read_ptr_ = pos;
  }

  // Returns the position of read cursor, relative to the start of the buffer.
  inline size_t read_offset() const {
    return static_cast<size_t>(read_ptr_ - begin_);
  }

  inline size_t bytes_left() const {
    PERFETTO_DCHECK(read_ptr_ <= end_);
    return static_cast<size_t>(end_ - read_ptr_);
  }

  const uint8_t* begin() const { return begin_; }
  const uint8_t* end() const { return end_; }

 protected:
  const uint8_t* const begin_;
  const uint8_t* const end_;
  const uint8_t* read_ptr_ = nullptr;
};

// An iterator-like class used to iterate through repeated fields. Used by
// TypedProtoDecoder. The iteration sequence is a bit counter-intuitive due to
// the fact that fields_[field_id] holds the *last* value of the field, not the
// first, but the remaining storage holds repeated fields in FIFO order.
// Assume that we push the 10,11,12 into a repeated field with ID=1.
//
// Decoder memory layout:  [  fields storage  ] [ repeated fields storage]
// 1st iteration:           10
// 2nd iteration:           11                   10
// 3rd iteration:           12                   10 11
//
// We start the iteration @ fields_[num_fields], which is the start of the
// repeated fields storage, proceed until the end and lastly jump @ fields_[id].
class RepeatedFieldIterator {
 public:
  RepeatedFieldIterator(uint32_t field_id,
                        const Field* begin,
                        const Field* end,
                        const Field* last)
      : field_id_(field_id), iter_(begin), end_(end), last_(last) {
    FindNextMatchingId();
  }

  inline const Field* operator->() const { return &*iter_; }
  inline const Field& operator*() const { return *iter_; }
  inline explicit operator bool() const { return iter_ != end_; }

  RepeatedFieldIterator& operator++() {
    PERFETTO_DCHECK(iter_ != end_);
    if (iter_ == last_) {
      iter_ = end_;
      return *this;
    }
    ++iter_;
    FindNextMatchingId();
    return *this;
  }

 private:
  inline void FindNextMatchingId() {
    PERFETTO_DCHECK(iter_ != last_);
    for (; iter_ != end_; ++iter_) {
      if (iter_->id() == field_id_)
        return;
    }
    iter_ = last_->valid() ? last_ : end_;
  }

  uint32_t field_id_;

  // Initially points to the beginning of the repeated field storage, then is
  // incremented as we call operator++().
  const Field* iter_;

  // Always points to fields_[size_], i.e. past the end of the storage.
  const Field* end_;

  // Always points to fields_[field_id].
  const Field* last_;
};

// This decoder loads all fields upfront, without recursing in nested messages.
// It is used as a base class for typed decoders generated by the pbzero plugin.
// The split between TypedProtoDecoderBase and TypedProtoDecoder<> is to have
// unique definition of functions like ParseAllFields() and ExpandHeapStorage().
// The storage (either on-stack or on-heap) for this class is organized as
// follows:
// |-------------------------- fields_ ----------------------|
// [ field 0 (invalid) ] [ fields 1 .. N ] [ repeated fields ]
//                                        ^                  ^
//                                        num_fields_        size_
class TypedProtoDecoderBase : public ProtoDecoder {
 public:
  // If the field |id| is known at compile time, prefer the templated
  // specialization at<kFieldNumber>().
  inline const Field& Get(uint32_t id) {
    return PERFETTO_LIKELY(id < num_fields_) ? fields_[id] : fields_[0];
  }

  // Returns an object that allows to iterate over all instances of a repeated
  // field given its id. Example usage:
  // for (auto it = decoder.GetRepeated(N); it; ++it) { ... }
  inline RepeatedFieldIterator GetRepeated(uint32_t field_id) const {
    return RepeatedFieldIterator(field_id, &fields_[num_fields_],
                                 &fields_[size_], &fields_[field_id]);
  }

 protected:
  TypedProtoDecoderBase(Field* storage,
                        uint32_t num_fields,
                        uint32_t capacity,
                        const uint8_t* buffer,
                        size_t length)
      : ProtoDecoder(buffer, length),
        fields_(storage),
        num_fields_(num_fields),
        size_(num_fields),
        capacity_(capacity) {
    // The reason why Field needs to be trivially de/constructible is to avoid
    // implicit initializers on all the ~1000 entries. We need it to initialize
    // only on the first |max_field_id| fields, the remaining capacity doesn't
    // require initialization.
    static_assert(PERFETTO_IS_TRIVIALLY_CONSTRUCTIBLE(Field) &&
                      std::is_trivially_destructible<Field>::value &&
                      std::is_trivial<Field>::value,
                  "Field must be a trivial aggregate type");
    memset(fields_, 0, sizeof(Field) * num_fields_);
  }

  void ParseAllFields();

  // Called when the default on-stack storage is exhausted and new repeated
  // fields need to be pushed.
  void ExpandHeapStorage();

  // Used only in presence of a large number of repeated fields, when the
  // default on-stack storage is exhausted.
  std::unique_ptr<Field[]> heap_storage_;

  // Points to the storage, either on-stack (default, provided by the template
  // specialization) or |heap_storage_| after ExpandHeapStorage() is called, in
  // case of a large number of repeated fields.
  Field* fields_;

  // Number of fields without accounting repeated storage. This is equal to
  // MAX_FIELD_ID + 1 (to account for the invalid 0th field).
  // This value is always <= size_ (and hence <= capacity);
  uint32_t num_fields_;

  // Number of active |fields_| entries. This is initially equal to the highest
  // number of fields for the message (num_fields_ == MAX_FIELD_ID + 1) and can
  // grow up to |capacity_| in the case of repeated fields.
  uint32_t size_;

  // Initially equal to kFieldsCapacity of the TypedProtoDecoder
  // specialization. Can grow when falling back on heap-based storage, in which
  // case it represents the size (#fields with each entry of a repeated field
  // counted individually) of the |heap_storage_| array.
  uint32_t capacity_;
};

// Template class instantiated by the auto-generated decoder classes declared in
// xxx.pbzero.h files.
template <int MAX_FIELD_ID, bool HAS_REPEATED_FIELDS>
class TypedProtoDecoder : public TypedProtoDecoderBase {
 public:
  TypedProtoDecoder(const uint8_t* buffer, size_t length)
      : TypedProtoDecoderBase(on_stack_storage_,
                              /*num_fields=*/MAX_FIELD_ID + 1,
                              kCapacity,
                              buffer,
                              length) {
    static_assert(MAX_FIELD_ID <= kMaxDecoderFieldId, "Field ordinal too high");
    TypedProtoDecoderBase::ParseAllFields();
  }

  template <uint32_t FIELD_ID>
  inline const Field& at() const {
    static_assert(FIELD_ID <= MAX_FIELD_ID, "FIELD_ID > MAX_FIELD_ID");
    return fields_[FIELD_ID];
  }

 private:
  // In the case of non-repeated fields, this constant defines the highest field
  // id we are able to decode. This is to limit the on-stack storage.
  // In the case of repeated fields, this constant defines the max number of
  // repeated fields that we'll be able to store before falling back on the
  // heap. Keep this value in sync with the one in protozero_generator.cc.
  static constexpr size_t kMaxDecoderFieldId = 999;

  // If we the message has no repeated fields we need at most N Field entries
  // in the on-stack storage, where N is the highest field id.
  // Otherwise we need some room to store repeated fields.
  static constexpr size_t kCapacity =
      1 + (HAS_REPEATED_FIELDS ? kMaxDecoderFieldId : MAX_FIELD_ID);

  Field on_stack_storage_[kCapacity];
};

}  // namespace protozero

#endif  // INCLUDE_PERFETTO_PROTOZERO_PROTO_DECODER_H_
/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"

#include <string.h>
#include <limits>

// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/utils.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

namespace protozero {

using namespace proto_utils;

#if __BYTE_ORDER__ != __ORDER_LITTLE_ENDIAN__
#error Unimplemented for big endian archs.
#endif

namespace {

struct ParseFieldResult {
  const uint8_t* next;
  Field field;
};

// Parses one field and returns the field itself and a pointer to the next
// field to parse. If parsing fails, the returned |next| == |buffer|.
PERFETTO_ALWAYS_INLINE ParseFieldResult
ParseOneField(const uint8_t* const buffer, const uint8_t* const end) {
  ParseFieldResult res{buffer, Field{}};

  // The first byte of a proto field is structured as follows:
  // The least 3 significant bits determine the field type.
  // The most 5 significant bits determine the field id. If MSB == 1, the
  // field id continues on the next bytes following the VarInt encoding.
  const uint8_t kFieldTypeNumBits = 3;
  const uint64_t kFieldTypeMask = (1 << kFieldTypeNumBits) - 1;  // 0000 0111;
  const uint8_t* pos = buffer;

  // If we've already hit the end, just return an invalid field.
  if (PERFETTO_UNLIKELY(pos >= end))
    return res;

  uint64_t preamble = 0;
  if (PERFETTO_LIKELY(*pos < 0x80)) {  // Fastpath for fields with ID < 32.
    preamble = *(pos++);
  } else {
    pos = ParseVarInt(pos, end, &preamble);
  }

  uint32_t field_id = static_cast<uint32_t>(preamble >> kFieldTypeNumBits);
  if (field_id == 0 || pos >= end)
    return res;

  auto field_type = static_cast<uint8_t>(preamble & kFieldTypeMask);
  const uint8_t* new_pos = pos;
  uint64_t int_value = 0;
  uint32_t size = 0;

  switch (field_type) {
    case static_cast<uint8_t>(ProtoWireType::kVarInt): {
      new_pos = ParseVarInt(pos, end, &int_value);

      // new_pos not being greater than pos means ParseVarInt could not fully
      // parse the number. This is because we are out of space in the buffer.
      // Set the id to zero and return but don't update the offset so a future
      // read can read this field.
      if (PERFETTO_UNLIKELY(new_pos == pos))
        return res;

      break;
    }

    case static_cast<uint8_t>(ProtoWireType::kLengthDelimited): {
      uint64_t payload_length;
      new_pos = ParseVarInt(pos, end, &payload_length);
      if (PERFETTO_UNLIKELY(new_pos == pos))
        return res;

      // ParseVarInt guarantees that |new_pos| <= |end| when it succeeds;
      if (payload_length > static_cast<uint64_t>(end - new_pos))
        return res;

      // If the message is larger than 256 MiB silently skip it.
      if (PERFETTO_LIKELY(payload_length <= proto_utils::kMaxMessageLength)) {
        const uintptr_t payload_start = reinterpret_cast<uintptr_t>(new_pos);
        int_value = payload_start;
        size = static_cast<uint32_t>(payload_length);
      }

      new_pos += payload_length;
      break;
    }

    case static_cast<uint8_t>(ProtoWireType::kFixed64): {
      new_pos = pos + sizeof(uint64_t);
      if (PERFETTO_UNLIKELY(new_pos > end))
        return res;
      memcpy(&int_value, pos, sizeof(uint64_t));
      break;
    }

    case static_cast<uint8_t>(ProtoWireType::kFixed32): {
      new_pos = pos + sizeof(uint32_t);
      if (PERFETTO_UNLIKELY(new_pos > end))
        return res;
      memcpy(&int_value, pos, sizeof(uint32_t));
      break;
    }

    default:
      PERFETTO_DLOG("Invalid proto field type: %u", field_type);
      return res;
  }

  if (PERFETTO_UNLIKELY(field_id > std::numeric_limits<uint16_t>::max())) {
    PERFETTO_DFATAL("Cannot parse proto field ids > 0xFFFF");
    return res;
  }

  res.field.initialize(static_cast<uint16_t>(field_id), field_type, int_value,
                       size);
  res.next = new_pos;
  return res;
}

}  // namespace

Field ProtoDecoder::FindField(uint32_t field_id) {
  Field res{};
  auto old_position = read_ptr_;
  read_ptr_ = begin_;
  for (auto f = ReadField(); f.valid(); f = ReadField()) {
    if (f.id() == field_id) {
      res = f;
      break;
    }
  }
  read_ptr_ = old_position;
  return res;
}

PERFETTO_ALWAYS_INLINE
Field ProtoDecoder::ReadField() {
  ParseFieldResult res = ParseOneField(read_ptr_, end_);
  read_ptr_ = res.next;
  return res.field;
}

void TypedProtoDecoderBase::ParseAllFields() {
  const uint8_t* cur = begin_;
  ParseFieldResult res;
  for (;;) {
    res = ParseOneField(cur, end_);
    if (res.next == cur)
      break;
    PERFETTO_DCHECK(res.field.valid());
    cur = res.next;

    auto field_id = res.field.id();
    if (PERFETTO_UNLIKELY(field_id >= num_fields_))
      continue;

    Field* fld = &fields_[field_id];
    if (PERFETTO_LIKELY(!fld->valid())) {
      // This is the first time we see this field.
      *fld = std::move(res.field);
    } else {
      // Repeated field case.
      // In this case we need to:
      // 1. Append the last value of the field to end of the repeated field
      //    storage.
      // 2. Replace the default instance at offset |field_id| with the current
      //    value. This is because in case of repeated field a call to Get(X) is
      //    supposed to return the last value of X, not the first one.
      // This is so that the RepeatedFieldIterator will iterate in the right
      // order, see comments on RepeatedFieldIterator.
      if (PERFETTO_UNLIKELY(size_ >= capacity_)) {
        ExpandHeapStorage();
        // ExpandHeapStorage moves fields_ so we need to update the ptr to fld:
        fld = &fields_[field_id];
        PERFETTO_DCHECK(size_ < capacity_);
      }
      fields_[size_++] = *fld;
      *fld = std::move(res.field);
    }
  }
  read_ptr_ = res.next;
}

void TypedProtoDecoderBase::ExpandHeapStorage() {
  uint32_t new_capacity = capacity_ * 2;
  PERFETTO_CHECK(new_capacity > size_);
  std::unique_ptr<Field[]> new_storage(new Field[new_capacity]);

  static_assert(PERFETTO_IS_TRIVIALLY_COPYABLE(Field),
                "Field must be trivially copyable");
  memcpy(&new_storage[0], fields_, sizeof(Field) * size_);

  heap_storage_ = std::move(new_storage);
  fields_ = &heap_storage_[0];
  capacity_ = new_capacity;
}

}  // namespace protozero
// gen_amalgamated begin source: src/protozero/scattered_heap_buffer.cc
// gen_amalgamated begin header: include/perfetto/protozero/scattered_heap_buffer.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_PROTOZERO_SCATTERED_HEAP_BUFFER_H_
#define INCLUDE_PERFETTO_PROTOZERO_SCATTERED_HEAP_BUFFER_H_

#include <memory>
#include <string>
#include <vector>

// gen_amalgamated expanded: #include "perfetto/base/export.h"
// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/protozero/scattered_stream_writer.h"

namespace protozero {

class Message;

class PERFETTO_EXPORT ScatteredHeapBuffer
    : public protozero::ScatteredStreamWriter::Delegate {
 public:
  class PERFETTO_EXPORT Slice {
   public:
    explicit Slice(size_t size);
    Slice(Slice&& slice) noexcept;
    ~Slice();

    inline protozero::ContiguousMemoryRange GetTotalRange() const {
      return {buffer_.get(), buffer_.get() + size_};
    }

    inline protozero::ContiguousMemoryRange GetUsedRange() const {
      return {buffer_.get(), buffer_.get() + size_ - unused_bytes_};
    }

    uint8_t* start() const { return buffer_.get(); }
    size_t size() const { return size_; }
    size_t unused_bytes() const { return unused_bytes_; }
    void set_unused_bytes(size_t unused_bytes) {
      PERFETTO_DCHECK(unused_bytes_ <= size_);
      unused_bytes_ = unused_bytes;
    }

   private:
    std::unique_ptr<uint8_t[]> buffer_;
    const size_t size_;
    size_t unused_bytes_;
  };

  ScatteredHeapBuffer(size_t initial_slice_size_bytes = 128,
                      size_t maximum_slice_size_bytes = 128 * 1024);
  ~ScatteredHeapBuffer() override;

  // protozero::ScatteredStreamWriter::Delegate implementation.
  protozero::ContiguousMemoryRange GetNewBuffer() override;

  // Stitch all the slices into a single contiguous buffer.
  std::vector<uint8_t> StitchSlices();

  const std::vector<Slice>& slices() const { return slices_; }

  void set_writer(protozero::ScatteredStreamWriter* writer) {
    writer_ = writer;
  }

  // Update unused_bytes() of the current |Slice| based on the writer's state.
  void AdjustUsedSizeOfCurrentSlice();

  // Returns the total size the slices occupy in heap memory (including unused).
  size_t GetTotalSize();

 private:
  size_t next_slice_size_;
  const size_t maximum_slice_size_;
  protozero::ScatteredStreamWriter* writer_ = nullptr;
  std::vector<Slice> slices_;
};

// Helper function to create heap-based protozero messages in one line.
// This is a convenience wrapper, mostly for tests, to avoid having to do:
//   MyMessage msg;
//   ScatteredHeapBuffer shb;
//   ScatteredStreamWriter writer(&shb);
//   shb.set_writer(&writer);
//   msg.Reset(&shb);
// Just to get an easily serializable message. Instead this allows simply:
//   HeapBuffered<MyMessage> msg;
//   msg->set_stuff(...);
//   msg->SerializeAsString();
template <typename T = ::protozero::Message>
class HeapBuffered {
 public:
  HeapBuffered() : shb_(4096, 4096), writer_(&shb_) {
    shb_.set_writer(&writer_);
    msg_.Reset(&writer_);
  }

  // This can't be neither copied nor moved because Message hands out pointers
  // to itself when creating submessages.
  HeapBuffered(const HeapBuffered&) = delete;
  HeapBuffered& operator=(const HeapBuffered&) = delete;
  HeapBuffered(HeapBuffered&&) = delete;
  HeapBuffered& operator=(HeapBuffered&&) = delete;

  T* get() { return &msg_; }
  T* operator->() { return &msg_; }

  std::vector<uint8_t> SerializeAsArray() {
    msg_.Finalize();
    return shb_.StitchSlices();
  }

  std::string SerializeAsString() {
    auto vec = SerializeAsArray();
    return std::string(reinterpret_cast<const char*>(vec.data()), vec.size());
  }

 private:
  ScatteredHeapBuffer shb_;
  ScatteredStreamWriter writer_;
  T msg_;
};

}  // namespace protozero

#endif  // INCLUDE_PERFETTO_PROTOZERO_SCATTERED_HEAP_BUFFER_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "perfetto/protozero/scattered_heap_buffer.h"

#include <algorithm>

namespace protozero {

ScatteredHeapBuffer::Slice::Slice(size_t size)
    : buffer_(std::unique_ptr<uint8_t[]>(new uint8_t[size])),
      size_(size),
      unused_bytes_(size) {
  PERFETTO_DCHECK(size);
#if PERFETTO_DCHECK_IS_ON()
  memset(start(), 0xff, size_);
#endif  // PERFETTO_DCHECK_IS_ON()
}

ScatteredHeapBuffer::Slice::Slice(Slice&& slice) noexcept = default;

ScatteredHeapBuffer::Slice::~Slice() = default;

ScatteredHeapBuffer::ScatteredHeapBuffer(size_t initial_slice_size_bytes,
                                         size_t maximum_slice_size_bytes)
    : next_slice_size_(initial_slice_size_bytes),
      maximum_slice_size_(maximum_slice_size_bytes) {
  PERFETTO_DCHECK(next_slice_size_ && maximum_slice_size_);
  PERFETTO_DCHECK(maximum_slice_size_ >= initial_slice_size_bytes);
}

ScatteredHeapBuffer::~ScatteredHeapBuffer() = default;

protozero::ContiguousMemoryRange ScatteredHeapBuffer::GetNewBuffer() {
  PERFETTO_CHECK(writer_);
  AdjustUsedSizeOfCurrentSlice();

  slices_.emplace_back(next_slice_size_);
  next_slice_size_ = std::min(maximum_slice_size_, next_slice_size_ * 2);
  return slices_.back().GetTotalRange();
}

std::vector<uint8_t> ScatteredHeapBuffer::StitchSlices() {
  AdjustUsedSizeOfCurrentSlice();
  std::vector<uint8_t> buffer;
  size_t i = 0;
  for (const auto& slice : slices_) {
    auto used_range = slice.GetUsedRange();
    buffer.insert(buffer.end(), used_range.begin, used_range.end);
    i++;
  }
  return buffer;
}

void ScatteredHeapBuffer::AdjustUsedSizeOfCurrentSlice() {
  if (!slices_.empty())
    slices_.back().set_unused_bytes(writer_->bytes_available());
}

size_t ScatteredHeapBuffer::GetTotalSize() {
  size_t total_size = 0;
  for (auto& slice : slices_) {
    total_size += slice.size();
  }
  return total_size;
}

}  // namespace protozero
// gen_amalgamated begin source: src/protozero/scattered_stream_null_delegate.cc
// gen_amalgamated begin header: include/perfetto/protozero/scattered_stream_null_delegate.h
/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_PROTOZERO_SCATTERED_STREAM_NULL_DELEGATE_H_
#define INCLUDE_PERFETTO_PROTOZERO_SCATTERED_STREAM_NULL_DELEGATE_H_

#include <memory>
#include <vector>

// gen_amalgamated expanded: #include "perfetto/base/export.h"
// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/protozero/contiguous_memory_range.h"
// gen_amalgamated expanded: #include "perfetto/protozero/scattered_stream_writer.h"

namespace protozero {

class PERFETTO_EXPORT ScatteredStreamWriterNullDelegate
    : public ScatteredStreamWriter::Delegate {
 public:
  explicit ScatteredStreamWriterNullDelegate(size_t chunk_size);
  ~ScatteredStreamWriterNullDelegate() override;

  // protozero::ScatteredStreamWriter::Delegate implementation.
  ContiguousMemoryRange GetNewBuffer() override;

 private:
  const size_t chunk_size_;
  std::unique_ptr<uint8_t[]> chunk_;
};

}  // namespace protozero

#endif  // INCLUDE_PERFETTO_PROTOZERO_SCATTERED_STREAM_NULL_DELEGATE_H_
/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "perfetto/protozero/scattered_stream_null_delegate.h"

namespace protozero {

// An implementation of ScatteredStreamWriter::Delegate which always returns
// the same piece of memory.
// This is used when we need to no-op the writers (e.g. during teardown or in
// case of resource exhaustion), avoiding that the clients have to deal with
// nullptr checks.
ScatteredStreamWriterNullDelegate::ScatteredStreamWriterNullDelegate(
    size_t chunk_size)
    : chunk_size_(chunk_size),
      chunk_(std::unique_ptr<uint8_t[]>(new uint8_t[chunk_size_])) {}

ScatteredStreamWriterNullDelegate::~ScatteredStreamWriterNullDelegate() {}

ContiguousMemoryRange ScatteredStreamWriterNullDelegate::GetNewBuffer() {
  return {chunk_.get(), chunk_.get() + chunk_size_};
}

}  // namespace protozero
// gen_amalgamated begin source: src/protozero/scattered_stream_writer.cc
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "perfetto/protozero/scattered_stream_writer.h"

#include <algorithm>

// gen_amalgamated expanded: #include "perfetto/base/logging.h"

namespace protozero {

ScatteredStreamWriter::Delegate::~Delegate() {}

ScatteredStreamWriter::ScatteredStreamWriter(Delegate* delegate)
    : delegate_(delegate),
      cur_range_({nullptr, nullptr}),
      write_ptr_(nullptr) {}

ScatteredStreamWriter::~ScatteredStreamWriter() {}

void ScatteredStreamWriter::Reset(ContiguousMemoryRange range) {
  written_previously_ += static_cast<uint64_t>(write_ptr_ - cur_range_.begin);
  cur_range_ = range;
  write_ptr_ = range.begin;
  PERFETTO_DCHECK(!write_ptr_ || write_ptr_ < cur_range_.end);
}

void ScatteredStreamWriter::Extend() {
  Reset(delegate_->GetNewBuffer());
}

void ScatteredStreamWriter::WriteBytesSlowPath(const uint8_t* src,
                                               size_t size) {
  size_t bytes_left = size;
  while (bytes_left > 0) {
    if (write_ptr_ >= cur_range_.end)
      Extend();
    const size_t burst_size = std::min(bytes_available(), bytes_left);
    WriteBytesUnsafe(src, burst_size);
    bytes_left -= burst_size;
    src += burst_size;
  }
}

// TODO(primiano): perf optimization: I suspect that at the end this will always
// be called with |size| == 4, in which case we might just hardcode it.
uint8_t* ScatteredStreamWriter::ReserveBytes(size_t size) {
  if (write_ptr_ + size > cur_range_.end) {
    // Assume the reservations are always < Delegate::GetNewBuffer().size(),
    // so that one single call to Extend() will definitely give enough headroom.
    Extend();
    PERFETTO_DCHECK(write_ptr_ + size <= cur_range_.end);
  }
  uint8_t* begin = write_ptr_;
  write_ptr_ += size;
#if PERFETTO_DCHECK_IS_ON()
  memset(begin, 0, size);
#endif
  return begin;
}

}  // namespace protozero
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/perfetto/perfetto_metatrace.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/clock_snapshot.pb.cc
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/clock_snapshot.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/trace/clock_snapshot.proto

#ifndef PROTOBUF_perfetto_2ftrace_2fclock_5fsnapshot_2eproto__INCLUDED
#define PROTOBUF_perfetto_2ftrace_2fclock_5fsnapshot_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_perfetto_2ftrace_2fclock_5fsnapshot_2eproto();
void protobuf_AssignDesc_perfetto_2ftrace_2fclock_5fsnapshot_2eproto();
void protobuf_ShutdownFile_perfetto_2ftrace_2fclock_5fsnapshot_2eproto();

class ClockSnapshot;
class ClockSnapshot_Clock;

enum ClockSnapshot_Clock_Type {
  ClockSnapshot_Clock_Type_UNKNOWN = 0,
  ClockSnapshot_Clock_Type_REALTIME = 1,
  ClockSnapshot_Clock_Type_REALTIME_COARSE = 2,
  ClockSnapshot_Clock_Type_MONOTONIC = 3,
  ClockSnapshot_Clock_Type_MONOTONIC_COARSE = 4,
  ClockSnapshot_Clock_Type_MONOTONIC_RAW = 5,
  ClockSnapshot_Clock_Type_BOOTTIME = 6,
  ClockSnapshot_Clock_Type_PROCESS_CPUTIME = 7,
  ClockSnapshot_Clock_Type_THREAD_CPUTIME = 8
};
bool ClockSnapshot_Clock_Type_IsValid(int value);
const ClockSnapshot_Clock_Type ClockSnapshot_Clock_Type_Type_MIN = ClockSnapshot_Clock_Type_UNKNOWN;
const ClockSnapshot_Clock_Type ClockSnapshot_Clock_Type_Type_MAX = ClockSnapshot_Clock_Type_THREAD_CPUTIME;
const int ClockSnapshot_Clock_Type_Type_ARRAYSIZE = ClockSnapshot_Clock_Type_Type_MAX + 1;

// ===================================================================

class ClockSnapshot_Clock : public ::google::protobuf::MessageLite {
 public:
  ClockSnapshot_Clock();
  virtual ~ClockSnapshot_Clock();

  ClockSnapshot_Clock(const ClockSnapshot_Clock& from);

  inline ClockSnapshot_Clock& operator=(const ClockSnapshot_Clock& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ClockSnapshot_Clock& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClockSnapshot_Clock* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClockSnapshot_Clock* other);

  // implements Message ----------------------------------------------

  inline ClockSnapshot_Clock* New() const { return New(NULL); }

  ClockSnapshot_Clock* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClockSnapshot_Clock& from);
  void MergeFrom(const ClockSnapshot_Clock& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClockSnapshot_Clock* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ClockSnapshot_Clock_Type Type;
  static const Type UNKNOWN =
    ClockSnapshot_Clock_Type_UNKNOWN;
  static const Type REALTIME =
    ClockSnapshot_Clock_Type_REALTIME;
  static const Type REALTIME_COARSE =
    ClockSnapshot_Clock_Type_REALTIME_COARSE;
  static const Type MONOTONIC =
    ClockSnapshot_Clock_Type_MONOTONIC;
  static const Type MONOTONIC_COARSE =
    ClockSnapshot_Clock_Type_MONOTONIC_COARSE;
  static const Type MONOTONIC_RAW =
    ClockSnapshot_Clock_Type_MONOTONIC_RAW;
  static const Type BOOTTIME =
    ClockSnapshot_Clock_Type_BOOTTIME;
  static const Type PROCESS_CPUTIME =
    ClockSnapshot_Clock_Type_PROCESS_CPUTIME;
  static const Type THREAD_CPUTIME =
    ClockSnapshot_Clock_Type_THREAD_CPUTIME;
  static inline bool Type_IsValid(int value) {
    return ClockSnapshot_Clock_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ClockSnapshot_Clock_Type_Type_MIN;
  static const Type Type_MAX =
    ClockSnapshot_Clock_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ClockSnapshot_Clock_Type_Type_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .perfetto.protos.ClockSnapshot.Clock.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::perfetto::protos::ClockSnapshot_Clock_Type type() const;
  void set_type(::perfetto::protos::ClockSnapshot_Clock_Type value);

  // optional uint64 timestamp = 2;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.ClockSnapshot.Clock)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 timestamp_;
  int type_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2ftrace_2fclock_5fsnapshot_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2ftrace_2fclock_5fsnapshot_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2ftrace_2fclock_5fsnapshot_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2ftrace_2fclock_5fsnapshot_2eproto();

  void InitAsDefaultInstance();
  static ClockSnapshot_Clock* default_instance_;
};
// -------------------------------------------------------------------

class ClockSnapshot : public ::google::protobuf::MessageLite {
 public:
  ClockSnapshot();
  virtual ~ClockSnapshot();

  ClockSnapshot(const ClockSnapshot& from);

  inline ClockSnapshot& operator=(const ClockSnapshot& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ClockSnapshot& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClockSnapshot* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClockSnapshot* other);

  // implements Message ----------------------------------------------

  inline ClockSnapshot* New() const { return New(NULL); }

  ClockSnapshot* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClockSnapshot& from);
  void MergeFrom(const ClockSnapshot& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClockSnapshot* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ClockSnapshot_Clock Clock;

  // accessors -------------------------------------------------------

  // repeated .perfetto.protos.ClockSnapshot.Clock clocks = 1;
  int clocks_size() const;
  void clear_clocks();
  static const int kClocksFieldNumber = 1;
  const ::perfetto::protos::ClockSnapshot_Clock& clocks(int index) const;
  ::perfetto::protos::ClockSnapshot_Clock* mutable_clocks(int index);
  ::perfetto::protos::ClockSnapshot_Clock* add_clocks();
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::ClockSnapshot_Clock >*
      mutable_clocks();
  const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::ClockSnapshot_Clock >&
      clocks() const;

  // @@protoc_insertion_point(class_scope:perfetto.protos.ClockSnapshot)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::perfetto::protos::ClockSnapshot_Clock > clocks_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2ftrace_2fclock_5fsnapshot_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2ftrace_2fclock_5fsnapshot_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2ftrace_2fclock_5fsnapshot_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2ftrace_2fclock_5fsnapshot_2eproto();

  void InitAsDefaultInstance();
  static ClockSnapshot* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// ClockSnapshot_Clock

// optional .perfetto.protos.ClockSnapshot.Clock.Type type = 1;
inline bool ClockSnapshot_Clock::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClockSnapshot_Clock::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClockSnapshot_Clock::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClockSnapshot_Clock::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::perfetto::protos::ClockSnapshot_Clock_Type ClockSnapshot_Clock::type() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ClockSnapshot.Clock.type)
  return static_cast< ::perfetto::protos::ClockSnapshot_Clock_Type >(type_);
}
inline void ClockSnapshot_Clock::set_type(::perfetto::protos::ClockSnapshot_Clock_Type value) {
  assert(::perfetto::protos::ClockSnapshot_Clock_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.ClockSnapshot.Clock.type)
}

// optional uint64 timestamp = 2;
inline bool ClockSnapshot_Clock::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClockSnapshot_Clock::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClockSnapshot_Clock::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClockSnapshot_Clock::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 ClockSnapshot_Clock::timestamp() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ClockSnapshot.Clock.timestamp)
  return timestamp_;
}
inline void ClockSnapshot_Clock::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.ClockSnapshot.Clock.timestamp)
}

// -------------------------------------------------------------------

// ClockSnapshot

// repeated .perfetto.protos.ClockSnapshot.Clock clocks = 1;
inline int ClockSnapshot::clocks_size() const {
  return clocks_.size();
}
inline void ClockSnapshot::clear_clocks() {
  clocks_.Clear();
}
inline const ::perfetto::protos::ClockSnapshot_Clock& ClockSnapshot::clocks(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ClockSnapshot.clocks)
  return clocks_.Get(index);
}
inline ::perfetto::protos::ClockSnapshot_Clock* ClockSnapshot::mutable_clocks(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.ClockSnapshot.clocks)
  return clocks_.Mutable(index);
}
inline ::perfetto::protos::ClockSnapshot_Clock* ClockSnapshot::add_clocks() {
  // @@protoc_insertion_point(field_add:perfetto.protos.ClockSnapshot.clocks)
  return clocks_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::perfetto::protos::ClockSnapshot_Clock >*
ClockSnapshot::mutable_clocks() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.ClockSnapshot.clocks)
  return &clocks_;
}
inline const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::ClockSnapshot_Clock >&
ClockSnapshot::clocks() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.ClockSnapshot.clocks)
  return clocks_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::perfetto::protos::ClockSnapshot_Clock_Type> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_perfetto_2ftrace_2fclock_5fsnapshot_2eproto__INCLUDED
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/trace/clock_snapshot.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
// gen_amalgamated expanded: #include "perfetto/trace/clock_snapshot.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

void protobuf_ShutdownFile_perfetto_2ftrace_2fclock_5fsnapshot_2eproto() {
  delete ClockSnapshot::default_instance_;
  delete ClockSnapshot_Clock::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_perfetto_2ftrace_2fclock_5fsnapshot_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_perfetto_2ftrace_2fclock_5fsnapshot_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ClockSnapshot::default_instance_ = new ClockSnapshot();
  ClockSnapshot_Clock::default_instance_ = new ClockSnapshot_Clock();
  ClockSnapshot::default_instance_->InitAsDefaultInstance();
  ClockSnapshot_Clock::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_perfetto_2ftrace_2fclock_5fsnapshot_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_perfetto_2ftrace_2fclock_5fsnapshot_2eproto_once_);
void protobuf_AddDesc_perfetto_2ftrace_2fclock_5fsnapshot_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_perfetto_2ftrace_2fclock_5fsnapshot_2eproto_once_,
                 &protobuf_AddDesc_perfetto_2ftrace_2fclock_5fsnapshot_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_perfetto_2ftrace_2fclock_5fsnapshot_2eproto {
  StaticDescriptorInitializer_perfetto_2ftrace_2fclock_5fsnapshot_2eproto() {
    protobuf_AddDesc_perfetto_2ftrace_2fclock_5fsnapshot_2eproto();
  }
} static_descriptor_initializer_perfetto_2ftrace_2fclock_5fsnapshot_2eproto_;
#endif

namespace {

static void clock_snapshot_pb_MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
static void clock_snapshot_pb_MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

static ::std::string* MutableUnknownFieldsForClockSnapshot(
    ClockSnapshot* ptr) {
  return ptr->mutable_unknown_fields();
}

static ::std::string* MutableUnknownFieldsForClockSnapshot_Clock(
    ClockSnapshot_Clock* ptr) {
  return ptr->mutable_unknown_fields();
}

bool ClockSnapshot_Clock_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const ClockSnapshot_Clock_Type ClockSnapshot_Clock::UNKNOWN;
const ClockSnapshot_Clock_Type ClockSnapshot_Clock::REALTIME;
const ClockSnapshot_Clock_Type ClockSnapshot_Clock::REALTIME_COARSE;
const ClockSnapshot_Clock_Type ClockSnapshot_Clock::MONOTONIC;
const ClockSnapshot_Clock_Type ClockSnapshot_Clock::MONOTONIC_COARSE;
const ClockSnapshot_Clock_Type ClockSnapshot_Clock::MONOTONIC_RAW;
const ClockSnapshot_Clock_Type ClockSnapshot_Clock::BOOTTIME;
const ClockSnapshot_Clock_Type ClockSnapshot_Clock::PROCESS_CPUTIME;
const ClockSnapshot_Clock_Type ClockSnapshot_Clock::THREAD_CPUTIME;
const ClockSnapshot_Clock_Type ClockSnapshot_Clock::Type_MIN;
const ClockSnapshot_Clock_Type ClockSnapshot_Clock::Type_MAX;
const int ClockSnapshot_Clock::Type_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ClockSnapshot_Clock::kTypeFieldNumber;
const int ClockSnapshot_Clock::kTimestampFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ClockSnapshot_Clock::ClockSnapshot_Clock()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.ClockSnapshot.Clock)
}

void ClockSnapshot_Clock::InitAsDefaultInstance() {
}

ClockSnapshot_Clock::ClockSnapshot_Clock(const ClockSnapshot_Clock& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.ClockSnapshot.Clock)
}

void ClockSnapshot_Clock::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  type_ = 0;
  timestamp_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClockSnapshot_Clock::~ClockSnapshot_Clock() {
  // @@protoc_insertion_point(destructor:perfetto.protos.ClockSnapshot.Clock)
  SharedDtor();
}

void ClockSnapshot_Clock::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ClockSnapshot_Clock::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ClockSnapshot_Clock& ClockSnapshot_Clock::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2ftrace_2fclock_5fsnapshot_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2ftrace_2fclock_5fsnapshot_2eproto();
#endif
  return *default_instance_;
}

ClockSnapshot_Clock* ClockSnapshot_Clock::default_instance_ = NULL;

ClockSnapshot_Clock* ClockSnapshot_Clock::New(::google::protobuf::Arena* arena) const {
  ClockSnapshot_Clock* n = new ClockSnapshot_Clock;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ClockSnapshot_Clock::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.ClockSnapshot.Clock)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(ClockSnapshot_Clock, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<ClockSnapshot_Clock*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(timestamp_, type_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool ClockSnapshot_Clock::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForClockSnapshot_Clock, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.ClockSnapshot.Clock)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .perfetto.protos.ClockSnapshot.Clock.Type type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::perfetto::protos::ClockSnapshot_Clock_Type_IsValid(value)) {
            set_type(static_cast< ::perfetto::protos::ClockSnapshot_Clock_Type >(value));
          } else {
            unknown_fields_stream.WriteVarint32(8);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_timestamp;
        break;
      }

      // optional uint64 timestamp = 2;
      case 2: {
        if (tag == 16) {
         parse_timestamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.ClockSnapshot.Clock)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.ClockSnapshot.Clock)
  return false;
#undef DO_
}

void ClockSnapshot_Clock::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.ClockSnapshot.Clock)
  // optional .perfetto.protos.ClockSnapshot.Clock.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional uint64 timestamp = 2;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->timestamp(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.ClockSnapshot.Clock)
}

int ClockSnapshot_Clock::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.ClockSnapshot.Clock)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional .perfetto.protos.ClockSnapshot.Clock.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional uint64 timestamp = 2;
    if (has_timestamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->timestamp());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClockSnapshot_Clock::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ClockSnapshot_Clock*>(&from));
}

void ClockSnapshot_Clock::MergeFrom(const ClockSnapshot_Clock& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.ClockSnapshot.Clock)
  if (GOOGLE_PREDICT_FALSE(&from == this)) clock_snapshot_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void ClockSnapshot_Clock::CopyFrom(const ClockSnapshot_Clock& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.ClockSnapshot.Clock)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClockSnapshot_Clock::IsInitialized() const {

  return true;
}

void ClockSnapshot_Clock::Swap(ClockSnapshot_Clock* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ClockSnapshot_Clock::InternalSwap(ClockSnapshot_Clock* other) {
  std::swap(type_, other->type_);
  std::swap(timestamp_, other->timestamp_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ClockSnapshot_Clock::GetTypeName() const {
  return "perfetto.protos.ClockSnapshot.Clock";
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ClockSnapshot::kClocksFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ClockSnapshot::ClockSnapshot()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.ClockSnapshot)
}

void ClockSnapshot::InitAsDefaultInstance() {
}

ClockSnapshot::ClockSnapshot(const ClockSnapshot& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.ClockSnapshot)
}

void ClockSnapshot::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ClockSnapshot::~ClockSnapshot() {
  // @@protoc_insertion_point(destructor:perfetto.protos.ClockSnapshot)
  SharedDtor();
}

void ClockSnapshot::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void ClockSnapshot::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ClockSnapshot& ClockSnapshot::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2ftrace_2fclock_5fsnapshot_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2ftrace_2fclock_5fsnapshot_2eproto();
#endif
  return *default_instance_;
}

ClockSnapshot* ClockSnapshot::default_instance_ = NULL;

ClockSnapshot* ClockSnapshot::New(::google::protobuf::Arena* arena) const {
  ClockSnapshot* n = new ClockSnapshot;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ClockSnapshot::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.ClockSnapshot)
  clocks_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool ClockSnapshot::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForClockSnapshot, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.ClockSnapshot)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .perfetto.protos.ClockSnapshot.Clock clocks = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_clocks:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_clocks()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_clocks;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.ClockSnapshot)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.ClockSnapshot)
  return false;
#undef DO_
}

void ClockSnapshot::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.ClockSnapshot)
  // repeated .perfetto.protos.ClockSnapshot.Clock clocks = 1;
  for (unsigned int i = 0, n = this->clocks_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->clocks(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.ClockSnapshot)
}

int ClockSnapshot::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.ClockSnapshot)
  int total_size = 0;

  // repeated .perfetto.protos.ClockSnapshot.Clock clocks = 1;
  total_size += 1 * this->clocks_size();
  for (int i = 0; i < this->clocks_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->clocks(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ClockSnapshot::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const ClockSnapshot*>(&from));
}

void ClockSnapshot::MergeFrom(const ClockSnapshot& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.ClockSnapshot)
  if (GOOGLE_PREDICT_FALSE(&from == this)) clock_snapshot_pb_MergeFromFail(__LINE__);
  clocks_.MergeFrom(from.clocks_);
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void ClockSnapshot::CopyFrom(const ClockSnapshot& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.ClockSnapshot)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClockSnapshot::IsInitialized() const {

  return true;
}

void ClockSnapshot::Swap(ClockSnapshot* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ClockSnapshot::InternalSwap(ClockSnapshot* other) {
  clocks_.UnsafeArenaSwap(&other->clocks_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string ClockSnapshot::GetTypeName() const {
  return "perfetto.protos.ClockSnapshot";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ClockSnapshot_Clock

// optional .perfetto.protos.ClockSnapshot.Clock.Type type = 1;
bool ClockSnapshot_Clock::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ClockSnapshot_Clock::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
void ClockSnapshot_Clock::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
void ClockSnapshot_Clock::clear_type() {
  type_ = 0;
  clear_has_type();
}
 ::perfetto::protos::ClockSnapshot_Clock_Type ClockSnapshot_Clock::type() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ClockSnapshot.Clock.type)
  return static_cast< ::perfetto::protos::ClockSnapshot_Clock_Type >(type_);
}
 void ClockSnapshot_Clock::set_type(::perfetto::protos::ClockSnapshot_Clock_Type value) {
  assert(::perfetto::protos::ClockSnapshot_Clock_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.ClockSnapshot.Clock.type)
}

// optional uint64 timestamp = 2;
bool ClockSnapshot_Clock::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ClockSnapshot_Clock::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
void ClockSnapshot_Clock::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
void ClockSnapshot_Clock::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
 ::google::protobuf::uint64 ClockSnapshot_Clock::timestamp() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ClockSnapshot.Clock.timestamp)
  return timestamp_;
}
 void ClockSnapshot_Clock::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.ClockSnapshot.Clock.timestamp)
}

// -------------------------------------------------------------------

// ClockSnapshot

// repeated .perfetto.protos.ClockSnapshot.Clock clocks = 1;
int ClockSnapshot::clocks_size() const {
  return clocks_.size();
}
void ClockSnapshot::clear_clocks() {
  clocks_.Clear();
}
const ::perfetto::protos::ClockSnapshot_Clock& ClockSnapshot::clocks(int index) const {
  // @@protoc_insertion_point(field_get:perfetto.protos.ClockSnapshot.clocks)
  return clocks_.Get(index);
}
::perfetto::protos::ClockSnapshot_Clock* ClockSnapshot::mutable_clocks(int index) {
  // @@protoc_insertion_point(field_mutable:perfetto.protos.ClockSnapshot.clocks)
  return clocks_.Mutable(index);
}
::perfetto::protos::ClockSnapshot_Clock* ClockSnapshot::add_clocks() {
  // @@protoc_insertion_point(field_add:perfetto.protos.ClockSnapshot.clocks)
  return clocks_.Add();
}
::google::protobuf::RepeatedPtrField< ::perfetto::protos::ClockSnapshot_Clock >*
ClockSnapshot::mutable_clocks() {
  // @@protoc_insertion_point(field_mutable_list:perfetto.protos.ClockSnapshot.clocks)
  return &clocks_;
}
const ::google::protobuf::RepeatedPtrField< ::perfetto::protos::ClockSnapshot_Clock >&
ClockSnapshot::clocks() const {
  // @@protoc_insertion_point(field_list:perfetto.protos.ClockSnapshot.clocks)
  return clocks_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/trigger.pb.cc
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/trigger.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/trace/trigger.proto

#ifndef PROTOBUF_perfetto_2ftrace_2ftrigger_2eproto__INCLUDED
#define PROTOBUF_perfetto_2ftrace_2ftrigger_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_perfetto_2ftrace_2ftrigger_2eproto();
void protobuf_AssignDesc_perfetto_2ftrace_2ftrigger_2eproto();
void protobuf_ShutdownFile_perfetto_2ftrace_2ftrigger_2eproto();

class Trigger;

// ===================================================================

class Trigger : public ::google::protobuf::MessageLite {
 public:
  Trigger();
  virtual ~Trigger();

  Trigger(const Trigger& from);

  inline Trigger& operator=(const Trigger& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Trigger& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Trigger* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Trigger* other);

  // implements Message ----------------------------------------------

  inline Trigger* New() const { return New(NULL); }

  Trigger* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Trigger& from);
  void MergeFrom(const Trigger& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Trigger* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string trigger_name = 1;
  bool has_trigger_name() const;
  void clear_trigger_name();
  static const int kTriggerNameFieldNumber = 1;
  const ::std::string& trigger_name() const;
  void set_trigger_name(const ::std::string& value);
  void set_trigger_name(const char* value);
  void set_trigger_name(const char* value, size_t size);
  ::std::string* mutable_trigger_name();
  ::std::string* release_trigger_name();
  void set_allocated_trigger_name(::std::string* trigger_name);

  // optional string producer_name = 2;
  bool has_producer_name() const;
  void clear_producer_name();
  static const int kProducerNameFieldNumber = 2;
  const ::std::string& producer_name() const;
  void set_producer_name(const ::std::string& value);
  void set_producer_name(const char* value);
  void set_producer_name(const char* value, size_t size);
  ::std::string* mutable_producer_name();
  ::std::string* release_producer_name();
  void set_allocated_producer_name(::std::string* producer_name);

  // optional int32 trusted_producer_uid = 3;
  bool has_trusted_producer_uid() const;
  void clear_trusted_producer_uid();
  static const int kTrustedProducerUidFieldNumber = 3;
  ::google::protobuf::int32 trusted_producer_uid() const;
  void set_trusted_producer_uid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:perfetto.protos.Trigger)
 private:
  inline void set_has_trigger_name();
  inline void clear_has_trigger_name();
  inline void set_has_producer_name();
  inline void clear_has_producer_name();
  inline void set_has_trusted_producer_uid();
  inline void clear_has_trusted_producer_uid();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr trigger_name_;
  ::google::protobuf::internal::ArenaStringPtr producer_name_;
  ::google::protobuf::int32 trusted_producer_uid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2ftrace_2ftrigger_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2ftrace_2ftrigger_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2ftrace_2ftrigger_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2ftrace_2ftrigger_2eproto();

  void InitAsDefaultInstance();
  static Trigger* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Trigger

// optional string trigger_name = 1;
inline bool Trigger::has_trigger_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Trigger::set_has_trigger_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Trigger::clear_has_trigger_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Trigger::clear_trigger_name() {
  trigger_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_trigger_name();
}
inline const ::std::string& Trigger::trigger_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.Trigger.trigger_name)
  return trigger_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Trigger::set_trigger_name(const ::std::string& value) {
  set_has_trigger_name();
  trigger_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.Trigger.trigger_name)
}
inline void Trigger::set_trigger_name(const char* value) {
  set_has_trigger_name();
  trigger_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.Trigger.trigger_name)
}
inline void Trigger::set_trigger_name(const char* value, size_t size) {
  set_has_trigger_name();
  trigger_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.Trigger.trigger_name)
}
inline ::std::string* Trigger::mutable_trigger_name() {
  set_has_trigger_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.Trigger.trigger_name)
  return trigger_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Trigger::release_trigger_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.Trigger.trigger_name)
  clear_has_trigger_name();
  return trigger_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Trigger::set_allocated_trigger_name(::std::string* trigger_name) {
  if (trigger_name != NULL) {
    set_has_trigger_name();
  } else {
    clear_has_trigger_name();
  }
  trigger_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), trigger_name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.Trigger.trigger_name)
}

// optional string producer_name = 2;
inline bool Trigger::has_producer_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Trigger::set_has_producer_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Trigger::clear_has_producer_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Trigger::clear_producer_name() {
  producer_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_producer_name();
}
inline const ::std::string& Trigger::producer_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.Trigger.producer_name)
  return producer_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Trigger::set_producer_name(const ::std::string& value) {
  set_has_producer_name();
  producer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.Trigger.producer_name)
}
inline void Trigger::set_producer_name(const char* value) {
  set_has_producer_name();
  producer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.Trigger.producer_name)
}
inline void Trigger::set_producer_name(const char* value, size_t size) {
  set_has_producer_name();
  producer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.Trigger.producer_name)
}
inline ::std::string* Trigger::mutable_producer_name() {
  set_has_producer_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.Trigger.producer_name)
  return producer_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Trigger::release_producer_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.Trigger.producer_name)
  clear_has_producer_name();
  return producer_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Trigger::set_allocated_producer_name(::std::string* producer_name) {
  if (producer_name != NULL) {
    set_has_producer_name();
  } else {
    clear_has_producer_name();
  }
  producer_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), producer_name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.Trigger.producer_name)
}

// optional int32 trusted_producer_uid = 3;
inline bool Trigger::has_trusted_producer_uid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Trigger::set_has_trusted_producer_uid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Trigger::clear_has_trusted_producer_uid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Trigger::clear_trusted_producer_uid() {
  trusted_producer_uid_ = 0;
  clear_has_trusted_producer_uid();
}
inline ::google::protobuf::int32 Trigger::trusted_producer_uid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.Trigger.trusted_producer_uid)
  return trusted_producer_uid_;
}
inline void Trigger::set_trusted_producer_uid(::google::protobuf::int32 value) {
  set_has_trusted_producer_uid();
  trusted_producer_uid_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.Trigger.trusted_producer_uid)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_perfetto_2ftrace_2ftrigger_2eproto__INCLUDED
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/trace/trigger.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
// gen_amalgamated expanded: #include "perfetto/trace/trigger.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

void protobuf_ShutdownFile_perfetto_2ftrace_2ftrigger_2eproto() {
  delete Trigger::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_perfetto_2ftrace_2ftrigger_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_perfetto_2ftrace_2ftrigger_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  Trigger::default_instance_ = new Trigger();
  Trigger::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_perfetto_2ftrace_2ftrigger_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_perfetto_2ftrace_2ftrigger_2eproto_once_);
void protobuf_AddDesc_perfetto_2ftrace_2ftrigger_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_perfetto_2ftrace_2ftrigger_2eproto_once_,
                 &protobuf_AddDesc_perfetto_2ftrace_2ftrigger_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_perfetto_2ftrace_2ftrigger_2eproto {
  StaticDescriptorInitializer_perfetto_2ftrace_2ftrigger_2eproto() {
    protobuf_AddDesc_perfetto_2ftrace_2ftrigger_2eproto();
  }
} static_descriptor_initializer_perfetto_2ftrace_2ftrigger_2eproto_;
#endif

namespace {

static void trigger_pb_MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
static void trigger_pb_MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

static ::std::string* MutableUnknownFieldsForTrigger(
    Trigger* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Trigger::kTriggerNameFieldNumber;
const int Trigger::kProducerNameFieldNumber;
const int Trigger::kTrustedProducerUidFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Trigger::Trigger()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Trigger)
}

void Trigger::InitAsDefaultInstance() {
}

Trigger::Trigger(const Trigger& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Trigger)
}

void Trigger::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  trigger_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  producer_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  trusted_producer_uid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Trigger::~Trigger() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Trigger)
  SharedDtor();
}

void Trigger::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  trigger_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  producer_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Trigger::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Trigger& Trigger::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2ftrace_2ftrigger_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2ftrace_2ftrigger_2eproto();
#endif
  return *default_instance_;
}

Trigger* Trigger::default_instance_ = NULL;

Trigger* Trigger::New(::google::protobuf::Arena* arena) const {
  Trigger* n = new Trigger;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Trigger::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Trigger)
  if (_has_bits_[0 / 32] & 7u) {
    if (has_trigger_name()) {
      trigger_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_producer_name()) {
      producer_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    trusted_producer_uid_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool Trigger::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForTrigger, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Trigger)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string trigger_name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_trigger_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_producer_name;
        break;
      }

      // optional string producer_name = 2;
      case 2: {
        if (tag == 18) {
         parse_producer_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_producer_name()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_trusted_producer_uid;
        break;
      }

      // optional int32 trusted_producer_uid = 3;
      case 3: {
        if (tag == 24) {
         parse_trusted_producer_uid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &trusted_producer_uid_)));
          set_has_trusted_producer_uid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Trigger)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Trigger)
  return false;
#undef DO_
}

void Trigger::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Trigger)
  // optional string trigger_name = 1;
  if (has_trigger_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->trigger_name(), output);
  }

  // optional string producer_name = 2;
  if (has_producer_name()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->producer_name(), output);
  }

  // optional int32 trusted_producer_uid = 3;
  if (has_trusted_producer_uid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->trusted_producer_uid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Trigger)
}

int Trigger::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Trigger)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 7u) {
    // optional string trigger_name = 1;
    if (has_trigger_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->trigger_name());
    }

    // optional string producer_name = 2;
    if (has_producer_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->producer_name());
    }

    // optional int32 trusted_producer_uid = 3;
    if (has_trusted_producer_uid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->trusted_producer_uid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Trigger::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Trigger*>(&from));
}

void Trigger::MergeFrom(const Trigger& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Trigger)
  if (GOOGLE_PREDICT_FALSE(&from == this)) trigger_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_trigger_name()) {
      set_has_trigger_name();
      trigger_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.trigger_name_);
    }
    if (from.has_producer_name()) {
      set_has_producer_name();
      producer_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.producer_name_);
    }
    if (from.has_trusted_producer_uid()) {
      set_trusted_producer_uid(from.trusted_producer_uid());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void Trigger::CopyFrom(const Trigger& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Trigger)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Trigger::IsInitialized() const {

  return true;
}

void Trigger::Swap(Trigger* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Trigger::InternalSwap(Trigger* other) {
  trigger_name_.Swap(&other->trigger_name_);
  producer_name_.Swap(&other->producer_name_);
  std::swap(trusted_producer_uid_, other->trusted_producer_uid_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Trigger::GetTypeName() const {
  return "perfetto.protos.Trigger";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Trigger

// optional string trigger_name = 1;
bool Trigger::has_trigger_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Trigger::set_has_trigger_name() {
  _has_bits_[0] |= 0x00000001u;
}
void Trigger::clear_has_trigger_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void Trigger::clear_trigger_name() {
  trigger_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_trigger_name();
}
 const ::std::string& Trigger::trigger_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.Trigger.trigger_name)
  return trigger_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Trigger::set_trigger_name(const ::std::string& value) {
  set_has_trigger_name();
  trigger_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.Trigger.trigger_name)
}
 void Trigger::set_trigger_name(const char* value) {
  set_has_trigger_name();
  trigger_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.Trigger.trigger_name)
}
 void Trigger::set_trigger_name(const char* value, size_t size) {
  set_has_trigger_name();
  trigger_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.Trigger.trigger_name)
}
 ::std::string* Trigger::mutable_trigger_name() {
  set_has_trigger_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.Trigger.trigger_name)
  return trigger_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Trigger::release_trigger_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.Trigger.trigger_name)
  clear_has_trigger_name();
  return trigger_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Trigger::set_allocated_trigger_name(::std::string* trigger_name) {
  if (trigger_name != NULL) {
    set_has_trigger_name();
  } else {
    clear_has_trigger_name();
  }
  trigger_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), trigger_name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.Trigger.trigger_name)
}

// optional string producer_name = 2;
bool Trigger::has_producer_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Trigger::set_has_producer_name() {
  _has_bits_[0] |= 0x00000002u;
}
void Trigger::clear_has_producer_name() {
  _has_bits_[0] &= ~0x00000002u;
}
void Trigger::clear_producer_name() {
  producer_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_producer_name();
}
 const ::std::string& Trigger::producer_name() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.Trigger.producer_name)
  return producer_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Trigger::set_producer_name(const ::std::string& value) {
  set_has_producer_name();
  producer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.Trigger.producer_name)
}
 void Trigger::set_producer_name(const char* value) {
  set_has_producer_name();
  producer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.Trigger.producer_name)
}
 void Trigger::set_producer_name(const char* value, size_t size) {
  set_has_producer_name();
  producer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.Trigger.producer_name)
}
 ::std::string* Trigger::mutable_producer_name() {
  set_has_producer_name();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.Trigger.producer_name)
  return producer_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Trigger::release_producer_name() {
  // @@protoc_insertion_point(field_release:perfetto.protos.Trigger.producer_name)
  clear_has_producer_name();
  return producer_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Trigger::set_allocated_producer_name(::std::string* producer_name) {
  if (producer_name != NULL) {
    set_has_producer_name();
  } else {
    clear_has_producer_name();
  }
  producer_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), producer_name);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.Trigger.producer_name)
}

// optional int32 trusted_producer_uid = 3;
bool Trigger::has_trusted_producer_uid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Trigger::set_has_trusted_producer_uid() {
  _has_bits_[0] |= 0x00000004u;
}
void Trigger::clear_has_trusted_producer_uid() {
  _has_bits_[0] &= ~0x00000004u;
}
void Trigger::clear_trusted_producer_uid() {
  trusted_producer_uid_ = 0;
  clear_has_trusted_producer_uid();
}
 ::google::protobuf::int32 Trigger::trusted_producer_uid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.Trigger.trusted_producer_uid)
  return trusted_producer_uid_;
}
 void Trigger::set_trusted_producer_uid(::google::protobuf::int32 value) {
  set_has_trusted_producer_uid();
  trusted_producer_uid_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.Trigger.trusted_producer_uid)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/system_info.pb.cc
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/system_info.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/trace/system_info.proto

#ifndef PROTOBUF_perfetto_2ftrace_2fsystem_5finfo_2eproto__INCLUDED
#define PROTOBUF_perfetto_2ftrace_2fsystem_5finfo_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_perfetto_2ftrace_2fsystem_5finfo_2eproto();
void protobuf_AssignDesc_perfetto_2ftrace_2fsystem_5finfo_2eproto();
void protobuf_ShutdownFile_perfetto_2ftrace_2fsystem_5finfo_2eproto();

class SystemInfo;
class Utsname;

// ===================================================================

class Utsname : public ::google::protobuf::MessageLite {
 public:
  Utsname();
  virtual ~Utsname();

  Utsname(const Utsname& from);

  inline Utsname& operator=(const Utsname& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Utsname& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Utsname* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Utsname* other);

  // implements Message ----------------------------------------------

  inline Utsname* New() const { return New(NULL); }

  Utsname* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Utsname& from);
  void MergeFrom(const Utsname& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Utsname* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string sysname = 1;
  bool has_sysname() const;
  void clear_sysname();
  static const int kSysnameFieldNumber = 1;
  const ::std::string& sysname() const;
  void set_sysname(const ::std::string& value);
  void set_sysname(const char* value);
  void set_sysname(const char* value, size_t size);
  ::std::string* mutable_sysname();
  ::std::string* release_sysname();
  void set_allocated_sysname(::std::string* sysname);

  // optional string version = 2;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // optional string release = 3;
  bool has_release() const;
  void clear_release();
  static const int kReleaseFieldNumber = 3;
  const ::std::string& release() const;
  void set_release(const ::std::string& value);
  void set_release(const char* value);
  void set_release(const char* value, size_t size);
  ::std::string* mutable_release();
  ::std::string* release_release();
  void set_allocated_release(::std::string* release);

  // optional string machine = 4;
  bool has_machine() const;
  void clear_machine();
  static const int kMachineFieldNumber = 4;
  const ::std::string& machine() const;
  void set_machine(const ::std::string& value);
  void set_machine(const char* value);
  void set_machine(const char* value, size_t size);
  ::std::string* mutable_machine();
  ::std::string* release_machine();
  void set_allocated_machine(::std::string* machine);

  // @@protoc_insertion_point(class_scope:perfetto.protos.Utsname)
 private:
  inline void set_has_sysname();
  inline void clear_has_sysname();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_release();
  inline void clear_has_release();
  inline void set_has_machine();
  inline void clear_has_machine();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr sysname_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr release_;
  ::google::protobuf::internal::ArenaStringPtr machine_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2ftrace_2fsystem_5finfo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2ftrace_2fsystem_5finfo_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2ftrace_2fsystem_5finfo_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2ftrace_2fsystem_5finfo_2eproto();

  void InitAsDefaultInstance();
  static Utsname* default_instance_;
};
// -------------------------------------------------------------------

class SystemInfo : public ::google::protobuf::MessageLite {
 public:
  SystemInfo();
  virtual ~SystemInfo();

  SystemInfo(const SystemInfo& from);

  inline SystemInfo& operator=(const SystemInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const SystemInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SystemInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SystemInfo* other);

  // implements Message ----------------------------------------------

  inline SystemInfo* New() const { return New(NULL); }

  SystemInfo* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SystemInfo& from);
  void MergeFrom(const SystemInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SystemInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .perfetto.protos.Utsname utsname = 1;
  bool has_utsname() const;
  void clear_utsname();
  static const int kUtsnameFieldNumber = 1;
  const ::perfetto::protos::Utsname& utsname() const;
  ::perfetto::protos::Utsname* mutable_utsname();
  ::perfetto::protos::Utsname* release_utsname();
  void set_allocated_utsname(::perfetto::protos::Utsname* utsname);

  // @@protoc_insertion_point(class_scope:perfetto.protos.SystemInfo)
 private:
  inline void set_has_utsname();
  inline void clear_has_utsname();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::perfetto::protos::Utsname* utsname_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2ftrace_2fsystem_5finfo_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2ftrace_2fsystem_5finfo_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2ftrace_2fsystem_5finfo_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2ftrace_2fsystem_5finfo_2eproto();

  void InitAsDefaultInstance();
  static SystemInfo* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Utsname

// optional string sysname = 1;
inline bool Utsname::has_sysname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Utsname::set_has_sysname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Utsname::clear_has_sysname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Utsname::clear_sysname() {
  sysname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sysname();
}
inline const ::std::string& Utsname::sysname() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.Utsname.sysname)
  return sysname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Utsname::set_sysname(const ::std::string& value) {
  set_has_sysname();
  sysname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.Utsname.sysname)
}
inline void Utsname::set_sysname(const char* value) {
  set_has_sysname();
  sysname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.Utsname.sysname)
}
inline void Utsname::set_sysname(const char* value, size_t size) {
  set_has_sysname();
  sysname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.Utsname.sysname)
}
inline ::std::string* Utsname::mutable_sysname() {
  set_has_sysname();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.Utsname.sysname)
  return sysname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Utsname::release_sysname() {
  // @@protoc_insertion_point(field_release:perfetto.protos.Utsname.sysname)
  clear_has_sysname();
  return sysname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Utsname::set_allocated_sysname(::std::string* sysname) {
  if (sysname != NULL) {
    set_has_sysname();
  } else {
    clear_has_sysname();
  }
  sysname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sysname);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.Utsname.sysname)
}

// optional string version = 2;
inline bool Utsname::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Utsname::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Utsname::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Utsname::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_version();
}
inline const ::std::string& Utsname::version() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.Utsname.version)
  return version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Utsname::set_version(const ::std::string& value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.Utsname.version)
}
inline void Utsname::set_version(const char* value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.Utsname.version)
}
inline void Utsname::set_version(const char* value, size_t size) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.Utsname.version)
}
inline ::std::string* Utsname::mutable_version() {
  set_has_version();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.Utsname.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Utsname::release_version() {
  // @@protoc_insertion_point(field_release:perfetto.protos.Utsname.version)
  clear_has_version();
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Utsname::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.Utsname.version)
}

// optional string release = 3;
inline bool Utsname::has_release() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Utsname::set_has_release() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Utsname::clear_has_release() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Utsname::clear_release() {
  release_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_release();
}
inline const ::std::string& Utsname::release() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.Utsname.release)
  return release_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Utsname::set_release(const ::std::string& value) {
  set_has_release();
  release_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.Utsname.release)
}
inline void Utsname::set_release(const char* value) {
  set_has_release();
  release_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.Utsname.release)
}
inline void Utsname::set_release(const char* value, size_t size) {
  set_has_release();
  release_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.Utsname.release)
}
inline ::std::string* Utsname::mutable_release() {
  set_has_release();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.Utsname.release)
  return release_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Utsname::release_release() {
  // @@protoc_insertion_point(field_release:perfetto.protos.Utsname.release)
  clear_has_release();
  return release_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Utsname::set_allocated_release(::std::string* release) {
  if (release != NULL) {
    set_has_release();
  } else {
    clear_has_release();
  }
  release_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), release);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.Utsname.release)
}

// optional string machine = 4;
inline bool Utsname::has_machine() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Utsname::set_has_machine() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Utsname::clear_has_machine() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Utsname::clear_machine() {
  machine_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_machine();
}
inline const ::std::string& Utsname::machine() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.Utsname.machine)
  return machine_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Utsname::set_machine(const ::std::string& value) {
  set_has_machine();
  machine_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.Utsname.machine)
}
inline void Utsname::set_machine(const char* value) {
  set_has_machine();
  machine_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.Utsname.machine)
}
inline void Utsname::set_machine(const char* value, size_t size) {
  set_has_machine();
  machine_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.Utsname.machine)
}
inline ::std::string* Utsname::mutable_machine() {
  set_has_machine();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.Utsname.machine)
  return machine_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Utsname::release_machine() {
  // @@protoc_insertion_point(field_release:perfetto.protos.Utsname.machine)
  clear_has_machine();
  return machine_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Utsname::set_allocated_machine(::std::string* machine) {
  if (machine != NULL) {
    set_has_machine();
  } else {
    clear_has_machine();
  }
  machine_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), machine);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.Utsname.machine)
}

// -------------------------------------------------------------------

// SystemInfo

// optional .perfetto.protos.Utsname utsname = 1;
inline bool SystemInfo::has_utsname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SystemInfo::set_has_utsname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SystemInfo::clear_has_utsname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SystemInfo::clear_utsname() {
  if (utsname_ != NULL) utsname_->::perfetto::protos::Utsname::Clear();
  clear_has_utsname();
}
inline const ::perfetto::protos::Utsname& SystemInfo::utsname() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SystemInfo.utsname)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return utsname_ != NULL ? *utsname_ : *default_instance().utsname_;
#else
  return utsname_ != NULL ? *utsname_ : *default_instance_->utsname_;
#endif
}
inline ::perfetto::protos::Utsname* SystemInfo::mutable_utsname() {
  set_has_utsname();
  if (utsname_ == NULL) {
    utsname_ = new ::perfetto::protos::Utsname;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.SystemInfo.utsname)
  return utsname_;
}
inline ::perfetto::protos::Utsname* SystemInfo::release_utsname() {
  // @@protoc_insertion_point(field_release:perfetto.protos.SystemInfo.utsname)
  clear_has_utsname();
  ::perfetto::protos::Utsname* temp = utsname_;
  utsname_ = NULL;
  return temp;
}
inline void SystemInfo::set_allocated_utsname(::perfetto::protos::Utsname* utsname) {
  delete utsname_;
  utsname_ = utsname;
  if (utsname) {
    set_has_utsname();
  } else {
    clear_has_utsname();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.SystemInfo.utsname)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_perfetto_2ftrace_2fsystem_5finfo_2eproto__INCLUDED
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/trace/system_info.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
// gen_amalgamated expanded: #include "perfetto/trace/system_info.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

void protobuf_ShutdownFile_perfetto_2ftrace_2fsystem_5finfo_2eproto() {
  delete Utsname::default_instance_;
  delete SystemInfo::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_perfetto_2ftrace_2fsystem_5finfo_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_perfetto_2ftrace_2fsystem_5finfo_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  Utsname::default_instance_ = new Utsname();
  SystemInfo::default_instance_ = new SystemInfo();
  Utsname::default_instance_->InitAsDefaultInstance();
  SystemInfo::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_perfetto_2ftrace_2fsystem_5finfo_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_perfetto_2ftrace_2fsystem_5finfo_2eproto_once_);
void protobuf_AddDesc_perfetto_2ftrace_2fsystem_5finfo_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_perfetto_2ftrace_2fsystem_5finfo_2eproto_once_,
                 &protobuf_AddDesc_perfetto_2ftrace_2fsystem_5finfo_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_perfetto_2ftrace_2fsystem_5finfo_2eproto {
  StaticDescriptorInitializer_perfetto_2ftrace_2fsystem_5finfo_2eproto() {
    protobuf_AddDesc_perfetto_2ftrace_2fsystem_5finfo_2eproto();
  }
} static_descriptor_initializer_perfetto_2ftrace_2fsystem_5finfo_2eproto_;
#endif

namespace {

static void system_info_pb_MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
static void system_info_pb_MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

static ::std::string* MutableUnknownFieldsForUtsname(
    Utsname* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Utsname::kSysnameFieldNumber;
const int Utsname::kVersionFieldNumber;
const int Utsname::kReleaseFieldNumber;
const int Utsname::kMachineFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Utsname::Utsname()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.Utsname)
}

void Utsname::InitAsDefaultInstance() {
}

Utsname::Utsname(const Utsname& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.Utsname)
}

void Utsname::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  sysname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  version_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  release_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  machine_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Utsname::~Utsname() {
  // @@protoc_insertion_point(destructor:perfetto.protos.Utsname)
  SharedDtor();
}

void Utsname::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  sysname_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  version_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  release_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  machine_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Utsname::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Utsname& Utsname::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2ftrace_2fsystem_5finfo_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2ftrace_2fsystem_5finfo_2eproto();
#endif
  return *default_instance_;
}

Utsname* Utsname::default_instance_ = NULL;

Utsname* Utsname::New(::google::protobuf::Arena* arena) const {
  Utsname* n = new Utsname;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Utsname::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.Utsname)
  if (_has_bits_[0 / 32] & 15u) {
    if (has_sysname()) {
      sysname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_version()) {
      version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_release()) {
      release_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_machine()) {
      machine_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool Utsname::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForUtsname, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.Utsname)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string sysname = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_sysname()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_version;
        break;
      }

      // optional string version = 2;
      case 2: {
        if (tag == 18) {
         parse_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_release;
        break;
      }

      // optional string release = 3;
      case 3: {
        if (tag == 26) {
         parse_release:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_release()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_machine;
        break;
      }

      // optional string machine = 4;
      case 4: {
        if (tag == 34) {
         parse_machine:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_machine()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.Utsname)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.Utsname)
  return false;
#undef DO_
}

void Utsname::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.Utsname)
  // optional string sysname = 1;
  if (has_sysname()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->sysname(), output);
  }

  // optional string version = 2;
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->version(), output);
  }

  // optional string release = 3;
  if (has_release()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->release(), output);
  }

  // optional string machine = 4;
  if (has_machine()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->machine(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.Utsname)
}

int Utsname::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.Utsname)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 15u) {
    // optional string sysname = 1;
    if (has_sysname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->sysname());
    }

    // optional string version = 2;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->version());
    }

    // optional string release = 3;
    if (has_release()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->release());
    }

    // optional string machine = 4;
    if (has_machine()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->machine());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Utsname::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Utsname*>(&from));
}

void Utsname::MergeFrom(const Utsname& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.Utsname)
  if (GOOGLE_PREDICT_FALSE(&from == this)) system_info_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sysname()) {
      set_has_sysname();
      sysname_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.sysname_);
    }
    if (from.has_version()) {
      set_has_version();
      version_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.version_);
    }
    if (from.has_release()) {
      set_has_release();
      release_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.release_);
    }
    if (from.has_machine()) {
      set_has_machine();
      machine_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.machine_);
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void Utsname::CopyFrom(const Utsname& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.Utsname)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Utsname::IsInitialized() const {

  return true;
}

void Utsname::Swap(Utsname* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Utsname::InternalSwap(Utsname* other) {
  sysname_.Swap(&other->sysname_);
  version_.Swap(&other->version_);
  release_.Swap(&other->release_);
  machine_.Swap(&other->machine_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Utsname::GetTypeName() const {
  return "perfetto.protos.Utsname";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Utsname

// optional string sysname = 1;
bool Utsname::has_sysname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Utsname::set_has_sysname() {
  _has_bits_[0] |= 0x00000001u;
}
void Utsname::clear_has_sysname() {
  _has_bits_[0] &= ~0x00000001u;
}
void Utsname::clear_sysname() {
  sysname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sysname();
}
 const ::std::string& Utsname::sysname() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.Utsname.sysname)
  return sysname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Utsname::set_sysname(const ::std::string& value) {
  set_has_sysname();
  sysname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.Utsname.sysname)
}
 void Utsname::set_sysname(const char* value) {
  set_has_sysname();
  sysname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.Utsname.sysname)
}
 void Utsname::set_sysname(const char* value, size_t size) {
  set_has_sysname();
  sysname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.Utsname.sysname)
}
 ::std::string* Utsname::mutable_sysname() {
  set_has_sysname();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.Utsname.sysname)
  return sysname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Utsname::release_sysname() {
  // @@protoc_insertion_point(field_release:perfetto.protos.Utsname.sysname)
  clear_has_sysname();
  return sysname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Utsname::set_allocated_sysname(::std::string* sysname) {
  if (sysname != NULL) {
    set_has_sysname();
  } else {
    clear_has_sysname();
  }
  sysname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sysname);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.Utsname.sysname)
}

// optional string version = 2;
bool Utsname::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Utsname::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
void Utsname::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
void Utsname::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_version();
}
 const ::std::string& Utsname::version() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.Utsname.version)
  return version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Utsname::set_version(const ::std::string& value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.Utsname.version)
}
 void Utsname::set_version(const char* value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.Utsname.version)
}
 void Utsname::set_version(const char* value, size_t size) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.Utsname.version)
}
 ::std::string* Utsname::mutable_version() {
  set_has_version();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.Utsname.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Utsname::release_version() {
  // @@protoc_insertion_point(field_release:perfetto.protos.Utsname.version)
  clear_has_version();
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Utsname::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.Utsname.version)
}

// optional string release = 3;
bool Utsname::has_release() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Utsname::set_has_release() {
  _has_bits_[0] |= 0x00000004u;
}
void Utsname::clear_has_release() {
  _has_bits_[0] &= ~0x00000004u;
}
void Utsname::clear_release() {
  release_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_release();
}
 const ::std::string& Utsname::release() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.Utsname.release)
  return release_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Utsname::set_release(const ::std::string& value) {
  set_has_release();
  release_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.Utsname.release)
}
 void Utsname::set_release(const char* value) {
  set_has_release();
  release_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.Utsname.release)
}
 void Utsname::set_release(const char* value, size_t size) {
  set_has_release();
  release_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.Utsname.release)
}
 ::std::string* Utsname::mutable_release() {
  set_has_release();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.Utsname.release)
  return release_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Utsname::release_release() {
  // @@protoc_insertion_point(field_release:perfetto.protos.Utsname.release)
  clear_has_release();
  return release_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Utsname::set_allocated_release(::std::string* release) {
  if (release != NULL) {
    set_has_release();
  } else {
    clear_has_release();
  }
  release_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), release);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.Utsname.release)
}

// optional string machine = 4;
bool Utsname::has_machine() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Utsname::set_has_machine() {
  _has_bits_[0] |= 0x00000008u;
}
void Utsname::clear_has_machine() {
  _has_bits_[0] &= ~0x00000008u;
}
void Utsname::clear_machine() {
  machine_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_machine();
}
 const ::std::string& Utsname::machine() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.Utsname.machine)
  return machine_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Utsname::set_machine(const ::std::string& value) {
  set_has_machine();
  machine_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.Utsname.machine)
}
 void Utsname::set_machine(const char* value) {
  set_has_machine();
  machine_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.Utsname.machine)
}
 void Utsname::set_machine(const char* value, size_t size) {
  set_has_machine();
  machine_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.Utsname.machine)
}
 ::std::string* Utsname::mutable_machine() {
  set_has_machine();
  // @@protoc_insertion_point(field_mutable:perfetto.protos.Utsname.machine)
  return machine_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Utsname::release_machine() {
  // @@protoc_insertion_point(field_release:perfetto.protos.Utsname.machine)
  clear_has_machine();
  return machine_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Utsname::set_allocated_machine(::std::string* machine) {
  if (machine != NULL) {
    set_has_machine();
  } else {
    clear_has_machine();
  }
  machine_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), machine);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.Utsname.machine)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForSystemInfo(
    SystemInfo* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SystemInfo::kUtsnameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SystemInfo::SystemInfo()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.SystemInfo)
}

void SystemInfo::InitAsDefaultInstance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  utsname_ = const_cast< ::perfetto::protos::Utsname*>(
      ::perfetto::protos::Utsname::internal_default_instance());
#else
  utsname_ = const_cast< ::perfetto::protos::Utsname*>(&::perfetto::protos::Utsname::default_instance());
#endif
}

SystemInfo::SystemInfo(const SystemInfo& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.SystemInfo)
}

void SystemInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  utsname_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SystemInfo::~SystemInfo() {
  // @@protoc_insertion_point(destructor:perfetto.protos.SystemInfo)
  SharedDtor();
}

void SystemInfo::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete utsname_;
  }
}

void SystemInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SystemInfo& SystemInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2ftrace_2fsystem_5finfo_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2ftrace_2fsystem_5finfo_2eproto();
#endif
  return *default_instance_;
}

SystemInfo* SystemInfo::default_instance_ = NULL;

SystemInfo* SystemInfo::New(::google::protobuf::Arena* arena) const {
  SystemInfo* n = new SystemInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SystemInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.SystemInfo)
  if (has_utsname()) {
    if (utsname_ != NULL) utsname_->::perfetto::protos::Utsname::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool SystemInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::internal::NewPermanentCallback(
          &MutableUnknownFieldsForSystemInfo, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:perfetto.protos.SystemInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .perfetto.protos.Utsname utsname = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_utsname()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.SystemInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.SystemInfo)
  return false;
#undef DO_
}

void SystemInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.SystemInfo)
  // optional .perfetto.protos.Utsname utsname = 1;
  if (has_utsname()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->utsname_, output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:perfetto.protos.SystemInfo)
}

int SystemInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.SystemInfo)
  int total_size = 0;

  // optional .perfetto.protos.Utsname utsname = 1;
  if (has_utsname()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->utsname_);
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SystemInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SystemInfo*>(&from));
}

void SystemInfo::MergeFrom(const SystemInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.SystemInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) system_info_pb_MergeFromFail(__LINE__);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_utsname()) {
      mutable_utsname()->::perfetto::protos::Utsname::MergeFrom(from.utsname());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void SystemInfo::CopyFrom(const SystemInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.SystemInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SystemInfo::IsInitialized() const {

  return true;
}

void SystemInfo::Swap(SystemInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SystemInfo::InternalSwap(SystemInfo* other) {
  std::swap(utsname_, other->utsname_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string SystemInfo::GetTypeName() const {
  return "perfetto.protos.SystemInfo";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SystemInfo

// optional .perfetto.protos.Utsname utsname = 1;
bool SystemInfo::has_utsname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void SystemInfo::set_has_utsname() {
  _has_bits_[0] |= 0x00000001u;
}
void SystemInfo::clear_has_utsname() {
  _has_bits_[0] &= ~0x00000001u;
}
void SystemInfo::clear_utsname() {
  if (utsname_ != NULL) utsname_->::perfetto::protos::Utsname::Clear();
  clear_has_utsname();
}
const ::perfetto::protos::Utsname& SystemInfo::utsname() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.SystemInfo.utsname)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return utsname_ != NULL ? *utsname_ : *default_instance().utsname_;
#else
  return utsname_ != NULL ? *utsname_ : *default_instance_->utsname_;
#endif
}
::perfetto::protos::Utsname* SystemInfo::mutable_utsname() {
  set_has_utsname();
  if (utsname_ == NULL) {
    utsname_ = new ::perfetto::protos::Utsname;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.SystemInfo.utsname)
  return utsname_;
}
::perfetto::protos::Utsname* SystemInfo::release_utsname() {
  // @@protoc_insertion_point(field_release:perfetto.protos.SystemInfo.utsname)
  clear_has_utsname();
  ::perfetto::protos::Utsname* temp = utsname_;
  utsname_ = NULL;
  return temp;
}
void SystemInfo::set_allocated_utsname(::perfetto::protos::Utsname* utsname) {
  delete utsname_;
  utsname_ = utsname;
  if (utsname) {
    set_has_utsname();
  } else {
    clear_has_utsname();
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.SystemInfo.utsname)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/trusted_packet.pb.cc
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/trusted_packet.pb.h
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/trace/trusted_packet.proto

#ifndef PROTOBUF_perfetto_2ftrace_2ftrusted_5fpacket_2eproto__INCLUDED
#define PROTOBUF_perfetto_2ftrace_2ftrusted_5fpacket_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// gen_amalgamated expanded: #include "perfetto/common/trace_stats.pb.h"
// gen_amalgamated expanded: #include "perfetto/config/trace_config.pb.h"
// gen_amalgamated expanded: #include "perfetto/trace/clock_snapshot.pb.h"
// gen_amalgamated expanded: #include "perfetto/trace/system_info.pb.h"
// gen_amalgamated expanded: #include "perfetto/trace/trigger.pb.h"
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_perfetto_2ftrace_2ftrusted_5fpacket_2eproto();
void protobuf_AssignDesc_perfetto_2ftrace_2ftrusted_5fpacket_2eproto();
void protobuf_ShutdownFile_perfetto_2ftrace_2ftrusted_5fpacket_2eproto();

class TrustedPacket;

// ===================================================================

class TrustedPacket : public ::google::protobuf::MessageLite {
 public:
  TrustedPacket();
  virtual ~TrustedPacket();

  TrustedPacket(const TrustedPacket& from);

  inline TrustedPacket& operator=(const TrustedPacket& from) {
    CopyFrom(from);
    return *this;
  }

  static const TrustedPacket& default_instance();

  enum OptionalTrustedUidCase {
    kTrustedUid = 3,
    OPTIONAL_TRUSTED_UID_NOT_SET = 0,
  };

  enum OptionalTrustedPacketSequenceIdCase {
    kTrustedPacketSequenceId = 10,
    OPTIONAL_TRUSTED_PACKET_SEQUENCE_ID_NOT_SET = 0,
  };

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TrustedPacket* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TrustedPacket* other);

  // implements Message ----------------------------------------------

  inline TrustedPacket* New() const { return New(NULL); }

  TrustedPacket* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TrustedPacket& from);
  void MergeFrom(const TrustedPacket& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TrustedPacket* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 trusted_uid = 3;
  private:
  bool has_trusted_uid() const;
  public:
  void clear_trusted_uid();
  static const int kTrustedUidFieldNumber = 3;
  ::google::protobuf::int32 trusted_uid() const;
  void set_trusted_uid(::google::protobuf::int32 value);

  // optional uint32 trusted_packet_sequence_id = 10;
  private:
  bool has_trusted_packet_sequence_id() const;
  public:
  void clear_trusted_packet_sequence_id();
  static const int kTrustedPacketSequenceIdFieldNumber = 10;
  ::google::protobuf::uint32 trusted_packet_sequence_id() const;
  void set_trusted_packet_sequence_id(::google::protobuf::uint32 value);

  // optional .perfetto.protos.ClockSnapshot clock_snapshot = 6;
  bool has_clock_snapshot() const;
  void clear_clock_snapshot();
  static const int kClockSnapshotFieldNumber = 6;
  const ::perfetto::protos::ClockSnapshot& clock_snapshot() const;
  ::perfetto::protos::ClockSnapshot* mutable_clock_snapshot();
  ::perfetto::protos::ClockSnapshot* release_clock_snapshot();
  void set_allocated_clock_snapshot(::perfetto::protos::ClockSnapshot* clock_snapshot);

  // optional uint64 timestamp = 8;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 8;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // optional .perfetto.protos.TraceConfig trace_config = 33;
  bool has_trace_config() const;
  void clear_trace_config();
  static const int kTraceConfigFieldNumber = 33;
  const ::perfetto::protos::TraceConfig& trace_config() const;
  ::perfetto::protos::TraceConfig* mutable_trace_config();
  ::perfetto::protos::TraceConfig* release_trace_config();
  void set_allocated_trace_config(::perfetto::protos::TraceConfig* trace_config);

  // optional .perfetto.protos.TraceStats trace_stats = 35;
  bool has_trace_stats() const;
  void clear_trace_stats();
  static const int kTraceStatsFieldNumber = 35;
  const ::perfetto::protos::TraceStats& trace_stats() const;
  ::perfetto::protos::TraceStats* mutable_trace_stats();
  ::perfetto::protos::TraceStats* release_trace_stats();
  void set_allocated_trace_stats(::perfetto::protos::TraceStats* trace_stats);

  // optional bytes synchronization_marker = 36;
  void clear_synchronization_marker();
  static const int kSynchronizationMarkerFieldNumber = 36;
  const ::std::string& synchronization_marker() const;
  void set_synchronization_marker(const ::std::string& value);
  void set_synchronization_marker(const char* value);
  void set_synchronization_marker(const void* value, size_t size);
  ::std::string* mutable_synchronization_marker();
  ::std::string* release_synchronization_marker();
  void set_allocated_synchronization_marker(::std::string* synchronization_marker);

  // optional bool previous_packet_dropped = 42;
  void clear_previous_packet_dropped();
  static const int kPreviousPacketDroppedFieldNumber = 42;
  bool previous_packet_dropped() const;
  void set_previous_packet_dropped(bool value);

  // optional .perfetto.protos.SystemInfo system_info = 45;
  bool has_system_info() const;
  void clear_system_info();
  static const int kSystemInfoFieldNumber = 45;
  const ::perfetto::protos::SystemInfo& system_info() const;
  ::perfetto::protos::SystemInfo* mutable_system_info();
  ::perfetto::protos::SystemInfo* release_system_info();
  void set_allocated_system_info(::perfetto::protos::SystemInfo* system_info);

  // optional .perfetto.protos.Trigger trigger = 46;
  bool has_trigger() const;
  void clear_trigger();
  static const int kTriggerFieldNumber = 46;
  const ::perfetto::protos::Trigger& trigger() const;
  ::perfetto::protos::Trigger* mutable_trigger();
  ::perfetto::protos::Trigger* release_trigger();
  void set_allocated_trigger(::perfetto::protos::Trigger* trigger);

  OptionalTrustedUidCase optional_trusted_uid_case() const;
  OptionalTrustedPacketSequenceIdCase optional_trusted_packet_sequence_id_case() const;
  // @@protoc_insertion_point(class_scope:perfetto.protos.TrustedPacket)
 private:
  inline void set_has_trusted_uid();
  inline void set_has_trusted_packet_sequence_id();

  inline bool has_optional_trusted_uid() const;
  void clear_optional_trusted_uid();
  inline void clear_has_optional_trusted_uid();

  inline bool has_optional_trusted_packet_sequence_id() const;
  void clear_optional_trusted_packet_sequence_id();
  inline void clear_has_optional_trusted_packet_sequence_id();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  bool _is_default_instance_;
  ::perfetto::protos::ClockSnapshot* clock_snapshot_;
  ::google::protobuf::uint64 timestamp_;
  ::perfetto::protos::TraceConfig* trace_config_;
  ::perfetto::protos::TraceStats* trace_stats_;
  ::google::protobuf::internal::ArenaStringPtr synchronization_marker_;
  ::perfetto::protos::SystemInfo* system_info_;
  ::perfetto::protos::Trigger* trigger_;
  bool previous_packet_dropped_;
  union OptionalTrustedUidUnion {
    OptionalTrustedUidUnion() {}
    ::google::protobuf::int32 trusted_uid_;
  } optional_trusted_uid_;
  union OptionalTrustedPacketSequenceIdUnion {
    OptionalTrustedPacketSequenceIdUnion() {}
    ::google::protobuf::uint32 trusted_packet_sequence_id_;
  } optional_trusted_packet_sequence_id_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[2];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_perfetto_2ftrace_2ftrusted_5fpacket_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_perfetto_2ftrace_2ftrusted_5fpacket_2eproto();
  #endif
  friend void protobuf_AssignDesc_perfetto_2ftrace_2ftrusted_5fpacket_2eproto();
  friend void protobuf_ShutdownFile_perfetto_2ftrace_2ftrusted_5fpacket_2eproto();

  void InitAsDefaultInstance();
  static TrustedPacket* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// TrustedPacket

// optional int32 trusted_uid = 3;
inline bool TrustedPacket::has_trusted_uid() const {
  return optional_trusted_uid_case() == kTrustedUid;
}
inline void TrustedPacket::set_has_trusted_uid() {
  _oneof_case_[0] = kTrustedUid;
}
inline void TrustedPacket::clear_trusted_uid() {
  if (has_trusted_uid()) {
    optional_trusted_uid_.trusted_uid_ = 0;
    clear_has_optional_trusted_uid();
  }
}
inline ::google::protobuf::int32 TrustedPacket::trusted_uid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TrustedPacket.trusted_uid)
  if (has_trusted_uid()) {
    return optional_trusted_uid_.trusted_uid_;
  }
  return 0;
}
inline void TrustedPacket::set_trusted_uid(::google::protobuf::int32 value) {
  if (!has_trusted_uid()) {
    clear_optional_trusted_uid();
    set_has_trusted_uid();
  }
  optional_trusted_uid_.trusted_uid_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TrustedPacket.trusted_uid)
}

// optional uint32 trusted_packet_sequence_id = 10;
inline bool TrustedPacket::has_trusted_packet_sequence_id() const {
  return optional_trusted_packet_sequence_id_case() == kTrustedPacketSequenceId;
}
inline void TrustedPacket::set_has_trusted_packet_sequence_id() {
  _oneof_case_[1] = kTrustedPacketSequenceId;
}
inline void TrustedPacket::clear_trusted_packet_sequence_id() {
  if (has_trusted_packet_sequence_id()) {
    optional_trusted_packet_sequence_id_.trusted_packet_sequence_id_ = 0u;
    clear_has_optional_trusted_packet_sequence_id();
  }
}
inline ::google::protobuf::uint32 TrustedPacket::trusted_packet_sequence_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TrustedPacket.trusted_packet_sequence_id)
  if (has_trusted_packet_sequence_id()) {
    return optional_trusted_packet_sequence_id_.trusted_packet_sequence_id_;
  }
  return 0u;
}
inline void TrustedPacket::set_trusted_packet_sequence_id(::google::protobuf::uint32 value) {
  if (!has_trusted_packet_sequence_id()) {
    clear_optional_trusted_packet_sequence_id();
    set_has_trusted_packet_sequence_id();
  }
  optional_trusted_packet_sequence_id_.trusted_packet_sequence_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TrustedPacket.trusted_packet_sequence_id)
}

// optional .perfetto.protos.ClockSnapshot clock_snapshot = 6;
inline bool TrustedPacket::has_clock_snapshot() const {
  return !_is_default_instance_ && clock_snapshot_ != NULL;
}
inline void TrustedPacket::clear_clock_snapshot() {
  if (GetArenaNoVirtual() == NULL && clock_snapshot_ != NULL) delete clock_snapshot_;
  clock_snapshot_ = NULL;
}
inline const ::perfetto::protos::ClockSnapshot& TrustedPacket::clock_snapshot() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TrustedPacket.clock_snapshot)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return clock_snapshot_ != NULL ? *clock_snapshot_ : *default_instance().clock_snapshot_;
#else
  return clock_snapshot_ != NULL ? *clock_snapshot_ : *default_instance_->clock_snapshot_;
#endif
}
inline ::perfetto::protos::ClockSnapshot* TrustedPacket::mutable_clock_snapshot() {
  
  if (clock_snapshot_ == NULL) {
    clock_snapshot_ = new ::perfetto::protos::ClockSnapshot;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TrustedPacket.clock_snapshot)
  return clock_snapshot_;
}
inline ::perfetto::protos::ClockSnapshot* TrustedPacket::release_clock_snapshot() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TrustedPacket.clock_snapshot)
  
  ::perfetto::protos::ClockSnapshot* temp = clock_snapshot_;
  clock_snapshot_ = NULL;
  return temp;
}
inline void TrustedPacket::set_allocated_clock_snapshot(::perfetto::protos::ClockSnapshot* clock_snapshot) {
  delete clock_snapshot_;
  clock_snapshot_ = clock_snapshot;
  if (clock_snapshot) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TrustedPacket.clock_snapshot)
}

// optional uint64 timestamp = 8;
inline void TrustedPacket::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 TrustedPacket::timestamp() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TrustedPacket.timestamp)
  return timestamp_;
}
inline void TrustedPacket::set_timestamp(::google::protobuf::uint64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TrustedPacket.timestamp)
}

// optional .perfetto.protos.TraceConfig trace_config = 33;
inline bool TrustedPacket::has_trace_config() const {
  return !_is_default_instance_ && trace_config_ != NULL;
}
inline void TrustedPacket::clear_trace_config() {
  if (GetArenaNoVirtual() == NULL && trace_config_ != NULL) delete trace_config_;
  trace_config_ = NULL;
}
inline const ::perfetto::protos::TraceConfig& TrustedPacket::trace_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TrustedPacket.trace_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return trace_config_ != NULL ? *trace_config_ : *default_instance().trace_config_;
#else
  return trace_config_ != NULL ? *trace_config_ : *default_instance_->trace_config_;
#endif
}
inline ::perfetto::protos::TraceConfig* TrustedPacket::mutable_trace_config() {
  
  if (trace_config_ == NULL) {
    trace_config_ = new ::perfetto::protos::TraceConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TrustedPacket.trace_config)
  return trace_config_;
}
inline ::perfetto::protos::TraceConfig* TrustedPacket::release_trace_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TrustedPacket.trace_config)
  
  ::perfetto::protos::TraceConfig* temp = trace_config_;
  trace_config_ = NULL;
  return temp;
}
inline void TrustedPacket::set_allocated_trace_config(::perfetto::protos::TraceConfig* trace_config) {
  delete trace_config_;
  trace_config_ = trace_config;
  if (trace_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TrustedPacket.trace_config)
}

// optional .perfetto.protos.TraceStats trace_stats = 35;
inline bool TrustedPacket::has_trace_stats() const {
  return !_is_default_instance_ && trace_stats_ != NULL;
}
inline void TrustedPacket::clear_trace_stats() {
  if (GetArenaNoVirtual() == NULL && trace_stats_ != NULL) delete trace_stats_;
  trace_stats_ = NULL;
}
inline const ::perfetto::protos::TraceStats& TrustedPacket::trace_stats() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TrustedPacket.trace_stats)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return trace_stats_ != NULL ? *trace_stats_ : *default_instance().trace_stats_;
#else
  return trace_stats_ != NULL ? *trace_stats_ : *default_instance_->trace_stats_;
#endif
}
inline ::perfetto::protos::TraceStats* TrustedPacket::mutable_trace_stats() {
  
  if (trace_stats_ == NULL) {
    trace_stats_ = new ::perfetto::protos::TraceStats;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TrustedPacket.trace_stats)
  return trace_stats_;
}
inline ::perfetto::protos::TraceStats* TrustedPacket::release_trace_stats() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TrustedPacket.trace_stats)
  
  ::perfetto::protos::TraceStats* temp = trace_stats_;
  trace_stats_ = NULL;
  return temp;
}
inline void TrustedPacket::set_allocated_trace_stats(::perfetto::protos::TraceStats* trace_stats) {
  delete trace_stats_;
  trace_stats_ = trace_stats;
  if (trace_stats) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TrustedPacket.trace_stats)
}

// optional bytes synchronization_marker = 36;
inline void TrustedPacket::clear_synchronization_marker() {
  synchronization_marker_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TrustedPacket::synchronization_marker() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TrustedPacket.synchronization_marker)
  return synchronization_marker_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TrustedPacket::set_synchronization_marker(const ::std::string& value) {
  
  synchronization_marker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.TrustedPacket.synchronization_marker)
}
inline void TrustedPacket::set_synchronization_marker(const char* value) {
  
  synchronization_marker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.TrustedPacket.synchronization_marker)
}
inline void TrustedPacket::set_synchronization_marker(const void* value, size_t size) {
  
  synchronization_marker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.TrustedPacket.synchronization_marker)
}
inline ::std::string* TrustedPacket::mutable_synchronization_marker() {
  
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TrustedPacket.synchronization_marker)
  return synchronization_marker_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TrustedPacket::release_synchronization_marker() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TrustedPacket.synchronization_marker)
  
  return synchronization_marker_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TrustedPacket::set_allocated_synchronization_marker(::std::string* synchronization_marker) {
  if (synchronization_marker != NULL) {
    
  } else {
    
  }
  synchronization_marker_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), synchronization_marker);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TrustedPacket.synchronization_marker)
}

// optional bool previous_packet_dropped = 42;
inline void TrustedPacket::clear_previous_packet_dropped() {
  previous_packet_dropped_ = false;
}
inline bool TrustedPacket::previous_packet_dropped() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TrustedPacket.previous_packet_dropped)
  return previous_packet_dropped_;
}
inline void TrustedPacket::set_previous_packet_dropped(bool value) {
  
  previous_packet_dropped_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TrustedPacket.previous_packet_dropped)
}

// optional .perfetto.protos.SystemInfo system_info = 45;
inline bool TrustedPacket::has_system_info() const {
  return !_is_default_instance_ && system_info_ != NULL;
}
inline void TrustedPacket::clear_system_info() {
  if (GetArenaNoVirtual() == NULL && system_info_ != NULL) delete system_info_;
  system_info_ = NULL;
}
inline const ::perfetto::protos::SystemInfo& TrustedPacket::system_info() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TrustedPacket.system_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return system_info_ != NULL ? *system_info_ : *default_instance().system_info_;
#else
  return system_info_ != NULL ? *system_info_ : *default_instance_->system_info_;
#endif
}
inline ::perfetto::protos::SystemInfo* TrustedPacket::mutable_system_info() {
  
  if (system_info_ == NULL) {
    system_info_ = new ::perfetto::protos::SystemInfo;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TrustedPacket.system_info)
  return system_info_;
}
inline ::perfetto::protos::SystemInfo* TrustedPacket::release_system_info() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TrustedPacket.system_info)
  
  ::perfetto::protos::SystemInfo* temp = system_info_;
  system_info_ = NULL;
  return temp;
}
inline void TrustedPacket::set_allocated_system_info(::perfetto::protos::SystemInfo* system_info) {
  delete system_info_;
  system_info_ = system_info;
  if (system_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TrustedPacket.system_info)
}

// optional .perfetto.protos.Trigger trigger = 46;
inline bool TrustedPacket::has_trigger() const {
  return !_is_default_instance_ && trigger_ != NULL;
}
inline void TrustedPacket::clear_trigger() {
  if (GetArenaNoVirtual() == NULL && trigger_ != NULL) delete trigger_;
  trigger_ = NULL;
}
inline const ::perfetto::protos::Trigger& TrustedPacket::trigger() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TrustedPacket.trigger)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return trigger_ != NULL ? *trigger_ : *default_instance().trigger_;
#else
  return trigger_ != NULL ? *trigger_ : *default_instance_->trigger_;
#endif
}
inline ::perfetto::protos::Trigger* TrustedPacket::mutable_trigger() {
  
  if (trigger_ == NULL) {
    trigger_ = new ::perfetto::protos::Trigger;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TrustedPacket.trigger)
  return trigger_;
}
inline ::perfetto::protos::Trigger* TrustedPacket::release_trigger() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TrustedPacket.trigger)
  
  ::perfetto::protos::Trigger* temp = trigger_;
  trigger_ = NULL;
  return temp;
}
inline void TrustedPacket::set_allocated_trigger(::perfetto::protos::Trigger* trigger) {
  delete trigger_;
  trigger_ = trigger;
  if (trigger) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TrustedPacket.trigger)
}

inline bool TrustedPacket::has_optional_trusted_uid() const {
  return optional_trusted_uid_case() != OPTIONAL_TRUSTED_UID_NOT_SET;
}
inline void TrustedPacket::clear_has_optional_trusted_uid() {
  _oneof_case_[0] = OPTIONAL_TRUSTED_UID_NOT_SET;
}
inline bool TrustedPacket::has_optional_trusted_packet_sequence_id() const {
  return optional_trusted_packet_sequence_id_case() != OPTIONAL_TRUSTED_PACKET_SEQUENCE_ID_NOT_SET;
}
inline void TrustedPacket::clear_has_optional_trusted_packet_sequence_id() {
  _oneof_case_[1] = OPTIONAL_TRUSTED_PACKET_SEQUENCE_ID_NOT_SET;
}
inline TrustedPacket::OptionalTrustedUidCase TrustedPacket::optional_trusted_uid_case() const {
  return TrustedPacket::OptionalTrustedUidCase(_oneof_case_[0]);
}
inline TrustedPacket::OptionalTrustedPacketSequenceIdCase TrustedPacket::optional_trusted_packet_sequence_id_case() const {
  return TrustedPacket::OptionalTrustedPacketSequenceIdCase(_oneof_case_[1]);
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_perfetto_2ftrace_2ftrusted_5fpacket_2eproto__INCLUDED
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: perfetto/trace/trusted_packet.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
// gen_amalgamated expanded: #include "perfetto/trace/trusted_packet.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace perfetto {
namespace protos {

void protobuf_ShutdownFile_perfetto_2ftrace_2ftrusted_5fpacket_2eproto() {
  delete TrustedPacket::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_perfetto_2ftrace_2ftrusted_5fpacket_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_perfetto_2ftrace_2ftrusted_5fpacket_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  ::perfetto::protos::protobuf_AddDesc_perfetto_2fcommon_2ftrace_5fstats_2eproto();
  ::perfetto::protos::protobuf_AddDesc_perfetto_2fconfig_2ftrace_5fconfig_2eproto();
  ::perfetto::protos::protobuf_AddDesc_perfetto_2ftrace_2fclock_5fsnapshot_2eproto();
  ::perfetto::protos::protobuf_AddDesc_perfetto_2ftrace_2fsystem_5finfo_2eproto();
  ::perfetto::protos::protobuf_AddDesc_perfetto_2ftrace_2ftrigger_2eproto();
  TrustedPacket::default_instance_ = new TrustedPacket();
  TrustedPacket::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_perfetto_2ftrace_2ftrusted_5fpacket_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_perfetto_2ftrace_2ftrusted_5fpacket_2eproto_once_);
void protobuf_AddDesc_perfetto_2ftrace_2ftrusted_5fpacket_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_perfetto_2ftrace_2ftrusted_5fpacket_2eproto_once_,
                 &protobuf_AddDesc_perfetto_2ftrace_2ftrusted_5fpacket_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_perfetto_2ftrace_2ftrusted_5fpacket_2eproto {
  StaticDescriptorInitializer_perfetto_2ftrace_2ftrusted_5fpacket_2eproto() {
    protobuf_AddDesc_perfetto_2ftrace_2ftrusted_5fpacket_2eproto();
  }
} static_descriptor_initializer_perfetto_2ftrace_2ftrusted_5fpacket_2eproto_;
#endif

namespace {

static void trusted_packet_pb_MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD;
static void trusted_packet_pb_MergeFromFail(int line) {
  GOOGLE_CHECK(false) << __FILE__ << ":" << line;
}

}  // namespace


// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TrustedPacket::kTrustedUidFieldNumber;
const int TrustedPacket::kTrustedPacketSequenceIdFieldNumber;
const int TrustedPacket::kClockSnapshotFieldNumber;
const int TrustedPacket::kTimestampFieldNumber;
const int TrustedPacket::kTraceConfigFieldNumber;
const int TrustedPacket::kTraceStatsFieldNumber;
const int TrustedPacket::kSynchronizationMarkerFieldNumber;
const int TrustedPacket::kPreviousPacketDroppedFieldNumber;
const int TrustedPacket::kSystemInfoFieldNumber;
const int TrustedPacket::kTriggerFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TrustedPacket::TrustedPacket()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:perfetto.protos.TrustedPacket)
}

void TrustedPacket::InitAsDefaultInstance() {
  _is_default_instance_ = true;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  clock_snapshot_ = const_cast< ::perfetto::protos::ClockSnapshot*>(
      ::perfetto::protos::ClockSnapshot::internal_default_instance());
#else
  clock_snapshot_ = const_cast< ::perfetto::protos::ClockSnapshot*>(&::perfetto::protos::ClockSnapshot::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  trace_config_ = const_cast< ::perfetto::protos::TraceConfig*>(
      ::perfetto::protos::TraceConfig::internal_default_instance());
#else
  trace_config_ = const_cast< ::perfetto::protos::TraceConfig*>(&::perfetto::protos::TraceConfig::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  trace_stats_ = const_cast< ::perfetto::protos::TraceStats*>(
      ::perfetto::protos::TraceStats::internal_default_instance());
#else
  trace_stats_ = const_cast< ::perfetto::protos::TraceStats*>(&::perfetto::protos::TraceStats::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  system_info_ = const_cast< ::perfetto::protos::SystemInfo*>(
      ::perfetto::protos::SystemInfo::internal_default_instance());
#else
  system_info_ = const_cast< ::perfetto::protos::SystemInfo*>(&::perfetto::protos::SystemInfo::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  trigger_ = const_cast< ::perfetto::protos::Trigger*>(
      ::perfetto::protos::Trigger::internal_default_instance());
#else
  trigger_ = const_cast< ::perfetto::protos::Trigger*>(&::perfetto::protos::Trigger::default_instance());
#endif
}

TrustedPacket::TrustedPacket(const TrustedPacket& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:perfetto.protos.TrustedPacket)
}

void TrustedPacket::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  clock_snapshot_ = NULL;
  timestamp_ = GOOGLE_ULONGLONG(0);
  trace_config_ = NULL;
  trace_stats_ = NULL;
  synchronization_marker_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  previous_packet_dropped_ = false;
  system_info_ = NULL;
  trigger_ = NULL;
  clear_has_optional_trusted_uid();
  clear_has_optional_trusted_packet_sequence_id();
}

TrustedPacket::~TrustedPacket() {
  // @@protoc_insertion_point(destructor:perfetto.protos.TrustedPacket)
  SharedDtor();
}

void TrustedPacket::SharedDtor() {
  synchronization_marker_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (has_optional_trusted_uid()) {
    clear_optional_trusted_uid();
  }
  if (has_optional_trusted_packet_sequence_id()) {
    clear_optional_trusted_packet_sequence_id();
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete clock_snapshot_;
    delete trace_config_;
    delete trace_stats_;
    delete system_info_;
    delete trigger_;
  }
}

void TrustedPacket::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TrustedPacket& TrustedPacket::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_perfetto_2ftrace_2ftrusted_5fpacket_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_perfetto_2ftrace_2ftrusted_5fpacket_2eproto();
#endif
  return *default_instance_;
}

TrustedPacket* TrustedPacket::default_instance_ = NULL;

TrustedPacket* TrustedPacket::New(::google::protobuf::Arena* arena) const {
  TrustedPacket* n = new TrustedPacket;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TrustedPacket::clear_optional_trusted_uid() {
// @@protoc_insertion_point(one_of_clear_start:perfetto.protos.TrustedPacket)
  switch(optional_trusted_uid_case()) {
    case kTrustedUid: {
      // No need to clear
      break;
    }
    case OPTIONAL_TRUSTED_UID_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = OPTIONAL_TRUSTED_UID_NOT_SET;
}

void TrustedPacket::clear_optional_trusted_packet_sequence_id() {
// @@protoc_insertion_point(one_of_clear_start:perfetto.protos.TrustedPacket)
  switch(optional_trusted_packet_sequence_id_case()) {
    case kTrustedPacketSequenceId: {
      // No need to clear
      break;
    }
    case OPTIONAL_TRUSTED_PACKET_SEQUENCE_ID_NOT_SET: {
      break;
    }
  }
  _oneof_case_[1] = OPTIONAL_TRUSTED_PACKET_SEQUENCE_ID_NOT_SET;
}


void TrustedPacket::Clear() {
// @@protoc_insertion_point(message_clear_start:perfetto.protos.TrustedPacket)
  if (GetArenaNoVirtual() == NULL && clock_snapshot_ != NULL) delete clock_snapshot_;
  clock_snapshot_ = NULL;
  timestamp_ = GOOGLE_ULONGLONG(0);
  if (GetArenaNoVirtual() == NULL && trace_config_ != NULL) delete trace_config_;
  trace_config_ = NULL;
  if (GetArenaNoVirtual() == NULL && trace_stats_ != NULL) delete trace_stats_;
  trace_stats_ = NULL;
  synchronization_marker_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  previous_packet_dropped_ = false;
  if (GetArenaNoVirtual() == NULL && system_info_ != NULL) delete system_info_;
  system_info_ = NULL;
  if (GetArenaNoVirtual() == NULL && trigger_ != NULL) delete trigger_;
  trigger_ = NULL;
  clear_optional_trusted_uid();
  clear_optional_trusted_packet_sequence_id();
}

bool TrustedPacket::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:perfetto.protos.TrustedPacket)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 trusted_uid = 3;
      case 3: {
        if (tag == 24) {
          clear_optional_trusted_uid();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &optional_trusted_uid_.trusted_uid_)));
          set_has_trusted_uid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_clock_snapshot;
        break;
      }

      // optional .perfetto.protos.ClockSnapshot clock_snapshot = 6;
      case 6: {
        if (tag == 50) {
         parse_clock_snapshot:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_clock_snapshot()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_timestamp;
        break;
      }

      // optional uint64 timestamp = 8;
      case 8: {
        if (tag == 64) {
         parse_timestamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &timestamp_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_trusted_packet_sequence_id;
        break;
      }

      // optional uint32 trusted_packet_sequence_id = 10;
      case 10: {
        if (tag == 80) {
         parse_trusted_packet_sequence_id:
          clear_optional_trusted_packet_sequence_id();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &optional_trusted_packet_sequence_id_.trusted_packet_sequence_id_)));
          set_has_trusted_packet_sequence_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(266)) goto parse_trace_config;
        break;
      }

      // optional .perfetto.protos.TraceConfig trace_config = 33;
      case 33: {
        if (tag == 266) {
         parse_trace_config:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_trace_config()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(282)) goto parse_trace_stats;
        break;
      }

      // optional .perfetto.protos.TraceStats trace_stats = 35;
      case 35: {
        if (tag == 282) {
         parse_trace_stats:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_trace_stats()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(290)) goto parse_synchronization_marker;
        break;
      }

      // optional bytes synchronization_marker = 36;
      case 36: {
        if (tag == 290) {
         parse_synchronization_marker:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_synchronization_marker()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(336)) goto parse_previous_packet_dropped;
        break;
      }

      // optional bool previous_packet_dropped = 42;
      case 42: {
        if (tag == 336) {
         parse_previous_packet_dropped:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &previous_packet_dropped_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(362)) goto parse_system_info;
        break;
      }

      // optional .perfetto.protos.SystemInfo system_info = 45;
      case 45: {
        if (tag == 362) {
         parse_system_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_system_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(370)) goto parse_trigger;
        break;
      }

      // optional .perfetto.protos.Trigger trigger = 46;
      case 46: {
        if (tag == 370) {
         parse_trigger:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_trigger()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:perfetto.protos.TrustedPacket)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:perfetto.protos.TrustedPacket)
  return false;
#undef DO_
}

void TrustedPacket::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:perfetto.protos.TrustedPacket)
  // optional int32 trusted_uid = 3;
  if (has_trusted_uid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->trusted_uid(), output);
  }

  // optional .perfetto.protos.ClockSnapshot clock_snapshot = 6;
  if (this->has_clock_snapshot()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, *this->clock_snapshot_, output);
  }

  // optional uint64 timestamp = 8;
  if (this->timestamp() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(8, this->timestamp(), output);
  }

  // optional uint32 trusted_packet_sequence_id = 10;
  if (has_trusted_packet_sequence_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->trusted_packet_sequence_id(), output);
  }

  // optional .perfetto.protos.TraceConfig trace_config = 33;
  if (this->has_trace_config()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      33, *this->trace_config_, output);
  }

  // optional .perfetto.protos.TraceStats trace_stats = 35;
  if (this->has_trace_stats()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      35, *this->trace_stats_, output);
  }

  // optional bytes synchronization_marker = 36;
  if (this->synchronization_marker().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      36, this->synchronization_marker(), output);
  }

  // optional bool previous_packet_dropped = 42;
  if (this->previous_packet_dropped() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(42, this->previous_packet_dropped(), output);
  }

  // optional .perfetto.protos.SystemInfo system_info = 45;
  if (this->has_system_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      45, *this->system_info_, output);
  }

  // optional .perfetto.protos.Trigger trigger = 46;
  if (this->has_trigger()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      46, *this->trigger_, output);
  }

  // @@protoc_insertion_point(serialize_end:perfetto.protos.TrustedPacket)
}

int TrustedPacket::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:perfetto.protos.TrustedPacket)
  int total_size = 0;

  // optional .perfetto.protos.ClockSnapshot clock_snapshot = 6;
  if (this->has_clock_snapshot()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->clock_snapshot_);
  }

  // optional uint64 timestamp = 8;
  if (this->timestamp() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->timestamp());
  }

  // optional .perfetto.protos.TraceConfig trace_config = 33;
  if (this->has_trace_config()) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->trace_config_);
  }

  // optional .perfetto.protos.TraceStats trace_stats = 35;
  if (this->has_trace_stats()) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->trace_stats_);
  }

  // optional bytes synchronization_marker = 36;
  if (this->synchronization_marker().size() > 0) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->synchronization_marker());
  }

  // optional bool previous_packet_dropped = 42;
  if (this->previous_packet_dropped() != 0) {
    total_size += 2 + 1;
  }

  // optional .perfetto.protos.SystemInfo system_info = 45;
  if (this->has_system_info()) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->system_info_);
  }

  // optional .perfetto.protos.Trigger trigger = 46;
  if (this->has_trigger()) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->trigger_);
  }

  switch (optional_trusted_uid_case()) {
    // optional int32 trusted_uid = 3;
    case kTrustedUid: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->trusted_uid());
      break;
    }
    case OPTIONAL_TRUSTED_UID_NOT_SET: {
      break;
    }
  }
  switch (optional_trusted_packet_sequence_id_case()) {
    // optional uint32 trusted_packet_sequence_id = 10;
    case kTrustedPacketSequenceId: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->trusted_packet_sequence_id());
      break;
    }
    case OPTIONAL_TRUSTED_PACKET_SEQUENCE_ID_NOT_SET: {
      break;
    }
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TrustedPacket::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TrustedPacket*>(&from));
}

void TrustedPacket::MergeFrom(const TrustedPacket& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:perfetto.protos.TrustedPacket)
  if (GOOGLE_PREDICT_FALSE(&from == this)) trusted_packet_pb_MergeFromFail(__LINE__);
  switch (from.optional_trusted_uid_case()) {
    case kTrustedUid: {
      set_trusted_uid(from.trusted_uid());
      break;
    }
    case OPTIONAL_TRUSTED_UID_NOT_SET: {
      break;
    }
  }
  switch (from.optional_trusted_packet_sequence_id_case()) {
    case kTrustedPacketSequenceId: {
      set_trusted_packet_sequence_id(from.trusted_packet_sequence_id());
      break;
    }
    case OPTIONAL_TRUSTED_PACKET_SEQUENCE_ID_NOT_SET: {
      break;
    }
  }
  if (from.has_clock_snapshot()) {
    mutable_clock_snapshot()->::perfetto::protos::ClockSnapshot::MergeFrom(from.clock_snapshot());
  }
  if (from.timestamp() != 0) {
    set_timestamp(from.timestamp());
  }
  if (from.has_trace_config()) {
    mutable_trace_config()->::perfetto::protos::TraceConfig::MergeFrom(from.trace_config());
  }
  if (from.has_trace_stats()) {
    mutable_trace_stats()->::perfetto::protos::TraceStats::MergeFrom(from.trace_stats());
  }
  if (from.synchronization_marker().size() > 0) {

    synchronization_marker_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.synchronization_marker_);
  }
  if (from.previous_packet_dropped() != 0) {
    set_previous_packet_dropped(from.previous_packet_dropped());
  }
  if (from.has_system_info()) {
    mutable_system_info()->::perfetto::protos::SystemInfo::MergeFrom(from.system_info());
  }
  if (from.has_trigger()) {
    mutable_trigger()->::perfetto::protos::Trigger::MergeFrom(from.trigger());
  }
}

void TrustedPacket::CopyFrom(const TrustedPacket& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:perfetto.protos.TrustedPacket)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrustedPacket::IsInitialized() const {

  return true;
}

void TrustedPacket::Swap(TrustedPacket* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TrustedPacket::InternalSwap(TrustedPacket* other) {
  std::swap(clock_snapshot_, other->clock_snapshot_);
  std::swap(timestamp_, other->timestamp_);
  std::swap(trace_config_, other->trace_config_);
  std::swap(trace_stats_, other->trace_stats_);
  synchronization_marker_.Swap(&other->synchronization_marker_);
  std::swap(previous_packet_dropped_, other->previous_packet_dropped_);
  std::swap(system_info_, other->system_info_);
  std::swap(trigger_, other->trigger_);
  std::swap(optional_trusted_uid_, other->optional_trusted_uid_);
  std::swap(_oneof_case_[0], other->_oneof_case_[0]);
  std::swap(optional_trusted_packet_sequence_id_, other->optional_trusted_packet_sequence_id_);
  std::swap(_oneof_case_[1], other->_oneof_case_[1]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string TrustedPacket::GetTypeName() const {
  return "perfetto.protos.TrustedPacket";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TrustedPacket

// optional int32 trusted_uid = 3;
bool TrustedPacket::has_trusted_uid() const {
  return optional_trusted_uid_case() == kTrustedUid;
}
void TrustedPacket::set_has_trusted_uid() {
  _oneof_case_[0] = kTrustedUid;
}
void TrustedPacket::clear_trusted_uid() {
  if (has_trusted_uid()) {
    optional_trusted_uid_.trusted_uid_ = 0;
    clear_has_optional_trusted_uid();
  }
}
 ::google::protobuf::int32 TrustedPacket::trusted_uid() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TrustedPacket.trusted_uid)
  if (has_trusted_uid()) {
    return optional_trusted_uid_.trusted_uid_;
  }
  return 0;
}
 void TrustedPacket::set_trusted_uid(::google::protobuf::int32 value) {
  if (!has_trusted_uid()) {
    clear_optional_trusted_uid();
    set_has_trusted_uid();
  }
  optional_trusted_uid_.trusted_uid_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TrustedPacket.trusted_uid)
}

// optional uint32 trusted_packet_sequence_id = 10;
bool TrustedPacket::has_trusted_packet_sequence_id() const {
  return optional_trusted_packet_sequence_id_case() == kTrustedPacketSequenceId;
}
void TrustedPacket::set_has_trusted_packet_sequence_id() {
  _oneof_case_[1] = kTrustedPacketSequenceId;
}
void TrustedPacket::clear_trusted_packet_sequence_id() {
  if (has_trusted_packet_sequence_id()) {
    optional_trusted_packet_sequence_id_.trusted_packet_sequence_id_ = 0u;
    clear_has_optional_trusted_packet_sequence_id();
  }
}
 ::google::protobuf::uint32 TrustedPacket::trusted_packet_sequence_id() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TrustedPacket.trusted_packet_sequence_id)
  if (has_trusted_packet_sequence_id()) {
    return optional_trusted_packet_sequence_id_.trusted_packet_sequence_id_;
  }
  return 0u;
}
 void TrustedPacket::set_trusted_packet_sequence_id(::google::protobuf::uint32 value) {
  if (!has_trusted_packet_sequence_id()) {
    clear_optional_trusted_packet_sequence_id();
    set_has_trusted_packet_sequence_id();
  }
  optional_trusted_packet_sequence_id_.trusted_packet_sequence_id_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TrustedPacket.trusted_packet_sequence_id)
}

// optional .perfetto.protos.ClockSnapshot clock_snapshot = 6;
bool TrustedPacket::has_clock_snapshot() const {
  return !_is_default_instance_ && clock_snapshot_ != NULL;
}
void TrustedPacket::clear_clock_snapshot() {
  if (GetArenaNoVirtual() == NULL && clock_snapshot_ != NULL) delete clock_snapshot_;
  clock_snapshot_ = NULL;
}
const ::perfetto::protos::ClockSnapshot& TrustedPacket::clock_snapshot() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TrustedPacket.clock_snapshot)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return clock_snapshot_ != NULL ? *clock_snapshot_ : *default_instance().clock_snapshot_;
#else
  return clock_snapshot_ != NULL ? *clock_snapshot_ : *default_instance_->clock_snapshot_;
#endif
}
::perfetto::protos::ClockSnapshot* TrustedPacket::mutable_clock_snapshot() {
  
  if (clock_snapshot_ == NULL) {
    clock_snapshot_ = new ::perfetto::protos::ClockSnapshot;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TrustedPacket.clock_snapshot)
  return clock_snapshot_;
}
::perfetto::protos::ClockSnapshot* TrustedPacket::release_clock_snapshot() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TrustedPacket.clock_snapshot)
  
  ::perfetto::protos::ClockSnapshot* temp = clock_snapshot_;
  clock_snapshot_ = NULL;
  return temp;
}
void TrustedPacket::set_allocated_clock_snapshot(::perfetto::protos::ClockSnapshot* clock_snapshot) {
  delete clock_snapshot_;
  clock_snapshot_ = clock_snapshot;
  if (clock_snapshot) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TrustedPacket.clock_snapshot)
}

// optional uint64 timestamp = 8;
void TrustedPacket::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
}
 ::google::protobuf::uint64 TrustedPacket::timestamp() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TrustedPacket.timestamp)
  return timestamp_;
}
 void TrustedPacket::set_timestamp(::google::protobuf::uint64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TrustedPacket.timestamp)
}

// optional .perfetto.protos.TraceConfig trace_config = 33;
bool TrustedPacket::has_trace_config() const {
  return !_is_default_instance_ && trace_config_ != NULL;
}
void TrustedPacket::clear_trace_config() {
  if (GetArenaNoVirtual() == NULL && trace_config_ != NULL) delete trace_config_;
  trace_config_ = NULL;
}
const ::perfetto::protos::TraceConfig& TrustedPacket::trace_config() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TrustedPacket.trace_config)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return trace_config_ != NULL ? *trace_config_ : *default_instance().trace_config_;
#else
  return trace_config_ != NULL ? *trace_config_ : *default_instance_->trace_config_;
#endif
}
::perfetto::protos::TraceConfig* TrustedPacket::mutable_trace_config() {
  
  if (trace_config_ == NULL) {
    trace_config_ = new ::perfetto::protos::TraceConfig;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TrustedPacket.trace_config)
  return trace_config_;
}
::perfetto::protos::TraceConfig* TrustedPacket::release_trace_config() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TrustedPacket.trace_config)
  
  ::perfetto::protos::TraceConfig* temp = trace_config_;
  trace_config_ = NULL;
  return temp;
}
void TrustedPacket::set_allocated_trace_config(::perfetto::protos::TraceConfig* trace_config) {
  delete trace_config_;
  trace_config_ = trace_config;
  if (trace_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TrustedPacket.trace_config)
}

// optional .perfetto.protos.TraceStats trace_stats = 35;
bool TrustedPacket::has_trace_stats() const {
  return !_is_default_instance_ && trace_stats_ != NULL;
}
void TrustedPacket::clear_trace_stats() {
  if (GetArenaNoVirtual() == NULL && trace_stats_ != NULL) delete trace_stats_;
  trace_stats_ = NULL;
}
const ::perfetto::protos::TraceStats& TrustedPacket::trace_stats() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TrustedPacket.trace_stats)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return trace_stats_ != NULL ? *trace_stats_ : *default_instance().trace_stats_;
#else
  return trace_stats_ != NULL ? *trace_stats_ : *default_instance_->trace_stats_;
#endif
}
::perfetto::protos::TraceStats* TrustedPacket::mutable_trace_stats() {
  
  if (trace_stats_ == NULL) {
    trace_stats_ = new ::perfetto::protos::TraceStats;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TrustedPacket.trace_stats)
  return trace_stats_;
}
::perfetto::protos::TraceStats* TrustedPacket::release_trace_stats() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TrustedPacket.trace_stats)
  
  ::perfetto::protos::TraceStats* temp = trace_stats_;
  trace_stats_ = NULL;
  return temp;
}
void TrustedPacket::set_allocated_trace_stats(::perfetto::protos::TraceStats* trace_stats) {
  delete trace_stats_;
  trace_stats_ = trace_stats;
  if (trace_stats) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TrustedPacket.trace_stats)
}

// optional bytes synchronization_marker = 36;
void TrustedPacket::clear_synchronization_marker() {
  synchronization_marker_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& TrustedPacket::synchronization_marker() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TrustedPacket.synchronization_marker)
  return synchronization_marker_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TrustedPacket::set_synchronization_marker(const ::std::string& value) {
  
  synchronization_marker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:perfetto.protos.TrustedPacket.synchronization_marker)
}
 void TrustedPacket::set_synchronization_marker(const char* value) {
  
  synchronization_marker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:perfetto.protos.TrustedPacket.synchronization_marker)
}
 void TrustedPacket::set_synchronization_marker(const void* value, size_t size) {
  
  synchronization_marker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:perfetto.protos.TrustedPacket.synchronization_marker)
}
 ::std::string* TrustedPacket::mutable_synchronization_marker() {
  
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TrustedPacket.synchronization_marker)
  return synchronization_marker_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* TrustedPacket::release_synchronization_marker() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TrustedPacket.synchronization_marker)
  
  return synchronization_marker_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TrustedPacket::set_allocated_synchronization_marker(::std::string* synchronization_marker) {
  if (synchronization_marker != NULL) {
    
  } else {
    
  }
  synchronization_marker_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), synchronization_marker);
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TrustedPacket.synchronization_marker)
}

// optional bool previous_packet_dropped = 42;
void TrustedPacket::clear_previous_packet_dropped() {
  previous_packet_dropped_ = false;
}
 bool TrustedPacket::previous_packet_dropped() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TrustedPacket.previous_packet_dropped)
  return previous_packet_dropped_;
}
 void TrustedPacket::set_previous_packet_dropped(bool value) {
  
  previous_packet_dropped_ = value;
  // @@protoc_insertion_point(field_set:perfetto.protos.TrustedPacket.previous_packet_dropped)
}

// optional .perfetto.protos.SystemInfo system_info = 45;
bool TrustedPacket::has_system_info() const {
  return !_is_default_instance_ && system_info_ != NULL;
}
void TrustedPacket::clear_system_info() {
  if (GetArenaNoVirtual() == NULL && system_info_ != NULL) delete system_info_;
  system_info_ = NULL;
}
const ::perfetto::protos::SystemInfo& TrustedPacket::system_info() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TrustedPacket.system_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return system_info_ != NULL ? *system_info_ : *default_instance().system_info_;
#else
  return system_info_ != NULL ? *system_info_ : *default_instance_->system_info_;
#endif
}
::perfetto::protos::SystemInfo* TrustedPacket::mutable_system_info() {
  
  if (system_info_ == NULL) {
    system_info_ = new ::perfetto::protos::SystemInfo;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TrustedPacket.system_info)
  return system_info_;
}
::perfetto::protos::SystemInfo* TrustedPacket::release_system_info() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TrustedPacket.system_info)
  
  ::perfetto::protos::SystemInfo* temp = system_info_;
  system_info_ = NULL;
  return temp;
}
void TrustedPacket::set_allocated_system_info(::perfetto::protos::SystemInfo* system_info) {
  delete system_info_;
  system_info_ = system_info;
  if (system_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TrustedPacket.system_info)
}

// optional .perfetto.protos.Trigger trigger = 46;
bool TrustedPacket::has_trigger() const {
  return !_is_default_instance_ && trigger_ != NULL;
}
void TrustedPacket::clear_trigger() {
  if (GetArenaNoVirtual() == NULL && trigger_ != NULL) delete trigger_;
  trigger_ = NULL;
}
const ::perfetto::protos::Trigger& TrustedPacket::trigger() const {
  // @@protoc_insertion_point(field_get:perfetto.protos.TrustedPacket.trigger)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return trigger_ != NULL ? *trigger_ : *default_instance().trigger_;
#else
  return trigger_ != NULL ? *trigger_ : *default_instance_->trigger_;
#endif
}
::perfetto::protos::Trigger* TrustedPacket::mutable_trigger() {
  
  if (trigger_ == NULL) {
    trigger_ = new ::perfetto::protos::Trigger;
  }
  // @@protoc_insertion_point(field_mutable:perfetto.protos.TrustedPacket.trigger)
  return trigger_;
}
::perfetto::protos::Trigger* TrustedPacket::release_trigger() {
  // @@protoc_insertion_point(field_release:perfetto.protos.TrustedPacket.trigger)
  
  ::perfetto::protos::Trigger* temp = trigger_;
  trigger_ = NULL;
  return temp;
}
void TrustedPacket::set_allocated_trigger(::perfetto::protos::Trigger* trigger) {
  delete trigger_;
  trigger_ = trigger;
  if (trigger) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:perfetto.protos.TrustedPacket.trigger)
}

bool TrustedPacket::has_optional_trusted_uid() const {
  return optional_trusted_uid_case() != OPTIONAL_TRUSTED_UID_NOT_SET;
}
void TrustedPacket::clear_has_optional_trusted_uid() {
  _oneof_case_[0] = OPTIONAL_TRUSTED_UID_NOT_SET;
}
bool TrustedPacket::has_optional_trusted_packet_sequence_id() const {
  return optional_trusted_packet_sequence_id_case() != OPTIONAL_TRUSTED_PACKET_SEQUENCE_ID_NOT_SET;
}
void TrustedPacket::clear_has_optional_trusted_packet_sequence_id() {
  _oneof_case_[1] = OPTIONAL_TRUSTED_PACKET_SEQUENCE_ID_NOT_SET;
}
TrustedPacket::OptionalTrustedUidCase TrustedPacket::optional_trusted_uid_case() const {
  return TrustedPacket::OptionalTrustedUidCase(_oneof_case_[0]);
}
TrustedPacket::OptionalTrustedPacketSequenceIdCase TrustedPacket::optional_trusted_packet_sequence_id_case() const {
  return TrustedPacket::OptionalTrustedPacketSequenceIdCase(_oneof_case_[1]);
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace perfetto

// @@protoc_insertion_point(global_scope)
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/common/android_log_constants.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/common/commit_data_request.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/common/data_source_descriptor.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/common/descriptor.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/common/gpu_counter_descriptor.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/common/observable_events.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/common/sys_stats_counters.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/common/tracing_service_state.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/common/trace_stats.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/config/android/android_log_config.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/config/android/packages_list_config.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/config/chrome/chrome_config.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/config/data_source_config.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/config/ftrace/ftrace_config.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/config/gpu/gpu_counter_config.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/config/inode_file/inode_file_config.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/config/power/android_power_config.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/config/process_stats/process_stats_config.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/config/profiling/heapprofd_config.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/config/sys_stats/sys_stats_config.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/config/test_config.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/config/trace_config.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/android/android_log.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/android/packages_list.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/profiling/profile_common.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/profiling/profile_packet.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/track_event/debug_annotation.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/track_event/process_descriptor.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/track_event/task_execution.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/track_event/thread_descriptor.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/track_event/track_event.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/interned_data/interned_data.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/chrome/chrome_trace_event.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/chrome/chrome_benchmark_metadata.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/chrome/chrome_metadata.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/filesystem/inode_file_map.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/ftrace_event.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/ftrace_event_bundle.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/ftrace_stats.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/test_bundle_wrapper.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/generic.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/binder.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/block.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/cgroup.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/clk.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/compaction.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/ext4.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/f2fs.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/fence.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/filemap.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/ftrace.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/i2c.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/ipi.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/irq.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/kmem.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/lowmemorykiller.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/mdss.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/mm_event.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/oom.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/power.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/raw_syscalls.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/regulator.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/sched.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/signal.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/sync.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/systrace.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/task.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/vmscan.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ftrace/workqueue.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/gpu/gpu_counter_event.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/gpu/gpu_render_stage_event.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/power/battery_counters.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/power/power_rails.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ps/process_stats.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/ps/process_tree.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/sys_stats/sys_stats.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/clock_snapshot.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/trigger.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/system_info.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/test_event.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/trace_packet.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/trace.pbzero.cc
// Intentionally empty
// gen_amalgamated begin source: src/tracing/core/chrome_config.cc
// gen_amalgamated begin header: include/perfetto/tracing/core/chrome_config.h
// gen_amalgamated begin header: include/perfetto/base/copyable_ptr.h
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_BASE_COPYABLE_PTR_H_
#define INCLUDE_PERFETTO_BASE_COPYABLE_PTR_H_

#include <memory>

namespace perfetto {
namespace base {

// This class is essentially a std::vector<T> of fixed size = 1.
// It's a pointer wrapper with deep copying and deep equality comparison.
// At all effects this wrapper behaves like the underlying T, with the exception
// of the heap indirection.
// Conversely to a std::unique_ptr, the pointer will be always valid, never
// null. The problem it solves is the following: when generating C++ classes
// from proto files, we want to keep each header hermetic (i.e. not #include
// headers of dependent types). As such we can't directly instantiate T
// field members but we can instead rely on pointers, so only the .cc file needs
// to see the actual definition of T. If the generated classes were move-only we
// could just use a unique_ptr there. But they aren't, hence this wrapper.
// Converesely to unique_ptr, this wrapper:
// - Default constructs the T instance in its constructor.
// - Implements deep comparison in operator== instead of pointer comparison.
template <typename T>
class CopyablePtr {
 public:
  CopyablePtr() : ptr_(new T()) {}
  ~CopyablePtr() = default;

  // Copy operators.
  CopyablePtr(const CopyablePtr& other) : ptr_(new T(*other.ptr_)) {}
  CopyablePtr& operator=(const CopyablePtr& other) {
    *ptr_ = *other.ptr_;
    return *this;
  }

  // Move operators.
  CopyablePtr(CopyablePtr&& other) noexcept : ptr_(std::move(other.ptr_)) {
    other.ptr_.reset(new T());
  }

  CopyablePtr& operator=(CopyablePtr&& other) {
    ptr_ = std::move(other.ptr_);
    other.ptr_.reset(new T());
    return *this;
  }

  T* get() { return ptr_.get(); }
  const T* get() const { return ptr_.get(); }

  T* operator->() { return ptr_.get(); }
  const T* operator->() const { return ptr_.get(); }

  T& operator*() { return *ptr_; }
  const T& operator*() const { return *ptr_; }

  friend bool operator==(const CopyablePtr& lhs, const CopyablePtr& rhs) {
    return *lhs == *rhs;
  }

  friend bool operator!=(const CopyablePtr& lhs, const CopyablePtr& rhs) {
    // In theory the underlying type might have a special operator!=
    // implementation which is not just !(x == y). Respect that.
    return *lhs != *rhs;
  }

 private:
  std::unique_ptr<T> ptr_;
};

}  // namespace base
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_BASE_COPYABLE_PTR_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*******************************************************************************
 * AUTOGENERATED - DO NOT EDIT
 *******************************************************************************
 * This file has been generated from the protobuf message
 * perfetto/config/chrome/chrome_config.proto
 * by
 * ../../tools/proto_to_cpp/proto_to_cpp.cc.
 * If you need to make changes here, change the .proto file and then run
 * ./tools/gen_tracing_cpp_headers_from_protos
 */

#ifndef INCLUDE_PERFETTO_TRACING_CORE_CHROME_CONFIG_H_
#define INCLUDE_PERFETTO_TRACING_CORE_CHROME_CONFIG_H_

#include <stdint.h>
#include <string>
#include <type_traits>
#include <vector>

// gen_amalgamated expanded: #include "perfetto/base/copyable_ptr.h"
// gen_amalgamated expanded: #include "perfetto/base/export.h"

// Forward declarations for protobuf types.
namespace perfetto {
namespace protos {
class ChromeConfig;
}
}  // namespace perfetto

namespace perfetto {
class ChromeConfig;

class PERFETTO_EXPORT ChromeConfig {
 public:
  ChromeConfig();
  ~ChromeConfig();
  ChromeConfig(ChromeConfig&&) noexcept;
  ChromeConfig& operator=(ChromeConfig&&);
  ChromeConfig(const ChromeConfig&);
  ChromeConfig& operator=(const ChromeConfig&);
  bool operator==(const ChromeConfig&) const;
  bool operator!=(const ChromeConfig& other) const { return !(*this == other); }

  // Raw proto decoding.
  void ParseRawProto(const std::string&);
  // Conversion methods from/to the corresponding protobuf types.
  void FromProto(const perfetto::protos::ChromeConfig&);
  void ToProto(perfetto::protos::ChromeConfig*) const;

  const std::string& trace_config() const { return trace_config_; }
  void set_trace_config(const std::string& value) { trace_config_ = value; }

  bool privacy_filtering_enabled() const { return privacy_filtering_enabled_; }
  void set_privacy_filtering_enabled(bool value) {
    privacy_filtering_enabled_ = value;
  }

 private:
  std::string trace_config_{};
  bool privacy_filtering_enabled_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;
};

}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_TRACING_CORE_CHROME_CONFIG_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*******************************************************************************
 * AUTOGENERATED - DO NOT EDIT
 *******************************************************************************
 * This file has been generated from the protobuf message
 * perfetto/config/chrome/chrome_config.proto
 * by
 * ../../tools/proto_to_cpp/proto_to_cpp.cc.
 * If you need to make changes here, change the .proto file and then run
 * ./tools/gen_tracing_cpp_headers_from_protos
 */

// gen_amalgamated expanded: #include "perfetto/tracing/core/chrome_config.h"

// gen_amalgamated expanded: #include "perfetto/config/chrome/chrome_config.pb.h"

namespace perfetto {

ChromeConfig::ChromeConfig() = default;
ChromeConfig::~ChromeConfig() = default;
ChromeConfig::ChromeConfig(const ChromeConfig&) = default;
ChromeConfig& ChromeConfig::operator=(const ChromeConfig&) = default;
ChromeConfig::ChromeConfig(ChromeConfig&&) noexcept = default;
ChromeConfig& ChromeConfig::operator=(ChromeConfig&&) = default;

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
bool ChromeConfig::operator==(const ChromeConfig& other) const {
  return (trace_config_ == other.trace_config_) &&
         (privacy_filtering_enabled_ == other.privacy_filtering_enabled_);
}
#pragma GCC diagnostic pop

void ChromeConfig::ParseRawProto(const std::string& raw) {
  perfetto::protos::ChromeConfig proto;
  proto.ParseFromString(raw);
  FromProto(proto);
}

void ChromeConfig::FromProto(const perfetto::protos::ChromeConfig& proto) {
  static_assert(sizeof(trace_config_) == sizeof(proto.trace_config()),
                "size mismatch");
  trace_config_ = static_cast<decltype(trace_config_)>(proto.trace_config());

  static_assert(sizeof(privacy_filtering_enabled_) ==
                    sizeof(proto.privacy_filtering_enabled()),
                "size mismatch");
  privacy_filtering_enabled_ =
      static_cast<decltype(privacy_filtering_enabled_)>(
          proto.privacy_filtering_enabled());
  unknown_fields_ = proto.unknown_fields();
}

void ChromeConfig::ToProto(perfetto::protos::ChromeConfig* proto) const {
  proto->Clear();

  static_assert(sizeof(trace_config_) == sizeof(proto->trace_config()),
                "size mismatch");
  proto->set_trace_config(
      static_cast<decltype(proto->trace_config())>(trace_config_));

  static_assert(sizeof(privacy_filtering_enabled_) ==
                    sizeof(proto->privacy_filtering_enabled()),
                "size mismatch");
  proto->set_privacy_filtering_enabled(
      static_cast<decltype(proto->privacy_filtering_enabled())>(
          privacy_filtering_enabled_));
  *(proto->mutable_unknown_fields()) = unknown_fields_;
}

}  // namespace perfetto
// gen_amalgamated begin source: src/tracing/core/commit_data_request.cc
// gen_amalgamated begin header: include/perfetto/ext/tracing/core/commit_data_request.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*******************************************************************************
 * AUTOGENERATED - DO NOT EDIT
 *******************************************************************************
 * This file has been generated from the protobuf message
 * perfetto/common/commit_data_request.proto
 * by
 * ../../tools/proto_to_cpp/proto_to_cpp.cc.
 * If you need to make changes here, change the .proto file and then run
 * ./tools/gen_tracing_cpp_headers_from_protos
 */

#ifndef INCLUDE_PERFETTO_EXT_TRACING_CORE_COMMIT_DATA_REQUEST_H_
#define INCLUDE_PERFETTO_EXT_TRACING_CORE_COMMIT_DATA_REQUEST_H_

#include <stdint.h>
#include <string>
#include <type_traits>
#include <vector>

// gen_amalgamated expanded: #include "perfetto/base/copyable_ptr.h"
// gen_amalgamated expanded: #include "perfetto/base/export.h"

// Forward declarations for protobuf types.
namespace perfetto {
namespace protos {
class CommitDataRequest;
class CommitDataRequest_ChunksToMove;
class CommitDataRequest_ChunkToPatch;
class CommitDataRequest_ChunkToPatch_Patch;
}  // namespace protos
}  // namespace perfetto

namespace perfetto {
class CommitDataRequest;

class PERFETTO_EXPORT CommitDataRequest {
 public:
  class PERFETTO_EXPORT ChunksToMove {
   public:
    ChunksToMove();
    ~ChunksToMove();
    ChunksToMove(ChunksToMove&&) noexcept;
    ChunksToMove& operator=(ChunksToMove&&);
    ChunksToMove(const ChunksToMove&);
    ChunksToMove& operator=(const ChunksToMove&);
    bool operator==(const ChunksToMove&) const;
    bool operator!=(const ChunksToMove& other) const {
      return !(*this == other);
    }

    // Raw proto decoding.
    void ParseRawProto(const std::string&);
    // Conversion methods from/to the corresponding protobuf types.
    void FromProto(const perfetto::protos::CommitDataRequest_ChunksToMove&);
    void ToProto(perfetto::protos::CommitDataRequest_ChunksToMove*) const;

    uint32_t page() const { return page_; }
    void set_page(uint32_t value) { page_ = value; }

    uint32_t chunk() const { return chunk_; }
    void set_chunk(uint32_t value) { chunk_ = value; }

    uint32_t target_buffer() const { return target_buffer_; }
    void set_target_buffer(uint32_t value) { target_buffer_ = value; }

   private:
    uint32_t page_{};
    uint32_t chunk_{};
    uint32_t target_buffer_{};

    // Allows to preserve unknown protobuf fields for compatibility
    // with future versions of .proto files.
    std::string unknown_fields_;
  };

  class PERFETTO_EXPORT ChunkToPatch {
   public:
    class PERFETTO_EXPORT Patch {
     public:
      Patch();
      ~Patch();
      Patch(Patch&&) noexcept;
      Patch& operator=(Patch&&);
      Patch(const Patch&);
      Patch& operator=(const Patch&);
      bool operator==(const Patch&) const;
      bool operator!=(const Patch& other) const { return !(*this == other); }

      // Raw proto decoding.
      void ParseRawProto(const std::string&);
      // Conversion methods from/to the corresponding protobuf types.
      void FromProto(
          const perfetto::protos::CommitDataRequest_ChunkToPatch_Patch&);
      void ToProto(
          perfetto::protos::CommitDataRequest_ChunkToPatch_Patch*) const;

      uint32_t offset() const { return offset_; }
      void set_offset(uint32_t value) { offset_ = value; }

      const std::string& data() const { return data_; }
      void set_data(const std::string& value) { data_ = value; }
      void set_data(const void* p, size_t s) {
        data_.assign(reinterpret_cast<const char*>(p), s);
      }

     private:
      uint32_t offset_{};
      std::string data_{};

      // Allows to preserve unknown protobuf fields for compatibility
      // with future versions of .proto files.
      std::string unknown_fields_;
    };

    ChunkToPatch();
    ~ChunkToPatch();
    ChunkToPatch(ChunkToPatch&&) noexcept;
    ChunkToPatch& operator=(ChunkToPatch&&);
    ChunkToPatch(const ChunkToPatch&);
    ChunkToPatch& operator=(const ChunkToPatch&);
    bool operator==(const ChunkToPatch&) const;
    bool operator!=(const ChunkToPatch& other) const {
      return !(*this == other);
    }

    // Raw proto decoding.
    void ParseRawProto(const std::string&);
    // Conversion methods from/to the corresponding protobuf types.
    void FromProto(const perfetto::protos::CommitDataRequest_ChunkToPatch&);
    void ToProto(perfetto::protos::CommitDataRequest_ChunkToPatch*) const;

    uint32_t target_buffer() const { return target_buffer_; }
    void set_target_buffer(uint32_t value) { target_buffer_ = value; }

    uint32_t writer_id() const { return writer_id_; }
    void set_writer_id(uint32_t value) { writer_id_ = value; }

    uint32_t chunk_id() const { return chunk_id_; }
    void set_chunk_id(uint32_t value) { chunk_id_ = value; }

    int patches_size() const { return static_cast<int>(patches_.size()); }
    const std::vector<Patch>& patches() const { return patches_; }
    std::vector<Patch>* mutable_patches() { return &patches_; }
    void clear_patches() { patches_.clear(); }
    Patch* add_patches() {
      patches_.emplace_back();
      return &patches_.back();
    }

    bool has_more_patches() const { return has_more_patches_; }
    void set_has_more_patches(bool value) { has_more_patches_ = value; }

   private:
    uint32_t target_buffer_{};
    uint32_t writer_id_{};
    uint32_t chunk_id_{};
    std::vector<Patch> patches_;
    bool has_more_patches_{};

    // Allows to preserve unknown protobuf fields for compatibility
    // with future versions of .proto files.
    std::string unknown_fields_;
  };

  CommitDataRequest();
  ~CommitDataRequest();
  CommitDataRequest(CommitDataRequest&&) noexcept;
  CommitDataRequest& operator=(CommitDataRequest&&);
  CommitDataRequest(const CommitDataRequest&);
  CommitDataRequest& operator=(const CommitDataRequest&);
  bool operator==(const CommitDataRequest&) const;
  bool operator!=(const CommitDataRequest& other) const {
    return !(*this == other);
  }

  // Raw proto decoding.
  void ParseRawProto(const std::string&);
  // Conversion methods from/to the corresponding protobuf types.
  void FromProto(const perfetto::protos::CommitDataRequest&);
  void ToProto(perfetto::protos::CommitDataRequest*) const;

  int chunks_to_move_size() const {
    return static_cast<int>(chunks_to_move_.size());
  }
  const std::vector<ChunksToMove>& chunks_to_move() const {
    return chunks_to_move_;
  }
  std::vector<ChunksToMove>* mutable_chunks_to_move() {
    return &chunks_to_move_;
  }
  void clear_chunks_to_move() { chunks_to_move_.clear(); }
  ChunksToMove* add_chunks_to_move() {
    chunks_to_move_.emplace_back();
    return &chunks_to_move_.back();
  }

  int chunks_to_patch_size() const {
    return static_cast<int>(chunks_to_patch_.size());
  }
  const std::vector<ChunkToPatch>& chunks_to_patch() const {
    return chunks_to_patch_;
  }
  std::vector<ChunkToPatch>* mutable_chunks_to_patch() {
    return &chunks_to_patch_;
  }
  void clear_chunks_to_patch() { chunks_to_patch_.clear(); }
  ChunkToPatch* add_chunks_to_patch() {
    chunks_to_patch_.emplace_back();
    return &chunks_to_patch_.back();
  }

  uint64_t flush_request_id() const { return flush_request_id_; }
  void set_flush_request_id(uint64_t value) { flush_request_id_ = value; }

 private:
  std::vector<ChunksToMove> chunks_to_move_;
  std::vector<ChunkToPatch> chunks_to_patch_;
  uint64_t flush_request_id_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;
};

}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_TRACING_CORE_COMMIT_DATA_REQUEST_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*******************************************************************************
 * AUTOGENERATED - DO NOT EDIT
 *******************************************************************************
 * This file has been generated from the protobuf message
 * perfetto/common/commit_data_request.proto
 * by
 * ../../tools/proto_to_cpp/proto_to_cpp.cc.
 * If you need to make changes here, change the .proto file and then run
 * ./tools/gen_tracing_cpp_headers_from_protos
 */

// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/commit_data_request.h"

// gen_amalgamated expanded: #include "perfetto/common/commit_data_request.pb.h"

namespace perfetto {

CommitDataRequest::CommitDataRequest() = default;
CommitDataRequest::~CommitDataRequest() = default;
CommitDataRequest::CommitDataRequest(const CommitDataRequest&) = default;
CommitDataRequest& CommitDataRequest::operator=(const CommitDataRequest&) =
    default;
CommitDataRequest::CommitDataRequest(CommitDataRequest&&) noexcept = default;
CommitDataRequest& CommitDataRequest::operator=(CommitDataRequest&&) = default;

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
bool CommitDataRequest::operator==(const CommitDataRequest& other) const {
  return (chunks_to_move_ == other.chunks_to_move_) &&
         (chunks_to_patch_ == other.chunks_to_patch_) &&
         (flush_request_id_ == other.flush_request_id_);
}
#pragma GCC diagnostic pop

void CommitDataRequest::ParseRawProto(const std::string& raw) {
  perfetto::protos::CommitDataRequest proto;
  proto.ParseFromString(raw);
  FromProto(proto);
}

void CommitDataRequest::FromProto(
    const perfetto::protos::CommitDataRequest& proto) {
  chunks_to_move_.clear();
  for (const auto& field : proto.chunks_to_move()) {
    chunks_to_move_.emplace_back();
    chunks_to_move_.back().FromProto(field);
  }

  chunks_to_patch_.clear();
  for (const auto& field : proto.chunks_to_patch()) {
    chunks_to_patch_.emplace_back();
    chunks_to_patch_.back().FromProto(field);
  }

  static_assert(sizeof(flush_request_id_) == sizeof(proto.flush_request_id()),
                "size mismatch");
  flush_request_id_ =
      static_cast<decltype(flush_request_id_)>(proto.flush_request_id());
  unknown_fields_ = proto.unknown_fields();
}

void CommitDataRequest::ToProto(
    perfetto::protos::CommitDataRequest* proto) const {
  proto->Clear();

  for (const auto& it : chunks_to_move_) {
    auto* entry = proto->add_chunks_to_move();
    it.ToProto(entry);
  }

  for (const auto& it : chunks_to_patch_) {
    auto* entry = proto->add_chunks_to_patch();
    it.ToProto(entry);
  }

  static_assert(sizeof(flush_request_id_) == sizeof(proto->flush_request_id()),
                "size mismatch");
  proto->set_flush_request_id(
      static_cast<decltype(proto->flush_request_id())>(flush_request_id_));
  *(proto->mutable_unknown_fields()) = unknown_fields_;
}

CommitDataRequest::ChunksToMove::ChunksToMove() = default;
CommitDataRequest::ChunksToMove::~ChunksToMove() = default;
CommitDataRequest::ChunksToMove::ChunksToMove(
    const CommitDataRequest::ChunksToMove&) = default;
CommitDataRequest::ChunksToMove& CommitDataRequest::ChunksToMove::operator=(
    const CommitDataRequest::ChunksToMove&) = default;
CommitDataRequest::ChunksToMove::ChunksToMove(
    CommitDataRequest::ChunksToMove&&) noexcept = default;
CommitDataRequest::ChunksToMove& CommitDataRequest::ChunksToMove::operator=(
    CommitDataRequest::ChunksToMove&&) = default;

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
bool CommitDataRequest::ChunksToMove::operator==(
    const CommitDataRequest::ChunksToMove& other) const {
  return (page_ == other.page_) && (chunk_ == other.chunk_) &&
         (target_buffer_ == other.target_buffer_);
}
#pragma GCC diagnostic pop

void CommitDataRequest::ChunksToMove::ParseRawProto(const std::string& raw) {
  perfetto::protos::CommitDataRequest_ChunksToMove proto;
  proto.ParseFromString(raw);
  FromProto(proto);
}

void CommitDataRequest::ChunksToMove::FromProto(
    const perfetto::protos::CommitDataRequest_ChunksToMove& proto) {
  static_assert(sizeof(page_) == sizeof(proto.page()), "size mismatch");
  page_ = static_cast<decltype(page_)>(proto.page());

  static_assert(sizeof(chunk_) == sizeof(proto.chunk()), "size mismatch");
  chunk_ = static_cast<decltype(chunk_)>(proto.chunk());

  static_assert(sizeof(target_buffer_) == sizeof(proto.target_buffer()),
                "size mismatch");
  target_buffer_ = static_cast<decltype(target_buffer_)>(proto.target_buffer());
  unknown_fields_ = proto.unknown_fields();
}

void CommitDataRequest::ChunksToMove::ToProto(
    perfetto::protos::CommitDataRequest_ChunksToMove* proto) const {
  proto->Clear();

  static_assert(sizeof(page_) == sizeof(proto->page()), "size mismatch");
  proto->set_page(static_cast<decltype(proto->page())>(page_));

  static_assert(sizeof(chunk_) == sizeof(proto->chunk()), "size mismatch");
  proto->set_chunk(static_cast<decltype(proto->chunk())>(chunk_));

  static_assert(sizeof(target_buffer_) == sizeof(proto->target_buffer()),
                "size mismatch");
  proto->set_target_buffer(
      static_cast<decltype(proto->target_buffer())>(target_buffer_));
  *(proto->mutable_unknown_fields()) = unknown_fields_;
}

CommitDataRequest::ChunkToPatch::ChunkToPatch() = default;
CommitDataRequest::ChunkToPatch::~ChunkToPatch() = default;
CommitDataRequest::ChunkToPatch::ChunkToPatch(
    const CommitDataRequest::ChunkToPatch&) = default;
CommitDataRequest::ChunkToPatch& CommitDataRequest::ChunkToPatch::operator=(
    const CommitDataRequest::ChunkToPatch&) = default;
CommitDataRequest::ChunkToPatch::ChunkToPatch(
    CommitDataRequest::ChunkToPatch&&) noexcept = default;
CommitDataRequest::ChunkToPatch& CommitDataRequest::ChunkToPatch::operator=(
    CommitDataRequest::ChunkToPatch&&) = default;

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
bool CommitDataRequest::ChunkToPatch::operator==(
    const CommitDataRequest::ChunkToPatch& other) const {
  return (target_buffer_ == other.target_buffer_) &&
         (writer_id_ == other.writer_id_) && (chunk_id_ == other.chunk_id_) &&
         (patches_ == other.patches_) &&
         (has_more_patches_ == other.has_more_patches_);
}
#pragma GCC diagnostic pop

void CommitDataRequest::ChunkToPatch::ParseRawProto(const std::string& raw) {
  perfetto::protos::CommitDataRequest_ChunkToPatch proto;
  proto.ParseFromString(raw);
  FromProto(proto);
}

void CommitDataRequest::ChunkToPatch::FromProto(
    const perfetto::protos::CommitDataRequest_ChunkToPatch& proto) {
  static_assert(sizeof(target_buffer_) == sizeof(proto.target_buffer()),
                "size mismatch");
  target_buffer_ = static_cast<decltype(target_buffer_)>(proto.target_buffer());

  static_assert(sizeof(writer_id_) == sizeof(proto.writer_id()),
                "size mismatch");
  writer_id_ = static_cast<decltype(writer_id_)>(proto.writer_id());

  static_assert(sizeof(chunk_id_) == sizeof(proto.chunk_id()), "size mismatch");
  chunk_id_ = static_cast<decltype(chunk_id_)>(proto.chunk_id());

  patches_.clear();
  for (const auto& field : proto.patches()) {
    patches_.emplace_back();
    patches_.back().FromProto(field);
  }

  static_assert(sizeof(has_more_patches_) == sizeof(proto.has_more_patches()),
                "size mismatch");
  has_more_patches_ =
      static_cast<decltype(has_more_patches_)>(proto.has_more_patches());
  unknown_fields_ = proto.unknown_fields();
}

void CommitDataRequest::ChunkToPatch::ToProto(
    perfetto::protos::CommitDataRequest_ChunkToPatch* proto) const {
  proto->Clear();

  static_assert(sizeof(target_buffer_) == sizeof(proto->target_buffer()),
                "size mismatch");
  proto->set_target_buffer(
      static_cast<decltype(proto->target_buffer())>(target_buffer_));

  static_assert(sizeof(writer_id_) == sizeof(proto->writer_id()),
                "size mismatch");
  proto->set_writer_id(static_cast<decltype(proto->writer_id())>(writer_id_));

  static_assert(sizeof(chunk_id_) == sizeof(proto->chunk_id()),
                "size mismatch");
  proto->set_chunk_id(static_cast<decltype(proto->chunk_id())>(chunk_id_));

  for (const auto& it : patches_) {
    auto* entry = proto->add_patches();
    it.ToProto(entry);
  }

  static_assert(sizeof(has_more_patches_) == sizeof(proto->has_more_patches()),
                "size mismatch");
  proto->set_has_more_patches(
      static_cast<decltype(proto->has_more_patches())>(has_more_patches_));
  *(proto->mutable_unknown_fields()) = unknown_fields_;
}

CommitDataRequest::ChunkToPatch::Patch::Patch() = default;
CommitDataRequest::ChunkToPatch::Patch::~Patch() = default;
CommitDataRequest::ChunkToPatch::Patch::Patch(
    const CommitDataRequest::ChunkToPatch::Patch&) = default;
CommitDataRequest::ChunkToPatch::Patch& CommitDataRequest::ChunkToPatch::Patch::
operator=(const CommitDataRequest::ChunkToPatch::Patch&) = default;
CommitDataRequest::ChunkToPatch::Patch::Patch(
    CommitDataRequest::ChunkToPatch::Patch&&) noexcept = default;
CommitDataRequest::ChunkToPatch::Patch& CommitDataRequest::ChunkToPatch::Patch::
operator=(CommitDataRequest::ChunkToPatch::Patch&&) = default;

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
bool CommitDataRequest::ChunkToPatch::Patch::operator==(
    const CommitDataRequest::ChunkToPatch::Patch& other) const {
  return (offset_ == other.offset_) && (data_ == other.data_);
}
#pragma GCC diagnostic pop

void CommitDataRequest::ChunkToPatch::Patch::ParseRawProto(
    const std::string& raw) {
  perfetto::protos::CommitDataRequest_ChunkToPatch_Patch proto;
  proto.ParseFromString(raw);
  FromProto(proto);
}

void CommitDataRequest::ChunkToPatch::Patch::FromProto(
    const perfetto::protos::CommitDataRequest_ChunkToPatch_Patch& proto) {
  static_assert(sizeof(offset_) == sizeof(proto.offset()), "size mismatch");
  offset_ = static_cast<decltype(offset_)>(proto.offset());

  static_assert(sizeof(data_) == sizeof(proto.data()), "size mismatch");
  data_ = static_cast<decltype(data_)>(proto.data());
  unknown_fields_ = proto.unknown_fields();
}

void CommitDataRequest::ChunkToPatch::Patch::ToProto(
    perfetto::protos::CommitDataRequest_ChunkToPatch_Patch* proto) const {
  proto->Clear();

  static_assert(sizeof(offset_) == sizeof(proto->offset()), "size mismatch");
  proto->set_offset(static_cast<decltype(proto->offset())>(offset_));

  static_assert(sizeof(data_) == sizeof(proto->data()), "size mismatch");
  proto->set_data(static_cast<decltype(proto->data())>(data_));
  *(proto->mutable_unknown_fields()) = unknown_fields_;
}

}  // namespace perfetto
// gen_amalgamated begin source: src/tracing/core/data_source_config.cc
// gen_amalgamated begin header: include/perfetto/tracing/core/data_source_config.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*******************************************************************************
 * AUTOGENERATED - DO NOT EDIT
 *******************************************************************************
 * This file has been generated from the protobuf message
 * perfetto/config/data_source_config.proto
 * by
 * ../../tools/proto_to_cpp/proto_to_cpp.cc.
 * If you need to make changes here, change the .proto file and then run
 * ./tools/gen_tracing_cpp_headers_from_protos
 */

#ifndef INCLUDE_PERFETTO_TRACING_CORE_DATA_SOURCE_CONFIG_H_
#define INCLUDE_PERFETTO_TRACING_CORE_DATA_SOURCE_CONFIG_H_

#include <stdint.h>
#include <string>
#include <type_traits>
#include <vector>

// gen_amalgamated expanded: #include "perfetto/base/copyable_ptr.h"
// gen_amalgamated expanded: #include "perfetto/base/export.h"

// Forward declarations for protobuf types.
namespace perfetto {
namespace protos {
class DataSourceConfig;
class ChromeConfig;
class TestConfig;
class TestConfig_DummyFields;
}  // namespace protos
}  // namespace perfetto

namespace perfetto {
class DataSourceConfig;
class ChromeConfig;
class TestConfig;

class PERFETTO_EXPORT DataSourceConfig {
 public:
  DataSourceConfig();
  ~DataSourceConfig();
  DataSourceConfig(DataSourceConfig&&) noexcept;
  DataSourceConfig& operator=(DataSourceConfig&&);
  DataSourceConfig(const DataSourceConfig&);
  DataSourceConfig& operator=(const DataSourceConfig&);
  bool operator==(const DataSourceConfig&) const;
  bool operator!=(const DataSourceConfig& other) const {
    return !(*this == other);
  }

  // Raw proto decoding.
  void ParseRawProto(const std::string&);
  // Conversion methods from/to the corresponding protobuf types.
  void FromProto(const perfetto::protos::DataSourceConfig&);
  void ToProto(perfetto::protos::DataSourceConfig*) const;

  const std::string& name() const { return name_; }
  void set_name(const std::string& value) { name_ = value; }

  uint32_t target_buffer() const { return target_buffer_; }
  void set_target_buffer(uint32_t value) { target_buffer_ = value; }

  uint32_t trace_duration_ms() const { return trace_duration_ms_; }
  void set_trace_duration_ms(uint32_t value) { trace_duration_ms_ = value; }

  bool enable_extra_guardrails() const { return enable_extra_guardrails_; }
  void set_enable_extra_guardrails(bool value) {
    enable_extra_guardrails_ = value;
  }

  uint64_t tracing_session_id() const { return tracing_session_id_; }
  void set_tracing_session_id(uint64_t value) { tracing_session_id_ = value; }

  const std::string& ftrace_config_raw() const { return ftrace_config_; }
  void set_ftrace_config_raw(const std::string& raw) { ftrace_config_ = raw; }

  const std::string& inode_file_config_raw() const {
    return inode_file_config_;
  }
  void set_inode_file_config_raw(const std::string& raw) {
    inode_file_config_ = raw;
  }

  const std::string& process_stats_config_raw() const {
    return process_stats_config_;
  }
  void set_process_stats_config_raw(const std::string& raw) {
    process_stats_config_ = raw;
  }

  const std::string& sys_stats_config_raw() const { return sys_stats_config_; }
  void set_sys_stats_config_raw(const std::string& raw) {
    sys_stats_config_ = raw;
  }

  const std::string& heapprofd_config_raw() const { return heapprofd_config_; }
  void set_heapprofd_config_raw(const std::string& raw) {
    heapprofd_config_ = raw;
  }

  const std::string& android_power_config_raw() const {
    return android_power_config_;
  }
  void set_android_power_config_raw(const std::string& raw) {
    android_power_config_ = raw;
  }

  const std::string& android_log_config_raw() const {
    return android_log_config_;
  }
  void set_android_log_config_raw(const std::string& raw) {
    android_log_config_ = raw;
  }

  const std::string& gpu_counter_config_raw() const {
    return gpu_counter_config_;
  }
  void set_gpu_counter_config_raw(const std::string& raw) {
    gpu_counter_config_ = raw;
  }

  const std::string& packages_list_config_raw() const {
    return packages_list_config_;
  }
  void set_packages_list_config_raw(const std::string& raw) {
    packages_list_config_ = raw;
  }

  const ChromeConfig& chrome_config() const { return *chrome_config_; }
  ChromeConfig* mutable_chrome_config() { return chrome_config_.get(); }

  const std::string& legacy_config() const { return legacy_config_; }
  void set_legacy_config(const std::string& value) { legacy_config_ = value; }

  const TestConfig& for_testing() const { return *for_testing_; }
  TestConfig* mutable_for_testing() { return for_testing_.get(); }

 private:
  std::string name_{};
  uint32_t target_buffer_{};
  uint32_t trace_duration_ms_{};
  bool enable_extra_guardrails_{};
  uint64_t tracing_session_id_{};
  std::string ftrace_config_;         // [lazy=true]
  std::string inode_file_config_;     // [lazy=true]
  std::string process_stats_config_;  // [lazy=true]
  std::string sys_stats_config_;      // [lazy=true]
  std::string heapprofd_config_;      // [lazy=true]
  std::string android_power_config_;  // [lazy=true]
  std::string android_log_config_;    // [lazy=true]
  std::string gpu_counter_config_;    // [lazy=true]
  std::string packages_list_config_;  // [lazy=true]
  ::perfetto::base::CopyablePtr<ChromeConfig> chrome_config_;
  std::string legacy_config_{};
  ::perfetto::base::CopyablePtr<TestConfig> for_testing_;

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;
};

}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_TRACING_CORE_DATA_SOURCE_CONFIG_H_
// gen_amalgamated begin header: include/perfetto/tracing/core/test_config.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*******************************************************************************
 * AUTOGENERATED - DO NOT EDIT
 *******************************************************************************
 * This file has been generated from the protobuf message
 * perfetto/config/test_config.proto
 * by
 * ../../tools/proto_to_cpp/proto_to_cpp.cc.
 * If you need to make changes here, change the .proto file and then run
 * ./tools/gen_tracing_cpp_headers_from_protos
 */

#ifndef INCLUDE_PERFETTO_TRACING_CORE_TEST_CONFIG_H_
#define INCLUDE_PERFETTO_TRACING_CORE_TEST_CONFIG_H_

#include <stdint.h>
#include <string>
#include <type_traits>
#include <vector>

// gen_amalgamated expanded: #include "perfetto/base/copyable_ptr.h"
// gen_amalgamated expanded: #include "perfetto/base/export.h"

// Forward declarations for protobuf types.
namespace perfetto {
namespace protos {
class TestConfig;
class TestConfig_DummyFields;
}  // namespace protos
}  // namespace perfetto

namespace perfetto {
class TestConfig;

class PERFETTO_EXPORT TestConfig {
 public:
  class PERFETTO_EXPORT DummyFields {
   public:
    DummyFields();
    ~DummyFields();
    DummyFields(DummyFields&&) noexcept;
    DummyFields& operator=(DummyFields&&);
    DummyFields(const DummyFields&);
    DummyFields& operator=(const DummyFields&);
    bool operator==(const DummyFields&) const;
    bool operator!=(const DummyFields& other) const {
      return !(*this == other);
    }

    // Raw proto decoding.
    void ParseRawProto(const std::string&);
    // Conversion methods from/to the corresponding protobuf types.
    void FromProto(const perfetto::protos::TestConfig_DummyFields&);
    void ToProto(perfetto::protos::TestConfig_DummyFields*) const;

    uint32_t field_uint32() const { return field_uint32_; }
    void set_field_uint32(uint32_t value) { field_uint32_ = value; }

    int32_t field_int32() const { return field_int32_; }
    void set_field_int32(int32_t value) { field_int32_ = value; }

    uint64_t field_uint64() const { return field_uint64_; }
    void set_field_uint64(uint64_t value) { field_uint64_ = value; }

    int64_t field_int64() const { return field_int64_; }
    void set_field_int64(int64_t value) { field_int64_ = value; }

    uint64_t field_fixed64() const { return field_fixed64_; }
    void set_field_fixed64(uint64_t value) { field_fixed64_ = value; }

    int64_t field_sfixed64() const { return field_sfixed64_; }
    void set_field_sfixed64(int64_t value) { field_sfixed64_ = value; }

    uint32_t field_fixed32() const { return field_fixed32_; }
    void set_field_fixed32(uint32_t value) { field_fixed32_ = value; }

    int32_t field_sfixed32() const { return field_sfixed32_; }
    void set_field_sfixed32(int32_t value) { field_sfixed32_ = value; }

    double field_double() const { return field_double_; }
    void set_field_double(double value) { field_double_ = value; }

    float field_float() const { return field_float_; }
    void set_field_float(float value) { field_float_ = value; }

    int64_t field_sint64() const { return field_sint64_; }
    void set_field_sint64(int64_t value) { field_sint64_ = value; }

    int32_t field_sint32() const { return field_sint32_; }
    void set_field_sint32(int32_t value) { field_sint32_ = value; }

    const std::string& field_string() const { return field_string_; }
    void set_field_string(const std::string& value) { field_string_ = value; }

    const std::string& field_bytes() const { return field_bytes_; }
    void set_field_bytes(const std::string& value) { field_bytes_ = value; }
    void set_field_bytes(const void* p, size_t s) {
      field_bytes_.assign(reinterpret_cast<const char*>(p), s);
    }

   private:
    uint32_t field_uint32_{};
    int32_t field_int32_{};
    uint64_t field_uint64_{};
    int64_t field_int64_{};
    uint64_t field_fixed64_{};
    int64_t field_sfixed64_{};
    uint32_t field_fixed32_{};
    int32_t field_sfixed32_{};
    double field_double_{};
    float field_float_{};
    int64_t field_sint64_{};
    int32_t field_sint32_{};
    std::string field_string_{};
    std::string field_bytes_{};

    // Allows to preserve unknown protobuf fields for compatibility
    // with future versions of .proto files.
    std::string unknown_fields_;
  };

  TestConfig();
  ~TestConfig();
  TestConfig(TestConfig&&) noexcept;
  TestConfig& operator=(TestConfig&&);
  TestConfig(const TestConfig&);
  TestConfig& operator=(const TestConfig&);
  bool operator==(const TestConfig&) const;
  bool operator!=(const TestConfig& other) const { return !(*this == other); }

  // Raw proto decoding.
  void ParseRawProto(const std::string&);
  // Conversion methods from/to the corresponding protobuf types.
  void FromProto(const perfetto::protos::TestConfig&);
  void ToProto(perfetto::protos::TestConfig*) const;

  uint32_t message_count() const { return message_count_; }
  void set_message_count(uint32_t value) { message_count_ = value; }

  uint32_t max_messages_per_second() const { return max_messages_per_second_; }
  void set_max_messages_per_second(uint32_t value) {
    max_messages_per_second_ = value;
  }

  uint32_t seed() const { return seed_; }
  void set_seed(uint32_t value) { seed_ = value; }

  uint32_t message_size() const { return message_size_; }
  void set_message_size(uint32_t value) { message_size_ = value; }

  bool send_batch_on_register() const { return send_batch_on_register_; }
  void set_send_batch_on_register(bool value) {
    send_batch_on_register_ = value;
  }

  const DummyFields& dummy_fields() const { return *dummy_fields_; }
  DummyFields* mutable_dummy_fields() { return dummy_fields_.get(); }

 private:
  uint32_t message_count_{};
  uint32_t max_messages_per_second_{};
  uint32_t seed_{};
  uint32_t message_size_{};
  bool send_batch_on_register_{};
  ::perfetto::base::CopyablePtr<DummyFields> dummy_fields_;

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;
};

}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_TRACING_CORE_TEST_CONFIG_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*******************************************************************************
 * AUTOGENERATED - DO NOT EDIT
 *******************************************************************************
 * This file has been generated from the protobuf message
 * perfetto/config/data_source_config.proto
 * by
 * ../../tools/proto_to_cpp/proto_to_cpp.cc.
 * If you need to make changes here, change the .proto file and then run
 * ./tools/gen_tracing_cpp_headers_from_protos
 */

// gen_amalgamated expanded: #include "perfetto/tracing/core/data_source_config.h"

// gen_amalgamated expanded: #include "perfetto/config/data_source_config.pb.h"

// gen_amalgamated expanded: #include "perfetto/config/chrome/chrome_config.pb.h"
// gen_amalgamated expanded: #include "perfetto/tracing/core/chrome_config.h"

// gen_amalgamated expanded: #include "perfetto/config/test_config.pb.h"
// gen_amalgamated expanded: #include "perfetto/tracing/core/test_config.h"

namespace perfetto {

DataSourceConfig::DataSourceConfig() = default;
DataSourceConfig::~DataSourceConfig() = default;
DataSourceConfig::DataSourceConfig(const DataSourceConfig&) = default;
DataSourceConfig& DataSourceConfig::operator=(const DataSourceConfig&) =
    default;
DataSourceConfig::DataSourceConfig(DataSourceConfig&&) noexcept = default;
DataSourceConfig& DataSourceConfig::operator=(DataSourceConfig&&) = default;

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
bool DataSourceConfig::operator==(const DataSourceConfig& other) const {
  return (name_ == other.name_) && (target_buffer_ == other.target_buffer_) &&
         (trace_duration_ms_ == other.trace_duration_ms_) &&
         (enable_extra_guardrails_ == other.enable_extra_guardrails_) &&
         (tracing_session_id_ == other.tracing_session_id_) &&
         (ftrace_config_ == other.ftrace_config_) &&
         (inode_file_config_ == other.inode_file_config_) &&
         (process_stats_config_ == other.process_stats_config_) &&
         (sys_stats_config_ == other.sys_stats_config_) &&
         (heapprofd_config_ == other.heapprofd_config_) &&
         (android_power_config_ == other.android_power_config_) &&
         (android_log_config_ == other.android_log_config_) &&
         (gpu_counter_config_ == other.gpu_counter_config_) &&
         (packages_list_config_ == other.packages_list_config_) &&
         (chrome_config_ == other.chrome_config_) &&
         (legacy_config_ == other.legacy_config_) &&
         (for_testing_ == other.for_testing_);
}
#pragma GCC diagnostic pop

void DataSourceConfig::ParseRawProto(const std::string& raw) {
  perfetto::protos::DataSourceConfig proto;
  proto.ParseFromString(raw);
  FromProto(proto);
}

void DataSourceConfig::FromProto(
    const perfetto::protos::DataSourceConfig& proto) {
  static_assert(sizeof(name_) == sizeof(proto.name()), "size mismatch");
  name_ = static_cast<decltype(name_)>(proto.name());

  static_assert(sizeof(target_buffer_) == sizeof(proto.target_buffer()),
                "size mismatch");
  target_buffer_ = static_cast<decltype(target_buffer_)>(proto.target_buffer());

  static_assert(sizeof(trace_duration_ms_) == sizeof(proto.trace_duration_ms()),
                "size mismatch");
  trace_duration_ms_ =
      static_cast<decltype(trace_duration_ms_)>(proto.trace_duration_ms());

  static_assert(sizeof(enable_extra_guardrails_) ==
                    sizeof(proto.enable_extra_guardrails()),
                "size mismatch");
  enable_extra_guardrails_ = static_cast<decltype(enable_extra_guardrails_)>(
      proto.enable_extra_guardrails());

  static_assert(
      sizeof(tracing_session_id_) == sizeof(proto.tracing_session_id()),
      "size mismatch");
  tracing_session_id_ =
      static_cast<decltype(tracing_session_id_)>(proto.tracing_session_id());

  ftrace_config_ = proto.ftrace_config().SerializeAsString();

  inode_file_config_ = proto.inode_file_config().SerializeAsString();

  process_stats_config_ = proto.process_stats_config().SerializeAsString();

  sys_stats_config_ = proto.sys_stats_config().SerializeAsString();

  heapprofd_config_ = proto.heapprofd_config().SerializeAsString();

  android_power_config_ = proto.android_power_config().SerializeAsString();

  android_log_config_ = proto.android_log_config().SerializeAsString();

  gpu_counter_config_ = proto.gpu_counter_config().SerializeAsString();

  packages_list_config_ = proto.packages_list_config().SerializeAsString();

  chrome_config_->FromProto(proto.chrome_config());

  static_assert(sizeof(legacy_config_) == sizeof(proto.legacy_config()),
                "size mismatch");
  legacy_config_ = static_cast<decltype(legacy_config_)>(proto.legacy_config());

  for_testing_->FromProto(proto.for_testing());
  unknown_fields_ = proto.unknown_fields();
}

void DataSourceConfig::ToProto(
    perfetto::protos::DataSourceConfig* proto) const {
  proto->Clear();

  static_assert(sizeof(name_) == sizeof(proto->name()), "size mismatch");
  proto->set_name(static_cast<decltype(proto->name())>(name_));

  static_assert(sizeof(target_buffer_) == sizeof(proto->target_buffer()),
                "size mismatch");
  proto->set_target_buffer(
      static_cast<decltype(proto->target_buffer())>(target_buffer_));

  static_assert(
      sizeof(trace_duration_ms_) == sizeof(proto->trace_duration_ms()),
      "size mismatch");
  proto->set_trace_duration_ms(
      static_cast<decltype(proto->trace_duration_ms())>(trace_duration_ms_));

  static_assert(sizeof(enable_extra_guardrails_) ==
                    sizeof(proto->enable_extra_guardrails()),
                "size mismatch");
  proto->set_enable_extra_guardrails(
      static_cast<decltype(proto->enable_extra_guardrails())>(
          enable_extra_guardrails_));

  static_assert(
      sizeof(tracing_session_id_) == sizeof(proto->tracing_session_id()),
      "size mismatch");
  proto->set_tracing_session_id(
      static_cast<decltype(proto->tracing_session_id())>(tracing_session_id_));

  proto->mutable_ftrace_config()->ParseFromString(ftrace_config_);

  proto->mutable_inode_file_config()->ParseFromString(inode_file_config_);

  proto->mutable_process_stats_config()->ParseFromString(process_stats_config_);

  proto->mutable_sys_stats_config()->ParseFromString(sys_stats_config_);

  proto->mutable_heapprofd_config()->ParseFromString(heapprofd_config_);

  proto->mutable_android_power_config()->ParseFromString(android_power_config_);

  proto->mutable_android_log_config()->ParseFromString(android_log_config_);

  proto->mutable_gpu_counter_config()->ParseFromString(gpu_counter_config_);

  proto->mutable_packages_list_config()->ParseFromString(packages_list_config_);

  chrome_config_->ToProto(proto->mutable_chrome_config());

  static_assert(sizeof(legacy_config_) == sizeof(proto->legacy_config()),
                "size mismatch");
  proto->set_legacy_config(
      static_cast<decltype(proto->legacy_config())>(legacy_config_));

  for_testing_->ToProto(proto->mutable_for_testing());
  *(proto->mutable_unknown_fields()) = unknown_fields_;
}

}  // namespace perfetto
// gen_amalgamated begin source: src/tracing/core/data_source_descriptor.cc
// gen_amalgamated begin header: include/perfetto/tracing/core/data_source_descriptor.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*******************************************************************************
 * AUTOGENERATED - DO NOT EDIT
 *******************************************************************************
 * This file has been generated from the protobuf message
 * perfetto/common/data_source_descriptor.proto
 * by
 * ../../tools/proto_to_cpp/proto_to_cpp.cc.
 * If you need to make changes here, change the .proto file and then run
 * ./tools/gen_tracing_cpp_headers_from_protos
 */

#ifndef INCLUDE_PERFETTO_TRACING_CORE_DATA_SOURCE_DESCRIPTOR_H_
#define INCLUDE_PERFETTO_TRACING_CORE_DATA_SOURCE_DESCRIPTOR_H_

#include <stdint.h>
#include <string>
#include <type_traits>
#include <vector>

// gen_amalgamated expanded: #include "perfetto/base/copyable_ptr.h"
// gen_amalgamated expanded: #include "perfetto/base/export.h"

// Forward declarations for protobuf types.
namespace perfetto {
namespace protos {
class DataSourceDescriptor;
}
}  // namespace perfetto

namespace perfetto {
class DataSourceDescriptor;

class PERFETTO_EXPORT DataSourceDescriptor {
 public:
  DataSourceDescriptor();
  ~DataSourceDescriptor();
  DataSourceDescriptor(DataSourceDescriptor&&) noexcept;
  DataSourceDescriptor& operator=(DataSourceDescriptor&&);
  DataSourceDescriptor(const DataSourceDescriptor&);
  DataSourceDescriptor& operator=(const DataSourceDescriptor&);
  bool operator==(const DataSourceDescriptor&) const;
  bool operator!=(const DataSourceDescriptor& other) const {
    return !(*this == other);
  }

  // Raw proto decoding.
  void ParseRawProto(const std::string&);
  // Conversion methods from/to the corresponding protobuf types.
  void FromProto(const perfetto::protos::DataSourceDescriptor&);
  void ToProto(perfetto::protos::DataSourceDescriptor*) const;

  const std::string& name() const { return name_; }
  void set_name(const std::string& value) { name_ = value; }

  bool will_notify_on_stop() const { return will_notify_on_stop_; }
  void set_will_notify_on_stop(bool value) { will_notify_on_stop_ = value; }

  bool will_notify_on_start() const { return will_notify_on_start_; }
  void set_will_notify_on_start(bool value) { will_notify_on_start_ = value; }

  bool handles_incremental_state_clear() const {
    return handles_incremental_state_clear_;
  }
  void set_handles_incremental_state_clear(bool value) {
    handles_incremental_state_clear_ = value;
  }

  const std::string& gpu_counter_descriptor_raw() const {
    return gpu_counter_descriptor_;
  }
  void set_gpu_counter_descriptor_raw(const std::string& raw) {
    gpu_counter_descriptor_ = raw;
  }

 private:
  std::string name_{};
  bool will_notify_on_stop_{};
  bool will_notify_on_start_{};
  bool handles_incremental_state_clear_{};
  std::string gpu_counter_descriptor_;  // [lazy=true]

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;
};

}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_TRACING_CORE_DATA_SOURCE_DESCRIPTOR_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*******************************************************************************
 * AUTOGENERATED - DO NOT EDIT
 *******************************************************************************
 * This file has been generated from the protobuf message
 * perfetto/common/data_source_descriptor.proto
 * by
 * ../../tools/proto_to_cpp/proto_to_cpp.cc.
 * If you need to make changes here, change the .proto file and then run
 * ./tools/gen_tracing_cpp_headers_from_protos
 */

// gen_amalgamated expanded: #include "perfetto/tracing/core/data_source_descriptor.h"

// gen_amalgamated expanded: #include "perfetto/common/data_source_descriptor.pb.h"

namespace perfetto {

DataSourceDescriptor::DataSourceDescriptor() = default;
DataSourceDescriptor::~DataSourceDescriptor() = default;
DataSourceDescriptor::DataSourceDescriptor(const DataSourceDescriptor&) =
    default;
DataSourceDescriptor& DataSourceDescriptor::operator=(
    const DataSourceDescriptor&) = default;
DataSourceDescriptor::DataSourceDescriptor(DataSourceDescriptor&&) noexcept =
    default;
DataSourceDescriptor& DataSourceDescriptor::operator=(DataSourceDescriptor&&) =
    default;

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
bool DataSourceDescriptor::operator==(const DataSourceDescriptor& other) const {
  return (name_ == other.name_) &&
         (will_notify_on_stop_ == other.will_notify_on_stop_) &&
         (will_notify_on_start_ == other.will_notify_on_start_) &&
         (handles_incremental_state_clear_ ==
          other.handles_incremental_state_clear_) &&
         (gpu_counter_descriptor_ == other.gpu_counter_descriptor_);
}
#pragma GCC diagnostic pop

void DataSourceDescriptor::ParseRawProto(const std::string& raw) {
  perfetto::protos::DataSourceDescriptor proto;
  proto.ParseFromString(raw);
  FromProto(proto);
}

void DataSourceDescriptor::FromProto(
    const perfetto::protos::DataSourceDescriptor& proto) {
  static_assert(sizeof(name_) == sizeof(proto.name()), "size mismatch");
  name_ = static_cast<decltype(name_)>(proto.name());

  static_assert(
      sizeof(will_notify_on_stop_) == sizeof(proto.will_notify_on_stop()),
      "size mismatch");
  will_notify_on_stop_ =
      static_cast<decltype(will_notify_on_stop_)>(proto.will_notify_on_stop());

  static_assert(
      sizeof(will_notify_on_start_) == sizeof(proto.will_notify_on_start()),
      "size mismatch");
  will_notify_on_start_ = static_cast<decltype(will_notify_on_start_)>(
      proto.will_notify_on_start());

  static_assert(sizeof(handles_incremental_state_clear_) ==
                    sizeof(proto.handles_incremental_state_clear()),
                "size mismatch");
  handles_incremental_state_clear_ =
      static_cast<decltype(handles_incremental_state_clear_)>(
          proto.handles_incremental_state_clear());

  gpu_counter_descriptor_ = proto.gpu_counter_descriptor().SerializeAsString();
  unknown_fields_ = proto.unknown_fields();
}

void DataSourceDescriptor::ToProto(
    perfetto::protos::DataSourceDescriptor* proto) const {
  proto->Clear();

  static_assert(sizeof(name_) == sizeof(proto->name()), "size mismatch");
  proto->set_name(static_cast<decltype(proto->name())>(name_));

  static_assert(
      sizeof(will_notify_on_stop_) == sizeof(proto->will_notify_on_stop()),
      "size mismatch");
  proto->set_will_notify_on_stop(
      static_cast<decltype(proto->will_notify_on_stop())>(
          will_notify_on_stop_));

  static_assert(
      sizeof(will_notify_on_start_) == sizeof(proto->will_notify_on_start()),
      "size mismatch");
  proto->set_will_notify_on_start(
      static_cast<decltype(proto->will_notify_on_start())>(
          will_notify_on_start_));

  static_assert(sizeof(handles_incremental_state_clear_) ==
                    sizeof(proto->handles_incremental_state_clear()),
                "size mismatch");
  proto->set_handles_incremental_state_clear(
      static_cast<decltype(proto->handles_incremental_state_clear())>(
          handles_incremental_state_clear_));

  proto->mutable_gpu_counter_descriptor()->ParseFromString(
      gpu_counter_descriptor_);
  *(proto->mutable_unknown_fields()) = unknown_fields_;
}

}  // namespace perfetto
// gen_amalgamated begin source: src/tracing/core/id_allocator.cc
// gen_amalgamated begin header: src/tracing/core/id_allocator.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef SRC_TRACING_CORE_ID_ALLOCATOR_H_
#define SRC_TRACING_CORE_ID_ALLOCATOR_H_

#include <stdint.h>

#include <type_traits>
#include <vector>

namespace perfetto {

// Handles assigment of IDs (int types) from a fixed-size pool.
// Zero is not considered a valid ID.
// The base class takes always a uint32_t and the derived class casts and checks
// bounds at compile time. This is to avoid bloating code with different
// instances of the main class for each size.
class IdAllocatorGeneric {
 public:
  // |max_id| is inclusive.
  explicit IdAllocatorGeneric(uint32_t max_id);
  ~IdAllocatorGeneric();

  // Returns an ID in the range [1, max_id] or 0 if no more ids are available.
  uint32_t AllocateGeneric();
  void FreeGeneric(uint32_t);

 private:
  IdAllocatorGeneric(const IdAllocatorGeneric&) = delete;
  IdAllocatorGeneric& operator=(const IdAllocatorGeneric&) = delete;

  const uint32_t max_id_;
  uint32_t last_id_ = 0;
  std::vector<bool> ids_;
};

template <typename T = uint32_t>
class IdAllocator : public IdAllocatorGeneric {
 public:
  explicit IdAllocator(T end) : IdAllocatorGeneric(end) {
    static_assert(std::is_integral<T>::value && std::is_unsigned<T>::value,
                  "T must be an unsigned integer");
    static_assert(sizeof(T) <= sizeof(uint32_t), "T is too big");
  }

  T Allocate() { return static_cast<T>(AllocateGeneric()); }
  void Free(T id) { FreeGeneric(id); }
};

}  // namespace perfetto

#endif  // SRC_TRACING_CORE_ID_ALLOCATOR_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "src/tracing/core/id_allocator.h"

// gen_amalgamated expanded: #include "perfetto/base/logging.h"

namespace perfetto {

IdAllocatorGeneric::IdAllocatorGeneric(uint32_t max_id) : max_id_(max_id) {
  PERFETTO_DCHECK(max_id > 1);
}

IdAllocatorGeneric::~IdAllocatorGeneric() = default;

uint32_t IdAllocatorGeneric::AllocateGeneric() {
  for (uint32_t ignored = 1; ignored <= max_id_; ignored++) {
    last_id_ = last_id_ < max_id_ ? last_id_ + 1 : 1;
    const auto id = last_id_;

    // 0 is never a valid ID. So if we are looking for |id| == N and there are
    // N or less elements in the vector, they must necessarily be all < N.
    // e.g. if |id| == 4 and size() == 4, the vector will contain IDs 0,1,2,3.
    if (id >= ids_.size()) {
      ids_.resize(id + 1);
      ids_[id] = true;
      return id;
    }

    if (!ids_[id]) {
      ids_[id] = true;
      return id;
    }
  }
  return 0;
}

void IdAllocatorGeneric::FreeGeneric(uint32_t id) {
  if (id == 0 || id >= ids_.size() || !ids_[id]) {
    PERFETTO_DFATAL("Invalid id.");
    return;
  }
  ids_[id] = false;
}

}  // namespace perfetto
// gen_amalgamated begin source: src/tracing/core/metatrace_writer.cc
// gen_amalgamated begin header: src/tracing/core/metatrace_writer.h
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef SRC_TRACING_CORE_METATRACE_WRITER_H_
#define SRC_TRACING_CORE_METATRACE_WRITER_H_

#include <functional>
#include <memory>

// gen_amalgamated expanded: #include "perfetto/ext/base/metatrace.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/thread_checker.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/weak_ptr.h"

namespace perfetto {

namespace base {
class TaskRunner;
}

class TraceWriter;

// Complements the base::metatrace infrastructure.
// It hooks a callback to metatrace::Enable() and writes metatrace events into
// a TraceWriter whenever the metatrace ring buffer is half full.
// It is safe to create and attempt to start multiple instances of this class,
// however only the first one will succeed because the metatrace framework
// doesn't support multiple instances.
// This class is defined here (instead of directly in src/probes/) so it can
// be reused by other components (e.g. heapprofd).
class MetatraceWriter {
 public:
  static constexpr char kDataSourceName[] = "perfetto.metatrace";

  MetatraceWriter();
  ~MetatraceWriter();
  void Enable(base::TaskRunner*, std::unique_ptr<TraceWriter>, uint32_t tags);
  void Disable();
  void WriteAllAndFlushTraceWriter(std::function<void()> callback);

 private:
  void WriteAllAvailableEvents();

  bool started_ = false;
  base::TaskRunner* task_runner_ = nullptr;
  std::unique_ptr<TraceWriter> trace_writer_;
  PERFETTO_THREAD_CHECKER(thread_checker_)
  base::WeakPtrFactory<MetatraceWriter> weak_ptr_factory_;  // Keep last.
};

}  // namespace perfetto

#endif  // SRC_TRACING_CORE_METATRACE_WRITER_H_
// gen_amalgamated begin header: include/perfetto/ext/tracing/core/trace_writer.h
// gen_amalgamated begin header: include/perfetto/ext/tracing/core/basic_types.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_TRACING_CORE_BASIC_TYPES_H_
#define INCLUDE_PERFETTO_EXT_TRACING_CORE_BASIC_TYPES_H_

// gen_amalgamated expanded: #include "perfetto/base/build_config.h"

#include <stddef.h>
#include <stdint.h>
#include <sys/types.h>

#if PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)
using uid_t = unsigned int;
#endif

namespace perfetto {

// Unique within the scope of the tracing service.
using TracingSessionID = uint64_t;

// Unique within the scope of the tracing service.
using ProducerID = uint16_t;

// Unique within the scope of the tracing service.
using DataSourceInstanceID = uint64_t;

// Unique within the scope of a Producer.
using WriterID = uint16_t;

// Unique within the scope of the tracing service.
using FlushRequestID = uint64_t;

// We need one FD per producer and we are not going to be able to keep > 64k FDs
// open in the service.
static constexpr ProducerID kMaxProducerID = static_cast<ProducerID>(-1);

// 1024 Writers per producer seems a resonable bound. This reduces the ability
// to memory-DoS the service by having to keep track of too many writer IDs.
static constexpr WriterID kMaxWriterID = static_cast<WriterID>((1 << 10) - 1);

// Unique within the scope of a {ProducerID, WriterID} tuple.
using ChunkID = uint32_t;
static constexpr ChunkID kMaxChunkID = static_cast<ChunkID>(-1);

// Unique within the scope of the tracing service.
using BufferID = uint16_t;

// Keep this in sync with SharedMemoryABI::PageHeader::target_buffer.
static constexpr BufferID kMaxTraceBufferID = static_cast<BufferID>(-1);

// Unique within the scope of a tracing session.
using PacketSequenceID = uint32_t;
// Used for extra packets emitted by the service, such as statistics.
static constexpr PacketSequenceID kInvalidPacketSequenceID = 0;
static constexpr PacketSequenceID kServicePacketSequenceID = 1;
static constexpr PacketSequenceID kMaxPacketSequenceID =
    static_cast<PacketSequenceID>(-1);

// TODO(primiano): temporary. The buffer page size should be configurable by
// consumers.
static constexpr size_t kBufferPageSize = 8192;

constexpr uid_t kInvalidUid = static_cast<uid_t>(-1);

constexpr uint32_t kDefaultFlushTimeoutMs = 5000;

}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_TRACING_CORE_BASIC_TYPES_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_TRACING_CORE_TRACE_WRITER_H_
#define INCLUDE_PERFETTO_EXT_TRACING_CORE_TRACE_WRITER_H_

#include <functional>

// gen_amalgamated expanded: #include "perfetto/base/export.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/basic_types.h"
// gen_amalgamated expanded: #include "perfetto/protozero/message_handle.h"
// gen_amalgamated expanded: #include "perfetto/tracing/trace_writer_base.h"

namespace perfetto {

namespace protos {
namespace pbzero {
class TracePacket;
}  // namespace pbzero
}  // namespace protos

// This is a single-thread write interface that allows to write protobufs
// directly into the tracing shared buffer without making any copies.
// It takes care of acquiring and releasing chunks from the
// SharedMemoryArbiter and splitting protos over chunks.
// The idea is that each data source creates one (or more) TraceWriter for each
// thread it wants to write from. Each TraceWriter will get its own dedicated
// chunk and will write into the shared buffer without any locking most of the
// time. Locking will happen only when a chunk is exhausted and a new one is
// acquired from the arbiter.

// TODO: TraceWriter needs to keep the shared memory buffer alive (refcount?).
// Otherwise if the shared memory buffer goes away (e.g. the Service crashes)
// the TraceWriter will keep writing into unmapped memory.

class PERFETTO_EXPORT TraceWriter : public TraceWriterBase {
 public:
  using TracePacketHandle =
      protozero::MessageHandle<protos::pbzero::TracePacket>;

  TraceWriter();
  ~TraceWriter() override;

  // Returns a handle to the root proto message for the trace. The message will
  // be finalized either by calling directly handle.Finalize() or by letting the
  // handle go out of scope. The returned handle can be std::move()'d but cannot
  // be used after either: (i) the TraceWriter instance is destroyed, (ii) a
  // subsequence NewTracePacket() call is made on the same TraceWriter instance.
  TracePacketHandle NewTracePacket() override = 0;

  // Commits the data pending for the current chunk into the shared memory
  // buffer and sends a CommitDataRequest() to the service. This can be called
  // only if handle returned by NewTracePacket() has been destroyed (i.e. we
  // cannot Flush() while writing a TracePacket).
  // Note: Flush() also happens implicitly when destroying the TraceWriter.
  // |callback| is an optional callback. When non-null it will request the
  // service to ACK the flush and will be invoked after the service has
  // ackwnoledged it. Please note that the callback might be NEVER INVOKED, for
  // instance if the service crashes or the IPC connection is dropped. The
  // callback should be used only by tests and best-effort features (logging).
  // TODO(primiano): right now the |callback| will be called on the IPC thread.
  // This is fine in the current single-thread scenario, but long-term
  // trace_writer_impl.cc should be smarter and post it on the right thread.
  virtual void Flush(std::function<void()> callback = {}) = 0;

  virtual WriterID writer_id() const = 0;

  // Bytes written since creation. Is not reset when new chunks are acquired.
  virtual uint64_t written() const = 0;

  // Set the id of the first chunk the writer will emit. Returns |false| if not
  // implemented or if the first chunk was already emitted by the writer.
  //
  // StartupTraceWriter will call this if it committed buffered data on
  // behalf of the TraceWriter.
  virtual bool SetFirstChunkId(ChunkID);

 private:
  TraceWriter(const TraceWriter&) = delete;
  TraceWriter& operator=(const TraceWriter&) = delete;
};

}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_TRACING_CORE_TRACE_WRITER_H_
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/perfetto/perfetto_metatrace.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PERFETTO_TRACE_PERFETTO_PERFETTO_METATRACE_PROTO_H_
#define PERFETTO_PROTOS_PERFETTO_TRACE_PERFETTO_PERFETTO_METATRACE_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/message.h"

namespace perfetto {
namespace protos {
namespace pbzero {


class PerfettoMetatrace_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/6, /*HAS_REPEATED_FIELDS=*/false> {
 public:
  PerfettoMetatrace_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit PerfettoMetatrace_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit PerfettoMetatrace_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_event_id() const { return at<1>().valid(); }
  uint32_t event_id() const { return at<1>().as_uint32(); }
  bool has_counter_id() const { return at<2>().valid(); }
  uint32_t counter_id() const { return at<2>().as_uint32(); }
  bool has_event_duration_ns() const { return at<3>().valid(); }
  uint32_t event_duration_ns() const { return at<3>().as_uint32(); }
  bool has_counter_value() const { return at<4>().valid(); }
  int32_t counter_value() const { return at<4>().as_int32(); }
  bool has_thread_id() const { return at<5>().valid(); }
  uint32_t thread_id() const { return at<5>().as_uint32(); }
  bool has_has_overruns() const { return at<6>().valid(); }
  bool has_overruns() const { return at<6>().as_bool(); }
};

class PerfettoMetatrace : public ::protozero::Message {
 public:
  using Decoder = PerfettoMetatrace_Decoder;
  enum : int32_t {
    kEventIdFieldNumber = 1,
    kCounterIdFieldNumber = 2,
    kEventDurationNsFieldNumber = 3,
    kCounterValueFieldNumber = 4,
    kThreadIdFieldNumber = 5,
    kHasOverrunsFieldNumber = 6,
  };
  void set_event_id(uint32_t value) {
    AppendVarInt(1, value);
  }
  void set_counter_id(uint32_t value) {
    AppendVarInt(2, value);
  }
  void set_event_duration_ns(uint32_t value) {
    AppendVarInt(3, value);
  }
  void set_counter_value(int32_t value) {
    AppendVarInt(4, value);
  }
  void set_thread_id(uint32_t value) {
    AppendVarInt(5, value);
  }
  void set_has_overruns(bool value) {
    AppendTinyVarInt(6, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
// gen_amalgamated begin header: out/tmp.gen_amalgamated/gen/protos/perfetto/trace/trace_packet.pbzero.h
// Autogenerated by the ProtoZero compiler plugin. DO NOT EDIT.

#ifndef PERFETTO_PROTOS_PERFETTO_TRACE_TRACE_PACKET_PROTO_H_
#define PERFETTO_PROTOS_PERFETTO_TRACE_TRACE_PACKET_PROTO_H_

#include <stddef.h>
#include <stdint.h>

// gen_amalgamated expanded: #include "perfetto/protozero/proto_decoder.h"
// gen_amalgamated expanded: #include "perfetto/protozero/message.h"

namespace perfetto {
namespace protos {
namespace pbzero {

class AndroidLogPacket;
class BatteryCounters;
class ChromeBenchmarkMetadata;
class ChromeEventBundle;
class ChromeMetadataPacket;
class ClockSnapshot;
class FtraceEventBundle;
class FtraceStats;
class GpuCounterEvent;
class GpuRenderStageEvent;
class InodeFileMap;
class InternedData;
class PackagesList;
class PerfettoMetatrace;
class PowerRails;
class ProcessDescriptor;
class ProcessStats;
class ProcessTree;
class ProfilePacket;
class ProfiledFrameSymbols;
class StreamingProfilePacket;
class SysStats;
class SystemInfo;
class TestEvent;
class ThreadDescriptor;
class TraceConfig;
class TraceStats;
class TrackEvent;
class Trigger;

class TracePacket_Decoder : public ::protozero::TypedProtoDecoder</*MAX_FIELD_ID=*/900, /*HAS_REPEATED_FIELDS=*/false> {
 public:
  TracePacket_Decoder(const uint8_t* data, size_t len) : TypedProtoDecoder(data, len) {}
  explicit TracePacket_Decoder(const std::string& raw) : TypedProtoDecoder(reinterpret_cast<const uint8_t*>(raw.data()), raw.size()) {}
  explicit TracePacket_Decoder(const ::protozero::ConstBytes& raw) : TypedProtoDecoder(raw.data, raw.size) {}
  bool has_timestamp() const { return at<8>().valid(); }
  uint64_t timestamp() const { return at<8>().as_uint64(); }
  bool has_ftrace_events() const { return at<1>().valid(); }
  ::protozero::ConstBytes ftrace_events() const { return at<1>().as_bytes(); }
  bool has_process_tree() const { return at<2>().valid(); }
  ::protozero::ConstBytes process_tree() const { return at<2>().as_bytes(); }
  bool has_process_stats() const { return at<9>().valid(); }
  ::protozero::ConstBytes process_stats() const { return at<9>().as_bytes(); }
  bool has_inode_file_map() const { return at<4>().valid(); }
  ::protozero::ConstBytes inode_file_map() const { return at<4>().as_bytes(); }
  bool has_chrome_events() const { return at<5>().valid(); }
  ::protozero::ConstBytes chrome_events() const { return at<5>().as_bytes(); }
  bool has_clock_snapshot() const { return at<6>().valid(); }
  ::protozero::ConstBytes clock_snapshot() const { return at<6>().as_bytes(); }
  bool has_sys_stats() const { return at<7>().valid(); }
  ::protozero::ConstBytes sys_stats() const { return at<7>().as_bytes(); }
  bool has_track_event() const { return at<11>().valid(); }
  ::protozero::ConstBytes track_event() const { return at<11>().as_bytes(); }
  bool has_trace_config() const { return at<33>().valid(); }
  ::protozero::ConstBytes trace_config() const { return at<33>().as_bytes(); }
  bool has_ftrace_stats() const { return at<34>().valid(); }
  ::protozero::ConstBytes ftrace_stats() const { return at<34>().as_bytes(); }
  bool has_trace_stats() const { return at<35>().valid(); }
  ::protozero::ConstBytes trace_stats() const { return at<35>().as_bytes(); }
  bool has_profile_packet() const { return at<37>().valid(); }
  ::protozero::ConstBytes profile_packet() const { return at<37>().as_bytes(); }
  bool has_battery() const { return at<38>().valid(); }
  ::protozero::ConstBytes battery() const { return at<38>().as_bytes(); }
  bool has_power_rails() const { return at<40>().valid(); }
  ::protozero::ConstBytes power_rails() const { return at<40>().as_bytes(); }
  bool has_android_log() const { return at<39>().valid(); }
  ::protozero::ConstBytes android_log() const { return at<39>().as_bytes(); }
  bool has_system_info() const { return at<45>().valid(); }
  ::protozero::ConstBytes system_info() const { return at<45>().as_bytes(); }
  bool has_trigger() const { return at<46>().valid(); }
  ::protozero::ConstBytes trigger() const { return at<46>().as_bytes(); }
  bool has_packages_list() const { return at<47>().valid(); }
  ::protozero::ConstBytes packages_list() const { return at<47>().as_bytes(); }
  bool has_chrome_benchmark_metadata() const { return at<48>().valid(); }
  ::protozero::ConstBytes chrome_benchmark_metadata() const { return at<48>().as_bytes(); }
  bool has_perfetto_metatrace() const { return at<49>().valid(); }
  ::protozero::ConstBytes perfetto_metatrace() const { return at<49>().as_bytes(); }
  bool has_chrome_metadata() const { return at<51>().valid(); }
  ::protozero::ConstBytes chrome_metadata() const { return at<51>().as_bytes(); }
  bool has_gpu_counter_event() const { return at<52>().valid(); }
  ::protozero::ConstBytes gpu_counter_event() const { return at<52>().as_bytes(); }
  bool has_gpu_render_stage_event() const { return at<53>().valid(); }
  ::protozero::ConstBytes gpu_render_stage_event() const { return at<53>().as_bytes(); }
  bool has_streaming_profile_packet() const { return at<54>().valid(); }
  ::protozero::ConstBytes streaming_profile_packet() const { return at<54>().as_bytes(); }
  bool has_profiled_frame_symbols() const { return at<55>().valid(); }
  ::protozero::ConstBytes profiled_frame_symbols() const { return at<55>().as_bytes(); }
  bool has_process_descriptor() const { return at<43>().valid(); }
  ::protozero::ConstBytes process_descriptor() const { return at<43>().as_bytes(); }
  bool has_thread_descriptor() const { return at<44>().valid(); }
  ::protozero::ConstBytes thread_descriptor() const { return at<44>().as_bytes(); }
  bool has_synchronization_marker() const { return at<36>().valid(); }
  ::protozero::ConstBytes synchronization_marker() const { return at<36>().as_bytes(); }
  bool has_compressed_packets() const { return at<50>().valid(); }
  ::protozero::ConstBytes compressed_packets() const { return at<50>().as_bytes(); }
  bool has_for_testing() const { return at<900>().valid(); }
  ::protozero::ConstBytes for_testing() const { return at<900>().as_bytes(); }
  bool has_trusted_uid() const { return at<3>().valid(); }
  int32_t trusted_uid() const { return at<3>().as_int32(); }
  bool has_trusted_packet_sequence_id() const { return at<10>().valid(); }
  uint32_t trusted_packet_sequence_id() const { return at<10>().as_uint32(); }
  bool has_interned_data() const { return at<12>().valid(); }
  ::protozero::ConstBytes interned_data() const { return at<12>().as_bytes(); }
  bool has_incremental_state_cleared() const { return at<41>().valid(); }
  bool incremental_state_cleared() const { return at<41>().as_bool(); }
  bool has_previous_packet_dropped() const { return at<42>().valid(); }
  bool previous_packet_dropped() const { return at<42>().as_bool(); }
};

class TracePacket : public ::protozero::Message {
 public:
  using Decoder = TracePacket_Decoder;
  enum : int32_t {
    kTimestampFieldNumber = 8,
    kFtraceEventsFieldNumber = 1,
    kProcessTreeFieldNumber = 2,
    kProcessStatsFieldNumber = 9,
    kInodeFileMapFieldNumber = 4,
    kChromeEventsFieldNumber = 5,
    kClockSnapshotFieldNumber = 6,
    kSysStatsFieldNumber = 7,
    kTrackEventFieldNumber = 11,
    kTraceConfigFieldNumber = 33,
    kFtraceStatsFieldNumber = 34,
    kTraceStatsFieldNumber = 35,
    kProfilePacketFieldNumber = 37,
    kBatteryFieldNumber = 38,
    kPowerRailsFieldNumber = 40,
    kAndroidLogFieldNumber = 39,
    kSystemInfoFieldNumber = 45,
    kTriggerFieldNumber = 46,
    kPackagesListFieldNumber = 47,
    kChromeBenchmarkMetadataFieldNumber = 48,
    kPerfettoMetatraceFieldNumber = 49,
    kChromeMetadataFieldNumber = 51,
    kGpuCounterEventFieldNumber = 52,
    kGpuRenderStageEventFieldNumber = 53,
    kStreamingProfilePacketFieldNumber = 54,
    kProfiledFrameSymbolsFieldNumber = 55,
    kProcessDescriptorFieldNumber = 43,
    kThreadDescriptorFieldNumber = 44,
    kSynchronizationMarkerFieldNumber = 36,
    kCompressedPacketsFieldNumber = 50,
    kForTestingFieldNumber = 900,
    kTrustedUidFieldNumber = 3,
    kTrustedPacketSequenceIdFieldNumber = 10,
    kInternedDataFieldNumber = 12,
    kIncrementalStateClearedFieldNumber = 41,
    kPreviousPacketDroppedFieldNumber = 42,
  };
  void set_timestamp(uint64_t value) {
    AppendVarInt(8, value);
  }
  template <typename T = FtraceEventBundle> T* set_ftrace_events() {
    return BeginNestedMessage<T>(1);
  }

  template <typename T = ProcessTree> T* set_process_tree() {
    return BeginNestedMessage<T>(2);
  }

  template <typename T = ProcessStats> T* set_process_stats() {
    return BeginNestedMessage<T>(9);
  }

  template <typename T = InodeFileMap> T* set_inode_file_map() {
    return BeginNestedMessage<T>(4);
  }

  template <typename T = ChromeEventBundle> T* set_chrome_events() {
    return BeginNestedMessage<T>(5);
  }

  template <typename T = ClockSnapshot> T* set_clock_snapshot() {
    return BeginNestedMessage<T>(6);
  }

  template <typename T = SysStats> T* set_sys_stats() {
    return BeginNestedMessage<T>(7);
  }

  template <typename T = TrackEvent> T* set_track_event() {
    return BeginNestedMessage<T>(11);
  }

  template <typename T = TraceConfig> T* set_trace_config() {
    return BeginNestedMessage<T>(33);
  }

  template <typename T = FtraceStats> T* set_ftrace_stats() {
    return BeginNestedMessage<T>(34);
  }

  template <typename T = TraceStats> T* set_trace_stats() {
    return BeginNestedMessage<T>(35);
  }

  template <typename T = ProfilePacket> T* set_profile_packet() {
    return BeginNestedMessage<T>(37);
  }

  template <typename T = BatteryCounters> T* set_battery() {
    return BeginNestedMessage<T>(38);
  }

  template <typename T = PowerRails> T* set_power_rails() {
    return BeginNestedMessage<T>(40);
  }

  template <typename T = AndroidLogPacket> T* set_android_log() {
    return BeginNestedMessage<T>(39);
  }

  template <typename T = SystemInfo> T* set_system_info() {
    return BeginNestedMessage<T>(45);
  }

  template <typename T = Trigger> T* set_trigger() {
    return BeginNestedMessage<T>(46);
  }

  template <typename T = PackagesList> T* set_packages_list() {
    return BeginNestedMessage<T>(47);
  }

  template <typename T = ChromeBenchmarkMetadata> T* set_chrome_benchmark_metadata() {
    return BeginNestedMessage<T>(48);
  }

  template <typename T = PerfettoMetatrace> T* set_perfetto_metatrace() {
    return BeginNestedMessage<T>(49);
  }

  template <typename T = ChromeMetadataPacket> T* set_chrome_metadata() {
    return BeginNestedMessage<T>(51);
  }

  template <typename T = GpuCounterEvent> T* set_gpu_counter_event() {
    return BeginNestedMessage<T>(52);
  }

  template <typename T = GpuRenderStageEvent> T* set_gpu_render_stage_event() {
    return BeginNestedMessage<T>(53);
  }

  template <typename T = StreamingProfilePacket> T* set_streaming_profile_packet() {
    return BeginNestedMessage<T>(54);
  }

  template <typename T = ProfiledFrameSymbols> T* set_profiled_frame_symbols() {
    return BeginNestedMessage<T>(55);
  }

  template <typename T = ProcessDescriptor> T* set_process_descriptor() {
    return BeginNestedMessage<T>(43);
  }

  template <typename T = ThreadDescriptor> T* set_thread_descriptor() {
    return BeginNestedMessage<T>(44);
  }

  void set_synchronization_marker(const uint8_t* data, size_t size) {
    AppendBytes(36, data, size);
  }
  void set_compressed_packets(const uint8_t* data, size_t size) {
    AppendBytes(50, data, size);
  }
  template <typename T = TestEvent> T* set_for_testing() {
    return BeginNestedMessage<T>(900);
  }

  void set_trusted_uid(int32_t value) {
    AppendVarInt(3, value);
  }
  void set_trusted_packet_sequence_id(uint32_t value) {
    AppendVarInt(10, value);
  }
  template <typename T = InternedData> T* set_interned_data() {
    return BeginNestedMessage<T>(12);
  }

  void set_incremental_state_cleared(bool value) {
    AppendTinyVarInt(41, value);
  }
  void set_previous_packet_dropped(bool value) {
    AppendTinyVarInt(42, value);
  }
};

} // Namespace.
} // Namespace.
} // Namespace.
#endif  // Include guard.
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "src/tracing/core/metatrace_writer.h"

// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/base/task_runner.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/trace_writer.h"
// gen_amalgamated expanded: #include "perfetto/tracing/core/data_source_descriptor.h"

// gen_amalgamated expanded: #include "perfetto/trace/perfetto/perfetto_metatrace.pbzero.h"
// gen_amalgamated expanded: #include "perfetto/trace/trace_packet.pbzero.h"

namespace perfetto {

// static
constexpr char MetatraceWriter::kDataSourceName[];

MetatraceWriter::MetatraceWriter() : weak_ptr_factory_(this) {}

MetatraceWriter::~MetatraceWriter() {
  Disable();
}

void MetatraceWriter::Enable(base::TaskRunner* task_runner,
                             std::unique_ptr<TraceWriter> trace_writer,
                             uint32_t tags) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  if (started_) {
    PERFETTO_DFATAL_OR_ELOG("Metatrace already started from this instance");
    return;
  }
  task_runner_ = task_runner;
  trace_writer_ = std::move(trace_writer);
  auto weak_ptr = weak_ptr_factory_.GetWeakPtr();
  bool enabled = metatrace::Enable(
      [weak_ptr] {
        if (weak_ptr)
          weak_ptr->WriteAllAvailableEvents();
      },
      task_runner, tags);
  if (!enabled)
    return;
  started_ = true;
}

void MetatraceWriter::Disable() {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  if (!started_)
    return;
  metatrace::Disable();
  started_ = false;
  trace_writer_.reset();
}

void MetatraceWriter::WriteAllAvailableEvents() {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  if (!started_)
    return;
  for (auto it = metatrace::RingBuffer::GetReadIterator(); it; ++it) {
    auto type_and_id = it->type_and_id.load(std::memory_order_acquire);
    if (type_and_id == 0)
      break;  // Stop at the first incomplete event.

    auto packet = trace_writer_->NewTracePacket();
    packet->set_timestamp(it->timestamp_ns());
    auto* evt = packet->set_perfetto_metatrace();
    uint16_t type = type_and_id & metatrace::Record::kTypeMask;
    uint16_t id = type_and_id & ~metatrace::Record::kTypeMask;
    if (type == metatrace::Record::kTypeCounter) {
      evt->set_counter_id(id);
      evt->set_counter_value(it->counter_value);
    } else {
      evt->set_event_id(id);
      evt->set_event_duration_ns(it->duration_ns);
    }

    evt->set_thread_id(static_cast<uint32_t>(it->thread_id));

    if (metatrace::RingBuffer::has_overruns())
      evt->set_has_overruns(true);
  }
  // The |it| destructor will automatically update the read index position in
  // the meta-trace ring buffer.
}

void MetatraceWriter::WriteAllAndFlushTraceWriter(
    std::function<void()> callback) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  WriteAllAvailableEvents();
  trace_writer_->Flush(std::move(callback));
}

}  // namespace perfetto
// gen_amalgamated begin source: src/tracing/core/null_trace_writer.cc
// gen_amalgamated begin header: src/tracing/core/null_trace_writer.h
/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef SRC_TRACING_CORE_NULL_TRACE_WRITER_H_
#define SRC_TRACING_CORE_NULL_TRACE_WRITER_H_

// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/trace_writer.h"
// gen_amalgamated expanded: #include "perfetto/protozero/message_handle.h"
// gen_amalgamated expanded: #include "perfetto/protozero/scattered_stream_null_delegate.h"

namespace perfetto {

// A specialization of TraceWriter which no-ops all the writes routing them
// into a fixed region of memory
// See //include/perfetto/tracing/core/trace_writer.h for docs.
class NullTraceWriter : public TraceWriter {
 public:
  NullTraceWriter();
  ~NullTraceWriter() override;

  // TraceWriter implementation. See documentation in trace_writer.h.
  // TracePacketHandle is defined in trace_writer.h
  TracePacketHandle NewTracePacket() override;
  void Flush(std::function<void()> callback = {}) override;
  WriterID writer_id() const override;
  uint64_t written() const override;

 private:
  NullTraceWriter(const NullTraceWriter&) = delete;
  NullTraceWriter& operator=(const NullTraceWriter&) = delete;

  protozero::ScatteredStreamWriterNullDelegate delegate_;
  protozero::ScatteredStreamWriter stream_;

  // The packet returned via NewTracePacket(). Its owned by this class,
  // TracePacketHandle has just a pointer to it.
  std::unique_ptr<protos::pbzero::TracePacket> cur_packet_;
};

}  // namespace perfetto

#endif  // SRC_TRACING_CORE_NULL_TRACE_WRITER_H_
/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "src/tracing/core/null_trace_writer.h"

// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/utils.h"

// gen_amalgamated expanded: #include "perfetto/protozero/message.h"

// gen_amalgamated expanded: #include "perfetto/trace/trace_packet.pbzero.h"

namespace perfetto {

NullTraceWriter::NullTraceWriter()
    : delegate_(base::kPageSize), stream_(&delegate_) {
  cur_packet_.reset(new protos::pbzero::TracePacket());
  cur_packet_->Finalize();  // To avoid the DCHECK in NewTracePacket().
}

NullTraceWriter::~NullTraceWriter() {}

void NullTraceWriter::Flush(std::function<void()> callback) {
  // Flush() cannot be called in the middle of a TracePacket.
  PERFETTO_CHECK(cur_packet_->is_finalized());

  if (callback)
    callback();
}

NullTraceWriter::TracePacketHandle NullTraceWriter::NewTracePacket() {
  // If we hit this, the caller is calling NewTracePacket() without having
  // finalized the previous packet.
  PERFETTO_DCHECK(cur_packet_->is_finalized());
  cur_packet_->Reset(&stream_);
  return TraceWriter::TracePacketHandle(cur_packet_.get());
}

WriterID NullTraceWriter::writer_id() const {
  return 0;
}

uint64_t NullTraceWriter::written() const {
  return 0;
}

}  // namespace perfetto
// gen_amalgamated begin source: src/tracing/core/observable_events.cc
// gen_amalgamated begin header: include/perfetto/ext/tracing/core/observable_events.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*******************************************************************************
 * AUTOGENERATED - DO NOT EDIT
 *******************************************************************************
 * This file has been generated from the protobuf message
 * perfetto/common/observable_events.proto
 * by
 * ../../tools/proto_to_cpp/proto_to_cpp.cc.
 * If you need to make changes here, change the .proto file and then run
 * ./tools/gen_tracing_cpp_headers_from_protos
 */

#ifndef INCLUDE_PERFETTO_EXT_TRACING_CORE_OBSERVABLE_EVENTS_H_
#define INCLUDE_PERFETTO_EXT_TRACING_CORE_OBSERVABLE_EVENTS_H_

#include <stdint.h>
#include <string>
#include <type_traits>
#include <vector>

// gen_amalgamated expanded: #include "perfetto/base/copyable_ptr.h"
// gen_amalgamated expanded: #include "perfetto/base/export.h"

// Forward declarations for protobuf types.
namespace perfetto {
namespace protos {
class ObservableEvents;
class ObservableEvents_DataSourceInstanceStateChange;
}  // namespace protos
}  // namespace perfetto

namespace perfetto {
class ObservableEvents;

class PERFETTO_EXPORT ObservableEvents {
 public:
  class PERFETTO_EXPORT DataSourceInstanceStateChange {
   public:
    enum DataSourceInstanceState {
      DATA_SOURCE_INSTANCE_STATE_STOPPED = 1,
      DATA_SOURCE_INSTANCE_STATE_STARTED = 2,
    };
    DataSourceInstanceStateChange();
    ~DataSourceInstanceStateChange();
    DataSourceInstanceStateChange(DataSourceInstanceStateChange&&) noexcept;
    DataSourceInstanceStateChange& operator=(DataSourceInstanceStateChange&&);
    DataSourceInstanceStateChange(const DataSourceInstanceStateChange&);
    DataSourceInstanceStateChange& operator=(
        const DataSourceInstanceStateChange&);
    bool operator==(const DataSourceInstanceStateChange&) const;
    bool operator!=(const DataSourceInstanceStateChange& other) const {
      return !(*this == other);
    }

    // Raw proto decoding.
    void ParseRawProto(const std::string&);
    // Conversion methods from/to the corresponding protobuf types.
    void FromProto(const perfetto::protos::
                       ObservableEvents_DataSourceInstanceStateChange&);
    void ToProto(
        perfetto::protos::ObservableEvents_DataSourceInstanceStateChange*)
        const;

    const std::string& producer_name() const { return producer_name_; }
    void set_producer_name(const std::string& value) { producer_name_ = value; }

    const std::string& data_source_name() const { return data_source_name_; }
    void set_data_source_name(const std::string& value) {
      data_source_name_ = value;
    }

    DataSourceInstanceState state() const { return state_; }
    void set_state(DataSourceInstanceState value) { state_ = value; }

   private:
    std::string producer_name_{};
    std::string data_source_name_{};
    DataSourceInstanceState state_{};

    // Allows to preserve unknown protobuf fields for compatibility
    // with future versions of .proto files.
    std::string unknown_fields_;
  };

  ObservableEvents();
  ~ObservableEvents();
  ObservableEvents(ObservableEvents&&) noexcept;
  ObservableEvents& operator=(ObservableEvents&&);
  ObservableEvents(const ObservableEvents&);
  ObservableEvents& operator=(const ObservableEvents&);
  bool operator==(const ObservableEvents&) const;
  bool operator!=(const ObservableEvents& other) const {
    return !(*this == other);
  }

  // Raw proto decoding.
  void ParseRawProto(const std::string&);
  // Conversion methods from/to the corresponding protobuf types.
  void FromProto(const perfetto::protos::ObservableEvents&);
  void ToProto(perfetto::protos::ObservableEvents*) const;

  int instance_state_changes_size() const {
    return static_cast<int>(instance_state_changes_.size());
  }
  const std::vector<DataSourceInstanceStateChange>& instance_state_changes()
      const {
    return instance_state_changes_;
  }
  std::vector<DataSourceInstanceStateChange>* mutable_instance_state_changes() {
    return &instance_state_changes_;
  }
  void clear_instance_state_changes() { instance_state_changes_.clear(); }
  DataSourceInstanceStateChange* add_instance_state_changes() {
    instance_state_changes_.emplace_back();
    return &instance_state_changes_.back();
  }

 private:
  std::vector<DataSourceInstanceStateChange> instance_state_changes_;

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;
};

}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_TRACING_CORE_OBSERVABLE_EVENTS_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*******************************************************************************
 * AUTOGENERATED - DO NOT EDIT
 *******************************************************************************
 * This file has been generated from the protobuf message
 * perfetto/common/observable_events.proto
 * by
 * ../../tools/proto_to_cpp/proto_to_cpp.cc.
 * If you need to make changes here, change the .proto file and then run
 * ./tools/gen_tracing_cpp_headers_from_protos
 */

// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/observable_events.h"

// gen_amalgamated expanded: #include "perfetto/common/observable_events.pb.h"

namespace perfetto {

ObservableEvents::ObservableEvents() = default;
ObservableEvents::~ObservableEvents() = default;
ObservableEvents::ObservableEvents(const ObservableEvents&) = default;
ObservableEvents& ObservableEvents::operator=(const ObservableEvents&) =
    default;
ObservableEvents::ObservableEvents(ObservableEvents&&) noexcept = default;
ObservableEvents& ObservableEvents::operator=(ObservableEvents&&) = default;

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
bool ObservableEvents::operator==(const ObservableEvents& other) const {
  return (instance_state_changes_ == other.instance_state_changes_);
}
#pragma GCC diagnostic pop

void ObservableEvents::ParseRawProto(const std::string& raw) {
  perfetto::protos::ObservableEvents proto;
  proto.ParseFromString(raw);
  FromProto(proto);
}

void ObservableEvents::FromProto(
    const perfetto::protos::ObservableEvents& proto) {
  instance_state_changes_.clear();
  for (const auto& field : proto.instance_state_changes()) {
    instance_state_changes_.emplace_back();
    instance_state_changes_.back().FromProto(field);
  }
  unknown_fields_ = proto.unknown_fields();
}

void ObservableEvents::ToProto(
    perfetto::protos::ObservableEvents* proto) const {
  proto->Clear();

  for (const auto& it : instance_state_changes_) {
    auto* entry = proto->add_instance_state_changes();
    it.ToProto(entry);
  }
  *(proto->mutable_unknown_fields()) = unknown_fields_;
}

ObservableEvents::DataSourceInstanceStateChange::
    DataSourceInstanceStateChange() = default;
ObservableEvents::DataSourceInstanceStateChange::
    ~DataSourceInstanceStateChange() = default;
ObservableEvents::DataSourceInstanceStateChange::DataSourceInstanceStateChange(
    const ObservableEvents::DataSourceInstanceStateChange&) = default;
ObservableEvents::DataSourceInstanceStateChange&
ObservableEvents::DataSourceInstanceStateChange::operator=(
    const ObservableEvents::DataSourceInstanceStateChange&) = default;
ObservableEvents::DataSourceInstanceStateChange::DataSourceInstanceStateChange(
    ObservableEvents::DataSourceInstanceStateChange&&) noexcept = default;
ObservableEvents::DataSourceInstanceStateChange&
ObservableEvents::DataSourceInstanceStateChange::operator=(
    ObservableEvents::DataSourceInstanceStateChange&&) = default;

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
bool ObservableEvents::DataSourceInstanceStateChange::operator==(
    const ObservableEvents::DataSourceInstanceStateChange& other) const {
  return (producer_name_ == other.producer_name_) &&
         (data_source_name_ == other.data_source_name_) &&
         (state_ == other.state_);
}
#pragma GCC diagnostic pop

void ObservableEvents::DataSourceInstanceStateChange::ParseRawProto(
    const std::string& raw) {
  perfetto::protos::ObservableEvents_DataSourceInstanceStateChange proto;
  proto.ParseFromString(raw);
  FromProto(proto);
}

void ObservableEvents::DataSourceInstanceStateChange::FromProto(
    const perfetto::protos::ObservableEvents_DataSourceInstanceStateChange&
        proto) {
  static_assert(sizeof(producer_name_) == sizeof(proto.producer_name()),
                "size mismatch");
  producer_name_ = static_cast<decltype(producer_name_)>(proto.producer_name());

  static_assert(sizeof(data_source_name_) == sizeof(proto.data_source_name()),
                "size mismatch");
  data_source_name_ =
      static_cast<decltype(data_source_name_)>(proto.data_source_name());

  static_assert(sizeof(state_) == sizeof(proto.state()), "size mismatch");
  state_ = static_cast<decltype(state_)>(proto.state());
  unknown_fields_ = proto.unknown_fields();
}

void ObservableEvents::DataSourceInstanceStateChange::ToProto(
    perfetto::protos::ObservableEvents_DataSourceInstanceStateChange* proto)
    const {
  proto->Clear();

  static_assert(sizeof(producer_name_) == sizeof(proto->producer_name()),
                "size mismatch");
  proto->set_producer_name(
      static_cast<decltype(proto->producer_name())>(producer_name_));

  static_assert(sizeof(data_source_name_) == sizeof(proto->data_source_name()),
                "size mismatch");
  proto->set_data_source_name(
      static_cast<decltype(proto->data_source_name())>(data_source_name_));

  static_assert(sizeof(state_) == sizeof(proto->state()), "size mismatch");
  proto->set_state(static_cast<decltype(proto->state())>(state_));
  *(proto->mutable_unknown_fields()) = unknown_fields_;
}

}  // namespace perfetto
// gen_amalgamated begin source: src/tracing/core/packet_stream_validator.cc
// gen_amalgamated begin header: src/tracing/core/packet_stream_validator.h
// gen_amalgamated begin header: src/tracing/core/sliced_protobuf_input_stream.h
// gen_amalgamated begin header: include/perfetto/ext/tracing/core/slice.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_TRACING_CORE_SLICE_H_
#define INCLUDE_PERFETTO_EXT_TRACING_CORE_SLICE_H_

#include <stddef.h>
#include <string.h>

#include <memory>
#include <string>
#include <vector>

// gen_amalgamated expanded: #include "perfetto/base/logging.h"

namespace perfetto {

// A simple wrapper around a virtually contiguous memory range that contains a
// TracePacket, or just a portion of it.
struct Slice {
  Slice() : start(nullptr), size(0) {}
  Slice(const void* st, size_t sz) : start(st), size(sz) {}

  // Used to inherit ownership of a buffer from a protobuf via release_str().
  explicit Slice(std::unique_ptr<std::string> str)
      : start(&(*str)[0]), size(str->size()), moved_str_data_(std::move(str)) {}

  Slice(Slice&& other) noexcept = default;

  // Create a Slice which owns |size| bytes of memory.
  static Slice Allocate(size_t size) {
    Slice slice;
    slice.own_data_.reset(new uint8_t[size]);
    slice.start = &slice.own_data_[0];
    slice.size = size;
    return slice;
  }

  uint8_t* own_data() {
    PERFETTO_DCHECK(own_data_);
    return own_data_.get();
  }

  const void* start;
  size_t size;

 private:
  Slice(const Slice&) = delete;
  void operator=(const Slice&) = delete;

  std::unique_ptr<uint8_t[]> own_data_;
  std::unique_ptr<std::string> moved_str_data_;
};

// TODO(primiano): most TracePacket(s) fit in a slice or two. We need something
// a bit more clever here that has inline capacity for 2 slices and then uses a
// std::forward_list or a std::vector for the less likely cases.
using Slices = std::vector<Slice>;

}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_TRACING_CORE_SLICE_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef SRC_TRACING_CORE_SLICED_PROTOBUF_INPUT_STREAM_H_
#define SRC_TRACING_CORE_SLICED_PROTOBUF_INPUT_STREAM_H_

// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/slice.h"

#include <stdint.h>

#include <google/protobuf/io/zero_copy_stream.h>

namespace perfetto {

// Wraps a sequence of Slice(s) in a protobuf ZeroCopyInputStream that can be
// passed to protobuf::Message::ParseFromZeroCopyStream().
class SlicedProtobufInputStream
    : public google::protobuf::io::ZeroCopyInputStream {
 public:
  explicit SlicedProtobufInputStream(const Slices*);
  ~SlicedProtobufInputStream() override;

  // ZeroCopyInputStream implementation. See zero_copy_stream.h for the API
  // contract of the methods below.
  bool Next(const void** data, int* size) override;
  void BackUp(int count) override;
  bool Skip(int count) override;
  google::protobuf::int64 ByteCount() const override;

 private:
  bool Validate() const;

  const Slices* const slices_;
  Slices::const_iterator cur_slice_;
  size_t pos_in_cur_slice_ = 0;
};

}  // namespace perfetto

#endif  // SRC_TRACING_CORE_SLICED_PROTOBUF_INPUT_STREAM_H_
/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef SRC_TRACING_CORE_PACKET_STREAM_VALIDATOR_H_
#define SRC_TRACING_CORE_PACKET_STREAM_VALIDATOR_H_

// gen_amalgamated expanded: #include "src/tracing/core/sliced_protobuf_input_stream.h"

namespace perfetto {

// Checks that the stream of trace packets sent by the producer is well formed.
// This includes:
//
// - Checking that the packets are not truncated.
// - There are no dangling bytes left over in the packets.
// - Any trusted fields (e.g., uid) are not set.
//
// Note that we only validate top-level fields in the trace proto; sub-messages
// are simply skipped.
class PacketStreamValidator {
 public:
  PacketStreamValidator() = delete;

  static bool Validate(const Slices&);
};

}  // namespace perfetto

#endif  // SRC_TRACING_CORE_PACKET_STREAM_VALIDATOR_H_
/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "src/tracing/core/packet_stream_validator.h"

#include <inttypes.h>
#include <stddef.h>

// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"
// gen_amalgamated expanded: #include "perfetto/trace/trusted_packet.pb.h"

namespace perfetto {

// static
bool PacketStreamValidator::Validate(const Slices& slices) {
  SlicedProtobufInputStream stream(&slices);
  size_t size = 0;
  for (const Slice& slice : slices)
    size += slice.size;

  protos::TrustedPacket packet;
  if (!packet.ParseFromBoundedZeroCopyStream(&stream, static_cast<int>(size)))
    return false;

  // Only the service is allowed to fill in these fields:

  if (packet.optional_trusted_uid_case() !=
      protos::TrustedPacket::OPTIONAL_TRUSTED_UID_NOT_SET) {
    return false;
  }

  if (packet.optional_trusted_packet_sequence_id_case() !=
      protos::TrustedPacket::OPTIONAL_TRUSTED_PACKET_SEQUENCE_ID_NOT_SET) {
    return false;
  }

  if (packet.has_trace_config())
    return false;

  if (packet.has_trace_stats())
    return false;

  if (!packet.synchronization_marker().empty())
    return false;

  // We are deliberately not checking for clock_snapshot for the moment. It's
  // unclear if we want to allow producers to snapshot their clocks. Ideally we
  // want a security model where producers can only snapshot their own clocks
  // and not system ones. However, right now, there isn't a compelling need to
  // be so prescriptive.

  return true;
}

}  // namespace perfetto
// gen_amalgamated begin source: src/tracing/core/shared_memory_abi.cc
// gen_amalgamated begin header: include/perfetto/ext/tracing/core/shared_memory_abi.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_TRACING_CORE_SHARED_MEMORY_ABI_H_
#define INCLUDE_PERFETTO_EXT_TRACING_CORE_SHARED_MEMORY_ABI_H_

#include <stddef.h>
#include <stdint.h>

#include <array>
#include <atomic>
#include <bitset>
#include <thread>
#include <type_traits>
#include <utility>

// gen_amalgamated expanded: #include "perfetto/base/logging.h"

namespace perfetto {

// This file defines the binary interface of the memory buffers shared between
// Producer and Service. This is a long-term stable ABI and has to be backwards
// compatible to deal with mismatching Producer and Service versions.
//
// Overview
// --------
// SMB := "Shared Memory Buffer".
// In the most typical case of a multi-process architecture (i.e. Producer and
// Service are hosted by different processes), a Producer means almost always
// a "client process producing data" (almost: in some cases a process might host
// > 1 Producer, if it links two libraries, independent of each other, that both
// use Perfetto tracing).
// The Service has one SMB for each Producer.
// A producer has one or (typically) more data sources. They all share the same
// SMB.
// The SMB is a staging area to decouple data sources living in the Producer
// and allow them to do non-blocking async writes.
// The SMB is *not* the ultimate logging buffer seen by the Consumer. That one
// is larger (~MBs) and not shared with Producers.
// Each SMB is small, typically few KB. Its size is configurable by the producer
// within a max limit of ~MB (see kMaxShmSize in tracing_service_impl.cc).
// The SMB is partitioned into fixed-size Page(s). The size of the Pages are
// determined by each Producer at connection time and cannot be changed.
// Hence, different producers can have SMB(s) that have a different Page size
// from each other, but the page size will be constant throughout all the
// lifetime of the SMB.
// Page(s) are partitioned by the Producer into variable size Chunk(s):
//
// +------------+      +--------------------------+
// | Producer 1 |  <-> |      SMB 1 [~32K - 1MB]  |
// +------------+      +--------+--------+--------+
//                     |  Page  |  Page  |  Page  |
//                     +--------+--------+--------+
//                     | Chunk  |        | Chunk  |
//                     +--------+  Chunk +--------+ <----+
//                     | Chunk  |        | Chunk  |      |
//                     +--------+--------+--------+      +---------------------+
//                                                       |       Service       |
// +------------+      +--------------------------+      +---------------------+
// | Producer 2 |  <-> |      SMB 2 [~32K - 1MB]  |     /| large ring buffers  |
// +------------+      +--------+--------+--------+ <--+ | (100K - several MB) |
//                     |  Page  |  Page  |  Page  |      +---------------------+
//                     +--------+--------+--------+
//                     | Chunk  |        | Chunk  |
//                     +--------+  Chunk +--------+
//                     | Chunk  |        | Chunk  |
//                     +--------+--------+--------+
//
// * Sizes of both SMB and ring buffers are purely indicative and decided at
// configuration time by the Producer (for SMB sizes) and the Consumer (for the
// final ring buffer size).

// Page
// ----
// A page is a portion of the shared memory buffer and defines the granularity
// of the interaction between the Producer and tracing Service. When scanning
// the shared memory buffer to determine if something should be moved to the
// central logging buffers, the Service most of the times looks at and moves
// whole pages. Similarly, the Producer sends an IPC to invite the Service to
// drain the shared memory buffer only when a whole page is filled.
// Having fixed the total SMB size (hence the total memory overhead), the page
// size is a triangular tradeoff between:
// 1) IPC traffic: smaller pages -> more IPCs.
// 2) Producer lock freedom: larger pages -> larger chunks -> data sources can
//    write more data without needing to swap chunks and synchronize.
// 3) Risk of write-starving the SMB: larger pages -> higher chance that the
//    Service won't manage to drain them and the SMB remains full.
// The page size, on the other side, has no implications on wasted memory due to
// fragmentations (see Chunk below).
// The size of the page is chosen by the Service at connection time and stays
// fixed throughout all the lifetime of the Producer. Different producers (i.e.
// ~ different client processes) can use different page sizes.
// The page size must be an integer multiple of 4k (this is to allow VM page
// stealing optimizations) and obviously has to be an integer divisor of the
// total SMB size.

// Chunk
// -----
// A chunk is a portion of a Page which is written and handled by a Producer.
// A chunk contains a linear sequence of TracePacket(s) (the root proto).
// A chunk cannot be written concurrently by two data sources. Protobufs must be
// encoded as contiguous byte streams and cannot be interleaved. Therefore, on
// the Producer side, a chunk is almost always owned exclusively by one thread
// (% extremely peculiar slow-path cases).
// Chunks are essentially single-writer single-thread lock-free arenas. Locking
// happens only when a Chunk is full and a new one needs to be acquired.
// Locking happens only within the scope of a Producer process. There is no
// inter-process locking. The Producer cannot lock the Service and viceversa.
// In the worst case, any of the two can starve the SMB, by marking all chunks
// as either being read or written. But that has the only side effect of
// losing the trace data.
// The Producer can decide to partition each page into a number of limited
// configurations (e.g., 1 page == 1 chunk, 1 page == 2 chunks and so on).

// TracePacket
// -----------
// Is the atom of tracing. Putting aside pages and chunks a trace is merely a
// sequence of TracePacket(s). TracePacket is the root protobuf message.
// A TracePacket can span across several chunks (hence even across several
// pages). A TracePacket can therefore be >> chunk size, >> page size and even
// >> SMB size. The Chunk header carries metadata to deal with the TracePacket
// splitting case.

// Use only explicitly-sized types below. DO NOT use size_t or any architecture
// dependent size (e.g. size_t) in the struct fields. This buffer will be read
// and written by processes that have a different bitness in the same OS.
// Instead it's fine to assume little-endianess. Big-endian is a dream we are
// not currently pursuing.

class SharedMemoryABI {
 public:
  // This is due to Chunk::size being 16 bits.
  static constexpr size_t kMaxPageSize = 64 * 1024;

  // "14" is the max number that can be encoded in a 32 bit atomic word using
  // 2 state bits per Chunk and leaving 4 bits for the page layout.
  // See PageLayout below.
  static constexpr size_t kMaxChunksPerPage = 14;

  // Each TracePacket in the Chunk is prefixed by a 4 bytes redundant VarInt
  // (see proto_utils.h) stating its size.
  static constexpr size_t kPacketHeaderSize = 4;

  // Chunk states and transitions:
  //    kChunkFree  <----------------+
  //         |  (Producer)           |
  //         V                       |
  //  kChunkBeingWritten             |
  //         |  (Producer)           |
  //         V                       |
  //  kChunkComplete                 |
  //         |  (Service)            |
  //         V                       |
  //  kChunkBeingRead                |
  //        |   (Service)            |
  //        +------------------------+
  enum ChunkState : uint32_t {
    // The Chunk is free. The Service shall never touch it, the Producer can
    // acquire it and transition it into kChunkBeingWritten.
    kChunkFree = 0,

    // The Chunk is being used by the Producer and is not complete yet.
    // The Service shall never touch kChunkBeingWritten pages.
    kChunkBeingWritten = 1,

    // The Service is moving the page into its non-shared ring buffer. The
    // Producer shall never touch kChunkBeingRead pages.
    kChunkBeingRead = 2,

    // The Producer is done writing the page and won't touch it again. The
    // Service can now move it to its non-shared ring buffer.
    // kAllChunksComplete relies on this being == 3.
    kChunkComplete = 3,
  };
  static constexpr const char* kChunkStateStr[] = {"Free", "BeingWritten",
                                                   "BeingRead", "Complete"};

  enum PageLayout : uint32_t {
    // The page is fully free and has not been partitioned yet.
    kPageNotPartitioned = 0,

    // TODO(primiano): Aligning a chunk @ 16 bytes could allow to use faster
    // intrinsics based on quad-word moves. Do the math and check what is the
    // fragmentation loss.

    // align4(X) := the largest integer N s.t. (N % 4) == 0 && N <= X.
    // 8 == sizeof(PageHeader).
    kPageDiv1 = 1,   // Only one chunk of size: PAGE_SIZE - 8.
    kPageDiv2 = 2,   // Two chunks of size: align4((PAGE_SIZE - 8) / 2).
    kPageDiv4 = 3,   // Four chunks of size: align4((PAGE_SIZE - 8) / 4).
    kPageDiv7 = 4,   // Seven chunks of size: align4((PAGE_SIZE - 8) / 7).
    kPageDiv14 = 5,  // Fourteen chunks of size: align4((PAGE_SIZE - 8) / 14).

    // The rationale for 7 and 14 above is to maximize the page usage for the
    // likely case of |page_size| == 4096:
    // (((4096 - 8) / 14) % 4) == 0, while (((4096 - 8) / 16 % 4)) == 3. So
    // Div16 would waste 3 * 16 = 48 bytes per page for chunk alignment gaps.

    kPageDivReserved1 = 6,
    kPageDivReserved2 = 7,
    kNumPageLayouts = 8,
  };

  // Keep this consistent with the PageLayout enum above.
  static constexpr uint32_t kNumChunksForLayout[] = {0, 1, 2, 4, 7, 14, 0, 0};

  // Layout of a Page.
  // +===================================================+
  // | Page header [8 bytes]                             |
  // | Tells how many chunks there are, how big they are |
  // | and their state (free, read, write, complete).    |
  // +===================================================+
  // +***************************************************+
  // | Chunk #0 header [8 bytes]                         |
  // | Tells how many packets there are and whether the  |
  // | whether the 1st and last ones are fragmented.     |
  // | Also has a chunk id to reassemble fragments.    |
  // +***************************************************+
  // +---------------------------------------------------+
  // | Packet #0 size [varint, up to 4 bytes]            |
  // + - - - - - - - - - - - - - - - - - - - - - - - - - +
  // | Packet #0 payload                                 |
  // | A TracePacket protobuf message                    |
  // +---------------------------------------------------+
  //                         ...
  // + . . . . . . . . . . . . . . . . . . . . . . . . . +
  // |      Optional padding to maintain aligment        |
  // + . . . . . . . . . . . . . . . . . . . . . . . . . +
  // +---------------------------------------------------+
  // | Packet #N size [varint, up to 4 bytes]            |
  // + - - - - - - - - - - - - - - - - - - - - - - - - - +
  // | Packet #N payload                                 |
  // | A TracePacket protobuf message                    |
  // +---------------------------------------------------+
  //                         ...
  // +***************************************************+
  // | Chunk #M header [8 bytes]                         |
  //                         ...

  // Alignment applies to start offset only. The Chunk size is *not* aligned.
  static constexpr uint32_t kChunkAlignment = 4;
  static constexpr uint32_t kChunkShift = 2;
  static constexpr uint32_t kChunkMask = 0x3;
  static constexpr uint32_t kLayoutMask = 0x70000000;
  static constexpr uint32_t kLayoutShift = 28;
  static constexpr uint32_t kAllChunksMask = 0x0FFFFFFF;

  // This assumes that kChunkComplete == 3.
  static constexpr uint32_t kAllChunksComplete = 0x0FFFFFFF;
  static constexpr uint32_t kAllChunksFree = 0;
  static constexpr size_t kInvalidPageIdx = static_cast<size_t>(-1);

  // There is one page header per page, at the beginning of the page.
  struct PageHeader {
    // |layout| bits:
    // [31] [30:28] [27:26] ... [1:0]
    //  |      |       |     |    |
    //  |      |       |     |    +---------- ChunkState[0]
    //  |      |       |     +--------------- ChunkState[12..1]
    //  |      |       +--------------------- ChunkState[13]
    //  |      +----------------------------- PageLayout (0 == page fully free)
    //  +------------------------------------ Reserved for future use
    std::atomic<uint32_t> layout;

    // If we'll ever going to use this in the future it might come handy
    // reviving the kPageBeingPartitioned logic (look in git log, it was there
    // at some point in the past).
    uint32_t reserved;
  };

  // There is one Chunk header per chunk (hence PageLayout per page) at the
  // beginning of each chunk.
  struct ChunkHeader {
    enum Flags : uint8_t {
      // If set, the first TracePacket in the chunk is partial and continues
      // from |chunk_id| - 1 (within the same |writer_id|).
      kFirstPacketContinuesFromPrevChunk = 1 << 0,

      // If set, the last TracePacket in the chunk is partial and continues on
      // |chunk_id| + 1 (within the same |writer_id|).
      kLastPacketContinuesOnNextChunk = 1 << 1,

      // If set, the last (fragmented) TracePacket in the chunk has holes (even
      // if the chunk is marked as kChunkComplete) that need to be patched
      // out-of-band before the chunk can be read.
      kChunkNeedsPatching = 1 << 2,
    };

    struct Packets {
      // Number of valid TracePacket protobuf messages contained in the chunk.
      // Each TracePacket is prefixed by its own size. This field is
      // monotonically updated by the Producer with release store semantic when
      // the packet at position |count| is started. This last packet may not be
      // considered complete until |count| is incremented for the subsequent
      // packet or the chunk is completed.
      uint16_t count : 10;
      static constexpr size_t kMaxCount = (1 << 10) - 1;

      // See Flags above.
      uint16_t flags : 6;
    };

    // A monotonic counter of the chunk within the scoped of a |writer_id|.
    // The tuple (ProducerID, WriterID, ChunkID) allows to figure out if two
    // chunks are contiguous (and hence a trace packets spanning across them can
    // be glued) or we had some holes due to the ring buffer wrapping.
    // This is set only when transitioning from kChunkFree to kChunkBeingWritten
    // and remains unchanged throughout the remaining lifetime of the chunk.
    std::atomic<uint32_t> chunk_id;

    // ID of the writer, unique within the producer.
    // Like |chunk_id|, this is set only when transitioning from kChunkFree to
    // kChunkBeingWritten.
    std::atomic<uint16_t> writer_id;

    // There is no ProducerID here. The service figures that out from the IPC
    // channel, which is unspoofable.

    // Updated with release-store semantics.
    std::atomic<Packets> packets;
  };

  class Chunk {
   public:
    Chunk();  // Constructs an invalid chunk.

    // Chunk is move-only, to document the scope of the Acquire/Release
    // TryLock operations below.
    Chunk(const Chunk&) = delete;
    Chunk operator=(const Chunk&) = delete;
    Chunk(Chunk&&) noexcept;
    Chunk& operator=(Chunk&&);

    uint8_t* begin() const { return begin_; }
    uint8_t* end() const { return begin_ + size_; }

    // Size, including Chunk header.
    size_t size() const { return size_; }

    // Begin of the first packet (or packet fragment).
    uint8_t* payload_begin() const { return begin_ + sizeof(ChunkHeader); }
    size_t payload_size() const {
      PERFETTO_DCHECK(size_ >= sizeof(ChunkHeader));
      return size_ - sizeof(ChunkHeader);
    }

    bool is_valid() const { return begin_ && size_; }

    // Index of the chunk within the page [0..13] (13 comes from kPageDiv14).
    uint8_t chunk_idx() const { return chunk_idx_; }

    ChunkHeader* header() { return reinterpret_cast<ChunkHeader*>(begin_); }

    uint16_t writer_id() {
      return header()->writer_id.load(std::memory_order_relaxed);
    }

    // Returns the count of packets and the flags with acquire-load semantics.
    std::pair<uint16_t, uint8_t> GetPacketCountAndFlags() {
      auto packets = header()->packets.load(std::memory_order_acquire);
      const uint16_t packets_count = packets.count;
      const uint8_t packets_flags = packets.flags;
      return std::make_pair(packets_count, packets_flags);
    }

    // Increases |packets.count| with release semantics (note, however, that the
    // packet count is incremented *before* starting writing a packet). Returns
    // the new packet count. The increment is atomic but NOT race-free (i.e. no
    // CAS). Only the Producer is supposed to perform this increment, and it's
    // supposed to do that in a thread-safe way (holding a lock). A Chunk cannot
    // be shared by multiple Producer threads without locking. The packet count
    // is cleared by TryAcquireChunk(), when passing the new header for the
    // chunk.
    uint16_t IncrementPacketCount() {
      ChunkHeader* chunk_header = header();
      auto packets = chunk_header->packets.load(std::memory_order_relaxed);
      packets.count++;
      chunk_header->packets.store(packets, std::memory_order_release);
      return packets.count;
    }

    // Increases |packets.count| to the given |packet_count|, but only if
    // |packet_count| is larger than the current value of |packets.count|.
    // Returns the new packet count. Same atomicity guarantees as
    // IncrementPacketCount().
    uint16_t IncreasePacketCountTo(uint16_t packet_count) {
      ChunkHeader* chunk_header = header();
      auto packets = chunk_header->packets.load(std::memory_order_relaxed);
      if (packets.count < packet_count)
        packets.count = packet_count;
      chunk_header->packets.store(packets, std::memory_order_release);
      return packets.count;
    }

    // Flags are cleared by TryAcquireChunk(), by passing the new header for
    // the chunk.
    void SetFlag(ChunkHeader::Flags flag) {
      ChunkHeader* chunk_header = header();
      auto packets = chunk_header->packets.load(std::memory_order_relaxed);
      packets.flags |= flag;
      chunk_header->packets.store(packets, std::memory_order_release);
    }

   private:
    friend class SharedMemoryABI;
    Chunk(uint8_t* begin, uint16_t size, uint8_t chunk_idx);

    // Don't add extra fields, keep the move operator fast.
    uint8_t* begin_ = nullptr;
    uint16_t size_ = 0;
    uint8_t chunk_idx_ = 0;
  };

  // Construct an instance from an existing shared memory buffer.
  SharedMemoryABI(uint8_t* start, size_t size, size_t page_size);
  SharedMemoryABI();

  void Initialize(uint8_t* start, size_t size, size_t page_size);

  uint8_t* start() const { return start_; }
  uint8_t* end() const { return start_ + size_; }
  size_t size() const { return size_; }
  size_t page_size() const { return page_size_; }
  size_t num_pages() const { return num_pages_; }
  bool is_valid() { return num_pages() > 0; }

  uint8_t* page_start(size_t page_idx) {
    PERFETTO_DCHECK(page_idx < num_pages_);
    return start_ + page_size_ * page_idx;
  }

  PageHeader* page_header(size_t page_idx) {
    return reinterpret_cast<PageHeader*>(page_start(page_idx));
  }

  // Returns true if the page is fully clear and has not been partitioned yet.
  // The state of the page can change at any point after this returns (or even
  // before). The Producer should use this only as a hint to decide out whether
  // it should TryPartitionPage() or acquire an individual chunk.
  bool is_page_free(size_t page_idx) {
    return page_header(page_idx)->layout.load(std::memory_order_relaxed) == 0;
  }

  // Returns true if all chunks in the page are kChunkComplete. As above, this
  // is advisory only. The Service is supposed to use this only to decide
  // whether to TryAcquireAllChunksForReading() or not.
  bool is_page_complete(size_t page_idx) {
    auto layout = page_header(page_idx)->layout.load(std::memory_order_relaxed);
    const uint32_t num_chunks = GetNumChunksForLayout(layout);
    if (num_chunks == 0)
      return false;  // Non partitioned pages cannot be complete.
    return (layout & kAllChunksMask) ==
           (kAllChunksComplete & ((1 << (num_chunks * kChunkShift)) - 1));
  }

  // For testing / debugging only.
  std::string page_header_dbg(size_t page_idx) {
    uint32_t x = page_header(page_idx)->layout.load(std::memory_order_relaxed);
    return std::bitset<32>(x).to_string();
  }

  // Returns the page layout, which is a bitmap that specifies the chunking
  // layout of the page and each chunk's current state. Reads with an
  // acquire-load semantic to ensure a producer's writes corresponding to an
  // update of the layout (e.g. clearing a chunk's header) are observed
  // consistently.
  uint32_t GetPageLayout(size_t page_idx) {
    return page_header(page_idx)->layout.load(std::memory_order_acquire);
  }

  // Returns a bitmap in which each bit is set if the corresponding Chunk exists
  // in the page (according to the page layout) and is free. If the page is not
  // partitioned it returns 0 (as if the page had no free chunks).
  uint32_t GetFreeChunks(size_t page_idx);

  // Tries to atomically partition a page with the given |layout|. Returns true
  // if the page was free and has been partitioned with the given |layout|,
  // false if the page wasn't free anymore by the time we got there.
  // If succeeds all the chunks are atomically set in the kChunkFree state.
  bool TryPartitionPage(size_t page_idx, PageLayout layout);

  // Tries to atomically mark a single chunk within the page as
  // kChunkBeingWritten. Returns an invalid chunk if the page is not partitioned
  // or the chunk is not in the kChunkFree state. If succeeds sets the chunk
  // header to |header|.
  Chunk TryAcquireChunkForWriting(size_t page_idx,
                                  size_t chunk_idx,
                                  const ChunkHeader* header) {
    return TryAcquireChunk(page_idx, chunk_idx, kChunkBeingWritten, header);
  }

  // Similar to TryAcquireChunkForWriting. Fails if the chunk isn't in the
  // kChunkComplete state.
  Chunk TryAcquireChunkForReading(size_t page_idx, size_t chunk_idx) {
    return TryAcquireChunk(page_idx, chunk_idx, kChunkBeingRead, nullptr);
  }

  // The caller must have successfully TryAcquireAllChunksForReading().
  Chunk GetChunkUnchecked(size_t page_idx,
                          uint32_t page_layout,
                          size_t chunk_idx);

  // Puts a chunk into the kChunkComplete state. Returns the page index.
  size_t ReleaseChunkAsComplete(Chunk chunk) {
    return ReleaseChunk(std::move(chunk), kChunkComplete);
  }

  // Puts a chunk into the kChunkFree state. Returns the page index.
  size_t ReleaseChunkAsFree(Chunk chunk) {
    return ReleaseChunk(std::move(chunk), kChunkFree);
  }

  ChunkState GetChunkState(size_t page_idx, size_t chunk_idx) {
    PageHeader* phdr = page_header(page_idx);
    uint32_t layout = phdr->layout.load(std::memory_order_relaxed);
    return GetChunkStateFromLayout(layout, chunk_idx);
  }

  std::pair<size_t, size_t> GetPageAndChunkIndex(const Chunk& chunk);

  uint16_t GetChunkSizeForLayout(uint32_t page_layout) const {
    return chunk_sizes_[(page_layout & kLayoutMask) >> kLayoutShift];
  }

  static ChunkState GetChunkStateFromLayout(uint32_t page_layout,
                                            size_t chunk_idx) {
    return static_cast<ChunkState>((page_layout >> (chunk_idx * kChunkShift)) &
                                   kChunkMask);
  }

  static constexpr uint32_t GetNumChunksForLayout(uint32_t page_layout) {
    return kNumChunksForLayout[(page_layout & kLayoutMask) >> kLayoutShift];
  }

  // Returns a bitmap in which each bit is set if the corresponding Chunk exists
  // in the page (according to the page layout) and is not free. If the page is
  // not partitioned it returns 0 (as if the page had no used chunks). Bit N
  // corresponds to Chunk N.
  static uint32_t GetUsedChunks(uint32_t page_layout) {
    const uint32_t num_chunks = GetNumChunksForLayout(page_layout);
    uint32_t res = 0;
    for (uint32_t i = 0; i < num_chunks; i++) {
      res |= ((page_layout & kChunkMask) != kChunkFree) ? (1 << i) : 0;
      page_layout >>= kChunkShift;
    }
    return res;
  }

 private:
  SharedMemoryABI(const SharedMemoryABI&) = delete;
  SharedMemoryABI& operator=(const SharedMemoryABI&) = delete;

  Chunk TryAcquireChunk(size_t page_idx,
                        size_t chunk_idx,
                        ChunkState,
                        const ChunkHeader*);
  size_t ReleaseChunk(Chunk chunk, ChunkState);

  uint8_t* start_ = nullptr;
  size_t size_ = 0;
  size_t page_size_ = 0;
  size_t num_pages_ = 0;
  std::array<uint16_t, kNumPageLayouts> chunk_sizes_;
};

}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_TRACING_CORE_SHARED_MEMORY_ABI_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS
 * IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/shared_memory_abi.h"

// gen_amalgamated expanded: #include "perfetto/base/build_config.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/time.h"

#if !PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)
#include <sys/mman.h>
#endif

// gen_amalgamated expanded: #include "perfetto/ext/base/utils.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/basic_types.h"

namespace perfetto {

namespace {

constexpr int kRetryAttempts = 64;

inline void WaitBeforeNextAttempt(int attempt) {
  if (attempt < kRetryAttempts / 2) {
    std::this_thread::yield();
  } else {
    base::SleepMicroseconds((unsigned(attempt) / 10) * 1000);
  }
}

// Returns the largest 4-bytes aligned chunk size <= |page_size| / |divider|
// for each divider in PageLayout.
constexpr size_t GetChunkSize(size_t page_size, size_t divider) {
  return ((page_size - sizeof(SharedMemoryABI::PageHeader)) / divider) & ~3UL;
}

// Initializer for the const |chunk_sizes_| array.
std::array<uint16_t, SharedMemoryABI::kNumPageLayouts> InitChunkSizes(
    size_t page_size) {
  static_assert(SharedMemoryABI::kNumPageLayouts ==
                    base::ArraySize(SharedMemoryABI::kNumChunksForLayout),
                "kNumPageLayouts out of date");
  std::array<uint16_t, SharedMemoryABI::kNumPageLayouts> res = {};
  for (size_t i = 0; i < SharedMemoryABI::kNumPageLayouts; i++) {
    size_t num_chunks = SharedMemoryABI::kNumChunksForLayout[i];
    size_t size = num_chunks == 0 ? 0 : GetChunkSize(page_size, num_chunks);
    PERFETTO_CHECK(size <= std::numeric_limits<uint16_t>::max());
    res[i] = static_cast<uint16_t>(size);
  }
  return res;
}

inline void ClearChunkHeader(SharedMemoryABI::ChunkHeader* header) {
  header->writer_id.store(0u, std::memory_order_relaxed);
  header->chunk_id.store(0u, std::memory_order_relaxed);
  header->packets.store({}, std::memory_order_release);
}

}  // namespace

// static
constexpr uint32_t SharedMemoryABI::kNumChunksForLayout[];
constexpr const char* SharedMemoryABI::kChunkStateStr[];
constexpr const size_t SharedMemoryABI::kInvalidPageIdx;
constexpr const size_t SharedMemoryABI::kMaxPageSize;

SharedMemoryABI::SharedMemoryABI() = default;

SharedMemoryABI::SharedMemoryABI(uint8_t* start,
                                 size_t size,
                                 size_t page_size) {
  Initialize(start, size, page_size);
}

void SharedMemoryABI::Initialize(uint8_t* start,
                                 size_t size,
                                 size_t page_size) {
  start_ = start;
  size_ = size;
  page_size_ = page_size;
  num_pages_ = size / page_size;
  chunk_sizes_ = InitChunkSizes(page_size);
  static_assert(sizeof(PageHeader) == 8, "PageHeader size");
  static_assert(sizeof(ChunkHeader) == 8, "ChunkHeader size");
  static_assert(sizeof(ChunkHeader::chunk_id) == sizeof(ChunkID),
                "ChunkID size");

  static_assert(sizeof(ChunkHeader::Packets) == 2, "ChunkHeader::Packets size");
  static_assert(alignof(ChunkHeader) == kChunkAlignment,
                "ChunkHeader alignment");

  // In theory std::atomic does not guarantee that the underlying type
  // consists only of the actual atomic word. Theoretically it could have
  // locks or other state. In practice most implementations just implement
  // them without extra state. The code below overlays the atomic into the
  // SMB, hence relies on this implementation detail. This should be fine
  // pragmatically (Chrome's base makes the same assumption), but let's have a
  // check for this.
  static_assert(sizeof(std::atomic<uint32_t>) == sizeof(uint32_t) &&
                    sizeof(std::atomic<uint16_t>) == sizeof(uint16_t),
                "Incompatible STL <atomic> implementation");

  // Chec that the kAllChunks(Complete,Free) are consistent with the
  // ChunkState enum values.

  // These must be zero because rely on zero-initialized memory being
  // interpreted as "free".
  static_assert(kChunkFree == 0 && kAllChunksFree == 0,
                "kChunkFree/kAllChunksFree and must be 0");

  static_assert((kAllChunksComplete & kChunkMask) == kChunkComplete,
                "kAllChunksComplete out of sync with kChunkComplete");

  // Sanity check the consistency of the kMax... constants.
  static_assert(sizeof(ChunkHeader::writer_id) == sizeof(WriterID),
                "WriterID size");
  ChunkHeader chunk_header{};
  chunk_header.chunk_id.store(static_cast<uint32_t>(-1));
  PERFETTO_CHECK(chunk_header.chunk_id.load() == kMaxChunkID);

  chunk_header.writer_id.store(static_cast<uint16_t>(-1));
  PERFETTO_CHECK(kMaxWriterID <= chunk_header.writer_id.load());

  PERFETTO_CHECK(page_size >= base::kPageSize);
  PERFETTO_CHECK(page_size <= kMaxPageSize);
  PERFETTO_CHECK(page_size % base::kPageSize == 0);
  PERFETTO_CHECK(reinterpret_cast<uintptr_t>(start) % base::kPageSize == 0);
  PERFETTO_CHECK(size % page_size == 0);
}

SharedMemoryABI::Chunk SharedMemoryABI::GetChunkUnchecked(size_t page_idx,
                                                          uint32_t page_layout,
                                                          size_t chunk_idx) {
  const size_t num_chunks = GetNumChunksForLayout(page_layout);
  PERFETTO_DCHECK(chunk_idx < num_chunks);
  // Compute the chunk virtual address and write it into |chunk|.
  const uint16_t chunk_size = GetChunkSizeForLayout(page_layout);
  size_t chunk_offset_in_page = sizeof(PageHeader) + chunk_idx * chunk_size;

  Chunk chunk(page_start(page_idx) + chunk_offset_in_page, chunk_size,
              static_cast<uint8_t>(chunk_idx));
  PERFETTO_DCHECK(chunk.end() <= end());
  return chunk;
}

SharedMemoryABI::Chunk SharedMemoryABI::TryAcquireChunk(
    size_t page_idx,
    size_t chunk_idx,
    ChunkState desired_chunk_state,
    const ChunkHeader* header) {
  PERFETTO_DCHECK(desired_chunk_state == kChunkBeingRead ||
                  desired_chunk_state == kChunkBeingWritten);
  PageHeader* phdr = page_header(page_idx);
  for (int attempt = 0; attempt < kRetryAttempts; attempt++) {
    uint32_t layout = phdr->layout.load(std::memory_order_acquire);
    const size_t num_chunks = GetNumChunksForLayout(layout);

    // The page layout has changed (or the page is free).
    if (chunk_idx >= num_chunks)
      return Chunk();

    // Verify that the chunk is still in a state that allows the transition to
    // |desired_chunk_state|. The only allowed transitions are:
    // 1. kChunkFree -> kChunkBeingWritten (Producer).
    // 2. kChunkComplete -> kChunkBeingRead (Service).
    ChunkState expected_chunk_state =
        desired_chunk_state == kChunkBeingWritten ? kChunkFree : kChunkComplete;
    auto cur_chunk_state = (layout >> (chunk_idx * kChunkShift)) & kChunkMask;
    if (cur_chunk_state != expected_chunk_state)
      return Chunk();

    uint32_t next_layout = layout;
    next_layout &= ~(kChunkMask << (chunk_idx * kChunkShift));
    next_layout |= (desired_chunk_state << (chunk_idx * kChunkShift));
    if (phdr->layout.compare_exchange_strong(layout, next_layout,
                                             std::memory_order_acq_rel)) {
      // Compute the chunk virtual address and write it into |chunk|.
      Chunk chunk = GetChunkUnchecked(page_idx, layout, chunk_idx);
      if (desired_chunk_state == kChunkBeingWritten) {
        PERFETTO_DCHECK(header);
        ChunkHeader* new_header = chunk.header();
        new_header->writer_id.store(header->writer_id,
                                    std::memory_order_relaxed);
        new_header->chunk_id.store(header->chunk_id, std::memory_order_relaxed);
        new_header->packets.store(header->packets, std::memory_order_release);
      }
      return chunk;
    }
    WaitBeforeNextAttempt(attempt);
  }
  return Chunk();  // All our attempts failed.
}

bool SharedMemoryABI::TryPartitionPage(size_t page_idx, PageLayout layout) {
  PERFETTO_DCHECK(layout >= kPageDiv1 && layout <= kPageDiv14);
  uint32_t expected_layout = 0;  // Free page.
  uint32_t next_layout = (layout << kLayoutShift) & kLayoutMask;
  PageHeader* phdr = page_header(page_idx);
  if (!phdr->layout.compare_exchange_strong(expected_layout, next_layout,
                                            std::memory_order_acq_rel)) {
    return false;
  }
  return true;
}

uint32_t SharedMemoryABI::GetFreeChunks(size_t page_idx) {
  uint32_t layout =
      page_header(page_idx)->layout.load(std::memory_order_relaxed);
  const uint32_t num_chunks = GetNumChunksForLayout(layout);
  uint32_t res = 0;
  for (uint32_t i = 0; i < num_chunks; i++) {
    res |= ((layout & kChunkMask) == kChunkFree) ? (1 << i) : 0;
    layout >>= kChunkShift;
  }
  return res;
}

size_t SharedMemoryABI::ReleaseChunk(Chunk chunk,
                                     ChunkState desired_chunk_state) {
  PERFETTO_DCHECK(desired_chunk_state == kChunkComplete ||
                  desired_chunk_state == kChunkFree);

  size_t page_idx;
  size_t chunk_idx;
  std::tie(page_idx, chunk_idx) = GetPageAndChunkIndex(chunk);

  // Reset header fields, so that the service can identify when the chunk's
  // header has been initialized by the producer.
  if (desired_chunk_state == kChunkFree)
    ClearChunkHeader(chunk.header());

  for (int attempt = 0; attempt < kRetryAttempts; attempt++) {
    PageHeader* phdr = page_header(page_idx);
    uint32_t layout = phdr->layout.load(std::memory_order_relaxed);
    const size_t page_chunk_size = GetChunkSizeForLayout(layout);

    // TODO(primiano): this should not be a CHECK, because a malicious producer
    // could crash us by putting the chunk in an invalid state. This should
    // gracefully fail. Keep a CHECK until then.
    PERFETTO_CHECK(chunk.size() == page_chunk_size);
    const uint32_t chunk_state =
        ((layout >> (chunk_idx * kChunkShift)) & kChunkMask);

    // Verify that the chunk is still in a state that allows the transition to
    // |desired_chunk_state|. The only allowed transitions are:
    // 1. kChunkBeingWritten -> kChunkComplete (Producer).
    // 2. kChunkBeingRead -> kChunkFree (Service).
    ChunkState expected_chunk_state;
    if (desired_chunk_state == kChunkComplete) {
      expected_chunk_state = kChunkBeingWritten;
    } else {
      expected_chunk_state = kChunkBeingRead;
    }

    // TODO(primiano): should not be a CHECK (same rationale of comment above).
    PERFETTO_CHECK(chunk_state == expected_chunk_state);
    uint32_t next_layout = layout;
    next_layout &= ~(kChunkMask << (chunk_idx * kChunkShift));
    next_layout |= (desired_chunk_state << (chunk_idx * kChunkShift));

    // If we are freeing a chunk and all the other chunks in the page are free
    // we should de-partition the page and mark it as clear.
    if ((next_layout & kAllChunksMask) == kAllChunksFree)
      next_layout = 0;

    if (phdr->layout.compare_exchange_strong(layout, next_layout,
                                             std::memory_order_acq_rel)) {
      return page_idx;
    }
    WaitBeforeNextAttempt(attempt);
  }
  // Too much contention on this page. Give up. This page will be left pending
  // forever but there isn't much more we can do at this point.
  PERFETTO_DFATAL("Too much contention on page.");
  return kInvalidPageIdx;
}

SharedMemoryABI::Chunk::Chunk() = default;

SharedMemoryABI::Chunk::Chunk(uint8_t* begin, uint16_t size, uint8_t chunk_idx)
    : begin_(begin), size_(size), chunk_idx_(chunk_idx) {
  PERFETTO_CHECK(reinterpret_cast<uintptr_t>(begin) % kChunkAlignment == 0);
  PERFETTO_CHECK(size > 0);
}

SharedMemoryABI::Chunk::Chunk(Chunk&& o) noexcept {
  *this = std::move(o);
}

SharedMemoryABI::Chunk& SharedMemoryABI::Chunk::operator=(Chunk&& o) {
  begin_ = o.begin_;
  size_ = o.size_;
  chunk_idx_ = o.chunk_idx_;
  o.begin_ = nullptr;
  o.size_ = 0;
  o.chunk_idx_ = 0;
  return *this;
}

std::pair<size_t, size_t> SharedMemoryABI::GetPageAndChunkIndex(
    const Chunk& chunk) {
  PERFETTO_DCHECK(chunk.is_valid());
  PERFETTO_DCHECK(chunk.begin() >= start_);
  PERFETTO_DCHECK(chunk.end() <= start_ + size_);

  // TODO(primiano): The divisions below could be avoided if we cached
  // |page_shift_|.
  const uintptr_t rel_addr = static_cast<uintptr_t>(chunk.begin() - start_);
  const size_t page_idx = rel_addr / page_size_;
  const size_t offset = rel_addr % page_size_;
  PERFETTO_DCHECK(offset >= sizeof(PageHeader));
  PERFETTO_DCHECK(offset % kChunkAlignment == 0);
  PERFETTO_DCHECK((offset - sizeof(PageHeader)) % chunk.size() == 0);
  const size_t chunk_idx = (offset - sizeof(PageHeader)) / chunk.size();
  PERFETTO_DCHECK(chunk_idx < kMaxChunksPerPage);
  PERFETTO_DCHECK(chunk_idx < GetNumChunksForLayout(GetPageLayout(page_idx)));
  return std::make_pair(page_idx, chunk_idx);
}

}  // namespace perfetto
// gen_amalgamated begin source: src/tracing/core/shared_memory_arbiter_impl.cc
// gen_amalgamated begin header: src/tracing/core/shared_memory_arbiter_impl.h
// gen_amalgamated begin header: include/perfetto/ext/tracing/core/shared_memory_arbiter.h
// gen_amalgamated begin header: include/perfetto/ext/tracing/core/tracing_service.h
// gen_amalgamated begin header: include/perfetto/ext/tracing/core/shared_memory.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_TRACING_CORE_SHARED_MEMORY_H_
#define INCLUDE_PERFETTO_EXT_TRACING_CORE_SHARED_MEMORY_H_

#include <stddef.h>

#include <memory>

// gen_amalgamated expanded: #include "perfetto/base/export.h"

namespace perfetto {

// An abstract interface that models the shared memory region shared between
// Service and Producer. The concrete implementation of this is up to the
// transport layer. This can be as simple as a malloc()-ed buffer, if both
// Producer and Service are hosted in the same process, or some posix shared
// memory for the out-of-process case (see src/unix_rpc).
// Both this class and the Factory are subclassed by the transport layer, which
// will attach platform specific fields to it (e.g., a unix file descriptor).
class PERFETTO_EXPORT SharedMemory {
 public:
  class PERFETTO_EXPORT Factory {
   public:
    virtual ~Factory();
    virtual std::unique_ptr<SharedMemory> CreateSharedMemory(size_t) = 0;
  };

  // The transport layer is expected to tear down the resource associated to
  // this object region when destroyed.
  virtual ~SharedMemory();

  virtual void* start() const = 0;
  virtual size_t size() const = 0;
};

}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_TRACING_CORE_SHARED_MEMORY_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_TRACING_CORE_TRACING_SERVICE_H_
#define INCLUDE_PERFETTO_EXT_TRACING_CORE_TRACING_SERVICE_H_

#include <stdint.h>

#include <functional>
#include <memory>
#include <vector>

// gen_amalgamated expanded: #include "perfetto/base/export.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/scoped_file.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/basic_types.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/shared_memory.h"

namespace perfetto {

namespace base {
class TaskRunner;
}  // namespace base

class CommitDataRequest;
class Consumer;
class DataSourceDescriptor;
class Producer;
class SharedMemoryArbiter;
class TracingServiceState;
class TraceConfig;
class TraceWriter;

// TODO: for the moment this assumes that all the calls happen on the same
// thread/sequence. Not sure this will be the case long term in Chrome.

// The API for the Producer port of the Service.
// Subclassed by:
// 1. The tracing_service_impl.cc business logic when returning it in response
//    to the ConnectProducer() method.
// 2. The transport layer (e.g., src/ipc) when the producer and
//    the service don't talk locally but via some IPC mechanism.
class PERFETTO_EXPORT ProducerEndpoint {
 public:
  virtual ~ProducerEndpoint();

  // Called by the Producer to (un)register data sources. Data sources are
  // identified by their name (i.e. DataSourceDescriptor.name)
  virtual void RegisterDataSource(const DataSourceDescriptor&) = 0;
  virtual void UnregisterDataSource(const std::string& name) = 0;

  // Associate the trace writer with the given |writer_id| with
  // |target_buffer|. The service may use this information to retrieve and
  // copy uncommitted chunks written by the trace writer into its associated
  // buffer, e.g. when a producer process crashes or when a flush is
  // necessary.
  virtual void RegisterTraceWriter(uint32_t writer_id,
                                   uint32_t target_buffer) = 0;

  // Remove the association of the trace writer previously created via
  // RegisterTraceWriter.
  virtual void UnregisterTraceWriter(uint32_t writer_id) = 0;

  // Called by the Producer to signal that some pages in the shared memory
  // buffer (shared between Service and Producer) have changed.
  // When the Producer and the Service are hosted in the same process and
  // hence potentially live on the same task runner, This method must call
  // TracingServiceImpl's CommitData synchronously, without any PostTask()s,
  // if on the same thread. This is to avoid a deadlock where the Producer
  // exhausts its SMB and stalls waiting for the service to catch up with
  // reads, but the Service never gets to that because it lives on the same
  // thread.
  using CommitDataCallback = std::function<void()>;
  virtual void CommitData(const CommitDataRequest&,
                          CommitDataCallback callback = {}) = 0;

  virtual SharedMemory* shared_memory() const = 0;

  // Size of shared memory buffer pages. It's always a multiple of 4K.
  // See shared_memory_abi.h
  virtual size_t shared_buffer_page_size_kb() const = 0;

  // Creates a trace writer, which allows to create events, handling the
  // underying shared memory buffer and signalling to the Service. This method
  // is thread-safe but the returned object is not. A TraceWriter should be
  // used only from a single thread, or the caller has to handle sequencing
  // via a mutex or equivalent. This method can only be called if
  // TracingService::ConnectProducer was called with |in_process=true|.
  // Args:
  // |target_buffer| is the target buffer ID where the data produced by the
  // writer should be stored by the tracing service. This value is passed
  // upon creation of the data source (StartDataSource()) in the
  // DataSourceConfig.target_buffer().
  virtual std::unique_ptr<TraceWriter> CreateTraceWriter(
      BufferID target_buffer) = 0;

  // If TracingService::ConnectProducer is called with |in_process=true|,
  // this returns the producer's SharedMemoryArbiter which can be used
  // to create TraceWriters which is able to directly commit chunks
  // without going through an IPC layer.
  virtual SharedMemoryArbiter* GetInProcessShmemArbiter() = 0;

  // Called in response to a Producer::Flush(request_id) call after all data
  // for the flush request has been committed.
  virtual void NotifyFlushComplete(FlushRequestID) = 0;

  // Called in response to one or more Producer::StartDataSource(),
  // if the data source registered setting the flag
  // DataSourceDescriptor.will_notify_on_start.
  virtual void NotifyDataSourceStarted(DataSourceInstanceID) = 0;

  // Called in response to one or more Producer::StopDataSource(),
  // if the data source registered setting the flag
  // DataSourceDescriptor.will_notify_on_stop.
  virtual void NotifyDataSourceStopped(DataSourceInstanceID) = 0;

  // This informs the service to activate any of these triggers if any tracing
  // session was waiting for them.
  virtual void ActivateTriggers(const std::vector<std::string>&) = 0;
};  // class ProducerEndpoint.

// The API for the Consumer port of the Service.
// Subclassed by:
// 1. The tracing_service_impl.cc business logic when returning it in response
// to
//    the ConnectConsumer() method.
// 2. The transport layer (e.g., src/ipc) when the consumer and
//    the service don't talk locally but via some IPC mechanism.
class ConsumerEndpoint {
 public:
  virtual ~ConsumerEndpoint();

  // Enables tracing with the given TraceConfig. The ScopedFile argument is
  // used only when TraceConfig.write_into_file == true.
  // If TraceConfig.deferred_start == true data sources are configured via
  // SetupDataSource() but are not started until StartTracing() is called.
  // This is to support pre-initialization and fast triggering of traces.
  // The ScopedFile argument is used only when TraceConfig.write_into_file
  // == true.
  virtual void EnableTracing(const TraceConfig&,
                             base::ScopedFile = base::ScopedFile()) = 0;

  // Update the trace config of an existing tracing session; only a subset
  // of options can be changed mid-session. Currently the only
  // supported functionality is expanding the list of producer_name_filters()
  // (or removing the filter entirely) for existing data sources.
  virtual void ChangeTraceConfig(const TraceConfig&) = 0;

  // Starts all data sources configured in the trace config. This is used only
  // after calling EnableTracing() with TraceConfig.deferred_start=true.
  // It's a no-op if called after a regular EnableTracing(), without setting
  // deferred_start.
  virtual void StartTracing() = 0;

  virtual void DisableTracing() = 0;

  // Requests all data sources to flush their data immediately and invokes the
  // passed callback once all of them have acked the flush (in which case
  // the callback argument |success| will be true) or |timeout_ms| are elapsed
  // (in which case |success| will be false).
  // If |timeout_ms| is 0 the TraceConfig's flush_timeout_ms is used, or,
  // if that one is not set (or is set to 0), kDefaultFlushTimeoutMs (5s) is
  // used.
  using FlushCallback = std::function<void(bool /*success*/)>;
  virtual void Flush(uint32_t timeout_ms, FlushCallback) = 0;

  // Tracing data will be delivered invoking Consumer::OnTraceData().
  virtual void ReadBuffers() = 0;

  virtual void FreeBuffers() = 0;

  // Will call OnDetach().
  virtual void Detach(const std::string& key) = 0;

  // Will call OnAttach().
  virtual void Attach(const std::string& key) = 0;

  // Will call OnTraceStats().
  virtual void GetTraceStats() = 0;

  enum ObservableEventType : uint32_t {
    kNone = 0,
    kDataSourceInstances = 1 << 0
  };

  // Start or stop observing events of selected types. |enabled_event_types|
  // specifies the types of events to observe in a bitmask (see
  // ObservableEventType enum). To disable observing, pass
  // ObservableEventType::kNone. Will call OnObservableEvents() repeatedly
  // whenever an event of an enabled ObservableEventType occurs.
  //
  // TODO(eseckler): Extend this to support producers & data sources.
  virtual void ObserveEvents(uint32_t enabled_event_types) = 0;

  // Used to obtain the list of connected data sources and other info about
  // the tracing service.
  using QueryServiceStateCallback =
      std::function<void(bool success, const TracingServiceState&)>;
  virtual void QueryServiceState(QueryServiceStateCallback) = 0;
};  // class ConsumerEndpoint.

// The public API of the tracing Service business logic.
//
// Exposed to:
// 1. The transport layer (e.g., src/unix_rpc/unix_service_host.cc),
//    which forwards commands received from a remote producer or consumer to
//    the actual service implementation.
// 2. Tests.
//
// Subclassed by:
//   The service business logic in src/core/tracing_service_impl.cc.
class PERFETTO_EXPORT TracingService {
 public:
  using ProducerEndpoint = perfetto::ProducerEndpoint;
  using ConsumerEndpoint = perfetto::ConsumerEndpoint;

  enum class ProducerSMBScrapingMode {
    // Use service's default setting for SMB scraping. Currently, the default
    // mode is to disable SMB scraping, but this may change in the future.
    kDefault,

    // Enable scraping of uncommitted chunks in producers' shared memory
    // buffers.
    kEnabled,

    // Disable scraping of uncommitted chunks in producers' shared memory
    // buffers.
    kDisabled
  };

  // Implemented in src/core/tracing_service_impl.cc .
  static std::unique_ptr<TracingService> CreateInstance(
      std::unique_ptr<SharedMemory::Factory>,
      base::TaskRunner*);

  virtual ~TracingService();

  // Connects a Producer instance and obtains a ProducerEndpoint, which is
  // essentially a 1:1 channel between one Producer and the Service.
  // The caller has to guarantee that the passed Producer will be alive as long
  // as the returned ProducerEndpoint is alive.
  // Both the passed Prodcer and the returned ProducerEndpint must live on the
  // same task runner of the service, specifically:
  // 1) The Service will call Producer::* methods on the Service's task runner.
  // 2) The Producer should call ProducerEndpoint::* methods only on the
  //    service's task runner, except for ProducerEndpoint::CreateTraceWriter(),
  //    which can be called on any thread.
  // To disconnect just destroy the returned ProducerEndpoint object. It is safe
  // to destroy the Producer once the Producer::OnDisconnect() has been invoked.
  // |uid| is the trusted user id of the producer process, used by the consumers
  // for validating the origin of trace data.
  // |shared_memory_size_hint_bytes| is an optional hint on the size of the
  // shared memory buffer. The service can ignore the hint (e.g., if the hint
  // is unreasonably large).
  // |in_process| enables the ProducerEndpoint to manage its own shared memory
  // and enables use of |ProducerEndpoint::CreateTraceWriter|.
  // Can return null in the unlikely event that service has too many producers
  // connected.
  virtual std::unique_ptr<ProducerEndpoint> ConnectProducer(
      Producer*,
      uid_t uid,
      const std::string& name,
      size_t shared_memory_size_hint_bytes = 0,
      bool in_process = false,
      ProducerSMBScrapingMode smb_scraping_mode =
          ProducerSMBScrapingMode::kDefault) = 0;

  // Connects a Consumer instance and obtains a ConsumerEndpoint, which is
  // essentially a 1:1 channel between one Consumer and the Service.
  // The caller has to guarantee that the passed Consumer will be alive as long
  // as the returned ConsumerEndpoint is alive.
  // To disconnect just destroy the returned ConsumerEndpoint object. It is safe
  // to destroy the Consumer once the Consumer::OnDisconnect() has been invoked.
  virtual std::unique_ptr<ConsumerEndpoint> ConnectConsumer(Consumer*,
                                                            uid_t) = 0;

  // Enable/disable scraping of chunks in the shared memory buffer. If enabled,
  // the service will copy uncommitted but non-empty chunks from the SMB when
  // flushing (e.g. to handle unresponsive producers or producers unable to
  // flush their active chunks), on producer disconnect (e.g. to recover data
  // from crashed producers), and after disabling a tracing session (e.g. to
  // gather data from producers that didn't stop their data sources in time).
  //
  // This feature is currently used by Chrome.
  virtual void SetSMBScrapingEnabled(bool enabled) = 0;
};

}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_TRACING_CORE_TRACING_SERVICE_H_
/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_TRACING_CORE_SHARED_MEMORY_ARBITER_H_
#define INCLUDE_PERFETTO_EXT_TRACING_CORE_SHARED_MEMORY_ARBITER_H_

#include <stddef.h>

#include <functional>
#include <memory>
#include <vector>

// gen_amalgamated expanded: #include "perfetto/base/export.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/basic_types.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/tracing_service.h"

namespace perfetto {

namespace base {
class TaskRunner;
}

class CommitDataRequest;
class StartupTraceWriter;
class StartupTraceWriterRegistry;
class SharedMemory;
class TraceWriter;

// Used by the Producer-side of the transport layer to vend TraceWriters
// from the SharedMemory it receives from the Service-side.
class PERFETTO_EXPORT SharedMemoryArbiter {
 public:
  virtual ~SharedMemoryArbiter();

  // Creates a new TraceWriter and assigns it a new WriterID. The WriterID is
  // written in each chunk header owned by a given TraceWriter and is used by
  // the Service to reconstruct TracePackets written by the same TraceWriter.
  // Returns null impl of TraceWriter if all WriterID slots are exhausted.
  virtual std::unique_ptr<TraceWriter> CreateTraceWriter(
      BufferID target_buffer) = 0;

  // Binds the provided unbound StartupTraceWriterRegistry to the arbiter's SMB.
  // Normally this happens when the perfetto service has been initialized and we
  // want to rebind all the writers created in the early startup phase.
  //
  // All StartupTraceWriters created by the registry are bound to the arbiter
  // and the given target buffer. The writers may not be bound immediately if
  // they are concurrently being written to or if this method isn't called on
  // the arbiter's TaskRunner. The registry will retry on the arbiter's
  // TaskRunner until all writers were bound successfully.
  //
  // By calling this method, the registry's ownership is transferred to the
  // arbiter. The arbiter will delete the registry once all writers were bound.
  //
  // TODO(eseckler): Make target buffer assignment more flexible (i.e. per
  // writer). For now, embedders can use multiple registries instead.
  virtual void BindStartupTraceWriterRegistry(
      std::unique_ptr<StartupTraceWriterRegistry>,
      BufferID target_buffer) = 0;

  // Notifies the service that all data for the given FlushRequestID has been
  // committed in the shared memory buffer.
  virtual void NotifyFlushComplete(FlushRequestID) = 0;

  // Implemented in src/core/shared_memory_arbiter_impl.cc .
  static std::unique_ptr<SharedMemoryArbiter> CreateInstance(
      SharedMemory*,
      size_t page_size,
      TracingService::ProducerEndpoint*,
      base::TaskRunner*);
};

}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_TRACING_CORE_SHARED_MEMORY_ARBITER_H_
// gen_amalgamated begin header: include/perfetto/ext/tracing/core/startup_trace_writer_registry.h
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_TRACING_CORE_STARTUP_TRACE_WRITER_REGISTRY_H_
#define INCLUDE_PERFETTO_EXT_TRACING_CORE_STARTUP_TRACE_WRITER_REGISTRY_H_

#include <functional>
#include <memory>
#include <mutex>
#include <set>
#include <vector>

// gen_amalgamated expanded: #include "perfetto/base/export.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/weak_ptr.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/basic_types.h"

namespace perfetto {

class SharedMemoryArbiterImpl;
class StartupTraceWriter;
class StartupTraceWriterRegistry;

namespace base {
class TaskRunner;
}  // namespace base

// Used to return a StartupTraceWriter back to its registry when the writer's
// thread is destroyed, provided the registry itself wasn't deleted yet. The
// indirection via the handle is necessary to avoid potential deadlocks caused
// by lock order inversion. These issues are avoided by locking on the handle's
// common lock.
class StartupTraceWriterRegistryHandle {
 public:
  explicit StartupTraceWriterRegistryHandle(StartupTraceWriterRegistry*);

  // Called by StartupTraceWriterRegistry destructor.
  void OnRegistryDestroyed();

  // Called by StartupTraceWriter::ReturnToRegistry.
  void ReturnWriterToRegistry(std::unique_ptr<StartupTraceWriter> writer);

 private:
  StartupTraceWriterRegistryHandle(const StartupTraceWriterRegistryHandle&) =
      delete;
  StartupTraceWriterRegistryHandle& operator=(
      const StartupTraceWriterRegistryHandle&) = delete;

  std::mutex lock_;
  StartupTraceWriterRegistry* registry_;
};

// Embedders can use this registry to create unbound StartupTraceWriters during
// startup, and later bind them all safely to an arbiter and target buffer.
class PERFETTO_EXPORT StartupTraceWriterRegistry {
 public:
  StartupTraceWriterRegistry();
  ~StartupTraceWriterRegistry();

  // Returns a new unbound StartupTraceWriter. Should only be called while
  // unbound. Usually called on a writer thread. The writer should never be
  // destroyed by the caller directly, but instead returned to the registry by
  // calling StartupTraceWriter::ReturnToRegistry.
  std::unique_ptr<StartupTraceWriter> CreateUnboundTraceWriter();

  // Binds all StartupTraceWriters created by this registry to the given arbiter
  // and target buffer. Should only be called once and on the passed
  // TaskRunner's sequence. See
  // SharedMemoryArbiter::BindStartupTraceWriterRegistry() for details.
  //
  // Note that the writers may not be bound synchronously if they are
  // concurrently being written to. The registry will retry on the passed
  // TaskRunner until all writers were bound successfully.
  //
  // Calls |on_bound_callback| asynchronously on the passed TaskRunner once all
  // writers were bound.
  void BindToArbiter(
      SharedMemoryArbiterImpl*,
      BufferID target_buffer,
      base::TaskRunner*,
      std::function<void(StartupTraceWriterRegistry*)> on_bound_callback);

 private:
  friend class StartupTraceWriterRegistryHandle;
  friend class StartupTraceWriterTest;

  StartupTraceWriterRegistry(const StartupTraceWriterRegistry&) = delete;
  StartupTraceWriterRegistry& operator=(const StartupTraceWriterRegistry&) =
      delete;

  // Try to bind the remaining unbound writers and post a continuation to
  // |task_runner_| if any writers could not be bound.
  void TryBindWriters();

  // Notifies the arbiter when we have bound all writers. May delete |this|.
  void OnUnboundWritersRemovedLocked();

  // Return a StartupTraceWriter back to the registry, see
  // StartupTraceWriter::ReturnToRegistry.
  void ReturnTraceWriter(std::unique_ptr<StartupTraceWriter>);

  std::shared_ptr<StartupTraceWriterRegistryHandle> handle_;

  // Begin lock-protected members.
  std::mutex lock_;

  // Unbound writers that we handed out to writer threads. These writers may be
  // concurrently written to by the writer threads.
  std::set<StartupTraceWriter*> unbound_writers_;

  // Unbound writers that writer threads returned to the registry by calling
  // ReturnUnboundTraceWriter(). Writers are removed from |unbound_writers_|
  // when they are added to |unbound_owned_writers_|. No new data can be written
  // to these writers.
  std::vector<std::unique_ptr<StartupTraceWriter>> unbound_owned_writers_;

  SharedMemoryArbiterImpl* arbiter_ = nullptr;  // |nullptr| while unbound.
  BufferID target_buffer_ = 0;
  base::TaskRunner* task_runner_;
  std::function<void(StartupTraceWriterRegistry*)> on_bound_callback_ = nullptr;

  // Keep at the end. Initialized during |BindToArbiter()|, like |task_runner_|.
  // Weak pointers are only valid on |task_runner_|'s thread/sequence.
  std::unique_ptr<base::WeakPtrFactory<StartupTraceWriterRegistry>>
      weak_ptr_factory_;
  // End lock-protected members.
};

}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_TRACING_CORE_STARTUP_TRACE_WRITER_REGISTRY_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef SRC_TRACING_CORE_SHARED_MEMORY_ARBITER_IMPL_H_
#define SRC_TRACING_CORE_SHARED_MEMORY_ARBITER_IMPL_H_

#include <stdint.h>

#include <functional>
#include <memory>
#include <mutex>
#include <vector>

// gen_amalgamated expanded: #include "perfetto/ext/base/weak_ptr.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/basic_types.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/shared_memory_abi.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/shared_memory_arbiter.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/startup_trace_writer_registry.h"
// gen_amalgamated expanded: #include "src/tracing/core/id_allocator.h"

namespace perfetto {

class CommitDataRequest;
class PatchList;
class TraceWriter;
class TraceWriterImpl;

namespace base {
class TaskRunner;
}  // namespace base

// This class handles the shared memory buffer on the producer side. It is used
// to obtain thread-local chunks and to partition pages from several threads.
// There is one arbiter instance per Producer.
// This class is thread-safe and uses locks to do so. Data sources are supposed
// to interact with this sporadically, only when they run out of space on their
// current thread-local chunk.
class SharedMemoryArbiterImpl : public SharedMemoryArbiter {
 public:
  // Args:
  // |start|,|size|: boundaries of the shared memory buffer.
  // |page_size|: a multiple of 4KB that defines the granularity of tracing
  // pages. See tradeoff considerations in shared_memory_abi.h.
  // |OnPagesCompleteCallback|: a callback that will be posted on the passed
  // |TaskRunner| when one or more pages are complete (and hence the Producer
  // should send a CommitData request to the Service).
  // |TaskRunner|: Task runner for perfetto's main thread, which executes the
  // OnPagesCompleteCallback and IPC calls to the |ProducerEndpoint|.
  SharedMemoryArbiterImpl(void* start,
                          size_t size,
                          size_t page_size,
                          TracingService::ProducerEndpoint*,
                          base::TaskRunner*);

  // Returns a new Chunk to write tracing data. The call always returns a valid
  // Chunk. TODO(primiano): right now this blocks if there are no free chunks
  // in the SMB. In the long term the caller should be allowed to pick a policy
  // and handle the retry itself asynchronously.
  SharedMemoryABI::Chunk GetNewChunk(const SharedMemoryABI::ChunkHeader&,
                                     size_t size_hint = 0);

  // Puts back a Chunk that has been completed and sends a request to the
  // service to move it to the central tracing buffer. |target_buffer| is the
  // absolute trace buffer ID where the service should move the chunk onto (the
  // producer is just to copy back the same number received in the
  // DataSourceConfig upon the StartDataSource() reques).
  // PatchList is a pointer to the list of patches for previous chunks. The
  // first patched entries will be removed from the patched list and sent over
  // to the service in the same CommitData() IPC request.
  void ReturnCompletedChunk(SharedMemoryABI::Chunk,
                            BufferID target_buffer,
                            PatchList*);

  // Send a request to the service to apply completed patches from |patch_list|.
  // |writer_id| is the ID of the TraceWriter that calls this method,
  // |target_buffer| is the global trace buffer ID of its target buffer.
  void SendPatches(WriterID writer_id,
                   BufferID target_buffer,
                   PatchList* patch_list);

  // Forces a synchronous commit of the completed packets without waiting for
  // the next task.
  void FlushPendingCommitDataRequests(std::function<void()> callback = {});

  SharedMemoryABI* shmem_abi_for_testing() { return &shmem_abi_; }

  static void set_default_layout_for_testing(SharedMemoryABI::PageLayout l) {
    default_page_layout = l;
  }

  // SharedMemoryArbiter implementation.
  // See include/perfetto/tracing/core/shared_memory_arbiter.h for comments.
  std::unique_ptr<TraceWriter> CreateTraceWriter(
      BufferID target_buffer) override;
  void BindStartupTraceWriterRegistry(
      std::unique_ptr<StartupTraceWriterRegistry>,
      BufferID target_buffer) override;

  void NotifyFlushComplete(FlushRequestID) override;

 private:
  friend class TraceWriterImpl;
  friend class StartupTraceWriterTest;

  static SharedMemoryABI::PageLayout default_page_layout;

  SharedMemoryArbiterImpl(const SharedMemoryArbiterImpl&) = delete;
  SharedMemoryArbiterImpl& operator=(const SharedMemoryArbiterImpl&) = delete;

  void UpdateCommitDataRequest(SharedMemoryABI::Chunk chunk,
                               WriterID writer_id,
                               BufferID target_buffer,
                               PatchList* patch_list);

  // Called by the TraceWriter destructor.
  void ReleaseWriterID(WriterID);

  base::TaskRunner* const task_runner_;
  TracingService::ProducerEndpoint* const producer_endpoint_;

  // --- Begin lock-protected members ---
  std::mutex lock_;
  SharedMemoryABI shmem_abi_;
  size_t page_idx_ = 0;
  std::unique_ptr<CommitDataRequest> commit_data_req_;
  size_t bytes_pending_commit_ = 0;  // SUM(chunk.size() : commit_data_req_).
  IdAllocator<WriterID> active_writer_ids_;
  // Registries whose Bind() is in progress. We destroy each registry when their
  // Bind() is complete or when the arbiter is destroyed itself.
  std::vector<std::unique_ptr<StartupTraceWriterRegistry>>
      startup_trace_writer_registries_;
  // --- End lock-protected members ---

  // Keep at the end.
  base::WeakPtrFactory<SharedMemoryArbiterImpl> weak_ptr_factory_;
};

}  // namespace perfetto

#endif  // SRC_TRACING_CORE_SHARED_MEMORY_ARBITER_IMPL_H_
// gen_amalgamated begin header: src/tracing/core/trace_writer_impl.h
// gen_amalgamated begin header: src/tracing/core/patch_list.h
/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef SRC_TRACING_CORE_PATCH_LIST_H_
#define SRC_TRACING_CORE_PATCH_LIST_H_

#include <array>
#include <forward_list>

// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/basic_types.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/shared_memory_abi.h"

namespace perfetto {

// Used to handle the backfilling of the headers (the |size_field|) of nested
// messages when a proto is fragmented over several chunks. These patches are
// sent out-of-band to the tracing service, after having returned the initial
// chunks of the fragment.
// TODO(crbug.com/904477): Re-disable the move constructors when all usses of
// this class have been fixed.
class Patch {
 public:
  using PatchContent = std::array<uint8_t, SharedMemoryABI::kPacketHeaderSize>;
  Patch(ChunkID c, uint16_t o) : chunk_id(c), offset(o) {}
  Patch(const Patch&) = default;  // For tests.

  const ChunkID chunk_id;
  const uint16_t offset;
  PatchContent size_field{};

  // |size_field| contains a varint. Any varint must start with != 0. Even in
  // the case we want to encode a size == 0, protozero will write a redundant
  // varint for that, that is [0x80, 0x80, 0x80, 0x00]. So the first byte is 0
  // iff we never wrote any varint into that.
  bool is_patched() const { return size_field[0] != 0; }

  // For tests.
  bool operator==(const Patch& o) const {
    return chunk_id == o.chunk_id && offset == o.offset &&
           size_field == o.size_field;
  }

 private:
  Patch& operator=(const Patch&) = delete;
};

// Note: the protozero::Message(s) will take pointers to the |size_field| of
// these entries. This container must guarantee that the Patch objects are never
// moved around (i.e. cannot be a vector because of reallocations can change
// addresses of pre-existing entries).
class PatchList {
 public:
  using ListType = std::forward_list<Patch>;
  using value_type = ListType::value_type;          // For gtest.
  using const_iterator = ListType::const_iterator;  // For gtest.

  PatchList() : last_(list_.before_begin()) {}

  Patch* emplace_back(ChunkID chunk_id, uint16_t offset) {
    PERFETTO_DCHECK(empty() || last_->chunk_id != chunk_id ||
                    offset >= last_->offset + sizeof(Patch::PatchContent));
    last_ = list_.emplace_after(last_, chunk_id, offset);
    return &*last_;
  }

  void pop_front() {
    PERFETTO_DCHECK(!list_.empty());
    list_.pop_front();
    if (empty())
      last_ = list_.before_begin();
  }

  const Patch& front() const {
    PERFETTO_DCHECK(!list_.empty());
    return list_.front();
  }

  const Patch& back() const {
    PERFETTO_DCHECK(!list_.empty());
    return *last_;
  }

  ListType::const_iterator begin() const { return list_.begin(); }
  ListType::const_iterator end() const { return list_.end(); }
  bool empty() const { return list_.empty(); }

 private:
  ListType list_;
  ListType::iterator last_;
};

}  // namespace perfetto

#endif  // SRC_TRACING_CORE_PATCH_LIST_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef SRC_TRACING_CORE_TRACE_WRITER_IMPL_H_
#define SRC_TRACING_CORE_TRACE_WRITER_IMPL_H_

// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/basic_types.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/shared_memory_abi.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/trace_writer.h"
// gen_amalgamated expanded: #include "perfetto/protozero/message_handle.h"
// gen_amalgamated expanded: #include "perfetto/protozero/scattered_stream_writer.h"
// gen_amalgamated expanded: #include "src/tracing/core/patch_list.h"

namespace perfetto {

class SharedMemoryArbiterImpl;

// See //include/perfetto/tracing/core/trace_writer.h for docs.
class TraceWriterImpl : public TraceWriter,
                        public protozero::ScatteredStreamWriter::Delegate {
 public:
  // TracePacketHandle is defined in trace_writer.h
  TraceWriterImpl(SharedMemoryArbiterImpl*, WriterID, BufferID);
  ~TraceWriterImpl() override;

  // TraceWriter implementation. See documentation in trace_writer.h.
  TracePacketHandle NewTracePacket() override;
  void Flush(std::function<void()> callback = {}) override;
  WriterID writer_id() const override;
  bool SetFirstChunkId(ChunkID) override;
  uint64_t written() const override {
    return protobuf_stream_writer_.written();
  }

  void ResetChunkForTesting() { cur_chunk_ = SharedMemoryABI::Chunk(); }

 private:
  TraceWriterImpl(const TraceWriterImpl&) = delete;
  TraceWriterImpl& operator=(const TraceWriterImpl&) = delete;

  // ScatteredStreamWriter::Delegate implementation.
  protozero::ContiguousMemoryRange GetNewBuffer() override;

  // The per-producer arbiter that coordinates access to the shared memory
  // buffer from several threads.
  SharedMemoryArbiterImpl* const shmem_arbiter_;

  // ID of the current writer.
  const WriterID id_;

  // This is just copied back into the chunk header.
  // See comments in data_source_config.proto for |target_buffer|.
  const BufferID target_buffer_;

  // Monotonic (% wrapping) sequence id of the chunk. Together with the WriterID
  // this allows the Service to reconstruct the linear sequence of packets.
  ChunkID next_chunk_id_ = 0;

  // The chunk we are holding onto (if any).
  SharedMemoryABI::Chunk cur_chunk_;

  // Passed to protozero message to write directly into |cur_chunk_|. It
  // keeps track of the write pointer. It calls us back (GetNewBuffer()) when
  // |cur_chunk_| is filled.
  protozero::ScatteredStreamWriter protobuf_stream_writer_;

  // The packet returned via NewTracePacket(). Its owned by this class,
  // TracePacketHandle has just a pointer to it.
  std::unique_ptr<protos::pbzero::TracePacket> cur_packet_;

  // The start address of |cur_packet_| within |cur_chunk_|. Used to figure out
  // fragments sizes when a TracePacket write is interrupted by GetNewBuffer().
  uint8_t* cur_fragment_start_ = nullptr;

  // true if we received a call to GetNewBuffer() after NewTracePacket(),
  // false if GetNewBuffer() happened during NewTracePacket() prologue, while
  // starting the TracePacket header.
  bool fragmenting_packet_ = false;

  // Set to |true| when the current chunk contains the maximum number of packets
  // a chunk can contain. When this is |true|, the next packet requires starting
  // a new chunk.
  bool reached_max_packets_per_chunk_ = false;

  // When a packet is fragmented across different chunks, the |size_field| of
  // the outstanding nested protobuf messages is redirected onto Patch entries
  // in this list at the time the Chunk is returned (because at that point we
  // have to release the ownership of the current Chunk). This list will be
  // later sent out-of-band to the tracing service, who will patch the required
  // chunks, if they are still around.
  PatchList patch_list_;
};

}  // namespace perfetto

#endif  // SRC_TRACING_CORE_TRACE_WRITER_IMPL_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "src/tracing/core/shared_memory_arbiter_impl.h"

// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/base/task_runner.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/time.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/commit_data_request.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/shared_memory.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/startup_trace_writer_registry.h"
// gen_amalgamated expanded: #include "src/tracing/core/null_trace_writer.h"
// gen_amalgamated expanded: #include "src/tracing/core/trace_writer_impl.h"

#include <limits>
#include <utility>

namespace perfetto {

using Chunk = SharedMemoryABI::Chunk;

// static
SharedMemoryABI::PageLayout SharedMemoryArbiterImpl::default_page_layout =
    SharedMemoryABI::PageLayout::kPageDiv1;

// static
std::unique_ptr<SharedMemoryArbiter> SharedMemoryArbiter::CreateInstance(
    SharedMemory* shared_memory,
    size_t page_size,
    TracingService::ProducerEndpoint* producer_endpoint,
    base::TaskRunner* task_runner) {
  return std::unique_ptr<SharedMemoryArbiterImpl>(
      new SharedMemoryArbiterImpl(shared_memory->start(), shared_memory->size(),
                                  page_size, producer_endpoint, task_runner));
}

SharedMemoryArbiterImpl::SharedMemoryArbiterImpl(
    void* start,
    size_t size,
    size_t page_size,
    TracingService::ProducerEndpoint* producer_endpoint,
    base::TaskRunner* task_runner)
    : task_runner_(task_runner),
      producer_endpoint_(producer_endpoint),
      shmem_abi_(reinterpret_cast<uint8_t*>(start), size, page_size),
      active_writer_ids_(kMaxWriterID),
      weak_ptr_factory_(this) {}

Chunk SharedMemoryArbiterImpl::GetNewChunk(
    const SharedMemoryABI::ChunkHeader& header,
    size_t size_hint) {
  PERFETTO_DCHECK(size_hint == 0);  // Not implemented yet.
  int stall_count = 0;
  unsigned stall_interval_us = 0;
  static const unsigned kMaxStallIntervalUs = 100000;
  static const int kLogAfterNStalls = 3;
  static const int kFlushCommitsAfterEveryNStalls = 2;
  static const int kAssertAtNStalls = 100;

  for (;;) {
    // TODO(primiano): Probably this lock is not really required and this code
    // could be rewritten leveraging only the Try* atomic operations in
    // SharedMemoryABI. But let's not be too adventurous for the moment.
    {
      std::lock_guard<std::mutex> scoped_lock(lock_);
      const size_t initial_page_idx = page_idx_;
      for (size_t i = 0; i < shmem_abi_.num_pages(); i++) {
        page_idx_ = (initial_page_idx + i) % shmem_abi_.num_pages();
        bool is_new_page = false;

        // TODO(primiano): make the page layout dynamic.
        auto layout = SharedMemoryArbiterImpl::default_page_layout;

        if (shmem_abi_.is_page_free(page_idx_)) {
          // TODO(primiano): Use the |size_hint| here to decide the layout.
          is_new_page = shmem_abi_.TryPartitionPage(page_idx_, layout);
        }
        uint32_t free_chunks;
        if (is_new_page) {
          free_chunks = (1 << SharedMemoryABI::kNumChunksForLayout[layout]) - 1;
        } else {
          free_chunks = shmem_abi_.GetFreeChunks(page_idx_);
        }

        for (uint32_t chunk_idx = 0; free_chunks;
             chunk_idx++, free_chunks >>= 1) {
          if (!(free_chunks & 1))
            continue;
          // We found a free chunk.
          Chunk chunk = shmem_abi_.TryAcquireChunkForWriting(
              page_idx_, chunk_idx, &header);
          if (!chunk.is_valid())
            continue;
          if (stall_count > kLogAfterNStalls) {
            PERFETTO_LOG("Recovered from stall after %d iterations",
                         stall_count);
          }
          return chunk;
        }
      }
    }  // std::lock_guard<std::mutex>

    // All chunks are taken (either kBeingWritten by us or kBeingRead by the
    // Service). TODO: at this point we should return a bankrupcy chunk, not
    // crash the process.
    if (stall_count++ == kLogAfterNStalls) {
      PERFETTO_ELOG("Shared memory buffer overrun! Stalling");
    }

    if (stall_count == kAssertAtNStalls) {
      PERFETTO_FATAL(
          "Shared memory buffer max stall count exceeded; possible deadlock");
    }

    // If the IPC thread itself is stalled because the current process has
    // filled up the SMB, we need to make sure that the service can process and
    // purge the chunks written by our process, by flushing any pending commit
    // requests. Because other threads in our process can continue to
    // concurrently grab, fill and commit any chunks purged by the service, it
    // is possible that the SMB remains full and the IPC thread remains stalled,
    // needing to flush the concurrently queued up commits again. This is
    // particularly likely with in-process perfetto service where the IPC thread
    // is the service thread. To avoid remaining stalled forever in such a
    // situation, we attempt to flush periodically after every N stalls.
    if (stall_count % kFlushCommitsAfterEveryNStalls == 0 &&
        task_runner_->RunsTasksOnCurrentThread()) {
      // TODO(primiano): sending the IPC synchronously is a temporary workaround
      // until the backpressure logic in probes_producer is sorted out. Until
      // then the risk is that we stall the message loop waiting for the tracing
      // service to consume the shared memory buffer (SMB) and, for this reason,
      // never run the task that tells the service to purge the SMB. This must
      // happen iff we are on the IPC thread, not doing this will cause
      // deadlocks, doing this on the wrong thread causes out-of-order data
      // commits (crbug.com/919187#c28).
      FlushPendingCommitDataRequests();
    } else {
      base::SleepMicroseconds(stall_interval_us);
      stall_interval_us =
          std::min(kMaxStallIntervalUs, (stall_interval_us + 1) * 8);
    }
  }
}

void SharedMemoryArbiterImpl::ReturnCompletedChunk(Chunk chunk,
                                                   BufferID target_buffer,
                                                   PatchList* patch_list) {
  PERFETTO_DCHECK(chunk.is_valid());
  const WriterID writer_id = chunk.writer_id();
  UpdateCommitDataRequest(std::move(chunk), writer_id, target_buffer,
                          patch_list);
}

void SharedMemoryArbiterImpl::SendPatches(WriterID writer_id,
                                          BufferID target_buffer,
                                          PatchList* patch_list) {
  PERFETTO_DCHECK(!patch_list->empty() && patch_list->front().is_patched());
  UpdateCommitDataRequest(Chunk(), writer_id, target_buffer, patch_list);
}

void SharedMemoryArbiterImpl::UpdateCommitDataRequest(Chunk chunk,
                                                      WriterID writer_id,
                                                      BufferID target_buffer,
                                                      PatchList* patch_list) {
  // Note: chunk will be invalid if the call came from SendPatches().
  bool should_post_callback = false;
  bool should_commit_synchronously = false;
  base::WeakPtr<SharedMemoryArbiterImpl> weak_this;
  {
    std::lock_guard<std::mutex> scoped_lock(lock_);

    if (!commit_data_req_) {
      commit_data_req_.reset(new CommitDataRequest());
      weak_this = weak_ptr_factory_.GetWeakPtr();
      should_post_callback = true;
    }

    // If a valid chunk is specified, return it and attach it to the request.
    if (chunk.is_valid()) {
      PERFETTO_DCHECK(chunk.writer_id() == writer_id);
      uint8_t chunk_idx = chunk.chunk_idx();
      bytes_pending_commit_ += chunk.size();
      size_t page_idx = shmem_abi_.ReleaseChunkAsComplete(std::move(chunk));

      // DO NOT access |chunk| after this point, has been std::move()-d above.

      CommitDataRequest::ChunksToMove* ctm =
          commit_data_req_->add_chunks_to_move();
      ctm->set_page(static_cast<uint32_t>(page_idx));
      ctm->set_chunk(chunk_idx);
      ctm->set_target_buffer(target_buffer);

      // If more than half of the SMB.size() is filled with completed chunks for
      // which we haven't notified the service yet (i.e. they are still enqueued
      // in |commit_data_req_|), force a synchronous CommitDataRequest(), to
      // reduce the likeliness of stalling the writer.
      //
      // We can only do this if we're writing on the same thread that we access
      // the producer endpoint on, since we cannot notify the producer endpoint
      // to commit synchronously on a different thread. Attempting to flush
      // synchronously on another thread will lead to subtle bugs caused by
      // out-of-order commit requests (crbug.com/919187#c28).
      if (task_runner_->RunsTasksOnCurrentThread() &&
          bytes_pending_commit_ >= shmem_abi_.size() / 2) {
        should_commit_synchronously = true;
        should_post_callback = false;
      }
    }

    // Get the completed patches for previous chunks from the |patch_list|
    // and attach them.
    ChunkID last_chunk_id = 0;  // 0 is irrelevant but keeps the compiler happy.
    CommitDataRequest::ChunkToPatch* last_chunk_req = nullptr;
    while (!patch_list->empty() && patch_list->front().is_patched()) {
      if (!last_chunk_req || last_chunk_id != patch_list->front().chunk_id) {
        last_chunk_req = commit_data_req_->add_chunks_to_patch();
        last_chunk_req->set_writer_id(writer_id);
        last_chunk_id = patch_list->front().chunk_id;
        last_chunk_req->set_chunk_id(last_chunk_id);
        last_chunk_req->set_target_buffer(target_buffer);
      }
      auto* patch_req = last_chunk_req->add_patches();
      patch_req->set_offset(patch_list->front().offset);
      patch_req->set_data(&patch_list->front().size_field[0],
                          patch_list->front().size_field.size());
      patch_list->pop_front();
    }
    // Patches are enqueued in the |patch_list| in order and are notified to
    // the service when the chunk is returned. The only case when the current
    // patch list is incomplete is if there is an unpatched entry at the head of
    // the |patch_list| that belongs to the same ChunkID as the last one we are
    // about to send to the service.
    if (last_chunk_req && !patch_list->empty() &&
        patch_list->front().chunk_id == last_chunk_id) {
      last_chunk_req->set_has_more_patches(true);
    }
  }  // scoped_lock(lock_)

  if (should_post_callback) {
    task_runner_->PostTask([weak_this] {
      if (weak_this)
        weak_this->FlushPendingCommitDataRequests();
    });
  }

  if (should_commit_synchronously)
    FlushPendingCommitDataRequests();
}

// This function is quite subtle. When making changes keep in mind these two
// challenges:
// 1) If the producer stalls and we happen to be on the |task_runner_| IPC
//    thread (or, for in-process cases, on the same thread where
//    TracingServiceImpl lives), the CommitData() call must be synchronous and
//    not posted, to avoid deadlocks.
// 2) When different threads hit this function, we must guarantee that we don't
//    accidentally make commits out of order. See commit 4e4fe8f56ef and
//    crbug.com/919187 for more context.
void SharedMemoryArbiterImpl::FlushPendingCommitDataRequests(
    std::function<void()> callback) {
  // May be called by TraceWriterImpl on any thread.
  if (!task_runner_->RunsTasksOnCurrentThread()) {
    auto weak_this = weak_ptr_factory_.GetWeakPtr();
    task_runner_->PostTask([weak_this, callback] {
      if (weak_this)
        weak_this->FlushPendingCommitDataRequests(std::move(callback));
    });
    return;
  }

  std::shared_ptr<CommitDataRequest> req;
  {
    std::lock_guard<std::mutex> scoped_lock(lock_);
    req = std::move(commit_data_req_);
    bytes_pending_commit_ = 0;
  }

  // |req| could be a nullptr if |commit_data_req_| became a nullptr. For
  // example when a forced sync flush happens in GetNewChunk().
  if (req) {
    producer_endpoint_->CommitData(*req, callback);
  } else if (callback) {
    // If |req| was nullptr, it means that an enqueued deferred commit was
    // executed just before this. At this point send an empty commit request
    // to the service, just to linearize with it and give the guarantee to the
    // caller that the data has been flushed into the service.
    producer_endpoint_->CommitData(CommitDataRequest(), std::move(callback));
  }
}

std::unique_ptr<TraceWriter> SharedMemoryArbiterImpl::CreateTraceWriter(
    BufferID target_buffer) {
  WriterID id;
  {
    std::lock_guard<std::mutex> scoped_lock(lock_);
    id = active_writer_ids_.Allocate();
  }
  if (!id)
    return std::unique_ptr<TraceWriter>(new NullTraceWriter());
  auto weak_this = weak_ptr_factory_.GetWeakPtr();
  task_runner_->PostTask([weak_this, id, target_buffer] {
    if (weak_this)
      weak_this->producer_endpoint_->RegisterTraceWriter(id, target_buffer);
  });
  return std::unique_ptr<TraceWriter>(
      new TraceWriterImpl(this, id, target_buffer));
}

void SharedMemoryArbiterImpl::BindStartupTraceWriterRegistry(
    std::unique_ptr<StartupTraceWriterRegistry> registry,
    BufferID target_buffer) {
  if (!task_runner_->RunsTasksOnCurrentThread()) {
    auto weak_this = weak_ptr_factory_.GetWeakPtr();
    auto* raw_reg = registry.release();
    task_runner_->PostTask([weak_this, raw_reg, target_buffer]() {
      std::unique_ptr<StartupTraceWriterRegistry> owned_reg(raw_reg);
      if (!weak_this)
        return;
      weak_this->BindStartupTraceWriterRegistry(std::move(owned_reg),
                                                target_buffer);
    });
    return;
  }

  // The registry will be owned by the arbiter, so it's safe to capture |this|
  // in the callback.
  auto on_bound_callback = [this](StartupTraceWriterRegistry* bound_registry) {
    std::unique_ptr<StartupTraceWriterRegistry> registry_to_delete;
    {
      std::lock_guard<std::mutex> scoped_lock(lock_);

      for (auto it = startup_trace_writer_registries_.begin();
           it != startup_trace_writer_registries_.end(); it++) {
        if (it->get() == bound_registry) {
          // We can't delete the registry while the arbiter's lock is held
          // (to avoid lock inversion).
          registry_to_delete = std::move(*it);
          startup_trace_writer_registries_.erase(it);
          break;
        }
      }
    }

    // The registry should have been in |startup_trace_writer_registries_|.
    PERFETTO_DCHECK(registry_to_delete);
    registry_to_delete.reset();
  };
  registry->BindToArbiter(this, target_buffer, task_runner_, on_bound_callback);
  std::lock_guard<std::mutex> scoped_lock(lock_);
  startup_trace_writer_registries_.push_back(std::move(registry));
}

void SharedMemoryArbiterImpl::NotifyFlushComplete(FlushRequestID req_id) {
  bool should_post_commit_task = false;
  {
    std::lock_guard<std::mutex> scoped_lock(lock_);
    // If a commit_data_req_ exists it means that somebody else already posted a
    // FlushPendingCommitDataRequests() task.
    if (!commit_data_req_) {
      commit_data_req_.reset(new CommitDataRequest());
      should_post_commit_task = true;
    } else {
      // If there is another request queued and that also contains is a reply
      // to a flush request, reply with the highest id.
      req_id = std::max(req_id, commit_data_req_->flush_request_id());
    }
    commit_data_req_->set_flush_request_id(req_id);
  }
  if (should_post_commit_task) {
    auto weak_this = weak_ptr_factory_.GetWeakPtr();
    task_runner_->PostTask([weak_this] {
      if (weak_this)
        weak_this->FlushPendingCommitDataRequests();
    });
  }
}

void SharedMemoryArbiterImpl::ReleaseWriterID(WriterID id) {
  auto weak_this = weak_ptr_factory_.GetWeakPtr();
  task_runner_->PostTask([weak_this, id] {
    if (weak_this)
      weak_this->producer_endpoint_->UnregisterTraceWriter(id);
  });

  std::lock_guard<std::mutex> scoped_lock(lock_);
  active_writer_ids_.Free(id);
}

}  // namespace perfetto
// gen_amalgamated begin source: src/tracing/core/sliced_protobuf_input_stream.cc
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "src/tracing/core/sliced_protobuf_input_stream.h"

#include <algorithm>

// gen_amalgamated expanded: #include "perfetto/base/logging.h"

namespace perfetto {

SlicedProtobufInputStream::SlicedProtobufInputStream(const Slices* slices)
    : slices_(slices), cur_slice_(slices_->begin()) {}

SlicedProtobufInputStream::~SlicedProtobufInputStream() = default;

bool SlicedProtobufInputStream::Next(const void** data, int* size) {
  if (cur_slice_ == slices_->end())
    return false;

  PERFETTO_DCHECK(Validate());
  *data = reinterpret_cast<const void*>(
      reinterpret_cast<uintptr_t>(cur_slice_->start) + pos_in_cur_slice_);
  *size = static_cast<int>(cur_slice_->size - pos_in_cur_slice_);
  cur_slice_++;
  pos_in_cur_slice_ = 0;
  PERFETTO_DCHECK(Validate());

  return true;
}

void SlicedProtobufInputStream::BackUp(int count) {
  size_t n = static_cast<size_t>(count);
  PERFETTO_DCHECK(Validate());
  while (n) {
    if (cur_slice_ == slices_->end() || pos_in_cur_slice_ == 0) {
      if (cur_slice_ == slices_->begin()) {
        // The protobuf library is violating its contract and backing up more
        // bytes than available.
        PERFETTO_DFATAL("Protobuf library backed up too many bytes.");
        return;
      }
      cur_slice_--;
      pos_in_cur_slice_ = cur_slice_->size;
      continue;
    }

    const size_t decrement = std::min(n, pos_in_cur_slice_);
    pos_in_cur_slice_ -= decrement;
    n -= decrement;
  }
  PERFETTO_DCHECK(Validate());
}

bool SlicedProtobufInputStream::Skip(int count) {
  PERFETTO_DCHECK(Validate());
  size_t n = static_cast<size_t>(count);
  while (n) {
    PERFETTO_DCHECK(Validate());
    if (cur_slice_ == slices_->end())
      return false;

    const size_t increment = std::min(n, cur_slice_->size - pos_in_cur_slice_);
    pos_in_cur_slice_ += increment;
    n -= increment;

    if (pos_in_cur_slice_ >= cur_slice_->size) {
      cur_slice_++;
      pos_in_cur_slice_ = 0;
    }
  }
  PERFETTO_DCHECK(Validate());
  return true;
}

google::protobuf::int64 SlicedProtobufInputStream::ByteCount() const {
  PERFETTO_DCHECK(Validate());
  google::protobuf::int64 count = 0;
  for (auto it = slices_->begin(); it != slices_->end(); it++) {
    if (it == cur_slice_) {
      count += static_cast<google::protobuf::int64>(pos_in_cur_slice_);
      break;
    }
    count += static_cast<google::protobuf::int64>(it->size);
  }
  return count;
}

bool SlicedProtobufInputStream::Validate() const {
  return ((cur_slice_ == slices_->end() && pos_in_cur_slice_ == 0) ||
          pos_in_cur_slice_ < cur_slice_->size ||
          (pos_in_cur_slice_ == 0 && cur_slice_->size == 0));
}

}  // namespace perfetto
// gen_amalgamated begin source: src/tracing/core/startup_trace_writer.cc
// gen_amalgamated begin header: include/perfetto/ext/tracing/core/startup_trace_writer.h
// gen_amalgamated begin header: include/perfetto/ext/base/optional.h
/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_BASE_OPTIONAL_H_
#define INCLUDE_PERFETTO_EXT_BASE_OPTIONAL_H_

#include <functional>
#include <type_traits>
#include <utility>

// gen_amalgamated expanded: #include "perfetto/base/logging.h"

namespace perfetto {
namespace base {

// Specification:
// http://en.cppreference.com/w/cpp/utility/optional/in_place_t
struct in_place_t {};

// Specification:
// http://en.cppreference.com/w/cpp/utility/optional/nullopt_t
struct nullopt_t {
  constexpr explicit nullopt_t(int) {}
};

// Specification:
// http://en.cppreference.com/w/cpp/utility/optional/in_place
constexpr in_place_t in_place = {};

// Specification:
// http://en.cppreference.com/w/cpp/utility/optional/nullopt
constexpr nullopt_t nullopt(0);

// Forward declaration, which is refered by following helpers.
template <typename T>
class Optional;

namespace internal {

template <typename T, bool = std::is_trivially_destructible<T>::value>
struct OptionalStorageBase {
  // Initializing |empty_| here instead of using default member initializing
  // to avoid errors in g++ 4.8.
  constexpr OptionalStorageBase() : empty_('\0') {}

  template <class... Args>
  constexpr explicit OptionalStorageBase(in_place_t, Args&&... args)
      : is_populated_(true), value_(std::forward<Args>(args)...) {}

  // When T is not trivially destructible we must call its
  // destructor before deallocating its memory.
  // Note that this hides the (implicitly declared) move constructor, which
  // would be used for constexpr move constructor in OptionalStorage<T>.
  // It is needed iff T is trivially move constructible. However, the current
  // is_trivially_{copy,move}_constructible implementation requires
  // is_trivially_destructible (which looks a bug, cf:
  // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51452 and
  // http://cplusplus.github.io/LWG/lwg-active.html#2116), so it is not
  // necessary for this case at the moment. Please see also the destructor
  // comment in "is_trivially_destructible = true" specialization below.
  ~OptionalStorageBase() {
    if (is_populated_)
      value_.~T();
  }

  template <class... Args>
  void Init(Args&&... args) {
    PERFETTO_DCHECK(!is_populated_);
    ::new (&value_) T(std::forward<Args>(args)...);
    is_populated_ = true;
  }

  bool is_populated_ = false;
  union {
    // |empty_| exists so that the union will always be initialized, even when
    // it doesn't contain a value. Union members must be initialized for the
    // constructor to be 'constexpr'.
    char empty_;
    T value_;
  };
};

template <typename T>
struct OptionalStorageBase<T, true /* trivially destructible */> {
  // Initializing |empty_| here instead of using default member initializing
  // to avoid errors in g++ 4.8.
  constexpr OptionalStorageBase() : empty_('\0') {}

  template <class... Args>
  constexpr explicit OptionalStorageBase(in_place_t, Args&&... args)
      : is_populated_(true), value_(std::forward<Args>(args)...) {}

  // When T is trivially destructible (i.e. its destructor does nothing) there
  // is no need to call it. Implicitly defined destructor is trivial, because
  // both members (bool and union containing only variants which are trivially
  // destructible) are trivially destructible.
  // Explicitly-defaulted destructor is also trivial, but do not use it here,
  // because it hides the implicit move constructor. It is needed to implement
  // constexpr move constructor in OptionalStorage iff T is trivially move
  // constructible. Note that, if T is trivially move constructible, the move
  // constructor of OptionalStorageBase<T> is also implicitly defined and it is
  // trivially move constructor. If T is not trivially move constructible,
  // "not declaring move constructor without destructor declaration" here means
  // "delete move constructor", which works because any move constructor of
  // OptionalStorage will not refer to it in that case.

  template <class... Args>
  void Init(Args&&... args) {
    PERFETTO_DCHECK(!is_populated_);
    ::new (&value_) T(std::forward<Args>(args)...);
    is_populated_ = true;
  }

  bool is_populated_ = false;
  union {
    // |empty_| exists so that the union will always be initialized, even when
    // it doesn't contain a value. Union members must be initialized for the
    // constructor to be 'constexpr'.
    char empty_;
    T value_;
  };
};

// Implement conditional constexpr copy and move constructors. These are
// constexpr if is_trivially_{copy,move}_constructible<T>::value is true
// respectively. If each is true, the corresponding constructor is defined as
// "= default;", which generates a constexpr constructor (In this case,
// the condition of constexpr-ness is satisfied because the base class also has
// compiler generated constexpr {copy,move} constructors). Note that
// placement-new is prohibited in constexpr.
template <typename T, bool = std::is_trivially_copy_constructible<T>::value>
struct OptionalStorage : OptionalStorageBase<T> {
  // This is no trivially {copy,move} constructible case. Other cases are
  // defined below as specializations.

  // Accessing the members of template base class requires explicit
  // declaration.
  using OptionalStorageBase<T>::is_populated_;
  using OptionalStorageBase<T>::value_;
  using OptionalStorageBase<T>::Init;

  // Inherit constructors (specifically, the in_place constructor).
  using OptionalStorageBase<T>::OptionalStorageBase;

  // User defined constructor deletes the default constructor.
  // Define it explicitly.
  OptionalStorage() = default;

  OptionalStorage(const OptionalStorage& other) : OptionalStorageBase<T>() {
    if (other.is_populated_)
      Init(other.value_);
  }

  OptionalStorage(OptionalStorage&& other) noexcept(
      std::is_nothrow_move_constructible<T>::value) {
    if (other.is_populated_)
      Init(std::move(other.value_));
  }
};

template <typename T>
struct OptionalStorage<T, true /* trivially copy constructible */>
    : OptionalStorageBase<T> {
  using OptionalStorageBase<T>::is_populated_;
  using OptionalStorageBase<T>::value_;
  using OptionalStorageBase<T>::Init;
  using OptionalStorageBase<T>::OptionalStorageBase;

  OptionalStorage() = default;
  OptionalStorage(const OptionalStorage& other) = default;

  OptionalStorage(OptionalStorage&& other) noexcept(
      std::is_nothrow_move_constructible<T>::value) {
    if (other.is_populated_)
      Init(std::move(other.value_));
  }
};

// Base class to support conditionally usable copy-/move- constructors
// and assign operators.
template <typename T>
class OptionalBase {
  // This class provides implementation rather than public API, so everything
  // should be hidden. Often we use composition, but we cannot in this case
  // because of C++ language restriction.
 protected:
  constexpr OptionalBase() = default;
  constexpr OptionalBase(const OptionalBase& other) = default;
  constexpr OptionalBase(OptionalBase&& other) = default;

  template <class... Args>
  constexpr explicit OptionalBase(in_place_t, Args&&... args)
      : storage_(in_place, std::forward<Args>(args)...) {}

  // Implementation of converting constructors.
  template <typename U>
  explicit OptionalBase(const OptionalBase<U>& other) {
    if (other.storage_.is_populated_)
      storage_.Init(other.storage_.value_);
  }

  template <typename U>
  explicit OptionalBase(OptionalBase<U>&& other) {
    if (other.storage_.is_populated_)
      storage_.Init(std::move(other.storage_.value_));
  }

  ~OptionalBase() = default;

  OptionalBase& operator=(const OptionalBase& other) {
    CopyAssign(other);
    return *this;
  }

  OptionalBase& operator=(OptionalBase&& other) noexcept(
      std::is_nothrow_move_assignable<T>::value&&
          std::is_nothrow_move_constructible<T>::value) {
    MoveAssign(std::move(other));
    return *this;
  }

  template <typename U>
  void CopyAssign(const OptionalBase<U>& other) {
    if (other.storage_.is_populated_)
      InitOrAssign(other.storage_.value_);
    else
      FreeIfNeeded();
  }

  template <typename U>
  void MoveAssign(OptionalBase<U>&& other) {
    if (other.storage_.is_populated_)
      InitOrAssign(std::move(other.storage_.value_));
    else
      FreeIfNeeded();
  }

  template <typename U>
  void InitOrAssign(U&& value) {
    if (storage_.is_populated_)
      storage_.value_ = std::forward<U>(value);
    else
      storage_.Init(std::forward<U>(value));
  }

  void FreeIfNeeded() {
    if (!storage_.is_populated_)
      return;
    storage_.value_.~T();
    storage_.is_populated_ = false;
  }

  // For implementing conversion, allow access to other typed OptionalBase
  // class.
  template <typename U>
  friend class OptionalBase;

  OptionalStorage<T> storage_;
};

// The following {Copy,Move}{Constructible,Assignable} structs are helpers to
// implement constructor/assign-operator overloading. Specifically, if T is
// is not movable but copyable, Optional<T>'s move constructor should not
// participate in overload resolution. This inheritance trick implements that.
template <bool is_copy_constructible>
struct CopyConstructible {};

template <>
struct CopyConstructible<false> {
  constexpr CopyConstructible() = default;
  constexpr CopyConstructible(const CopyConstructible&) = delete;
  constexpr CopyConstructible(CopyConstructible&&) = default;
  CopyConstructible& operator=(const CopyConstructible&) = default;
  CopyConstructible& operator=(CopyConstructible&&) = default;
};

template <bool is_move_constructible>
struct MoveConstructible {};

template <>
struct MoveConstructible<false> {
  constexpr MoveConstructible() = default;
  constexpr MoveConstructible(const MoveConstructible&) = default;
  constexpr MoveConstructible(MoveConstructible&&) = delete;
  MoveConstructible& operator=(const MoveConstructible&) = default;
  MoveConstructible& operator=(MoveConstructible&&) = default;
};

template <bool is_copy_assignable>
struct CopyAssignable {};

template <>
struct CopyAssignable<false> {
  constexpr CopyAssignable() = default;
  constexpr CopyAssignable(const CopyAssignable&) = default;
  constexpr CopyAssignable(CopyAssignable&&) = default;
  CopyAssignable& operator=(const CopyAssignable&) = delete;
  CopyAssignable& operator=(CopyAssignable&&) = default;
};

template <bool is_move_assignable>
struct MoveAssignable {};

template <>
struct MoveAssignable<false> {
  constexpr MoveAssignable() = default;
  constexpr MoveAssignable(const MoveAssignable&) = default;
  constexpr MoveAssignable(MoveAssignable&&) = default;
  MoveAssignable& operator=(const MoveAssignable&) = default;
  MoveAssignable& operator=(MoveAssignable&&) = delete;
};

// Helper to conditionally enable converting constructors and assign operators.
template <typename T, typename U>
struct IsConvertibleFromOptional
    : std::integral_constant<
          bool,
          std::is_constructible<T, Optional<U>&>::value ||
              std::is_constructible<T, const Optional<U>&>::value ||
              std::is_constructible<T, Optional<U>&&>::value ||
              std::is_constructible<T, const Optional<U>&&>::value ||
              std::is_convertible<Optional<U>&, T>::value ||
              std::is_convertible<const Optional<U>&, T>::value ||
              std::is_convertible<Optional<U>&&, T>::value ||
              std::is_convertible<const Optional<U>&&, T>::value> {};

template <typename T, typename U>
struct IsAssignableFromOptional
    : std::integral_constant<
          bool,
          IsConvertibleFromOptional<T, U>::value ||
              std::is_assignable<T&, Optional<U>&>::value ||
              std::is_assignable<T&, const Optional<U>&>::value ||
              std::is_assignable<T&, Optional<U>&&>::value ||
              std::is_assignable<T&, const Optional<U>&&>::value> {};

// Forward compatibility for C++17.
// Introduce one more deeper nested namespace to avoid leaking using std::swap.
namespace swappable_impl {
using std::swap;

struct IsSwappableImpl {
  // Tests if swap can be called. Check<T&>(0) returns true_type iff swap is
  // available for T. Otherwise, Check's overload resolution falls back to
  // Check(...) declared below thanks to SFINAE, so returns false_type.
  template <typename T>
  static auto Check(int)
      -> decltype(swap(std::declval<T>(), std::declval<T>()), std::true_type());

  template <typename T>
  static std::false_type Check(...);
};
}  // namespace swappable_impl

template <typename T>
struct IsSwappable : decltype(swappable_impl::IsSwappableImpl::Check<T&>(0)) {};

// Forward compatibility for C++20.
template <typename T>
using RemoveCvRefT =
    typename std::remove_cv<typename std::remove_reference<T>::type>::type;

}  // namespace internal

// On Windows, by default, empty-base class optimization does not work,
// which means even if the base class is empty struct, it still consumes one
// byte for its body. __declspec(empty_bases) enables the optimization.
// cf)
// https://blogs.msdn.microsoft.com/vcblog/2016/03/30/optimizing-the-layout-of-empty-base-classes-in-vs2015-update-2-3/
#if PERFETTO_BUILDFLAG(PERFETTO_OS_WIN) && \
    !PERFETTO_BUILDFLAG(PERFETTO_COMPILER_GCC)
#define OPTIONAL_DECLSPEC_EMPTY_BASES __declspec(empty_bases)
#else
#define OPTIONAL_DECLSPEC_EMPTY_BASES
#endif

// base::Optional is a Chromium version of the C++17 optional class:
// std::optional documentation:
// http://en.cppreference.com/w/cpp/utility/optional
// Chromium documentation:
// https://chromium.googlesource.com/chromium/src/+/master/docs/optional.md
//
// These are the differences between the specification and the implementation:
// - Constructors do not use 'constexpr' as it is a C++14 extension.
// - 'constexpr' might be missing in some places for reasons specified locally.
// - No exceptions are thrown, because they are banned from Chromium.
//   Marked noexcept for only move constructor and move assign operators.
// - All the non-members are in the 'base' namespace instead of 'std'.
//
// Note that T cannot have a constructor T(Optional<T>) etc. Optional<T>
// PERFETTO_CHECKs T's constructor (specifically via IsConvertibleFromOptional),
// and in the PERFETTO_CHECK whether T can be constructible from Optional<T>,
// which is recursive so it does not work. As of Feb 2018, std::optional C++17
// implementation in both clang and gcc has same limitation. MSVC SFINAE looks
// to have different behavior, but anyway it reports an error, too.
//
// This file is a modified version of optional.h from Chromium at revision
// 5e71bd454e60511c1293c0c686544aaa76094424. The changes remove C++14/C++17
// specific code and replace with C++11 counterparts.
template <typename T>
class OPTIONAL_DECLSPEC_EMPTY_BASES Optional
    : public internal::OptionalBase<T>,
      public internal::CopyConstructible<std::is_copy_constructible<T>::value>,
      public internal::MoveConstructible<std::is_move_constructible<T>::value>,
      public internal::CopyAssignable<std::is_copy_constructible<T>::value &&
                                      std::is_copy_assignable<T>::value>,
      public internal::MoveAssignable<std::is_move_constructible<T>::value &&
                                      std::is_move_assignable<T>::value> {
 public:
#undef OPTIONAL_DECLSPEC_EMPTY_BASES
  using value_type = T;

  // Defer default/copy/move constructor implementation to OptionalBase.
  constexpr Optional() = default;
  constexpr Optional(const Optional& other) = default;
  constexpr Optional(Optional&& other) noexcept(
      std::is_nothrow_move_constructible<T>::value) = default;

  constexpr Optional(nullopt_t) {}  // NOLINT(runtime/explicit)

  // Converting copy constructor. "explicit" only if
  // std::is_convertible<const U&, T>::value is false. It is implemented by
  // declaring two almost same constructors, but that condition in enable_if_t
  // is different, so that either one is chosen, thanks to SFINAE.
  template <typename U,
            typename std::enable_if<
                std::is_constructible<T, const U&>::value &&
                    !internal::IsConvertibleFromOptional<T, U>::value &&
                    std::is_convertible<const U&, T>::value,
                bool>::type = false>
  Optional(const Optional<U>& other) : internal::OptionalBase<T>(other) {}

  template <typename U,
            typename std::enable_if<
                std::is_constructible<T, const U&>::value &&
                    !internal::IsConvertibleFromOptional<T, U>::value &&
                    !std::is_convertible<const U&, T>::value,
                bool>::type = false>
  explicit Optional(const Optional<U>& other)
      : internal::OptionalBase<T>(other) {}

  // Converting move constructor. Similar to converting copy constructor,
  // declaring two (explicit and non-explicit) constructors.
  template <typename U,
            typename std::enable_if<
                std::is_constructible<T, U&&>::value &&
                    !internal::IsConvertibleFromOptional<T, U>::value &&
                    std::is_convertible<U&&, T>::value,
                bool>::type = false>
  Optional(Optional<U>&& other) : internal::OptionalBase<T>(std::move(other)) {}

  template <typename U,
            typename std::enable_if<
                std::is_constructible<T, U&&>::value &&
                    !internal::IsConvertibleFromOptional<T, U>::value &&
                    !std::is_convertible<U&&, T>::value,
                bool>::type = false>
  explicit Optional(Optional<U>&& other)
      : internal::OptionalBase<T>(std::move(other)) {}

  template <class... Args>
  constexpr explicit Optional(in_place_t, Args&&... args)
      : internal::OptionalBase<T>(in_place, std::forward<Args>(args)...) {}

  template <class U,
            class... Args,
            class = typename std::enable_if<
                std::is_constructible<value_type,
                                      std::initializer_list<U>&,
                                      Args...>::value>::type>
  constexpr explicit Optional(in_place_t,
                              std::initializer_list<U> il,
                              Args&&... args)
      : internal::OptionalBase<T>(in_place, il, std::forward<Args>(args)...) {}

  // Forward value constructor. Similar to converting constructors,
  // conditionally explicit.
  template <
      typename U = value_type,
      typename std::enable_if<
          std::is_constructible<T, U&&>::value &&
              !std::is_same<internal::RemoveCvRefT<U>, in_place_t>::value &&
              !std::is_same<internal::RemoveCvRefT<U>, Optional<T>>::value &&
              std::is_convertible<U&&, T>::value,
          bool>::type = false>
  constexpr Optional(U&& value)
      : internal::OptionalBase<T>(in_place, std::forward<U>(value)) {}

  template <
      typename U = value_type,
      typename std::enable_if<
          std::is_constructible<T, U&&>::value &&
              !std::is_same<internal::RemoveCvRefT<U>, in_place_t>::value &&
              !std::is_same<internal::RemoveCvRefT<U>, Optional<T>>::value &&
              !std::is_convertible<U&&, T>::value,
          bool>::type = false>
  constexpr explicit Optional(U&& value)
      : internal::OptionalBase<T>(in_place, std::forward<U>(value)) {}

  ~Optional() = default;

  // Defer copy-/move- assign operator implementation to OptionalBase.
  Optional& operator=(const Optional& other) = default;
  Optional& operator=(Optional&& other) noexcept(
      std::is_nothrow_move_assignable<T>::value&&
          std::is_nothrow_move_constructible<T>::value) = default;

  Optional& operator=(nullopt_t) {
    FreeIfNeeded();
    return *this;
  }

  // Perfect-forwarded assignment.
  template <typename U>
  typename std::enable_if<
      !std::is_same<internal::RemoveCvRefT<U>, Optional<T>>::value &&
          std::is_constructible<T, U>::value &&
          std::is_assignable<T&, U>::value &&
          (!std::is_scalar<T>::value ||
           !std::is_same<typename std::decay<U>::type, T>::value),
      Optional&>::type
  operator=(U&& value) {
    InitOrAssign(std::forward<U>(value));
    return *this;
  }

  // Copy assign the state of other.
  template <typename U>
  typename std::enable_if<!internal::IsAssignableFromOptional<T, U>::value &&
                              std::is_constructible<T, const U&>::value &&
                              std::is_assignable<T&, const U&>::value,
                          Optional&>::type
  operator=(const Optional<U>& other) {
    CopyAssign(other);
    return *this;
  }

  // Move assign the state of other.
  template <typename U>
  typename std::enable_if<!internal::IsAssignableFromOptional<T, U>::value &&
                              std::is_constructible<T, U>::value &&
                              std::is_assignable<T&, U>::value,
                          Optional&>::type
  operator=(Optional<U>&& other) {
    MoveAssign(std::move(other));
    return *this;
  }

  const T* operator->() const {
    PERFETTO_DCHECK(storage_.is_populated_);
    return &storage_.value_;
  }

  T* operator->() {
    PERFETTO_DCHECK(storage_.is_populated_);
    return &storage_.value_;
  }

  const T& operator*() const& {
    PERFETTO_DCHECK(storage_.is_populated_);
    return storage_.value_;
  }

  T& operator*() & {
    PERFETTO_DCHECK(storage_.is_populated_);
    return storage_.value_;
  }

  const T&& operator*() const&& {
    PERFETTO_DCHECK(storage_.is_populated_);
    return std::move(storage_.value_);
  }

  T&& operator*() && {
    PERFETTO_DCHECK(storage_.is_populated_);
    return std::move(storage_.value_);
  }

  constexpr explicit operator bool() const { return storage_.is_populated_; }

  constexpr bool has_value() const { return storage_.is_populated_; }

  T& value() & {
    PERFETTO_CHECK(storage_.is_populated_);
    return storage_.value_;
  }

  const T& value() const& {
    PERFETTO_CHECK(storage_.is_populated_);
    return storage_.value_;
  }

  T&& value() && {
    PERFETTO_CHECK(storage_.is_populated_);
    return std::move(storage_.value_);
  }

  const T&& value() const&& {
    PERFETTO_CHECK(storage_.is_populated_);
    return std::move(storage_.value_);
  }

  template <class U>
  constexpr T value_or(U&& default_value) const& {
    static_assert(std::is_convertible<U, T>::value,
                  "U must be convertible to T");
    return storage_.is_populated_
               ? storage_.value_
               : static_cast<T>(std::forward<U>(default_value));
  }

  template <class U>
  T value_or(U&& default_value) && {
    static_assert(std::is_convertible<U, T>::value,
                  "U must be convertible to T");
    return storage_.is_populated_
               ? std::move(storage_.value_)
               : static_cast<T>(std::forward<U>(default_value));
  }

  void swap(Optional& other) {
    if (!storage_.is_populated_ && !other.storage_.is_populated_)
      return;

    if (storage_.is_populated_ != other.storage_.is_populated_) {
      if (storage_.is_populated_) {
        other.storage_.Init(std::move(storage_.value_));
        FreeIfNeeded();
      } else {
        storage_.Init(std::move(other.storage_.value_));
        other.FreeIfNeeded();
      }
      return;
    }

    PERFETTO_DCHECK(storage_.is_populated_ && other.storage_.is_populated_);
    using std::swap;
    swap(**this, *other);
  }

  void reset() { FreeIfNeeded(); }

  template <class... Args>
  T& emplace(Args&&... args) {
    FreeIfNeeded();
    storage_.Init(std::forward<Args>(args)...);
    return storage_.value_;
  }

  template <class U, class... Args>
  typename std::enable_if<
      std::is_constructible<T, std::initializer_list<U>&, Args&&...>::value,
      T&>::type
  emplace(std::initializer_list<U> il, Args&&... args) {
    FreeIfNeeded();
    storage_.Init(il, std::forward<Args>(args)...);
    return storage_.value_;
  }

 private:
  // Accessing template base class's protected member needs explicit
  // declaration to do so.
  using internal::OptionalBase<T>::CopyAssign;
  using internal::OptionalBase<T>::FreeIfNeeded;
  using internal::OptionalBase<T>::InitOrAssign;
  using internal::OptionalBase<T>::MoveAssign;
  using internal::OptionalBase<T>::storage_;
};

// Here after defines comparation operators. The definition follows
// http://en.cppreference.com/w/cpp/utility/optional/operator_cmp
// while bool() casting is replaced by has_value() to meet the chromium
// style guide.
template <class T, class U>
bool operator==(const Optional<T>& lhs, const Optional<U>& rhs) {
  if (lhs.has_value() != rhs.has_value())
    return false;
  if (!lhs.has_value())
    return true;
  return *lhs == *rhs;
}

template <class T, class U>
bool operator!=(const Optional<T>& lhs, const Optional<U>& rhs) {
  if (lhs.has_value() != rhs.has_value())
    return true;
  if (!lhs.has_value())
    return false;
  return *lhs != *rhs;
}

template <class T, class U>
bool operator<(const Optional<T>& lhs, const Optional<U>& rhs) {
  if (!rhs.has_value())
    return false;
  if (!lhs.has_value())
    return true;
  return *lhs < *rhs;
}

template <class T, class U>
bool operator<=(const Optional<T>& lhs, const Optional<U>& rhs) {
  if (!lhs.has_value())
    return true;
  if (!rhs.has_value())
    return false;
  return *lhs <= *rhs;
}

template <class T, class U>
bool operator>(const Optional<T>& lhs, const Optional<U>& rhs) {
  if (!lhs.has_value())
    return false;
  if (!rhs.has_value())
    return true;
  return *lhs > *rhs;
}

template <class T, class U>
bool operator>=(const Optional<T>& lhs, const Optional<U>& rhs) {
  if (!rhs.has_value())
    return true;
  if (!lhs.has_value())
    return false;
  return *lhs >= *rhs;
}

template <class T>
constexpr bool operator==(const Optional<T>& opt, nullopt_t) {
  return !opt;
}

template <class T>
constexpr bool operator==(nullopt_t, const Optional<T>& opt) {
  return !opt;
}

template <class T>
constexpr bool operator!=(const Optional<T>& opt, nullopt_t) {
  return opt.has_value();
}

template <class T>
constexpr bool operator!=(nullopt_t, const Optional<T>& opt) {
  return opt.has_value();
}

template <class T>
constexpr bool operator<(const Optional<T>&, nullopt_t) {
  return false;
}

template <class T>
constexpr bool operator<(nullopt_t, const Optional<T>& opt) {
  return opt.has_value();
}

template <class T>
constexpr bool operator<=(const Optional<T>& opt, nullopt_t) {
  return !opt;
}

template <class T>
constexpr bool operator<=(nullopt_t, const Optional<T>&) {
  return true;
}

template <class T>
constexpr bool operator>(const Optional<T>& opt, nullopt_t) {
  return opt.has_value();
}

template <class T>
constexpr bool operator>(nullopt_t, const Optional<T>&) {
  return false;
}

template <class T>
constexpr bool operator>=(const Optional<T>&, nullopt_t) {
  return true;
}

template <class T>
constexpr bool operator>=(nullopt_t, const Optional<T>& opt) {
  return !opt;
}

template <class T, class U>
constexpr bool operator==(const Optional<T>& opt, const U& value) {
  return opt.has_value() ? *opt == value : false;
}

template <class T, class U>
constexpr bool operator==(const U& value, const Optional<T>& opt) {
  return opt.has_value() ? value == *opt : false;
}

template <class T, class U>
constexpr bool operator!=(const Optional<T>& opt, const U& value) {
  return opt.has_value() ? *opt != value : true;
}

template <class T, class U>
constexpr bool operator!=(const U& value, const Optional<T>& opt) {
  return opt.has_value() ? value != *opt : true;
}

template <class T, class U>
constexpr bool operator<(const Optional<T>& opt, const U& value) {
  return opt.has_value() ? *opt < value : true;
}

template <class T, class U>
constexpr bool operator<(const U& value, const Optional<T>& opt) {
  return opt.has_value() ? value < *opt : false;
}

template <class T, class U>
constexpr bool operator<=(const Optional<T>& opt, const U& value) {
  return opt.has_value() ? *opt <= value : true;
}

template <class T, class U>
constexpr bool operator<=(const U& value, const Optional<T>& opt) {
  return opt.has_value() ? value <= *opt : false;
}

template <class T, class U>
constexpr bool operator>(const Optional<T>& opt, const U& value) {
  return opt.has_value() ? *opt > value : false;
}

template <class T, class U>
constexpr bool operator>(const U& value, const Optional<T>& opt) {
  return opt.has_value() ? value > *opt : true;
}

template <class T, class U>
constexpr bool operator>=(const Optional<T>& opt, const U& value) {
  return opt.has_value() ? *opt >= value : false;
}

template <class T, class U>
constexpr bool operator>=(const U& value, const Optional<T>& opt) {
  return opt.has_value() ? value >= *opt : true;
}

template <class T>
constexpr Optional<typename std::decay<T>::type> make_optional(T&& value) {
  return Optional<typename std::decay<T>::type>(std::forward<T>(value));
}

template <class T, class... Args>
constexpr Optional<T> make_optional(Args&&... args) {
  return Optional<T>(in_place, std::forward<Args>(args)...);
}

template <class T, class U, class... Args>
constexpr Optional<T> make_optional(std::initializer_list<U> il,
                                    Args&&... args) {
  return Optional<T>(in_place, il, std::forward<Args>(args)...);
}

// Partial specialization for a function template is not allowed. Also, it is
// not allowed to add overload function to std namespace, while it is allowed
// to specialize the template in std. Thus, swap() (kind of) overloading is
// defined in base namespace, instead.
template <class T>
typename std::enable_if<std::is_move_constructible<T>::value &&
                        internal::IsSwappable<T>::value>::type
swap(Optional<T>& lhs, Optional<T>& rhs) {
  lhs.swap(rhs);
}

}  // namespace base
}  // namespace perfetto

namespace std {

template <class T>
struct hash<perfetto::base::Optional<T>> {
  size_t operator()(const perfetto::base::Optional<T>& opt) const {
    return opt == perfetto::base::nullopt ? 0 : std::hash<T>()(*opt);
  }
};

}  // namespace std

#endif  // INCLUDE_PERFETTO_EXT_BASE_OPTIONAL_H_
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_TRACING_CORE_STARTUP_TRACE_WRITER_H_
#define INCLUDE_PERFETTO_EXT_TRACING_CORE_STARTUP_TRACE_WRITER_H_

#include <memory>
#include <mutex>
#include <set>
#include <vector>

// gen_amalgamated expanded: #include "perfetto/base/export.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/optional.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/thread_checker.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/basic_types.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/trace_writer.h"
// gen_amalgamated expanded: #include "perfetto/protozero/message_handle.h"
// gen_amalgamated expanded: #include "perfetto/protozero/scattered_heap_buffer.h"
// gen_amalgamated expanded: #include "perfetto/protozero/scattered_stream_writer.h"

namespace perfetto {

class SharedMemoryArbiterImpl;
class StartupTraceWriterRegistryHandle;

namespace protos {
namespace pbzero {
class TracePacket;
}  // namespace pbzero
}  // namespace protos

// Facilitates writing trace events in early phases of an application's startup
// when the perfetto service is not available yet.
//
// Until the service is available, producer threads instantiate an unbound
// StartupTraceWriter instance (via a StartupTraceWriterRegistry) and use it to
// emit trace events. Each writer will record the serialized trace events into a
// temporary local memory buffer.
//
// Once the service is available, the producer binds each StartupTraceWriter to
// the SMB by calling SharedMemoryArbiter::BindStartupTraceWriter(). The data in
// the writer's local buffer will then be copied into the SMB and the any future
// writes will proxy directly to a new SMB-backed TraceWriter.
//
// Writing to the temporary local trace buffer is guarded by a lock and flag to
// allow binding the writer from a different thread. When the writer starts
// writing data by calling NewTracePacket(), the writer thread acquires the lock
// to set a flag indicating that a write is in progress. Once the packet is
// finalized, the flag is reset. To bind the writer, the lock is acquired while
// the flag is unset and released only once binding completed, thereby blocking
// the writer thread from starting a write concurrently.
//
// While unbound, the writer thread should finalize each TracePacket as soon as
// possible to ensure that it doesn't block binding the writer.
class PERFETTO_EXPORT StartupTraceWriter
    : public TraceWriter,
      public protozero::MessageHandleBase::FinalizationListener {
 public:
  // Create a StartupTraceWriter bound to |trace_writer|. Should only be called
  // on the writer thread.
  explicit StartupTraceWriter(std::unique_ptr<TraceWriter> trace_writer);

  ~StartupTraceWriter() override;

  // Return the given writer back to its registry if it is associated with a
  // registry and the registry was not yet deleted. Otherwise, the writer is
  // destroyed synchronously.
  //
  // Usually called when the writer's thread is destroyed. Can be called on any
  // thread. The passed writer may still be unbound or already be bound. If
  // unbound, the registry will ensure that it is bound before destroying it,
  // keeping it alive until the registry is bound if necessary. This way, its
  // buffered data is retained.
  //
  // All packets written to the passed writer should have been completed and it
  // should no longer be used to write data after calling this method.
  static void ReturnToRegistry(std::unique_ptr<StartupTraceWriter> writer);

  // TraceWriter implementation. These methods should only be called on the
  // writer thread.
  TracePacketHandle NewTracePacket() override;
  void Flush(std::function<void()> callback = {}) override;

  // Note that this will return 0 until the first TracePacket was started after
  // binding.
  WriterID writer_id() const override;

  uint64_t written() const override;

  // Returns |true| if the writer thread has observed that the writer was bound
  // to an SMB. Should only be called on the writer thread.
  //
  // The writer thread can use the return value to determine whether it needs to
  // finalize the current TracePacket as soon as possible. It is only safe for
  // the writer to batch data into a single TracePacket over a longer time
  // period when this returns |true|.
  bool was_bound() const {
    PERFETTO_DCHECK_THREAD(writer_thread_checker_);
    return was_bound_;
  }

  // Should only be called on the writer thread.
  size_t used_buffer_size();

 private:
  friend class StartupTraceWriterRegistry;
  friend class StartupTraceWriterTest;

  // Create an unbound StartupTraceWriter associated with the registry pointed
  // to by the handle. The writer can later be bound by calling
  // BindToTraceWriter(). The registry handle may be nullptr in tests.
  StartupTraceWriter(std::shared_ptr<StartupTraceWriterRegistryHandle>);

  StartupTraceWriter(const StartupTraceWriter&) = delete;
  StartupTraceWriter& operator=(const StartupTraceWriter&) = delete;

  // Bind this StartupTraceWriter to the provided SharedMemoryArbiterImpl.
  // Called by StartupTraceWriterRegistry::BindToArbiter().
  //
  // This method can be called on any thread. If any data was written locally
  // before the writer was bound, BindToArbiter() will copy this data into
  // chunks in the provided target buffer via the SMB. Any future packets will
  // be directly written into the SMB via a newly obtained TraceWriter from the
  // arbiter.
  //
  // Will fail and return |false| if a concurrent write is in progress. Returns
  // |true| if successfully bound and should then not be called again.
  bool BindToArbiter(SharedMemoryArbiterImpl*,
                     BufferID target_buffer) PERFETTO_WARN_UNUSED_RESULT;

  // protozero::MessageHandleBase::FinalizationListener implementation.
  void OnMessageFinalized(protozero::Message* message) override;

  void OnTracePacketCompleted();
  ChunkID CommitLocalBufferChunks(SharedMemoryArbiterImpl*, WriterID, BufferID);

  PERFETTO_THREAD_CHECKER(writer_thread_checker_)

  std::shared_ptr<StartupTraceWriterRegistryHandle> registry_handle_;

  // Only set and accessed from the writer thread. The writer thread flips this
  // bit when it sees that trace_writer_ is set (while holding the lock).
  // Caching this fact in this variable avoids the need to acquire the lock to
  // check on later calls to NewTracePacket().
  bool was_bound_ = false;

  // All variables below this point are protected by |lock_|.
  std::mutex lock_;

  // Never reset once it is changed from |nullptr|.
  std::unique_ptr<TraceWriter> trace_writer_ = nullptr;

  // Local memory buffer for trace packets written before the writer is bound.
  std::unique_ptr<protozero::ScatteredHeapBuffer> memory_buffer_;
  std::unique_ptr<protozero::ScatteredStreamWriter> memory_stream_writer_;

  std::vector<uint32_t> packet_sizes_;

  // Whether the writer thread is currently writing a TracePacket.
  bool write_in_progress_ = false;

  // The packet returned via NewTracePacket() while the writer is unbound. Reset
  // to |nullptr| once bound. Owned by this class, TracePacketHandle has just a
  // pointer to it.
  std::unique_ptr<protos::pbzero::TracePacket> cur_packet_;
};

}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_TRACING_CORE_STARTUP_TRACE_WRITER_H_
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/startup_trace_writer.h"

#include <numeric>

// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/shared_memory_abi.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/startup_trace_writer_registry.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"
// gen_amalgamated expanded: #include "perfetto/trace/trace_packet.pbzero.h"
// gen_amalgamated expanded: #include "src/tracing/core/patch_list.h"
// gen_amalgamated expanded: #include "src/tracing/core/shared_memory_arbiter_impl.h"

using ChunkHeader = perfetto::SharedMemoryABI::ChunkHeader;

namespace perfetto {

namespace {

SharedMemoryABI::Chunk NewChunk(SharedMemoryArbiterImpl* arbiter,
                                WriterID writer_id,
                                ChunkID chunk_id,
                                bool fragmenting_packet) {
  ChunkHeader::Packets packets = {};
  if (fragmenting_packet) {
    packets.count = 1;
    packets.flags = ChunkHeader::kFirstPacketContinuesFromPrevChunk;
  }

  // The memory order of the stores below doesn't really matter. This |header|
  // is just a local temporary object. The GetNewChunk() call below will copy it
  // into the shared buffer with the proper barriers.
  ChunkHeader header = {};
  header.writer_id.store(writer_id, std::memory_order_relaxed);
  header.chunk_id.store(chunk_id, std::memory_order_relaxed);
  header.packets.store(packets, std::memory_order_relaxed);

  return arbiter->GetNewChunk(header);
}

class LocalBufferReader {
 public:
  LocalBufferReader(protozero::ScatteredHeapBuffer* buffer)
      : buffer_slices_(buffer->slices()), cur_slice_(buffer_slices_.begin()) {}

  size_t ReadBytes(SharedMemoryABI::Chunk* target_chunk,
                   size_t num_bytes,
                   size_t cur_payload_size) {
    PERFETTO_CHECK(target_chunk->payload_size() >=
                   num_bytes + cur_payload_size);
    uint8_t* target_ptr = target_chunk->payload_begin() + cur_payload_size;
    size_t bytes_read = 0;
    while (bytes_read < num_bytes) {
      if (cur_slice_ == buffer_slices_.end())
        return bytes_read;

      auto cur_slice_range = cur_slice_->GetUsedRange();

      if (cur_slice_range.size() == cur_slice_offset_) {
        cur_slice_offset_ = 0;
        cur_slice_++;
        continue;
      }

      size_t read_size = std::min(num_bytes - bytes_read,
                                  cur_slice_range.size() - cur_slice_offset_);
      memcpy(target_ptr + bytes_read, cur_slice_range.begin + cur_slice_offset_,
             read_size);
      cur_slice_offset_ += read_size;
      bytes_read += read_size;

      // Should have either read all of the chunk or completed reading now.
      PERFETTO_DCHECK(cur_slice_offset_ == cur_slice_range.size() ||
                      bytes_read == num_bytes);
    }
    return bytes_read;
  }

  size_t TotalUsedSize() const {
    size_t used_size = 0;
    for (const auto& slice : buffer_slices_) {
      used_size += slice.GetUsedRange().size();
    }
    return used_size;
  }

  bool DidReadAllData() const {
    if (cur_slice_ == buffer_slices_.end())
      return true;

    const auto next_slice = cur_slice_ + 1;
    return next_slice == buffer_slices_.end() &&
           cur_slice_->GetUsedRange().size() == cur_slice_offset_;
  }

 private:
  const std::vector<protozero::ScatteredHeapBuffer::Slice>& buffer_slices_;

  // Iterator pointing to slice in |buffer_slices_| that we're currently reading
  // from.
  std::vector<protozero::ScatteredHeapBuffer::Slice>::const_iterator cur_slice_;
  // Read offset in the current slice in bytes.
  size_t cur_slice_offset_ = 0;
};

}  // namespace

StartupTraceWriter::StartupTraceWriter(
    std::shared_ptr<StartupTraceWriterRegistryHandle> registry_handle)
    : registry_handle_(std::move(registry_handle)),
      memory_buffer_(new protozero::ScatteredHeapBuffer()),
      memory_stream_writer_(
          new protozero::ScatteredStreamWriter(memory_buffer_.get())) {
  memory_buffer_->set_writer(memory_stream_writer_.get());
  PERFETTO_DETACH_FROM_THREAD(writer_thread_checker_);
}

StartupTraceWriter::StartupTraceWriter(
    std::unique_ptr<TraceWriter> trace_writer)
    : was_bound_(true), trace_writer_(std::move(trace_writer)) {}

StartupTraceWriter::~StartupTraceWriter() {
  // Should have been returned to the registry before destruction.
  PERFETTO_DCHECK(!registry_handle_);
}

// static
void StartupTraceWriter::ReturnToRegistry(
    std::unique_ptr<StartupTraceWriter> writer) {
  auto registry_handle = std::move(writer->registry_handle_);
  if (registry_handle) {
    // May destroy |writer|.
    registry_handle->ReturnWriterToRegistry(std::move(writer));
  }
}

bool StartupTraceWriter::BindToArbiter(SharedMemoryArbiterImpl* arbiter,
                                       BufferID target_buffer) {
  // Create and destroy trace writer without holding lock, since this will post
  // a task and task posting may trigger a trace event, which would cause a
  // deadlock. This may create a few more trace writers than necessary in cases
  // where a concurrent write is in progress (other than causing some
  // computational overhead, this is not problematic).
  auto trace_writer = arbiter->CreateTraceWriter(target_buffer);

  {
    std::lock_guard<std::mutex> lock(lock_);

    PERFETTO_DCHECK(!trace_writer_);

    // Can't bind while the writer thread is writing.
    if (write_in_progress_)
      return false;

    // If there's a pending trace packet, it should have been completed by the
    // writer thread before write_in_progress_ is reset.
    if (cur_packet_) {
      PERFETTO_DCHECK(cur_packet_->is_finalized());
      cur_packet_.reset();
    }

    trace_writer_ = std::move(trace_writer);
    ChunkID next_chunk_id = CommitLocalBufferChunks(
        arbiter, trace_writer_->writer_id(), target_buffer);

    // The real TraceWriter should start writing at the subsequent chunk ID.
    bool success = trace_writer_->SetFirstChunkId(next_chunk_id);
    PERFETTO_DCHECK(success);

    memory_stream_writer_.reset();
    memory_buffer_.reset();
  }

  return true;
}

TraceWriter::TracePacketHandle StartupTraceWriter::NewTracePacket() {
  PERFETTO_DCHECK_THREAD(writer_thread_checker_);

  // Check if we are already bound without grabbing the lock. This is an
  // optimization to avoid any locking in the common case where the proxy was
  // bound some time ago.
  if (PERFETTO_LIKELY(was_bound_)) {
    PERFETTO_DCHECK(!cur_packet_);
    PERFETTO_DCHECK(trace_writer_);
    return trace_writer_->NewTracePacket();
  }

  // Now grab the lock and safely check whether we are still unbound.
  {
    std::unique_lock<std::mutex> lock(lock_);
    if (trace_writer_) {
      PERFETTO_DCHECK(!cur_packet_);
      // Set the |was_bound_| flag to avoid locking in future calls to
      // NewTracePacket().
      was_bound_ = true;
      // Don't hold the lock while calling NewTracePacket() on |trace_writer_|.
      // This is safe because |trace_writer_| remains valid once set. It also
      // avoids deadlocks that may be caused by holding the lock while waiting
      // for a new SMB chunk in |trace_writer_|.
      lock.unlock();
      return trace_writer_->NewTracePacket();
    }
    // Not bound. Make sure it stays this way until the TracePacketHandle goes
    // out of scope by setting |write_in_progress_|.
    PERFETTO_DCHECK(!write_in_progress_);
    write_in_progress_ = true;
  }

  // Write to the local buffer.
  if (cur_packet_) {
    // If we hit this, the caller is calling NewTracePacket() without having
    // finalized the previous packet.
    PERFETTO_DCHECK(cur_packet_->is_finalized());
  } else {
    cur_packet_.reset(new protos::pbzero::TracePacket());
  }
  cur_packet_->Reset(memory_stream_writer_.get());
  TraceWriter::TracePacketHandle handle(cur_packet_.get());
  // |this| outlives the packet handle.
  handle.set_finalization_listener(this);
  return handle;
}

void StartupTraceWriter::Flush(std::function<void()> callback) {
  PERFETTO_DCHECK_THREAD(writer_thread_checker_);
  // It's fine to check |was_bound_| instead of acquiring the lock because
  // |trace_writer_| will only need flushing after the first trace packet was
  // written to it and |was_bound_| is set.
  if (PERFETTO_LIKELY(was_bound_)) {
    PERFETTO_DCHECK(trace_writer_);
    return trace_writer_->Flush(std::move(callback));
  }

  // Can't flush while unbound.
  if (callback)
    callback();
}

WriterID StartupTraceWriter::writer_id() const {
  PERFETTO_DCHECK_THREAD(writer_thread_checker_);
  // We can't acquire the lock because this is a const method. So we'll only
  // proxy to |trace_writer_| once we have written the first packet to it
  // instead.
  if (PERFETTO_LIKELY(was_bound_)) {
    PERFETTO_DCHECK(trace_writer_);
    return trace_writer_->writer_id();
  }
  return 0;
}

uint64_t StartupTraceWriter::written() const {
  PERFETTO_DCHECK_THREAD(writer_thread_checker_);
  // We can't acquire the lock because this is a const method. So we'll only
  // proxy to |trace_writer_| once we have written the first packet to it
  // instead.
  if (PERFETTO_LIKELY(was_bound_)) {
    PERFETTO_DCHECK(trace_writer_);
    return trace_writer_->written();
  }
  return 0;
}

size_t StartupTraceWriter::used_buffer_size() {
  PERFETTO_DCHECK_THREAD(writer_thread_checker_);
  if (PERFETTO_LIKELY(was_bound_))
    return 0;

  std::lock_guard<std::mutex> lock(lock_);
  if (trace_writer_)
    return 0;

  size_t used_size = 0;
  memory_buffer_->AdjustUsedSizeOfCurrentSlice();
  for (const auto& slice : memory_buffer_->slices()) {
    used_size += slice.GetUsedRange().size();
  }
  return used_size;
}

void StartupTraceWriter::OnMessageFinalized(protozero::Message* message) {
  PERFETTO_DCHECK(cur_packet_.get() == message);
  PERFETTO_DCHECK(cur_packet_->is_finalized());
  // Finalize() is a no-op because the packet is already finalized.
  uint32_t packet_size = cur_packet_->Finalize();
  packet_sizes_.push_back(packet_size);

  // Write is complete, reset the flag to allow binding.
  std::lock_guard<std::mutex> lock(lock_);
  PERFETTO_DCHECK(write_in_progress_);
  write_in_progress_ = false;
}

ChunkID StartupTraceWriter::CommitLocalBufferChunks(
    SharedMemoryArbiterImpl* arbiter,
    WriterID writer_id,
    BufferID target_buffer) {
  // TODO(eseckler): Write and commit these chunks asynchronously. This would
  // require that the service is informed of the missing initial chunks, e.g. by
  // committing our first chunk here before the new trace writer has a chance to
  // commit its first chunk. Otherwise the service wouldn't know to wait for our
  // chunks.

  if (packet_sizes_.empty() || !writer_id)
    return 0;

  memory_buffer_->AdjustUsedSizeOfCurrentSlice();
  LocalBufferReader local_buffer_reader(memory_buffer_.get());

  PERFETTO_DCHECK(local_buffer_reader.TotalUsedSize() ==
                  std::accumulate(packet_sizes_.begin(), packet_sizes_.end(),
                                  static_cast<size_t>(0u)));

  ChunkID next_chunk_id = 0;
  SharedMemoryABI::Chunk cur_chunk =
      NewChunk(arbiter, writer_id, next_chunk_id++, false);

  size_t max_payload_size = cur_chunk.payload_size();
  size_t cur_payload_size = 0;
  uint16_t cur_num_packets = 0;
  size_t total_num_packets = packet_sizes_.size();
  PatchList empty_patch_list;
  for (size_t packet_idx = 0; packet_idx < total_num_packets; packet_idx++) {
    uint32_t packet_size = packet_sizes_[packet_idx];
    uint32_t remaining_packet_size = packet_size;
    ++cur_num_packets;
    do {
      uint32_t fragment_size = static_cast<uint32_t>(
          std::min(static_cast<size_t>(remaining_packet_size),
                   max_payload_size - cur_payload_size -
                       SharedMemoryABI::kPacketHeaderSize));
      // Write packet header, i.e. the fragment size.
      protozero::proto_utils::WriteRedundantVarInt(
          fragment_size, cur_chunk.payload_begin() + cur_payload_size);
      cur_payload_size += SharedMemoryABI::kPacketHeaderSize;

      // Copy packet content into the chunk.
      size_t bytes_read = local_buffer_reader.ReadBytes(
          &cur_chunk, fragment_size, cur_payload_size);
      PERFETTO_DCHECK(bytes_read == fragment_size);

      cur_payload_size += fragment_size;
      remaining_packet_size -= fragment_size;

      bool last_write =
          packet_idx == total_num_packets - 1 && remaining_packet_size == 0;

      // We should return the current chunk if we've filled its payload, reached
      // the maximum number of packets, or wrote everything we wanted to.
      bool return_chunk =
          cur_payload_size >=
              max_payload_size - SharedMemoryABI::kPacketHeaderSize ||
          cur_num_packets == ChunkHeader::Packets::kMaxCount || last_write;

      if (return_chunk) {
        auto new_packet_count =
            cur_chunk.IncreasePacketCountTo(cur_num_packets);
        PERFETTO_DCHECK(new_packet_count == cur_num_packets);

        bool is_fragmenting = remaining_packet_size > 0;
        if (is_fragmenting) {
          PERFETTO_DCHECK(cur_payload_size == max_payload_size);
          cur_chunk.SetFlag(ChunkHeader::kLastPacketContinuesOnNextChunk);
        }

        arbiter->ReturnCompletedChunk(std::move(cur_chunk), target_buffer,
                                      &empty_patch_list);

        // Avoid creating a new chunk after the last write.
        if (!last_write) {
          cur_chunk =
              NewChunk(arbiter, writer_id, next_chunk_id++, is_fragmenting);
          max_payload_size = cur_chunk.payload_size();
          cur_payload_size = 0;
          cur_num_packets = is_fragmenting ? 1 : 0;
        } else {
          PERFETTO_DCHECK(!is_fragmenting);
        }
      }
    } while (remaining_packet_size > 0);
  }

  // The last chunk should have been returned.
  PERFETTO_DCHECK(!cur_chunk.is_valid());
  // We should have read all data from the local buffer.
  PERFETTO_DCHECK(local_buffer_reader.DidReadAllData());

  return next_chunk_id;
}

}  // namespace perfetto
// gen_amalgamated begin source: src/tracing/core/startup_trace_writer_registry.cc
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/startup_trace_writer_registry.h"

#include <functional>

// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/base/task_runner.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/startup_trace_writer.h"
// gen_amalgamated expanded: #include "src/tracing/core/shared_memory_arbiter_impl.h"

using ChunkHeader = perfetto::SharedMemoryABI::ChunkHeader;

namespace perfetto {

StartupTraceWriterRegistryHandle::StartupTraceWriterRegistryHandle(
    StartupTraceWriterRegistry* registry)
    : registry_(registry) {}

void StartupTraceWriterRegistryHandle::ReturnWriterToRegistry(
    std::unique_ptr<StartupTraceWriter> writer) {
  std::lock_guard<std::mutex> lock(lock_);
  if (registry_)
    registry_->ReturnTraceWriter(std::move(writer));
}

void StartupTraceWriterRegistryHandle::OnRegistryDestroyed() {
  std::lock_guard<std::mutex> lock(lock_);
  registry_ = nullptr;
}

StartupTraceWriterRegistry::StartupTraceWriterRegistry()
    : handle_(std::make_shared<StartupTraceWriterRegistryHandle>(this)) {}

StartupTraceWriterRegistry::~StartupTraceWriterRegistry() {
  handle_->OnRegistryDestroyed();
}

std::unique_ptr<StartupTraceWriter>
StartupTraceWriterRegistry::CreateUnboundTraceWriter() {
  std::lock_guard<std::mutex> lock(lock_);
  PERFETTO_DCHECK(!arbiter_);  // Should only be called while unbound.
  std::unique_ptr<StartupTraceWriter> writer(new StartupTraceWriter(handle_));
  unbound_writers_.insert(writer.get());
  return writer;
}

void StartupTraceWriterRegistry::ReturnTraceWriter(
    std::unique_ptr<StartupTraceWriter> trace_writer) {
  std::lock_guard<std::mutex> lock(lock_);
  PERFETTO_DCHECK(!trace_writer->write_in_progress_);

  // If the registry is already bound, but the writer wasn't, bind it now.
  if (arbiter_) {
    auto it = unbound_writers_.find(trace_writer.get());
    if (it == unbound_writers_.end()) {
      // Nothing to do, the writer was already bound.
      return;
    }

    // This should succeed since nobody can write to this writer concurrently.
    bool success = trace_writer->BindToArbiter(arbiter_, target_buffer_);
    PERFETTO_DCHECK(success);
    unbound_writers_.erase(it);

    OnUnboundWritersRemovedLocked();
    return;
  }

  // If the registry was not bound yet, keep the writer alive until it is.
  PERFETTO_DCHECK(unbound_writers_.count(trace_writer.get()));
  unbound_writers_.erase(trace_writer.get());
  unbound_owned_writers_.push_back(std::move(trace_writer));
}

void StartupTraceWriterRegistry::BindToArbiter(
    SharedMemoryArbiterImpl* arbiter,
    BufferID target_buffer,
    base::TaskRunner* task_runner,
    std::function<void(StartupTraceWriterRegistry*)> on_bound_callback) {
  std::vector<std::unique_ptr<StartupTraceWriter>> unbound_owned_writers;
  {
    std::lock_guard<std::mutex> lock(lock_);
    PERFETTO_DCHECK(!arbiter_);
    arbiter_ = arbiter;
    target_buffer_ = target_buffer;
    task_runner_ = task_runner;
    // Weakptrs should be valid on |task_runner|. For this, the factory needs to
    // be created on |task_runner|, i.e. BindToArbiter must be called on
    // |task_runner|.
    PERFETTO_DCHECK(task_runner_->RunsTasksOnCurrentThread());
    weak_ptr_factory_.reset(
        new base::WeakPtrFactory<StartupTraceWriterRegistry>(this));
    on_bound_callback_ = std::move(on_bound_callback);
    // We can't destroy the writers while holding |lock_|, so we swap them out
    // here instead. After we are bound, no more writers can be added to the
    // list.
    unbound_owned_writers.swap(unbound_owned_writers_);
  }

  // Bind and destroy the owned writers.
  for (const auto& writer : unbound_owned_writers) {
    // This should succeed since nobody can write to these writers concurrently.
    bool success = writer->BindToArbiter(arbiter_, target_buffer_);
    PERFETTO_DCHECK(success);
  }
  unbound_owned_writers.clear();

  TryBindWriters();
}

void StartupTraceWriterRegistry::TryBindWriters() {
  std::lock_guard<std::mutex> lock(lock_);
  for (auto it = unbound_writers_.begin(); it != unbound_writers_.end();) {
    if ((*it)->BindToArbiter(arbiter_, target_buffer_)) {
      it = unbound_writers_.erase(it);
    } else {
      it++;
    }
  }
  if (!unbound_writers_.empty()) {
    auto weak_this = weak_ptr_factory_->GetWeakPtr();
    task_runner_->PostTask([weak_this] {
      if (weak_this)
        weak_this->TryBindWriters();
    });
  }
  OnUnboundWritersRemovedLocked();
}

void StartupTraceWriterRegistry::OnUnboundWritersRemovedLocked() {
  if (!unbound_writers_.empty() || !task_runner_ || !on_bound_callback_)
    return;

  PERFETTO_DCHECK(weak_ptr_factory_);
  auto weak_this = weak_ptr_factory_->GetWeakPtr();
  // Run callback in PostTask() since the callback may delete |this| and thus
  // might otherwise cause a deadlock.
  auto callback = on_bound_callback_;
  on_bound_callback_ = nullptr;
  task_runner_->PostTask([weak_this, callback]() {
    if (!weak_this)
      return;
    // Note: callback may delete |this|.
    callback(weak_this.get());
  });
}

}  // namespace perfetto
// gen_amalgamated begin source: src/tracing/core/test_config.cc
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*******************************************************************************
 * AUTOGENERATED - DO NOT EDIT
 *******************************************************************************
 * This file has been generated from the protobuf message
 * perfetto/config/test_config.proto
 * by
 * ../../tools/proto_to_cpp/proto_to_cpp.cc.
 * If you need to make changes here, change the .proto file and then run
 * ./tools/gen_tracing_cpp_headers_from_protos
 */

// gen_amalgamated expanded: #include "perfetto/tracing/core/test_config.h"

// gen_amalgamated expanded: #include "perfetto/config/test_config.pb.h"

namespace perfetto {

TestConfig::TestConfig() = default;
TestConfig::~TestConfig() = default;
TestConfig::TestConfig(const TestConfig&) = default;
TestConfig& TestConfig::operator=(const TestConfig&) = default;
TestConfig::TestConfig(TestConfig&&) noexcept = default;
TestConfig& TestConfig::operator=(TestConfig&&) = default;

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
bool TestConfig::operator==(const TestConfig& other) const {
  return (message_count_ == other.message_count_) &&
         (max_messages_per_second_ == other.max_messages_per_second_) &&
         (seed_ == other.seed_) && (message_size_ == other.message_size_) &&
         (send_batch_on_register_ == other.send_batch_on_register_) &&
         (dummy_fields_ == other.dummy_fields_);
}
#pragma GCC diagnostic pop

void TestConfig::ParseRawProto(const std::string& raw) {
  perfetto::protos::TestConfig proto;
  proto.ParseFromString(raw);
  FromProto(proto);
}

void TestConfig::FromProto(const perfetto::protos::TestConfig& proto) {
  static_assert(sizeof(message_count_) == sizeof(proto.message_count()),
                "size mismatch");
  message_count_ = static_cast<decltype(message_count_)>(proto.message_count());

  static_assert(sizeof(max_messages_per_second_) ==
                    sizeof(proto.max_messages_per_second()),
                "size mismatch");
  max_messages_per_second_ = static_cast<decltype(max_messages_per_second_)>(
      proto.max_messages_per_second());

  static_assert(sizeof(seed_) == sizeof(proto.seed()), "size mismatch");
  seed_ = static_cast<decltype(seed_)>(proto.seed());

  static_assert(sizeof(message_size_) == sizeof(proto.message_size()),
                "size mismatch");
  message_size_ = static_cast<decltype(message_size_)>(proto.message_size());

  static_assert(
      sizeof(send_batch_on_register_) == sizeof(proto.send_batch_on_register()),
      "size mismatch");
  send_batch_on_register_ = static_cast<decltype(send_batch_on_register_)>(
      proto.send_batch_on_register());

  dummy_fields_->FromProto(proto.dummy_fields());
  unknown_fields_ = proto.unknown_fields();
}

void TestConfig::ToProto(perfetto::protos::TestConfig* proto) const {
  proto->Clear();

  static_assert(sizeof(message_count_) == sizeof(proto->message_count()),
                "size mismatch");
  proto->set_message_count(
      static_cast<decltype(proto->message_count())>(message_count_));

  static_assert(sizeof(max_messages_per_second_) ==
                    sizeof(proto->max_messages_per_second()),
                "size mismatch");
  proto->set_max_messages_per_second(
      static_cast<decltype(proto->max_messages_per_second())>(
          max_messages_per_second_));

  static_assert(sizeof(seed_) == sizeof(proto->seed()), "size mismatch");
  proto->set_seed(static_cast<decltype(proto->seed())>(seed_));

  static_assert(sizeof(message_size_) == sizeof(proto->message_size()),
                "size mismatch");
  proto->set_message_size(
      static_cast<decltype(proto->message_size())>(message_size_));

  static_assert(sizeof(send_batch_on_register_) ==
                    sizeof(proto->send_batch_on_register()),
                "size mismatch");
  proto->set_send_batch_on_register(
      static_cast<decltype(proto->send_batch_on_register())>(
          send_batch_on_register_));

  dummy_fields_->ToProto(proto->mutable_dummy_fields());
  *(proto->mutable_unknown_fields()) = unknown_fields_;
}

TestConfig::DummyFields::DummyFields() = default;
TestConfig::DummyFields::~DummyFields() = default;
TestConfig::DummyFields::DummyFields(const TestConfig::DummyFields&) = default;
TestConfig::DummyFields& TestConfig::DummyFields::operator=(
    const TestConfig::DummyFields&) = default;
TestConfig::DummyFields::DummyFields(TestConfig::DummyFields&&) noexcept =
    default;
TestConfig::DummyFields& TestConfig::DummyFields::operator=(
    TestConfig::DummyFields&&) = default;

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
bool TestConfig::DummyFields::operator==(
    const TestConfig::DummyFields& other) const {
  return (field_uint32_ == other.field_uint32_) &&
         (field_int32_ == other.field_int32_) &&
         (field_uint64_ == other.field_uint64_) &&
         (field_int64_ == other.field_int64_) &&
         (field_fixed64_ == other.field_fixed64_) &&
         (field_sfixed64_ == other.field_sfixed64_) &&
         (field_fixed32_ == other.field_fixed32_) &&
         (field_sfixed32_ == other.field_sfixed32_) &&
         (field_double_ == other.field_double_) &&
         (field_float_ == other.field_float_) &&
         (field_sint64_ == other.field_sint64_) &&
         (field_sint32_ == other.field_sint32_) &&
         (field_string_ == other.field_string_) &&
         (field_bytes_ == other.field_bytes_);
}
#pragma GCC diagnostic pop

void TestConfig::DummyFields::ParseRawProto(const std::string& raw) {
  perfetto::protos::TestConfig_DummyFields proto;
  proto.ParseFromString(raw);
  FromProto(proto);
}

void TestConfig::DummyFields::FromProto(
    const perfetto::protos::TestConfig_DummyFields& proto) {
  static_assert(sizeof(field_uint32_) == sizeof(proto.field_uint32()),
                "size mismatch");
  field_uint32_ = static_cast<decltype(field_uint32_)>(proto.field_uint32());

  static_assert(sizeof(field_int32_) == sizeof(proto.field_int32()),
                "size mismatch");
  field_int32_ = static_cast<decltype(field_int32_)>(proto.field_int32());

  static_assert(sizeof(field_uint64_) == sizeof(proto.field_uint64()),
                "size mismatch");
  field_uint64_ = static_cast<decltype(field_uint64_)>(proto.field_uint64());

  static_assert(sizeof(field_int64_) == sizeof(proto.field_int64()),
                "size mismatch");
  field_int64_ = static_cast<decltype(field_int64_)>(proto.field_int64());

  static_assert(sizeof(field_fixed64_) == sizeof(proto.field_fixed64()),
                "size mismatch");
  field_fixed64_ = static_cast<decltype(field_fixed64_)>(proto.field_fixed64());

  static_assert(sizeof(field_sfixed64_) == sizeof(proto.field_sfixed64()),
                "size mismatch");
  field_sfixed64_ =
      static_cast<decltype(field_sfixed64_)>(proto.field_sfixed64());

  static_assert(sizeof(field_fixed32_) == sizeof(proto.field_fixed32()),
                "size mismatch");
  field_fixed32_ = static_cast<decltype(field_fixed32_)>(proto.field_fixed32());

  static_assert(sizeof(field_sfixed32_) == sizeof(proto.field_sfixed32()),
                "size mismatch");
  field_sfixed32_ =
      static_cast<decltype(field_sfixed32_)>(proto.field_sfixed32());

  static_assert(sizeof(field_double_) == sizeof(proto.field_double()),
                "size mismatch");
  field_double_ = static_cast<decltype(field_double_)>(proto.field_double());

  static_assert(sizeof(field_float_) == sizeof(proto.field_float()),
                "size mismatch");
  field_float_ = static_cast<decltype(field_float_)>(proto.field_float());

  static_assert(sizeof(field_sint64_) == sizeof(proto.field_sint64()),
                "size mismatch");
  field_sint64_ = static_cast<decltype(field_sint64_)>(proto.field_sint64());

  static_assert(sizeof(field_sint32_) == sizeof(proto.field_sint32()),
                "size mismatch");
  field_sint32_ = static_cast<decltype(field_sint32_)>(proto.field_sint32());

  static_assert(sizeof(field_string_) == sizeof(proto.field_string()),
                "size mismatch");
  field_string_ = static_cast<decltype(field_string_)>(proto.field_string());

  static_assert(sizeof(field_bytes_) == sizeof(proto.field_bytes()),
                "size mismatch");
  field_bytes_ = static_cast<decltype(field_bytes_)>(proto.field_bytes());
  unknown_fields_ = proto.unknown_fields();
}

void TestConfig::DummyFields::ToProto(
    perfetto::protos::TestConfig_DummyFields* proto) const {
  proto->Clear();

  static_assert(sizeof(field_uint32_) == sizeof(proto->field_uint32()),
                "size mismatch");
  proto->set_field_uint32(
      static_cast<decltype(proto->field_uint32())>(field_uint32_));

  static_assert(sizeof(field_int32_) == sizeof(proto->field_int32()),
                "size mismatch");
  proto->set_field_int32(
      static_cast<decltype(proto->field_int32())>(field_int32_));

  static_assert(sizeof(field_uint64_) == sizeof(proto->field_uint64()),
                "size mismatch");
  proto->set_field_uint64(
      static_cast<decltype(proto->field_uint64())>(field_uint64_));

  static_assert(sizeof(field_int64_) == sizeof(proto->field_int64()),
                "size mismatch");
  proto->set_field_int64(
      static_cast<decltype(proto->field_int64())>(field_int64_));

  static_assert(sizeof(field_fixed64_) == sizeof(proto->field_fixed64()),
                "size mismatch");
  proto->set_field_fixed64(
      static_cast<decltype(proto->field_fixed64())>(field_fixed64_));

  static_assert(sizeof(field_sfixed64_) == sizeof(proto->field_sfixed64()),
                "size mismatch");
  proto->set_field_sfixed64(
      static_cast<decltype(proto->field_sfixed64())>(field_sfixed64_));

  static_assert(sizeof(field_fixed32_) == sizeof(proto->field_fixed32()),
                "size mismatch");
  proto->set_field_fixed32(
      static_cast<decltype(proto->field_fixed32())>(field_fixed32_));

  static_assert(sizeof(field_sfixed32_) == sizeof(proto->field_sfixed32()),
                "size mismatch");
  proto->set_field_sfixed32(
      static_cast<decltype(proto->field_sfixed32())>(field_sfixed32_));

  static_assert(sizeof(field_double_) == sizeof(proto->field_double()),
                "size mismatch");
  proto->set_field_double(
      static_cast<decltype(proto->field_double())>(field_double_));

  static_assert(sizeof(field_float_) == sizeof(proto->field_float()),
                "size mismatch");
  proto->set_field_float(
      static_cast<decltype(proto->field_float())>(field_float_));

  static_assert(sizeof(field_sint64_) == sizeof(proto->field_sint64()),
                "size mismatch");
  proto->set_field_sint64(
      static_cast<decltype(proto->field_sint64())>(field_sint64_));

  static_assert(sizeof(field_sint32_) == sizeof(proto->field_sint32()),
                "size mismatch");
  proto->set_field_sint32(
      static_cast<decltype(proto->field_sint32())>(field_sint32_));

  static_assert(sizeof(field_string_) == sizeof(proto->field_string()),
                "size mismatch");
  proto->set_field_string(
      static_cast<decltype(proto->field_string())>(field_string_));

  static_assert(sizeof(field_bytes_) == sizeof(proto->field_bytes()),
                "size mismatch");
  proto->set_field_bytes(
      static_cast<decltype(proto->field_bytes())>(field_bytes_));
  *(proto->mutable_unknown_fields()) = unknown_fields_;
}

}  // namespace perfetto
// gen_amalgamated begin source: src/tracing/core/trace_buffer.cc
// gen_amalgamated begin header: src/tracing/core/trace_buffer.h
// gen_amalgamated begin header: include/perfetto/ext/tracing/core/trace_stats.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*******************************************************************************
 * AUTOGENERATED - DO NOT EDIT
 *******************************************************************************
 * This file has been generated from the protobuf message
 * perfetto/common/trace_stats.proto
 * by
 * ../../tools/proto_to_cpp/proto_to_cpp.cc.
 * If you need to make changes here, change the .proto file and then run
 * ./tools/gen_tracing_cpp_headers_from_protos
 */

#ifndef INCLUDE_PERFETTO_EXT_TRACING_CORE_TRACE_STATS_H_
#define INCLUDE_PERFETTO_EXT_TRACING_CORE_TRACE_STATS_H_

#include <stdint.h>
#include <string>
#include <type_traits>
#include <vector>

// gen_amalgamated expanded: #include "perfetto/base/copyable_ptr.h"
// gen_amalgamated expanded: #include "perfetto/base/export.h"

// Forward declarations for protobuf types.
namespace perfetto {
namespace protos {
class TraceStats;
class TraceStats_BufferStats;
}  // namespace protos
}  // namespace perfetto

namespace perfetto {
class TraceStats;

class PERFETTO_EXPORT TraceStats {
 public:
  class PERFETTO_EXPORT BufferStats {
   public:
    BufferStats();
    ~BufferStats();
    BufferStats(BufferStats&&) noexcept;
    BufferStats& operator=(BufferStats&&);
    BufferStats(const BufferStats&);
    BufferStats& operator=(const BufferStats&);
    bool operator==(const BufferStats&) const;
    bool operator!=(const BufferStats& other) const {
      return !(*this == other);
    }

    // Raw proto decoding.
    void ParseRawProto(const std::string&);
    // Conversion methods from/to the corresponding protobuf types.
    void FromProto(const perfetto::protos::TraceStats_BufferStats&);
    void ToProto(perfetto::protos::TraceStats_BufferStats*) const;

    uint64_t buffer_size() const { return buffer_size_; }
    void set_buffer_size(uint64_t value) { buffer_size_ = value; }

    uint64_t bytes_written() const { return bytes_written_; }
    void set_bytes_written(uint64_t value) { bytes_written_ = value; }

    uint64_t bytes_overwritten() const { return bytes_overwritten_; }
    void set_bytes_overwritten(uint64_t value) { bytes_overwritten_ = value; }

    uint64_t bytes_read() const { return bytes_read_; }
    void set_bytes_read(uint64_t value) { bytes_read_ = value; }

    uint64_t padding_bytes_written() const { return padding_bytes_written_; }
    void set_padding_bytes_written(uint64_t value) {
      padding_bytes_written_ = value;
    }

    uint64_t padding_bytes_cleared() const { return padding_bytes_cleared_; }
    void set_padding_bytes_cleared(uint64_t value) {
      padding_bytes_cleared_ = value;
    }

    uint64_t chunks_written() const { return chunks_written_; }
    void set_chunks_written(uint64_t value) { chunks_written_ = value; }

    uint64_t chunks_rewritten() const { return chunks_rewritten_; }
    void set_chunks_rewritten(uint64_t value) { chunks_rewritten_ = value; }

    uint64_t chunks_overwritten() const { return chunks_overwritten_; }
    void set_chunks_overwritten(uint64_t value) { chunks_overwritten_ = value; }

    uint64_t chunks_discarded() const { return chunks_discarded_; }
    void set_chunks_discarded(uint64_t value) { chunks_discarded_ = value; }

    uint64_t chunks_read() const { return chunks_read_; }
    void set_chunks_read(uint64_t value) { chunks_read_ = value; }

    uint64_t chunks_committed_out_of_order() const {
      return chunks_committed_out_of_order_;
    }
    void set_chunks_committed_out_of_order(uint64_t value) {
      chunks_committed_out_of_order_ = value;
    }

    uint64_t write_wrap_count() const { return write_wrap_count_; }
    void set_write_wrap_count(uint64_t value) { write_wrap_count_ = value; }

    uint64_t patches_succeeded() const { return patches_succeeded_; }
    void set_patches_succeeded(uint64_t value) { patches_succeeded_ = value; }

    uint64_t patches_failed() const { return patches_failed_; }
    void set_patches_failed(uint64_t value) { patches_failed_ = value; }

    uint64_t readaheads_succeeded() const { return readaheads_succeeded_; }
    void set_readaheads_succeeded(uint64_t value) {
      readaheads_succeeded_ = value;
    }

    uint64_t readaheads_failed() const { return readaheads_failed_; }
    void set_readaheads_failed(uint64_t value) { readaheads_failed_ = value; }

    uint64_t abi_violations() const { return abi_violations_; }
    void set_abi_violations(uint64_t value) { abi_violations_ = value; }

   private:
    uint64_t buffer_size_{};
    uint64_t bytes_written_{};
    uint64_t bytes_overwritten_{};
    uint64_t bytes_read_{};
    uint64_t padding_bytes_written_{};
    uint64_t padding_bytes_cleared_{};
    uint64_t chunks_written_{};
    uint64_t chunks_rewritten_{};
    uint64_t chunks_overwritten_{};
    uint64_t chunks_discarded_{};
    uint64_t chunks_read_{};
    uint64_t chunks_committed_out_of_order_{};
    uint64_t write_wrap_count_{};
    uint64_t patches_succeeded_{};
    uint64_t patches_failed_{};
    uint64_t readaheads_succeeded_{};
    uint64_t readaheads_failed_{};
    uint64_t abi_violations_{};

    // Allows to preserve unknown protobuf fields for compatibility
    // with future versions of .proto files.
    std::string unknown_fields_;
  };

  TraceStats();
  ~TraceStats();
  TraceStats(TraceStats&&) noexcept;
  TraceStats& operator=(TraceStats&&);
  TraceStats(const TraceStats&);
  TraceStats& operator=(const TraceStats&);
  bool operator==(const TraceStats&) const;
  bool operator!=(const TraceStats& other) const { return !(*this == other); }

  // Raw proto decoding.
  void ParseRawProto(const std::string&);
  // Conversion methods from/to the corresponding protobuf types.
  void FromProto(const perfetto::protos::TraceStats&);
  void ToProto(perfetto::protos::TraceStats*) const;

  int buffer_stats_size() const {
    return static_cast<int>(buffer_stats_.size());
  }
  const std::vector<BufferStats>& buffer_stats() const { return buffer_stats_; }
  std::vector<BufferStats>* mutable_buffer_stats() { return &buffer_stats_; }
  void clear_buffer_stats() { buffer_stats_.clear(); }
  BufferStats* add_buffer_stats() {
    buffer_stats_.emplace_back();
    return &buffer_stats_.back();
  }

  uint32_t producers_connected() const { return producers_connected_; }
  void set_producers_connected(uint32_t value) { producers_connected_ = value; }

  uint64_t producers_seen() const { return producers_seen_; }
  void set_producers_seen(uint64_t value) { producers_seen_ = value; }

  uint32_t data_sources_registered() const { return data_sources_registered_; }
  void set_data_sources_registered(uint32_t value) {
    data_sources_registered_ = value;
  }

  uint64_t data_sources_seen() const { return data_sources_seen_; }
  void set_data_sources_seen(uint64_t value) { data_sources_seen_ = value; }

  uint32_t tracing_sessions() const { return tracing_sessions_; }
  void set_tracing_sessions(uint32_t value) { tracing_sessions_ = value; }

  uint32_t total_buffers() const { return total_buffers_; }
  void set_total_buffers(uint32_t value) { total_buffers_ = value; }

  uint64_t chunks_discarded() const { return chunks_discarded_; }
  void set_chunks_discarded(uint64_t value) { chunks_discarded_ = value; }

  uint64_t patches_discarded() const { return patches_discarded_; }
  void set_patches_discarded(uint64_t value) { patches_discarded_ = value; }

 private:
  std::vector<BufferStats> buffer_stats_;
  uint32_t producers_connected_{};
  uint64_t producers_seen_{};
  uint32_t data_sources_registered_{};
  uint64_t data_sources_seen_{};
  uint32_t tracing_sessions_{};
  uint32_t total_buffers_{};
  uint64_t chunks_discarded_{};
  uint64_t patches_discarded_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;
};

}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_TRACING_CORE_TRACE_STATS_H_
/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef SRC_TRACING_CORE_TRACE_BUFFER_H_
#define SRC_TRACING_CORE_TRACE_BUFFER_H_

#include <stdint.h>
#include <string.h>

#include <array>
#include <limits>
#include <map>
#include <tuple>

// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/paged_memory.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/thread_annotations.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/utils.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/basic_types.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/slice.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/trace_stats.h"

namespace perfetto {

class TracePacket;

// The main buffer, owned by the tracing service, where all the trace data is
// ultimately stored into. The service will own several instances of this class,
// at least one per active consumer (as defined in the |buffers| section of
// trace_config.proto) and will copy chunks from the producer's shared memory
// buffers into here when a CommitData IPC is received.
//
// Writing into the buffer
// -----------------------
// Data is copied from the SMB(s) using CopyChunkUntrusted(). The buffer will
// hence contain data coming from different producers and different writer
// sequences, more specifically:
// - The service receives data by several producer(s), identified by their ID.
// - Each producer writes several sequences identified by the same WriterID.
//   (they correspond to TraceWriter instances in the producer).
// - Each Writer writes, in order, several chunks.
// - Each chunk contains zero, one, or more TracePacket(s), or even just
//   fragments of packets (when they span across several chunks).
//
// So at any point in time, the buffer will contain a variable number of logical
// sequences identified by the {ProducerID, WriterID} tuple. Any given chunk
// will only contain packets (or fragments) belonging to the same sequence.
//
// The buffer operates by default as a ring buffer.
// It has two overwrite policies:
//  1. kOverwrite (default): if the write pointer reaches the read pointer, old
//     unread chunks will be overwritten by new chunks.
//  2. kDiscard: if the write pointer reaches the read pointer, unread chunks
//     are preserved and the new chunks are discarded. Any future write becomes
//     a no-op, even if the reader manages to fully catch up. This is because
//     once a chunk is discarded, the sequence of packets is broken and trying
//     to recover would be too hard (also due to the fact that, at the same
//     time, we allow out-of-order commits and chunk re-writes).
//
// Chunks are (over)written in the same order of the CopyChunkUntrusted() calls.
// When overwriting old content, entire chunks are overwritten or clobbered.
// The buffer never leaves a partial chunk around. Chunks' payload is copied
// as-is, but their header is not and is repacked in order to keep the
// ProducerID around.
//
// Chunks are stored in the buffer next to each other. Each chunk is prefixed by
// an inline header (ChunkRecord), which contains most of the fields of the
// SharedMemoryABI ChunkHeader + the ProducerID + the size of the payload.
// It's a conventional binary object stream essentially, where each ChunkRecord
// tells where it ends and hence where to find the next one, like this:
//
//          .-------------------------. 16 byte boundary
//          | ChunkRecord:   16 bytes |
//          | - chunk id:     4 bytes |
//          | - producer id:  2 bytes |
//          | - writer id:    2 bytes |
//          | - #fragments:   2 bytes |
//    +-----+ - record size:  2 bytes |
//    |     | - flags+pad:    4 bytes |
//    |     +-------------------------+
//    |     |                         |
//    |     :     Chunk payload       :
//    |     |                         |
//    |     +-------------------------+
//    |     |    Optional padding     |
//    +---> +-------------------------+ 16 byte boundary
//          |      ChunkRecord        |
//          :                         :
// Chunks stored in the buffer are always rounded up to 16 bytes (that is
// sizeof(ChunkRecord)), in order to avoid further inner fragmentation.
// Special "padding" chunks can be put in the buffer, e.g. in the case when we
// try to write a chunk of size N while the write pointer is at the end of the
// buffer, but the write pointer is < N bytes from the end (and hence needs to
// wrap over).
// Because of this, the buffer is self-describing: the contents of the buffer
// can be reconstructed by just looking at the buffer content (this will be
// quite useful in future to recover the buffer from crash reports).
//
// However, in order to keep some operations (patching and reading) fast, a
// lookaside index is maintained (in |index_|), keeping each chunk in the buffer
// indexed by their {ProducerID, WriterID, ChunkID} tuple.
//
// Patching data out-of-band
// -------------------------
// This buffer also supports patching chunks' payload out-of-band, after they
// have been stored. This is to allow producers to backfill the "size" fields
// of the protos that spawn across several chunks, when the previous chunks are
// returned to the service. The MaybePatchChunkContents() deals with the fact
// that a chunk might have been lost (because of wrapping) by the time the OOB
// IPC comes.
//
// Reading from the buffer
// -----------------------
// This class supports one reader only (the consumer). Reads are NOT idempotent
// as they move the read cursors around. Reading back the buffer is the most
// conceptually complex part. The ReadNextTracePacket() method operates with
// whole packet granularity. Packets are returned only when all their fragments
// are available.
// This class takes care of:
// - Gluing packets within the same sequence, even if they are not stored
//   adjacently in the buffer.
// - Re-ordering chunks within a sequence (using the ChunkID, which wraps).
// - Detecting holes in packet fragments (because of loss of chunks).
// Reads guarantee that packets for the same sequence are read in FIFO order
// (according to their ChunkID), but don't give any guarantee about the read
// order of packets from different sequences, see comments in
// ReadNextTracePacket() below.
class TraceBuffer {
 public:
  static const size_t InlineChunkHeaderSize;  // For test/fake_packet.{cc,h}.

  // See comment in the header above.
  enum OverwritePolicy { kOverwrite, kDiscard };

  // Argument for out-of-band patches applied through TryPatchChunkContents().
  struct Patch {
    // From SharedMemoryABI::kPacketHeaderSize.
    static constexpr size_t kSize = 4;

    size_t offset_untrusted;
    std::array<uint8_t, kSize> data;
  };

  // Identifiers that are constant for a packet sequence.
  struct PacketSequenceProperties {
    ProducerID producer_id_trusted;
    uid_t producer_uid_trusted;
    WriterID writer_id;
  };

  // Can return nullptr if the memory allocation fails.
  static std::unique_ptr<TraceBuffer> Create(size_t size_in_bytes,
                                             OverwritePolicy = kOverwrite);

  ~TraceBuffer();

  // Copies a Chunk from a producer Shared Memory Buffer into the trace buffer.
  // |src| points to the first packet in the SharedMemoryABI's chunk shared with
  // an untrusted producer. "untrusted" here means: the producer might be
  // malicious and might change |src| concurrently while we read it (internally
  // this method memcpy()-s first the chunk before processing it). None of the
  // arguments should be trusted, unless otherwise stated. We can trust that
  // |src| points to a valid memory area, but not its contents.
  //
  // This method may be called multiple times for the same chunk. In this case,
  // the original chunk's payload will be overridden and its number of fragments
  // and flags adjusted to match |num_fragments| and |chunk_flags|. The service
  // may use this to insert partial chunks (|chunk_complete = false|) before the
  // producer has committed them.
  //
  // If |chunk_complete| is |false|, the TraceBuffer will only consider the
  // first |num_fragments - 1| packets to be complete, since the producer may
  // not have finished writing the latest packet. Reading from a sequence will
  // also not progress past any incomplete chunks until they were rewritten with
  // |chunk_complete = true|, e.g. after a producer's commit.
  //
  // TODO(eseckler): Pass in a PacketStreamProperties instead of individual IDs.
  void CopyChunkUntrusted(ProducerID producer_id_trusted,
                          uid_t producer_uid_trusted,
                          WriterID writer_id,
                          ChunkID chunk_id,
                          uint16_t num_fragments,
                          uint8_t chunk_flags,
                          bool chunk_complete,
                          const uint8_t* src,
                          size_t size);
  // Applies a batch of |patches| to the given chunk, if the given chunk is
  // still in the buffer. Does nothing if the given ChunkID is gone.
  // Returns true if the chunk has been found and patched, false otherwise.
  // |other_patches_pending| is used to determine whether this is the only
  // batch of patches for the chunk or there is more.
  // If |other_patches_pending| == false, the chunk is marked as ready to be
  // consumed. If true, the state of the chunk is not altered.
  bool TryPatchChunkContents(ProducerID,
                             WriterID,
                             ChunkID,
                             const Patch* patches,
                             size_t patches_size,
                             bool other_patches_pending);

  // To read the contents of the buffer the caller needs to:
  //   BeginRead()
  //   while (ReadNextTracePacket(packet_fragments)) { ... }
  // No other calls to any other method should be interleaved between
  // BeginRead() and ReadNextTracePacket().
  // Reads in the TraceBuffer are NOT idempotent.
  void BeginRead();

  // Returns the next packet in the buffer, if any, and the producer_id,
  // producer_uid, and writer_id of the producer/writer that wrote it (as passed
  // in the CopyChunkUntrusted() call). Returns false if no packets can be read
  // at this point. If a packet was read successfully,
  // |previous_packet_on_sequence_dropped| is set to |true| if the previous
  // packet on the sequence was dropped from the buffer before it could be read
  // (e.g. because its chunk was overridden due to the ring buffer wrapping or
  // due to an ABI violation), and to |false| otherwise.
  //
  // This function returns only complete packets. Specifically:
  // When there is at least one complete packet in the buffer, this function
  // returns true and populates the TracePacket argument with the boundaries of
  // each fragment for one packet.
  // TracePacket will have at least one slice when this function returns true.
  // When there are no whole packets eligible to read (e.g. we are still missing
  // fragments) this function returns false.
  // This function guarantees also that packets for a given
  // {ProducerID, WriterID} are read in FIFO order.
  // This function does not guarantee any ordering w.r.t. packets belonging to
  // different WriterID(s). For instance, given the following packets copied
  // into the buffer:
  //   {ProducerID: 1, WriterID: 1}: P1 P2 P3
  //   {ProducerID: 1, WriterID: 2}: P4 P5 P6
  //   {ProducerID: 2, WriterID: 1}: P7 P8 P9
  // The following read sequence is possible:
  //   P1, P4, P7, P2, P3, P5, P8, P9, P6
  // But the following is guaranteed to NOT happen:
  //   P1, P5, P7, P4 (P4 cannot come after P5)
  bool ReadNextTracePacket(TracePacket*,
                           PacketSequenceProperties* sequence_properties,
                           bool* previous_packet_on_sequence_dropped);

  const TraceStats::BufferStats& stats() const { return stats_; }
  size_t size() const { return size_; }

 private:
  friend class TraceBufferTest;

  // ChunkRecord is a Chunk header stored inline in the |data_| buffer, before
  // the chunk payload (the packets' data). The |data_| buffer looks like this:
  // +---------------+------------------++---------------+-----------------+
  // | ChunkRecord 1 | Chunk payload 1  || ChunkRecord 2 | Chunk payload 2 | ...
  // +---------------+------------------++---------------+-----------------+
  // Most of the ChunkRecord fields are copied from SharedMemoryABI::ChunkHeader
  // (the chunk header used in the shared memory buffers).
  // A ChunkRecord can be a special "padding" record. In this case its payload
  // should be ignored and the record should be just skipped.
  //
  // Full page move optimization:
  // This struct has to be exactly (sizeof(PageHeader) + sizeof(ChunkHeader))
  // (from shared_memory_abi.h) to allow full page move optimizations
  // (TODO(primiano): not implemented yet). In the special case of moving a full
  // 4k page that contains only one chunk, in fact, we can just ask the kernel
  // to move the full SHM page (see SPLICE_F_{GIFT,MOVE}) and overlay the
  // ChunkRecord on top of the moved SMB's header (page + chunk header).
  // This special requirement is covered by static_assert(s) in the .cc file.
  struct ChunkRecord {
    explicit ChunkRecord(size_t sz) : flags{0}, is_padding{0} {
      PERFETTO_DCHECK(sz >= sizeof(ChunkRecord) &&
                      sz % sizeof(ChunkRecord) == 0 && sz <= kMaxSize);
      size = static_cast<decltype(size)>(sz);
    }

    bool is_valid() const { return size != 0; }

    // Keep this structure packed and exactly 16 bytes (128 bits) big.

    // [32 bits] Monotonic counter within the same writer_id.
    ChunkID chunk_id = 0;

    // [16 bits] ID of the Producer from which the Chunk was copied from.
    ProducerID producer_id = 0;

    // [16 bits] Unique per Producer (but not within the service).
    // If writer_id == kWriterIdPadding the record should just be skipped.
    WriterID writer_id = 0;

    // Number of fragments contained in the chunk.
    uint16_t num_fragments = 0;

    // Size in bytes, including sizeof(ChunkRecord) itself.
    uint16_t size;

    uint8_t flags : 6;  // See SharedMemoryABI::ChunkHeader::flags.
    uint8_t is_padding : 1;
    uint8_t unused_flag : 1;

    // Not strictly needed, can be reused for more fields in the future. But
    // right now helps to spot chunks in hex dumps.
    char unused[3] = {'C', 'H', 'U'};

    static constexpr size_t kMaxSize =
        std::numeric_limits<decltype(size)>::max();
  };

  // Lookaside index entry. This serves two purposes:
  // 1) Allow a fast lookup of ChunkRecord by their ID (the tuple
  //   {ProducerID, WriterID, ChunkID}). This is used when applying out-of-band
  //   patches to the contents of the chunks after they have been copied into
  //   the TraceBuffer.
  // 2) keep the chunks ordered by their ID. This is used when reading back.
  // 3) Keep metadata about the status of the chunk, e.g. whether the contents
  //    have been read already and should be skipped in a future read pass.
  // This struct should not have any field that is essential for reconstructing
  // the contents of the buffer from a crash dump.
  struct ChunkMeta {
    // Key used for sorting in the map.
    struct Key {
      Key(ProducerID p, WriterID w, ChunkID c)
          : producer_id{p}, writer_id{w}, chunk_id{c} {}

      explicit Key(const ChunkRecord& cr)
          : Key(cr.producer_id, cr.writer_id, cr.chunk_id) {}

      // Note that this sorting doesn't keep into account the fact that ChunkID
      // will wrap over at some point. The extra logic in SequenceIterator deals
      // with that.
      bool operator<(const Key& other) const {
        return std::tie(producer_id, writer_id, chunk_id) <
               std::tie(other.producer_id, other.writer_id, other.chunk_id);
      }

      bool operator==(const Key& other) const {
        return std::tie(producer_id, writer_id, chunk_id) ==
               std::tie(other.producer_id, other.writer_id, other.chunk_id);
      }

      bool operator!=(const Key& other) const { return !(*this == other); }

      // These fields should match at all times the corresponding fields in
      // the |chunk_record|. They are copied here purely for efficiency to avoid
      // dereferencing the buffer all the time.
      ProducerID producer_id;
      WriterID writer_id;
      ChunkID chunk_id;
    };

    enum IndexFlags : uint8_t {
      // If set, the chunk state was kChunkComplete at the time it was copied.
      // If unset, the chunk was still kChunkBeingWritten while copied. When
      // reading from the chunk's sequence, the sequence will not advance past
      // this chunk until this flag is set.
      kComplete = 1 << 0,

      // If set, we skipped the last packet that we read from this chunk e.g.
      // because we it was a continuation from a previous chunk that was dropped
      // or due to an ABI violation.
      kLastReadPacketSkipped = 1 << 1
    };

    ChunkMeta(ChunkRecord* r, uint16_t p, bool complete, uint8_t f, uid_t u)
        : chunk_record{r}, trusted_uid{u}, flags{f}, num_fragments{p} {
      if (complete)
        index_flags = kComplete;
    }

    bool is_complete() const { return index_flags & kComplete; }

    void set_complete(bool complete) {
      if (complete) {
        index_flags |= kComplete;
      } else {
        index_flags &= ~kComplete;
      }
    }

    bool last_read_packet_skipped() const {
      return index_flags & kLastReadPacketSkipped;
    }

    void set_last_read_packet_skipped(bool skipped) {
      if (skipped) {
        index_flags |= kLastReadPacketSkipped;
      } else {
        index_flags &= ~kLastReadPacketSkipped;
      }
    }

    ChunkRecord* const chunk_record;  // Addr of ChunkRecord within |data_|.
    const uid_t trusted_uid;          // uid of the producer.

    // Flags set by TraceBuffer to track the state of the chunk in the index.
    uint8_t index_flags = 0;

    // Correspond to |chunk_record->flags| and |chunk_record->num_fragments|.
    // Copied here for performance reasons (avoids having to dereference
    // |chunk_record| while iterating over ChunkMeta) and to aid debugging in
    // case the buffer gets corrupted.
    uint8_t flags = 0;           // See SharedMemoryABI::ChunkHeader::flags.
    uint16_t num_fragments = 0;  // Total number of packet fragments.

    uint16_t num_fragments_read = 0;  // Number of fragments already read.

    // The start offset of the next fragment (the |num_fragments_read|-th) to be
    // read. This is the offset in bytes from the beginning of the ChunkRecord's
    // payload (the 1st fragment starts at |chunk_record| +
    // sizeof(ChunkRecord)).
    uint16_t cur_fragment_offset = 0;
  };

  using ChunkMap = std::map<ChunkMeta::Key, ChunkMeta>;

  // Allows to iterate over a sub-sequence of |index_| for all keys belonging to
  // the same {ProducerID,WriterID}. Furthermore takes into account the wrapping
  // of ChunkID. Instances are valid only as long as the |index_| is not altered
  // (can be used safely only between adjacent ReadNextTracePacket() calls).
  // The order of the iteration will proceed in the following order:
  // |wrapping_id| + 1 -> |seq_end|, |seq_begin| -> |wrapping_id|.
  // Practical example:
  // - Assume that kMaxChunkID == 7
  // - Assume that we have all 8 chunks in the range (0..7).
  // - Hence, |seq_begin| == c0, |seq_end| == c7
  // - Assume |wrapping_id| = 4 (c4 is the last chunk copied over
  //   through a CopyChunkUntrusted()).
  // The resulting iteration order will be: c5, c6, c7, c0, c1, c2, c3, c4.
  struct SequenceIterator {
    // Points to the 1st key (the one with the numerically min ChunkID).
    ChunkMap::iterator seq_begin;

    // Points one past the last key (the one with the numerically max ChunkID).
    ChunkMap::iterator seq_end;

    // Current iterator, always >= seq_begin && <= seq_end.
    ChunkMap::iterator cur;

    // The latest ChunkID written. Determines the start/end of the sequence.
    ChunkID wrapping_id;

    bool is_valid() const { return cur != seq_end; }

    ProducerID producer_id() const {
      PERFETTO_DCHECK(is_valid());
      return cur->first.producer_id;
    }

    WriterID writer_id() const {
      PERFETTO_DCHECK(is_valid());
      return cur->first.writer_id;
    }

    ChunkID chunk_id() const {
      PERFETTO_DCHECK(is_valid());
      return cur->first.chunk_id;
    }

    ChunkMeta& operator*() {
      PERFETTO_DCHECK(is_valid());
      return cur->second;
    }

    // Moves |cur| to the next chunk in the index.
    // is_valid() will become false after calling this, if this was the last
    // entry of the sequence.
    void MoveNext();

    void MoveToEnd() { cur = seq_end; }
  };

  enum class ReadAheadResult {
    kSucceededReturnSlices,
    kFailedMoveToNextSequence,
    kFailedStayOnSameSequence,
  };

  enum class ReadPacketResult {
    kSucceeded,
    kFailedInvalidPacket,
    kFailedEmptyPacket,
  };

  explicit TraceBuffer(OverwritePolicy);
  TraceBuffer(const TraceBuffer&) = delete;
  TraceBuffer& operator=(const TraceBuffer&) = delete;

  bool Initialize(size_t size);

  // Returns an object that allows to iterate over chunks in the |index_| that
  // have the same {ProducerID, WriterID} of
  // |seq_begin.first.{producer,writer}_id|. |seq_begin| must be an iterator to
  // the first entry in the |index_| that has a different {ProducerID, WriterID}
  // from the previous one. It is valid for |seq_begin| to be == index_.end()
  // (i.e. if the index is empty). The iteration takes care of ChunkID wrapping,
  // by using |last_chunk_id_|.
  SequenceIterator GetReadIterForSequence(ChunkMap::iterator seq_begin);

  // Used as a last resort when a buffer corruption is detected.
  void ClearContentsAndResetRWCursors();

  // Adds a padding record of the given size (must be a multiple of
  // sizeof(ChunkRecord)).
  void AddPaddingRecord(size_t);

  // Look for contiguous fragment of the same packet starting from |read_iter_|.
  // If a contiguous packet is found, all the fragments are pushed into
  // TracePacket and the function returns kSucceededReturnSlices. If not, the
  // function returns either kFailedMoveToNextSequence or
  // kFailedStayOnSameSequence, telling the caller to continue looking for
  // packets.
  ReadAheadResult ReadAhead(TracePacket*);

  // Deletes (by marking the record invalid and removing form the index) all
  // chunks from |wptr_| to |wptr_| + |bytes_to_clear|.
  // Returns:
  //   * The size of the gap left between the next valid Chunk and the end of
  //     the deletion range.
  //   * 0 if no next valid chunk exists (if the buffer is still zeroed).
  //   * -1 if the buffer |overwrite_policy_| == kDiscard and the deletion would
  //     cause unread chunks to be overwritten. In this case the buffer is left
  //     untouched.
  // Graphically, assume the initial situation is the following (|wptr_| = 10).
  // |0        |10 (wptr_)       |30       |40                 |60
  // +---------+-----------------+---------+-------------------+---------+
  // | Chunk 1 | Chunk 2         | Chunk 3 | Chunk 4           | Chunk 5 |
  // +---------+-----------------+---------+-------------------+---------+
  //           |_________Deletion range_______|~~return value~~|
  //
  // A call to DeleteNextChunksFor(32) will remove chunks 2,3,4 and return 18
  // (60 - 42), the distance between chunk 5 and the end of the deletion range.
  ssize_t DeleteNextChunksFor(size_t bytes_to_clear);

  // Decodes the boundaries of the next packet (or a fragment) pointed by
  // ChunkMeta and pushes that into |TracePacket|. It also increments the
  // |num_fragments_read| counter.
  // TracePacket can be nullptr, in which case the read state is still advanced.
  // When TracePacket is not nullptr, ProducerID must also be not null and will
  // be updated with the ProducerID that originally wrote the chunk.
  ReadPacketResult ReadNextPacketInChunk(ChunkMeta*, TracePacket*);

  void DcheckIsAlignedAndWithinBounds(const uint8_t* ptr) const {
    PERFETTO_DCHECK(ptr >= begin() && ptr <= end() - sizeof(ChunkRecord));
    PERFETTO_DCHECK(
        (reinterpret_cast<uintptr_t>(ptr) & (alignof(ChunkRecord) - 1)) == 0);
  }

  ChunkRecord* GetChunkRecordAt(uint8_t* ptr) {
    DcheckIsAlignedAndWithinBounds(ptr);
    // We may be accessing a new (empty) record.
    data_.EnsureCommitted(
        static_cast<size_t>(ptr + sizeof(ChunkRecord) - begin()));
    return reinterpret_cast<ChunkRecord*>(ptr);
  }

  void DiscardWrite();

  // |src| can be nullptr (in which case |size| must be ==
  // record.size - sizeof(ChunkRecord)), for the case of writing a padding
  // record. |wptr_| is NOT advanced by this function, the caller must do that.
  void WriteChunkRecord(uint8_t* wptr,
                        const ChunkRecord& record,
                        const uint8_t* src,
                        size_t size) {
    // Note: |record.size| will be slightly bigger than |size| because of the
    // ChunkRecord header and rounding, to ensure that all ChunkRecord(s) are
    // multiple of sizeof(ChunkRecord). The invariant is:
    // record.size >= |size| + sizeof(ChunkRecord) (== if no rounding).
    PERFETTO_DCHECK(size <= ChunkRecord::kMaxSize);
    PERFETTO_DCHECK(record.size >= sizeof(record));
    PERFETTO_DCHECK(record.size % sizeof(record) == 0);
    PERFETTO_DCHECK(record.size >= size + sizeof(record));
    PERFETTO_CHECK(record.size <= size_to_end());
    DcheckIsAlignedAndWithinBounds(wptr);

    // We may be writing to this area for the first time.
    data_.EnsureCommitted(static_cast<size_t>(wptr + record.size - begin()));

    // Deliberately not a *D*CHECK.
    PERFETTO_CHECK(wptr + sizeof(record) + size <= end());
    memcpy(wptr, &record, sizeof(record));
    if (PERFETTO_LIKELY(src)) {
      // If the producer modifies the data in the shared memory buffer while we
      // are copying it to the central buffer, TSAN will (rightfully) flag that
      // as a race. However the entire purpose of copying the data into the
      // central buffer is that we can validate it without worrying that the
      // producer changes it from under our feet, so this race is benign. The
      // alternative would be to try computing which part of the buffer is safe
      // to read (assuming a well-behaving client), but the risk of introducing
      // a bug that way outweighs the benefit.
      PERFETTO_ANNOTATE_BENIGN_RACE_SIZED(
          src, size, "Benign race when copying chunk from shared memory.")
      memcpy(wptr + sizeof(record), src, size);
    } else {
      PERFETTO_DCHECK(size == record.size - sizeof(record));
    }
    const size_t rounding_size = record.size - sizeof(record) - size;
    memset(wptr + sizeof(record) + size, 0, rounding_size);
  }

  uint8_t* begin() const { return reinterpret_cast<uint8_t*>(data_.Get()); }
  uint8_t* end() const { return begin() + size_; }
  size_t size_to_end() const { return static_cast<size_t>(end() - wptr_); }

  base::PagedMemory data_;
  size_t size_ = 0;            // Size in bytes of |data_|.
  size_t max_chunk_size_ = 0;  // Max size in bytes allowed for a chunk.
  uint8_t* wptr_ = nullptr;    // Write pointer.

  // An index that keeps track of the positions and metadata of each
  // ChunkRecord.
  ChunkMap index_;

  // Read iterator used for ReadNext(). It is reset by calling BeginRead().
  // It becomes invalid after any call to methods that alters the |index_|.
  SequenceIterator read_iter_;

  // See comments at the top of the file.
  OverwritePolicy overwrite_policy_ = kOverwrite;

  // Only used when |overwrite_policy_ == kDiscard|. This is set the first time
  // a write fails because it would overwrite unread chunks.
  bool discard_writes_ = false;

  // Keeps track of the highest ChunkID written for a given sequence, taking
  // into account a potential overflow of ChunkIDs. In the case of overflow,
  // stores the highest ChunkID written since the overflow.
  //
  // TODO(primiano): should clean up keys from this map. Right now it grows
  // without bounds (although realistically is not a problem unless we have too
  // many producers/writers within the same trace session).
  std::map<std::pair<ProducerID, WriterID>, ChunkID> last_chunk_id_written_;

  // Statistics about buffer usage.
  TraceStats::BufferStats stats_;

#if PERFETTO_DCHECK_IS_ON()
  bool changed_since_last_read_ = false;
#endif

  // When true disable some DCHECKs that have been put in place to detect
  // bugs in the producers. This is for tests that feed malicious inputs and
  // hence mimic a buggy producer.
  bool suppress_sanity_dchecks_for_testing_ = false;
};

}  // namespace perfetto

#endif  // SRC_TRACING_CORE_TRACE_BUFFER_H_
// gen_amalgamated begin header: include/perfetto/ext/tracing/core/trace_packet.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_TRACING_CORE_TRACE_PACKET_H_
#define INCLUDE_PERFETTO_EXT_TRACING_CORE_TRACE_PACKET_H_

#include <stddef.h>
#include <memory>
#include <tuple>

#include <google/protobuf/io/zero_copy_stream.h>
// gen_amalgamated expanded: #include "perfetto/base/export.h"
// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/slice.h"

namespace perfetto {

namespace protos {
class TracePacket;  // From protos/trace_packet.pb.h.
}  // namespace protos

// A wrapper around a byte buffer that contains a protobuf-encoded TracePacket
// (see trace_packet.proto). The TracePacket is decoded only if the Consumer
// requests that. This is to allow Consumer(s) to just stream the packet over
// the network or save it to a file without wasting time decoding it and without
// needing to depend on libprotobuf or the trace_packet.pb.h header.
// If the packets are saved / streamed and not just consumed locally, consumers
// should ensure to preserve the unknown fields in the proto. A consumer, in
// fact, might have an older version .proto which is newer on the producer.
class PERFETTO_EXPORT TracePacket {
 public:
  using const_iterator = Slices::const_iterator;
  using ZeroCopyInputStream = ::google::protobuf::io::ZeroCopyInputStream;

  // The field id of protos::Trace::packet, static_assert()-ed in the unittest.
  static constexpr uint32_t kPacketFieldNumber = 1;

  TracePacket();
  ~TracePacket();
  TracePacket(TracePacket&&) noexcept;
  TracePacket& operator=(TracePacket&&);

  // Accesses all the raw slices in the packet, for saving them to file/network.
  const Slices& slices() const { return slices_; }

  // Decodes the packet. This function requires that the caller:
  // 1) Does #include "perfetto/trace/trace_packet.pb.h"
  // 2) Links against the //protos/trace:lite target.
  // The core service code deliberately doesn't link against that in order to
  // avoid binary bloat. This is the reason why this is a templated function.
  // It doesn't need to be (i.e. the caller should not specify the template
  // argument) but doing so prevents the compiler trying to resolve the
  // TracePacket type until it's needed, in which case the caller needs (1).
  template <typename TracePacketType = protos::TracePacket>
  bool Decode(TracePacketType* packet) const {
    std::unique_ptr<ZeroCopyInputStream> istr = CreateSlicedInputStream();
    return packet->ParseFromZeroCopyStream(istr.get());
  }

  // Mutator, used only by the service and tests.
  void AddSlice(Slice);

  // Does not copy / take ownership of the memory of the slice. The TracePacket
  // will be valid only as long as the original buffer is valid.
  void AddSlice(const void* start, size_t size);

  // Total size of all slices.
  size_t size() const { return size_; }

  // Generates a protobuf preamble suitable to represent this packet as a
  // repeated field within a root trace.proto message.
  // Returns a pointer to a buffer, owned by this class, containing the preamble
  // and its size.
  std::tuple<char*, size_t> GetProtoPreamble();

 private:
  TracePacket(const TracePacket&) = delete;
  TracePacket& operator=(const TracePacket&) = delete;

  std::unique_ptr<ZeroCopyInputStream> CreateSlicedInputStream() const;

  Slices slices_;     // Not owned.
  size_t size_ = 0;   // SUM(slice.size for slice in slices_).
  char preamble_[8];  // Deliberately not initialized.

  // Remember to update the move operators and their unittest if adding new
  // fields. ConsumerIPCClientImpl::OnReadBuffersResponse() relies on
  // std::move(TracePacket) to clear up the moved-from instance.
};

}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_TRACING_CORE_TRACE_PACKET_H_
/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "src/tracing/core/trace_buffer.h"

#include <limits>

// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/utils.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/shared_memory_abi.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/trace_packet.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"

#define TRACE_BUFFER_VERBOSE_LOGGING() 0  // Set to 1 when debugging unittests.
#if TRACE_BUFFER_VERBOSE_LOGGING()
#define TRACE_BUFFER_DLOG PERFETTO_DLOG
namespace {
std::string HexDump(const uint8_t* src, size_t size) {
  std::string buf;
  buf.reserve(4096 * 4);
  char line[64];
  char* c = line;
  for (size_t i = 0; i < size; i++) {
    c += sprintf(c, "%02x ", src[i]);
    if (i % 16 == 15) {
      buf.append("\n");
      buf.append(line);
      c = line;
    }
  }
  return buf;
}
}  // namespace
#else
#define TRACE_BUFFER_DLOG(...) void()
#endif

namespace perfetto {

namespace {
constexpr uint8_t kFirstPacketContinuesFromPrevChunk =
    SharedMemoryABI::ChunkHeader::kFirstPacketContinuesFromPrevChunk;
constexpr uint8_t kLastPacketContinuesOnNextChunk =
    SharedMemoryABI::ChunkHeader::kLastPacketContinuesOnNextChunk;
constexpr uint8_t kChunkNeedsPatching =
    SharedMemoryABI::ChunkHeader::kChunkNeedsPatching;
}  // namespace.

constexpr size_t TraceBuffer::ChunkRecord::kMaxSize;
constexpr size_t TraceBuffer::InlineChunkHeaderSize = sizeof(ChunkRecord);

// static
std::unique_ptr<TraceBuffer> TraceBuffer::Create(size_t size_in_bytes,
                                                 OverwritePolicy pol) {
  std::unique_ptr<TraceBuffer> trace_buffer(new TraceBuffer(pol));
  if (!trace_buffer->Initialize(size_in_bytes))
    return nullptr;
  return trace_buffer;
}

TraceBuffer::TraceBuffer(OverwritePolicy pol) : overwrite_policy_(pol) {
  // See comments in ChunkRecord for the rationale of this.
  static_assert(sizeof(ChunkRecord) == sizeof(SharedMemoryABI::PageHeader) +
                                           sizeof(SharedMemoryABI::ChunkHeader),
                "ChunkRecord out of sync with the layout of SharedMemoryABI");
}

TraceBuffer::~TraceBuffer() = default;

bool TraceBuffer::Initialize(size_t size) {
  static_assert(
      base::kPageSize % sizeof(ChunkRecord) == 0,
      "sizeof(ChunkRecord) must be an integer divider of a page size");
  PERFETTO_CHECK(size % base::kPageSize == 0);
  data_ = base::PagedMemory::Allocate(
      size, base::PagedMemory::kMayFail | base::PagedMemory::kDontCommit);
  if (!data_.IsValid()) {
    PERFETTO_ELOG("Trace buffer allocation failed (size: %zu)", size);
    return false;
  }
  size_ = size;
  stats_.set_buffer_size(size);
  max_chunk_size_ = std::min(size, ChunkRecord::kMaxSize);
  wptr_ = begin();
  index_.clear();
  last_chunk_id_written_.clear();
  read_iter_ = GetReadIterForSequence(index_.end());
  return true;
}

// Note: |src| points to a shmem region that is shared with the producer. Assume
// that the producer is malicious and will change the content of |src|
// while we execute here. Don't do any processing on it other than memcpy().
void TraceBuffer::CopyChunkUntrusted(ProducerID producer_id_trusted,
                                     uid_t producer_uid_trusted,
                                     WriterID writer_id,
                                     ChunkID chunk_id,
                                     uint16_t num_fragments,
                                     uint8_t chunk_flags,
                                     bool chunk_complete,
                                     const uint8_t* src,
                                     size_t size) {
  // |record_size| = |size| + sizeof(ChunkRecord), rounded up to avoid to end
  // up in a fragmented state where size_to_end() < sizeof(ChunkRecord).
  const size_t record_size =
      base::AlignUp<sizeof(ChunkRecord)>(size + sizeof(ChunkRecord));
  if (PERFETTO_UNLIKELY(record_size > max_chunk_size_)) {
    stats_.set_abi_violations(stats_.abi_violations() + 1);
    PERFETTO_DCHECK(suppress_sanity_dchecks_for_testing_);
    return;
  }

  TRACE_BUFFER_DLOG("CopyChunk @ %lu, size=%zu", wptr_ - begin(), record_size);

#if PERFETTO_DCHECK_IS_ON()
  changed_since_last_read_ = true;
#endif

  // If the chunk hasn't been completed, we should only consider the first
  // |num_fragments - 1| packets complete. For simplicity, we simply disregard
  // the last one when we copy the chunk.
  if (PERFETTO_UNLIKELY(!chunk_complete)) {
    if (num_fragments > 0) {
      num_fragments--;
      chunk_flags &= ~kLastPacketContinuesOnNextChunk;
    }
  }

  ChunkRecord record(record_size);
  record.producer_id = producer_id_trusted;
  record.chunk_id = chunk_id;
  record.writer_id = writer_id;
  record.num_fragments = num_fragments;
  record.flags = chunk_flags;
  ChunkMeta::Key key(record);

  // Check whether we have already copied the same chunk previously. This may
  // happen if the service scrapes chunks in a potentially incomplete state
  // before receiving commit requests for them from the producer. Note that the
  // service may scrape and thus override chunks in arbitrary order since the
  // chunks aren't ordered in the SMB.
  const auto it = index_.find(key);
  if (PERFETTO_UNLIKELY(it != index_.end())) {
    ChunkMeta* record_meta = &it->second;
    ChunkRecord* prev = record_meta->chunk_record;

    // Verify that the old chunk's metadata corresponds to the new one.
    // Overridden chunks should never change size, since the page layout is
    // fixed per writer. The number of fragments should also never decrease and
    // flags should not be removed.
    if (PERFETTO_UNLIKELY(ChunkMeta::Key(*prev) != key ||
                          prev->size != record_size ||
                          prev->num_fragments > num_fragments ||
                          (prev->flags & chunk_flags) != prev->flags)) {
      stats_.set_abi_violations(stats_.abi_violations() + 1);
      PERFETTO_DCHECK(suppress_sanity_dchecks_for_testing_);
      return;
    }

    // If we've already started reading from chunk N+1 following this chunk N,
    // don't override chunk N. Otherwise we may end up reading a packet from
    // chunk N after having read from chunk N+1, thereby violating sequential
    // read of packets. This shouldn't happen if the producer is well-behaved,
    // because it shouldn't start chunk N+1 before completing chunk N.
    ChunkMeta::Key subsequent_key = key;
    static_assert(std::numeric_limits<ChunkID>::max() == kMaxChunkID,
                  "ChunkID wraps");
    subsequent_key.chunk_id++;
    const auto subsequent_it = index_.find(subsequent_key);
    if (subsequent_it != index_.end() &&
        subsequent_it->second.num_fragments_read > 0) {
      stats_.set_abi_violations(stats_.abi_violations() + 1);
      PERFETTO_DCHECK(suppress_sanity_dchecks_for_testing_);
      return;
    }

    // If this chunk was previously copied with the same number of fragments and
    // the number didn't change, there's no need to copy it again. If the
    // previous chunk was complete already, this should always be the case.
    PERFETTO_DCHECK(suppress_sanity_dchecks_for_testing_ ||
                    !record_meta->is_complete() ||
                    (chunk_complete && prev->num_fragments == num_fragments));
    if (prev->num_fragments == num_fragments) {
      TRACE_BUFFER_DLOG("  skipping recommit of identical chunk");
      return;
    }

    // We should not have read past the last packet.
    if (record_meta->num_fragments_read > prev->num_fragments) {
      PERFETTO_ELOG(
          "TraceBuffer read too many fragments from an incomplete chunk");
      PERFETTO_DCHECK(suppress_sanity_dchecks_for_testing_);
      return;
    }

    uint8_t* wptr = reinterpret_cast<uint8_t*>(prev);
    TRACE_BUFFER_DLOG("  overriding chunk @ %lu, size=%zu", wptr - begin(),
                      record_size);

    // Update chunk meta data stored in the index, as it may have changed.
    record_meta->num_fragments = num_fragments;
    record_meta->flags = chunk_flags;
    record_meta->set_complete(chunk_complete);

    // Override the ChunkRecord contents at the original |wptr|.
    TRACE_BUFFER_DLOG("  copying @ [%lu - %lu] %zu", wptr - begin(),
                      uintptr_t(wptr - begin()) + record_size, record_size);
    WriteChunkRecord(wptr, record, src, size);
    TRACE_BUFFER_DLOG("Chunk raw: %s", HexDump(wptr, record_size).c_str());
    stats_.set_chunks_rewritten(stats_.chunks_rewritten() + 1);
    return;
  }

  if (PERFETTO_UNLIKELY(discard_writes_))
    return DiscardWrite();

  // If there isn't enough room from the given write position. Write a padding
  // record to clear the end of the buffer and wrap back.
  const size_t cached_size_to_end = size_to_end();
  if (PERFETTO_UNLIKELY(record_size > cached_size_to_end)) {
    ssize_t res = DeleteNextChunksFor(cached_size_to_end);
    if (res == -1)
      return DiscardWrite();
    PERFETTO_DCHECK(static_cast<size_t>(res) <= cached_size_to_end);
    AddPaddingRecord(cached_size_to_end);
    wptr_ = begin();
    stats_.set_write_wrap_count(stats_.write_wrap_count() + 1);
    PERFETTO_DCHECK(size_to_end() >= record_size);
  }

  // At this point either |wptr_| points to an untouched part of the buffer
  // (i.e. *wptr_ == 0) or we are about to overwrite one or more ChunkRecord(s).
  // In the latter case we need to first figure out where the next valid
  // ChunkRecord is (if it exists) and add padding between the new record.
  // Example ((w) == write cursor):
  //
  // Initial state (wtpr_ == 0):
  // |0 (w)    |10               |30                  |50
  // +---------+-----------------+--------------------+--------------------+
  // | Chunk 1 | Chunk 2         | Chunk 3            | Chunk 4            |
  // +---------+-----------------+--------------------+--------------------+
  //
  // Let's assume we now want now write a 5th Chunk of size == 35. The final
  // state should look like this:
  // |0                                |35 (w)         |50
  // +---------------------------------+---------------+--------------------+
  // | Chunk 5                         | Padding Chunk | Chunk 4            |
  // +---------------------------------+---------------+--------------------+

  // Deletes all chunks from |wptr_| to |wptr_| + |record_size|.
  ssize_t del_res = DeleteNextChunksFor(record_size);
  if (del_res == -1)
    return DiscardWrite();
  size_t padding_size = static_cast<size_t>(del_res);

  // Now first insert the new chunk. At the end, if necessary, add the padding.
  stats_.set_chunks_written(stats_.chunks_written() + 1);
  stats_.set_bytes_written(stats_.bytes_written() + record_size);
  auto it_and_inserted = index_.emplace(
      key, ChunkMeta(GetChunkRecordAt(wptr_), num_fragments, chunk_complete,
                     chunk_flags, producer_uid_trusted));
  PERFETTO_DCHECK(it_and_inserted.second);
  TRACE_BUFFER_DLOG("  copying @ [%lu - %lu] %zu", wptr_ - begin(),
                    uintptr_t(wptr_ - begin()) + record_size, record_size);
  WriteChunkRecord(wptr_, record, src, size);
  TRACE_BUFFER_DLOG("Chunk raw: %s", HexDump(wptr_, record_size).c_str());
  wptr_ += record_size;
  if (wptr_ >= end()) {
    PERFETTO_DCHECK(padding_size == 0);
    wptr_ = begin();
    stats_.set_write_wrap_count(stats_.write_wrap_count() + 1);
  }
  DcheckIsAlignedAndWithinBounds(wptr_);

  // Chunks may be received out of order, so only update last_chunk_id if the
  // new chunk_id is larger. But take into account overflows by only selecting
  // the new ID if its distance to the latest ID is smaller than half the number
  // space.
  //
  // This accounts for both the case where the new ID has just overflown and
  // last_chunk_id be updated even though it's smaller (e.g. |chunk_id| = 1 and
  // |last_chunk_id| = kMaxChunkId; chunk_id - last_chunk_id = 0) and the case
  // where the new ID is an out-of-order ID right after an overflow and
  // last_chunk_id shouldn't be updated even though it's larger (e.g. |chunk_id|
  // = kMaxChunkId and |last_chunk_id| = 1; chunk_id - last_chunk_id =
  // kMaxChunkId - 1).
  auto producer_and_writer_id = std::make_pair(producer_id_trusted, writer_id);
  ChunkID& last_chunk_id = last_chunk_id_written_[producer_and_writer_id];
  static_assert(std::numeric_limits<ChunkID>::max() == kMaxChunkID,
                "This code assumes that ChunkID wraps at kMaxChunkID");
  if (chunk_id - last_chunk_id < kMaxChunkID / 2) {
    last_chunk_id = chunk_id;
  } else {
    stats_.set_chunks_committed_out_of_order(
        stats_.chunks_committed_out_of_order() + 1);
  }

  if (padding_size)
    AddPaddingRecord(padding_size);
}

ssize_t TraceBuffer::DeleteNextChunksFor(size_t bytes_to_clear) {
  PERFETTO_CHECK(!discard_writes_);

  // Find the position of the first chunk which begins at or after
  // (|wptr_| + |bytes|). Note that such a chunk might not exist and we might
  // either reach the end of the buffer or a zeroed region of the buffer.
  uint8_t* next_chunk_ptr = wptr_;
  uint8_t* search_end = wptr_ + bytes_to_clear;
  TRACE_BUFFER_DLOG("Delete [%zu %zu]", wptr_ - begin(), search_end - begin());
  DcheckIsAlignedAndWithinBounds(wptr_);
  PERFETTO_DCHECK(search_end <= end());
  std::vector<ChunkMap::iterator> index_delete;
  uint64_t chunks_overwritten = stats_.chunks_overwritten();
  uint64_t bytes_overwritten = stats_.bytes_overwritten();
  uint64_t padding_bytes_cleared = stats_.padding_bytes_cleared();
  while (next_chunk_ptr < search_end) {
    const ChunkRecord& next_chunk = *GetChunkRecordAt(next_chunk_ptr);
    TRACE_BUFFER_DLOG(
        "  scanning chunk [%zu %zu] (valid=%d)", next_chunk_ptr - begin(),
        next_chunk_ptr - begin() + next_chunk.size, next_chunk.is_valid());

    // We just reached the untouched part of the buffer, it's going to be all
    // zeroes from here to end().
    // Optimization: if during Initialize() we fill the buffer with padding
    // records we could get rid of this branch.
    if (PERFETTO_UNLIKELY(!next_chunk.is_valid())) {
      // This should happen only at the first iteration. The zeroed area can
      // only begin precisely at the |wptr_|, not after. Otherwise it means that
      // we wrapped but screwed up the ChunkRecord chain.
      PERFETTO_DCHECK(next_chunk_ptr == wptr_);
      return 0;
    }

    // Remove |next_chunk| from the index, unless it's a padding record (padding
    // records are not part of the index).
    if (PERFETTO_LIKELY(!next_chunk.is_padding)) {
      ChunkMeta::Key key(next_chunk);
      auto it = index_.find(key);
      bool will_remove = false;
      if (PERFETTO_LIKELY(it != index_.end())) {
        const ChunkMeta& meta = it->second;
        if (PERFETTO_UNLIKELY(meta.num_fragments_read < meta.num_fragments)) {
          if (overwrite_policy_ == kDiscard)
            return -1;
          chunks_overwritten++;
          bytes_overwritten += next_chunk.size;
        }
        index_delete.push_back(it);
        will_remove = true;
      }
      TRACE_BUFFER_DLOG("  del index {%" PRIu32 ",%" PRIu32
                        ",%u} @ [%lu - %lu] %d",
                        key.producer_id, key.writer_id, key.chunk_id,
                        next_chunk_ptr - begin(),
                        next_chunk_ptr - begin() + next_chunk.size, removed);
      PERFETTO_DCHECK(will_remove);
    } else {
      padding_bytes_cleared += next_chunk.size;
    }

    next_chunk_ptr += next_chunk.size;

    // We should never hit this, unless we managed to screw up while writing
    // to the buffer and breaking the ChunkRecord(s) chain.
    // TODO(primiano): Write more meaningful logging with the status of the
    // buffer, to get more actionable bugs in case we hit this.
    PERFETTO_CHECK(next_chunk_ptr <= end());
  }

  // Remove from the index.
  for (auto it : index_delete) {
    index_.erase(it);
  }
  stats_.set_chunks_overwritten(chunks_overwritten);
  stats_.set_bytes_overwritten(bytes_overwritten);
  stats_.set_padding_bytes_cleared(padding_bytes_cleared);

  PERFETTO_DCHECK(next_chunk_ptr >= search_end && next_chunk_ptr <= end());
  return static_cast<ssize_t>(next_chunk_ptr - search_end);
}

void TraceBuffer::AddPaddingRecord(size_t size) {
  PERFETTO_DCHECK(size >= sizeof(ChunkRecord) && size <= ChunkRecord::kMaxSize);
  ChunkRecord record(size);
  record.is_padding = 1;
  TRACE_BUFFER_DLOG("AddPaddingRecord @ [%lu - %lu] %zu", wptr_ - begin(),
                    uintptr_t(wptr_ - begin()) + size, size);
  WriteChunkRecord(wptr_, record, nullptr, size - sizeof(ChunkRecord));
  stats_.set_padding_bytes_written(stats_.padding_bytes_written() + size);
  // |wptr_| is deliberately not advanced when writing a padding record.
}

bool TraceBuffer::TryPatchChunkContents(ProducerID producer_id,
                                        WriterID writer_id,
                                        ChunkID chunk_id,
                                        const Patch* patches,
                                        size_t patches_size,
                                        bool other_patches_pending) {
  ChunkMeta::Key key(producer_id, writer_id, chunk_id);
  auto it = index_.find(key);
  if (it == index_.end()) {
    stats_.set_patches_failed(stats_.patches_failed() + 1);
    return false;
  }
  ChunkMeta& chunk_meta = it->second;

  // Check that the index is consistent with the actual ProducerID/WriterID
  // stored in the ChunkRecord.
  PERFETTO_DCHECK(ChunkMeta::Key(*chunk_meta.chunk_record) == key);
  uint8_t* chunk_begin = reinterpret_cast<uint8_t*>(chunk_meta.chunk_record);
  PERFETTO_DCHECK(chunk_begin >= begin());
  uint8_t* chunk_end = chunk_begin + chunk_meta.chunk_record->size;
  PERFETTO_DCHECK(chunk_end <= end());

  static_assert(Patch::kSize == SharedMemoryABI::kPacketHeaderSize,
                "Patch::kSize out of sync with SharedMemoryABI");

  for (size_t i = 0; i < patches_size; i++) {
    uint8_t* ptr =
        chunk_begin + sizeof(ChunkRecord) + patches[i].offset_untrusted;
    TRACE_BUFFER_DLOG("PatchChunk {%" PRIu32 ",%" PRIu32
                      ",%u} size=%zu @ %zu with {%02x %02x %02x %02x} cur "
                      "{%02x %02x %02x %02x}",
                      producer_id, writer_id, chunk_id, chunk_end - chunk_begin,
                      patches[i].offset_untrusted, patches[i].data[0],
                      patches[i].data[1], patches[i].data[2],
                      patches[i].data[3], ptr[0], ptr[1], ptr[2], ptr[3]);
    if (ptr < chunk_begin + sizeof(ChunkRecord) ||
        ptr > chunk_end - Patch::kSize) {
      // Either the IPC was so slow and in the meantime the writer managed to
      // wrap over |chunk_id| or the producer sent a malicious IPC.
      stats_.set_patches_failed(stats_.patches_failed() + 1);
      return false;
    }

    // DCHECK that we are writing into a zero-filled size field and not into
    // valid data. It relies on ScatteredStreamWriter::ReserveBytes() to
    // zero-fill reservations in debug builds.
    char zero[Patch::kSize]{};
    PERFETTO_DCHECK(memcmp(ptr, &zero, Patch::kSize) == 0);

    memcpy(ptr, &patches[i].data[0], Patch::kSize);
  }
  TRACE_BUFFER_DLOG(
      "Chunk raw (after patch): %s",
      HexDump(chunk_begin, chunk_meta.chunk_record->size).c_str());

  stats_.set_patches_succeeded(stats_.patches_succeeded() + patches_size);
  if (!other_patches_pending) {
    chunk_meta.flags &= ~kChunkNeedsPatching;
    chunk_meta.chunk_record->flags = chunk_meta.flags;
  }
  return true;
}

void TraceBuffer::BeginRead() {
  read_iter_ = GetReadIterForSequence(index_.begin());
#if PERFETTO_DCHECK_IS_ON()
  changed_since_last_read_ = false;
#endif
}

TraceBuffer::SequenceIterator TraceBuffer::GetReadIterForSequence(
    ChunkMap::iterator seq_begin) {
  SequenceIterator iter;
  iter.seq_begin = seq_begin;
  if (seq_begin == index_.end()) {
    iter.cur = iter.seq_end = index_.end();
    return iter;
  }

#if PERFETTO_DCHECK_IS_ON()
  // Either |seq_begin| is == index_.begin() or the item immediately before must
  // belong to a different {ProducerID, WriterID} sequence.
  if (seq_begin != index_.begin() && seq_begin != index_.end()) {
    auto prev_it = seq_begin;
    prev_it--;
    PERFETTO_DCHECK(
        seq_begin == index_.begin() ||
        std::tie(prev_it->first.producer_id, prev_it->first.writer_id) <
            std::tie(seq_begin->first.producer_id, seq_begin->first.writer_id));
  }
#endif

  // Find the first entry that has a greater {ProducerID, WriterID} (or just
  // index_.end() if we reached the end).
  ChunkMeta::Key key = seq_begin->first;  // Deliberate copy.
  key.chunk_id = kMaxChunkID;
  iter.seq_end = index_.upper_bound(key);
  PERFETTO_DCHECK(iter.seq_begin != iter.seq_end);

  // Now find the first entry between [seq_begin, seq_end) that is
  // > last_chunk_id_written_. This is where we the sequence will start (see
  // notes about wrapping of IDs in the header).
  auto producer_and_writer_id = std::make_pair(key.producer_id, key.writer_id);
  PERFETTO_DCHECK(last_chunk_id_written_.count(producer_and_writer_id));
  iter.wrapping_id = last_chunk_id_written_[producer_and_writer_id];
  key.chunk_id = iter.wrapping_id;
  iter.cur = index_.upper_bound(key);
  if (iter.cur == iter.seq_end)
    iter.cur = iter.seq_begin;
  return iter;
}

void TraceBuffer::SequenceIterator::MoveNext() {
  // Stop iterating when we reach the end of the sequence.
  // Note: |seq_begin| might be == |seq_end|.
  if (cur == seq_end || cur->first.chunk_id == wrapping_id) {
    cur = seq_end;
    return;
  }

  // If the current chunk wasn't completed yet, we shouldn't advance past it as
  // it may be rewritten with additional packets.
  if (!cur->second.is_complete()) {
    cur = seq_end;
    return;
  }

  ChunkID last_chunk_id = cur->first.chunk_id;
  if (++cur == seq_end)
    cur = seq_begin;

  // There may be a missing chunk in the sequence of chunks, in which case the
  // next chunk's ID won't follow the last one's. If so, skip the rest of the
  // sequence. We'll return to it later once the hole is filled.
  if (last_chunk_id + 1 != cur->first.chunk_id)
    cur = seq_end;
}

bool TraceBuffer::ReadNextTracePacket(
    TracePacket* packet,
    PacketSequenceProperties* sequence_properties,
    bool* previous_packet_on_sequence_dropped) {
  // Note: MoveNext() moves only within the next chunk within the same
  // {ProducerID, WriterID} sequence. Here we want to:
  // - return the next patched+complete packet in the current sequence, if any.
  // - return the first patched+complete packet in the next sequence, if any.
  // - return false if none of the above is found.
  TRACE_BUFFER_DLOG("ReadNextTracePacket()");

  // Just in case we forget to initialize these below.
  *sequence_properties = {0, kInvalidUid, 0};
  *previous_packet_on_sequence_dropped = false;

  // At the start of each sequence iteration, we consider the last read packet
  // dropped. While iterating over the chunks in the sequence, we update this
  // flag based on our knowledge about the last packet that was read from each
  // chunk (|last_read_packet_skipped| in ChunkMeta).
  bool previous_packet_dropped = true;

#if PERFETTO_DCHECK_IS_ON()
  PERFETTO_DCHECK(!changed_since_last_read_);
#endif
  for (;; read_iter_.MoveNext()) {
    if (PERFETTO_UNLIKELY(!read_iter_.is_valid())) {
      // We ran out of chunks in the current {ProducerID, WriterID} sequence or
      // we just reached the index_.end().

      if (PERFETTO_UNLIKELY(read_iter_.seq_end == index_.end()))
        return false;

      // We reached the end of sequence, move to the next one.
      // Note: ++read_iter_.seq_end might become index_.end(), but
      // GetReadIterForSequence() knows how to deal with that.
      read_iter_ = GetReadIterForSequence(read_iter_.seq_end);
      PERFETTO_DCHECK(read_iter_.is_valid() && read_iter_.cur != index_.end());
      previous_packet_dropped = true;
    }

    ChunkMeta* chunk_meta = &*read_iter_;

    // If the chunk has holes that are awaiting to be patched out-of-band,
    // skip the current sequence and move to the next one.
    if (chunk_meta->flags & kChunkNeedsPatching) {
      read_iter_.MoveToEnd();
      continue;
    }

    const ProducerID trusted_producer_id = read_iter_.producer_id();
    const WriterID writer_id = read_iter_.writer_id();
    const uid_t trusted_uid = chunk_meta->trusted_uid;

    // At this point we have a chunk in |chunk_meta| that has not been fully
    // read. We don't know yet whether we have enough data to read the full
    // packet (in the case it's fragmented over several chunks) and we are about
    // to find that out. Specifically:
    // A) If the first fragment is unread and is a fragment continuing from a
    //    previous chunk, it means we have missed the previous ChunkID. In
    //    fact, if this wasn't the case, a previous call to ReadNext() shouldn't
    //    have moved the cursor to this chunk.
    // B) Any fragment > 0 && < last is always readable. By definition an inner
    //    packet is never fragmented and hence doesn't require neither stitching
    //    nor any out-of-band patching. The same applies to the last packet
    //    iff it doesn't continue on the next chunk.
    // C) If the last packet (which might be also the only packet in the chunk)
    //    is a fragment and continues on the next chunk, we peek at the next
    //    chunks and, if we have all of them, mark as read and move the cursor.
    //
    // +---------------+   +-------------------+  +---------------+
    // | ChunkID: 1    |   | ChunkID: 2        |  | ChunkID: 3    |
    // |---------------+   +-------------------+  +---------------+
    // | Packet 1      |   |                   |  | ... Packet 3  |
    // | Packet 2      |   | ... Packet 3  ... |  | Packet 4      |
    // | Packet 3  ... |   |                   |  | Packet 5 ...  |
    // +---------------+   +-------------------+  +---------------+

    PERFETTO_DCHECK(chunk_meta->num_fragments_read <=
                    chunk_meta->num_fragments);

    // If we didn't read any packets from this chunk, the last packet was from
    // the previous chunk we iterated over; so don't update
    // |previous_packet_dropped| in this case.
    if (chunk_meta->num_fragments_read > 0)
      previous_packet_dropped = chunk_meta->last_read_packet_skipped();

    while (chunk_meta->num_fragments_read < chunk_meta->num_fragments) {
      enum { kSkip = 0, kReadOnePacket, kTryReadAhead } action;
      if (chunk_meta->num_fragments_read == 0) {
        if (chunk_meta->flags & kFirstPacketContinuesFromPrevChunk) {
          action = kSkip;  // Case A.
        } else if (chunk_meta->num_fragments == 1 &&
                   (chunk_meta->flags & kLastPacketContinuesOnNextChunk)) {
          action = kTryReadAhead;  // Case C.
        } else {
          action = kReadOnePacket;  // Case B.
        }
      } else if (chunk_meta->num_fragments_read <
                     chunk_meta->num_fragments - 1 ||
                 !(chunk_meta->flags & kLastPacketContinuesOnNextChunk)) {
        action = kReadOnePacket;  // Case B.
      } else {
        action = kTryReadAhead;  // Case C.
      }

      TRACE_BUFFER_DLOG("  chunk %u, packet %hu of %hu, action=%d",
                        read_iter_.chunk_id(), chunk_meta->num_fragments_read,
                        chunk_meta->num_fragments, action);

      if (action == kSkip) {
        // This fragment will be skipped forever, not just in this ReadPacket()
        // iteration. This happens by virtue of ReadNextPacketInChunk()
        // incrementing the |num_fragments_read| and marking the fragment as
        // read even if we didn't really.
        ReadNextPacketInChunk(chunk_meta, nullptr);
        chunk_meta->set_last_read_packet_skipped(true);
        previous_packet_dropped = true;
        continue;
      }

      if (action == kReadOnePacket) {
        // The easy peasy case B.
        ReadPacketResult result = ReadNextPacketInChunk(chunk_meta, packet);

        if (PERFETTO_LIKELY(result == ReadPacketResult::kSucceeded)) {
          *sequence_properties = {trusted_producer_id, trusted_uid, writer_id};
          *previous_packet_on_sequence_dropped = previous_packet_dropped;
          return true;
        } else if (result == ReadPacketResult::kFailedEmptyPacket) {
          // We can ignore and skip empty packets.
          PERFETTO_DCHECK(packet->slices().empty());
          continue;
        }

        // In extremely rare cases (producer bugged / malicious) the chunk might
        // contain an invalid fragment. In such case we don't want to stall the
        // sequence but just skip the chunk and move on. ReadNextPacketInChunk()
        // marks the chunk as fully read, so we don't attempt to read from it
        // again in a future call to ReadBuffers(). It also already records an
        // abi violation for this.
        PERFETTO_DCHECK(result == ReadPacketResult::kFailedInvalidPacket);
        chunk_meta->set_last_read_packet_skipped(true);
        previous_packet_dropped = true;
        break;
      }

      PERFETTO_DCHECK(action == kTryReadAhead);
      ReadAheadResult ra_res = ReadAhead(packet);
      if (ra_res == ReadAheadResult::kSucceededReturnSlices) {
        stats_.set_readaheads_succeeded(stats_.readaheads_succeeded() + 1);
        *sequence_properties = {trusted_producer_id, trusted_uid, writer_id};
        *previous_packet_on_sequence_dropped = previous_packet_dropped;
        return true;
      }

      if (ra_res == ReadAheadResult::kFailedMoveToNextSequence) {
        // readahead didn't find a contiguous packet sequence. We'll try again
        // on the next ReadPacket() call.
        stats_.set_readaheads_failed(stats_.readaheads_failed() + 1);

        // TODO(primiano): optimization: this MoveToEnd() is the reason why
        // MoveNext() (that is called in the outer for(;;MoveNext)) needs to
        // deal gracefully with the case of |cur|==|seq_end|. Maybe we can do
        // something to avoid that check by reshuffling the code here?
        read_iter_.MoveToEnd();

        // This break will go back to beginning of the for(;;MoveNext()). That
        // will move to the next sequence because we set the read iterator to
        // its end.
        break;
      }

      PERFETTO_DCHECK(ra_res == ReadAheadResult::kFailedStayOnSameSequence);

      // In this case ReadAhead() might advance |read_iter_|, so we need to
      // re-cache the |chunk_meta| pointer to point to the current chunk.
      chunk_meta = &*read_iter_;
      chunk_meta->set_last_read_packet_skipped(true);
      previous_packet_dropped = true;
    }  // while(...)  [iterate over packet fragments for the current chunk].
  }    // for(;;MoveNext()) [iterate over chunks].
}

TraceBuffer::ReadAheadResult TraceBuffer::ReadAhead(TracePacket* packet) {
  static_assert(static_cast<ChunkID>(kMaxChunkID + 1) == 0,
                "relying on kMaxChunkID to wrap naturally");
  TRACE_BUFFER_DLOG(" readahead start @ chunk %u", read_iter_.chunk_id());
  ChunkID next_chunk_id = read_iter_.chunk_id() + 1;
  SequenceIterator it = read_iter_;
  for (it.MoveNext(); it.is_valid(); it.MoveNext(), next_chunk_id++) {
    // We should stay within the same sequence while iterating here.
    PERFETTO_DCHECK(it.producer_id() == read_iter_.producer_id() &&
                    it.writer_id() == read_iter_.writer_id());

    TRACE_BUFFER_DLOG("   expected chunk ID: %u, actual ID: %u", next_chunk_id,
                      it.chunk_id());

    if (PERFETTO_UNLIKELY((*it).num_fragments == 0))
      continue;

    // If we miss the next chunk, stop looking in the current sequence and
    // try another sequence. This chunk might come in the near future.
    // The second condition is the edge case of a buggy/malicious
    // producer. The ChunkID is contiguous but its flags don't make sense.
    if (it.chunk_id() != next_chunk_id ||
        PERFETTO_UNLIKELY(
            !((*it).flags & kFirstPacketContinuesFromPrevChunk))) {
      return ReadAheadResult::kFailedMoveToNextSequence;
    }

    // If the chunk is contiguous but has not been patched yet move to the next
    // sequence and try coming back here on the next ReadNextTracePacket() call.
    // TODO(primiano): add a test to cover this, it's a subtle case.
    if ((*it).flags & kChunkNeedsPatching)
      return ReadAheadResult::kFailedMoveToNextSequence;

    // This is the case of an intermediate chunk which contains only one
    // fragment which continues on the next chunk. This is the case for large
    // packets, e.g.: [Packet0, Packet1(0)] [Packet1(1)] [Packet1(2), ...]
    // (Packet1(X) := fragment X of Packet1).
    if ((*it).num_fragments == 1 &&
        ((*it).flags & kLastPacketContinuesOnNextChunk)) {
      continue;
    }

    // We made it! We got all fragments for the packet without holes.
    TRACE_BUFFER_DLOG("  readahead success @ chunk %u", it.chunk_id());
    PERFETTO_DCHECK(((*it).num_fragments == 1 &&
                     !((*it).flags & kLastPacketContinuesOnNextChunk)) ||
                    (*it).num_fragments > 1);

    // Now let's re-iterate over the [read_iter_, it] sequence and mark
    // all the fragments as read.
    bool packet_corruption = false;
    for (;;) {
      PERFETTO_DCHECK(read_iter_.is_valid());
      TRACE_BUFFER_DLOG("    commit chunk %u", read_iter_.chunk_id());
      if (PERFETTO_LIKELY((*read_iter_).num_fragments > 0)) {
        // In the unlikely case of a corrupted packet (corrupted or empty
        // fragment), invalidate the all stitching and move on to the next chunk
        // in the same sequence, if any.
        packet_corruption |= ReadNextPacketInChunk(&*read_iter_, packet) ==
                             ReadPacketResult::kFailedInvalidPacket;
      }
      if (read_iter_.cur == it.cur)
        break;
      read_iter_.MoveNext();
    }  // for(;;)
    PERFETTO_DCHECK(read_iter_.cur == it.cur);

    if (PERFETTO_UNLIKELY(packet_corruption)) {
      // ReadNextPacketInChunk() already records an abi violation for this case.
      *packet = TracePacket();  // clear.
      return ReadAheadResult::kFailedStayOnSameSequence;
    }

    return ReadAheadResult::kSucceededReturnSlices;
  }  // for(it...)  [readahead loop]
  return ReadAheadResult::kFailedMoveToNextSequence;
}

TraceBuffer::ReadPacketResult TraceBuffer::ReadNextPacketInChunk(
    ChunkMeta* chunk_meta,
    TracePacket* packet) {
  PERFETTO_DCHECK(chunk_meta->num_fragments_read < chunk_meta->num_fragments);
  PERFETTO_DCHECK(!(chunk_meta->flags & kChunkNeedsPatching));

  const uint8_t* record_begin =
      reinterpret_cast<const uint8_t*>(chunk_meta->chunk_record);
  const uint8_t* record_end = record_begin + chunk_meta->chunk_record->size;
  const uint8_t* packets_begin = record_begin + sizeof(ChunkRecord);
  const uint8_t* packet_begin = packets_begin + chunk_meta->cur_fragment_offset;

  if (PERFETTO_UNLIKELY(packet_begin < packets_begin ||
                        packet_begin >= record_end)) {
    // The producer has a bug or is malicious and did declare that the chunk
    // contains more packets beyond its boundaries.
    stats_.set_abi_violations(stats_.abi_violations() + 1);
    PERFETTO_DCHECK(suppress_sanity_dchecks_for_testing_);
    chunk_meta->cur_fragment_offset = 0;
    chunk_meta->num_fragments_read = chunk_meta->num_fragments;
    if (PERFETTO_LIKELY(chunk_meta->is_complete())) {
      stats_.set_chunks_read(stats_.chunks_read() + 1);
      stats_.set_bytes_read(stats_.bytes_read() +
                            chunk_meta->chunk_record->size);
    }
    return ReadPacketResult::kFailedInvalidPacket;
  }

  // A packet (or a fragment) starts with a varint stating its size, followed
  // by its content. The varint shouldn't be larger than 4 bytes (just in case
  // the producer is using a redundant encoding)
  uint64_t packet_size = 0;
  const uint8_t* header_end =
      std::min(packet_begin + protozero::proto_utils::kMessageLengthFieldSize,
               record_end);
  const uint8_t* packet_data = protozero::proto_utils::ParseVarInt(
      packet_begin, header_end, &packet_size);

  const uint8_t* next_packet = packet_data + packet_size;
  if (PERFETTO_UNLIKELY(next_packet <= packet_begin ||
                        next_packet > record_end)) {
    stats_.set_abi_violations(stats_.abi_violations() + 1);
    PERFETTO_DCHECK(suppress_sanity_dchecks_for_testing_);
    chunk_meta->cur_fragment_offset = 0;
    chunk_meta->num_fragments_read = chunk_meta->num_fragments;
    if (PERFETTO_LIKELY(chunk_meta->is_complete())) {
      stats_.set_chunks_read(stats_.chunks_read() + 1);
      stats_.set_bytes_read(stats_.bytes_read() +
                            chunk_meta->chunk_record->size);
    }
    return ReadPacketResult::kFailedInvalidPacket;
  }

  chunk_meta->cur_fragment_offset =
      static_cast<uint16_t>(next_packet - packets_begin);
  chunk_meta->num_fragments_read++;

  if (PERFETTO_UNLIKELY(chunk_meta->num_fragments_read ==
                            chunk_meta->num_fragments &&
                        chunk_meta->is_complete())) {
    stats_.set_chunks_read(stats_.chunks_read() + 1);
    stats_.set_bytes_read(stats_.bytes_read() + chunk_meta->chunk_record->size);
  }

  chunk_meta->set_last_read_packet_skipped(false);

  if (PERFETTO_UNLIKELY(packet_size == 0))
    return ReadPacketResult::kFailedEmptyPacket;

  if (PERFETTO_LIKELY(packet))
    packet->AddSlice(packet_data, static_cast<size_t>(packet_size));

  return ReadPacketResult::kSucceeded;
}

void TraceBuffer::DiscardWrite() {
  PERFETTO_DCHECK(overwrite_policy_ == kDiscard);
  discard_writes_ = true;
  stats_.set_chunks_discarded(stats_.chunks_discarded() + 1);
  TRACE_BUFFER_DLOG("  discarding write");
}

}  // namespace perfetto
// gen_amalgamated begin source: src/tracing/core/trace_config.cc
// gen_amalgamated begin header: include/perfetto/tracing/core/trace_config.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*******************************************************************************
 * AUTOGENERATED - DO NOT EDIT
 *******************************************************************************
 * This file has been generated from the protobuf message
 * perfetto/config/trace_config.proto
 * by
 * ../../tools/proto_to_cpp/proto_to_cpp.cc.
 * If you need to make changes here, change the .proto file and then run
 * ./tools/gen_tracing_cpp_headers_from_protos
 */

#ifndef INCLUDE_PERFETTO_TRACING_CORE_TRACE_CONFIG_H_
#define INCLUDE_PERFETTO_TRACING_CORE_TRACE_CONFIG_H_

#include <stdint.h>
#include <string>
#include <type_traits>
#include <vector>

// gen_amalgamated expanded: #include "perfetto/base/copyable_ptr.h"
// gen_amalgamated expanded: #include "perfetto/base/export.h"

// Forward declarations for protobuf types.
namespace perfetto {
namespace protos {
class TraceConfig;
class TraceConfig_BufferConfig;
class TraceConfig_DataSource;
class DataSourceConfig;
class ChromeConfig;
class TestConfig;
class TestConfig_DummyFields;
class TraceConfig_BuiltinDataSource;
class TraceConfig_ProducerConfig;
class TraceConfig_StatsdMetadata;
class TraceConfig_GuardrailOverrides;
class TraceConfig_TriggerConfig;
class TraceConfig_TriggerConfig_Trigger;
class TraceConfig_IncrementalStateConfig;
class TraceConfig_IncidentReportConfig;
}  // namespace protos
}  // namespace perfetto

namespace perfetto {
class TraceConfig;
class DataSourceConfig;
class ChromeConfig;
class TestConfig;

class PERFETTO_EXPORT TraceConfig {
 public:
  class PERFETTO_EXPORT BufferConfig {
   public:
    enum FillPolicy {
      UNSPECIFIED = 0,
      RING_BUFFER = 1,
      DISCARD = 2,
    };
    BufferConfig();
    ~BufferConfig();
    BufferConfig(BufferConfig&&) noexcept;
    BufferConfig& operator=(BufferConfig&&);
    BufferConfig(const BufferConfig&);
    BufferConfig& operator=(const BufferConfig&);
    bool operator==(const BufferConfig&) const;
    bool operator!=(const BufferConfig& other) const {
      return !(*this == other);
    }

    // Raw proto decoding.
    void ParseRawProto(const std::string&);
    // Conversion methods from/to the corresponding protobuf types.
    void FromProto(const perfetto::protos::TraceConfig_BufferConfig&);
    void ToProto(perfetto::protos::TraceConfig_BufferConfig*) const;

    uint32_t size_kb() const { return size_kb_; }
    void set_size_kb(uint32_t value) { size_kb_ = value; }

    FillPolicy fill_policy() const { return fill_policy_; }
    void set_fill_policy(FillPolicy value) { fill_policy_ = value; }

   private:
    uint32_t size_kb_{};
    FillPolicy fill_policy_{};

    // Allows to preserve unknown protobuf fields for compatibility
    // with future versions of .proto files.
    std::string unknown_fields_;
  };

  class PERFETTO_EXPORT DataSource {
   public:
    DataSource();
    ~DataSource();
    DataSource(DataSource&&) noexcept;
    DataSource& operator=(DataSource&&);
    DataSource(const DataSource&);
    DataSource& operator=(const DataSource&);
    bool operator==(const DataSource&) const;
    bool operator!=(const DataSource& other) const { return !(*this == other); }

    // Raw proto decoding.
    void ParseRawProto(const std::string&);
    // Conversion methods from/to the corresponding protobuf types.
    void FromProto(const perfetto::protos::TraceConfig_DataSource&);
    void ToProto(perfetto::protos::TraceConfig_DataSource*) const;

    const DataSourceConfig& config() const { return *config_; }
    DataSourceConfig* mutable_config() { return config_.get(); }

    int producer_name_filter_size() const {
      return static_cast<int>(producer_name_filter_.size());
    }
    const std::vector<std::string>& producer_name_filter() const {
      return producer_name_filter_;
    }
    std::vector<std::string>* mutable_producer_name_filter() {
      return &producer_name_filter_;
    }
    void clear_producer_name_filter() { producer_name_filter_.clear(); }
    std::string* add_producer_name_filter() {
      producer_name_filter_.emplace_back();
      return &producer_name_filter_.back();
    }

   private:
    ::perfetto::base::CopyablePtr<DataSourceConfig> config_;
    std::vector<std::string> producer_name_filter_;

    // Allows to preserve unknown protobuf fields for compatibility
    // with future versions of .proto files.
    std::string unknown_fields_;
  };

  class PERFETTO_EXPORT BuiltinDataSource {
   public:
    BuiltinDataSource();
    ~BuiltinDataSource();
    BuiltinDataSource(BuiltinDataSource&&) noexcept;
    BuiltinDataSource& operator=(BuiltinDataSource&&);
    BuiltinDataSource(const BuiltinDataSource&);
    BuiltinDataSource& operator=(const BuiltinDataSource&);
    bool operator==(const BuiltinDataSource&) const;
    bool operator!=(const BuiltinDataSource& other) const {
      return !(*this == other);
    }

    // Raw proto decoding.
    void ParseRawProto(const std::string&);
    // Conversion methods from/to the corresponding protobuf types.
    void FromProto(const perfetto::protos::TraceConfig_BuiltinDataSource&);
    void ToProto(perfetto::protos::TraceConfig_BuiltinDataSource*) const;

    bool disable_clock_snapshotting() const {
      return disable_clock_snapshotting_;
    }
    void set_disable_clock_snapshotting(bool value) {
      disable_clock_snapshotting_ = value;
    }

    bool disable_trace_config() const { return disable_trace_config_; }
    void set_disable_trace_config(bool value) { disable_trace_config_ = value; }

    bool disable_system_info() const { return disable_system_info_; }
    void set_disable_system_info(bool value) { disable_system_info_ = value; }

   private:
    bool disable_clock_snapshotting_{};
    bool disable_trace_config_{};
    bool disable_system_info_{};

    // Allows to preserve unknown protobuf fields for compatibility
    // with future versions of .proto files.
    std::string unknown_fields_;
  };

  enum LockdownModeOperation {
    LOCKDOWN_UNCHANGED = 0,
    LOCKDOWN_CLEAR = 1,
    LOCKDOWN_SET = 2,
  };

  class PERFETTO_EXPORT ProducerConfig {
   public:
    ProducerConfig();
    ~ProducerConfig();
    ProducerConfig(ProducerConfig&&) noexcept;
    ProducerConfig& operator=(ProducerConfig&&);
    ProducerConfig(const ProducerConfig&);
    ProducerConfig& operator=(const ProducerConfig&);
    bool operator==(const ProducerConfig&) const;
    bool operator!=(const ProducerConfig& other) const {
      return !(*this == other);
    }

    // Raw proto decoding.
    void ParseRawProto(const std::string&);
    // Conversion methods from/to the corresponding protobuf types.
    void FromProto(const perfetto::protos::TraceConfig_ProducerConfig&);
    void ToProto(perfetto::protos::TraceConfig_ProducerConfig*) const;

    const std::string& producer_name() const { return producer_name_; }
    void set_producer_name(const std::string& value) { producer_name_ = value; }

    uint32_t shm_size_kb() const { return shm_size_kb_; }
    void set_shm_size_kb(uint32_t value) { shm_size_kb_ = value; }

    uint32_t page_size_kb() const { return page_size_kb_; }
    void set_page_size_kb(uint32_t value) { page_size_kb_ = value; }

   private:
    std::string producer_name_{};
    uint32_t shm_size_kb_{};
    uint32_t page_size_kb_{};

    // Allows to preserve unknown protobuf fields for compatibility
    // with future versions of .proto files.
    std::string unknown_fields_;
  };

  class PERFETTO_EXPORT StatsdMetadata {
   public:
    StatsdMetadata();
    ~StatsdMetadata();
    StatsdMetadata(StatsdMetadata&&) noexcept;
    StatsdMetadata& operator=(StatsdMetadata&&);
    StatsdMetadata(const StatsdMetadata&);
    StatsdMetadata& operator=(const StatsdMetadata&);
    bool operator==(const StatsdMetadata&) const;
    bool operator!=(const StatsdMetadata& other) const {
      return !(*this == other);
    }

    // Raw proto decoding.
    void ParseRawProto(const std::string&);
    // Conversion methods from/to the corresponding protobuf types.
    void FromProto(const perfetto::protos::TraceConfig_StatsdMetadata&);
    void ToProto(perfetto::protos::TraceConfig_StatsdMetadata*) const;

    int64_t triggering_alert_id() const { return triggering_alert_id_; }
    void set_triggering_alert_id(int64_t value) {
      triggering_alert_id_ = value;
    }

    int32_t triggering_config_uid() const { return triggering_config_uid_; }
    void set_triggering_config_uid(int32_t value) {
      triggering_config_uid_ = value;
    }

    int64_t triggering_config_id() const { return triggering_config_id_; }
    void set_triggering_config_id(int64_t value) {
      triggering_config_id_ = value;
    }

    int64_t triggering_subscription_id() const {
      return triggering_subscription_id_;
    }
    void set_triggering_subscription_id(int64_t value) {
      triggering_subscription_id_ = value;
    }

   private:
    int64_t triggering_alert_id_{};
    int32_t triggering_config_uid_{};
    int64_t triggering_config_id_{};
    int64_t triggering_subscription_id_{};

    // Allows to preserve unknown protobuf fields for compatibility
    // with future versions of .proto files.
    std::string unknown_fields_;
  };

  class PERFETTO_EXPORT GuardrailOverrides {
   public:
    GuardrailOverrides();
    ~GuardrailOverrides();
    GuardrailOverrides(GuardrailOverrides&&) noexcept;
    GuardrailOverrides& operator=(GuardrailOverrides&&);
    GuardrailOverrides(const GuardrailOverrides&);
    GuardrailOverrides& operator=(const GuardrailOverrides&);
    bool operator==(const GuardrailOverrides&) const;
    bool operator!=(const GuardrailOverrides& other) const {
      return !(*this == other);
    }

    // Raw proto decoding.
    void ParseRawProto(const std::string&);
    // Conversion methods from/to the corresponding protobuf types.
    void FromProto(const perfetto::protos::TraceConfig_GuardrailOverrides&);
    void ToProto(perfetto::protos::TraceConfig_GuardrailOverrides*) const;

    uint64_t max_upload_per_day_bytes() const {
      return max_upload_per_day_bytes_;
    }
    void set_max_upload_per_day_bytes(uint64_t value) {
      max_upload_per_day_bytes_ = value;
    }

   private:
    uint64_t max_upload_per_day_bytes_{};

    // Allows to preserve unknown protobuf fields for compatibility
    // with future versions of .proto files.
    std::string unknown_fields_;
  };

  class PERFETTO_EXPORT TriggerConfig {
   public:
    enum TriggerMode {
      UNSPECIFIED = 0,
      START_TRACING = 1,
      STOP_TRACING = 2,
    };

    class PERFETTO_EXPORT Trigger {
     public:
      Trigger();
      ~Trigger();
      Trigger(Trigger&&) noexcept;
      Trigger& operator=(Trigger&&);
      Trigger(const Trigger&);
      Trigger& operator=(const Trigger&);
      bool operator==(const Trigger&) const;
      bool operator!=(const Trigger& other) const { return !(*this == other); }

      // Raw proto decoding.
      void ParseRawProto(const std::string&);
      // Conversion methods from/to the corresponding protobuf types.
      void FromProto(
          const perfetto::protos::TraceConfig_TriggerConfig_Trigger&);
      void ToProto(perfetto::protos::TraceConfig_TriggerConfig_Trigger*) const;

      const std::string& name() const { return name_; }
      void set_name(const std::string& value) { name_ = value; }

      const std::string& producer_name_regex() const {
        return producer_name_regex_;
      }
      void set_producer_name_regex(const std::string& value) {
        producer_name_regex_ = value;
      }

      uint32_t stop_delay_ms() const { return stop_delay_ms_; }
      void set_stop_delay_ms(uint32_t value) { stop_delay_ms_ = value; }

     private:
      std::string name_{};
      std::string producer_name_regex_{};
      uint32_t stop_delay_ms_{};

      // Allows to preserve unknown protobuf fields for compatibility
      // with future versions of .proto files.
      std::string unknown_fields_;
    };

    TriggerConfig();
    ~TriggerConfig();
    TriggerConfig(TriggerConfig&&) noexcept;
    TriggerConfig& operator=(TriggerConfig&&);
    TriggerConfig(const TriggerConfig&);
    TriggerConfig& operator=(const TriggerConfig&);
    bool operator==(const TriggerConfig&) const;
    bool operator!=(const TriggerConfig& other) const {
      return !(*this == other);
    }

    // Raw proto decoding.
    void ParseRawProto(const std::string&);
    // Conversion methods from/to the corresponding protobuf types.
    void FromProto(const perfetto::protos::TraceConfig_TriggerConfig&);
    void ToProto(perfetto::protos::TraceConfig_TriggerConfig*) const;

    TriggerMode trigger_mode() const { return trigger_mode_; }
    void set_trigger_mode(TriggerMode value) { trigger_mode_ = value; }

    int triggers_size() const { return static_cast<int>(triggers_.size()); }
    const std::vector<Trigger>& triggers() const { return triggers_; }
    std::vector<Trigger>* mutable_triggers() { return &triggers_; }
    void clear_triggers() { triggers_.clear(); }
    Trigger* add_triggers() {
      triggers_.emplace_back();
      return &triggers_.back();
    }

    uint32_t trigger_timeout_ms() const { return trigger_timeout_ms_; }
    void set_trigger_timeout_ms(uint32_t value) { trigger_timeout_ms_ = value; }

   private:
    TriggerMode trigger_mode_{};
    std::vector<Trigger> triggers_;
    uint32_t trigger_timeout_ms_{};

    // Allows to preserve unknown protobuf fields for compatibility
    // with future versions of .proto files.
    std::string unknown_fields_;
  };

  class PERFETTO_EXPORT IncrementalStateConfig {
   public:
    IncrementalStateConfig();
    ~IncrementalStateConfig();
    IncrementalStateConfig(IncrementalStateConfig&&) noexcept;
    IncrementalStateConfig& operator=(IncrementalStateConfig&&);
    IncrementalStateConfig(const IncrementalStateConfig&);
    IncrementalStateConfig& operator=(const IncrementalStateConfig&);
    bool operator==(const IncrementalStateConfig&) const;
    bool operator!=(const IncrementalStateConfig& other) const {
      return !(*this == other);
    }

    // Raw proto decoding.
    void ParseRawProto(const std::string&);
    // Conversion methods from/to the corresponding protobuf types.
    void FromProto(const perfetto::protos::TraceConfig_IncrementalStateConfig&);
    void ToProto(perfetto::protos::TraceConfig_IncrementalStateConfig*) const;

    uint32_t clear_period_ms() const { return clear_period_ms_; }
    void set_clear_period_ms(uint32_t value) { clear_period_ms_ = value; }

   private:
    uint32_t clear_period_ms_{};

    // Allows to preserve unknown protobuf fields for compatibility
    // with future versions of .proto files.
    std::string unknown_fields_;
  };

  enum CompressionType {
    COMPRESSION_TYPE_UNSPECIFIED = 0,
    COMPRESSION_TYPE_DEFLATE = 1,
  };

  class PERFETTO_EXPORT IncidentReportConfig {
   public:
    IncidentReportConfig();
    ~IncidentReportConfig();
    IncidentReportConfig(IncidentReportConfig&&) noexcept;
    IncidentReportConfig& operator=(IncidentReportConfig&&);
    IncidentReportConfig(const IncidentReportConfig&);
    IncidentReportConfig& operator=(const IncidentReportConfig&);
    bool operator==(const IncidentReportConfig&) const;
    bool operator!=(const IncidentReportConfig& other) const {
      return !(*this == other);
    }

    // Raw proto decoding.
    void ParseRawProto(const std::string&);
    // Conversion methods from/to the corresponding protobuf types.
    void FromProto(const perfetto::protos::TraceConfig_IncidentReportConfig&);
    void ToProto(perfetto::protos::TraceConfig_IncidentReportConfig*) const;

    const std::string& destination_package() const {
      return destination_package_;
    }
    void set_destination_package(const std::string& value) {
      destination_package_ = value;
    }

    const std::string& destination_class() const { return destination_class_; }
    void set_destination_class(const std::string& value) {
      destination_class_ = value;
    }

    int32_t privacy_level() const { return privacy_level_; }
    void set_privacy_level(int32_t value) { privacy_level_ = value; }

    bool skip_dropbox() const { return skip_dropbox_; }
    void set_skip_dropbox(bool value) { skip_dropbox_ = value; }

   private:
    std::string destination_package_{};
    std::string destination_class_{};
    int32_t privacy_level_{};
    bool skip_dropbox_{};

    // Allows to preserve unknown protobuf fields for compatibility
    // with future versions of .proto files.
    std::string unknown_fields_;
  };

  TraceConfig();
  ~TraceConfig();
  TraceConfig(TraceConfig&&) noexcept;
  TraceConfig& operator=(TraceConfig&&);
  TraceConfig(const TraceConfig&);
  TraceConfig& operator=(const TraceConfig&);
  bool operator==(const TraceConfig&) const;
  bool operator!=(const TraceConfig& other) const { return !(*this == other); }

  // Raw proto decoding.
  void ParseRawProto(const std::string&);
  // Conversion methods from/to the corresponding protobuf types.
  void FromProto(const perfetto::protos::TraceConfig&);
  void ToProto(perfetto::protos::TraceConfig*) const;

  int buffers_size() const { return static_cast<int>(buffers_.size()); }
  const std::vector<BufferConfig>& buffers() const { return buffers_; }
  std::vector<BufferConfig>* mutable_buffers() { return &buffers_; }
  void clear_buffers() { buffers_.clear(); }
  BufferConfig* add_buffers() {
    buffers_.emplace_back();
    return &buffers_.back();
  }

  int data_sources_size() const {
    return static_cast<int>(data_sources_.size());
  }
  const std::vector<DataSource>& data_sources() const { return data_sources_; }
  std::vector<DataSource>* mutable_data_sources() { return &data_sources_; }
  void clear_data_sources() { data_sources_.clear(); }
  DataSource* add_data_sources() {
    data_sources_.emplace_back();
    return &data_sources_.back();
  }

  const BuiltinDataSource& builtin_data_sources() const {
    return *builtin_data_sources_;
  }
  BuiltinDataSource* mutable_builtin_data_sources() {
    return builtin_data_sources_.get();
  }

  uint32_t duration_ms() const { return duration_ms_; }
  void set_duration_ms(uint32_t value) { duration_ms_ = value; }

  bool enable_extra_guardrails() const { return enable_extra_guardrails_; }
  void set_enable_extra_guardrails(bool value) {
    enable_extra_guardrails_ = value;
  }

  LockdownModeOperation lockdown_mode() const { return lockdown_mode_; }
  void set_lockdown_mode(LockdownModeOperation value) {
    lockdown_mode_ = value;
  }

  int producers_size() const { return static_cast<int>(producers_.size()); }
  const std::vector<ProducerConfig>& producers() const { return producers_; }
  std::vector<ProducerConfig>* mutable_producers() { return &producers_; }
  void clear_producers() { producers_.clear(); }
  ProducerConfig* add_producers() {
    producers_.emplace_back();
    return &producers_.back();
  }

  const StatsdMetadata& statsd_metadata() const { return *statsd_metadata_; }
  StatsdMetadata* mutable_statsd_metadata() { return statsd_metadata_.get(); }

  bool write_into_file() const { return write_into_file_; }
  void set_write_into_file(bool value) { write_into_file_ = value; }

  uint32_t file_write_period_ms() const { return file_write_period_ms_; }
  void set_file_write_period_ms(uint32_t value) {
    file_write_period_ms_ = value;
  }

  uint64_t max_file_size_bytes() const { return max_file_size_bytes_; }
  void set_max_file_size_bytes(uint64_t value) { max_file_size_bytes_ = value; }

  const GuardrailOverrides& guardrail_overrides() const {
    return *guardrail_overrides_;
  }
  GuardrailOverrides* mutable_guardrail_overrides() {
    return guardrail_overrides_.get();
  }

  bool deferred_start() const { return deferred_start_; }
  void set_deferred_start(bool value) { deferred_start_ = value; }

  uint32_t flush_period_ms() const { return flush_period_ms_; }
  void set_flush_period_ms(uint32_t value) { flush_period_ms_ = value; }

  uint32_t flush_timeout_ms() const { return flush_timeout_ms_; }
  void set_flush_timeout_ms(uint32_t value) { flush_timeout_ms_ = value; }

  uint32_t data_source_stop_timeout_ms() const {
    return data_source_stop_timeout_ms_;
  }
  void set_data_source_stop_timeout_ms(uint32_t value) {
    data_source_stop_timeout_ms_ = value;
  }

  bool notify_traceur() const { return notify_traceur_; }
  void set_notify_traceur(bool value) { notify_traceur_ = value; }

  const TriggerConfig& trigger_config() const { return *trigger_config_; }
  TriggerConfig* mutable_trigger_config() { return trigger_config_.get(); }

  int activate_triggers_size() const {
    return static_cast<int>(activate_triggers_.size());
  }
  const std::vector<std::string>& activate_triggers() const {
    return activate_triggers_;
  }
  std::vector<std::string>* mutable_activate_triggers() {
    return &activate_triggers_;
  }
  void clear_activate_triggers() { activate_triggers_.clear(); }
  std::string* add_activate_triggers() {
    activate_triggers_.emplace_back();
    return &activate_triggers_.back();
  }

  const IncrementalStateConfig& incremental_state_config() const {
    return *incremental_state_config_;
  }
  IncrementalStateConfig* mutable_incremental_state_config() {
    return incremental_state_config_.get();
  }

  bool allow_user_build_tracing() const { return allow_user_build_tracing_; }
  void set_allow_user_build_tracing(bool value) {
    allow_user_build_tracing_ = value;
  }

  const std::string& unique_session_name() const {
    return unique_session_name_;
  }
  void set_unique_session_name(const std::string& value) {
    unique_session_name_ = value;
  }

  CompressionType compression_type() const { return compression_type_; }
  void set_compression_type(CompressionType value) {
    compression_type_ = value;
  }

  const IncidentReportConfig& incident_report_config() const {
    return *incident_report_config_;
  }
  IncidentReportConfig* mutable_incident_report_config() {
    return incident_report_config_.get();
  }

 private:
  std::vector<BufferConfig> buffers_;
  std::vector<DataSource> data_sources_;
  ::perfetto::base::CopyablePtr<BuiltinDataSource> builtin_data_sources_;
  uint32_t duration_ms_{};
  bool enable_extra_guardrails_{};
  LockdownModeOperation lockdown_mode_{};
  std::vector<ProducerConfig> producers_;
  ::perfetto::base::CopyablePtr<StatsdMetadata> statsd_metadata_;
  bool write_into_file_{};
  uint32_t file_write_period_ms_{};
  uint64_t max_file_size_bytes_{};
  ::perfetto::base::CopyablePtr<GuardrailOverrides> guardrail_overrides_;
  bool deferred_start_{};
  uint32_t flush_period_ms_{};
  uint32_t flush_timeout_ms_{};
  uint32_t data_source_stop_timeout_ms_{};
  bool notify_traceur_{};
  ::perfetto::base::CopyablePtr<TriggerConfig> trigger_config_;
  std::vector<std::string> activate_triggers_;
  ::perfetto::base::CopyablePtr<IncrementalStateConfig>
      incremental_state_config_;
  bool allow_user_build_tracing_{};
  std::string unique_session_name_{};
  CompressionType compression_type_{};
  ::perfetto::base::CopyablePtr<IncidentReportConfig> incident_report_config_;

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;
};

}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_TRACING_CORE_TRACE_CONFIG_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*******************************************************************************
 * AUTOGENERATED - DO NOT EDIT
 *******************************************************************************
 * This file has been generated from the protobuf message
 * perfetto/config/trace_config.proto
 * by
 * ../../tools/proto_to_cpp/proto_to_cpp.cc.
 * If you need to make changes here, change the .proto file and then run
 * ./tools/gen_tracing_cpp_headers_from_protos
 */

// gen_amalgamated expanded: #include "perfetto/tracing/core/trace_config.h"

// gen_amalgamated expanded: #include "perfetto/config/trace_config.pb.h"

// gen_amalgamated expanded: #include "perfetto/config/data_source_config.pb.h"
// gen_amalgamated expanded: #include "perfetto/tracing/core/data_source_config.h"

namespace perfetto {

TraceConfig::TraceConfig() = default;
TraceConfig::~TraceConfig() = default;
TraceConfig::TraceConfig(const TraceConfig&) = default;
TraceConfig& TraceConfig::operator=(const TraceConfig&) = default;
TraceConfig::TraceConfig(TraceConfig&&) noexcept = default;
TraceConfig& TraceConfig::operator=(TraceConfig&&) = default;

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
bool TraceConfig::operator==(const TraceConfig& other) const {
  return (buffers_ == other.buffers_) &&
         (data_sources_ == other.data_sources_) &&
         (builtin_data_sources_ == other.builtin_data_sources_) &&
         (duration_ms_ == other.duration_ms_) &&
         (enable_extra_guardrails_ == other.enable_extra_guardrails_) &&
         (lockdown_mode_ == other.lockdown_mode_) &&
         (producers_ == other.producers_) &&
         (statsd_metadata_ == other.statsd_metadata_) &&
         (write_into_file_ == other.write_into_file_) &&
         (file_write_period_ms_ == other.file_write_period_ms_) &&
         (max_file_size_bytes_ == other.max_file_size_bytes_) &&
         (guardrail_overrides_ == other.guardrail_overrides_) &&
         (deferred_start_ == other.deferred_start_) &&
         (flush_period_ms_ == other.flush_period_ms_) &&
         (flush_timeout_ms_ == other.flush_timeout_ms_) &&
         (data_source_stop_timeout_ms_ == other.data_source_stop_timeout_ms_) &&
         (notify_traceur_ == other.notify_traceur_) &&
         (trigger_config_ == other.trigger_config_) &&
         (activate_triggers_ == other.activate_triggers_) &&
         (incremental_state_config_ == other.incremental_state_config_) &&
         (allow_user_build_tracing_ == other.allow_user_build_tracing_) &&
         (unique_session_name_ == other.unique_session_name_) &&
         (compression_type_ == other.compression_type_) &&
         (incident_report_config_ == other.incident_report_config_);
}
#pragma GCC diagnostic pop

void TraceConfig::ParseRawProto(const std::string& raw) {
  perfetto::protos::TraceConfig proto;
  proto.ParseFromString(raw);
  FromProto(proto);
}

void TraceConfig::FromProto(const perfetto::protos::TraceConfig& proto) {
  buffers_.clear();
  for (const auto& field : proto.buffers()) {
    buffers_.emplace_back();
    buffers_.back().FromProto(field);
  }

  data_sources_.clear();
  for (const auto& field : proto.data_sources()) {
    data_sources_.emplace_back();
    data_sources_.back().FromProto(field);
  }

  builtin_data_sources_->FromProto(proto.builtin_data_sources());

  static_assert(sizeof(duration_ms_) == sizeof(proto.duration_ms()),
                "size mismatch");
  duration_ms_ = static_cast<decltype(duration_ms_)>(proto.duration_ms());

  static_assert(sizeof(enable_extra_guardrails_) ==
                    sizeof(proto.enable_extra_guardrails()),
                "size mismatch");
  enable_extra_guardrails_ = static_cast<decltype(enable_extra_guardrails_)>(
      proto.enable_extra_guardrails());

  static_assert(sizeof(lockdown_mode_) == sizeof(proto.lockdown_mode()),
                "size mismatch");
  lockdown_mode_ = static_cast<decltype(lockdown_mode_)>(proto.lockdown_mode());

  producers_.clear();
  for (const auto& field : proto.producers()) {
    producers_.emplace_back();
    producers_.back().FromProto(field);
  }

  statsd_metadata_->FromProto(proto.statsd_metadata());

  static_assert(sizeof(write_into_file_) == sizeof(proto.write_into_file()),
                "size mismatch");
  write_into_file_ =
      static_cast<decltype(write_into_file_)>(proto.write_into_file());

  static_assert(
      sizeof(file_write_period_ms_) == sizeof(proto.file_write_period_ms()),
      "size mismatch");
  file_write_period_ms_ = static_cast<decltype(file_write_period_ms_)>(
      proto.file_write_period_ms());

  static_assert(
      sizeof(max_file_size_bytes_) == sizeof(proto.max_file_size_bytes()),
      "size mismatch");
  max_file_size_bytes_ =
      static_cast<decltype(max_file_size_bytes_)>(proto.max_file_size_bytes());

  guardrail_overrides_->FromProto(proto.guardrail_overrides());

  static_assert(sizeof(deferred_start_) == sizeof(proto.deferred_start()),
                "size mismatch");
  deferred_start_ =
      static_cast<decltype(deferred_start_)>(proto.deferred_start());

  static_assert(sizeof(flush_period_ms_) == sizeof(proto.flush_period_ms()),
                "size mismatch");
  flush_period_ms_ =
      static_cast<decltype(flush_period_ms_)>(proto.flush_period_ms());

  static_assert(sizeof(flush_timeout_ms_) == sizeof(proto.flush_timeout_ms()),
                "size mismatch");
  flush_timeout_ms_ =
      static_cast<decltype(flush_timeout_ms_)>(proto.flush_timeout_ms());

  static_assert(sizeof(data_source_stop_timeout_ms_) ==
                    sizeof(proto.data_source_stop_timeout_ms()),
                "size mismatch");
  data_source_stop_timeout_ms_ =
      static_cast<decltype(data_source_stop_timeout_ms_)>(
          proto.data_source_stop_timeout_ms());

  static_assert(sizeof(notify_traceur_) == sizeof(proto.notify_traceur()),
                "size mismatch");
  notify_traceur_ =
      static_cast<decltype(notify_traceur_)>(proto.notify_traceur());

  trigger_config_->FromProto(proto.trigger_config());

  activate_triggers_.clear();
  for (const auto& field : proto.activate_triggers()) {
    activate_triggers_.emplace_back();
    static_assert(
        sizeof(activate_triggers_.back()) == sizeof(proto.activate_triggers(0)),
        "size mismatch");
    activate_triggers_.back() =
        static_cast<decltype(activate_triggers_)::value_type>(field);
  }

  incremental_state_config_->FromProto(proto.incremental_state_config());

  static_assert(sizeof(allow_user_build_tracing_) ==
                    sizeof(proto.allow_user_build_tracing()),
                "size mismatch");
  allow_user_build_tracing_ = static_cast<decltype(allow_user_build_tracing_)>(
      proto.allow_user_build_tracing());

  static_assert(
      sizeof(unique_session_name_) == sizeof(proto.unique_session_name()),
      "size mismatch");
  unique_session_name_ =
      static_cast<decltype(unique_session_name_)>(proto.unique_session_name());

  static_assert(sizeof(compression_type_) == sizeof(proto.compression_type()),
                "size mismatch");
  compression_type_ =
      static_cast<decltype(compression_type_)>(proto.compression_type());

  incident_report_config_->FromProto(proto.incident_report_config());
  unknown_fields_ = proto.unknown_fields();
}

void TraceConfig::ToProto(perfetto::protos::TraceConfig* proto) const {
  proto->Clear();

  for (const auto& it : buffers_) {
    auto* entry = proto->add_buffers();
    it.ToProto(entry);
  }

  for (const auto& it : data_sources_) {
    auto* entry = proto->add_data_sources();
    it.ToProto(entry);
  }

  builtin_data_sources_->ToProto(proto->mutable_builtin_data_sources());

  static_assert(sizeof(duration_ms_) == sizeof(proto->duration_ms()),
                "size mismatch");
  proto->set_duration_ms(
      static_cast<decltype(proto->duration_ms())>(duration_ms_));

  static_assert(sizeof(enable_extra_guardrails_) ==
                    sizeof(proto->enable_extra_guardrails()),
                "size mismatch");
  proto->set_enable_extra_guardrails(
      static_cast<decltype(proto->enable_extra_guardrails())>(
          enable_extra_guardrails_));

  static_assert(sizeof(lockdown_mode_) == sizeof(proto->lockdown_mode()),
                "size mismatch");
  proto->set_lockdown_mode(
      static_cast<decltype(proto->lockdown_mode())>(lockdown_mode_));

  for (const auto& it : producers_) {
    auto* entry = proto->add_producers();
    it.ToProto(entry);
  }

  statsd_metadata_->ToProto(proto->mutable_statsd_metadata());

  static_assert(sizeof(write_into_file_) == sizeof(proto->write_into_file()),
                "size mismatch");
  proto->set_write_into_file(
      static_cast<decltype(proto->write_into_file())>(write_into_file_));

  static_assert(
      sizeof(file_write_period_ms_) == sizeof(proto->file_write_period_ms()),
      "size mismatch");
  proto->set_file_write_period_ms(
      static_cast<decltype(proto->file_write_period_ms())>(
          file_write_period_ms_));

  static_assert(
      sizeof(max_file_size_bytes_) == sizeof(proto->max_file_size_bytes()),
      "size mismatch");
  proto->set_max_file_size_bytes(
      static_cast<decltype(proto->max_file_size_bytes())>(
          max_file_size_bytes_));

  guardrail_overrides_->ToProto(proto->mutable_guardrail_overrides());

  static_assert(sizeof(deferred_start_) == sizeof(proto->deferred_start()),
                "size mismatch");
  proto->set_deferred_start(
      static_cast<decltype(proto->deferred_start())>(deferred_start_));

  static_assert(sizeof(flush_period_ms_) == sizeof(proto->flush_period_ms()),
                "size mismatch");
  proto->set_flush_period_ms(
      static_cast<decltype(proto->flush_period_ms())>(flush_period_ms_));

  static_assert(sizeof(flush_timeout_ms_) == sizeof(proto->flush_timeout_ms()),
                "size mismatch");
  proto->set_flush_timeout_ms(
      static_cast<decltype(proto->flush_timeout_ms())>(flush_timeout_ms_));

  static_assert(sizeof(data_source_stop_timeout_ms_) ==
                    sizeof(proto->data_source_stop_timeout_ms()),
                "size mismatch");
  proto->set_data_source_stop_timeout_ms(
      static_cast<decltype(proto->data_source_stop_timeout_ms())>(
          data_source_stop_timeout_ms_));

  static_assert(sizeof(notify_traceur_) == sizeof(proto->notify_traceur()),
                "size mismatch");
  proto->set_notify_traceur(
      static_cast<decltype(proto->notify_traceur())>(notify_traceur_));

  trigger_config_->ToProto(proto->mutable_trigger_config());

  for (const auto& it : activate_triggers_) {
    proto->add_activate_triggers(
        static_cast<decltype(proto->activate_triggers(0))>(it));
    static_assert(sizeof(it) == sizeof(proto->activate_triggers(0)),
                  "size mismatch");
  }

  incremental_state_config_->ToProto(proto->mutable_incremental_state_config());

  static_assert(sizeof(allow_user_build_tracing_) ==
                    sizeof(proto->allow_user_build_tracing()),
                "size mismatch");
  proto->set_allow_user_build_tracing(
      static_cast<decltype(proto->allow_user_build_tracing())>(
          allow_user_build_tracing_));

  static_assert(
      sizeof(unique_session_name_) == sizeof(proto->unique_session_name()),
      "size mismatch");
  proto->set_unique_session_name(
      static_cast<decltype(proto->unique_session_name())>(
          unique_session_name_));

  static_assert(sizeof(compression_type_) == sizeof(proto->compression_type()),
                "size mismatch");
  proto->set_compression_type(
      static_cast<decltype(proto->compression_type())>(compression_type_));

  incident_report_config_->ToProto(proto->mutable_incident_report_config());
  *(proto->mutable_unknown_fields()) = unknown_fields_;
}

TraceConfig::BufferConfig::BufferConfig() = default;
TraceConfig::BufferConfig::~BufferConfig() = default;
TraceConfig::BufferConfig::BufferConfig(const TraceConfig::BufferConfig&) =
    default;
TraceConfig::BufferConfig& TraceConfig::BufferConfig::operator=(
    const TraceConfig::BufferConfig&) = default;
TraceConfig::BufferConfig::BufferConfig(TraceConfig::BufferConfig&&) noexcept =
    default;
TraceConfig::BufferConfig& TraceConfig::BufferConfig::operator=(
    TraceConfig::BufferConfig&&) = default;

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
bool TraceConfig::BufferConfig::operator==(
    const TraceConfig::BufferConfig& other) const {
  return (size_kb_ == other.size_kb_) && (fill_policy_ == other.fill_policy_);
}
#pragma GCC diagnostic pop

void TraceConfig::BufferConfig::ParseRawProto(const std::string& raw) {
  perfetto::protos::TraceConfig_BufferConfig proto;
  proto.ParseFromString(raw);
  FromProto(proto);
}

void TraceConfig::BufferConfig::FromProto(
    const perfetto::protos::TraceConfig_BufferConfig& proto) {
  static_assert(sizeof(size_kb_) == sizeof(proto.size_kb()), "size mismatch");
  size_kb_ = static_cast<decltype(size_kb_)>(proto.size_kb());

  static_assert(sizeof(fill_policy_) == sizeof(proto.fill_policy()),
                "size mismatch");
  fill_policy_ = static_cast<decltype(fill_policy_)>(proto.fill_policy());
  unknown_fields_ = proto.unknown_fields();
}

void TraceConfig::BufferConfig::ToProto(
    perfetto::protos::TraceConfig_BufferConfig* proto) const {
  proto->Clear();

  static_assert(sizeof(size_kb_) == sizeof(proto->size_kb()), "size mismatch");
  proto->set_size_kb(static_cast<decltype(proto->size_kb())>(size_kb_));

  static_assert(sizeof(fill_policy_) == sizeof(proto->fill_policy()),
                "size mismatch");
  proto->set_fill_policy(
      static_cast<decltype(proto->fill_policy())>(fill_policy_));
  *(proto->mutable_unknown_fields()) = unknown_fields_;
}

TraceConfig::DataSource::DataSource() = default;
TraceConfig::DataSource::~DataSource() = default;
TraceConfig::DataSource::DataSource(const TraceConfig::DataSource&) = default;
TraceConfig::DataSource& TraceConfig::DataSource::operator=(
    const TraceConfig::DataSource&) = default;
TraceConfig::DataSource::DataSource(TraceConfig::DataSource&&) noexcept =
    default;
TraceConfig::DataSource& TraceConfig::DataSource::operator=(
    TraceConfig::DataSource&&) = default;

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
bool TraceConfig::DataSource::operator==(
    const TraceConfig::DataSource& other) const {
  return (config_ == other.config_) &&
         (producer_name_filter_ == other.producer_name_filter_);
}
#pragma GCC diagnostic pop

void TraceConfig::DataSource::ParseRawProto(const std::string& raw) {
  perfetto::protos::TraceConfig_DataSource proto;
  proto.ParseFromString(raw);
  FromProto(proto);
}

void TraceConfig::DataSource::FromProto(
    const perfetto::protos::TraceConfig_DataSource& proto) {
  config_->FromProto(proto.config());

  producer_name_filter_.clear();
  for (const auto& field : proto.producer_name_filter()) {
    producer_name_filter_.emplace_back();
    static_assert(sizeof(producer_name_filter_.back()) ==
                      sizeof(proto.producer_name_filter(0)),
                  "size mismatch");
    producer_name_filter_.back() =
        static_cast<decltype(producer_name_filter_)::value_type>(field);
  }
  unknown_fields_ = proto.unknown_fields();
}

void TraceConfig::DataSource::ToProto(
    perfetto::protos::TraceConfig_DataSource* proto) const {
  proto->Clear();

  config_->ToProto(proto->mutable_config());

  for (const auto& it : producer_name_filter_) {
    proto->add_producer_name_filter(
        static_cast<decltype(proto->producer_name_filter(0))>(it));
    static_assert(sizeof(it) == sizeof(proto->producer_name_filter(0)),
                  "size mismatch");
  }
  *(proto->mutable_unknown_fields()) = unknown_fields_;
}

TraceConfig::BuiltinDataSource::BuiltinDataSource() = default;
TraceConfig::BuiltinDataSource::~BuiltinDataSource() = default;
TraceConfig::BuiltinDataSource::BuiltinDataSource(
    const TraceConfig::BuiltinDataSource&) = default;
TraceConfig::BuiltinDataSource& TraceConfig::BuiltinDataSource::operator=(
    const TraceConfig::BuiltinDataSource&) = default;
TraceConfig::BuiltinDataSource::BuiltinDataSource(
    TraceConfig::BuiltinDataSource&&) noexcept = default;
TraceConfig::BuiltinDataSource& TraceConfig::BuiltinDataSource::operator=(
    TraceConfig::BuiltinDataSource&&) = default;

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
bool TraceConfig::BuiltinDataSource::operator==(
    const TraceConfig::BuiltinDataSource& other) const {
  return (disable_clock_snapshotting_ == other.disable_clock_snapshotting_) &&
         (disable_trace_config_ == other.disable_trace_config_) &&
         (disable_system_info_ == other.disable_system_info_);
}
#pragma GCC diagnostic pop

void TraceConfig::BuiltinDataSource::ParseRawProto(const std::string& raw) {
  perfetto::protos::TraceConfig_BuiltinDataSource proto;
  proto.ParseFromString(raw);
  FromProto(proto);
}

void TraceConfig::BuiltinDataSource::FromProto(
    const perfetto::protos::TraceConfig_BuiltinDataSource& proto) {
  static_assert(sizeof(disable_clock_snapshotting_) ==
                    sizeof(proto.disable_clock_snapshotting()),
                "size mismatch");
  disable_clock_snapshotting_ =
      static_cast<decltype(disable_clock_snapshotting_)>(
          proto.disable_clock_snapshotting());

  static_assert(
      sizeof(disable_trace_config_) == sizeof(proto.disable_trace_config()),
      "size mismatch");
  disable_trace_config_ = static_cast<decltype(disable_trace_config_)>(
      proto.disable_trace_config());

  static_assert(
      sizeof(disable_system_info_) == sizeof(proto.disable_system_info()),
      "size mismatch");
  disable_system_info_ =
      static_cast<decltype(disable_system_info_)>(proto.disable_system_info());
  unknown_fields_ = proto.unknown_fields();
}

void TraceConfig::BuiltinDataSource::ToProto(
    perfetto::protos::TraceConfig_BuiltinDataSource* proto) const {
  proto->Clear();

  static_assert(sizeof(disable_clock_snapshotting_) ==
                    sizeof(proto->disable_clock_snapshotting()),
                "size mismatch");
  proto->set_disable_clock_snapshotting(
      static_cast<decltype(proto->disable_clock_snapshotting())>(
          disable_clock_snapshotting_));

  static_assert(
      sizeof(disable_trace_config_) == sizeof(proto->disable_trace_config()),
      "size mismatch");
  proto->set_disable_trace_config(
      static_cast<decltype(proto->disable_trace_config())>(
          disable_trace_config_));

  static_assert(
      sizeof(disable_system_info_) == sizeof(proto->disable_system_info()),
      "size mismatch");
  proto->set_disable_system_info(
      static_cast<decltype(proto->disable_system_info())>(
          disable_system_info_));
  *(proto->mutable_unknown_fields()) = unknown_fields_;
}

TraceConfig::ProducerConfig::ProducerConfig() = default;
TraceConfig::ProducerConfig::~ProducerConfig() = default;
TraceConfig::ProducerConfig::ProducerConfig(
    const TraceConfig::ProducerConfig&) = default;
TraceConfig::ProducerConfig& TraceConfig::ProducerConfig::operator=(
    const TraceConfig::ProducerConfig&) = default;
TraceConfig::ProducerConfig::ProducerConfig(
    TraceConfig::ProducerConfig&&) noexcept = default;
TraceConfig::ProducerConfig& TraceConfig::ProducerConfig::operator=(
    TraceConfig::ProducerConfig&&) = default;

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
bool TraceConfig::ProducerConfig::operator==(
    const TraceConfig::ProducerConfig& other) const {
  return (producer_name_ == other.producer_name_) &&
         (shm_size_kb_ == other.shm_size_kb_) &&
         (page_size_kb_ == other.page_size_kb_);
}
#pragma GCC diagnostic pop

void TraceConfig::ProducerConfig::ParseRawProto(const std::string& raw) {
  perfetto::protos::TraceConfig_ProducerConfig proto;
  proto.ParseFromString(raw);
  FromProto(proto);
}

void TraceConfig::ProducerConfig::FromProto(
    const perfetto::protos::TraceConfig_ProducerConfig& proto) {
  static_assert(sizeof(producer_name_) == sizeof(proto.producer_name()),
                "size mismatch");
  producer_name_ = static_cast<decltype(producer_name_)>(proto.producer_name());

  static_assert(sizeof(shm_size_kb_) == sizeof(proto.shm_size_kb()),
                "size mismatch");
  shm_size_kb_ = static_cast<decltype(shm_size_kb_)>(proto.shm_size_kb());

  static_assert(sizeof(page_size_kb_) == sizeof(proto.page_size_kb()),
                "size mismatch");
  page_size_kb_ = static_cast<decltype(page_size_kb_)>(proto.page_size_kb());
  unknown_fields_ = proto.unknown_fields();
}

void TraceConfig::ProducerConfig::ToProto(
    perfetto::protos::TraceConfig_ProducerConfig* proto) const {
  proto->Clear();

  static_assert(sizeof(producer_name_) == sizeof(proto->producer_name()),
                "size mismatch");
  proto->set_producer_name(
      static_cast<decltype(proto->producer_name())>(producer_name_));

  static_assert(sizeof(shm_size_kb_) == sizeof(proto->shm_size_kb()),
                "size mismatch");
  proto->set_shm_size_kb(
      static_cast<decltype(proto->shm_size_kb())>(shm_size_kb_));

  static_assert(sizeof(page_size_kb_) == sizeof(proto->page_size_kb()),
                "size mismatch");
  proto->set_page_size_kb(
      static_cast<decltype(proto->page_size_kb())>(page_size_kb_));
  *(proto->mutable_unknown_fields()) = unknown_fields_;
}

TraceConfig::StatsdMetadata::StatsdMetadata() = default;
TraceConfig::StatsdMetadata::~StatsdMetadata() = default;
TraceConfig::StatsdMetadata::StatsdMetadata(
    const TraceConfig::StatsdMetadata&) = default;
TraceConfig::StatsdMetadata& TraceConfig::StatsdMetadata::operator=(
    const TraceConfig::StatsdMetadata&) = default;
TraceConfig::StatsdMetadata::StatsdMetadata(
    TraceConfig::StatsdMetadata&&) noexcept = default;
TraceConfig::StatsdMetadata& TraceConfig::StatsdMetadata::operator=(
    TraceConfig::StatsdMetadata&&) = default;

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
bool TraceConfig::StatsdMetadata::operator==(
    const TraceConfig::StatsdMetadata& other) const {
  return (triggering_alert_id_ == other.triggering_alert_id_) &&
         (triggering_config_uid_ == other.triggering_config_uid_) &&
         (triggering_config_id_ == other.triggering_config_id_) &&
         (triggering_subscription_id_ == other.triggering_subscription_id_);
}
#pragma GCC diagnostic pop

void TraceConfig::StatsdMetadata::ParseRawProto(const std::string& raw) {
  perfetto::protos::TraceConfig_StatsdMetadata proto;
  proto.ParseFromString(raw);
  FromProto(proto);
}

void TraceConfig::StatsdMetadata::FromProto(
    const perfetto::protos::TraceConfig_StatsdMetadata& proto) {
  static_assert(
      sizeof(triggering_alert_id_) == sizeof(proto.triggering_alert_id()),
      "size mismatch");
  triggering_alert_id_ =
      static_cast<decltype(triggering_alert_id_)>(proto.triggering_alert_id());

  static_assert(
      sizeof(triggering_config_uid_) == sizeof(proto.triggering_config_uid()),
      "size mismatch");
  triggering_config_uid_ = static_cast<decltype(triggering_config_uid_)>(
      proto.triggering_config_uid());

  static_assert(
      sizeof(triggering_config_id_) == sizeof(proto.triggering_config_id()),
      "size mismatch");
  triggering_config_id_ = static_cast<decltype(triggering_config_id_)>(
      proto.triggering_config_id());

  static_assert(sizeof(triggering_subscription_id_) ==
                    sizeof(proto.triggering_subscription_id()),
                "size mismatch");
  triggering_subscription_id_ =
      static_cast<decltype(triggering_subscription_id_)>(
          proto.triggering_subscription_id());
  unknown_fields_ = proto.unknown_fields();
}

void TraceConfig::StatsdMetadata::ToProto(
    perfetto::protos::TraceConfig_StatsdMetadata* proto) const {
  proto->Clear();

  static_assert(
      sizeof(triggering_alert_id_) == sizeof(proto->triggering_alert_id()),
      "size mismatch");
  proto->set_triggering_alert_id(
      static_cast<decltype(proto->triggering_alert_id())>(
          triggering_alert_id_));

  static_assert(
      sizeof(triggering_config_uid_) == sizeof(proto->triggering_config_uid()),
      "size mismatch");
  proto->set_triggering_config_uid(
      static_cast<decltype(proto->triggering_config_uid())>(
          triggering_config_uid_));

  static_assert(
      sizeof(triggering_config_id_) == sizeof(proto->triggering_config_id()),
      "size mismatch");
  proto->set_triggering_config_id(
      static_cast<decltype(proto->triggering_config_id())>(
          triggering_config_id_));

  static_assert(sizeof(triggering_subscription_id_) ==
                    sizeof(proto->triggering_subscription_id()),
                "size mismatch");
  proto->set_triggering_subscription_id(
      static_cast<decltype(proto->triggering_subscription_id())>(
          triggering_subscription_id_));
  *(proto->mutable_unknown_fields()) = unknown_fields_;
}

TraceConfig::GuardrailOverrides::GuardrailOverrides() = default;
TraceConfig::GuardrailOverrides::~GuardrailOverrides() = default;
TraceConfig::GuardrailOverrides::GuardrailOverrides(
    const TraceConfig::GuardrailOverrides&) = default;
TraceConfig::GuardrailOverrides& TraceConfig::GuardrailOverrides::operator=(
    const TraceConfig::GuardrailOverrides&) = default;
TraceConfig::GuardrailOverrides::GuardrailOverrides(
    TraceConfig::GuardrailOverrides&&) noexcept = default;
TraceConfig::GuardrailOverrides& TraceConfig::GuardrailOverrides::operator=(
    TraceConfig::GuardrailOverrides&&) = default;

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
bool TraceConfig::GuardrailOverrides::operator==(
    const TraceConfig::GuardrailOverrides& other) const {
  return (max_upload_per_day_bytes_ == other.max_upload_per_day_bytes_);
}
#pragma GCC diagnostic pop

void TraceConfig::GuardrailOverrides::ParseRawProto(const std::string& raw) {
  perfetto::protos::TraceConfig_GuardrailOverrides proto;
  proto.ParseFromString(raw);
  FromProto(proto);
}

void TraceConfig::GuardrailOverrides::FromProto(
    const perfetto::protos::TraceConfig_GuardrailOverrides& proto) {
  static_assert(sizeof(max_upload_per_day_bytes_) ==
                    sizeof(proto.max_upload_per_day_bytes()),
                "size mismatch");
  max_upload_per_day_bytes_ = static_cast<decltype(max_upload_per_day_bytes_)>(
      proto.max_upload_per_day_bytes());
  unknown_fields_ = proto.unknown_fields();
}

void TraceConfig::GuardrailOverrides::ToProto(
    perfetto::protos::TraceConfig_GuardrailOverrides* proto) const {
  proto->Clear();

  static_assert(sizeof(max_upload_per_day_bytes_) ==
                    sizeof(proto->max_upload_per_day_bytes()),
                "size mismatch");
  proto->set_max_upload_per_day_bytes(
      static_cast<decltype(proto->max_upload_per_day_bytes())>(
          max_upload_per_day_bytes_));
  *(proto->mutable_unknown_fields()) = unknown_fields_;
}

TraceConfig::TriggerConfig::TriggerConfig() = default;
TraceConfig::TriggerConfig::~TriggerConfig() = default;
TraceConfig::TriggerConfig::TriggerConfig(const TraceConfig::TriggerConfig&) =
    default;
TraceConfig::TriggerConfig& TraceConfig::TriggerConfig::operator=(
    const TraceConfig::TriggerConfig&) = default;
TraceConfig::TriggerConfig::TriggerConfig(
    TraceConfig::TriggerConfig&&) noexcept = default;
TraceConfig::TriggerConfig& TraceConfig::TriggerConfig::operator=(
    TraceConfig::TriggerConfig&&) = default;

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
bool TraceConfig::TriggerConfig::operator==(
    const TraceConfig::TriggerConfig& other) const {
  return (trigger_mode_ == other.trigger_mode_) &&
         (triggers_ == other.triggers_) &&
         (trigger_timeout_ms_ == other.trigger_timeout_ms_);
}
#pragma GCC diagnostic pop

void TraceConfig::TriggerConfig::ParseRawProto(const std::string& raw) {
  perfetto::protos::TraceConfig_TriggerConfig proto;
  proto.ParseFromString(raw);
  FromProto(proto);
}

void TraceConfig::TriggerConfig::FromProto(
    const perfetto::protos::TraceConfig_TriggerConfig& proto) {
  static_assert(sizeof(trigger_mode_) == sizeof(proto.trigger_mode()),
                "size mismatch");
  trigger_mode_ = static_cast<decltype(trigger_mode_)>(proto.trigger_mode());

  triggers_.clear();
  for (const auto& field : proto.triggers()) {
    triggers_.emplace_back();
    triggers_.back().FromProto(field);
  }

  static_assert(
      sizeof(trigger_timeout_ms_) == sizeof(proto.trigger_timeout_ms()),
      "size mismatch");
  trigger_timeout_ms_ =
      static_cast<decltype(trigger_timeout_ms_)>(proto.trigger_timeout_ms());
  unknown_fields_ = proto.unknown_fields();
}

void TraceConfig::TriggerConfig::ToProto(
    perfetto::protos::TraceConfig_TriggerConfig* proto) const {
  proto->Clear();

  static_assert(sizeof(trigger_mode_) == sizeof(proto->trigger_mode()),
                "size mismatch");
  proto->set_trigger_mode(
      static_cast<decltype(proto->trigger_mode())>(trigger_mode_));

  for (const auto& it : triggers_) {
    auto* entry = proto->add_triggers();
    it.ToProto(entry);
  }

  static_assert(
      sizeof(trigger_timeout_ms_) == sizeof(proto->trigger_timeout_ms()),
      "size mismatch");
  proto->set_trigger_timeout_ms(
      static_cast<decltype(proto->trigger_timeout_ms())>(trigger_timeout_ms_));
  *(proto->mutable_unknown_fields()) = unknown_fields_;
}

TraceConfig::TriggerConfig::Trigger::Trigger() = default;
TraceConfig::TriggerConfig::Trigger::~Trigger() = default;
TraceConfig::TriggerConfig::Trigger::Trigger(
    const TraceConfig::TriggerConfig::Trigger&) = default;
TraceConfig::TriggerConfig::Trigger& TraceConfig::TriggerConfig::Trigger::
operator=(const TraceConfig::TriggerConfig::Trigger&) = default;
TraceConfig::TriggerConfig::Trigger::Trigger(
    TraceConfig::TriggerConfig::Trigger&&) noexcept = default;
TraceConfig::TriggerConfig::Trigger& TraceConfig::TriggerConfig::Trigger::
operator=(TraceConfig::TriggerConfig::Trigger&&) = default;

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
bool TraceConfig::TriggerConfig::Trigger::operator==(
    const TraceConfig::TriggerConfig::Trigger& other) const {
  return (name_ == other.name_) &&
         (producer_name_regex_ == other.producer_name_regex_) &&
         (stop_delay_ms_ == other.stop_delay_ms_);
}
#pragma GCC diagnostic pop

void TraceConfig::TriggerConfig::Trigger::ParseRawProto(
    const std::string& raw) {
  perfetto::protos::TraceConfig_TriggerConfig_Trigger proto;
  proto.ParseFromString(raw);
  FromProto(proto);
}

void TraceConfig::TriggerConfig::Trigger::FromProto(
    const perfetto::protos::TraceConfig_TriggerConfig_Trigger& proto) {
  static_assert(sizeof(name_) == sizeof(proto.name()), "size mismatch");
  name_ = static_cast<decltype(name_)>(proto.name());

  static_assert(
      sizeof(producer_name_regex_) == sizeof(proto.producer_name_regex()),
      "size mismatch");
  producer_name_regex_ =
      static_cast<decltype(producer_name_regex_)>(proto.producer_name_regex());

  static_assert(sizeof(stop_delay_ms_) == sizeof(proto.stop_delay_ms()),
                "size mismatch");
  stop_delay_ms_ = static_cast<decltype(stop_delay_ms_)>(proto.stop_delay_ms());
  unknown_fields_ = proto.unknown_fields();
}

void TraceConfig::TriggerConfig::Trigger::ToProto(
    perfetto::protos::TraceConfig_TriggerConfig_Trigger* proto) const {
  proto->Clear();

  static_assert(sizeof(name_) == sizeof(proto->name()), "size mismatch");
  proto->set_name(static_cast<decltype(proto->name())>(name_));

  static_assert(
      sizeof(producer_name_regex_) == sizeof(proto->producer_name_regex()),
      "size mismatch");
  proto->set_producer_name_regex(
      static_cast<decltype(proto->producer_name_regex())>(
          producer_name_regex_));

  static_assert(sizeof(stop_delay_ms_) == sizeof(proto->stop_delay_ms()),
                "size mismatch");
  proto->set_stop_delay_ms(
      static_cast<decltype(proto->stop_delay_ms())>(stop_delay_ms_));
  *(proto->mutable_unknown_fields()) = unknown_fields_;
}

TraceConfig::IncrementalStateConfig::IncrementalStateConfig() = default;
TraceConfig::IncrementalStateConfig::~IncrementalStateConfig() = default;
TraceConfig::IncrementalStateConfig::IncrementalStateConfig(
    const TraceConfig::IncrementalStateConfig&) = default;
TraceConfig::IncrementalStateConfig& TraceConfig::IncrementalStateConfig::
operator=(const TraceConfig::IncrementalStateConfig&) = default;
TraceConfig::IncrementalStateConfig::IncrementalStateConfig(
    TraceConfig::IncrementalStateConfig&&) noexcept = default;
TraceConfig::IncrementalStateConfig& TraceConfig::IncrementalStateConfig::
operator=(TraceConfig::IncrementalStateConfig&&) = default;

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
bool TraceConfig::IncrementalStateConfig::operator==(
    const TraceConfig::IncrementalStateConfig& other) const {
  return (clear_period_ms_ == other.clear_period_ms_);
}
#pragma GCC diagnostic pop

void TraceConfig::IncrementalStateConfig::ParseRawProto(
    const std::string& raw) {
  perfetto::protos::TraceConfig_IncrementalStateConfig proto;
  proto.ParseFromString(raw);
  FromProto(proto);
}

void TraceConfig::IncrementalStateConfig::FromProto(
    const perfetto::protos::TraceConfig_IncrementalStateConfig& proto) {
  static_assert(sizeof(clear_period_ms_) == sizeof(proto.clear_period_ms()),
                "size mismatch");
  clear_period_ms_ =
      static_cast<decltype(clear_period_ms_)>(proto.clear_period_ms());
  unknown_fields_ = proto.unknown_fields();
}

void TraceConfig::IncrementalStateConfig::ToProto(
    perfetto::protos::TraceConfig_IncrementalStateConfig* proto) const {
  proto->Clear();

  static_assert(sizeof(clear_period_ms_) == sizeof(proto->clear_period_ms()),
                "size mismatch");
  proto->set_clear_period_ms(
      static_cast<decltype(proto->clear_period_ms())>(clear_period_ms_));
  *(proto->mutable_unknown_fields()) = unknown_fields_;
}

TraceConfig::IncidentReportConfig::IncidentReportConfig() = default;
TraceConfig::IncidentReportConfig::~IncidentReportConfig() = default;
TraceConfig::IncidentReportConfig::IncidentReportConfig(
    const TraceConfig::IncidentReportConfig&) = default;
TraceConfig::IncidentReportConfig& TraceConfig::IncidentReportConfig::operator=(
    const TraceConfig::IncidentReportConfig&) = default;
TraceConfig::IncidentReportConfig::IncidentReportConfig(
    TraceConfig::IncidentReportConfig&&) noexcept = default;
TraceConfig::IncidentReportConfig& TraceConfig::IncidentReportConfig::operator=(
    TraceConfig::IncidentReportConfig&&) = default;

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
bool TraceConfig::IncidentReportConfig::operator==(
    const TraceConfig::IncidentReportConfig& other) const {
  return (destination_package_ == other.destination_package_) &&
         (destination_class_ == other.destination_class_) &&
         (privacy_level_ == other.privacy_level_) &&
         (skip_dropbox_ == other.skip_dropbox_);
}
#pragma GCC diagnostic pop

void TraceConfig::IncidentReportConfig::ParseRawProto(const std::string& raw) {
  perfetto::protos::TraceConfig_IncidentReportConfig proto;
  proto.ParseFromString(raw);
  FromProto(proto);
}

void TraceConfig::IncidentReportConfig::FromProto(
    const perfetto::protos::TraceConfig_IncidentReportConfig& proto) {
  static_assert(
      sizeof(destination_package_) == sizeof(proto.destination_package()),
      "size mismatch");
  destination_package_ =
      static_cast<decltype(destination_package_)>(proto.destination_package());

  static_assert(sizeof(destination_class_) == sizeof(proto.destination_class()),
                "size mismatch");
  destination_class_ =
      static_cast<decltype(destination_class_)>(proto.destination_class());

  static_assert(sizeof(privacy_level_) == sizeof(proto.privacy_level()),
                "size mismatch");
  privacy_level_ = static_cast<decltype(privacy_level_)>(proto.privacy_level());

  static_assert(sizeof(skip_dropbox_) == sizeof(proto.skip_dropbox()),
                "size mismatch");
  skip_dropbox_ = static_cast<decltype(skip_dropbox_)>(proto.skip_dropbox());
  unknown_fields_ = proto.unknown_fields();
}

void TraceConfig::IncidentReportConfig::ToProto(
    perfetto::protos::TraceConfig_IncidentReportConfig* proto) const {
  proto->Clear();

  static_assert(
      sizeof(destination_package_) == sizeof(proto->destination_package()),
      "size mismatch");
  proto->set_destination_package(
      static_cast<decltype(proto->destination_package())>(
          destination_package_));

  static_assert(
      sizeof(destination_class_) == sizeof(proto->destination_class()),
      "size mismatch");
  proto->set_destination_class(
      static_cast<decltype(proto->destination_class())>(destination_class_));

  static_assert(sizeof(privacy_level_) == sizeof(proto->privacy_level()),
                "size mismatch");
  proto->set_privacy_level(
      static_cast<decltype(proto->privacy_level())>(privacy_level_));

  static_assert(sizeof(skip_dropbox_) == sizeof(proto->skip_dropbox()),
                "size mismatch");
  proto->set_skip_dropbox(
      static_cast<decltype(proto->skip_dropbox())>(skip_dropbox_));
  *(proto->mutable_unknown_fields()) = unknown_fields_;
}

}  // namespace perfetto
// gen_amalgamated begin source: src/tracing/core/trace_packet.cc
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/trace_packet.h"

// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"
// gen_amalgamated expanded: #include "src/tracing/core/sliced_protobuf_input_stream.h"

namespace perfetto {

TracePacket::TracePacket() = default;
TracePacket::~TracePacket() = default;

TracePacket::TracePacket(TracePacket&& other) noexcept {
  *this = std::move(other);
}

TracePacket& TracePacket::operator=(TracePacket&& other) {
  slices_ = std::move(other.slices_);
  other.slices_.clear();
  size_ = other.size_;
  other.size_ = 0;
  return *this;
}

void TracePacket::AddSlice(Slice slice) {
  size_ += slice.size;
  slices_.push_back(std::move(slice));
}

void TracePacket::AddSlice(const void* start, size_t size) {
  size_ += size;
  slices_.emplace_back(start, size);
}

std::tuple<char*, size_t> TracePacket::GetProtoPreamble() {
  using protozero::proto_utils::MakeTagLengthDelimited;
  using protozero::proto_utils::WriteVarInt;
  uint8_t* ptr = reinterpret_cast<uint8_t*>(&preamble_[0]);

  constexpr uint8_t tag = MakeTagLengthDelimited(kPacketFieldNumber);
  static_assert(tag < 0x80, "TracePacket tag should fit in one byte");
  *(ptr++) = tag;

  ptr = WriteVarInt(size(), ptr);
  size_t preamble_size = reinterpret_cast<uintptr_t>(ptr) -
                         reinterpret_cast<uintptr_t>(&preamble_[0]);
  PERFETTO_DCHECK(preamble_size <= sizeof(preamble_));
  return std::make_tuple(&preamble_[0], preamble_size);
}

std::unique_ptr<TracePacket::ZeroCopyInputStream>
TracePacket::CreateSlicedInputStream() const {
  return std::unique_ptr<ZeroCopyInputStream>(
      new SlicedProtobufInputStream(&slices_));
}

}  // namespace perfetto
// gen_amalgamated begin source: src/tracing/core/trace_stats.cc
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*******************************************************************************
 * AUTOGENERATED - DO NOT EDIT
 *******************************************************************************
 * This file has been generated from the protobuf message
 * perfetto/common/trace_stats.proto
 * by
 * ../../tools/proto_to_cpp/proto_to_cpp.cc.
 * If you need to make changes here, change the .proto file and then run
 * ./tools/gen_tracing_cpp_headers_from_protos
 */

// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/trace_stats.h"

// gen_amalgamated expanded: #include "perfetto/common/trace_stats.pb.h"

namespace perfetto {

TraceStats::TraceStats() = default;
TraceStats::~TraceStats() = default;
TraceStats::TraceStats(const TraceStats&) = default;
TraceStats& TraceStats::operator=(const TraceStats&) = default;
TraceStats::TraceStats(TraceStats&&) noexcept = default;
TraceStats& TraceStats::operator=(TraceStats&&) = default;

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
bool TraceStats::operator==(const TraceStats& other) const {
  return (buffer_stats_ == other.buffer_stats_) &&
         (producers_connected_ == other.producers_connected_) &&
         (producers_seen_ == other.producers_seen_) &&
         (data_sources_registered_ == other.data_sources_registered_) &&
         (data_sources_seen_ == other.data_sources_seen_) &&
         (tracing_sessions_ == other.tracing_sessions_) &&
         (total_buffers_ == other.total_buffers_) &&
         (chunks_discarded_ == other.chunks_discarded_) &&
         (patches_discarded_ == other.patches_discarded_);
}
#pragma GCC diagnostic pop

void TraceStats::ParseRawProto(const std::string& raw) {
  perfetto::protos::TraceStats proto;
  proto.ParseFromString(raw);
  FromProto(proto);
}

void TraceStats::FromProto(const perfetto::protos::TraceStats& proto) {
  buffer_stats_.clear();
  for (const auto& field : proto.buffer_stats()) {
    buffer_stats_.emplace_back();
    buffer_stats_.back().FromProto(field);
  }

  static_assert(
      sizeof(producers_connected_) == sizeof(proto.producers_connected()),
      "size mismatch");
  producers_connected_ =
      static_cast<decltype(producers_connected_)>(proto.producers_connected());

  static_assert(sizeof(producers_seen_) == sizeof(proto.producers_seen()),
                "size mismatch");
  producers_seen_ =
      static_cast<decltype(producers_seen_)>(proto.producers_seen());

  static_assert(sizeof(data_sources_registered_) ==
                    sizeof(proto.data_sources_registered()),
                "size mismatch");
  data_sources_registered_ = static_cast<decltype(data_sources_registered_)>(
      proto.data_sources_registered());

  static_assert(sizeof(data_sources_seen_) == sizeof(proto.data_sources_seen()),
                "size mismatch");
  data_sources_seen_ =
      static_cast<decltype(data_sources_seen_)>(proto.data_sources_seen());

  static_assert(sizeof(tracing_sessions_) == sizeof(proto.tracing_sessions()),
                "size mismatch");
  tracing_sessions_ =
      static_cast<decltype(tracing_sessions_)>(proto.tracing_sessions());

  static_assert(sizeof(total_buffers_) == sizeof(proto.total_buffers()),
                "size mismatch");
  total_buffers_ = static_cast<decltype(total_buffers_)>(proto.total_buffers());

  static_assert(sizeof(chunks_discarded_) == sizeof(proto.chunks_discarded()),
                "size mismatch");
  chunks_discarded_ =
      static_cast<decltype(chunks_discarded_)>(proto.chunks_discarded());

  static_assert(sizeof(patches_discarded_) == sizeof(proto.patches_discarded()),
                "size mismatch");
  patches_discarded_ =
      static_cast<decltype(patches_discarded_)>(proto.patches_discarded());
  unknown_fields_ = proto.unknown_fields();
}

void TraceStats::ToProto(perfetto::protos::TraceStats* proto) const {
  proto->Clear();

  for (const auto& it : buffer_stats_) {
    auto* entry = proto->add_buffer_stats();
    it.ToProto(entry);
  }

  static_assert(
      sizeof(producers_connected_) == sizeof(proto->producers_connected()),
      "size mismatch");
  proto->set_producers_connected(
      static_cast<decltype(proto->producers_connected())>(
          producers_connected_));

  static_assert(sizeof(producers_seen_) == sizeof(proto->producers_seen()),
                "size mismatch");
  proto->set_producers_seen(
      static_cast<decltype(proto->producers_seen())>(producers_seen_));

  static_assert(sizeof(data_sources_registered_) ==
                    sizeof(proto->data_sources_registered()),
                "size mismatch");
  proto->set_data_sources_registered(
      static_cast<decltype(proto->data_sources_registered())>(
          data_sources_registered_));

  static_assert(
      sizeof(data_sources_seen_) == sizeof(proto->data_sources_seen()),
      "size mismatch");
  proto->set_data_sources_seen(
      static_cast<decltype(proto->data_sources_seen())>(data_sources_seen_));

  static_assert(sizeof(tracing_sessions_) == sizeof(proto->tracing_sessions()),
                "size mismatch");
  proto->set_tracing_sessions(
      static_cast<decltype(proto->tracing_sessions())>(tracing_sessions_));

  static_assert(sizeof(total_buffers_) == sizeof(proto->total_buffers()),
                "size mismatch");
  proto->set_total_buffers(
      static_cast<decltype(proto->total_buffers())>(total_buffers_));

  static_assert(sizeof(chunks_discarded_) == sizeof(proto->chunks_discarded()),
                "size mismatch");
  proto->set_chunks_discarded(
      static_cast<decltype(proto->chunks_discarded())>(chunks_discarded_));

  static_assert(
      sizeof(patches_discarded_) == sizeof(proto->patches_discarded()),
      "size mismatch");
  proto->set_patches_discarded(
      static_cast<decltype(proto->patches_discarded())>(patches_discarded_));
  *(proto->mutable_unknown_fields()) = unknown_fields_;
}

TraceStats::BufferStats::BufferStats() = default;
TraceStats::BufferStats::~BufferStats() = default;
TraceStats::BufferStats::BufferStats(const TraceStats::BufferStats&) = default;
TraceStats::BufferStats& TraceStats::BufferStats::operator=(
    const TraceStats::BufferStats&) = default;
TraceStats::BufferStats::BufferStats(TraceStats::BufferStats&&) noexcept =
    default;
TraceStats::BufferStats& TraceStats::BufferStats::operator=(
    TraceStats::BufferStats&&) = default;

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
bool TraceStats::BufferStats::operator==(
    const TraceStats::BufferStats& other) const {
  return (buffer_size_ == other.buffer_size_) &&
         (bytes_written_ == other.bytes_written_) &&
         (bytes_overwritten_ == other.bytes_overwritten_) &&
         (bytes_read_ == other.bytes_read_) &&
         (padding_bytes_written_ == other.padding_bytes_written_) &&
         (padding_bytes_cleared_ == other.padding_bytes_cleared_) &&
         (chunks_written_ == other.chunks_written_) &&
         (chunks_rewritten_ == other.chunks_rewritten_) &&
         (chunks_overwritten_ == other.chunks_overwritten_) &&
         (chunks_discarded_ == other.chunks_discarded_) &&
         (chunks_read_ == other.chunks_read_) &&
         (chunks_committed_out_of_order_ ==
          other.chunks_committed_out_of_order_) &&
         (write_wrap_count_ == other.write_wrap_count_) &&
         (patches_succeeded_ == other.patches_succeeded_) &&
         (patches_failed_ == other.patches_failed_) &&
         (readaheads_succeeded_ == other.readaheads_succeeded_) &&
         (readaheads_failed_ == other.readaheads_failed_) &&
         (abi_violations_ == other.abi_violations_);
}
#pragma GCC diagnostic pop

void TraceStats::BufferStats::ParseRawProto(const std::string& raw) {
  perfetto::protos::TraceStats_BufferStats proto;
  proto.ParseFromString(raw);
  FromProto(proto);
}

void TraceStats::BufferStats::FromProto(
    const perfetto::protos::TraceStats_BufferStats& proto) {
  static_assert(sizeof(buffer_size_) == sizeof(proto.buffer_size()),
                "size mismatch");
  buffer_size_ = static_cast<decltype(buffer_size_)>(proto.buffer_size());

  static_assert(sizeof(bytes_written_) == sizeof(proto.bytes_written()),
                "size mismatch");
  bytes_written_ = static_cast<decltype(bytes_written_)>(proto.bytes_written());

  static_assert(sizeof(bytes_overwritten_) == sizeof(proto.bytes_overwritten()),
                "size mismatch");
  bytes_overwritten_ =
      static_cast<decltype(bytes_overwritten_)>(proto.bytes_overwritten());

  static_assert(sizeof(bytes_read_) == sizeof(proto.bytes_read()),
                "size mismatch");
  bytes_read_ = static_cast<decltype(bytes_read_)>(proto.bytes_read());

  static_assert(
      sizeof(padding_bytes_written_) == sizeof(proto.padding_bytes_written()),
      "size mismatch");
  padding_bytes_written_ = static_cast<decltype(padding_bytes_written_)>(
      proto.padding_bytes_written());

  static_assert(
      sizeof(padding_bytes_cleared_) == sizeof(proto.padding_bytes_cleared()),
      "size mismatch");
  padding_bytes_cleared_ = static_cast<decltype(padding_bytes_cleared_)>(
      proto.padding_bytes_cleared());

  static_assert(sizeof(chunks_written_) == sizeof(proto.chunks_written()),
                "size mismatch");
  chunks_written_ =
      static_cast<decltype(chunks_written_)>(proto.chunks_written());

  static_assert(sizeof(chunks_rewritten_) == sizeof(proto.chunks_rewritten()),
                "size mismatch");
  chunks_rewritten_ =
      static_cast<decltype(chunks_rewritten_)>(proto.chunks_rewritten());

  static_assert(
      sizeof(chunks_overwritten_) == sizeof(proto.chunks_overwritten()),
      "size mismatch");
  chunks_overwritten_ =
      static_cast<decltype(chunks_overwritten_)>(proto.chunks_overwritten());

  static_assert(sizeof(chunks_discarded_) == sizeof(proto.chunks_discarded()),
                "size mismatch");
  chunks_discarded_ =
      static_cast<decltype(chunks_discarded_)>(proto.chunks_discarded());

  static_assert(sizeof(chunks_read_) == sizeof(proto.chunks_read()),
                "size mismatch");
  chunks_read_ = static_cast<decltype(chunks_read_)>(proto.chunks_read());

  static_assert(sizeof(chunks_committed_out_of_order_) ==
                    sizeof(proto.chunks_committed_out_of_order()),
                "size mismatch");
  chunks_committed_out_of_order_ =
      static_cast<decltype(chunks_committed_out_of_order_)>(
          proto.chunks_committed_out_of_order());

  static_assert(sizeof(write_wrap_count_) == sizeof(proto.write_wrap_count()),
                "size mismatch");
  write_wrap_count_ =
      static_cast<decltype(write_wrap_count_)>(proto.write_wrap_count());

  static_assert(sizeof(patches_succeeded_) == sizeof(proto.patches_succeeded()),
                "size mismatch");
  patches_succeeded_ =
      static_cast<decltype(patches_succeeded_)>(proto.patches_succeeded());

  static_assert(sizeof(patches_failed_) == sizeof(proto.patches_failed()),
                "size mismatch");
  patches_failed_ =
      static_cast<decltype(patches_failed_)>(proto.patches_failed());

  static_assert(
      sizeof(readaheads_succeeded_) == sizeof(proto.readaheads_succeeded()),
      "size mismatch");
  readaheads_succeeded_ = static_cast<decltype(readaheads_succeeded_)>(
      proto.readaheads_succeeded());

  static_assert(sizeof(readaheads_failed_) == sizeof(proto.readaheads_failed()),
                "size mismatch");
  readaheads_failed_ =
      static_cast<decltype(readaheads_failed_)>(proto.readaheads_failed());

  static_assert(sizeof(abi_violations_) == sizeof(proto.abi_violations()),
                "size mismatch");
  abi_violations_ =
      static_cast<decltype(abi_violations_)>(proto.abi_violations());
  unknown_fields_ = proto.unknown_fields();
}

void TraceStats::BufferStats::ToProto(
    perfetto::protos::TraceStats_BufferStats* proto) const {
  proto->Clear();

  static_assert(sizeof(buffer_size_) == sizeof(proto->buffer_size()),
                "size mismatch");
  proto->set_buffer_size(
      static_cast<decltype(proto->buffer_size())>(buffer_size_));

  static_assert(sizeof(bytes_written_) == sizeof(proto->bytes_written()),
                "size mismatch");
  proto->set_bytes_written(
      static_cast<decltype(proto->bytes_written())>(bytes_written_));

  static_assert(
      sizeof(bytes_overwritten_) == sizeof(proto->bytes_overwritten()),
      "size mismatch");
  proto->set_bytes_overwritten(
      static_cast<decltype(proto->bytes_overwritten())>(bytes_overwritten_));

  static_assert(sizeof(bytes_read_) == sizeof(proto->bytes_read()),
                "size mismatch");
  proto->set_bytes_read(
      static_cast<decltype(proto->bytes_read())>(bytes_read_));

  static_assert(
      sizeof(padding_bytes_written_) == sizeof(proto->padding_bytes_written()),
      "size mismatch");
  proto->set_padding_bytes_written(
      static_cast<decltype(proto->padding_bytes_written())>(
          padding_bytes_written_));

  static_assert(
      sizeof(padding_bytes_cleared_) == sizeof(proto->padding_bytes_cleared()),
      "size mismatch");
  proto->set_padding_bytes_cleared(
      static_cast<decltype(proto->padding_bytes_cleared())>(
          padding_bytes_cleared_));

  static_assert(sizeof(chunks_written_) == sizeof(proto->chunks_written()),
                "size mismatch");
  proto->set_chunks_written(
      static_cast<decltype(proto->chunks_written())>(chunks_written_));

  static_assert(sizeof(chunks_rewritten_) == sizeof(proto->chunks_rewritten()),
                "size mismatch");
  proto->set_chunks_rewritten(
      static_cast<decltype(proto->chunks_rewritten())>(chunks_rewritten_));

  static_assert(
      sizeof(chunks_overwritten_) == sizeof(proto->chunks_overwritten()),
      "size mismatch");
  proto->set_chunks_overwritten(
      static_cast<decltype(proto->chunks_overwritten())>(chunks_overwritten_));

  static_assert(sizeof(chunks_discarded_) == sizeof(proto->chunks_discarded()),
                "size mismatch");
  proto->set_chunks_discarded(
      static_cast<decltype(proto->chunks_discarded())>(chunks_discarded_));

  static_assert(sizeof(chunks_read_) == sizeof(proto->chunks_read()),
                "size mismatch");
  proto->set_chunks_read(
      static_cast<decltype(proto->chunks_read())>(chunks_read_));

  static_assert(sizeof(chunks_committed_out_of_order_) ==
                    sizeof(proto->chunks_committed_out_of_order()),
                "size mismatch");
  proto->set_chunks_committed_out_of_order(
      static_cast<decltype(proto->chunks_committed_out_of_order())>(
          chunks_committed_out_of_order_));

  static_assert(sizeof(write_wrap_count_) == sizeof(proto->write_wrap_count()),
                "size mismatch");
  proto->set_write_wrap_count(
      static_cast<decltype(proto->write_wrap_count())>(write_wrap_count_));

  static_assert(
      sizeof(patches_succeeded_) == sizeof(proto->patches_succeeded()),
      "size mismatch");
  proto->set_patches_succeeded(
      static_cast<decltype(proto->patches_succeeded())>(patches_succeeded_));

  static_assert(sizeof(patches_failed_) == sizeof(proto->patches_failed()),
                "size mismatch");
  proto->set_patches_failed(
      static_cast<decltype(proto->patches_failed())>(patches_failed_));

  static_assert(
      sizeof(readaheads_succeeded_) == sizeof(proto->readaheads_succeeded()),
      "size mismatch");
  proto->set_readaheads_succeeded(
      static_cast<decltype(proto->readaheads_succeeded())>(
          readaheads_succeeded_));

  static_assert(
      sizeof(readaheads_failed_) == sizeof(proto->readaheads_failed()),
      "size mismatch");
  proto->set_readaheads_failed(
      static_cast<decltype(proto->readaheads_failed())>(readaheads_failed_));

  static_assert(sizeof(abi_violations_) == sizeof(proto->abi_violations()),
                "size mismatch");
  proto->set_abi_violations(
      static_cast<decltype(proto->abi_violations())>(abi_violations_));
  *(proto->mutable_unknown_fields()) = unknown_fields_;
}

}  // namespace perfetto
// gen_amalgamated begin source: src/tracing/core/trace_writer_impl.cc
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "src/tracing/core/trace_writer_impl.h"

#include <string.h>

#include <algorithm>
#include <type_traits>
#include <utility>

// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/protozero/proto_utils.h"
// gen_amalgamated expanded: #include "src/tracing/core/shared_memory_arbiter_impl.h"

// gen_amalgamated expanded: #include "perfetto/trace/trace_packet.pbzero.h"

using protozero::proto_utils::kMessageLengthFieldSize;
using protozero::proto_utils::WriteRedundantVarInt;
using ChunkHeader = perfetto::SharedMemoryABI::ChunkHeader;

namespace perfetto {

namespace {
constexpr size_t kPacketHeaderSize = SharedMemoryABI::kPacketHeaderSize;
}  // namespace

TraceWriterImpl::TraceWriterImpl(SharedMemoryArbiterImpl* shmem_arbiter,
                                 WriterID id,
                                 BufferID target_buffer)
    : shmem_arbiter_(shmem_arbiter),
      id_(id),
      target_buffer_(target_buffer),
      protobuf_stream_writer_(this) {
  // TODO(primiano): we could handle the case of running out of TraceWriterID(s)
  // more gracefully and always return a no-op TracePacket in NewTracePacket().
  PERFETTO_CHECK(id_ != 0);

  cur_packet_.reset(new protos::pbzero::TracePacket());
  cur_packet_->Finalize();  // To avoid the DCHECK in NewTracePacket().
}

TraceWriterImpl::~TraceWriterImpl() {
  if (cur_chunk_.is_valid()) {
    cur_packet_->Finalize();
    Flush();
  }
  shmem_arbiter_->ReleaseWriterID(id_);
}

void TraceWriterImpl::Flush(std::function<void()> callback) {
  // Flush() cannot be called in the middle of a TracePacket.
  PERFETTO_CHECK(cur_packet_->is_finalized());

  if (cur_chunk_.is_valid()) {
    shmem_arbiter_->ReturnCompletedChunk(std::move(cur_chunk_), target_buffer_,
                                         &patch_list_);
  } else {
    PERFETTO_DCHECK(patch_list_.empty());
  }
  // Always issue the Flush request, even if there is nothing to flush, just
  // for the sake of getting the callback posted back.
  shmem_arbiter_->FlushPendingCommitDataRequests(callback);
  protobuf_stream_writer_.Reset({nullptr, nullptr});
}

TraceWriterImpl::TracePacketHandle TraceWriterImpl::NewTracePacket() {
  // If we hit this, the caller is calling NewTracePacket() without having
  // finalized the previous packet.
  PERFETTO_DCHECK(cur_packet_->is_finalized());

  fragmenting_packet_ = false;

  // Reserve space for the size of the message. Note: this call might re-enter
  // into this class invoking GetNewBuffer() if there isn't enough space or if
  // this is the very first call to NewTracePacket().
  static_assert(kPacketHeaderSize == kMessageLengthFieldSize,
                "The packet header must match the Message header size");

  // It doesn't make sense to begin a packet that is going to fragment
  // immediately after (8 is just an arbitrary estimation on the minimum size of
  // a realistic packet).
  bool chunk_too_full =
      protobuf_stream_writer_.bytes_available() < kPacketHeaderSize + 8;
  if (chunk_too_full || reached_max_packets_per_chunk_) {
    protobuf_stream_writer_.Reset(GetNewBuffer());
  }

  // Send any completed patches to the service to facilitate trace data
  // recovery by the service. This should only happen when we're completing
  // the first packet in a chunk which was a continuation from the previous
  // chunk, i.e. at most once per chunk.
  if (!patch_list_.empty() && patch_list_.front().is_patched()) {
    shmem_arbiter_->SendPatches(id_, target_buffer_, &patch_list_);
  }

  cur_packet_->Reset(&protobuf_stream_writer_);
  uint8_t* header = protobuf_stream_writer_.ReserveBytes(kPacketHeaderSize);
  memset(header, 0, kPacketHeaderSize);
  cur_packet_->set_size_field(header);
  uint16_t new_packet_count = cur_chunk_.IncrementPacketCount();
  reached_max_packets_per_chunk_ =
      new_packet_count == ChunkHeader::Packets::kMaxCount;
  TracePacketHandle handle(cur_packet_.get());
  cur_fragment_start_ = protobuf_stream_writer_.write_ptr();
  fragmenting_packet_ = true;
  return handle;
}

// Called by the Message. We can get here in two cases:
// 1. In the middle of writing a Message,
// when |fragmenting_packet_| == true. In this case we want to update the
// chunk header with a partial packet and start a new partial packet in the
// new chunk.
// 2. While calling ReserveBytes() for the packet header in NewTracePacket().
// In this case |fragmenting_packet_| == false and we just want a new chunk
// without creating any fragments.
protozero::ContiguousMemoryRange TraceWriterImpl::GetNewBuffer() {
  if (fragmenting_packet_) {
    uint8_t* const wptr = protobuf_stream_writer_.write_ptr();
    PERFETTO_DCHECK(wptr >= cur_fragment_start_);
    uint32_t partial_size = static_cast<uint32_t>(wptr - cur_fragment_start_);
    PERFETTO_DCHECK(partial_size < cur_chunk_.size());

    // Backfill the packet header with the fragment size.
    PERFETTO_DCHECK(partial_size > 0);
    cur_packet_->inc_size_already_written(partial_size);
    cur_chunk_.SetFlag(ChunkHeader::kLastPacketContinuesOnNextChunk);
    WriteRedundantVarInt(partial_size, cur_packet_->size_field());

    // Descend in the stack of non-finalized nested submessages (if any) and
    // detour their |size_field| into the |patch_list_|. At this point we have
    // to release the chunk and they cannot write anymore into that.
    // TODO(primiano): add tests to cover this logic.
    bool chunk_needs_patching = false;
    for (auto* nested_msg = cur_packet_->nested_message(); nested_msg;
         nested_msg = nested_msg->nested_message()) {
      uint8_t* const cur_hdr = nested_msg->size_field();

      // If this is false the protozero Message has already been instructed to
      // write, upon Finalize(), its size into the patch list.
      bool size_field_points_within_chunk =
          cur_hdr >= cur_chunk_.payload_begin() &&
          cur_hdr + kMessageLengthFieldSize <= cur_chunk_.end();

      if (size_field_points_within_chunk) {
        auto offset =
            static_cast<uint16_t>(cur_hdr - cur_chunk_.payload_begin());
        const ChunkID cur_chunk_id =
            cur_chunk_.header()->chunk_id.load(std::memory_order_relaxed);
        Patch* patch = patch_list_.emplace_back(cur_chunk_id, offset);
        nested_msg->set_size_field(&patch->size_field[0]);
        chunk_needs_patching = true;
      } else {
#if PERFETTO_DCHECK_IS_ON()
        // Ensure that the size field of the message points to an element of the
        // patch list.
        auto patch_it = std::find_if(
            patch_list_.begin(), patch_list_.end(),
            [cur_hdr](const Patch& p) { return &p.size_field[0] == cur_hdr; });
        PERFETTO_DCHECK(patch_it != patch_list_.end());
#endif
      }
    }  // for(nested_msg

    if (chunk_needs_patching)
      cur_chunk_.SetFlag(ChunkHeader::kChunkNeedsPatching);
  }  // if(fragmenting_packet)

  if (cur_chunk_.is_valid()) {
    // ReturnCompletedChunk will consume the first patched entries from
    // |patch_list_| and shrink it.
    shmem_arbiter_->ReturnCompletedChunk(std::move(cur_chunk_), target_buffer_,
                                         &patch_list_);
  }

  // Start a new chunk.

  ChunkHeader::Packets packets = {};
  if (fragmenting_packet_) {
    packets.count = 1;
    packets.flags = ChunkHeader::kFirstPacketContinuesFromPrevChunk;
  }

  // The memory order of the stores below doesn't really matter. This |header|
  // is just a local temporary object. The GetNewChunk() call below will copy it
  // into the shared buffer with the proper barriers.
  ChunkHeader header = {};
  header.writer_id.store(id_, std::memory_order_relaxed);
  header.chunk_id.store(next_chunk_id_++, std::memory_order_relaxed);
  header.packets.store(packets, std::memory_order_relaxed);

  cur_chunk_ = shmem_arbiter_->GetNewChunk(header);
  reached_max_packets_per_chunk_ = false;
  uint8_t* payload_begin = cur_chunk_.payload_begin();
  if (fragmenting_packet_) {
    cur_packet_->set_size_field(payload_begin);
    memset(payload_begin, 0, kPacketHeaderSize);
    payload_begin += kPacketHeaderSize;
    cur_fragment_start_ = payload_begin;
  }

  return protozero::ContiguousMemoryRange{payload_begin, cur_chunk_.end()};
}

WriterID TraceWriterImpl::writer_id() const {
  return id_;
}

bool TraceWriterImpl::SetFirstChunkId(ChunkID chunk_id) {
  if (next_chunk_id_ > 0)
    return false;
  next_chunk_id_ = chunk_id;
  return true;
}

// Base class definitions.
TraceWriter::TraceWriter() = default;
TraceWriter::~TraceWriter() = default;

bool TraceWriter::SetFirstChunkId(ChunkID) {
  return false;
}

}  // namespace perfetto
// gen_amalgamated begin source: src/tracing/core/tracing_service_impl.cc
// gen_amalgamated begin header: src/tracing/core/tracing_service_impl.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef SRC_TRACING_CORE_TRACING_SERVICE_IMPL_H_
#define SRC_TRACING_CORE_TRACING_SERVICE_IMPL_H_

#include <functional>
#include <map>
#include <memory>
#include <mutex>
#include <set>
#include <vector>

// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/optional.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/time.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/weak_ptr.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/basic_types.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/commit_data_request.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/observable_events.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/shared_memory_abi.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/trace_stats.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/tracing_service.h"
// gen_amalgamated expanded: #include "perfetto/tracing/core/data_source_config.h"
// gen_amalgamated expanded: #include "perfetto/tracing/core/data_source_descriptor.h"
// gen_amalgamated expanded: #include "perfetto/tracing/core/trace_config.h"
// gen_amalgamated expanded: #include "src/tracing/core/id_allocator.h"

namespace perfetto {

namespace base {
class TaskRunner;
}  // namespace base

class Consumer;
class DataSourceConfig;
class Producer;
class SharedMemory;
class SharedMemoryArbiterImpl;
class TraceBuffer;
class TraceConfig;
class TracePacket;

// The tracing service business logic.
class TracingServiceImpl : public TracingService {
 private:
  struct DataSourceInstance;

 public:
  static constexpr size_t kDefaultShmSize = 256 * 1024ul;
  static constexpr size_t kMaxShmSize = 32 * 1024 * 1024ul;
  static constexpr uint32_t kDataSourceStopTimeoutMs = 5000;
  static constexpr uint8_t kSyncMarker[] = {0x82, 0x47, 0x7a, 0x76, 0xb2, 0x8d,
                                            0x42, 0xba, 0x81, 0xdc, 0x33, 0x32,
                                            0x6d, 0x57, 0xa0, 0x79};

  // The implementation behind the service endpoint exposed to each producer.
  class ProducerEndpointImpl : public TracingService::ProducerEndpoint {
   public:
    ProducerEndpointImpl(ProducerID,
                         uid_t uid,
                         TracingServiceImpl*,
                         base::TaskRunner*,
                         Producer*,
                         const std::string& producer_name,
                         bool in_process,
                         bool smb_scraping_enabled);
    ~ProducerEndpointImpl() override;

    // TracingService::ProducerEndpoint implementation.
    void RegisterDataSource(const DataSourceDescriptor&) override;
    void UnregisterDataSource(const std::string& name) override;
    void RegisterTraceWriter(uint32_t writer_id,
                             uint32_t target_buffer) override;
    void UnregisterTraceWriter(uint32_t writer_id) override;
    void CommitData(const CommitDataRequest&, CommitDataCallback) override;
    void SetSharedMemory(std::unique_ptr<SharedMemory>);
    std::unique_ptr<TraceWriter> CreateTraceWriter(BufferID) override;
    SharedMemoryArbiter* GetInProcessShmemArbiter() override;
    void NotifyFlushComplete(FlushRequestID) override;
    void NotifyDataSourceStarted(DataSourceInstanceID) override;
    void NotifyDataSourceStopped(DataSourceInstanceID) override;
    SharedMemory* shared_memory() const override;
    size_t shared_buffer_page_size_kb() const override;
    void ActivateTriggers(const std::vector<std::string>&) override;

    void OnTracingSetup();
    void SetupDataSource(DataSourceInstanceID, const DataSourceConfig&);
    void StartDataSource(DataSourceInstanceID, const DataSourceConfig&);
    void StopDataSource(DataSourceInstanceID);
    void Flush(FlushRequestID, const std::vector<DataSourceInstanceID>&);
    void OnFreeBuffers(const std::vector<BufferID>& target_buffers);
    void ClearIncrementalState(const std::vector<DataSourceInstanceID>&);

    bool is_allowed_target_buffer(BufferID buffer_id) const {
      return allowed_target_buffers_.count(buffer_id);
    }

    base::Optional<BufferID> buffer_id_for_writer(WriterID writer_id) const {
      const auto it = writers_.find(writer_id);
      if (it != writers_.end())
        return it->second;
      return base::nullopt;
    }

    uid_t uid() const { return uid_; }

   private:
    friend class TracingServiceImpl;
    friend class TracingServiceImplTest;
    friend class TracingIntegrationTest;
    ProducerEndpointImpl(const ProducerEndpointImpl&) = delete;
    ProducerEndpointImpl& operator=(const ProducerEndpointImpl&) = delete;

    ProducerID const id_;
    const uid_t uid_;
    TracingServiceImpl* const service_;
    base::TaskRunner* const task_runner_;
    Producer* producer_;
    std::unique_ptr<SharedMemory> shared_memory_;
    size_t shared_buffer_page_size_kb_ = 0;
    SharedMemoryABI shmem_abi_;
    size_t shmem_size_hint_bytes_ = 0;
    const std::string name_;
    bool in_process_;
    bool smb_scraping_enabled_;

    // Set of the global target_buffer IDs that the producer is configured to
    // write into in any active tracing session.
    std::set<BufferID> allowed_target_buffers_;

    // Maps registered TraceWriter IDs to their target buffers as registered by
    // the producer. Note that producers aren't required to register their
    // writers, so we may see commits of chunks with WriterIDs that aren't
    // contained in this map. However, if a producer does register a writer, the
    // service will prevent the writer from writing into any other buffer than
    // the one associated with it here. The BufferIDs stored in this map are
    // untrusted, so need to be verified against |allowed_target_buffers_|
    // before use.
    std::map<WriterID, BufferID> writers_;

    // This is used only in in-process configurations.
    // SharedMemoryArbiterImpl methods themselves are thread-safe.
    std::unique_ptr<SharedMemoryArbiterImpl> inproc_shmem_arbiter_;

    PERFETTO_THREAD_CHECKER(thread_checker_)
    base::WeakPtrFactory<ProducerEndpointImpl> weak_ptr_factory_;  // Keep last.
  };

  // The implementation behind the service endpoint exposed to each consumer.
  class ConsumerEndpointImpl : public TracingService::ConsumerEndpoint {
   public:
    ConsumerEndpointImpl(TracingServiceImpl*,
                         base::TaskRunner*,
                         Consumer*,
                         uid_t uid);
    ~ConsumerEndpointImpl() override;

    void NotifyOnTracingDisabled();
    base::WeakPtr<ConsumerEndpointImpl> GetWeakPtr();

    // TracingService::ConsumerEndpoint implementation.
    void EnableTracing(const TraceConfig&, base::ScopedFile) override;
    void ChangeTraceConfig(const TraceConfig& cfg) override;
    void StartTracing() override;
    void DisableTracing() override;
    void ReadBuffers() override;
    void FreeBuffers() override;
    void Flush(uint32_t timeout_ms, FlushCallback) override;
    void Detach(const std::string& key) override;
    void Attach(const std::string& key) override;
    void GetTraceStats() override;
    void ObserveEvents(uint32_t enabled_event_types) override;
    void QueryServiceState(QueryServiceStateCallback) override;

    // If |observe_data_source_instances == true|, will queue a task to notify
    // the consumer about the state change.
    void OnDataSourceInstanceStateChange(const ProducerEndpointImpl&,
                                         const DataSourceInstance&);

   private:
    friend class TracingServiceImpl;
    ConsumerEndpointImpl(const ConsumerEndpointImpl&) = delete;
    ConsumerEndpointImpl& operator=(const ConsumerEndpointImpl&) = delete;

    // Returns a pointer to an ObservableEvents object that the caller can fill
    // and schedules a task to send the ObservableEvents to the consumer.
    ObservableEvents* AddObservableEvents();

    base::TaskRunner* const task_runner_;
    TracingServiceImpl* const service_;
    Consumer* const consumer_;
    uid_t const uid_;
    TracingSessionID tracing_session_id_ = 0;

    // Whether the consumer is interested in DataSourceInstance state change
    // events.
    uint32_t enabled_observable_event_types_ = ObservableEventType::kNone;
    // ObservableEvents that will be sent to the consumer. If set, a task to
    // flush the events to the consumer has been queued.
    std::unique_ptr<ObservableEvents> observable_events_;

    PERFETTO_THREAD_CHECKER(thread_checker_)
    base::WeakPtrFactory<ConsumerEndpointImpl> weak_ptr_factory_;  // Keep last.
  };

  explicit TracingServiceImpl(std::unique_ptr<SharedMemory::Factory>,
                              base::TaskRunner*);
  ~TracingServiceImpl() override;

  // Called by ProducerEndpointImpl.
  void DisconnectProducer(ProducerID);
  void RegisterDataSource(ProducerID, const DataSourceDescriptor&);
  void UnregisterDataSource(ProducerID, const std::string& name);
  void CopyProducerPageIntoLogBuffer(ProducerID,
                                     uid_t,
                                     WriterID,
                                     ChunkID,
                                     BufferID,
                                     uint16_t num_fragments,
                                     uint8_t chunk_flags,
                                     bool chunk_complete,
                                     const uint8_t* src,
                                     size_t size);
  void ApplyChunkPatches(ProducerID,
                         const std::vector<CommitDataRequest::ChunkToPatch>&);
  void NotifyFlushDoneForProducer(ProducerID, FlushRequestID);
  void NotifyDataSourceStarted(ProducerID, const DataSourceInstanceID);
  void NotifyDataSourceStopped(ProducerID, const DataSourceInstanceID);
  void ActivateTriggers(ProducerID, const std::vector<std::string>& triggers);

  // Called by ConsumerEndpointImpl.
  bool DetachConsumer(ConsumerEndpointImpl*, const std::string& key);
  bool AttachConsumer(ConsumerEndpointImpl*, const std::string& key);
  void DisconnectConsumer(ConsumerEndpointImpl*);
  bool EnableTracing(ConsumerEndpointImpl*,
                     const TraceConfig&,
                     base::ScopedFile);
  void ChangeTraceConfig(ConsumerEndpointImpl*, const TraceConfig&);

  bool StartTracing(TracingSessionID);
  void DisableTracing(TracingSessionID, bool disable_immediately = false);
  void Flush(TracingSessionID tsid,
             uint32_t timeout_ms,
             ConsumerEndpoint::FlushCallback);
  void FlushAndDisableTracing(TracingSessionID);
  void ReadBuffers(TracingSessionID, ConsumerEndpointImpl*);
  void FreeBuffers(TracingSessionID);

  // Service implementation.
  std::unique_ptr<TracingService::ProducerEndpoint> ConnectProducer(
      Producer*,
      uid_t uid,
      const std::string& producer_name,
      size_t shared_memory_size_hint_bytes = 0,
      bool in_process = false,
      ProducerSMBScrapingMode smb_scraping_mode =
          ProducerSMBScrapingMode::kDefault) override;

  std::unique_ptr<TracingService::ConsumerEndpoint> ConnectConsumer(
      Consumer*,
      uid_t) override;

  // Set whether SMB scraping should be enabled by default or not. Producers can
  // override this setting for their own SMBs.
  void SetSMBScrapingEnabled(bool enabled) override {
    smb_scraping_enabled_ = enabled;
  }

  // Exposed mainly for testing.
  size_t num_producers() const { return producers_.size(); }
  ProducerEndpointImpl* GetProducer(ProducerID) const;

 private:
  friend class TracingServiceImplTest;
  friend class TracingIntegrationTest;

  struct RegisteredDataSource {
    ProducerID producer_id;
    DataSourceDescriptor descriptor;
  };

  // Represents an active data source for a tracing session.
  struct DataSourceInstance {
    DataSourceInstance(DataSourceInstanceID id,
                       const DataSourceConfig& cfg,
                       const std::string& ds_name,
                       bool notify_on_start,
                       bool notify_on_stop,
                       bool handles_incremental_state_invalidation)
        : instance_id(id),
          config(cfg),
          data_source_name(ds_name),
          will_notify_on_start(notify_on_start),
          will_notify_on_stop(notify_on_stop),
          handles_incremental_state_clear(
              handles_incremental_state_invalidation) {}
    DataSourceInstance(const DataSourceInstance&) = delete;
    DataSourceInstance& operator=(const DataSourceInstance&) = delete;

    DataSourceInstanceID instance_id;
    DataSourceConfig config;
    std::string data_source_name;
    bool will_notify_on_start;
    bool will_notify_on_stop;
    bool handles_incremental_state_clear;

    enum DataSourceInstanceState {
      CONFIGURED,
      STARTING,
      STARTED,
      STOPPING,
      STOPPED
    };
    DataSourceInstanceState state = CONFIGURED;
  };

  struct PendingFlush {
    std::set<ProducerID> producers;
    ConsumerEndpoint::FlushCallback callback;
    explicit PendingFlush(decltype(callback) cb) : callback(std::move(cb)) {}
  };

  // Holds the state of a tracing session. A tracing session is uniquely bound
  // a specific Consumer. Each Consumer can own one or more sessions.
  struct TracingSession {
    enum State {
      DISABLED = 0,
      CONFIGURED,
      STARTED,
      DISABLING_WAITING_STOP_ACKS
    };

    TracingSession(TracingSessionID, ConsumerEndpointImpl*, const TraceConfig&);

    size_t num_buffers() const { return buffers_index.size(); }

    uint32_t delay_to_next_write_period_ms() const {
      PERFETTO_DCHECK(write_period_ms > 0);
      return write_period_ms -
             (base::GetWallTimeMs().count() % write_period_ms);
    }

    uint32_t flush_timeout_ms() {
      uint32_t timeout_ms = config.flush_timeout_ms();
      return timeout_ms ? timeout_ms : kDefaultFlushTimeoutMs;
    }

    uint32_t data_source_stop_timeout_ms() {
      uint32_t timeout_ms = config.data_source_stop_timeout_ms();
      return timeout_ms ? timeout_ms : kDataSourceStopTimeoutMs;
    }

    PacketSequenceID GetPacketSequenceID(ProducerID producer_id,
                                         WriterID writer_id) {
      auto key = std::make_pair(producer_id, writer_id);
      auto it = packet_sequence_ids.find(key);
      if (it != packet_sequence_ids.end())
        return it->second;
      // We shouldn't run out of sequence IDs (producer ID is 16 bit, writer IDs
      // are limited to 1024).
      static_assert(kMaxPacketSequenceID > kMaxProducerID * kMaxWriterID,
                    "PacketSequenceID value space doesn't cover service "
                    "sequence ID and all producer/writer ID combinations!");
      PERFETTO_DCHECK(last_packet_sequence_id < kMaxPacketSequenceID);
      PacketSequenceID sequence_id = ++last_packet_sequence_id;
      packet_sequence_ids[key] = sequence_id;
      return sequence_id;
    }

    DataSourceInstance* GetDataSourceInstance(
        ProducerID producer_id,
        DataSourceInstanceID instance_id) {
      for (auto& inst_kv : data_source_instances) {
        if (inst_kv.first != producer_id ||
            inst_kv.second.instance_id != instance_id) {
          continue;
        }
        return &inst_kv.second;
      }
      return nullptr;
    }

    bool AllDataSourceInstancesStopped() {
      for (const auto& inst_kv : data_source_instances) {
        if (inst_kv.second.state != DataSourceInstance::STOPPED)
          return false;
      }
      return true;
    }

    const TracingSessionID id;

    // The consumer that started the session.
    // Can be nullptr if the consumer detached from the session.
    ConsumerEndpointImpl* consumer_maybe_null;

    // Unix uid of the consumer. This is valid even after the consumer detaches
    // and does not change for the entire duration of the session. It is used to
    // prevent that a consumer re-attaches to a session from a different uid.
    uid_t const consumer_uid;

    // The list of triggers this session received while alive and the time they
    // were received at. This is used to insert 'fake' packets back to the
    // consumer so they can tell when some event happened. The order matches the
    // order they were received.
    struct TriggerInfo {
      uint64_t boot_time_ns;
      std::string trigger_name;
      std::string producer_name;
      uid_t producer_uid;
    };
    std::vector<TriggerInfo> received_triggers;

    // The trace config provided by the Consumer when calling
    // EnableTracing(), plus any updates performed by ChangeTraceConfig.
    TraceConfig config;

    // List of data source instances that have been enabled on the various
    // producers for this tracing session.
    // TODO(rsavitski): at the time of writing, the map structure is unused
    // (even when the calling code has a key). This is also an opportunity to
    // consider an alternative data type, e.g. a map of vectors.
    std::multimap<ProducerID, DataSourceInstance> data_source_instances;

    // For each Flush(N) request, keeps track of the set of producers for which
    // we are still awaiting a NotifyFlushComplete(N) ack.
    std::map<FlushRequestID, PendingFlush> pending_flushes;

    // Maps a per-trace-session buffer index into the corresponding global
    // BufferID (shared namespace amongst all consumers). This vector has as
    // many entries as |config.buffers_size()|.
    std::vector<BufferID> buffers_index;

    std::map<std::pair<ProducerID, WriterID>, PacketSequenceID>
        packet_sequence_ids;
    PacketSequenceID last_packet_sequence_id = kServicePacketSequenceID;

    // When the last snapshots (clock, stats, sync marker) were emitted into
    // the output stream.
    base::TimeMillis last_snapshot_time = {};

    // Whether we should emit the trace stats next time we reach EOF while
    // performing ReadBuffers.
    bool should_emit_stats = false;

    // Whether we mirrored the trace config back to the trace output yet.
    bool did_emit_config = false;

    // Whether we put the system info into the trace output yet.
    bool did_emit_system_info = false;

    // The number of received triggers we've emitted into the trace output.
    size_t num_triggers_emitted_into_trace = 0;

    // Initial clock snapshot, captured at trace start time (when state goes
    // to TracingSession::STARTED). Emitted into the trace when the consumer
    // first begins reading the trace.
    std::vector<TracePacket> initial_clock_snapshot_;

    State state = DISABLED;

    // If the consumer detached the session, this variable defines the key used
    // for identifying the session later when reattaching.
    std::string detach_key;

    // This is set when the Consumer calls sets |write_into_file| == true in the
    // TraceConfig. In this case this represents the file we should stream the
    // trace packets into, rather than returning it to the consumer via
    // OnTraceData().
    base::ScopedFile write_into_file;
    uint32_t write_period_ms = 0;
    uint64_t max_file_size_bytes = 0;
    uint64_t bytes_written_into_file = 0;
  };

  TracingServiceImpl(const TracingServiceImpl&) = delete;
  TracingServiceImpl& operator=(const TracingServiceImpl&) = delete;

  DataSourceInstance* SetupDataSource(const TraceConfig::DataSource&,
                                      const TraceConfig::ProducerConfig&,
                                      const RegisteredDataSource&,
                                      TracingSession*);

  // Returns the next available ProducerID that is not in |producers_|.
  ProducerID GetNextProducerID();

  // Returns a pointer to the |tracing_sessions_| entry or nullptr if the
  // session doesn't exists.
  TracingSession* GetTracingSession(TracingSessionID);

  // Returns a pointer to the |tracing_sessions_| entry, matching the given
  // uid and detach key, or nullptr if no such session exists.
  TracingSession* GetDetachedSession(uid_t, const std::string& key);

  // Update the memory guard rail by using the latest information from the
  // shared memory and trace buffers.
  void UpdateMemoryGuardrail();

  void StartDataSourceInstance(ProducerEndpointImpl* producer,
                               TracingSession* tracing_session,
                               DataSourceInstance* instance);
  void SnapshotSyncMarker(std::vector<TracePacket>*);
  void SnapshotClocks(std::vector<TracePacket>*, bool set_root_timestamp);
  void SnapshotStats(TracingSession*, std::vector<TracePacket>*);
  TraceStats GetTraceStats(TracingSession* tracing_session);
  void MaybeEmitTraceConfig(TracingSession*, std::vector<TracePacket>*);
  void MaybeEmitSystemInfo(TracingSession*, std::vector<TracePacket>*);
  void MaybeEmitReceivedTriggers(TracingSession*, std::vector<TracePacket>*);
  void OnFlushTimeout(TracingSessionID, FlushRequestID);
  void OnDisableTracingTimeout(TracingSessionID);
  void DisableTracingNotifyConsumerAndFlushFile(TracingSession*);
  void PeriodicFlushTask(TracingSessionID, bool post_next_only);
  void CompleteFlush(TracingSessionID tsid,
                     ConsumerEndpoint::FlushCallback callback,
                     bool success);
  void ScrapeSharedMemoryBuffers(TracingSession* tracing_session,
                                 ProducerEndpointImpl* producer);
  void PeriodicClearIncrementalStateTask(TracingSessionID, bool post_next_only);
  TraceBuffer* GetBufferByID(BufferID);
  void OnStartTriggersTimeout(TracingSessionID tsid);

  base::TaskRunner* const task_runner_;
  std::unique_ptr<SharedMemory::Factory> shm_factory_;
  ProducerID last_producer_id_ = 0;
  DataSourceInstanceID last_data_source_instance_id_ = 0;
  TracingSessionID last_tracing_session_id_ = 0;
  FlushRequestID last_flush_request_id_ = 0;
  uid_t uid_ = 0;

  // Buffer IDs are global across all consumers (because a Producer can produce
  // data for more than one trace session, hence more than one consumer).
  IdAllocator<BufferID> buffer_ids_;

  std::multimap<std::string /*name*/, RegisteredDataSource> data_sources_;
  std::map<ProducerID, ProducerEndpointImpl*> producers_;
  std::set<ConsumerEndpointImpl*> consumers_;
  std::map<TracingSessionID, TracingSession> tracing_sessions_;
  std::map<BufferID, std::unique_ptr<TraceBuffer>> buffers_;

  bool smb_scraping_enabled_ = false;
  bool lockdown_mode_ = false;
  uint32_t min_write_period_ms_ = 100;  // Overridable for testing.

  uint8_t sync_marker_packet_[32];  // Lazily initialized.
  size_t sync_marker_packet_size_ = 0;

  // Stats.
  uint64_t chunks_discarded_ = 0;
  uint64_t patches_discarded_ = 0;

  PERFETTO_THREAD_CHECKER(thread_checker_)

  base::WeakPtrFactory<TracingServiceImpl>
      weak_ptr_factory_;  // Keep at the end.
};

}  // namespace perfetto

#endif  // SRC_TRACING_CORE_TRACING_SERVICE_IMPL_H_
// gen_amalgamated begin header: include/perfetto/ext/tracing/core/consumer.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_TRACING_CORE_CONSUMER_H_
#define INCLUDE_PERFETTO_EXT_TRACING_CORE_CONSUMER_H_

#include <vector>

// gen_amalgamated expanded: #include "perfetto/base/export.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/basic_types.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/observable_events.h"

namespace perfetto {

class TraceConfig;
class TracePacket;
class TraceStats;
class TracingServiceState;

class PERFETTO_EXPORT Consumer {
 public:
  virtual ~Consumer();

  // Called by Service (or more typically by the transport layer, on behalf of
  // the remote Service), once the Consumer <> Service connection has been
  // established.
  virtual void OnConnect() = 0;

  // Called by the Service or by the transport layer if the connection with the
  // service drops, either voluntarily (e.g., by destroying the ConsumerEndpoint
  // obtained through Service::ConnectConsumer()) or involuntarily (e.g., if the
  // Service process crashes).
  virtual void OnDisconnect() = 0;

  // Called by the Service after the tracing session has ended. This can happen
  // for a variety of reasons:
  // - The consumer explicitly called DisableTracing()
  // - The TraceConfig's |duration_ms| has been reached.
  // - The TraceConfig's |max_file_size_bytes| has been reached.
  // - An error occurred while trying to enable tracing.
  virtual void OnTracingDisabled() = 0;

  // Called back by the Service (or transport layer) after invoking
  // TracingService::ConsumerEndpoint::ReadBuffers(). This function can be
  // called more than once. Each invocation can carry one or more
  // TracePacket(s). Upon the last call, |has_more| is set to true (i.e.
  // |has_more| is a !EOF).
  virtual void OnTraceData(std::vector<TracePacket>, bool has_more) = 0;

  // Called back by the Service (or transport layer) after invoking
  // TracingService::ConsumerEndpoint::Detach().
  // The consumer can disconnect at this point and the trace session will keep
  // on going. A new consumer can later re-attach passing back the same |key|
  // passed to Detach(), but only if the two requests come from the same uid.
  virtual void OnDetach(bool success) = 0;

  // Called back by the Service (or transport layer) after invoking
  // TracingService::ConsumerEndpoint::Attach().
  virtual void OnAttach(bool success, const TraceConfig&) = 0;

  // Called back by the Service (or transport layer) after invoking
  // TracingService::ConsumerEndpoint::GetTraceStats().
  virtual void OnTraceStats(bool success, const TraceStats&) = 0;

  // Called back by the Service (or transport layer) after invoking
  // TracingService::ConsumerEndpoint::ObserveEvents() whenever one or more
  // ObservableEvents of enabled event types occur.
  virtual void OnObservableEvents(const ObservableEvents&) = 0;
};

}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_TRACING_CORE_CONSUMER_H_
// gen_amalgamated begin header: include/perfetto/ext/tracing/core/producer.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_TRACING_CORE_PRODUCER_H_
#define INCLUDE_PERFETTO_EXT_TRACING_CORE_PRODUCER_H_

// gen_amalgamated expanded: #include "perfetto/base/export.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/basic_types.h"

namespace perfetto {

class DataSourceConfig;
class SharedMemory;

// A Producer is an entity that connects to the write-only port of the Service
// and exposes the ability to produce performance data on-demand. The lifecycle
// of a Producer is as follows:
// 1. The producer connects to the service and advertises its data sources
//    (e.g., the ability to get kernel ftraces, to list process stats).
// 2. The service acknowledges the connection and sends over the SharedMemory
//    region that will be used to exchange data (together with the signalling
//    API TracingService::ProducerEndpoint::OnPageAcquired()/OnPageReleased()).
// 3. At some point later on, the Service asks the Producer to turn on some of
//    the previously registered data sources, together with some configuration
//    parameters. This happens via the StartDataSource() callback.
// 4. In response to that the Producer will spawn an instance of the given data
//    source and inject its data into the shared memory buffer (obtained during
//    OnConnect).
// This interface is subclassed by:
//  1. The actual producer code in the clients e.g., the ftrace reader process.
//  2. The transport layer when interposing RPC between service and producers.
class PERFETTO_EXPORT Producer {
 public:
  virtual ~Producer();

  // Called by Service (or more typically by the transport layer, on behalf of
  // the remote Service), once the Producer <> Service connection has been
  // established.
  virtual void OnConnect() = 0;

  // Called by the Service or by the transport layer if the connection with the
  // service drops, either voluntarily (e.g., by destroying the ProducerEndpoint
  // obtained through Service::ConnectProducer()) or involuntarily (e.g., if the
  // Service process crashes).
  // The Producer is expected to tear down all its data sources if this happens.
  // Once this call returns it is possible to safely destroy the Producer
  // instance.
  virtual void OnDisconnect() = 0;

  // Called by the Service after OnConnect but before the first DataSource is
  // created. Can be used for any setup required before tracing begins.
  virtual void OnTracingSetup() = 0;

  // The lifecycle methods below are always called in the following sequence:
  // SetupDataSource  -> StartDataSource -> StopDataSource.
  // Or, in the edge case where a trace is aborted immediately:
  // SetupDataSource  -> StopDataSource.
  // The Setup+Start call sequence is always guaranateed, regardless of the
  // TraceConfig.deferred_start flags.
  // Called by the Service to configure one of the data sources previously
  // registered through TracingService::ProducerEndpoint::RegisterDataSource().
  // This method is always called before StartDataSource. There is always a
  // SetupDataSource() call before each StartDataSource() call.
  // Args:
  // - DataSourceInstanceID is an identifier chosen by the Service that should
  //   be assigned to the newly created data source instance. It is used to
  //   match the StopDataSource() request below.
  // - DataSourceConfig is the configuration for the new data source (e.g.,
  //   tells which trace categories to enable).
  virtual void SetupDataSource(DataSourceInstanceID,
                               const DataSourceConfig&) = 0;

  // Called by the Service to turn on one of the data sources previously
  // registered through TracingService::ProducerEndpoint::RegisterDataSource()
  // and initialized through SetupDataSource().
  // Both arguments are guaranteed to be identical to the ones passed to the
  // prior SetupDataSource() call.
  virtual void StartDataSource(DataSourceInstanceID,
                               const DataSourceConfig&) = 0;

  // Called by the Service to shut down an existing data source instance.
  virtual void StopDataSource(DataSourceInstanceID) = 0;

  // Called by the service to request the Producer to commit the data of the
  // given data sources and return their chunks into the shared memory buffer.
  // The Producer is expected to invoke NotifyFlushComplete(FlushRequestID) on
  // the Service after the data has been committed. The producer has to either
  // reply to the flush requests in order, or can just reply to the latest one
  // Upon seeing a NotifyFlushComplete(N), the service will assume that all
  // flushes < N have also been committed.
  virtual void Flush(FlushRequestID,
                     const DataSourceInstanceID* data_source_ids,
                     size_t num_data_sources) = 0;

  // Called by the service to instruct the given data sources to stop referring
  // to any trace contents emitted so far. The intent is that after processing
  // this call, the rest of the trace should be parsable even if all of the
  // packets emitted so far have been lost (for example due to ring buffer
  // overwrites).
  //
  // Called only for Producers with active data sources that have opted in by
  // setting |handles_incremental_state_clear| in their DataSourceDescriptor.
  //
  // The way this call is handled is up to the individual Producer
  // implementation. Some might wish to emit invalidation markers in the trace
  // (see TracePacket.incremental_state_cleared for an existing field), and
  // handle them when parsing the trace.
  virtual void ClearIncrementalState(
      const DataSourceInstanceID* data_source_ids,
      size_t num_data_sources) = 0;
};

}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_TRACING_CORE_PRODUCER_H_
// gen_amalgamated begin header: include/perfetto/tracing/core/tracing_service_state.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*******************************************************************************
 * AUTOGENERATED - DO NOT EDIT
 *******************************************************************************
 * This file has been generated from the protobuf message
 * perfetto/common/tracing_service_state.proto
 * by
 * ../../tools/proto_to_cpp/proto_to_cpp.cc.
 * If you need to make changes here, change the .proto file and then run
 * ./tools/gen_tracing_cpp_headers_from_protos
 */

#ifndef INCLUDE_PERFETTO_TRACING_CORE_TRACING_SERVICE_STATE_H_
#define INCLUDE_PERFETTO_TRACING_CORE_TRACING_SERVICE_STATE_H_

#include <stdint.h>
#include <string>
#include <type_traits>
#include <vector>

// gen_amalgamated expanded: #include "perfetto/base/copyable_ptr.h"
// gen_amalgamated expanded: #include "perfetto/base/export.h"

// Forward declarations for protobuf types.
namespace perfetto {
namespace protos {
class TracingServiceState;
class TracingServiceState_Producer;
class TracingServiceState_DataSource;
class DataSourceDescriptor;
}  // namespace protos
}  // namespace perfetto

namespace perfetto {
class TracingServiceState;
class DataSourceDescriptor;

class PERFETTO_EXPORT TracingServiceState {
 public:
  class PERFETTO_EXPORT Producer {
   public:
    Producer();
    ~Producer();
    Producer(Producer&&) noexcept;
    Producer& operator=(Producer&&);
    Producer(const Producer&);
    Producer& operator=(const Producer&);
    bool operator==(const Producer&) const;
    bool operator!=(const Producer& other) const { return !(*this == other); }

    // Raw proto decoding.
    void ParseRawProto(const std::string&);
    // Conversion methods from/to the corresponding protobuf types.
    void FromProto(const perfetto::protos::TracingServiceState_Producer&);
    void ToProto(perfetto::protos::TracingServiceState_Producer*) const;

    int32_t id() const { return id_; }
    void set_id(int32_t value) { id_ = value; }

    const std::string& name() const { return name_; }
    void set_name(const std::string& value) { name_ = value; }

    int32_t uid() const { return uid_; }
    void set_uid(int32_t value) { uid_ = value; }

   private:
    int32_t id_{};
    std::string name_{};
    int32_t uid_{};

    // Allows to preserve unknown protobuf fields for compatibility
    // with future versions of .proto files.
    std::string unknown_fields_;
  };

  class PERFETTO_EXPORT DataSource {
   public:
    DataSource();
    ~DataSource();
    DataSource(DataSource&&) noexcept;
    DataSource& operator=(DataSource&&);
    DataSource(const DataSource&);
    DataSource& operator=(const DataSource&);
    bool operator==(const DataSource&) const;
    bool operator!=(const DataSource& other) const { return !(*this == other); }

    // Raw proto decoding.
    void ParseRawProto(const std::string&);
    // Conversion methods from/to the corresponding protobuf types.
    void FromProto(const perfetto::protos::TracingServiceState_DataSource&);
    void ToProto(perfetto::protos::TracingServiceState_DataSource*) const;

    const DataSourceDescriptor& ds_descriptor() const {
      return *ds_descriptor_;
    }
    DataSourceDescriptor* mutable_ds_descriptor() {
      return ds_descriptor_.get();
    }

    int32_t producer_id() const { return producer_id_; }
    void set_producer_id(int32_t value) { producer_id_ = value; }

   private:
    ::perfetto::base::CopyablePtr<DataSourceDescriptor> ds_descriptor_;
    int32_t producer_id_{};

    // Allows to preserve unknown protobuf fields for compatibility
    // with future versions of .proto files.
    std::string unknown_fields_;
  };

  TracingServiceState();
  ~TracingServiceState();
  TracingServiceState(TracingServiceState&&) noexcept;
  TracingServiceState& operator=(TracingServiceState&&);
  TracingServiceState(const TracingServiceState&);
  TracingServiceState& operator=(const TracingServiceState&);
  bool operator==(const TracingServiceState&) const;
  bool operator!=(const TracingServiceState& other) const {
    return !(*this == other);
  }

  // Raw proto decoding.
  void ParseRawProto(const std::string&);
  // Conversion methods from/to the corresponding protobuf types.
  void FromProto(const perfetto::protos::TracingServiceState&);
  void ToProto(perfetto::protos::TracingServiceState*) const;

  int producers_size() const { return static_cast<int>(producers_.size()); }
  const std::vector<Producer>& producers() const { return producers_; }
  std::vector<Producer>* mutable_producers() { return &producers_; }
  void clear_producers() { producers_.clear(); }
  Producer* add_producers() {
    producers_.emplace_back();
    return &producers_.back();
  }

  int data_sources_size() const {
    return static_cast<int>(data_sources_.size());
  }
  const std::vector<DataSource>& data_sources() const { return data_sources_; }
  std::vector<DataSource>* mutable_data_sources() { return &data_sources_; }
  void clear_data_sources() { data_sources_.clear(); }
  DataSource* add_data_sources() {
    data_sources_.emplace_back();
    return &data_sources_.back();
  }

  int32_t num_sessions() const { return num_sessions_; }
  void set_num_sessions(int32_t value) { num_sessions_ = value; }

  int32_t num_sessions_started() const { return num_sessions_started_; }
  void set_num_sessions_started(int32_t value) {
    num_sessions_started_ = value;
  }

 private:
  std::vector<Producer> producers_;
  std::vector<DataSource> data_sources_;
  int32_t num_sessions_{};
  int32_t num_sessions_started_{};

  // Allows to preserve unknown protobuf fields for compatibility
  // with future versions of .proto files.
  std::string unknown_fields_;
};

}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_TRACING_CORE_TRACING_SERVICE_STATE_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "src/tracing/core/tracing_service_impl.h"

// gen_amalgamated expanded: #include "perfetto/base/build_config.h"

#include <errno.h>
#include <inttypes.h>
#include <limits.h>
#include <string.h>
#include <regex>
#include <unordered_set>

#if !PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)
#include <sys/uio.h>
#include <sys/utsname.h>
#include <unistd.h>
#endif

#if PERFETTO_BUILDFLAG(PERFETTO_OS_ANDROID)
#include <sys/system_properties.h>
#endif

#include <algorithm>

// gen_amalgamated expanded: #include "perfetto/base/build_config.h"
// gen_amalgamated expanded: #include "perfetto/base/task_runner.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/file_utils.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/utils.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/watchdog.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/consumer.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/producer.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/shared_memory.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/shared_memory_abi.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/trace_packet.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/trace_writer.h"
// gen_amalgamated expanded: #include "perfetto/tracing/core/data_source_descriptor.h"
// gen_amalgamated expanded: #include "perfetto/tracing/core/tracing_service_state.h"
// gen_amalgamated expanded: #include "src/tracing/core/packet_stream_validator.h"
// gen_amalgamated expanded: #include "src/tracing/core/shared_memory_arbiter_impl.h"
// gen_amalgamated expanded: #include "src/tracing/core/trace_buffer.h"

// gen_amalgamated expanded: #include "perfetto/trace/clock_snapshot.pb.h"
// gen_amalgamated expanded: #include "perfetto/trace/system_info.pb.h"
// gen_amalgamated expanded: #include "perfetto/trace/trusted_packet.pb.h"

// General note: this class must assume that Producers are malicious and will
// try to crash / exploit this class. We can trust pointers because they come
// from the IPC layer, but we should never assume that that the producer calls
// come in the right order or their arguments are sane / within bounds.

namespace perfetto {

namespace {
constexpr size_t kDefaultShmPageSize = base::kPageSize;
constexpr int kMaxBuffersPerConsumer = 128;
constexpr base::TimeMillis kSnapshotsInterval(10 * 1000);
constexpr int kDefaultWriteIntoFilePeriodMs = 5000;
constexpr int kMaxConcurrentTracingSessions = 5;

constexpr uint32_t kMillisPerHour = 3600000;
constexpr uint32_t kMaxTracingDurationMillis = 7 * 24 * kMillisPerHour;

// These apply only if enable_extra_guardrails is true.
constexpr uint32_t kGuardrailsMaxTracingBufferSizeKb = 32 * 1024;
constexpr uint32_t kGuardrailsMaxTracingDurationMillis = 24 * kMillisPerHour;

#if PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)
struct iovec {
  void* iov_base;  // Address
  size_t iov_len;  // Block size
};

// Simple implementation of writev. Note that this does not give the atomicity
// guarantees of a real writev, but we don't depend on these (we aren't writing
// to the same file from another thread).
ssize_t writev(int fd, const struct iovec* iov, int iovcnt) {
  ssize_t total_size = 0;
  for (int i = 0; i < iovcnt; ++i) {
    ssize_t current_size = base::WriteAll(fd, iov[i].iov_base, iov[i].iov_len);
    if (current_size != static_cast<ssize_t>(iov[i].iov_len))
      return -1;
    total_size += current_size;
  }
  return total_size;
}

#define IOV_MAX 1024  // Linux compatible limit.

// uid checking is a NOP on Windows.
uid_t getuid() {
  return 0;
}
uid_t geteuid() {
  return 0;
}
#endif  // PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)

}  // namespace

// These constants instead are defined in the header because are used by tests.
constexpr size_t TracingServiceImpl::kDefaultShmSize;
constexpr size_t TracingServiceImpl::kMaxShmSize;
constexpr uint32_t TracingServiceImpl::kDataSourceStopTimeoutMs;
constexpr uint8_t TracingServiceImpl::kSyncMarker[];

// static
std::unique_ptr<TracingService> TracingService::CreateInstance(
    std::unique_ptr<SharedMemory::Factory> shm_factory,
    base::TaskRunner* task_runner) {
  return std::unique_ptr<TracingService>(
      new TracingServiceImpl(std::move(shm_factory), task_runner));
}

TracingServiceImpl::TracingServiceImpl(
    std::unique_ptr<SharedMemory::Factory> shm_factory,
    base::TaskRunner* task_runner)
    : task_runner_(task_runner),
      shm_factory_(std::move(shm_factory)),
      uid_(getuid()),
      buffer_ids_(kMaxTraceBufferID),
      weak_ptr_factory_(this) {
  PERFETTO_DCHECK(task_runner_);
}

TracingServiceImpl::~TracingServiceImpl() {
  // TODO(fmayer): handle teardown of all Producer.
}

std::unique_ptr<TracingService::ProducerEndpoint>
TracingServiceImpl::ConnectProducer(Producer* producer,
                                    uid_t uid,
                                    const std::string& producer_name,
                                    size_t shared_memory_size_hint_bytes,
                                    bool in_process,
                                    ProducerSMBScrapingMode smb_scraping_mode) {
  PERFETTO_DCHECK_THREAD(thread_checker_);

  if (lockdown_mode_ && uid != geteuid()) {
    PERFETTO_DLOG("Lockdown mode. Rejecting producer with UID %ld",
                  static_cast<unsigned long>(uid));
    return nullptr;
  }

  if (producers_.size() >= kMaxProducerID) {
    PERFETTO_DFATAL("Too many producers.");
    return nullptr;
  }
  const ProducerID id = GetNextProducerID();
  PERFETTO_DLOG("Producer %" PRIu16 " connected", id);

  bool smb_scraping_enabled = smb_scraping_enabled_;
  switch (smb_scraping_mode) {
    case ProducerSMBScrapingMode::kDefault:
      break;
    case ProducerSMBScrapingMode::kEnabled:
      smb_scraping_enabled = true;
      break;
    case ProducerSMBScrapingMode::kDisabled:
      smb_scraping_enabled = false;
      break;
  }

  std::unique_ptr<ProducerEndpointImpl> endpoint(new ProducerEndpointImpl(
      id, uid, this, task_runner_, producer, producer_name, in_process,
      smb_scraping_enabled));
  auto it_and_inserted = producers_.emplace(id, endpoint.get());
  PERFETTO_DCHECK(it_and_inserted.second);
  endpoint->shmem_size_hint_bytes_ = shared_memory_size_hint_bytes;
  task_runner_->PostTask(std::bind(&Producer::OnConnect, endpoint->producer_));

  return std::move(endpoint);
}

void TracingServiceImpl::DisconnectProducer(ProducerID id) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  PERFETTO_DLOG("Producer %" PRIu16 " disconnected", id);
  PERFETTO_DCHECK(producers_.count(id));

  // Scrape remaining chunks for this producer to ensure we don't lose data.
  if (auto* producer = GetProducer(id)) {
    for (auto& session_id_and_session : tracing_sessions_)
      ScrapeSharedMemoryBuffers(&session_id_and_session.second, producer);
  }

  for (auto it = data_sources_.begin(); it != data_sources_.end();) {
    auto next = it;
    next++;
    if (it->second.producer_id == id)
      UnregisterDataSource(id, it->second.descriptor.name());
    it = next;
  }

  producers_.erase(id);
  UpdateMemoryGuardrail();
}

TracingServiceImpl::ProducerEndpointImpl* TracingServiceImpl::GetProducer(
    ProducerID id) const {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  auto it = producers_.find(id);
  if (it == producers_.end())
    return nullptr;
  return it->second;
}

std::unique_ptr<TracingService::ConsumerEndpoint>
TracingServiceImpl::ConnectConsumer(Consumer* consumer, uid_t uid) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  PERFETTO_DLOG("Consumer %p connected", reinterpret_cast<void*>(consumer));
  std::unique_ptr<ConsumerEndpointImpl> endpoint(
      new ConsumerEndpointImpl(this, task_runner_, consumer, uid));
  auto it_and_inserted = consumers_.emplace(endpoint.get());
  PERFETTO_DCHECK(it_and_inserted.second);
  task_runner_->PostTask(std::bind(&Consumer::OnConnect, endpoint->consumer_));
  return std::move(endpoint);
}

void TracingServiceImpl::DisconnectConsumer(ConsumerEndpointImpl* consumer) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  PERFETTO_DLOG("Consumer %p disconnected", reinterpret_cast<void*>(consumer));
  PERFETTO_DCHECK(consumers_.count(consumer));

  // TODO(primiano) : Check that this is safe (what happens if there are
  // ReadBuffers() calls posted in the meantime? They need to become noop).
  if (consumer->tracing_session_id_)
    FreeBuffers(consumer->tracing_session_id_);  // Will also DisableTracing().
  consumers_.erase(consumer);

  // At this point no more pointers to |consumer| should be around.
  PERFETTO_DCHECK(!std::any_of(
      tracing_sessions_.begin(), tracing_sessions_.end(),
      [consumer](const std::pair<const TracingSessionID, TracingSession>& kv) {
        return kv.second.consumer_maybe_null == consumer;
      }));
}

bool TracingServiceImpl::DetachConsumer(ConsumerEndpointImpl* consumer,
                                        const std::string& key) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  PERFETTO_DLOG("Consumer %p detached", reinterpret_cast<void*>(consumer));
  PERFETTO_DCHECK(consumers_.count(consumer));

  TracingSessionID tsid = consumer->tracing_session_id_;
  TracingSession* tracing_session;
  if (!tsid || !(tracing_session = GetTracingSession(tsid)))
    return false;

  if (GetDetachedSession(consumer->uid_, key)) {
    PERFETTO_ELOG("Another session has been detached with the same key \"%s\"",
                  key.c_str());
    return false;
  }

  PERFETTO_DCHECK(tracing_session->consumer_maybe_null == consumer);
  tracing_session->consumer_maybe_null = nullptr;
  tracing_session->detach_key = key;
  consumer->tracing_session_id_ = 0;
  return true;
}

bool TracingServiceImpl::AttachConsumer(ConsumerEndpointImpl* consumer,
                                        const std::string& key) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  PERFETTO_DLOG("Consumer %p attaching to session %s",
                reinterpret_cast<void*>(consumer), key.c_str());
  PERFETTO_DCHECK(consumers_.count(consumer));

  if (consumer->tracing_session_id_) {
    PERFETTO_ELOG(
        "Cannot reattach consumer to session %s"
        " while it already attached tracing session ID %" PRIu64,
        key.c_str(), consumer->tracing_session_id_);
    return false;
  }

  auto* tracing_session = GetDetachedSession(consumer->uid_, key);
  if (!tracing_session) {
    PERFETTO_ELOG(
        "Failed to attach consumer, session '%s' not found for uid %d",
        key.c_str(), static_cast<int>(consumer->uid_));
    return false;
  }

  consumer->tracing_session_id_ = tracing_session->id;
  tracing_session->consumer_maybe_null = consumer;
  tracing_session->detach_key.clear();
  return true;
}

bool TracingServiceImpl::EnableTracing(ConsumerEndpointImpl* consumer,
                                       const TraceConfig& cfg,
                                       base::ScopedFile fd) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  PERFETTO_DLOG("Enabling tracing for consumer %p",
                reinterpret_cast<void*>(consumer));
  if (cfg.lockdown_mode() == TraceConfig::LockdownModeOperation::LOCKDOWN_SET)
    lockdown_mode_ = true;
  if (cfg.lockdown_mode() == TraceConfig::LockdownModeOperation::LOCKDOWN_CLEAR)
    lockdown_mode_ = false;
  TracingSession* tracing_session =
      GetTracingSession(consumer->tracing_session_id_);
  if (tracing_session) {
    PERFETTO_DLOG(
        "A Consumer is trying to EnableTracing() but another tracing session "
        "is already active (forgot a call to FreeBuffers() ?)");
    return false;
  }

  const uint32_t max_duration_ms = cfg.enable_extra_guardrails()
                                       ? kGuardrailsMaxTracingDurationMillis
                                       : kMaxTracingDurationMillis;
  if (cfg.duration_ms() > max_duration_ms) {
    PERFETTO_ELOG("Requested too long trace (%" PRIu32 "ms  > %" PRIu32 " ms)",
                  cfg.duration_ms(), max_duration_ms);
    return false;
  }

  const bool has_trigger_config = cfg.trigger_config().trigger_mode() !=
                                  TraceConfig::TriggerConfig::UNSPECIFIED;
  if (has_trigger_config && (cfg.trigger_config().trigger_timeout_ms() == 0 ||
                             cfg.trigger_config().trigger_timeout_ms() >
                                 kGuardrailsMaxTracingDurationMillis)) {
    PERFETTO_ELOG(
        "Traces with START_TRACING triggers must provide a positive "
        "trigger_timeout_ms < 7 days (received %" PRIu32 "ms)",
        cfg.trigger_config().trigger_timeout_ms());
    return false;
  }

  if (has_trigger_config && cfg.duration_ms() != 0) {
    PERFETTO_ELOG(
        "duration_ms was set, this must not be set for traces with triggers.");
    return false;
  }

  std::unordered_set<std::string> triggers;
  for (const auto& trigger : cfg.trigger_config().triggers()) {
    if (!triggers.insert(trigger.name()).second) {
      PERFETTO_ELOG("Duplicate trigger name: %s", trigger.name().c_str());
      return false;
    }
  }

  if (cfg.enable_extra_guardrails()) {
    if (cfg.deferred_start()) {
      PERFETTO_ELOG(
          "deferred_start=true is not supported in unsupervised traces");
      return false;
    }
    uint64_t buf_size_sum = 0;
    for (const auto& buf : cfg.buffers())
      buf_size_sum += buf.size_kb();
    if (buf_size_sum > kGuardrailsMaxTracingBufferSizeKb) {
      PERFETTO_ELOG("Requested too large trace buffer (%" PRIu64
                    "kB  > %" PRIu32 " kB)",
                    buf_size_sum, kGuardrailsMaxTracingBufferSizeKb);
      return false;
    }
  }

  if (cfg.buffers_size() > kMaxBuffersPerConsumer) {
    PERFETTO_DLOG("Too many buffers configured (%d)", cfg.buffers_size());
    return false;
  }

  if (!cfg.unique_session_name().empty()) {
    const std::string& name = cfg.unique_session_name();
    for (auto& kv : tracing_sessions_) {
      if (kv.second.config.unique_session_name() == name) {
        PERFETTO_ELOG(
            "A trace wtih this unique session name (%s) already exists",
            name.c_str());
        return false;
      }
    }
  }

  // TODO(primiano): This is a workaround to prevent that a producer gets stuck
  // in a state where it stalls by design by having more TraceWriterImpl
  // instances than free pages in the buffer. This is really a bug in
  // trace_probes and the way it handles stalls in the shmem buffer.
  if (tracing_sessions_.size() >= kMaxConcurrentTracingSessions) {
    PERFETTO_ELOG("Too many concurrent tracing sesions (%zu)",
                  tracing_sessions_.size());
    return false;
  }

  const TracingSessionID tsid = ++last_tracing_session_id_;
  tracing_session =
      &tracing_sessions_.emplace(tsid, TracingSession(tsid, consumer, cfg))
           .first->second;

  if (cfg.write_into_file()) {
    if (!fd) {
      PERFETTO_ELOG(
          "The TraceConfig had write_into_file==true but no fd was passed");
      tracing_sessions_.erase(tsid);
      return false;
    }
    tracing_session->write_into_file = std::move(fd);
    uint32_t write_period_ms = cfg.file_write_period_ms();
    if (write_period_ms == 0)
      write_period_ms = kDefaultWriteIntoFilePeriodMs;
    if (write_period_ms < min_write_period_ms_)
      write_period_ms = min_write_period_ms_;
    tracing_session->write_period_ms = write_period_ms;
    tracing_session->max_file_size_bytes = cfg.max_file_size_bytes();
    tracing_session->bytes_written_into_file = 0;
  }

  // Initialize the log buffers.
  bool did_allocate_all_buffers = true;

  // Allocate the trace buffers. Also create a map to translate a consumer
  // relative index (TraceConfig.DataSourceConfig.target_buffer) into the
  // corresponding BufferID, which is a global ID namespace for the service and
  // all producers.
  size_t total_buf_size_kb = 0;
  const size_t num_buffers = static_cast<size_t>(cfg.buffers_size());
  tracing_session->buffers_index.reserve(num_buffers);
  for (size_t i = 0; i < num_buffers; i++) {
    const TraceConfig::BufferConfig& buffer_cfg = cfg.buffers()[i];
    BufferID global_id = buffer_ids_.Allocate();
    if (!global_id) {
      did_allocate_all_buffers = false;  // We ran out of IDs.
      break;
    }
    tracing_session->buffers_index.push_back(global_id);
    const size_t buf_size_bytes = buffer_cfg.size_kb() * 1024u;
    total_buf_size_kb += buffer_cfg.size_kb();
    TraceBuffer::OverwritePolicy policy =
        buffer_cfg.fill_policy() == TraceConfig::BufferConfig::DISCARD
            ? TraceBuffer::kDiscard
            : TraceBuffer::kOverwrite;
    auto it_and_inserted = buffers_.emplace(
        global_id, TraceBuffer::Create(buf_size_bytes, policy));
    PERFETTO_DCHECK(it_and_inserted.second);  // buffers_.count(global_id) == 0.
    std::unique_ptr<TraceBuffer>& trace_buffer = it_and_inserted.first->second;
    if (!trace_buffer) {
      did_allocate_all_buffers = false;
      break;
    }
  }

  UpdateMemoryGuardrail();

  // This can happen if either:
  // - All the kMaxTraceBufferID slots are taken.
  // - OOM, or, more relistically, we exhausted virtual memory.
  // In any case, free all the previously allocated buffers and abort.
  // TODO(fmayer): add a test to cover this case, this is quite subtle.
  if (!did_allocate_all_buffers) {
    for (BufferID global_id : tracing_session->buffers_index) {
      buffer_ids_.Free(global_id);
      buffers_.erase(global_id);
    }
    tracing_sessions_.erase(tsid);
    return false;
  }

  consumer->tracing_session_id_ = tsid;

  // Setup the data sources on the producers without starting them.
  for (const TraceConfig::DataSource& cfg_data_source : cfg.data_sources()) {
    // Scan all the registered data sources with a matching name.
    auto range = data_sources_.equal_range(cfg_data_source.config().name());
    for (auto it = range.first; it != range.second; it++) {
      TraceConfig::ProducerConfig producer_config;
      for (auto& config : cfg.producers()) {
        if (GetProducer(it->second.producer_id)->name_ ==
            config.producer_name()) {
          producer_config = config;
          break;
        }
      }
      SetupDataSource(cfg_data_source, producer_config, it->second,
                      tracing_session);
    }
  }

  bool has_start_trigger = false;
  auto weak_this = weak_ptr_factory_.GetWeakPtr();
  switch (cfg.trigger_config().trigger_mode()) {
    case TraceConfig::TriggerConfig::UNSPECIFIED:
      // no triggers are specified so this isn't a trace that is using triggers.
      PERFETTO_DCHECK(!has_trigger_config);
      break;
    case TraceConfig::TriggerConfig::START_TRACING:
      // For traces which use START_TRACE triggers we need to ensure that the
      // tracing session will be cleaned up when it times out.
      has_start_trigger = true;
      task_runner_->PostDelayedTask(
          [weak_this, tsid]() {
            if (weak_this)
              weak_this->OnStartTriggersTimeout(tsid);
          },
          cfg.trigger_config().trigger_timeout_ms());
      break;
    case TraceConfig::TriggerConfig::STOP_TRACING:
      // Update the tracing_session's duration_ms to ensure that if no trigger
      // is received the session will end and be cleaned up equal to the
      // timeout.
      //
      // TODO(nuskos): Refactor this so that rather then modifying the config we
      // have a field we look at on the tracing_session.
      tracing_session->config.set_duration_ms(
          cfg.trigger_config().trigger_timeout_ms());
      break;
  }

  tracing_session->state = TracingSession::CONFIGURED;
  PERFETTO_LOG(
      "Configured tracing, #sources:%zu, duration:%d ms, #buffers:%d, total "
      "buffer size:%zu KB, total sessions:%zu",
      cfg.data_sources().size(), tracing_session->config.duration_ms(),
      cfg.buffers_size(), total_buf_size_kb, tracing_sessions_.size());

  // Start the data sources, unless this is a case of early setup + fast
  // triggering, either through TraceConfig.deferred_start or
  // TraceConfig.trigger_config(). If both are specified which ever one occurs
  // first will initiate the trace.
  if (!cfg.deferred_start() && !has_start_trigger)
    return StartTracing(tsid);

  return true;
}

void TracingServiceImpl::ChangeTraceConfig(ConsumerEndpointImpl* consumer,
                                           const TraceConfig& updated_cfg) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  TracingSession* tracing_session =
      GetTracingSession(consumer->tracing_session_id_);
  PERFETTO_DCHECK(tracing_session);

  if ((tracing_session->state != TracingSession::STARTED) &&
      (tracing_session->state != TracingSession::CONFIGURED)) {
    PERFETTO_ELOG(
        "ChangeTraceConfig() was called for a tracing session which isn't "
        "running.");
    return;
  }

  // We only support updating producer_name_filter (and pass-through configs)
  // for now; null out any changeable fields and make sure the rest are
  // identical.
  TraceConfig new_config_copy(updated_cfg);
  for (auto& ds_cfg : *new_config_copy.mutable_data_sources()) {
    ds_cfg.clear_producer_name_filter();
  }

  TraceConfig current_config_copy(tracing_session->config);
  for (auto& ds_cfg : *current_config_copy.mutable_data_sources())
    ds_cfg.clear_producer_name_filter();

  if (new_config_copy != current_config_copy) {
    PERFETTO_LOG(
        "ChangeTraceConfig() was called with a config containing unsupported "
        "changes; only adding to the producer_name_filter is currently "
        "supported and will have an effect.");
  }

  for (TraceConfig::DataSource& cfg_data_source :
       *tracing_session->config.mutable_data_sources()) {
    // Find the updated producer_filter in the new config.
    std::vector<std::string> new_producer_name_filter;
    bool found_data_source = false;
    for (auto it : updated_cfg.data_sources()) {
      if (cfg_data_source.config().name() == it.config().name()) {
        new_producer_name_filter = it.producer_name_filter();
        found_data_source = true;
        break;
      }
    }

    // Bail out if data source not present in the new config.
    if (!found_data_source) {
      PERFETTO_ELOG(
          "ChangeTraceConfig() called without a current data source also "
          "present in the new "
          "config: %s",
          cfg_data_source.config().name().c_str());
      continue;
    }

    // TODO(oysteine): Just replacing the filter means that if
    // there are any filter entries which were present in the original config,
    // but removed from the config passed to ChangeTraceConfig, any matching
    // producers will keep producing but newly added producers after this
    // point will never start.
    *cfg_data_source.mutable_producer_name_filter() = new_producer_name_filter;

    // Scan all the registered data sources with a matching name.
    auto range = data_sources_.equal_range(cfg_data_source.config().name());
    for (auto it = range.first; it != range.second; it++) {
      ProducerEndpointImpl* producer = GetProducer(it->second.producer_id);
      PERFETTO_DCHECK(producer);

      // Check if the producer name of this data source is present
      // in the name filter. We currently only support new filters, not removing
      // old ones.
      if (!new_producer_name_filter.empty() &&
          std::find(new_producer_name_filter.begin(),
                    new_producer_name_filter.end(),
                    producer->name_) == new_producer_name_filter.end()) {
        continue;
      }

      bool already_setup = false;
      auto& ds_instances = tracing_session->data_source_instances;
      for (auto instance_it = ds_instances.begin();
           instance_it != ds_instances.end(); ++instance_it) {
        if (instance_it->first == it->second.producer_id &&
            instance_it->second.data_source_name ==
                cfg_data_source.config().name()) {
          already_setup = true;
          break;
        }
      }

      if (already_setup)
        continue;

      // If it wasn't previously setup, set it up now.
      // (The per-producer config is optional).
      TraceConfig::ProducerConfig producer_config;
      for (auto& config : tracing_session->config.producers()) {
        if (producer->name_ == config.producer_name()) {
          producer_config = config;
          break;
        }
      }

      DataSourceInstance* ds_inst = SetupDataSource(
          cfg_data_source, producer_config, it->second, tracing_session);

      if (ds_inst && tracing_session->state == TracingSession::STARTED)
        StartDataSourceInstance(producer, tracing_session, ds_inst);
    }
  }
}

bool TracingServiceImpl::StartTracing(TracingSessionID tsid) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  TracingSession* tracing_session = GetTracingSession(tsid);
  if (!tracing_session) {
    PERFETTO_DLOG("StartTracing() failed, invalid session ID %" PRIu64, tsid);
    return false;
  }

  if (tracing_session->state != TracingSession::CONFIGURED) {
    PERFETTO_DLOG("StartTracing() failed, invalid session state: %d",
                  tracing_session->state);
    return false;
  }

  tracing_session->state = TracingSession::STARTED;

  if (!tracing_session->config.builtin_data_sources()
           .disable_clock_snapshotting()) {
    SnapshotClocks(&tracing_session->initial_clock_snapshot_,
                   /*set_root_timestamp=*/true);
  }

  // Trigger delayed task if the trace is time limited.
  const uint32_t trace_duration_ms = tracing_session->config.duration_ms();
  if (trace_duration_ms > 0) {
    auto weak_this = weak_ptr_factory_.GetWeakPtr();
    task_runner_->PostDelayedTask(
        [weak_this, tsid] {
          // Skip entirely the flush if the trace session doesn't exist anymore.
          // This is to prevent misleading error messages to be logged.
          if (!weak_this)
            return;
          auto* tracing_session_ptr = weak_this->GetTracingSession(tsid);
          if (!tracing_session_ptr)
            return;
          // If this trace was using STOP_TRACING triggers and we've seen
          // one, then the trigger overrides the normal timeout. In this
          // case we just return and let the other task clean up this trace.
          if (tracing_session_ptr->config.trigger_config().trigger_mode() ==
                  TraceConfig::TriggerConfig::STOP_TRACING &&
              !tracing_session_ptr->received_triggers.empty())
            return;
          // In all other cases (START_TRACING or no triggers) we flush
          // after |trace_duration_ms| unconditionally.
          weak_this->FlushAndDisableTracing(tsid);
        },
        trace_duration_ms);
  }

  // Start the periodic drain tasks if we should to save the trace into a file.
  if (tracing_session->config.write_into_file()) {
    auto weak_this = weak_ptr_factory_.GetWeakPtr();
    task_runner_->PostDelayedTask(
        [weak_this, tsid] {
          if (weak_this)
            weak_this->ReadBuffers(tsid, nullptr);
        },
        tracing_session->delay_to_next_write_period_ms());
  }

  // Start the periodic flush tasks if the config specified a flush period.
  if (tracing_session->config.flush_period_ms())
    PeriodicFlushTask(tsid, /*post_next_only=*/true);

  // Start the periodic incremental state clear tasks if the config specified a
  // period.
  if (tracing_session->config.incremental_state_config().clear_period_ms()) {
    PeriodicClearIncrementalStateTask(tsid, /*post_next_only=*/true);
  }

  for (auto& kv : tracing_session->data_source_instances) {
    ProducerID producer_id = kv.first;
    DataSourceInstance& data_source = kv.second;
    ProducerEndpointImpl* producer = GetProducer(producer_id);
    if (!producer) {
      PERFETTO_DFATAL("Producer does not exist.");
      continue;
    }
    StartDataSourceInstance(producer, tracing_session, &data_source);
  }
  return true;
}

void TracingServiceImpl::StartDataSourceInstance(
    ProducerEndpointImpl* producer,
    TracingSession* tracing_session,
    TracingServiceImpl::DataSourceInstance* instance) {
  PERFETTO_DCHECK(instance->state == DataSourceInstance::CONFIGURED);
  if (instance->will_notify_on_start) {
    instance->state = DataSourceInstance::STARTING;
  } else {
    instance->state = DataSourceInstance::STARTED;
  }
  if (tracing_session->consumer_maybe_null) {
    tracing_session->consumer_maybe_null->OnDataSourceInstanceStateChange(
        *producer, *instance);
  }
  producer->StartDataSource(instance->instance_id, instance->config);
}

// DisableTracing just stops the data sources but doesn't free up any buffer.
// This is to allow the consumer to freeze the buffers (by stopping the trace)
// and then drain the buffers. The actual teardown of the TracingSession happens
// in FreeBuffers().
void TracingServiceImpl::DisableTracing(TracingSessionID tsid,
                                        bool disable_immediately) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  TracingSession* tracing_session = GetTracingSession(tsid);
  if (!tracing_session) {
    // Can happen if the consumer calls this before EnableTracing() or after
    // FreeBuffers().
    PERFETTO_DLOG("DisableTracing() failed, invalid session ID %" PRIu64, tsid);
    return;
  }

  switch (tracing_session->state) {
    // Spurious call to DisableTracing() while already disabled, nothing to do.
    case TracingSession::DISABLED:
      PERFETTO_DCHECK(tracing_session->AllDataSourceInstancesStopped());
      return;

    // This is either:
    // A) The case of a graceful DisableTracing() call followed by a call to
    //    FreeBuffers(), iff |disable_immediately| == true. In this case we want
    //    to forcefully transition in the disabled state without waiting for the
    //    outstanding acks because the buffers are going to be destroyed soon.
    // B) A spurious call, iff |disable_immediately| == false, in which case
    //    there is nothing to do.
    case TracingSession::DISABLING_WAITING_STOP_ACKS:
      PERFETTO_DCHECK(!tracing_session->AllDataSourceInstancesStopped());
      if (disable_immediately)
        DisableTracingNotifyConsumerAndFlushFile(tracing_session);
      return;

    // Continues below.
    case TracingSession::CONFIGURED:
      // If the session didn't even start there is no need to orchestrate a
      // graceful stop of data sources.
      disable_immediately = true;
      break;

    // This is the nominal case, continues below.
    case TracingSession::STARTED:
      break;
  }

  for (auto& data_source_inst : tracing_session->data_source_instances) {
    const ProducerID producer_id = data_source_inst.first;
    DataSourceInstance& instance = data_source_inst.second;
    const DataSourceInstanceID ds_inst_id = instance.instance_id;
    ProducerEndpointImpl* producer = GetProducer(producer_id);
    PERFETTO_DCHECK(producer);
    PERFETTO_DCHECK(instance.state == DataSourceInstance::CONFIGURED ||
                    instance.state == DataSourceInstance::STARTING ||
                    instance.state == DataSourceInstance::STARTED);
    if (instance.will_notify_on_stop && !disable_immediately) {
      instance.state = DataSourceInstance::STOPPING;
    } else {
      instance.state = DataSourceInstance::STOPPED;
    }
    if (tracing_session->consumer_maybe_null) {
      tracing_session->consumer_maybe_null->OnDataSourceInstanceStateChange(
          *producer, instance);
    }
    producer->StopDataSource(ds_inst_id);
  }

  // Either this request is flagged with |disable_immediately| or there are no
  // data sources that are requesting a final handshake. In both cases just mark
  // the session as disabled immediately, notify the consumer and flush the
  // trace file (if used).
  if (tracing_session->AllDataSourceInstancesStopped())
    return DisableTracingNotifyConsumerAndFlushFile(tracing_session);

  tracing_session->state = TracingSession::DISABLING_WAITING_STOP_ACKS;
  auto weak_this = weak_ptr_factory_.GetWeakPtr();
  task_runner_->PostDelayedTask(
      [weak_this, tsid] {
        if (weak_this)
          weak_this->OnDisableTracingTimeout(tsid);
      },
      tracing_session->data_source_stop_timeout_ms());

  // Deliberately NOT removing the session from |tracing_session_|, it's still
  // needed to call ReadBuffers(). FreeBuffers() will erase() the session.
}

void TracingServiceImpl::NotifyDataSourceStarted(
    ProducerID producer_id,
    DataSourceInstanceID instance_id) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  for (auto& kv : tracing_sessions_) {
    TracingSession& tracing_session = kv.second;
    DataSourceInstance* instance =
        tracing_session.GetDataSourceInstance(producer_id, instance_id);

    if (!instance)
      continue;

    if (instance->state != DataSourceInstance::STARTING) {
      PERFETTO_ELOG("Data source instance in incorrect state.");
      continue;
    }

    instance->state = DataSourceInstance::STARTED;

    ProducerEndpointImpl* producer = GetProducer(producer_id);
    PERFETTO_DCHECK(producer);
    if (tracing_session.consumer_maybe_null) {
      tracing_session.consumer_maybe_null->OnDataSourceInstanceStateChange(
          *producer, *instance);
    }
  }  // for (tracing_session)
}

void TracingServiceImpl::NotifyDataSourceStopped(
    ProducerID producer_id,
    DataSourceInstanceID instance_id) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  for (auto& kv : tracing_sessions_) {
    TracingSession& tracing_session = kv.second;
    DataSourceInstance* instance =
        tracing_session.GetDataSourceInstance(producer_id, instance_id);

    if (!instance)
      continue;

    if (instance->state != DataSourceInstance::STOPPING) {
      PERFETTO_ELOG("Data source instance in incorrect state.");
      continue;
    }
    PERFETTO_DCHECK(tracing_session.state ==
                    TracingSession::DISABLING_WAITING_STOP_ACKS);

    instance->state = DataSourceInstance::STOPPED;

    ProducerEndpointImpl* producer = GetProducer(producer_id);
    PERFETTO_DCHECK(producer);
    if (tracing_session.consumer_maybe_null) {
      tracing_session.consumer_maybe_null->OnDataSourceInstanceStateChange(
          *producer, *instance);
    }

    if (!tracing_session.AllDataSourceInstancesStopped())
      continue;

    // All data sources acked the termination.
    DisableTracingNotifyConsumerAndFlushFile(&tracing_session);
  }  // for (tracing_session)
}

void TracingServiceImpl::ActivateTriggers(
    ProducerID producer_id,
    const std::vector<std::string>& triggers) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  auto* producer = GetProducer(producer_id);
  PERFETTO_DCHECK(producer);
  for (const auto& trigger_name : triggers) {
    for (auto& id_and_tracing_session : tracing_sessions_) {
      auto& tracing_session = id_and_tracing_session.second;
      TracingSessionID tsid = id_and_tracing_session.first;
      auto iter = std::find_if(
          tracing_session.config.trigger_config().triggers().begin(),
          tracing_session.config.trigger_config().triggers().end(),
          [&trigger_name](const TraceConfig::TriggerConfig::Trigger& trigger) {
            return trigger.name() == trigger_name;
          });
      if (iter == tracing_session.config.trigger_config().triggers().end()) {
        continue;
      }

      // If this trigger requires a certain producer to have sent it
      // (non-empty producer_name()) ensure the producer who sent this trigger
      // matches.
      if (!iter->producer_name_regex().empty() &&
          !std::regex_match(producer->name_,
                            std::regex(iter->producer_name_regex()))) {
        continue;
      }

      const bool triggers_already_received =
          !tracing_session.received_triggers.empty();
      tracing_session.received_triggers.push_back(
          {static_cast<uint64_t>(base::GetBootTimeNs().count()), iter->name(),
           producer->name_, producer->uid_});
      auto weak_this = weak_ptr_factory_.GetWeakPtr();
      switch (tracing_session.config.trigger_config().trigger_mode()) {
        case TraceConfig::TriggerConfig::START_TRACING:
          // If the session has already been triggered and moved past
          // CONFIGURED then we don't need to repeat StartTracing. This would
          // work fine (StartTracing would return false) but would add error
          // logs.
          if (tracing_session.state != TracingSession::CONFIGURED)
            break;

          PERFETTO_DLOG("Triggering '%s' on tracing session %" PRIu64
                        " with duration of %" PRIu32 "ms.",
                        iter->name().c_str(), tsid, iter->stop_delay_ms());
          // We override the trace duration to be the trigger's requested
          // value, this ensures that the trace will end after this amount
          // of time has passed.
          tracing_session.config.set_duration_ms(iter->stop_delay_ms());
          StartTracing(tsid);
          break;
        case TraceConfig::TriggerConfig::STOP_TRACING:
          // Only stop the trace once to avoid confusing log messages. I.E.
          // when we've already hit the first trigger we've already Posted the
          // task to FlushAndDisable. So all future triggers will just break
          // out.
          if (triggers_already_received)
            break;

          PERFETTO_DLOG("Triggering '%s' on tracing session %" PRIu64
                        " with duration of %" PRIu32 "ms.",
                        iter->name().c_str(), tsid, iter->stop_delay_ms());
          // Now that we've seen a trigger we need to stop, flush, and disable
          // this session after the configured |stop_delay_ms|.
          task_runner_->PostDelayedTask(
              [weak_this, tsid] {
                // Skip entirely the flush if the trace session doesn't exist
                // anymore. This is to prevent misleading error messages to be
                // logged.
                if (weak_this && weak_this->GetTracingSession(tsid))
                  weak_this->FlushAndDisableTracing(tsid);
              },
              // If this trigger is zero this will immediately executable and
              // will happen shortly.
              iter->stop_delay_ms());
          break;
        case TraceConfig::TriggerConfig::UNSPECIFIED:
          PERFETTO_ELOG("Trigger activated but trigger mode unspecified.");
          break;
      }
    }
  }
}

// Always invoked kDataSourceStopTimeoutMs after DisableTracing(). In nominal
// conditions all data sources should have acked the stop and this will early
// out.
void TracingServiceImpl::OnDisableTracingTimeout(TracingSessionID tsid) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  TracingSession* tracing_session = GetTracingSession(tsid);
  if (!tracing_session ||
      tracing_session->state != TracingSession::DISABLING_WAITING_STOP_ACKS) {
    return;  // Tracing session was successfully disabled.
  }

  PERFETTO_ILOG("Timeout while waiting for ACKs for tracing session %" PRIu64,
                tsid);
  PERFETTO_DCHECK(!tracing_session->AllDataSourceInstancesStopped());
  DisableTracingNotifyConsumerAndFlushFile(tracing_session);
}

void TracingServiceImpl::DisableTracingNotifyConsumerAndFlushFile(
    TracingSession* tracing_session) {
  PERFETTO_DCHECK(tracing_session->state != TracingSession::DISABLED);
  for (auto& inst_kv : tracing_session->data_source_instances) {
    if (inst_kv.second.state == DataSourceInstance::STOPPED)
      continue;
    inst_kv.second.state = DataSourceInstance::STOPPED;
    ProducerEndpointImpl* producer = GetProducer(inst_kv.first);
    PERFETTO_DCHECK(producer);
    if (tracing_session->consumer_maybe_null) {
      tracing_session->consumer_maybe_null->OnDataSourceInstanceStateChange(
          *producer, inst_kv.second);
    }
  }
  tracing_session->state = TracingSession::DISABLED;

  // Scrape any remaining chunks that weren't flushed by the producers.
  for (auto& producer_id_and_producer : producers_)
    ScrapeSharedMemoryBuffers(tracing_session, producer_id_and_producer.second);

  if (tracing_session->write_into_file) {
    tracing_session->write_period_ms = 0;
    ReadBuffers(tracing_session->id, nullptr);
  }

  if (tracing_session->consumer_maybe_null)
    tracing_session->consumer_maybe_null->NotifyOnTracingDisabled();
}

void TracingServiceImpl::Flush(TracingSessionID tsid,
                               uint32_t timeout_ms,
                               ConsumerEndpoint::FlushCallback callback) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  TracingSession* tracing_session = GetTracingSession(tsid);
  if (!tracing_session) {
    PERFETTO_DLOG("Flush() failed, invalid session ID %" PRIu64, tsid);
    return;
  }

  if (!timeout_ms)
    timeout_ms = tracing_session->flush_timeout_ms();

  if (tracing_session->pending_flushes.size() > 1000) {
    PERFETTO_ELOG("Too many flushes (%zu) pending for the tracing session",
                  tracing_session->pending_flushes.size());
    callback(false);
    return;
  }

  FlushRequestID flush_request_id = ++last_flush_request_id_;
  PendingFlush& pending_flush =
      tracing_session->pending_flushes
          .emplace_hint(tracing_session->pending_flushes.end(),
                        flush_request_id, PendingFlush(std::move(callback)))
          ->second;

  // Send a flush request to each producer involved in the tracing session. In
  // order to issue a flush request we have to build a map of all data source
  // instance ids enabled for each producer.
  std::map<ProducerID, std::vector<DataSourceInstanceID>> flush_map;
  for (const auto& data_source_inst : tracing_session->data_source_instances) {
    const ProducerID producer_id = data_source_inst.first;
    const DataSourceInstanceID ds_inst_id = data_source_inst.second.instance_id;
    flush_map[producer_id].push_back(ds_inst_id);
  }

  for (const auto& kv : flush_map) {
    ProducerID producer_id = kv.first;
    ProducerEndpointImpl* producer = GetProducer(producer_id);
    const std::vector<DataSourceInstanceID>& data_sources = kv.second;
    producer->Flush(flush_request_id, data_sources);
    pending_flush.producers.insert(producer_id);
  }

  // If there are no producers to flush (realistically this happens only in
  // some tests) fire OnFlushTimeout() straight away, without waiting.
  if (flush_map.empty())
    timeout_ms = 0;

  auto weak_this = weak_ptr_factory_.GetWeakPtr();
  task_runner_->PostDelayedTask(
      [weak_this, tsid, flush_request_id] {
        if (weak_this)
          weak_this->OnFlushTimeout(tsid, flush_request_id);
      },
      timeout_ms);
}

void TracingServiceImpl::NotifyFlushDoneForProducer(
    ProducerID producer_id,
    FlushRequestID flush_request_id) {
  for (auto& kv : tracing_sessions_) {
    // Remove all pending flushes <= |flush_request_id| for |producer_id|.
    auto& pending_flushes = kv.second.pending_flushes;
    auto end_it = pending_flushes.upper_bound(flush_request_id);
    for (auto it = pending_flushes.begin(); it != end_it;) {
      PendingFlush& pending_flush = it->second;
      pending_flush.producers.erase(producer_id);
      if (pending_flush.producers.empty()) {
        auto weak_this = weak_ptr_factory_.GetWeakPtr();
        TracingSessionID tsid = kv.first;
        auto callback = std::move(pending_flush.callback);
        task_runner_->PostTask([weak_this, tsid, callback]() {
          if (weak_this) {
            weak_this->CompleteFlush(tsid, std::move(callback),
                                     /*success=*/true);
          }
        });
        it = pending_flushes.erase(it);
      } else {
        it++;
      }
    }  // for (pending_flushes)
  }    // for (tracing_session)
}

void TracingServiceImpl::OnFlushTimeout(TracingSessionID tsid,
                                        FlushRequestID flush_request_id) {
  TracingSession* tracing_session = GetTracingSession(tsid);
  if (!tracing_session)
    return;
  auto it = tracing_session->pending_flushes.find(flush_request_id);
  if (it == tracing_session->pending_flushes.end())
    return;  // Nominal case: flush was completed and acked on time.

  // If there were no producers to flush, consider it a success.
  bool success = it->second.producers.empty();

  auto callback = std::move(it->second.callback);
  tracing_session->pending_flushes.erase(it);
  CompleteFlush(tsid, std::move(callback), success);
}

void TracingServiceImpl::CompleteFlush(TracingSessionID tsid,
                                       ConsumerEndpoint::FlushCallback callback,
                                       bool success) {
  TracingSession* tracing_session = GetTracingSession(tsid);
  if (tracing_session) {
    // Producers may not have been able to flush all their data, even if they
    // indicated flush completion. If possible, also collect uncommitted chunks
    // to make sure we have everything they wrote so far.
    for (auto& producer_id_and_producer : producers_) {
      ScrapeSharedMemoryBuffers(tracing_session,
                                producer_id_and_producer.second);
    }
  }
  callback(success);
}

void TracingServiceImpl::ScrapeSharedMemoryBuffers(
    TracingSession* tracing_session,
    ProducerEndpointImpl* producer) {
  if (!producer->smb_scraping_enabled_)
    return;

  // Can't copy chunks if we don't know about any trace writers.
  if (producer->writers_.empty())
    return;

  // Performance optimization: On flush or session disconnect, this method is
  // called for each producer. If the producer doesn't participate in the
  // session, there's no need to scape its chunks right now. We can tell if a
  // producer participates in the session by checking if the producer is allowed
  // to write into the session's log buffers.
  const auto& session_buffers = tracing_session->buffers_index;
  bool producer_in_session =
      std::any_of(session_buffers.begin(), session_buffers.end(),
                  [producer](BufferID buffer_id) {
                    return producer->allowed_target_buffers_.count(buffer_id);
                  });
  if (!producer_in_session)
    return;

  PERFETTO_DLOG("Scraping SMB for producer %" PRIu16, producer->id_);

  // Find and copy any uncommitted chunks from the SMB.
  //
  // In nominal conditions, the page layout of the used SMB pages should never
  // change because the service is the only one who is supposed to modify used
  // pages (to make them free again).
  //
  // However, the code here needs to deal with the case of a malicious producer
  // altering the SMB in unpredictable ways. Thankfully the SMB size is
  // immutable, so a chunk will always point to some valid memory, even if the
  // producer alters the intended layout and chunk header concurrently.
  // Ultimately a malicious producer altering the SMB's chunk layout while we
  // are iterating in this function is not any different from the case of a
  // malicious producer asking to commit a chunk made of random data, which is
  // something this class has to deal with regardless.
  //
  // The only legitimate mutations that can happen from sane producers,
  // concurrently to this function, are:
  //   A. free pages being partitioned,
  //   B. free chunks being migrated to kChunkBeingWritten,
  //   C. kChunkBeingWritten chunks being migrated to kChunkCompleted.

  SharedMemoryABI* abi = &producer->shmem_abi_;
  // num_pages() is immutable after the SMB is initialized and cannot be changed
  // even by a producer even if malicious.
  for (size_t page_idx = 0; page_idx < abi->num_pages(); page_idx++) {
    uint32_t layout = abi->GetPageLayout(page_idx);

    uint32_t used_chunks = abi->GetUsedChunks(layout);  // Returns a bitmap.
    // Skip empty pages.
    if (used_chunks == 0)
      continue;

    // Scrape the chunks that are currently used. These should be either in
    // state kChunkBeingWritten or kChunkComplete.
    for (uint32_t chunk_idx = 0; used_chunks; chunk_idx++, used_chunks >>= 1) {
      if (!(used_chunks & 1))
        continue;

      SharedMemoryABI::ChunkState state =
          SharedMemoryABI::GetChunkStateFromLayout(layout, chunk_idx);
      PERFETTO_DCHECK(state == SharedMemoryABI::kChunkBeingWritten ||
                      state == SharedMemoryABI::kChunkComplete);
      bool chunk_complete = state == SharedMemoryABI::kChunkComplete;

      SharedMemoryABI::Chunk chunk =
          abi->GetChunkUnchecked(page_idx, layout, chunk_idx);

      uint16_t packet_count;
      uint8_t flags;
      // GetPacketCountAndFlags has acquire_load semantics.
      std::tie(packet_count, flags) = chunk.GetPacketCountAndFlags();

      // It only makes sense to copy an incomplete chunk if there's at least
      // one full packet available. (The producer may not have completed the
      // last packet in it yet, so we need at least 2.)
      if (!chunk_complete && packet_count < 2)
        continue;

      // At this point, it is safe to access the remaining header fields of
      // the chunk. Even if the chunk was only just transferred from
      // kChunkFree into kChunkBeingWritten state, the header should be
      // written completely once the packet count increased above 1 (it was
      // reset to 0 by the service when the chunk was freed).

      WriterID writer_id = chunk.writer_id();
      base::Optional<BufferID> target_buffer_id =
          producer->buffer_id_for_writer(writer_id);

      // We can only scrape this chunk if we know which log buffer to copy it
      // into.
      if (!target_buffer_id)
        continue;

      // Skip chunks that don't belong to the requested tracing session.
      bool target_buffer_belongs_to_session =
          std::find(session_buffers.begin(), session_buffers.end(),
                    *target_buffer_id) != session_buffers.end();
      if (!target_buffer_belongs_to_session)
        continue;

      uint32_t chunk_id =
          chunk.header()->chunk_id.load(std::memory_order_relaxed);

      CopyProducerPageIntoLogBuffer(
          producer->id_, producer->uid_, writer_id, chunk_id, *target_buffer_id,
          packet_count, flags, chunk_complete, chunk.payload_begin(),
          chunk.payload_size());
    }
  }
}

void TracingServiceImpl::FlushAndDisableTracing(TracingSessionID tsid) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  PERFETTO_DLOG("Triggering final flush for %" PRIu64, tsid);
  auto weak_this = weak_ptr_factory_.GetWeakPtr();
  Flush(tsid, 0, [weak_this, tsid](bool success) {
    PERFETTO_DLOG("Flush done (success: %d), disabling trace session %" PRIu64,
                  success, tsid);
    if (!weak_this)
      return;
    TracingSession* session = weak_this->GetTracingSession(tsid);
    if (session->consumer_maybe_null) {
      // If the consumer is still attached, just disable the session but give it
      // a chance to read the contents.
      weak_this->DisableTracing(tsid);
    } else {
      // If the consumer detached, destroy the session. If the consumer did
      // start the session in long-tracing mode, the service will have saved
      // the contents to the passed file. If not, the contents will be
      // destroyed.
      weak_this->FreeBuffers(tsid);
    }
  });
}

void TracingServiceImpl::PeriodicFlushTask(TracingSessionID tsid,
                                           bool post_next_only) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  TracingSession* tracing_session = GetTracingSession(tsid);
  if (!tracing_session || tracing_session->state != TracingSession::STARTED)
    return;

  uint32_t flush_period_ms = tracing_session->config.flush_period_ms();
  auto weak_this = weak_ptr_factory_.GetWeakPtr();
  task_runner_->PostDelayedTask(
      [weak_this, tsid] {
        if (weak_this)
          weak_this->PeriodicFlushTask(tsid, /*post_next_only=*/false);
      },
      flush_period_ms - (base::GetWallTimeMs().count() % flush_period_ms));

  if (post_next_only)
    return;

  PERFETTO_DLOG("Triggering periodic flush for trace session %" PRIu64, tsid);
  Flush(tsid, 0, [](bool success) {
    if (!success)
      PERFETTO_ELOG("Periodic flush timed out");
  });
}

void TracingServiceImpl::PeriodicClearIncrementalStateTask(
    TracingSessionID tsid,
    bool post_next_only) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  TracingSession* tracing_session = GetTracingSession(tsid);
  if (!tracing_session || tracing_session->state != TracingSession::STARTED)
    return;

  uint32_t clear_period_ms =
      tracing_session->config.incremental_state_config().clear_period_ms();
  auto weak_this = weak_ptr_factory_.GetWeakPtr();
  task_runner_->PostDelayedTask(
      [weak_this, tsid] {
        if (weak_this)
          weak_this->PeriodicClearIncrementalStateTask(
              tsid, /*post_next_only=*/false);
      },
      clear_period_ms - (base::GetWallTimeMs().count() % clear_period_ms));

  if (post_next_only)
    return;

  PERFETTO_DLOG(
      "Performing periodic incremental state clear for trace session %" PRIu64,
      tsid);

  // Queue the IPCs to producers with active data sources that opted in.
  std::map<ProducerID, std::vector<DataSourceInstanceID>> clear_map;
  for (const auto& kv : tracing_session->data_source_instances) {
    ProducerID producer_id = kv.first;
    const DataSourceInstance& data_source = kv.second;
    if (data_source.handles_incremental_state_clear)
      clear_map[producer_id].push_back(data_source.instance_id);
  }

  for (const auto& kv : clear_map) {
    ProducerID producer_id = kv.first;
    const std::vector<DataSourceInstanceID>& data_sources = kv.second;
    ProducerEndpointImpl* producer = GetProducer(producer_id);
    if (!producer) {
      PERFETTO_DFATAL("Producer does not exist.");
      continue;
    }
    producer->ClearIncrementalState(data_sources);
  }
}

// Note: when this is called to write into a file passed when starting tracing
// |consumer| will be == nullptr (as opposite to the case of a consumer asking
// to send the trace data back over IPC).
void TracingServiceImpl::ReadBuffers(TracingSessionID tsid,
                                     ConsumerEndpointImpl* consumer) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  TracingSession* tracing_session = GetTracingSession(tsid);
  if (!tracing_session) {
    // This will be hit systematically from the PostDelayedTask when directly
    // writing into the file (in which case consumer == nullptr). Suppress the
    // log in this case as it's just spam.
    if (consumer)
      PERFETTO_DLOG("Cannot ReadBuffers(): no tracing session is active");
    return;  // TODO(primiano): signal failure?
  }

  // When a tracing session is waiting for a trigger it is considered empty. If
  // a tracing session finishes and moves into DISABLED without ever receiving a
  // trigger the trace should never return any data. This includes the synthetic
  // packets like TraceConfig and Clock snapshots. So we bail out early and let
  // the consumer know there is no data.
  if (!tracing_session->config.trigger_config().triggers().empty() &&
      tracing_session->received_triggers.empty()) {
    if (consumer)
      consumer->consumer_->OnTraceData({}, /* has_more = */ false);
    PERFETTO_DLOG(
        "ReadBuffers(): tracing session has not received a trigger yet.");
    return;
  }

  // This can happen if the file is closed by a previous task because it reaches
  // |max_file_size_bytes|.
  if (!tracing_session->write_into_file && !consumer)
    return;

  if (tracing_session->write_into_file && consumer) {
    // If the consumer enabled tracing and asked to save the contents into the
    // passed file makes little sense to also try to read the buffers over IPC,
    // as that would just steal data from the periodic draining task.
    PERFETTO_DFATAL("Consumer trying to read from write_into_file session.");
    return;
  }

  std::vector<TracePacket> packets;
  packets.reserve(1024);  // Just an educated guess to avoid trivial expansions.

  std::move(tracing_session->initial_clock_snapshot_.begin(),
            tracing_session->initial_clock_snapshot_.end(),
            std::back_inserter(packets));
  tracing_session->initial_clock_snapshot_.clear();

  base::TimeMillis now = base::GetWallTimeMs();
  if (now >= tracing_session->last_snapshot_time + kSnapshotsInterval) {
    tracing_session->last_snapshot_time = now;
    // Don't emit the stats immediately, but instead wait until no more trace
    // data is available to read. That way, any problems that occur while
    // reading from the buffers are reflected in the emitted stats. This is
    // particularly important for use cases where ReadBuffers is only ever
    // called after the tracing session is stopped.
    tracing_session->should_emit_stats = true;
    SnapshotSyncMarker(&packets);

    if (!tracing_session->config.builtin_data_sources()
             .disable_clock_snapshotting()) {
      // We don't want to put a root timestamp in this snapshot as the packet
      // may be very out of order with respect to the actual trace packets
      // since consuming the trace may happen at any point after it starts.
      SnapshotClocks(&packets, /*set_root_timestamp=*/false);
    }
  }
  if (!tracing_session->config.builtin_data_sources().disable_trace_config()) {
    MaybeEmitTraceConfig(tracing_session, &packets);
    MaybeEmitReceivedTriggers(tracing_session, &packets);
  }
  if (!tracing_session->config.builtin_data_sources().disable_system_info())
    MaybeEmitSystemInfo(tracing_session, &packets);

  size_t packets_bytes = 0;  // SUM(slice.size() for each slice in |packets|).
  size_t total_slices = 0;   // SUM(#slices in |packets|).

  // Add up size for packets added by the Maybe* calls above.
  for (const TracePacket& packet : packets) {
    packets_bytes += packet.size();
    total_slices += packet.slices().size();
  }

  // This is a rough threshold to determine how much to read from the buffer in
  // each task. This is to avoid executing a single huge sending task for too
  // long and risk to hit the watchdog. This is *not* an upper bound: we just
  // stop accumulating new packets and PostTask *after* we cross this threshold.
  // This constant essentially balances the PostTask and IPC overhead vs the
  // responsiveness of the service. An extremely small value will cause one IPC
  // and one PostTask for each slice but will keep the service extremely
  // responsive. An extremely large value will batch the send for the full
  // buffer in one large task, will hit the blocking send() once the socket
  // buffers are full and hang the service for a bit (until the consumer
  // catches up).
  static constexpr size_t kApproxBytesPerTask = 32768;
  bool did_hit_threshold = false;

  // TODO(primiano): Extend the ReadBuffers API to allow reading only some
  // buffers, not all of them in one go.
  for (size_t buf_idx = 0;
       buf_idx < tracing_session->num_buffers() && !did_hit_threshold;
       buf_idx++) {
    auto tbuf_iter = buffers_.find(tracing_session->buffers_index[buf_idx]);
    if (tbuf_iter == buffers_.end()) {
      PERFETTO_DFATAL("Buffer not found.");
      continue;
    }
    TraceBuffer& tbuf = *tbuf_iter->second;
    tbuf.BeginRead();
    while (!did_hit_threshold) {
      TracePacket packet;
      TraceBuffer::PacketSequenceProperties sequence_properties{};
      bool previous_packet_dropped;
      if (!tbuf.ReadNextTracePacket(&packet, &sequence_properties,
                                    &previous_packet_dropped)) {
        break;
      }
      PERFETTO_DCHECK(sequence_properties.producer_id_trusted != 0);
      PERFETTO_DCHECK(sequence_properties.writer_id != 0);
      PERFETTO_DCHECK(sequence_properties.producer_uid_trusted != kInvalidUid);
      PERFETTO_DCHECK(packet.size() > 0);
      if (!PacketStreamValidator::Validate(packet.slices())) {
        PERFETTO_DLOG("Dropping invalid packet");
        continue;
      }

      // Append a slice with the trusted field data. This can't be spoofed
      // because above we validated that the existing slices don't contain any
      // trusted fields. For added safety we append instead of prepending
      // because according to protobuf semantics, if the same field is
      // encountered multiple times the last instance takes priority. Note that
      // truncated packets are also rejected, so the producer can't give us a
      // partial packet (e.g., a truncated string) which only becomes valid when
      // the trusted data is appended here.
      protos::TrustedPacket trusted_packet;
      trusted_packet.set_trusted_uid(
          static_cast<int32_t>(sequence_properties.producer_uid_trusted));
      trusted_packet.set_trusted_packet_sequence_id(
          tracing_session->GetPacketSequenceID(
              sequence_properties.producer_id_trusted,
              sequence_properties.writer_id));
      if (previous_packet_dropped)
        trusted_packet.set_previous_packet_dropped(previous_packet_dropped);
      static constexpr size_t kTrustedBufSize = 16;
      Slice slice = Slice::Allocate(kTrustedBufSize);
      PERFETTO_CHECK(
          trusted_packet.SerializeToArray(slice.own_data(), kTrustedBufSize));
      slice.size = static_cast<size_t>(trusted_packet.GetCachedSize());
      PERFETTO_DCHECK(slice.size > 0 && slice.size <= kTrustedBufSize);
      packet.AddSlice(std::move(slice));

      // Append the packet (inclusive of the trusted uid) to |packets|.
      packets_bytes += packet.size();
      total_slices += packet.slices().size();
      did_hit_threshold = packets_bytes >= kApproxBytesPerTask &&
                          !tracing_session->write_into_file;
      packets.emplace_back(std::move(packet));
    }  // for(packets...)
  }    // for(buffers...)

  const bool has_more = did_hit_threshold;
  if (!has_more && tracing_session->should_emit_stats) {
    size_t prev_packets_size = packets.size();
    SnapshotStats(tracing_session, &packets);
    tracing_session->should_emit_stats = false;

    // Add sizes of packets emitted by SnapshotStats.
    for (size_t i = prev_packets_size; i < packets.size(); ++i) {
      packets_bytes += packets[i].size();
      total_slices += packets[i].slices().size();
    }
  }

  // If the caller asked us to write into a file by setting
  // |write_into_file| == true in the trace config, drain the packets read
  // (if any) into the given file descriptor.
  if (tracing_session->write_into_file) {
    const uint64_t max_size = tracing_session->max_file_size_bytes
                                  ? tracing_session->max_file_size_bytes
                                  : std::numeric_limits<size_t>::max();

    // When writing into a file, the file should look like a root trace.proto
    // message. Each packet should be prepended with a proto preamble stating
    // its field id (within trace.proto) and size. Hence the addition below.
    const size_t max_iovecs = total_slices + packets.size();

    size_t num_iovecs = 0;
    bool stop_writing_into_file = tracing_session->write_period_ms == 0;
    std::unique_ptr<struct iovec[]> iovecs(new struct iovec[max_iovecs]);
    size_t num_iovecs_at_last_packet = 0;
    uint64_t bytes_about_to_be_written = 0;
    for (TracePacket& packet : packets) {
      std::tie(iovecs[num_iovecs].iov_base, iovecs[num_iovecs].iov_len) =
          packet.GetProtoPreamble();
      bytes_about_to_be_written += iovecs[num_iovecs].iov_len;
      num_iovecs++;
      for (const Slice& slice : packet.slices()) {
        // writev() doesn't change the passed pointer. However, struct iovec
        // take a non-const ptr because it's the same struct used by readv().
        // Hence the const_cast here.
        char* start = static_cast<char*>(const_cast<void*>(slice.start));
        bytes_about_to_be_written += slice.size;
        iovecs[num_iovecs++] = {start, slice.size};
      }

      if (tracing_session->bytes_written_into_file +
              bytes_about_to_be_written >=
          max_size) {
        stop_writing_into_file = true;
        num_iovecs = num_iovecs_at_last_packet;
        break;
      }

      num_iovecs_at_last_packet = num_iovecs;
    }
    PERFETTO_DCHECK(num_iovecs <= max_iovecs);
    int fd = *tracing_session->write_into_file;

    uint64_t total_wr_size = 0;

    // writev() can take at most IOV_MAX entries per call. Batch them.
    constexpr size_t kIOVMax = IOV_MAX;
    for (size_t i = 0; i < num_iovecs; i += kIOVMax) {
      int iov_batch_size = static_cast<int>(std::min(num_iovecs - i, kIOVMax));
      ssize_t wr_size = PERFETTO_EINTR(writev(fd, &iovecs[i], iov_batch_size));
      if (wr_size <= 0) {
        PERFETTO_PLOG("writev() failed");
        stop_writing_into_file = true;
        break;
      }
      total_wr_size += static_cast<size_t>(wr_size);
    }

    tracing_session->bytes_written_into_file += total_wr_size;

    PERFETTO_DLOG("Draining into file, written: %" PRIu64 " KB, stop: %d",
                  (total_wr_size + 1023) / 1024, stop_writing_into_file);
    if (stop_writing_into_file) {
      // Ensure all data was written to the file before we close it.
      base::FlushFile(fd);
      tracing_session->write_into_file.reset();
      tracing_session->write_period_ms = 0;
      if (tracing_session->state == TracingSession::STARTED)
        DisableTracing(tsid);
      return;
    }

    auto weak_this = weak_ptr_factory_.GetWeakPtr();
    task_runner_->PostDelayedTask(
        [weak_this, tsid] {
          if (weak_this)
            weak_this->ReadBuffers(tsid, nullptr);
        },
        tracing_session->delay_to_next_write_period_ms());
    return;
  }  // if (tracing_session->write_into_file)

  if (has_more) {
    auto weak_consumer = consumer->GetWeakPtr();
    auto weak_this = weak_ptr_factory_.GetWeakPtr();
    task_runner_->PostTask([weak_this, weak_consumer, tsid] {
      if (!weak_this || !weak_consumer)
        return;
      weak_this->ReadBuffers(tsid, weak_consumer.get());
    });
  }

  // Keep this as tail call, just in case the consumer re-enters.
  consumer->consumer_->OnTraceData(std::move(packets), has_more);
}

void TracingServiceImpl::FreeBuffers(TracingSessionID tsid) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  PERFETTO_DLOG("Freeing buffers for session %" PRIu64, tsid);
  TracingSession* tracing_session = GetTracingSession(tsid);
  if (!tracing_session) {
    PERFETTO_DLOG("FreeBuffers() failed, invalid session ID %" PRIu64, tsid);
    return;  // TODO(primiano): signal failure?
  }
  DisableTracing(tsid, /*disable_immediately=*/true);

  PERFETTO_DCHECK(tracing_session->AllDataSourceInstancesStopped());
  tracing_session->data_source_instances.clear();

  for (auto& producer_entry : producers_) {
    ProducerEndpointImpl* producer = producer_entry.second;
    producer->OnFreeBuffers(tracing_session->buffers_index);
  }

  for (BufferID buffer_id : tracing_session->buffers_index) {
    buffer_ids_.Free(buffer_id);
    PERFETTO_DCHECK(buffers_.count(buffer_id) == 1);
    buffers_.erase(buffer_id);
  }
  bool notify_traceur = tracing_session->config.notify_traceur();
  tracing_sessions_.erase(tsid);
  UpdateMemoryGuardrail();

  PERFETTO_LOG("Tracing session %" PRIu64 " ended, total sessions:%zu", tsid,
               tracing_sessions_.size());

#if PERFETTO_BUILDFLAG(PERFETTO_OS_ANDROID)
  static const char kTraceurProp[] = "sys.trace.trace_end_signal";
  if (notify_traceur && __system_property_set(kTraceurProp, "1"))
    PERFETTO_ELOG("Failed to setprop %s=1", kTraceurProp);
#else
  base::ignore_result(notify_traceur);
#endif
}

void TracingServiceImpl::RegisterDataSource(ProducerID producer_id,
                                            const DataSourceDescriptor& desc) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  PERFETTO_DLOG("Producer %" PRIu16 " registered data source \"%s\"",
                producer_id, desc.name().c_str());

  PERFETTO_DCHECK(!desc.name().empty());
  auto reg_ds = data_sources_.emplace(desc.name(),
                                      RegisteredDataSource{producer_id, desc});

  // If there are existing tracing sessions, we need to check if the new
  // data source is enabled by any of them.
  if (tracing_sessions_.empty())
    return;

  ProducerEndpointImpl* producer = GetProducer(producer_id);
  if (!producer) {
    PERFETTO_DFATAL("Producer not found.");
    return;
  }

  for (auto& iter : tracing_sessions_) {
    TracingSession& tracing_session = iter.second;
    if (tracing_session.state != TracingSession::STARTED &&
        tracing_session.state != TracingSession::CONFIGURED) {
      continue;
    }

    TraceConfig::ProducerConfig producer_config;
    for (auto& config : tracing_session.config.producers()) {
      if (producer->name_ == config.producer_name()) {
        producer_config = config;
        break;
      }
    }
    for (const TraceConfig::DataSource& cfg_data_source :
         tracing_session.config.data_sources()) {
      if (cfg_data_source.config().name() != desc.name())
        continue;
      DataSourceInstance* ds_inst = SetupDataSource(
          cfg_data_source, producer_config, reg_ds->second, &tracing_session);
      if (ds_inst && tracing_session.state == TracingSession::STARTED)
        StartDataSourceInstance(producer, &tracing_session, ds_inst);
    }
  }
}

void TracingServiceImpl::UnregisterDataSource(ProducerID producer_id,
                                              const std::string& name) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  PERFETTO_CHECK(producer_id);
  ProducerEndpointImpl* producer = GetProducer(producer_id);
  PERFETTO_DCHECK(producer);
  for (auto& kv : tracing_sessions_) {
    auto& ds_instances = kv.second.data_source_instances;
    for (auto it = ds_instances.begin(); it != ds_instances.end();) {
      if (it->first == producer_id && it->second.data_source_name == name) {
        DataSourceInstanceID ds_inst_id = it->second.instance_id;
        if (it->second.state != DataSourceInstance::STOPPED) {
          if (it->second.state != DataSourceInstance::STOPPING)
            producer->StopDataSource(ds_inst_id);
          // Mark the instance as stopped immediately, since we are
          // unregistering it below.
          if (it->second.state == DataSourceInstance::STOPPING)
            NotifyDataSourceStopped(producer_id, ds_inst_id);
        }
        it = ds_instances.erase(it);
      } else {
        ++it;
      }
    }  // for (data_source_instances)
  }    // for (tracing_session)

  for (auto it = data_sources_.begin(); it != data_sources_.end(); ++it) {
    if (it->second.producer_id == producer_id &&
        it->second.descriptor.name() == name) {
      data_sources_.erase(it);
      return;
    }
  }

  PERFETTO_DFATAL(
      "Tried to unregister a non-existent data source \"%s\" for "
      "producer %" PRIu16,
      name.c_str(), producer_id);
}

TracingServiceImpl::DataSourceInstance* TracingServiceImpl::SetupDataSource(
    const TraceConfig::DataSource& cfg_data_source,
    const TraceConfig::ProducerConfig& producer_config,
    const RegisteredDataSource& data_source,
    TracingSession* tracing_session) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  ProducerEndpointImpl* producer = GetProducer(data_source.producer_id);
  PERFETTO_DCHECK(producer);
  // An existing producer that is not ftrace could have registered itself as
  // ftrace, we must not enable it in that case.
  if (lockdown_mode_ && producer->uid_ != uid_) {
    PERFETTO_DLOG("Lockdown mode: not enabling producer %hu", producer->id_);
    return nullptr;
  }
  // TODO(primiano): Add tests for registration ordering
  // (data sources vs consumers).
  // TODO: This logic is duplicated in ChangeTraceConfig, consider refactoring
  // it. Meanwhile update both.
  if (!cfg_data_source.producer_name_filter().empty()) {
    if (std::find(cfg_data_source.producer_name_filter().begin(),
                  cfg_data_source.producer_name_filter().end(),
                  producer->name_) ==
        cfg_data_source.producer_name_filter().end()) {
      PERFETTO_DLOG("Data source: %s is filtered out for producer: %s",
                    cfg_data_source.config().name().c_str(),
                    producer->name_.c_str());
      return nullptr;
    }
  }

  auto relative_buffer_id = cfg_data_source.config().target_buffer();
  if (relative_buffer_id >= tracing_session->num_buffers()) {
    PERFETTO_LOG(
        "The TraceConfig for DataSource %s specified a target_buffer out of "
        "bound (%d). Skipping it.",
        cfg_data_source.config().name().c_str(), relative_buffer_id);
    return nullptr;
  }

  // Create a copy of the DataSourceConfig specified in the trace config. This
  // will be passed to the producer after translating the |target_buffer| id.
  // The |target_buffer| parameter passed by the consumer in the trace config is
  // relative to the buffers declared in the same trace config. This has to be
  // translated to the global BufferID before passing it to the producers, which
  // don't know anything about tracing sessions and consumers.

  DataSourceInstanceID inst_id = ++last_data_source_instance_id_;
  auto insert_iter = tracing_session->data_source_instances.emplace(
      std::piecewise_construct,  //
      std::forward_as_tuple(producer->id_),
      std::forward_as_tuple(
          inst_id,
          cfg_data_source.config(),  //  Deliberate copy.
          data_source.descriptor.name(),
          data_source.descriptor.will_notify_on_start(),
          data_source.descriptor.will_notify_on_stop(),
          data_source.descriptor.handles_incremental_state_clear()));
  DataSourceInstance* ds_instance = &insert_iter->second;

  // New data source instance starts out in CONFIGURED state.
  if (tracing_session->consumer_maybe_null) {
    tracing_session->consumer_maybe_null->OnDataSourceInstanceStateChange(
        *producer, *ds_instance);
  }

  DataSourceConfig& ds_config = ds_instance->config;
  ds_config.set_trace_duration_ms(tracing_session->config.duration_ms());
  ds_config.set_enable_extra_guardrails(
      tracing_session->config.enable_extra_guardrails());
  ds_config.set_tracing_session_id(tracing_session->id);
  BufferID global_id = tracing_session->buffers_index[relative_buffer_id];
  PERFETTO_DCHECK(global_id);
  ds_config.set_target_buffer(global_id);

  PERFETTO_DLOG("Setting up data source %s with target buffer %" PRIu16,
                ds_config.name().c_str(), global_id);
  if (!producer->shared_memory()) {
    // Determine the SMB page size. Must be an integer multiple of 4k.
    size_t page_size = std::min<size_t>(producer_config.page_size_kb() * 1024,
                                        SharedMemoryABI::kMaxPageSize);
    if (page_size < base::kPageSize || page_size % base::kPageSize != 0)
      page_size = kDefaultShmPageSize;
    producer->shared_buffer_page_size_kb_ = page_size / 1024;

    // Determine the SMB size. Must be an integer multiple of the SMB page size.
    // The decisional tree is as follows:
    // 1. Give priority to what defined in the trace config.
    // 2. If unset give priority to the hint passed by the producer.
    // 3. Keep within bounds and ensure it's a multiple of the page size.
    size_t shm_size = producer_config.shm_size_kb() * 1024;
    if (shm_size == 0)
      shm_size = producer->shmem_size_hint_bytes_;
    shm_size = std::min<size_t>(shm_size, kMaxShmSize);
    if (shm_size < page_size || shm_size % page_size)
      shm_size = kDefaultShmSize;

    // TODO(primiano): right now Create() will suicide in case of OOM if the
    // mmap fails. We should instead gracefully fail the request and tell the
    // client to go away.
    auto shared_memory = shm_factory_->CreateSharedMemory(shm_size);
    producer->SetSharedMemory(std::move(shared_memory));
    producer->OnTracingSetup();
    UpdateMemoryGuardrail();
  }
  producer->SetupDataSource(inst_id, ds_config);
  return ds_instance;
}

// Note: all the fields % *_trusted ones are untrusted, as in, the Producer
// might be lying / returning garbage contents. |src| and |size| can be trusted
// in terms of being a valid pointer, but not the contents.
void TracingServiceImpl::CopyProducerPageIntoLogBuffer(
    ProducerID producer_id_trusted,
    uid_t producer_uid_trusted,
    WriterID writer_id,
    ChunkID chunk_id,
    BufferID buffer_id,
    uint16_t num_fragments,
    uint8_t chunk_flags,
    bool chunk_complete,
    const uint8_t* src,
    size_t size) {
  PERFETTO_DCHECK_THREAD(thread_checker_);

  ProducerEndpointImpl* producer = GetProducer(producer_id_trusted);
  if (!producer) {
    PERFETTO_DFATAL("Producer not found.");
    chunks_discarded_++;
    return;
  }

  TraceBuffer* buf = GetBufferByID(buffer_id);
  if (!buf) {
    PERFETTO_DLOG("Could not find target buffer %" PRIu16
                  " for producer %" PRIu16,
                  buffer_id, producer_id_trusted);
    chunks_discarded_++;
    return;
  }

  // Verify that the producer is actually allowed to write into the target
  // buffer specified in the request. This prevents a malicious producer from
  // injecting data into a log buffer that belongs to a tracing session the
  // producer is not part of.
  if (!producer->is_allowed_target_buffer(buffer_id)) {
    PERFETTO_ELOG("Producer %" PRIu16
                  " tried to write into forbidden target buffer %" PRIu16,
                  producer_id_trusted, buffer_id);
    PERFETTO_DFATAL("Forbidden target buffer");
    chunks_discarded_++;
    return;
  }

  // If the writer was registered by the producer, it should only write into the
  // buffer it was registered with.
  base::Optional<BufferID> associated_buffer =
      producer->buffer_id_for_writer(writer_id);
  if (associated_buffer && *associated_buffer != buffer_id) {
    PERFETTO_ELOG("Writer %" PRIu16 " of producer %" PRIu16
                  " was registered to write into target buffer %" PRIu16
                  ", but tried to write into buffer %" PRIu16,
                  writer_id, producer_id_trusted, *associated_buffer,
                  buffer_id);
    PERFETTO_DFATAL("Wrong target buffer");
    chunks_discarded_++;
    return;
  }

  buf->CopyChunkUntrusted(producer_id_trusted, producer_uid_trusted, writer_id,
                          chunk_id, num_fragments, chunk_flags, chunk_complete,
                          src, size);
}

void TracingServiceImpl::ApplyChunkPatches(
    ProducerID producer_id_trusted,
    const std::vector<CommitDataRequest::ChunkToPatch>& chunks_to_patch) {
  PERFETTO_DCHECK_THREAD(thread_checker_);

  for (const auto& chunk : chunks_to_patch) {
    const ChunkID chunk_id = static_cast<ChunkID>(chunk.chunk_id());
    const WriterID writer_id = static_cast<WriterID>(chunk.writer_id());
    TraceBuffer* buf =
        GetBufferByID(static_cast<BufferID>(chunk.target_buffer()));
    static_assert(std::numeric_limits<ChunkID>::max() == kMaxChunkID,
                  "Add a '|| chunk_id > kMaxChunkID' below if this fails");
    if (!writer_id || writer_id > kMaxWriterID || !buf) {
      PERFETTO_ELOG(
          "Received invalid chunks_to_patch request from Producer: %" PRIu16
          ", BufferID: %" PRIu32 " ChunkdID: %" PRIu32 " WriterID: %" PRIu16,
          producer_id_trusted, chunk.target_buffer(), chunk_id, writer_id);
      patches_discarded_ += static_cast<uint64_t>(chunk.patches_size());
      continue;
    }

    // Note, there's no need to validate that the producer is allowed to write
    // to the specified buffer ID (or that it's the correct buffer ID for a
    // registered TraceWriter). That's because TraceBuffer uses the producer ID
    // and writer ID to look up the chunk to patch. If the producer specifies an
    // incorrect buffer, this lookup will fail and TraceBuffer will ignore the
    // patches. Because the producer ID is trusted, there's also no way for a
    // malicious producer to patch another producer's data.

    // Speculate on the fact that there are going to be a limited amount of
    // patches per request, so we can allocate the |patches| array on the stack.
    std::array<TraceBuffer::Patch, 1024> patches;  // Uninitialized.
    if (chunk.patches().size() > patches.size()) {
      PERFETTO_ELOG("Too many patches (%zu) batched in the same request",
                    patches.size());
      PERFETTO_DFATAL("Too many patches");
      patches_discarded_ += static_cast<uint64_t>(chunk.patches_size());
      continue;
    }

    size_t i = 0;
    for (const auto& patch : chunk.patches()) {
      const std::string& patch_data = patch.data();
      if (patch_data.size() != patches[i].data.size()) {
        PERFETTO_ELOG("Received patch from producer: %" PRIu16
                      " of unexpected size %zu",
                      producer_id_trusted, patch_data.size());
        patches_discarded_++;
        continue;
      }
      patches[i].offset_untrusted = patch.offset();
      memcpy(&patches[i].data[0], patch_data.data(), patches[i].data.size());
      i++;
    }
    buf->TryPatchChunkContents(producer_id_trusted, writer_id, chunk_id,
                               &patches[0], i, chunk.has_more_patches());
  }
}

TracingServiceImpl::TracingSession* TracingServiceImpl::GetDetachedSession(
    uid_t uid,
    const std::string& key) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  for (auto& kv : tracing_sessions_) {
    TracingSession* session = &kv.second;
    if (session->consumer_uid == uid && session->detach_key == key) {
      PERFETTO_DCHECK(session->consumer_maybe_null == nullptr);
      return session;
    }
  }
  return nullptr;
}

TracingServiceImpl::TracingSession* TracingServiceImpl::GetTracingSession(
    TracingSessionID tsid) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  auto it = tsid ? tracing_sessions_.find(tsid) : tracing_sessions_.end();
  if (it == tracing_sessions_.end())
    return nullptr;
  return &it->second;
}

ProducerID TracingServiceImpl::GetNextProducerID() {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  PERFETTO_CHECK(producers_.size() < kMaxProducerID);
  do {
    ++last_producer_id_;
  } while (producers_.count(last_producer_id_) || last_producer_id_ == 0);
  PERFETTO_DCHECK(last_producer_id_ > 0 && last_producer_id_ <= kMaxProducerID);
  return last_producer_id_;
}

TraceBuffer* TracingServiceImpl::GetBufferByID(BufferID buffer_id) {
  auto buf_iter = buffers_.find(buffer_id);
  if (buf_iter == buffers_.end())
    return nullptr;
  return &*buf_iter->second;
}

void TracingServiceImpl::OnStartTriggersTimeout(TracingSessionID tsid) {
  // Skip entirely the flush if the trace session doesn't exist anymore.
  // This is to prevent misleading error messages to be logged.
  //
  // if the trace has started from the trigger we rely on
  // the |stop_delay_ms| from the trigger so don't flush and
  // disable if we've moved beyond a CONFIGURED state
  auto* tracing_session_ptr = GetTracingSession(tsid);
  if (tracing_session_ptr &&
      tracing_session_ptr->state == TracingSession::CONFIGURED) {
    PERFETTO_DLOG("Disabling TracingSession %" PRIu64
                  " since no triggers activated.",
                  tsid);
    // No data should be returned from ReadBuffers() regardless of if we
    // call FreeBuffers() or DisableTracing(). This is because in
    // STOP_TRACING we need this promise in either case, and using
    // DisableTracing() allows a graceful shutdown. Consumers can follow
    // their normal path and check the buffers through ReadBuffers() and
    // the code won't hang because the tracing session will still be
    // alive just disabled.
    DisableTracing(tsid);
  }
}

void TracingServiceImpl::UpdateMemoryGuardrail() {
#if !PERFETTO_BUILDFLAG(PERFETTO_EMBEDDER_BUILD) && \
    !PERFETTO_BUILDFLAG(PERFETTO_OS_MACOSX)
  uint64_t total_buffer_bytes = 0;

  // Sum up all the shared memory buffers.
  for (const auto& id_to_producer : producers_) {
    if (id_to_producer.second->shared_memory())
      total_buffer_bytes += id_to_producer.second->shared_memory()->size();
  }

  // Sum up all the trace buffers.
  for (const auto& id_to_buffer : buffers_) {
    total_buffer_bytes += id_to_buffer.second->size();
  }

  // Set the guard rail to 32MB + the sum of all the buffers over a 30 second
  // interval.
  uint64_t guardrail = 32 * 1024 * 1024 + total_buffer_bytes;
  base::Watchdog::GetInstance()->SetMemoryLimit(guardrail, 30 * 1000);
#endif
}

void TracingServiceImpl::SnapshotSyncMarker(std::vector<TracePacket>* packets) {
  // The sync markes is used to tokenize large traces efficiently.
  // See description in trace_packet.proto.
  if (sync_marker_packet_size_ == 0) {
    // Serialize the marker and the uid separately to guarantee that the marker
    // is serialzied at the end and is adjacent to the start of the next packet.
    int size_left = static_cast<int>(sizeof(sync_marker_packet_));
    uint8_t* dst = &sync_marker_packet_[0];
    protos::TrustedPacket packet;
    packet.set_trusted_uid(static_cast<int32_t>(uid_));
    packet.set_trusted_packet_sequence_id(kServicePacketSequenceID);
    PERFETTO_CHECK(packet.SerializeToArray(dst, size_left));
    size_left -= packet.ByteSize();
    sync_marker_packet_size_ += static_cast<size_t>(packet.ByteSize());
    dst += sync_marker_packet_size_;

    packet.Clear();
    packet.set_synchronization_marker(kSyncMarker, sizeof(kSyncMarker));
    PERFETTO_CHECK(packet.SerializeToArray(dst, size_left));
    sync_marker_packet_size_ += static_cast<size_t>(packet.ByteSize());
    PERFETTO_CHECK(sync_marker_packet_size_ <= sizeof(sync_marker_packet_));
  }
  packets->emplace_back();
  packets->back().AddSlice(&sync_marker_packet_[0], sync_marker_packet_size_);
}

void TracingServiceImpl::SnapshotClocks(std::vector<TracePacket>* packets,
                                        bool set_root_timestamp) {
  protos::TrustedPacket packet;
  protos::ClockSnapshot* clock_snapshot = packet.mutable_clock_snapshot();

#if !PERFETTO_BUILDFLAG(PERFETTO_OS_MACOSX) && \
    !PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)
  struct {
    clockid_t id;
    protos::ClockSnapshot::Clock::Type type;
    struct timespec ts;
  } clocks[] = {
      {CLOCK_BOOTTIME, protos::ClockSnapshot::Clock::BOOTTIME, {0, 0}},
      {CLOCK_REALTIME_COARSE,
       protos::ClockSnapshot::Clock::REALTIME_COARSE,
       {0, 0}},
      {CLOCK_MONOTONIC_COARSE,
       protos::ClockSnapshot::Clock::MONOTONIC_COARSE,
       {0, 0}},
      {CLOCK_REALTIME, protos::ClockSnapshot::Clock::REALTIME, {0, 0}},
      {CLOCK_MONOTONIC, protos::ClockSnapshot::Clock::MONOTONIC, {0, 0}},
      {CLOCK_MONOTONIC_RAW,
       protos::ClockSnapshot::Clock::MONOTONIC_RAW,
       {0, 0}},
      {CLOCK_PROCESS_CPUTIME_ID,
       protos::ClockSnapshot::Clock::PROCESS_CPUTIME,
       {0, 0}},
      {CLOCK_THREAD_CPUTIME_ID,
       protos::ClockSnapshot::Clock::THREAD_CPUTIME,
       {0, 0}},
  };
  // First snapshot all the clocks as atomically as we can.
  for (auto& clock : clocks) {
    if (clock_gettime(clock.id, &clock.ts) == -1)
      PERFETTO_DLOG("clock_gettime failed for clock %d", clock.id);
  }
  for (auto& clock : clocks) {
    if (set_root_timestamp &&
        clock.type == protos::ClockSnapshot::Clock::BOOTTIME) {
      packet.set_timestamp(
          static_cast<uint64_t>(base::FromPosixTimespec(clock.ts).count()));
    }
    protos::ClockSnapshot::Clock* c = clock_snapshot->add_clocks();
    c->set_type(clock.type);
    c->set_timestamp(
        static_cast<uint64_t>(base::FromPosixTimespec(clock.ts).count()));
  }
#else   // !PERFETTO_BUILDFLAG(PERFETTO_OS_MACOSX)
  auto wall_time_ns = static_cast<uint64_t>(base::GetWallTimeNs().count());
  if (set_root_timestamp)
    packet.set_timestamp(wall_time_ns);
  protos::ClockSnapshot::Clock* c = clock_snapshot->add_clocks();
  c->set_type(protos::ClockSnapshot::Clock::MONOTONIC);
  c->set_timestamp(wall_time_ns);
#endif  // !PERFETTO_BUILDFLAG(PERFETTO_OS_MACOSX)

  packet.set_trusted_uid(static_cast<int32_t>(uid_));
  packet.set_trusted_packet_sequence_id(kServicePacketSequenceID);
  Slice slice = Slice::Allocate(static_cast<size_t>(packet.ByteSize()));
  PERFETTO_CHECK(packet.SerializeWithCachedSizesToArray(slice.own_data()));
  packets->emplace_back();
  packets->back().AddSlice(std::move(slice));
}

void TracingServiceImpl::SnapshotStats(TracingSession* tracing_session,
                                       std::vector<TracePacket>* packets) {
  protos::TrustedPacket packet;
  packet.set_trusted_uid(static_cast<int32_t>(uid_));
  packet.set_trusted_packet_sequence_id(kServicePacketSequenceID);

  protos::TraceStats* trace_stats = packet.mutable_trace_stats();
  GetTraceStats(tracing_session).ToProto(trace_stats);
  Slice slice = Slice::Allocate(static_cast<size_t>(packet.ByteSize()));
  PERFETTO_CHECK(packet.SerializeWithCachedSizesToArray(slice.own_data()));
  packets->emplace_back();
  packets->back().AddSlice(std::move(slice));
}

TraceStats TracingServiceImpl::GetTraceStats(TracingSession* tracing_session) {
  TraceStats trace_stats;
  trace_stats.set_producers_connected(static_cast<uint32_t>(producers_.size()));
  trace_stats.set_producers_seen(last_producer_id_);
  trace_stats.set_data_sources_registered(
      static_cast<uint32_t>(data_sources_.size()));
  trace_stats.set_data_sources_seen(last_data_source_instance_id_);
  trace_stats.set_tracing_sessions(
      static_cast<uint32_t>(tracing_sessions_.size()));
  trace_stats.set_total_buffers(static_cast<uint32_t>(buffers_.size()));
  trace_stats.set_chunks_discarded(chunks_discarded_);
  trace_stats.set_patches_discarded(patches_discarded_);

  for (BufferID buf_id : tracing_session->buffers_index) {
    TraceBuffer* buf = GetBufferByID(buf_id);
    if (!buf) {
      PERFETTO_DFATAL("Buffer not found.");
      continue;
    }
    *trace_stats.add_buffer_stats() = buf->stats();
  }  // for (buf in session).
  return trace_stats;
}

void TracingServiceImpl::MaybeEmitTraceConfig(
    TracingSession* tracing_session,
    std::vector<TracePacket>* packets) {
  if (tracing_session->did_emit_config)
    return;
  tracing_session->did_emit_config = true;
  protos::TrustedPacket packet;
  tracing_session->config.ToProto(packet.mutable_trace_config());
  packet.set_trusted_uid(static_cast<int32_t>(uid_));
  packet.set_trusted_packet_sequence_id(kServicePacketSequenceID);
  Slice slice = Slice::Allocate(static_cast<size_t>(packet.ByteSize()));
  PERFETTO_CHECK(packet.SerializeWithCachedSizesToArray(slice.own_data()));
  packets->emplace_back();
  packets->back().AddSlice(std::move(slice));
}

void TracingServiceImpl::MaybeEmitSystemInfo(
    TracingSession* tracing_session,
    std::vector<TracePacket>* packets) {
  if (tracing_session->did_emit_system_info)
    return;
  tracing_session->did_emit_system_info = true;
  protos::TrustedPacket packet;
#if !PERFETTO_BUILDFLAG(PERFETTO_OS_WIN)
  protos::SystemInfo* info = packet.mutable_system_info();
  struct utsname uname_info;
  if (uname(&uname_info) == 0) {
    protos::Utsname* utsname_info = info->mutable_utsname();
    utsname_info->set_sysname(uname_info.sysname);
    utsname_info->set_version(uname_info.version);
    utsname_info->set_machine(uname_info.machine);
    utsname_info->set_release(uname_info.release);
  }
#endif
  packet.set_trusted_uid(static_cast<int32_t>(uid_));
  packet.set_trusted_packet_sequence_id(kServicePacketSequenceID);
  Slice slice = Slice::Allocate(static_cast<size_t>(packet.ByteSize()));
  PERFETTO_CHECK(packet.SerializeWithCachedSizesToArray(slice.own_data()));
  packets->emplace_back();
  packets->back().AddSlice(std::move(slice));
}

void TracingServiceImpl::MaybeEmitReceivedTriggers(
    TracingSession* tracing_session,
    std::vector<TracePacket>* packets) {
  PERFETTO_DCHECK(tracing_session->num_triggers_emitted_into_trace <=
                  tracing_session->received_triggers.size());
  for (size_t i = tracing_session->num_triggers_emitted_into_trace;
       i < tracing_session->received_triggers.size(); ++i) {
    const auto& info = tracing_session->received_triggers[i];
    protos::TrustedPacket packet;

    protos::Trigger* trigger = packet.mutable_trigger();
    trigger->set_trigger_name(info.trigger_name);
    trigger->set_producer_name(info.producer_name);
    trigger->set_trusted_producer_uid(static_cast<int32_t>(info.producer_uid));

    packet.set_timestamp(info.boot_time_ns);
    packet.set_trusted_uid(static_cast<int32_t>(uid_));
    packet.set_trusted_packet_sequence_id(kServicePacketSequenceID);
    Slice slice = Slice::Allocate(static_cast<size_t>(packet.ByteSize()));
    PERFETTO_CHECK(packet.SerializeWithCachedSizesToArray(slice.own_data()));
    packets->emplace_back();
    packets->back().AddSlice(std::move(slice));
    ++tracing_session->num_triggers_emitted_into_trace;
  }
}

////////////////////////////////////////////////////////////////////////////////
// TracingServiceImpl::ConsumerEndpointImpl implementation
////////////////////////////////////////////////////////////////////////////////

TracingServiceImpl::ConsumerEndpointImpl::ConsumerEndpointImpl(
    TracingServiceImpl* service,
    base::TaskRunner* task_runner,
    Consumer* consumer,
    uid_t uid)
    : task_runner_(task_runner),
      service_(service),
      consumer_(consumer),
      uid_(uid),
      weak_ptr_factory_(this) {}

TracingServiceImpl::ConsumerEndpointImpl::~ConsumerEndpointImpl() {
  service_->DisconnectConsumer(this);
  consumer_->OnDisconnect();
}

void TracingServiceImpl::ConsumerEndpointImpl::NotifyOnTracingDisabled() {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  auto weak_this = GetWeakPtr();
  task_runner_->PostTask([weak_this] {
    if (weak_this)
      weak_this->consumer_->OnTracingDisabled();
  });
}

void TracingServiceImpl::ConsumerEndpointImpl::EnableTracing(
    const TraceConfig& cfg,
    base::ScopedFile fd) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  if (!service_->EnableTracing(this, cfg, std::move(fd)))
    NotifyOnTracingDisabled();
}

void TracingServiceImpl::ConsumerEndpointImpl::ChangeTraceConfig(
    const TraceConfig& cfg) {
  if (!tracing_session_id_) {
    PERFETTO_LOG(
        "Consumer called ChangeTraceConfig() but tracing was "
        "not active");
    return;
  }
  service_->ChangeTraceConfig(this, cfg);
}

void TracingServiceImpl::ConsumerEndpointImpl::StartTracing() {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  if (!tracing_session_id_) {
    PERFETTO_LOG("Consumer called StartTracing() but tracing was not active");
    return;
  }
  service_->StartTracing(tracing_session_id_);
}

void TracingServiceImpl::ConsumerEndpointImpl::DisableTracing() {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  if (!tracing_session_id_) {
    PERFETTO_LOG("Consumer called DisableTracing() but tracing was not active");
    return;
  }
  service_->DisableTracing(tracing_session_id_);
}

void TracingServiceImpl::ConsumerEndpointImpl::ReadBuffers() {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  if (!tracing_session_id_) {
    PERFETTO_LOG("Consumer called ReadBuffers() but tracing was not active");
    return;
  }
  service_->ReadBuffers(tracing_session_id_, this);
}

void TracingServiceImpl::ConsumerEndpointImpl::FreeBuffers() {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  if (!tracing_session_id_) {
    PERFETTO_LOG("Consumer called FreeBuffers() but tracing was not active");
    return;
  }
  service_->FreeBuffers(tracing_session_id_);
  tracing_session_id_ = 0;
}

void TracingServiceImpl::ConsumerEndpointImpl::Flush(uint32_t timeout_ms,
                                                     FlushCallback callback) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  if (!tracing_session_id_) {
    PERFETTO_LOG("Consumer called Flush() but tracing was not active");
    return;
  }
  service_->Flush(tracing_session_id_, timeout_ms, callback);
}

void TracingServiceImpl::ConsumerEndpointImpl::Detach(const std::string& key) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  bool success = service_->DetachConsumer(this, key);
  auto weak_this = GetWeakPtr();
  task_runner_->PostTask([weak_this, success] {
    if (weak_this)
      weak_this->consumer_->OnDetach(success);
  });
}

void TracingServiceImpl::ConsumerEndpointImpl::Attach(const std::string& key) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  bool success = service_->AttachConsumer(this, key);
  auto weak_this = GetWeakPtr();
  task_runner_->PostTask([weak_this, success] {
    if (!weak_this)
      return;
    Consumer* consumer = weak_this->consumer_;
    TracingSession* session =
        weak_this->service_->GetTracingSession(weak_this->tracing_session_id_);
    if (!session) {
      consumer->OnAttach(false, TraceConfig());
      return;
    }
    consumer->OnAttach(success, session->config);
  });
}

void TracingServiceImpl::ConsumerEndpointImpl::GetTraceStats() {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  bool success = false;
  TraceStats stats;
  TracingSession* session = service_->GetTracingSession(tracing_session_id_);
  if (session) {
    success = true;
    stats = service_->GetTraceStats(session);
  }
  auto weak_this = GetWeakPtr();
  task_runner_->PostTask([weak_this, success, stats] {
    if (weak_this)
      weak_this->consumer_->OnTraceStats(success, stats);
  });
}

void TracingServiceImpl::ConsumerEndpointImpl::ObserveEvents(
    uint32_t enabled_event_types) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  enabled_observable_event_types_ = enabled_event_types;

  if (enabled_observable_event_types_ == ObservableEventType::kNone)
    return;

  PERFETTO_DCHECK(enabled_observable_event_types_ ==
                  ObservableEventType::kDataSourceInstances);

  TracingSession* session = service_->GetTracingSession(tracing_session_id_);
  if (!session)
    return;

  // Issue initial states
  for (const auto& kv : session->data_source_instances) {
    ProducerEndpointImpl* producer = service_->GetProducer(kv.first);
    PERFETTO_DCHECK(producer);
    OnDataSourceInstanceStateChange(*producer, kv.second);
  }
}

void TracingServiceImpl::ConsumerEndpointImpl::OnDataSourceInstanceStateChange(
    const ProducerEndpointImpl& producer,
    const DataSourceInstance& instance) {
  if (!(enabled_observable_event_types_ &
        ObservableEventType::kDataSourceInstances)) {
    return;
  }

  if (instance.state != DataSourceInstance::CONFIGURED &&
      instance.state != DataSourceInstance::STARTED &&
      instance.state != DataSourceInstance::STOPPED) {
    return;
  }

  auto* observable_events = AddObservableEvents();
  auto* change = observable_events->add_instance_state_changes();
  change->set_producer_name(producer.name_);
  change->set_data_source_name(instance.data_source_name);
  if (instance.state == DataSourceInstance::STARTED) {
    change->set_state(ObservableEvents::DataSourceInstanceStateChange::
                          DATA_SOURCE_INSTANCE_STATE_STARTED);
  } else {
    change->set_state(ObservableEvents::DataSourceInstanceStateChange::
                          DATA_SOURCE_INSTANCE_STATE_STOPPED);
  }
}

base::WeakPtr<TracingServiceImpl::ConsumerEndpointImpl>
TracingServiceImpl::ConsumerEndpointImpl::GetWeakPtr() {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  return weak_ptr_factory_.GetWeakPtr();
}

ObservableEvents*
TracingServiceImpl::ConsumerEndpointImpl::AddObservableEvents() {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  if (!observable_events_) {
    observable_events_.reset(new ObservableEvents());
    auto weak_this = GetWeakPtr();
    task_runner_->PostTask([weak_this] {
      if (!weak_this)
        return;

      // Move into a temporary to allow reentrancy in OnObservableEvents.
      auto observable_events = std::move(weak_this->observable_events_);
      weak_this->consumer_->OnObservableEvents(*observable_events);
    });
  }
  return observable_events_.get();
}

void TracingServiceImpl::ConsumerEndpointImpl::QueryServiceState(
    QueryServiceStateCallback callback) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  TracingServiceState svc_state;

  const auto& sessions = service_->tracing_sessions_;
  svc_state.set_num_sessions(static_cast<int>(sessions.size()));

  int num_started = 0;
  for (const auto& kv : sessions)
    num_started += kv.second.state == TracingSession::State::STARTED ? 1 : 0;
  svc_state.set_num_sessions_started(static_cast<int>(num_started));

  for (const auto& kv : service_->producers_) {
    auto* producer = svc_state.add_producers();
    producer->set_id(static_cast<int>(kv.first));
    producer->set_name(kv.second->name_);
    producer->set_uid(static_cast<int32_t>(producer->uid()));
  }

  for (const auto& kv : service_->data_sources_) {
    const auto& registered_data_source = kv.second;
    auto* data_source = svc_state.add_data_sources();
    *data_source->mutable_ds_descriptor() = registered_data_source.descriptor;
    data_source->set_producer_id(
        static_cast<int>(registered_data_source.producer_id));
  }
  callback(/*success=*/true, svc_state);
}

////////////////////////////////////////////////////////////////////////////////
// TracingServiceImpl::ProducerEndpointImpl implementation
////////////////////////////////////////////////////////////////////////////////

TracingServiceImpl::ProducerEndpointImpl::ProducerEndpointImpl(
    ProducerID id,
    uid_t uid,
    TracingServiceImpl* service,
    base::TaskRunner* task_runner,
    Producer* producer,
    const std::string& producer_name,
    bool in_process,
    bool smb_scraping_enabled)
    : id_(id),
      uid_(uid),
      service_(service),
      task_runner_(task_runner),
      producer_(producer),
      name_(producer_name),
      in_process_(in_process),
      smb_scraping_enabled_(smb_scraping_enabled),
      weak_ptr_factory_(this) {}

TracingServiceImpl::ProducerEndpointImpl::~ProducerEndpointImpl() {
  service_->DisconnectProducer(id_);
  producer_->OnDisconnect();
}

void TracingServiceImpl::ProducerEndpointImpl::RegisterDataSource(
    const DataSourceDescriptor& desc) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  if (desc.name().empty()) {
    PERFETTO_DLOG("Received RegisterDataSource() with empty name");
    return;
  }

  service_->RegisterDataSource(id_, desc);
}

void TracingServiceImpl::ProducerEndpointImpl::UnregisterDataSource(
    const std::string& name) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  service_->UnregisterDataSource(id_, name);
}

void TracingServiceImpl::ProducerEndpointImpl::RegisterTraceWriter(
    uint32_t writer_id,
    uint32_t target_buffer) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  PERFETTO_DCHECK(!buffer_id_for_writer(static_cast<WriterID>(writer_id)));
  writers_[static_cast<WriterID>(writer_id)] =
      static_cast<BufferID>(target_buffer);
}

void TracingServiceImpl::ProducerEndpointImpl::UnregisterTraceWriter(
    uint32_t writer_id) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  PERFETTO_DCHECK(buffer_id_for_writer(static_cast<WriterID>(writer_id)));
  writers_.erase(static_cast<WriterID>(writer_id));
}

void TracingServiceImpl::ProducerEndpointImpl::CommitData(
    const CommitDataRequest& req_untrusted,
    CommitDataCallback callback) {
  PERFETTO_DCHECK_THREAD(thread_checker_);

  if (!shared_memory_) {
    PERFETTO_DLOG(
        "Attempted to commit data before the shared memory was allocated.");
    return;
  }
  PERFETTO_DCHECK(shmem_abi_.is_valid());
  for (const auto& entry : req_untrusted.chunks_to_move()) {
    const uint32_t page_idx = entry.page();
    if (page_idx >= shmem_abi_.num_pages())
      continue;  // A buggy or malicious producer.

    SharedMemoryABI::Chunk chunk =
        shmem_abi_.TryAcquireChunkForReading(page_idx, entry.chunk());
    if (!chunk.is_valid()) {
      PERFETTO_DLOG("Asked to move chunk %d:%d, but it's not complete",
                    entry.page(), entry.chunk());
      continue;
    }

    // TryAcquireChunkForReading() has load-acquire semantics. Once acquired,
    // the ABI contract expects the producer to not touch the chunk anymore
    // (until the service marks that as free). This is why all the reads below
    // are just memory_order_relaxed. Also, the code here assumes that all this
    // data can be malicious and just gives up if anything is malformed.
    BufferID buffer_id = static_cast<BufferID>(entry.target_buffer());
    const SharedMemoryABI::ChunkHeader& chunk_header = *chunk.header();
    WriterID writer_id = chunk_header.writer_id.load(std::memory_order_relaxed);
    ChunkID chunk_id = chunk_header.chunk_id.load(std::memory_order_relaxed);
    auto packets = chunk_header.packets.load(std::memory_order_relaxed);
    uint16_t num_fragments = packets.count;
    uint8_t chunk_flags = packets.flags;

    service_->CopyProducerPageIntoLogBuffer(
        id_, uid_, writer_id, chunk_id, buffer_id, num_fragments, chunk_flags,
        /*chunk_complete=*/true, chunk.payload_begin(), chunk.payload_size());

    // This one has release-store semantics.
    shmem_abi_.ReleaseChunkAsFree(std::move(chunk));
  }  // for(chunks_to_move)

  service_->ApplyChunkPatches(id_, req_untrusted.chunks_to_patch());

  if (req_untrusted.flush_request_id()) {
    service_->NotifyFlushDoneForProducer(id_, req_untrusted.flush_request_id());
  }

  // Keep this invocation last. ProducerIPCService::CommitData() relies on this
  // callback being invoked within the same callstack and not posted. If this
  // changes, the code there needs to be changed accordingly.
  if (callback)
    callback();
}

void TracingServiceImpl::ProducerEndpointImpl::SetSharedMemory(
    std::unique_ptr<SharedMemory> shared_memory) {
  PERFETTO_DCHECK(!shared_memory_ && !shmem_abi_.is_valid());
  shared_memory_ = std::move(shared_memory);
  shmem_abi_.Initialize(reinterpret_cast<uint8_t*>(shared_memory_->start()),
                        shared_memory_->size(),
                        shared_buffer_page_size_kb() * 1024);
  if (in_process_) {
    inproc_shmem_arbiter_.reset(new SharedMemoryArbiterImpl(
        shared_memory_->start(), shared_memory_->size(),
        shared_buffer_page_size_kb_ * 1024, this, task_runner_));
  }
}

SharedMemory* TracingServiceImpl::ProducerEndpointImpl::shared_memory() const {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  return shared_memory_.get();
}

size_t TracingServiceImpl::ProducerEndpointImpl::shared_buffer_page_size_kb()
    const {
  return shared_buffer_page_size_kb_;
}

void TracingServiceImpl::ProducerEndpointImpl::ActivateTriggers(
    const std::vector<std::string>& triggers) {
  service_->ActivateTriggers(id_, triggers);
}

void TracingServiceImpl::ProducerEndpointImpl::StopDataSource(
    DataSourceInstanceID ds_inst_id) {
  // TODO(primiano): When we'll support tearing down the SMB, at this point we
  // should send the Producer a TearDownTracing if all its data sources have
  // been disabled (see b/77532839 and aosp/655179 PS1).
  PERFETTO_DCHECK_THREAD(thread_checker_);
  auto weak_this = weak_ptr_factory_.GetWeakPtr();
  task_runner_->PostTask([weak_this, ds_inst_id] {
    if (weak_this)
      weak_this->producer_->StopDataSource(ds_inst_id);
  });
}

SharedMemoryArbiter*
TracingServiceImpl::ProducerEndpointImpl::GetInProcessShmemArbiter() {
  if (!inproc_shmem_arbiter_) {
    PERFETTO_FATAL(
        "The in-process SharedMemoryArbiter can only be used when "
        "CreateProducer has been called with in_process=true and after tracing "
        "has started.");
  }

  PERFETTO_DCHECK(in_process_);
  return inproc_shmem_arbiter_.get();
}

// Can be called on any thread.
std::unique_ptr<TraceWriter>
TracingServiceImpl::ProducerEndpointImpl::CreateTraceWriter(BufferID buf_id) {
  return GetInProcessShmemArbiter()->CreateTraceWriter(buf_id);
}

void TracingServiceImpl::ProducerEndpointImpl::NotifyFlushComplete(
    FlushRequestID id) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  return GetInProcessShmemArbiter()->NotifyFlushComplete(id);
}

void TracingServiceImpl::ProducerEndpointImpl::OnTracingSetup() {
  auto weak_this = weak_ptr_factory_.GetWeakPtr();
  task_runner_->PostTask([weak_this] {
    if (weak_this)
      weak_this->producer_->OnTracingSetup();
  });
}

void TracingServiceImpl::ProducerEndpointImpl::Flush(
    FlushRequestID flush_request_id,
    const std::vector<DataSourceInstanceID>& data_sources) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  auto weak_this = weak_ptr_factory_.GetWeakPtr();
  task_runner_->PostTask([weak_this, flush_request_id, data_sources] {
    if (weak_this) {
      weak_this->producer_->Flush(flush_request_id, data_sources.data(),
                                  data_sources.size());
    }
  });
}

void TracingServiceImpl::ProducerEndpointImpl::SetupDataSource(
    DataSourceInstanceID ds_id,
    const DataSourceConfig& config) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  allowed_target_buffers_.insert(static_cast<BufferID>(config.target_buffer()));
  auto weak_this = weak_ptr_factory_.GetWeakPtr();
  task_runner_->PostTask([weak_this, ds_id, config] {
    if (weak_this)
      weak_this->producer_->SetupDataSource(ds_id, std::move(config));
  });
}

void TracingServiceImpl::ProducerEndpointImpl::StartDataSource(
    DataSourceInstanceID ds_id,
    const DataSourceConfig& config) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  auto weak_this = weak_ptr_factory_.GetWeakPtr();
  task_runner_->PostTask([weak_this, ds_id, config] {
    if (weak_this)
      weak_this->producer_->StartDataSource(ds_id, std::move(config));
  });
}

void TracingServiceImpl::ProducerEndpointImpl::NotifyDataSourceStarted(
    DataSourceInstanceID data_source_id) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  service_->NotifyDataSourceStarted(id_, data_source_id);
}

void TracingServiceImpl::ProducerEndpointImpl::NotifyDataSourceStopped(
    DataSourceInstanceID data_source_id) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  service_->NotifyDataSourceStopped(id_, data_source_id);
}

void TracingServiceImpl::ProducerEndpointImpl::OnFreeBuffers(
    const std::vector<BufferID>& target_buffers) {
  if (allowed_target_buffers_.empty())
    return;
  for (BufferID buffer : target_buffers)
    allowed_target_buffers_.erase(buffer);
}

void TracingServiceImpl::ProducerEndpointImpl::ClearIncrementalState(
    const std::vector<DataSourceInstanceID>& data_sources) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  auto weak_this = weak_ptr_factory_.GetWeakPtr();
  task_runner_->PostTask([weak_this, data_sources] {
    if (weak_this) {
      weak_this->producer_->ClearIncrementalState(data_sources.data(),
                                                  data_sources.size());
    }
  });
}

////////////////////////////////////////////////////////////////////////////////
// TracingServiceImpl::TracingSession implementation
////////////////////////////////////////////////////////////////////////////////

TracingServiceImpl::TracingSession::TracingSession(
    TracingSessionID session_id,
    ConsumerEndpointImpl* consumer,
    const TraceConfig& new_config)
    : id(session_id),
      consumer_maybe_null(consumer),
      consumer_uid(consumer->uid_),
      config(new_config) {}

}  // namespace perfetto
// gen_amalgamated begin source: src/tracing/core/tracing_service_state.cc
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*******************************************************************************
 * AUTOGENERATED - DO NOT EDIT
 *******************************************************************************
 * This file has been generated from the protobuf message
 * perfetto/common/tracing_service_state.proto
 * by
 * ../../tools/proto_to_cpp/proto_to_cpp.cc.
 * If you need to make changes here, change the .proto file and then run
 * ./tools/gen_tracing_cpp_headers_from_protos
 */

// gen_amalgamated expanded: #include "perfetto/tracing/core/tracing_service_state.h"

// gen_amalgamated expanded: #include "perfetto/common/tracing_service_state.pb.h"

// gen_amalgamated expanded: #include "perfetto/common/data_source_descriptor.pb.h"
// gen_amalgamated expanded: #include "perfetto/tracing/core/data_source_descriptor.h"

namespace perfetto {

TracingServiceState::TracingServiceState() = default;
TracingServiceState::~TracingServiceState() = default;
TracingServiceState::TracingServiceState(const TracingServiceState&) = default;
TracingServiceState& TracingServiceState::operator=(
    const TracingServiceState&) = default;
TracingServiceState::TracingServiceState(TracingServiceState&&) noexcept =
    default;
TracingServiceState& TracingServiceState::operator=(TracingServiceState&&) =
    default;

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
bool TracingServiceState::operator==(const TracingServiceState& other) const {
  return (producers_ == other.producers_) &&
         (data_sources_ == other.data_sources_) &&
         (num_sessions_ == other.num_sessions_) &&
         (num_sessions_started_ == other.num_sessions_started_);
}
#pragma GCC diagnostic pop

void TracingServiceState::ParseRawProto(const std::string& raw) {
  perfetto::protos::TracingServiceState proto;
  proto.ParseFromString(raw);
  FromProto(proto);
}

void TracingServiceState::FromProto(
    const perfetto::protos::TracingServiceState& proto) {
  producers_.clear();
  for (const auto& field : proto.producers()) {
    producers_.emplace_back();
    producers_.back().FromProto(field);
  }

  data_sources_.clear();
  for (const auto& field : proto.data_sources()) {
    data_sources_.emplace_back();
    data_sources_.back().FromProto(field);
  }

  static_assert(sizeof(num_sessions_) == sizeof(proto.num_sessions()),
                "size mismatch");
  num_sessions_ = static_cast<decltype(num_sessions_)>(proto.num_sessions());

  static_assert(
      sizeof(num_sessions_started_) == sizeof(proto.num_sessions_started()),
      "size mismatch");
  num_sessions_started_ = static_cast<decltype(num_sessions_started_)>(
      proto.num_sessions_started());
  unknown_fields_ = proto.unknown_fields();
}

void TracingServiceState::ToProto(
    perfetto::protos::TracingServiceState* proto) const {
  proto->Clear();

  for (const auto& it : producers_) {
    auto* entry = proto->add_producers();
    it.ToProto(entry);
  }

  for (const auto& it : data_sources_) {
    auto* entry = proto->add_data_sources();
    it.ToProto(entry);
  }

  static_assert(sizeof(num_sessions_) == sizeof(proto->num_sessions()),
                "size mismatch");
  proto->set_num_sessions(
      static_cast<decltype(proto->num_sessions())>(num_sessions_));

  static_assert(
      sizeof(num_sessions_started_) == sizeof(proto->num_sessions_started()),
      "size mismatch");
  proto->set_num_sessions_started(
      static_cast<decltype(proto->num_sessions_started())>(
          num_sessions_started_));
  *(proto->mutable_unknown_fields()) = unknown_fields_;
}

TracingServiceState::Producer::Producer() = default;
TracingServiceState::Producer::~Producer() = default;
TracingServiceState::Producer::Producer(const TracingServiceState::Producer&) =
    default;
TracingServiceState::Producer& TracingServiceState::Producer::operator=(
    const TracingServiceState::Producer&) = default;
TracingServiceState::Producer::Producer(
    TracingServiceState::Producer&&) noexcept = default;
TracingServiceState::Producer& TracingServiceState::Producer::operator=(
    TracingServiceState::Producer&&) = default;

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
bool TracingServiceState::Producer::operator==(
    const TracingServiceState::Producer& other) const {
  return (id_ == other.id_) && (name_ == other.name_) && (uid_ == other.uid_);
}
#pragma GCC diagnostic pop

void TracingServiceState::Producer::ParseRawProto(const std::string& raw) {
  perfetto::protos::TracingServiceState_Producer proto;
  proto.ParseFromString(raw);
  FromProto(proto);
}

void TracingServiceState::Producer::FromProto(
    const perfetto::protos::TracingServiceState_Producer& proto) {
  static_assert(sizeof(id_) == sizeof(proto.id()), "size mismatch");
  id_ = static_cast<decltype(id_)>(proto.id());

  static_assert(sizeof(name_) == sizeof(proto.name()), "size mismatch");
  name_ = static_cast<decltype(name_)>(proto.name());

  static_assert(sizeof(uid_) == sizeof(proto.uid()), "size mismatch");
  uid_ = static_cast<decltype(uid_)>(proto.uid());
  unknown_fields_ = proto.unknown_fields();
}

void TracingServiceState::Producer::ToProto(
    perfetto::protos::TracingServiceState_Producer* proto) const {
  proto->Clear();

  static_assert(sizeof(id_) == sizeof(proto->id()), "size mismatch");
  proto->set_id(static_cast<decltype(proto->id())>(id_));

  static_assert(sizeof(name_) == sizeof(proto->name()), "size mismatch");
  proto->set_name(static_cast<decltype(proto->name())>(name_));

  static_assert(sizeof(uid_) == sizeof(proto->uid()), "size mismatch");
  proto->set_uid(static_cast<decltype(proto->uid())>(uid_));
  *(proto->mutable_unknown_fields()) = unknown_fields_;
}

TracingServiceState::DataSource::DataSource() = default;
TracingServiceState::DataSource::~DataSource() = default;
TracingServiceState::DataSource::DataSource(
    const TracingServiceState::DataSource&) = default;
TracingServiceState::DataSource& TracingServiceState::DataSource::operator=(
    const TracingServiceState::DataSource&) = default;
TracingServiceState::DataSource::DataSource(
    TracingServiceState::DataSource&&) noexcept = default;
TracingServiceState::DataSource& TracingServiceState::DataSource::operator=(
    TracingServiceState::DataSource&&) = default;

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"
bool TracingServiceState::DataSource::operator==(
    const TracingServiceState::DataSource& other) const {
  return (ds_descriptor_ == other.ds_descriptor_) &&
         (producer_id_ == other.producer_id_);
}
#pragma GCC diagnostic pop

void TracingServiceState::DataSource::ParseRawProto(const std::string& raw) {
  perfetto::protos::TracingServiceState_DataSource proto;
  proto.ParseFromString(raw);
  FromProto(proto);
}

void TracingServiceState::DataSource::FromProto(
    const perfetto::protos::TracingServiceState_DataSource& proto) {
  ds_descriptor_->FromProto(proto.ds_descriptor());

  static_assert(sizeof(producer_id_) == sizeof(proto.producer_id()),
                "size mismatch");
  producer_id_ = static_cast<decltype(producer_id_)>(proto.producer_id());
  unknown_fields_ = proto.unknown_fields();
}

void TracingServiceState::DataSource::ToProto(
    perfetto::protos::TracingServiceState_DataSource* proto) const {
  proto->Clear();

  ds_descriptor_->ToProto(proto->mutable_ds_descriptor());

  static_assert(sizeof(producer_id_) == sizeof(proto->producer_id()),
                "size mismatch");
  proto->set_producer_id(
      static_cast<decltype(proto->producer_id())>(producer_id_));
  *(proto->mutable_unknown_fields()) = unknown_fields_;
}

}  // namespace perfetto
// gen_amalgamated begin source: src/tracing/core/virtual_destructors.cc
/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/consumer.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/producer.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/shared_memory.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/shared_memory_arbiter.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/tracing_service.h"

// This translation unit contains the definitions for the destructor of pure
// virtual interfaces for the current build target. The alternative would be
// introducing a one-liner .cc file for each pure virtual interface, which is
// overkill. This is for compliance with -Wweak-vtables.

namespace perfetto {

Consumer::~Consumer() = default;
Producer::~Producer() = default;
TracingService::~TracingService() = default;
TracingService::ConsumerEndpoint::~ConsumerEndpoint() = default;
TracingService::ProducerEndpoint::~ProducerEndpoint() = default;
SharedMemory::~SharedMemory() = default;
SharedMemory::Factory::~Factory() = default;
SharedMemoryArbiter::~SharedMemoryArbiter() = default;

}  // namespace perfetto
// gen_amalgamated begin source: src/tracing/ipc/consumer/consumer_ipc_client_impl.cc
// gen_amalgamated begin header: src/tracing/ipc/consumer/consumer_ipc_client_impl.h
// gen_amalgamated begin header: include/perfetto/ext/tracing/ipc/consumer_ipc_client.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_TRACING_IPC_CONSUMER_IPC_CLIENT_H_
#define INCLUDE_PERFETTO_EXT_TRACING_IPC_CONSUMER_IPC_CLIENT_H_

#include <memory>
#include <string>

// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/tracing_service.h"

namespace perfetto {

class Consumer;

// Allows to connect to a remote Service through a UNIX domain socket.
// Exposed to:
//   Consumer(s) of the tracing library.
// Implemented in:
//   src/tracing/ipc/consumer/consumer_ipc_client_impl.cc
class ConsumerIPCClient {
 public:
  // Connects to the producer port of the Service listening on the given
  // |service_sock_name|. If the connection is successful, the OnConnect()
  // method will be invoked asynchronously on the passed Consumer interface.
  // If the connection fails, OnDisconnect() will be invoked instead.
  // The returned ConsumerEndpoint serves also to delimit the scope of the
  // callbacks invoked on the Consumer interface: no more Consumer callbacks are
  // invoked immediately after its destruction and any pending callback will be
  // dropped.
  static std::unique_ptr<TracingService::ConsumerEndpoint>
  Connect(const char* service_sock_name, Consumer*, base::TaskRunner*);

 protected:
  ConsumerIPCClient() = delete;
};

}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_TRACING_IPC_CONSUMER_IPC_CLIENT_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef SRC_TRACING_IPC_CONSUMER_CONSUMER_IPC_CLIENT_IMPL_H_
#define SRC_TRACING_IPC_CONSUMER_CONSUMER_IPC_CLIENT_IMPL_H_

#include <stdint.h>

#include <vector>

// gen_amalgamated expanded: #include "perfetto/ext/base/scoped_file.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/weak_ptr.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/service_proxy.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/basic_types.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/trace_packet.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/tracing_service.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/ipc/consumer_ipc_client.h"

// gen_amalgamated expanded: #include "perfetto/ipc/consumer_port.ipc.h"

namespace perfetto {

namespace base {
class TaskRunner;
}  // namespace base

namespace ipc {
class Client;
}  // namespace ipc

class Consumer;
class TraceConfig;

// Exposes a Service endpoint to Consumer(s), proxying all requests through a
// IPC channel to the remote Service. This class is the glue layer between the
// generic Service interface exposed to the clients of the library and the
// actual IPC transport.
class ConsumerIPCClientImpl : public TracingService::ConsumerEndpoint,
                              public ipc::ServiceProxy::EventListener {
 public:
  ConsumerIPCClientImpl(const char* service_sock_name,
                        Consumer*,
                        base::TaskRunner*);
  ~ConsumerIPCClientImpl() override;

  // TracingService::ConsumerEndpoint implementation.
  // These methods are invoked by the actual Consumer(s) code by clients of the
  // tracing library, which know nothing about the IPC transport.
  void EnableTracing(const TraceConfig&, base::ScopedFile) override;
  void StartTracing() override;
  void ChangeTraceConfig(const TraceConfig&) override;
  void DisableTracing() override;
  void ReadBuffers() override;
  void FreeBuffers() override;
  void Flush(uint32_t timeout_ms, FlushCallback) override;
  void Detach(const std::string& key) override;
  void Attach(const std::string& key) override;
  void GetTraceStats() override;
  void ObserveEvents(uint32_t enabled_event_types) override;
  void QueryServiceState(QueryServiceStateCallback) override;

  // ipc::ServiceProxy::EventListener implementation.
  // These methods are invoked by the IPC layer, which knows nothing about
  // tracing, consumers and consumers.
  void OnConnect() override;
  void OnDisconnect() override;

 private:
  void OnReadBuffersResponse(ipc::AsyncResult<protos::ReadBuffersResponse>);
  void OnEnableTracingResponse(ipc::AsyncResult<protos::EnableTracingResponse>);

  // TODO(primiano): think to dtor order, do we rely on any specific sequence?
  Consumer* const consumer_;

  // The object that owns the client socket and takes care of IPC traffic.
  std::unique_ptr<ipc::Client> ipc_channel_;

  // The proxy interface for the consumer port of the service. It is bound
  // to |ipc_channel_| and (de)serializes method invocations over the wire.
  protos::ConsumerPortProxy consumer_port_;

  bool connected_ = false;

  // When a packet is too big to fit into a ReadBuffersResponse IPC, the service
  // will chunk it into several IPCs, each containing few slices of the packet
  // (a packet's slice is always guaranteed to be << kIPCBufferSize). When
  // chunking happens this field accumulates the slices received until the
  // one with |last_slice_for_packet| == true is received.
  TracePacket partial_packet_;

  // Keep last.
  base::WeakPtrFactory<ConsumerIPCClientImpl> weak_ptr_factory_;
};

}  // namespace perfetto

#endif  // SRC_TRACING_IPC_CONSUMER_CONSUMER_IPC_CLIENT_IMPL_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "src/tracing/ipc/consumer/consumer_ipc_client_impl.h"

#include <inttypes.h>
#include <string.h>

// gen_amalgamated expanded: #include "perfetto/base/task_runner.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/client.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/consumer.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/observable_events.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/trace_stats.h"
// gen_amalgamated expanded: #include "perfetto/tracing/core/trace_config.h"
// gen_amalgamated expanded: #include "perfetto/tracing/core/tracing_service_state.h"

// TODO(fmayer): Add a test to check to what happens when ConsumerIPCClientImpl
// gets destroyed w.r.t. the Consumer pointer. Also think to lifetime of the
// Consumer* during the callbacks.

namespace perfetto {

// static. (Declared in include/tracing/ipc/consumer_ipc_client.h).
std::unique_ptr<TracingService::ConsumerEndpoint> ConsumerIPCClient::Connect(
    const char* service_sock_name,
    Consumer* consumer,
    base::TaskRunner* task_runner) {
  return std::unique_ptr<TracingService::ConsumerEndpoint>(
      new ConsumerIPCClientImpl(service_sock_name, consumer, task_runner));
}

ConsumerIPCClientImpl::ConsumerIPCClientImpl(const char* service_sock_name,
                                             Consumer* consumer,
                                             base::TaskRunner* task_runner)
    : consumer_(consumer),
      ipc_channel_(ipc::Client::CreateInstance(service_sock_name, task_runner)),
      consumer_port_(this /* event_listener */),
      weak_ptr_factory_(this) {
  ipc_channel_->BindService(consumer_port_.GetWeakPtr());
}

ConsumerIPCClientImpl::~ConsumerIPCClientImpl() = default;

// Called by the IPC layer if the BindService() succeeds.
void ConsumerIPCClientImpl::OnConnect() {
  connected_ = true;
  consumer_->OnConnect();
}

void ConsumerIPCClientImpl::OnDisconnect() {
  PERFETTO_DLOG("Tracing service connection failure");
  connected_ = false;
  consumer_->OnDisconnect();
}

void ConsumerIPCClientImpl::EnableTracing(const TraceConfig& trace_config,
                                          base::ScopedFile fd) {
  if (!connected_) {
    PERFETTO_DLOG("Cannot EnableTracing(), not connected to tracing service");
    return;
  }

  protos::EnableTracingRequest req;
  trace_config.ToProto(req.mutable_trace_config());
  ipc::Deferred<protos::EnableTracingResponse> async_response;
  auto weak_this = weak_ptr_factory_.GetWeakPtr();
  async_response.Bind(
      [weak_this](ipc::AsyncResult<protos::EnableTracingResponse> response) {
        if (weak_this)
          weak_this->OnEnableTracingResponse(std::move(response));
      });

  // |fd| will be closed when this function returns, but it's fine because the
  // IPC layer dup()'s it when sending the IPC.
  consumer_port_.EnableTracing(req, std::move(async_response), *fd);
}

void ConsumerIPCClientImpl::ChangeTraceConfig(const TraceConfig&) {
  if (!connected_) {
    PERFETTO_DLOG(
        "Cannot ChangeTraceConfig(), not connected to tracing service");
    return;
  }

  ipc::Deferred<protos::ChangeTraceConfigResponse> async_response;
  async_response.Bind(
      [](ipc::AsyncResult<protos::ChangeTraceConfigResponse> response) {
        if (!response)
          PERFETTO_DLOG("ChangeTraceConfig() failed");
      });
  protos::ChangeTraceConfigRequest req;
  consumer_port_.ChangeTraceConfig(req, std::move(async_response));
}

void ConsumerIPCClientImpl::StartTracing() {
  if (!connected_) {
    PERFETTO_DLOG("Cannot StartTracing(), not connected to tracing service");
    return;
  }

  ipc::Deferred<protos::StartTracingResponse> async_response;
  async_response.Bind(
      [](ipc::AsyncResult<protos::StartTracingResponse> response) {
        if (!response)
          PERFETTO_DLOG("StartTracing() failed");
      });
  protos::StartTracingRequest req;
  consumer_port_.StartTracing(req, std::move(async_response));
}

void ConsumerIPCClientImpl::DisableTracing() {
  if (!connected_) {
    PERFETTO_DLOG("Cannot DisableTracing(), not connected to tracing service");
    return;
  }

  ipc::Deferred<protos::DisableTracingResponse> async_response;
  async_response.Bind(
      [](ipc::AsyncResult<protos::DisableTracingResponse> response) {
        if (!response)
          PERFETTO_DLOG("DisableTracing() failed");
      });
  consumer_port_.DisableTracing(protos::DisableTracingRequest(),
                                std::move(async_response));
}

void ConsumerIPCClientImpl::ReadBuffers() {
  if (!connected_) {
    PERFETTO_DLOG("Cannot ReadBuffers(), not connected to tracing service");
    return;
  }

  ipc::Deferred<protos::ReadBuffersResponse> async_response;

  // The IPC layer guarantees that callbacks are destroyed after this object
  // is destroyed (by virtue of destroying the |consumer_port_|). In turn the
  // contract of this class expects the caller to not destroy the Consumer class
  // before having destroyed this class. Hence binding |this| here is safe.
  async_response.Bind(
      [this](ipc::AsyncResult<protos::ReadBuffersResponse> response) {
        OnReadBuffersResponse(std::move(response));
      });
  consumer_port_.ReadBuffers(protos::ReadBuffersRequest(),
                             std::move(async_response));
}

void ConsumerIPCClientImpl::OnReadBuffersResponse(
    ipc::AsyncResult<protos::ReadBuffersResponse> response) {
  if (!response) {
    PERFETTO_DLOG("ReadBuffers() failed");
    return;
  }
  std::vector<TracePacket> trace_packets;
  for (auto& resp_slice : *response->mutable_slices()) {
    partial_packet_.AddSlice(
        Slice(std::unique_ptr<std::string>(resp_slice.release_data())));
    if (resp_slice.last_slice_for_packet())
      trace_packets.emplace_back(std::move(partial_packet_));
  }
  if (!trace_packets.empty() || !response.has_more())
    consumer_->OnTraceData(std::move(trace_packets), response.has_more());
}

void ConsumerIPCClientImpl::OnEnableTracingResponse(
    ipc::AsyncResult<protos::EnableTracingResponse> response) {
  if (!response || response->disabled())
    consumer_->OnTracingDisabled();
}

void ConsumerIPCClientImpl::FreeBuffers() {
  if (!connected_) {
    PERFETTO_DLOG("Cannot FreeBuffers(), not connected to tracing service");
    return;
  }

  protos::FreeBuffersRequest req;
  ipc::Deferred<protos::FreeBuffersResponse> async_response;
  async_response.Bind(
      [](ipc::AsyncResult<protos::FreeBuffersResponse> response) {
        if (!response)
          PERFETTO_DLOG("FreeBuffers() failed");
      });
  consumer_port_.FreeBuffers(req, std::move(async_response));
}

void ConsumerIPCClientImpl::Flush(uint32_t timeout_ms, FlushCallback callback) {
  if (!connected_) {
    PERFETTO_DLOG("Cannot Flush(), not connected to tracing service");
    return callback(/*success=*/false);
  }

  protos::FlushRequest req;
  req.set_timeout_ms(static_cast<uint32_t>(timeout_ms));
  ipc::Deferred<protos::FlushResponse> async_response;
  async_response.Bind(
      [callback](ipc::AsyncResult<protos::FlushResponse> response) {
        callback(!!response);
      });
  consumer_port_.Flush(req, std::move(async_response));
}

void ConsumerIPCClientImpl::Detach(const std::string& key) {
  if (!connected_) {
    PERFETTO_DLOG("Cannot Detach(), not connected to tracing service");
    return;
  }

  protos::DetachRequest req;
  req.set_key(key);
  ipc::Deferred<protos::DetachResponse> async_response;
  auto weak_this = weak_ptr_factory_.GetWeakPtr();

  async_response.Bind(
      [weak_this](ipc::AsyncResult<protos::DetachResponse> response) {
        if (weak_this)
          weak_this->consumer_->OnDetach(!!response);
      });
  consumer_port_.Detach(req, std::move(async_response));
}

void ConsumerIPCClientImpl::Attach(const std::string& key) {
  if (!connected_) {
    PERFETTO_DLOG("Cannot Attach(), not connected to tracing service");
    return;
  }

  {
    protos::AttachRequest req;
    req.set_key(key);
    ipc::Deferred<protos::AttachResponse> async_response;
    auto weak_this = weak_ptr_factory_.GetWeakPtr();

    async_response.Bind([weak_this](
                            ipc::AsyncResult<protos::AttachResponse> response) {
      if (!weak_this)
        return;
      TraceConfig trace_config;
      if (!response) {
        weak_this->consumer_->OnAttach(/*success=*/false, trace_config);
        return;
      }
      trace_config.FromProto(response->trace_config());

      // If attached succesfully, also attach to the end-of-trace
      // notificaton callback, via EnableTracing(attach_notification_only).
      protos::EnableTracingRequest enable_req;
      enable_req.set_attach_notification_only(true);
      ipc::Deferred<protos::EnableTracingResponse> enable_resp;
      enable_resp.Bind(
          [weak_this](ipc::AsyncResult<protos::EnableTracingResponse> resp) {
            if (weak_this)
              weak_this->OnEnableTracingResponse(std::move(resp));
          });
      weak_this->consumer_port_.EnableTracing(enable_req,
                                              std::move(enable_resp));

      weak_this->consumer_->OnAttach(/*success=*/true, trace_config);
    });
    consumer_port_.Attach(req, std::move(async_response));
  }
}

void ConsumerIPCClientImpl::GetTraceStats() {
  if (!connected_) {
    PERFETTO_DLOG("Cannot GetTraceStats(), not connected to tracing service");
    return;
  }

  protos::GetTraceStatsRequest req;
  ipc::Deferred<protos::GetTraceStatsResponse> async_response;

  // The IPC layer guarantees that callbacks are destroyed after this object
  // is destroyed (by virtue of destroying the |consumer_port_|). In turn the
  // contract of this class expects the caller to not destroy the Consumer class
  // before having destroyed this class. Hence binding |this| here is safe.
  async_response.Bind(
      [this](ipc::AsyncResult<protos::GetTraceStatsResponse> response) {
        TraceStats trace_stats;
        if (!response) {
          consumer_->OnTraceStats(/*success=*/false, trace_stats);
          return;
        }
        trace_stats.FromProto(response->trace_stats());
        consumer_->OnTraceStats(/*success=*/true, trace_stats);
      });
  consumer_port_.GetTraceStats(req, std::move(async_response));
}

void ConsumerIPCClientImpl::ObserveEvents(uint32_t enabled_event_types) {
  if (!connected_) {
    PERFETTO_DLOG("Cannot ObserveEvents(), not connected to tracing service");
    return;
  }

  protos::ObserveEventsRequest req;
  if (enabled_event_types & ObservableEventType::kDataSourceInstances) {
    req.add_events_to_observe(
        protos::ObservableEvents::TYPE_DATA_SOURCES_INSTANCES);
  }
  ipc::Deferred<protos::ObserveEventsResponse> async_response;
  // The IPC layer guarantees that callbacks are destroyed after this object
  // is destroyed (by virtue of destroying the |consumer_port_|). In turn the
  // contract of this class expects the caller to not destroy the Consumer class
  // before having destroyed this class. Hence binding |this| here is safe.
  async_response.Bind(
      [this](ipc::AsyncResult<protos::ObserveEventsResponse> response) {
        // Skip empty response, which the service sends to close the stream.
        if (!response->events().instance_state_changes().size()) {
          PERFETTO_DCHECK(!response.has_more());
          return;
        }
        ObservableEvents events;
        events.FromProto(response->events());
        consumer_->OnObservableEvents(events);
      });
  consumer_port_.ObserveEvents(req, std::move(async_response));
}

void ConsumerIPCClientImpl::QueryServiceState(
    QueryServiceStateCallback callback) {
  if (!connected_) {
    PERFETTO_DLOG(
        "Cannot QueryServiceState(), not connected to tracing service");
    return;
  }

  protos::QueryServiceStateRequest req;
  ipc::Deferred<protos::QueryServiceStateResponse> async_response;
  async_response.Bind(
      [callback](ipc::AsyncResult<protos::QueryServiceStateResponse> response) {
        if (!response)
          callback(false, TracingServiceState());
        TracingServiceState svc_state;
        svc_state.FromProto(response->service_state());
        callback(true, svc_state);
      });
  consumer_port_.QueryServiceState(req, std::move(async_response));
}

}  // namespace perfetto
// gen_amalgamated begin source: src/tracing/ipc/default_socket.cc
// gen_amalgamated begin header: include/perfetto/ext/tracing/ipc/default_socket.h
/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_TRACING_IPC_DEFAULT_SOCKET_H_
#define INCLUDE_PERFETTO_EXT_TRACING_IPC_DEFAULT_SOCKET_H_

namespace perfetto {

const char* GetConsumerSocket();
const char* GetProducerSocket();

}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_TRACING_IPC_DEFAULT_SOCKET_H_
/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "perfetto/ext/tracing/ipc/default_socket.h"

// gen_amalgamated expanded: #include "perfetto/base/build_config.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/basic_types.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/basic_types.h"

#include <stdlib.h>

namespace perfetto {

static_assert(kInvalidUid == ipc::kInvalidUid, "kInvalidUid mismatching");

const char* GetProducerSocket() {
  static const char* name = getenv("PERFETTO_PRODUCER_SOCK_NAME");
  if (name == nullptr) {
#if PERFETTO_BUILDFLAG(PERFETTO_OS_ANDROID)
    name = "/dev/socket/traced_producer";
#else
    name = "/tmp/perfetto-producer";
#endif
  }
  return name;
}

const char* GetConsumerSocket() {
  static const char* name = getenv("PERFETTO_CONSUMER_SOCK_NAME");
  if (name == nullptr) {
#if PERFETTO_BUILDFLAG(PERFETTO_OS_ANDROID)
    name = "/dev/socket/traced_consumer";
#else
    name = "/tmp/perfetto-consumer";
#endif
  }
  return name;
}

}  // namespace perfetto
// gen_amalgamated begin source: src/tracing/ipc/posix_shared_memory.cc
// gen_amalgamated begin header: src/tracing/ipc/posix_shared_memory.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef SRC_TRACING_IPC_POSIX_SHARED_MEMORY_H_
#define SRC_TRACING_IPC_POSIX_SHARED_MEMORY_H_

#include <stddef.h>

#include <memory>

// gen_amalgamated expanded: #include "perfetto/ext/base/scoped_file.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/shared_memory.h"

namespace perfetto {

// Implements the SharedMemory and its factory for the posix-based transport.
class PosixSharedMemory : public SharedMemory {
 public:
  class Factory : public SharedMemory::Factory {
   public:
    ~Factory() override;
    std::unique_ptr<SharedMemory> CreateSharedMemory(size_t) override;
  };

  // Create a brand new SHM region (the service uses this).
  static std::unique_ptr<PosixSharedMemory> Create(size_t size);

  // Mmaps a file descriptor to an existing SHM region (the producer uses this).
  static std::unique_ptr<PosixSharedMemory> AttachToFd(base::ScopedFile);

  ~PosixSharedMemory() override;

  int fd() const { return fd_.get(); }

  // SharedMemory implementation.
  void* start() const override { return start_; }
  size_t size() const override { return size_; }

 private:
  static std::unique_ptr<PosixSharedMemory> MapFD(base::ScopedFile, size_t);

  PosixSharedMemory(void* start, size_t size, base::ScopedFile);
  PosixSharedMemory(const PosixSharedMemory&) = delete;
  PosixSharedMemory& operator=(const PosixSharedMemory&) = delete;

  void* const start_;
  const size_t size_;
  base::ScopedFile fd_;
};

}  // namespace perfetto

#endif  // SRC_TRACING_IPC_POSIX_SHARED_MEMORY_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "src/tracing/ipc/posix_shared_memory.h"

#include <fcntl.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <unistd.h>

#include <memory>
#include <utility>

// gen_amalgamated expanded: #include "perfetto/base/build_config.h"
// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/temp_file.h"

#if PERFETTO_BUILDFLAG(PERFETTO_OS_ANDROID)
#include <linux/memfd.h>
#include <sys/syscall.h>
#endif

namespace perfetto {

// static
std::unique_ptr<PosixSharedMemory> PosixSharedMemory::Create(size_t size) {
  base::ScopedFile fd;
#if PERFETTO_BUILDFLAG(PERFETTO_OS_ANDROID)
  bool is_memfd = false;
  fd.reset(static_cast<int>(syscall(__NR_memfd_create, "perfetto_shmem",
                                    MFD_CLOEXEC | MFD_ALLOW_SEALING)));
  is_memfd = !!fd;

  if (!fd) {
    // TODO: if this fails on Android we should fall back on ashmem.
    PERFETTO_DPLOG("memfd_create() failed");
  }
#endif

  if (!fd)
    fd = base::TempFile::CreateUnlinked().ReleaseFD();

  PERFETTO_CHECK(fd);
  int res = ftruncate(fd.get(), static_cast<off_t>(size));
  PERFETTO_CHECK(res == 0);
#if PERFETTO_BUILDFLAG(PERFETTO_OS_ANDROID)
  if (is_memfd) {
    res = fcntl(*fd, F_ADD_SEALS, F_SEAL_SHRINK | F_SEAL_GROW | F_SEAL_SEAL);
    PERFETTO_DCHECK(res == 0);
  }
#endif
  return MapFD(std::move(fd), size);
}

// static
std::unique_ptr<PosixSharedMemory> PosixSharedMemory::AttachToFd(
    base::ScopedFile fd) {
  struct stat stat_buf = {};
  int res = fstat(fd.get(), &stat_buf);
  PERFETTO_CHECK(res == 0 && stat_buf.st_size > 0);
  return MapFD(std::move(fd), static_cast<size_t>(stat_buf.st_size));
}

// static
std::unique_ptr<PosixSharedMemory> PosixSharedMemory::MapFD(base::ScopedFile fd,
                                                            size_t size) {
  PERFETTO_DCHECK(fd);
  PERFETTO_DCHECK(size > 0);
  void* start =
      mmap(nullptr, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd.get(), 0);
  PERFETTO_CHECK(start != MAP_FAILED);
  return std::unique_ptr<PosixSharedMemory>(
      new PosixSharedMemory(start, size, std::move(fd)));
}

PosixSharedMemory::PosixSharedMemory(void* start,
                                     size_t size,
                                     base::ScopedFile fd)
    : start_(start), size_(size), fd_(std::move(fd)) {}

PosixSharedMemory::~PosixSharedMemory() {
  munmap(start(), size());
}

PosixSharedMemory::Factory::~Factory() {}

std::unique_ptr<SharedMemory> PosixSharedMemory::Factory::CreateSharedMemory(
    size_t size) {
  return PosixSharedMemory::Create(size);
}

}  // namespace perfetto
// gen_amalgamated begin source: src/tracing/ipc/producer/producer_ipc_client_impl.cc
// gen_amalgamated begin header: src/tracing/ipc/producer/producer_ipc_client_impl.h
// gen_amalgamated begin header: include/perfetto/ext/tracing/ipc/producer_ipc_client.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_TRACING_IPC_PRODUCER_IPC_CLIENT_H_
#define INCLUDE_PERFETTO_EXT_TRACING_IPC_PRODUCER_IPC_CLIENT_H_

#include <memory>
#include <string>

// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/tracing_service.h"

namespace perfetto {

class Producer;

// Allows to connect to a remote Service through a UNIX domain socket.
// Exposed to:
//   Producer(s) of the tracing library.
// Implemented in:
//   src/tracing/ipc/producer/producer_ipc_client_impl.cc
class ProducerIPCClient {
 public:
  // Connects to the producer port of the Service listening on the given
  // |service_sock_name|. If the connection is successful, the OnConnect()
  // method will be invoked asynchronously on the passed Producer interface.
  // If the connection fails, OnDisconnect() will be invoked instead.
  // The returned ProducerEndpoint serves also to delimit the scope of the
  // callbacks invoked on the Producer interface: no more Producer callbacks are
  // invoked immediately after its destruction and any pending callback will be
  // dropped.
  static std::unique_ptr<TracingService::ProducerEndpoint> Connect(
      const char* service_sock_name,
      Producer*,
      const std::string& producer_name,
      base::TaskRunner*,
      TracingService::ProducerSMBScrapingMode smb_scraping_mode =
          TracingService::ProducerSMBScrapingMode::kDefault);

 protected:
  ProducerIPCClient() = delete;
};

}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_TRACING_IPC_PRODUCER_IPC_CLIENT_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef SRC_TRACING_IPC_PRODUCER_PRODUCER_IPC_CLIENT_IMPL_H_
#define SRC_TRACING_IPC_PRODUCER_PRODUCER_IPC_CLIENT_IMPL_H_

#include <stdint.h>

#include <set>
#include <vector>

// gen_amalgamated expanded: #include "perfetto/ext/base/thread_checker.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/service_proxy.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/basic_types.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/shared_memory.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/tracing_service.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/ipc/producer_ipc_client.h"

// gen_amalgamated expanded: #include "perfetto/ipc/producer_port.ipc.h"

namespace perfetto {

namespace base {
class TaskRunner;
}  // namespace base

namespace ipc {
class Client;
}  // namespace ipc

class Producer;
class PosixSharedMemory;
class SharedMemoryArbiter;

// Exposes a Service endpoint to Producer(s), proxying all requests through a
// IPC channel to the remote Service. This class is the glue layer between the
// generic Service interface exposed to the clients of the library and the
// actual IPC transport.
class ProducerIPCClientImpl : public TracingService::ProducerEndpoint,
                              public ipc::ServiceProxy::EventListener {
 public:
  ProducerIPCClientImpl(const char* service_sock_name,
                        Producer*,
                        const std::string& producer_name,
                        base::TaskRunner*,
                        TracingService::ProducerSMBScrapingMode);
  ~ProducerIPCClientImpl() override;

  // TracingService::ProducerEndpoint implementation.
  // These methods are invoked by the actual Producer(s) code by clients of the
  // tracing library, which know nothing about the IPC transport.
  void RegisterDataSource(const DataSourceDescriptor&) override;
  void UnregisterDataSource(const std::string& name) override;
  void RegisterTraceWriter(uint32_t writer_id, uint32_t target_buffer) override;
  void UnregisterTraceWriter(uint32_t writer_id) override;
  void CommitData(const CommitDataRequest&, CommitDataCallback) override;
  void NotifyDataSourceStarted(DataSourceInstanceID) override;
  void NotifyDataSourceStopped(DataSourceInstanceID) override;
  void ActivateTriggers(const std::vector<std::string>&) override;

  std::unique_ptr<TraceWriter> CreateTraceWriter(
      BufferID target_buffer) override;
  SharedMemoryArbiter* GetInProcessShmemArbiter() override;
  void NotifyFlushComplete(FlushRequestID) override;
  SharedMemory* shared_memory() const override;
  size_t shared_buffer_page_size_kb() const override;

  // ipc::ServiceProxy::EventListener implementation.
  // These methods are invoked by the IPC layer, which knows nothing about
  // tracing, producers and consumers.
  void OnConnect() override;
  void OnDisconnect() override;

 private:
  // Invoked soon after having established the connection with the service.
  void OnConnectionInitialized(bool connection_succeeded);

  // Invoked when the remote Service sends an IPC to tell us to do something
  // (e.g. start/stop a data source).
  void OnServiceRequest(const protos::GetAsyncCommandResponse&);

  // TODO think to destruction order, do we rely on any specific dtor sequence?
  Producer* const producer_;
  base::TaskRunner* const task_runner_;

  // The object that owns the client socket and takes care of IPC traffic.
  std::unique_ptr<ipc::Client> ipc_channel_;

  // The proxy interface for the producer port of the service. It is bound
  // to |ipc_channel_| and (de)serializes method invocations over the wire.
  protos::ProducerPortProxy producer_port_;

  std::unique_ptr<PosixSharedMemory> shared_memory_;
  std::unique_ptr<SharedMemoryArbiter> shared_memory_arbiter_;
  size_t shared_buffer_page_size_kb_ = 0;
  std::set<DataSourceInstanceID> data_sources_setup_;
  bool connected_ = false;
  std::string const name_;
  TracingService::ProducerSMBScrapingMode const smb_scraping_mode_;
  PERFETTO_THREAD_CHECKER(thread_checker_)
};

}  // namespace perfetto

#endif  // SRC_TRACING_IPC_PRODUCER_PRODUCER_IPC_CLIENT_IMPL_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "src/tracing/ipc/producer/producer_ipc_client_impl.h"

#include <inttypes.h>
#include <string.h>

// gen_amalgamated expanded: #include "perfetto/base/task_runner.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/client.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/commit_data_request.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/producer.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/shared_memory_arbiter.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/trace_writer.h"
// gen_amalgamated expanded: #include "perfetto/tracing/core/data_source_config.h"
// gen_amalgamated expanded: #include "perfetto/tracing/core/data_source_descriptor.h"
// gen_amalgamated expanded: #include "perfetto/tracing/core/trace_config.h"
// gen_amalgamated expanded: #include "src/tracing/ipc/posix_shared_memory.h"

// TODO(fmayer): think to what happens when ProducerIPCClientImpl gets destroyed
// w.r.t. the Producer pointer. Also think to lifetime of the Producer* during
// the callbacks.

namespace perfetto {

// static. (Declared in include/tracing/ipc/producer_ipc_client.h).
std::unique_ptr<TracingService::ProducerEndpoint> ProducerIPCClient::Connect(
    const char* service_sock_name,
    Producer* producer,
    const std::string& producer_name,
    base::TaskRunner* task_runner,
    TracingService::ProducerSMBScrapingMode smb_scraping_mode) {
  return std::unique_ptr<TracingService::ProducerEndpoint>(
      new ProducerIPCClientImpl(service_sock_name, producer, producer_name,
                                task_runner, smb_scraping_mode));
}

ProducerIPCClientImpl::ProducerIPCClientImpl(
    const char* service_sock_name,
    Producer* producer,
    const std::string& producer_name,
    base::TaskRunner* task_runner,
    TracingService::ProducerSMBScrapingMode smb_scraping_mode)
    : producer_(producer),
      task_runner_(task_runner),
      ipc_channel_(ipc::Client::CreateInstance(service_sock_name, task_runner)),
      producer_port_(this /* event_listener */),
      name_(producer_name),
      smb_scraping_mode_(smb_scraping_mode) {
  ipc_channel_->BindService(producer_port_.GetWeakPtr());
  PERFETTO_DCHECK_THREAD(thread_checker_);
}

ProducerIPCClientImpl::~ProducerIPCClientImpl() = default;

// Called by the IPC layer if the BindService() succeeds.
void ProducerIPCClientImpl::OnConnect() {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  connected_ = true;

  // The IPC layer guarantees that any outstanding callback will be dropped on
  // the floor if producer_port_ is destroyed between the request and the reply.
  // Binding |this| is hence safe.
  ipc::Deferred<protos::InitializeConnectionResponse> on_init;
  on_init.Bind(
      [this](ipc::AsyncResult<protos::InitializeConnectionResponse> resp) {
        OnConnectionInitialized(resp.success());
      });
  protos::InitializeConnectionRequest req;
  req.set_producer_name(name_);
  switch (smb_scraping_mode_) {
    case TracingService::ProducerSMBScrapingMode::kDefault:
      // No need to set the mode, it defaults to use the service default if
      // unspecified.
      break;
    case TracingService::ProducerSMBScrapingMode::kEnabled:
      req.set_smb_scraping_mode(
          protos::InitializeConnectionRequest::SMB_SCRAPING_ENABLED);
      break;
    case TracingService::ProducerSMBScrapingMode::kDisabled:
      req.set_smb_scraping_mode(
          protos::InitializeConnectionRequest::SMB_SCRAPING_DISABLED);
      break;
  }
  producer_port_.InitializeConnection(req, std::move(on_init));

  // Create the back channel to receive commands from the Service.
  ipc::Deferred<protos::GetAsyncCommandResponse> on_cmd;
  on_cmd.Bind([this](ipc::AsyncResult<protos::GetAsyncCommandResponse> resp) {
    if (!resp)
      return;  // The IPC channel was closed and |resp| was auto-rejected.
    OnServiceRequest(*resp);
  });
  producer_port_.GetAsyncCommand(protos::GetAsyncCommandRequest(),
                                 std::move(on_cmd));
}

void ProducerIPCClientImpl::OnDisconnect() {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  PERFETTO_DLOG("Tracing service connection failure");
  connected_ = false;
  producer_->OnDisconnect();
  data_sources_setup_.clear();
}

void ProducerIPCClientImpl::OnConnectionInitialized(bool connection_succeeded) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  // If connection_succeeded == false, the OnDisconnect() call will follow next
  // and there we'll notify the |producer_|. TODO: add a test for this.
  if (!connection_succeeded)
    return;
  producer_->OnConnect();
}

void ProducerIPCClientImpl::OnServiceRequest(
    const protos::GetAsyncCommandResponse& cmd) {
  PERFETTO_DCHECK_THREAD(thread_checker_);

  // This message is sent only when connecting to a service running Android Q+.
  // See comment below in kStartDataSource.
  if (cmd.cmd_case() == protos::GetAsyncCommandResponse::kSetupDataSource) {
    const auto& req = cmd.setup_data_source();
    const DataSourceInstanceID dsid = req.new_instance_id();
    DataSourceConfig cfg;
    cfg.FromProto(req.config());
    data_sources_setup_.insert(dsid);
    producer_->SetupDataSource(dsid, cfg);
    return;
  }

  if (cmd.cmd_case() == protos::GetAsyncCommandResponse::kStartDataSource) {
    const auto& req = cmd.start_data_source();
    const DataSourceInstanceID dsid = req.new_instance_id();
    DataSourceConfig cfg;
    cfg.FromProto(req.config());
    if (!data_sources_setup_.count(dsid)) {
      // When connecting with an older (Android P) service, the service will not
      // send a SetupDataSource message. We synthesize it here in that case.
      producer_->SetupDataSource(dsid, cfg);
    }
    producer_->StartDataSource(dsid, cfg);
    return;
  }

  if (cmd.cmd_case() == protos::GetAsyncCommandResponse::kStopDataSource) {
    const DataSourceInstanceID dsid = cmd.stop_data_source().instance_id();
    producer_->StopDataSource(dsid);
    data_sources_setup_.erase(dsid);
    return;
  }

  if (cmd.cmd_case() == protos::GetAsyncCommandResponse::kSetupTracing) {
    base::ScopedFile shmem_fd = ipc_channel_->TakeReceivedFD();
    PERFETTO_CHECK(shmem_fd);

    // TODO(primiano): handle mmap failure in case of OOM.
    shared_memory_ = PosixSharedMemory::AttachToFd(std::move(shmem_fd));
    shared_buffer_page_size_kb_ =
        cmd.setup_tracing().shared_buffer_page_size_kb();
    shared_memory_arbiter_ = SharedMemoryArbiter::CreateInstance(
        shared_memory_.get(), shared_buffer_page_size_kb_ * 1024, this,
        task_runner_);
    producer_->OnTracingSetup();
    return;
  }

  if (cmd.cmd_case() == protos::GetAsyncCommandResponse::kFlush) {
    // This cast boilerplate is required only because protobuf uses its own
    // uint64 and not stdint's uint64_t. On some 64 bit archs they differ on the
    // type (long vs long long) even though they have the same size.
    const auto* data_source_ids = cmd.flush().data_source_ids().data();
    static_assert(sizeof(data_source_ids[0]) == sizeof(DataSourceInstanceID),
                  "data_source_ids should be 64-bit");
    producer_->Flush(
        cmd.flush().request_id(),
        reinterpret_cast<const DataSourceInstanceID*>(data_source_ids),
        static_cast<size_t>(cmd.flush().data_source_ids().size()));
    return;
  }

  if (cmd.cmd_case() ==
      protos::GetAsyncCommandResponse::kClearIncrementalState) {
    const auto* data_source_ids =
        cmd.clear_incremental_state().data_source_ids().data();
    static_assert(sizeof(data_source_ids[0]) == sizeof(DataSourceInstanceID),
                  "data_source_ids should be 64-bit");
    producer_->ClearIncrementalState(
        reinterpret_cast<const DataSourceInstanceID*>(data_source_ids),
        static_cast<size_t>(
            cmd.clear_incremental_state().data_source_ids().size()));
    return;
  }

  PERFETTO_DFATAL("Unknown async request %d received from tracing service",
                  cmd.cmd_case());
}

void ProducerIPCClientImpl::RegisterDataSource(
    const DataSourceDescriptor& descriptor) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  if (!connected_) {
    PERFETTO_DLOG(
        "Cannot RegisterDataSource(), not connected to tracing service");
  }
  protos::RegisterDataSourceRequest req;
  descriptor.ToProto(req.mutable_data_source_descriptor());
  ipc::Deferred<protos::RegisterDataSourceResponse> async_response;
  async_response.Bind(
      [](ipc::AsyncResult<protos::RegisterDataSourceResponse> response) {
        if (!response)
          PERFETTO_DLOG("RegisterDataSource() failed: connection reset");
      });
  producer_port_.RegisterDataSource(req, std::move(async_response));
}

void ProducerIPCClientImpl::UnregisterDataSource(const std::string& name) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  if (!connected_) {
    PERFETTO_DLOG(
        "Cannot UnregisterDataSource(), not connected to tracing service");
    return;
  }
  protos::UnregisterDataSourceRequest req;
  req.set_data_source_name(name);
  producer_port_.UnregisterDataSource(
      req, ipc::Deferred<protos::UnregisterDataSourceResponse>());
}

void ProducerIPCClientImpl::RegisterTraceWriter(uint32_t writer_id,
                                                uint32_t target_buffer) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  if (!connected_) {
    PERFETTO_DLOG(
        "Cannot RegisterTraceWriter(), not connected to tracing service");
    return;
  }
  protos::RegisterTraceWriterRequest req;
  req.set_trace_writer_id(writer_id);
  req.set_target_buffer(target_buffer);
  producer_port_.RegisterTraceWriter(
      req, ipc::Deferred<protos::RegisterTraceWriterResponse>());
}

void ProducerIPCClientImpl::UnregisterTraceWriter(uint32_t writer_id) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  if (!connected_) {
    PERFETTO_DLOG(
        "Cannot UnregisterTraceWriter(), not connected to tracing service");
    return;
  }
  protos::UnregisterTraceWriterRequest req;
  req.set_trace_writer_id(writer_id);
  producer_port_.UnregisterTraceWriter(
      req, ipc::Deferred<protos::UnregisterTraceWriterResponse>());
}

void ProducerIPCClientImpl::CommitData(const CommitDataRequest& req,
                                       CommitDataCallback callback) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  if (!connected_) {
    PERFETTO_DLOG("Cannot CommitData(), not connected to tracing service");
    return;
  }
  protos::CommitDataRequest proto_req;
  req.ToProto(&proto_req);
  ipc::Deferred<protos::CommitDataResponse> async_response;
  // TODO(primiano): add a test that destroys ProducerIPCClientImpl soon after
  // this call and checks that the callback is dropped.
  if (callback) {
    async_response.Bind(
        [callback](ipc::AsyncResult<protos::CommitDataResponse> response) {
          if (!response) {
            PERFETTO_DLOG("CommitData() failed: connection reset");
            return;
          }
          callback();
        });
  }
  producer_port_.CommitData(proto_req, std::move(async_response));
}

void ProducerIPCClientImpl::NotifyDataSourceStarted(DataSourceInstanceID id) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  if (!connected_) {
    PERFETTO_DLOG(
        "Cannot NotifyDataSourceStarted(), not connected to tracing service");
    return;
  }
  protos::NotifyDataSourceStartedRequest req;
  req.set_data_source_id(id);
  producer_port_.NotifyDataSourceStarted(
      req, ipc::Deferred<protos::NotifyDataSourceStartedResponse>());
}

void ProducerIPCClientImpl::NotifyDataSourceStopped(DataSourceInstanceID id) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  if (!connected_) {
    PERFETTO_DLOG(
        "Cannot NotifyDataSourceStopped(), not connected to tracing service");
    return;
  }
  protos::NotifyDataSourceStoppedRequest req;
  req.set_data_source_id(id);
  producer_port_.NotifyDataSourceStopped(
      req, ipc::Deferred<protos::NotifyDataSourceStoppedResponse>());
}

void ProducerIPCClientImpl::ActivateTriggers(
    const std::vector<std::string>& triggers) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  if (!connected_) {
    PERFETTO_DLOG(
        "Cannot ActivateTriggers(), not connected to tracing service");
    return;
  }
  protos::ActivateTriggersRequest proto_req;
  for (const auto& name : triggers) {
    *proto_req.add_trigger_names() = name;
  }
  producer_port_.ActivateTriggers(
      proto_req, ipc::Deferred<protos::ActivateTriggersResponse>());
}

std::unique_ptr<TraceWriter> ProducerIPCClientImpl::CreateTraceWriter(
    BufferID target_buffer) {
  // This method can be called by different threads. |shared_memory_arbiter_| is
  // thread-safe but be aware of accessing any other state in this function.
  return shared_memory_arbiter_->CreateTraceWriter(target_buffer);
}

SharedMemoryArbiter* ProducerIPCClientImpl::GetInProcessShmemArbiter() {
  PERFETTO_DLOG("Cannot GetInProcessShmemArbiter() via the IPC layer.");
  return nullptr;
}

void ProducerIPCClientImpl::NotifyFlushComplete(FlushRequestID req_id) {
  return shared_memory_arbiter_->NotifyFlushComplete(req_id);
}

SharedMemory* ProducerIPCClientImpl::shared_memory() const {
  return shared_memory_.get();
}

size_t ProducerIPCClientImpl::shared_buffer_page_size_kb() const {
  return shared_buffer_page_size_kb_;
}

}  // namespace perfetto
// gen_amalgamated begin source: src/tracing/ipc/service/consumer_ipc_service.cc
// gen_amalgamated begin header: src/tracing/ipc/service/consumer_ipc_service.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef SRC_TRACING_IPC_SERVICE_CONSUMER_IPC_SERVICE_H_
#define SRC_TRACING_IPC_SERVICE_CONSUMER_IPC_SERVICE_H_

#include <list>
#include <map>
#include <memory>
#include <string>

// gen_amalgamated expanded: #include "perfetto/ext/base/weak_ptr.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/basic_types.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/consumer.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/tracing_service.h"

// gen_amalgamated expanded: #include "perfetto/ipc/consumer_port.ipc.h"

namespace perfetto {

class TracingServiceState;

namespace ipc {
class Host;
}  // namespace ipc

// Implements the Consumer port of the IPC service. This class proxies requests
// and responses between the core service logic (|svc_|) and remote Consumer(s)
// on the IPC socket, through the methods overriddden from ConsumerPort.
class ConsumerIPCService : public protos::ConsumerPort {
 public:
  explicit ConsumerIPCService(TracingService* core_service);
  ~ConsumerIPCService() override;

  // ConsumerPort implementation (from .proto IPC definition).
  void EnableTracing(const protos::EnableTracingRequest&,
                     DeferredEnableTracingResponse) override;
  void StartTracing(const protos::StartTracingRequest&,
                    DeferredStartTracingResponse) override;
  void ChangeTraceConfig(const protos::ChangeTraceConfigRequest&,
                         DeferredChangeTraceConfigResponse) override;
  void DisableTracing(const protos::DisableTracingRequest&,
                      DeferredDisableTracingResponse) override;
  void ReadBuffers(const protos::ReadBuffersRequest&,
                   DeferredReadBuffersResponse) override;
  void FreeBuffers(const protos::FreeBuffersRequest&,
                   DeferredFreeBuffersResponse) override;
  void Flush(const protos::FlushRequest&, DeferredFlushResponse) override;
  void Detach(const protos::DetachRequest&, DeferredDetachResponse) override;
  void Attach(const protos::AttachRequest&, DeferredAttachResponse) override;
  void GetTraceStats(const protos::GetTraceStatsRequest&,
                     DeferredGetTraceStatsResponse) override;
  void ObserveEvents(const protos::ObserveEventsRequest&,
                     DeferredObserveEventsResponse) override;
  void QueryServiceState(const protos::QueryServiceStateRequest&,
                         DeferredQueryServiceStateResponse) override;
  void OnClientDisconnected() override;

 private:
  // Acts like a Consumer with the core Service business logic (which doesn't
  // know anything about the remote transport), but all it does is proxying
  // methods to the remote Consumer on the other side of the IPC channel.
  class RemoteConsumer : public Consumer {
   public:
    RemoteConsumer();
    ~RemoteConsumer() override;

    // These methods are called by the |core_service_| business logic. There is
    // no connection here, these methods are posted straight away.
    void OnConnect() override;
    void OnDisconnect() override;
    void OnTracingDisabled() override;
    void OnTraceData(std::vector<TracePacket>, bool has_more) override;
    void OnDetach(bool) override;
    void OnAttach(bool, const TraceConfig&) override;
    void OnTraceStats(bool, const TraceStats&) override;
    void OnObservableEvents(const ObservableEvents&) override;

    void CloseObserveEventsResponseStream();

    // The interface obtained from the core service business logic through
    // TracingService::ConnectConsumer(this). This allows to invoke methods for
    // a specific Consumer on the Service business logic.
    std::unique_ptr<TracingService::ConsumerEndpoint> service_endpoint;

    // After ReadBuffers() is invoked, this binds the async callback that
    // allows to stream trace packets back to the client.
    DeferredReadBuffersResponse read_buffers_response;

    // After EnableTracing() is invoked, this binds the async callback that
    // allows to send the OnTracingDisabled notification.
    DeferredEnableTracingResponse enable_tracing_response;

    // After Detach() is invoked, this binds the async callback that allows to
    // send the session id to the consumer.
    DeferredDetachResponse detach_response;

    // As above, but for the Attach() case.
    DeferredAttachResponse attach_response;

    // As above, but for GetTraceStats().
    DeferredGetTraceStatsResponse get_trace_stats_response;

    // After ObserveEvents() is invoked, this binds the async callback that
    // allows to stream ObservableEvents back to the client.
    DeferredObserveEventsResponse observe_events_response;
  };

  // This has to be a container that doesn't invalidate iterators.
  using PendingFlushResponses = std::list<DeferredFlushResponse>;
  using PendingQuerySvcResponses = std::list<DeferredQueryServiceStateResponse>;

  ConsumerIPCService(const ConsumerIPCService&) = delete;
  ConsumerIPCService& operator=(const ConsumerIPCService&) = delete;

  // Returns the ConsumerEndpoint in the core business logic that corresponds to
  // the current IPC request.
  RemoteConsumer* GetConsumerForCurrentRequest();

  void OnFlushCallback(bool success, PendingFlushResponses::iterator);
  void OnQueryServiceCallback(bool success,
                              const TracingServiceState&,
                              PendingQuerySvcResponses::iterator);

  TracingService* const core_service_;

  // Maps IPC clients to ConsumerEndpoint instances registered on the
  // |core_service_| business logic.
  std::map<ipc::ClientID, std::unique_ptr<RemoteConsumer>> consumers_;

  PendingFlushResponses pending_flush_responses_;
  PendingQuerySvcResponses pending_query_service_responses_;

  base::WeakPtrFactory<ConsumerIPCService> weak_ptr_factory_;  // Keep last.
};

}  // namespace perfetto

#endif  // SRC_TRACING_IPC_SERVICE_CONSUMER_IPC_SERVICE_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "src/tracing/ipc/service/consumer_ipc_service.h"

#include <inttypes.h>

// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/base/task_runner.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/scoped_file.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/basic_types.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/host.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/shared_memory_abi.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/slice.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/trace_packet.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/trace_stats.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/tracing_service.h"
// gen_amalgamated expanded: #include "perfetto/tracing/core/trace_config.h"
// gen_amalgamated expanded: #include "perfetto/tracing/core/tracing_service_state.h"

namespace perfetto {

ConsumerIPCService::ConsumerIPCService(TracingService* core_service)
    : core_service_(core_service), weak_ptr_factory_(this) {}

ConsumerIPCService::~ConsumerIPCService() = default;

ConsumerIPCService::RemoteConsumer*
ConsumerIPCService::GetConsumerForCurrentRequest() {
  const ipc::ClientID ipc_client_id = ipc::Service::client_info().client_id();
  const uid_t uid = ipc::Service::client_info().uid();
  PERFETTO_CHECK(ipc_client_id);
  auto it = consumers_.find(ipc_client_id);
  if (it == consumers_.end()) {
    auto* remote_consumer = new RemoteConsumer();
    consumers_[ipc_client_id].reset(remote_consumer);
    remote_consumer->service_endpoint =
        core_service_->ConnectConsumer(remote_consumer, uid);
    return remote_consumer;
  }
  return it->second.get();
}

// Called by the IPC layer.
void ConsumerIPCService::OnClientDisconnected() {
  ipc::ClientID client_id = ipc::Service::client_info().client_id();
  consumers_.erase(client_id);
}

// Called by the IPC layer.
void ConsumerIPCService::EnableTracing(const protos::EnableTracingRequest& req,
                                       DeferredEnableTracingResponse resp) {
  RemoteConsumer* remote_consumer = GetConsumerForCurrentRequest();
  if (req.attach_notification_only()) {
    remote_consumer->enable_tracing_response = std::move(resp);
    return;
  }
  TraceConfig trace_config;
  trace_config.FromProto(req.trace_config());
  base::ScopedFile fd;
  if (trace_config.write_into_file())
    fd = ipc::Service::TakeReceivedFD();
  remote_consumer->service_endpoint->EnableTracing(trace_config, std::move(fd));
  remote_consumer->enable_tracing_response = std::move(resp);
}

// Called by the IPC layer.
void ConsumerIPCService::StartTracing(const protos::StartTracingRequest&,
                                      DeferredStartTracingResponse resp) {
  RemoteConsumer* remote_consumer = GetConsumerForCurrentRequest();
  remote_consumer->service_endpoint->StartTracing();
  resp.Resolve(ipc::AsyncResult<protos::StartTracingResponse>::Create());
}

// Called by the IPC layer.
void ConsumerIPCService::ChangeTraceConfig(
    const protos::ChangeTraceConfigRequest& req,
    DeferredChangeTraceConfigResponse resp) {
  RemoteConsumer* remote_consumer = GetConsumerForCurrentRequest();
  TraceConfig trace_config;
  trace_config.FromProto(req.trace_config());
  remote_consumer->service_endpoint->ChangeTraceConfig(trace_config);
  resp.Resolve(ipc::AsyncResult<protos::ChangeTraceConfigResponse>::Create());
}

// Called by the IPC layer.
void ConsumerIPCService::DisableTracing(const protos::DisableTracingRequest&,
                                        DeferredDisableTracingResponse resp) {
  GetConsumerForCurrentRequest()->service_endpoint->DisableTracing();
  resp.Resolve(ipc::AsyncResult<protos::DisableTracingResponse>::Create());
}

// Called by the IPC layer.
void ConsumerIPCService::ReadBuffers(const protos::ReadBuffersRequest&,
                                     DeferredReadBuffersResponse resp) {
  RemoteConsumer* remote_consumer = GetConsumerForCurrentRequest();
  remote_consumer->read_buffers_response = std::move(resp);
  remote_consumer->service_endpoint->ReadBuffers();
}

// Called by the IPC layer.
void ConsumerIPCService::FreeBuffers(const protos::FreeBuffersRequest&,
                                     DeferredFreeBuffersResponse resp) {
  GetConsumerForCurrentRequest()->service_endpoint->FreeBuffers();
  resp.Resolve(ipc::AsyncResult<protos::FreeBuffersResponse>::Create());
}

// Called by the IPC layer.
void ConsumerIPCService::Flush(const protos::FlushRequest& req,
                               DeferredFlushResponse resp) {
  auto it = pending_flush_responses_.insert(pending_flush_responses_.end(),
                                            std::move(resp));
  auto weak_this = weak_ptr_factory_.GetWeakPtr();
  auto callback = [weak_this, it](bool success) {
    if (weak_this)
      weak_this->OnFlushCallback(success, std::move(it));
  };
  GetConsumerForCurrentRequest()->service_endpoint->Flush(req.timeout_ms(),
                                                          std::move(callback));
}

// Called by the IPC layer.
void ConsumerIPCService::Detach(const protos::DetachRequest& req,
                                DeferredDetachResponse resp) {
  // OnDetach() will resolve the |detach_response|.
  RemoteConsumer* remote_consumer = GetConsumerForCurrentRequest();
  remote_consumer->detach_response = std::move(resp);
  remote_consumer->service_endpoint->Detach(req.key());
}

// Called by the IPC layer.
void ConsumerIPCService::Attach(const protos::AttachRequest& req,
                                DeferredAttachResponse resp) {
  // OnAttach() will resolve the |attach_response|.
  RemoteConsumer* remote_consumer = GetConsumerForCurrentRequest();
  remote_consumer->attach_response = std::move(resp);
  remote_consumer->service_endpoint->Attach(req.key());
}

// Called by the IPC layer.
void ConsumerIPCService::GetTraceStats(const protos::GetTraceStatsRequest&,
                                       DeferredGetTraceStatsResponse resp) {
  // OnTraceStats() will resolve the |get_trace_stats_response|.
  RemoteConsumer* remote_consumer = GetConsumerForCurrentRequest();
  remote_consumer->get_trace_stats_response = std::move(resp);
  remote_consumer->service_endpoint->GetTraceStats();
}

// Called by the IPC layer.
void ConsumerIPCService::ObserveEvents(const protos::ObserveEventsRequest& req,
                                       DeferredObserveEventsResponse resp) {
  RemoteConsumer* remote_consumer = GetConsumerForCurrentRequest();

  // If there's a prior stream, close it so that client can clean it up.
  remote_consumer->CloseObserveEventsResponseStream();

  remote_consumer->observe_events_response = std::move(resp);

  bool observe_instances = false;
  for (const auto& type : req.events_to_observe()) {
    switch (type) {
      case protos::ObservableEvents::TYPE_DATA_SOURCES_INSTANCES:
        observe_instances = true;
        break;
      default:
        PERFETTO_DFATAL("Unknown ObservableEvent type: %d", type);
        break;
    }
  }
  remote_consumer->service_endpoint->ObserveEvents(observe_instances);

  // If no events are to be observed, close the stream immediately so that the
  // client can clean up.
  if (req.events_to_observe().size() == 0)
    remote_consumer->CloseObserveEventsResponseStream();
}

// Called by the IPC layer.
void ConsumerIPCService::QueryServiceState(
    const protos::QueryServiceStateRequest&,
    DeferredQueryServiceStateResponse resp) {
  RemoteConsumer* remote_consumer = GetConsumerForCurrentRequest();
  auto it = pending_query_service_responses_.insert(
      pending_query_service_responses_.end(), std::move(resp));
  auto weak_this = weak_ptr_factory_.GetWeakPtr();
  auto callback = [weak_this, it](bool success,
                                  const TracingServiceState& svc_state) {
    if (weak_this)
      weak_this->OnQueryServiceCallback(success, svc_state, std::move(it));
  };
  remote_consumer->service_endpoint->QueryServiceState(callback);
}

// Called by the service in response to a service_endpoint->Flush() request.
void ConsumerIPCService::OnFlushCallback(
    bool success,
    PendingFlushResponses::iterator pending_response_it) {
  DeferredFlushResponse response(std::move(*pending_response_it));
  pending_flush_responses_.erase(pending_response_it);
  if (success) {
    response.Resolve(ipc::AsyncResult<protos::FlushResponse>::Create());
  } else {
    response.Reject();
  }
}

// Called by the service in response to service_endpoint->QueryServiceState().
void ConsumerIPCService::OnQueryServiceCallback(
    bool success,
    const TracingServiceState& svc_state,
    PendingQuerySvcResponses::iterator pending_response_it) {
  DeferredQueryServiceStateResponse response(std::move(*pending_response_it));
  pending_query_service_responses_.erase(pending_response_it);
  if (success) {
    auto resp = ipc::AsyncResult<protos::QueryServiceStateResponse>::Create();
    svc_state.ToProto(resp->mutable_service_state());
    response.Resolve(std::move(resp));
  } else {
    response.Reject();
  }
}

////////////////////////////////////////////////////////////////////////////////
// RemoteConsumer methods
////////////////////////////////////////////////////////////////////////////////

ConsumerIPCService::RemoteConsumer::RemoteConsumer() = default;
ConsumerIPCService::RemoteConsumer::~RemoteConsumer() = default;

// Invoked by the |core_service_| business logic after the ConnectConsumer()
// call. There is nothing to do here, we really expected the ConnectConsumer()
// to just work in the local case.
void ConsumerIPCService::RemoteConsumer::OnConnect() {}

// Invoked by the |core_service_| business logic after we destroy the
// |service_endpoint| (in the RemoteConsumer dtor).
void ConsumerIPCService::RemoteConsumer::OnDisconnect() {}

void ConsumerIPCService::RemoteConsumer::OnTracingDisabled() {
  if (enable_tracing_response.IsBound()) {
    auto result = ipc::AsyncResult<protos::EnableTracingResponse>::Create();
    result->set_disabled(true);
    enable_tracing_response.Resolve(std::move(result));
  }
}

void ConsumerIPCService::RemoteConsumer::OnTraceData(
    std::vector<TracePacket> trace_packets,
    bool has_more) {
  if (!read_buffers_response.IsBound())
    return;

  auto result = ipc::AsyncResult<protos::ReadBuffersResponse>::Create();

  // A TracePacket might be too big to fit into a single IPC message (max
  // kIPCBufferSize). However a TracePacket is made of slices and each slice
  // is way smaller than kIPCBufferSize (a slice size is effectively bounded by
  // the max chunk size of the SharedMemoryABI). When sending a TracePacket,
  // if its slices don't fit within one IPC, chunk them over several contiguous
  // IPCs using the |last_slice_for_packet| for glueing on the other side.
  static_assert(ipc::kIPCBufferSize >= SharedMemoryABI::kMaxPageSize * 2,
                "kIPCBufferSize too small given the max possible slice size");

  auto send_ipc_reply = [this, &result](bool more) {
    result.set_has_more(more);
    read_buffers_response.Resolve(std::move(result));
    result = ipc::AsyncResult<protos::ReadBuffersResponse>::Create();
  };

  size_t approx_reply_size = 0;
  for (const TracePacket& trace_packet : trace_packets) {
    size_t num_slices_left_for_packet = trace_packet.slices().size();
    for (const Slice& slice : trace_packet.slices()) {
      // Check if this slice would cause the IPC to overflow its max size and,
      // if that is the case, split the IPCs. The "16" and "64" below are
      // over-estimations of, respectively:
      // 16: the preamble that prefixes each slice (there are 2 x size fields
      //     in the proto + the |last_slice_for_packet| bool).
      // 64: the overhead of the IPC InvokeMethodReply + wire_protocol's frame.
      // If these estimations are wrong, BufferedFrameDeserializer::Serialize()
      // will hit a DCHECK anyways.
      const size_t approx_slice_size = slice.size + 16;
      if (approx_reply_size + approx_slice_size > ipc::kIPCBufferSize - 64) {
        // If we hit this CHECK we got a single slice that is > kIPCBufferSize.
        PERFETTO_CHECK(result->slices_size() > 0);
        send_ipc_reply(/*has_more=*/true);
        approx_reply_size = 0;
      }
      approx_reply_size += approx_slice_size;

      auto* res_slice = result->add_slices();
      res_slice->set_last_slice_for_packet(--num_slices_left_for_packet == 0);
      res_slice->set_data(slice.start, slice.size);
    }
  }
  send_ipc_reply(has_more);
}

void ConsumerIPCService::RemoteConsumer::OnDetach(bool success) {
  if (!success) {
    std::move(detach_response).Reject();
    return;
  }
  auto resp = ipc::AsyncResult<protos::DetachResponse>::Create();
  std::move(detach_response).Resolve(std::move(resp));
}

void ConsumerIPCService::RemoteConsumer::OnAttach(
    bool success,
    const TraceConfig& trace_config) {
  if (!success) {
    std::move(attach_response).Reject();
    return;
  }
  auto response = ipc::AsyncResult<protos::AttachResponse>::Create();
  trace_config.ToProto(response->mutable_trace_config());
  std::move(attach_response).Resolve(std::move(response));
}

void ConsumerIPCService::RemoteConsumer::OnTraceStats(bool success,
                                                      const TraceStats& stats) {
  if (!success) {
    std::move(get_trace_stats_response).Reject();
    return;
  }
  auto response = ipc::AsyncResult<protos::GetTraceStatsResponse>::Create();
  stats.ToProto(response->mutable_trace_stats());
  std::move(get_trace_stats_response).Resolve(std::move(response));
}

void ConsumerIPCService::RemoteConsumer::OnObservableEvents(
    const ObservableEvents& events) {
  if (!observe_events_response.IsBound())
    return;

  auto result = ipc::AsyncResult<protos::ObserveEventsResponse>::Create();
  result.set_has_more(true);
  events.ToProto(result->mutable_events());
  observe_events_response.Resolve(std::move(result));
}

void ConsumerIPCService::RemoteConsumer::CloseObserveEventsResponseStream() {
  if (!observe_events_response.IsBound())
    return;

  auto result = ipc::AsyncResult<protos::ObserveEventsResponse>::Create();
  result.set_has_more(false);
  observe_events_response.Resolve(std::move(result));
}

}  // namespace perfetto
// gen_amalgamated begin source: src/tracing/ipc/service/producer_ipc_service.cc
// gen_amalgamated begin header: src/tracing/ipc/service/producer_ipc_service.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef SRC_TRACING_IPC_SERVICE_PRODUCER_IPC_SERVICE_H_
#define SRC_TRACING_IPC_SERVICE_PRODUCER_IPC_SERVICE_H_

#include <map>
#include <memory>
#include <string>

// gen_amalgamated expanded: #include "perfetto/ext/base/weak_ptr.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/basic_types.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/producer.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/tracing_service.h"

// gen_amalgamated expanded: #include "perfetto/ipc/producer_port.ipc.h"

namespace perfetto {

namespace ipc {
class Host;
}  // namespace ipc

// Implements the Producer port of the IPC service. This class proxies requests
// and responses between the core service logic (|svc_|) and remote Producer(s)
// on the IPC socket, through the methods overriddden from ProducerPort.
class ProducerIPCService : public protos::ProducerPort {
 public:
  explicit ProducerIPCService(TracingService* core_service);
  ~ProducerIPCService() override;

  // ProducerPort implementation (from .proto IPC definition).
  void InitializeConnection(const protos::InitializeConnectionRequest&,
                            DeferredInitializeConnectionResponse) override;
  void RegisterDataSource(const protos::RegisterDataSourceRequest&,
                          DeferredRegisterDataSourceResponse) override;
  void UnregisterDataSource(const protos::UnregisterDataSourceRequest&,
                            DeferredUnregisterDataSourceResponse) override;
  void RegisterTraceWriter(const protos::RegisterTraceWriterRequest&,
                           DeferredRegisterTraceWriterResponse) override;
  void UnregisterTraceWriter(const protos::UnregisterTraceWriterRequest&,
                             DeferredUnregisterTraceWriterResponse) override;
  void CommitData(const protos::CommitDataRequest&,
                  DeferredCommitDataResponse) override;
  void NotifyDataSourceStarted(
      const protos::NotifyDataSourceStartedRequest&,
      DeferredNotifyDataSourceStartedResponse) override;
  void NotifyDataSourceStopped(
      const protos::NotifyDataSourceStoppedRequest&,
      DeferredNotifyDataSourceStoppedResponse) override;

  void ActivateTriggers(const protos::ActivateTriggersRequest&,
                        DeferredActivateTriggersResponse) override;

  void GetAsyncCommand(const protos::GetAsyncCommandRequest&,
                       DeferredGetAsyncCommandResponse) override;
  void OnClientDisconnected() override;

 private:
  // Acts like a Producer with the core Service business logic (which doesn't
  // know anything about the remote transport), but all it does is proxying
  // methods to the remote Producer on the other side of the IPC channel.
  class RemoteProducer : public Producer {
   public:
    RemoteProducer();
    ~RemoteProducer() override;

    // These methods are called by the |core_service_| business logic. There is
    // no connection here, these methods are posted straight away.
    void OnConnect() override;
    void OnDisconnect() override;
    void SetupDataSource(DataSourceInstanceID,
                         const DataSourceConfig&) override;
    void StartDataSource(DataSourceInstanceID,
                         const DataSourceConfig&) override;
    void StopDataSource(DataSourceInstanceID) override;
    void OnTracingSetup() override;
    void Flush(FlushRequestID,
               const DataSourceInstanceID* data_source_ids,
               size_t num_data_sources) override;

    void ClearIncrementalState(const DataSourceInstanceID* data_source_ids,
                               size_t num_data_sources) override;

    // The interface obtained from the core service business logic through
    // Service::ConnectProducer(this). This allows to invoke methods for a
    // specific Producer on the Service business logic.
    std::unique_ptr<TracingService::ProducerEndpoint> service_endpoint;

    // The back-channel (based on a never ending stream request) that allows us
    // to send asynchronous commands to the remote Producer (e.g. start/stop a
    // data source).
    DeferredGetAsyncCommandResponse async_producer_commands;
  };

  ProducerIPCService(const ProducerIPCService&) = delete;
  ProducerIPCService& operator=(const ProducerIPCService&) = delete;

  // Returns the ProducerEndpoint in the core business logic that corresponds to
  // the current IPC request.
  RemoteProducer* GetProducerForCurrentRequest();

  TracingService* const core_service_;

  // Maps IPC clients to ProducerEndpoint instances registered on the
  // |core_service_| business logic.
  std::map<ipc::ClientID, std::unique_ptr<RemoteProducer>> producers_;

  base::WeakPtrFactory<ProducerIPCService> weak_ptr_factory_;  // Keep last.
};

}  // namespace perfetto

#endif  // SRC_TRACING_IPC_SERVICE_PRODUCER_IPC_SERVICE_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "src/tracing/ipc/service/producer_ipc_service.h"

#include <inttypes.h>

// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/base/task_runner.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/host.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/commit_data_request.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/tracing_service.h"
// gen_amalgamated expanded: #include "perfetto/tracing/core/data_source_config.h"
// gen_amalgamated expanded: #include "perfetto/tracing/core/data_source_descriptor.h"
// gen_amalgamated expanded: #include "src/tracing/ipc/posix_shared_memory.h"

// The remote Producer(s) are not trusted. All the methods from the ProducerPort
// IPC layer (e.g. RegisterDataSource()) must assume that the remote Producer is
// compromised.

namespace perfetto {

ProducerIPCService::ProducerIPCService(TracingService* core_service)
    : core_service_(core_service), weak_ptr_factory_(this) {}

ProducerIPCService::~ProducerIPCService() = default;

ProducerIPCService::RemoteProducer*
ProducerIPCService::GetProducerForCurrentRequest() {
  const ipc::ClientID ipc_client_id = ipc::Service::client_info().client_id();
  PERFETTO_CHECK(ipc_client_id);
  auto it = producers_.find(ipc_client_id);
  if (it == producers_.end())
    return nullptr;
  return it->second.get();
}

// Called by the remote Producer through the IPC channel soon after connecting.
void ProducerIPCService::InitializeConnection(
    const protos::InitializeConnectionRequest& req,
    DeferredInitializeConnectionResponse response) {
  const auto& client_info = ipc::Service::client_info();
  const ipc::ClientID ipc_client_id = client_info.client_id();
  PERFETTO_CHECK(ipc_client_id);

  if (producers_.count(ipc_client_id) > 0) {
    PERFETTO_DLOG(
        "The remote Producer is trying to re-initialize the connection");
    return response.Reject();
  }

  // Create a new entry.
  std::unique_ptr<RemoteProducer> producer(new RemoteProducer());

  TracingService::ProducerSMBScrapingMode smb_scraping_mode =
      TracingService::ProducerSMBScrapingMode::kDefault;
  switch (req.smb_scraping_mode()) {
    case protos::InitializeConnectionRequest::SMB_SCRAPING_UNSPECIFIED:
      break;
    case protos::InitializeConnectionRequest::SMB_SCRAPING_DISABLED:
      smb_scraping_mode = TracingService::ProducerSMBScrapingMode::kDisabled;
      break;
    case protos::InitializeConnectionRequest::SMB_SCRAPING_ENABLED:
      smb_scraping_mode = TracingService::ProducerSMBScrapingMode::kEnabled;
      break;
  }

  // ConnectProducer will call OnConnect() on the next task.
  producer->service_endpoint = core_service_->ConnectProducer(
      producer.get(), client_info.uid(), req.producer_name(),
      req.shared_memory_size_hint_bytes(), /*in_process=*/false,
      smb_scraping_mode);

  // Could happen if the service has too many producers connected.
  if (!producer->service_endpoint)
    response.Reject();

  producers_.emplace(ipc_client_id, std::move(producer));
  // Because of the std::move() |producer| is invalid after this point.

  auto async_res =
      ipc::AsyncResult<protos::InitializeConnectionResponse>::Create();
  response.Resolve(std::move(async_res));
}

// Called by the remote Producer through the IPC channel.
void ProducerIPCService::RegisterDataSource(
    const protos::RegisterDataSourceRequest& req,
    DeferredRegisterDataSourceResponse response) {
  RemoteProducer* producer = GetProducerForCurrentRequest();
  if (!producer) {
    PERFETTO_DLOG(
        "Producer invoked RegisterDataSource() before InitializeConnection()");
    if (response.IsBound())
      response.Reject();
    return;
  }

  DataSourceDescriptor dsd;
  dsd.FromProto(req.data_source_descriptor());
  GetProducerForCurrentRequest()->service_endpoint->RegisterDataSource(dsd);

  // RegisterDataSource doesn't expect any meaningful response.
  if (response.IsBound()) {
    response.Resolve(
        ipc::AsyncResult<protos::RegisterDataSourceResponse>::Create());
  }
}

// Called by the IPC layer.
void ProducerIPCService::OnClientDisconnected() {
  ipc::ClientID client_id = ipc::Service::client_info().client_id();
  PERFETTO_DLOG("Client %" PRIu64 " disconnected", client_id);
  producers_.erase(client_id);
}

// TODO(fmayer): test what happens if we receive the following tasks, in order:
// RegisterDataSource, UnregisterDataSource, OnDataSourceRegistered.
// which essentially means that the client posted back to back a
// ReqisterDataSource and UnregisterDataSource speculating on the next id.
// Called by the remote Service through the IPC channel.
void ProducerIPCService::UnregisterDataSource(
    const protos::UnregisterDataSourceRequest& req,
    DeferredUnregisterDataSourceResponse response) {
  RemoteProducer* producer = GetProducerForCurrentRequest();
  if (!producer) {
    PERFETTO_DLOG(
        "Producer invoked UnregisterDataSource() before "
        "InitializeConnection()");
    if (response.IsBound())
      response.Reject();
    return;
  }
  producer->service_endpoint->UnregisterDataSource(req.data_source_name());

  // UnregisterDataSource doesn't expect any meaningful response.
  if (response.IsBound()) {
    response.Resolve(
        ipc::AsyncResult<protos::UnregisterDataSourceResponse>::Create());
  }
}

void ProducerIPCService::RegisterTraceWriter(
    const protos::RegisterTraceWriterRequest& req,
    DeferredRegisterTraceWriterResponse response) {
  RemoteProducer* producer = GetProducerForCurrentRequest();
  if (!producer) {
    PERFETTO_DLOG(
        "Producer invoked RegisterTraceWriter() before "
        "InitializeConnection()");
    if (response.IsBound())
      response.Reject();
    return;
  }
  producer->service_endpoint->RegisterTraceWriter(req.trace_writer_id(),
                                                  req.target_buffer());

  // RegisterTraceWriter doesn't expect any meaningful response.
  if (response.IsBound()) {
    response.Resolve(
        ipc::AsyncResult<protos::RegisterTraceWriterResponse>::Create());
  }
}

void ProducerIPCService::UnregisterTraceWriter(
    const protos::UnregisterTraceWriterRequest& req,
    DeferredUnregisterTraceWriterResponse response) {
  RemoteProducer* producer = GetProducerForCurrentRequest();
  if (!producer) {
    PERFETTO_DLOG(
        "Producer invoked UnregisterTraceWriter() before "
        "InitializeConnection()");
    if (response.IsBound())
      response.Reject();
    return;
  }
  producer->service_endpoint->UnregisterTraceWriter(req.trace_writer_id());

  // UnregisterTraceWriter doesn't expect any meaningful response.
  if (response.IsBound()) {
    response.Resolve(
        ipc::AsyncResult<protos::UnregisterTraceWriterResponse>::Create());
  }
}

void ProducerIPCService::CommitData(const protos::CommitDataRequest& proto_req,
                                    DeferredCommitDataResponse resp) {
  RemoteProducer* producer = GetProducerForCurrentRequest();
  if (!producer) {
    PERFETTO_DLOG(
        "Producer invoked CommitData() before InitializeConnection()");
    if (resp.IsBound())
      resp.Reject();
    return;
  }
  CommitDataRequest req;
  req.FromProto(proto_req);

  // We don't want to send a response if the client didn't attach a callback to
  // the original request. Doing so would generate unnecessary wakeups and
  // context switches.
  std::function<void()> callback;
  if (resp.IsBound()) {
    // Capturing |resp| by reference here speculates on the fact that
    // CommitData() in tracing_service_impl.cc invokes the passed callback
    // inline, without posting it. If that assumption changes this code needs to
    // wrap the response in a shared_ptr (C+11 lambdas don't support move) and
    // use a weak ptr in the caller.
    callback = [&resp] {
      resp.Resolve(ipc::AsyncResult<protos::CommitDataResponse>::Create());
    };
  }
  producer->service_endpoint->CommitData(req, callback);
}

void ProducerIPCService::NotifyDataSourceStarted(
    const protos::NotifyDataSourceStartedRequest& request,
    DeferredNotifyDataSourceStartedResponse response) {
  RemoteProducer* producer = GetProducerForCurrentRequest();
  if (!producer) {
    PERFETTO_DLOG(
        "Producer invoked NotifyDataSourceStarted() before "
        "InitializeConnection()");
    if (response.IsBound())
      response.Reject();
    return;
  }
  producer->service_endpoint->NotifyDataSourceStarted(request.data_source_id());

  // NotifyDataSourceStopped shouldn't expect any meaningful response, avoid
  // a useless IPC in that case.
  if (response.IsBound()) {
    response.Resolve(
        ipc::AsyncResult<protos::NotifyDataSourceStartedResponse>::Create());
  }
}

void ProducerIPCService::NotifyDataSourceStopped(
    const protos::NotifyDataSourceStoppedRequest& request,
    DeferredNotifyDataSourceStoppedResponse response) {
  RemoteProducer* producer = GetProducerForCurrentRequest();
  if (!producer) {
    PERFETTO_DLOG(
        "Producer invoked NotifyDataSourceStopped() before "
        "InitializeConnection()");
    if (response.IsBound())
      response.Reject();
    return;
  }
  producer->service_endpoint->NotifyDataSourceStopped(request.data_source_id());

  // NotifyDataSourceStopped shouldn't expect any meaningful response, avoid
  // a useless IPC in that case.
  if (response.IsBound()) {
    response.Resolve(
        ipc::AsyncResult<protos::NotifyDataSourceStoppedResponse>::Create());
  }
}

void ProducerIPCService::ActivateTriggers(
    const protos::ActivateTriggersRequest& proto_req,
    DeferredActivateTriggersResponse resp) {
  RemoteProducer* producer = GetProducerForCurrentRequest();
  if (!producer) {
    PERFETTO_DLOG(
        "Producer invoked ActivateTriggers() before InitializeConnection()");
    if (resp.IsBound())
      resp.Reject();
    return;
  }
  std::vector<std::string> triggers;
  for (const auto& name : proto_req.trigger_names()) {
    triggers.push_back(name);
  }
  producer->service_endpoint->ActivateTriggers(triggers);
  // ActivateTriggers shouldn't expect any meaningful response, avoid
  // a useless IPC in that case.
  if (resp.IsBound()) {
    resp.Resolve(ipc::AsyncResult<protos::ActivateTriggersResponse>::Create());
  }
}

void ProducerIPCService::GetAsyncCommand(
    const protos::GetAsyncCommandRequest&,
    DeferredGetAsyncCommandResponse response) {
  RemoteProducer* producer = GetProducerForCurrentRequest();
  if (!producer) {
    PERFETTO_DLOG(
        "Producer invoked GetAsyncCommand() before "
        "InitializeConnection()");
    return response.Reject();
  }
  // Keep the back channel open, without ever resolving the ipc::Deferred fully,
  // to send async commands to the RemoteProducer (e.g., starting/stopping a
  // data source).
  producer->async_producer_commands = std::move(response);
}

////////////////////////////////////////////////////////////////////////////////
// RemoteProducer methods
////////////////////////////////////////////////////////////////////////////////

ProducerIPCService::RemoteProducer::RemoteProducer() = default;
ProducerIPCService::RemoteProducer::~RemoteProducer() = default;

// Invoked by the |core_service_| business logic after the ConnectProducer()
// call. There is nothing to do here, we really expected the ConnectProducer()
// to just work in the local case.
void ProducerIPCService::RemoteProducer::OnConnect() {}

// Invoked by the |core_service_| business logic after we destroy the
// |service_endpoint| (in the RemoteProducer dtor).
void ProducerIPCService::RemoteProducer::OnDisconnect() {}

// Invoked by the |core_service_| business logic when it wants to create a new
// data source.
void ProducerIPCService::RemoteProducer::SetupDataSource(
    DataSourceInstanceID dsid,
    const DataSourceConfig& cfg) {
  if (!async_producer_commands.IsBound()) {
    PERFETTO_DLOG(
        "The Service tried to create a new data source but the remote Producer "
        "has not yet initialized the connection");
    return;
  }
  auto cmd = ipc::AsyncResult<protos::GetAsyncCommandResponse>::Create();
  cmd.set_has_more(true);
  cmd->mutable_setup_data_source()->set_new_instance_id(dsid);
  cfg.ToProto(cmd->mutable_setup_data_source()->mutable_config());
  async_producer_commands.Resolve(std::move(cmd));
}

// Invoked by the |core_service_| business logic when it wants to start a new
// data source.
void ProducerIPCService::RemoteProducer::StartDataSource(
    DataSourceInstanceID dsid,
    const DataSourceConfig& cfg) {
  if (!async_producer_commands.IsBound()) {
    PERFETTO_DLOG(
        "The Service tried to start a new data source but the remote Producer "
        "has not yet initialized the connection");
    return;
  }
  auto cmd = ipc::AsyncResult<protos::GetAsyncCommandResponse>::Create();
  cmd.set_has_more(true);
  cmd->mutable_start_data_source()->set_new_instance_id(dsid);
  cfg.ToProto(cmd->mutable_start_data_source()->mutable_config());
  async_producer_commands.Resolve(std::move(cmd));
}

void ProducerIPCService::RemoteProducer::StopDataSource(
    DataSourceInstanceID dsid) {
  if (!async_producer_commands.IsBound()) {
    PERFETTO_DLOG(
        "The Service tried to stop a data source but the remote Producer "
        "has not yet initialized the connection");
    return;
  }
  auto cmd = ipc::AsyncResult<protos::GetAsyncCommandResponse>::Create();
  cmd.set_has_more(true);
  cmd->mutable_stop_data_source()->set_instance_id(dsid);
  async_producer_commands.Resolve(std::move(cmd));
}

void ProducerIPCService::RemoteProducer::OnTracingSetup() {
  if (!async_producer_commands.IsBound()) {
    PERFETTO_DLOG(
        "The Service tried to allocate the shared memory but the remote "
        "Producer has not yet initialized the connection");
    return;
  }
  PERFETTO_CHECK(service_endpoint->shared_memory());
  const int shm_fd =
      static_cast<PosixSharedMemory*>(service_endpoint->shared_memory())->fd();
  auto cmd = ipc::AsyncResult<protos::GetAsyncCommandResponse>::Create();
  cmd.set_has_more(true);
  cmd.set_fd(shm_fd);
  cmd->mutable_setup_tracing()->set_shared_buffer_page_size_kb(
      static_cast<uint32_t>(service_endpoint->shared_buffer_page_size_kb()));
  async_producer_commands.Resolve(std::move(cmd));
}

void ProducerIPCService::RemoteProducer::Flush(
    FlushRequestID flush_request_id,
    const DataSourceInstanceID* data_source_ids,
    size_t num_data_sources) {
  if (!async_producer_commands.IsBound()) {
    PERFETTO_DLOG(
        "The Service tried to request a flush but the remote Producer has not "
        "yet initialized the connection");
    return;
  }
  auto cmd = ipc::AsyncResult<protos::GetAsyncCommandResponse>::Create();
  cmd.set_has_more(true);
  for (size_t i = 0; i < num_data_sources; i++)
    cmd->mutable_flush()->add_data_source_ids(data_source_ids[i]);
  cmd->mutable_flush()->set_request_id(flush_request_id);
  async_producer_commands.Resolve(std::move(cmd));
}

void ProducerIPCService::RemoteProducer::ClearIncrementalState(
    const DataSourceInstanceID* data_source_ids,
    size_t num_data_sources) {
  if (!async_producer_commands.IsBound()) {
    PERFETTO_DLOG(
        "The Service tried to request an incremental state invalidation, but "
        "the remote Producer has not yet initialized the connection");
    return;
  }
  auto cmd = ipc::AsyncResult<protos::GetAsyncCommandResponse>::Create();
  cmd.set_has_more(true);
  for (size_t i = 0; i < num_data_sources; i++)
    cmd->mutable_clear_incremental_state()->add_data_source_ids(
        data_source_ids[i]);
  async_producer_commands.Resolve(std::move(cmd));
}

}  // namespace perfetto
// gen_amalgamated begin source: src/tracing/ipc/service/service_ipc_host_impl.cc
// gen_amalgamated begin header: src/tracing/ipc/service/service_ipc_host_impl.h
// gen_amalgamated begin header: include/perfetto/ext/tracing/ipc/service_ipc_host.h
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_EXT_TRACING_IPC_SERVICE_IPC_HOST_H_
#define INCLUDE_PERFETTO_EXT_TRACING_IPC_SERVICE_IPC_HOST_H_

#include <memory>

// gen_amalgamated expanded: #include "perfetto/ext/base/scoped_file.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/basic_types.h"

namespace perfetto {
namespace base {
class TaskRunner;
}  // namespace base.

class TracingService;

// Creates an instance of the service (business logic + UNIX socket transport).
// Exposed to:
//   The code in the tracing client that will host the service e.g., traced.
// Implemented in:
//   src/tracing/ipc/service/service_ipc_host_impl.cc
class ServiceIPCHost {
 public:
  static std::unique_ptr<ServiceIPCHost> CreateInstance(base::TaskRunner*);
  virtual ~ServiceIPCHost();

  // Start listening on the Producer & Consumer ports. Returns false in case of
  // failure (e.g., something else is listening on |socket_name|).
  virtual bool Start(const char* producer_socket_name,
                     const char* consumer_socket_name) = 0;

  // Like the above, but takes two file descriptors to already bound sockets.
  // This is used when building as part of the Android tree, where init opens
  // and binds the socket beore exec()-ing us.
  virtual bool Start(base::ScopedFile producer_socket_fd,
                     base::ScopedFile consumer_socket_fd) = 0;

  virtual TracingService* service() const = 0;

 protected:
  ServiceIPCHost();

 private:
  ServiceIPCHost(const ServiceIPCHost&) = delete;
  ServiceIPCHost& operator=(const ServiceIPCHost&) = delete;
};

}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_EXT_TRACING_IPC_SERVICE_IPC_HOST_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef SRC_TRACING_IPC_SERVICE_SERVICE_IPC_HOST_IMPL_H_
#define SRC_TRACING_IPC_SERVICE_SERVICE_IPC_HOST_IMPL_H_

#include <memory>

// gen_amalgamated expanded: #include "perfetto/ext/tracing/ipc/service_ipc_host.h"

namespace perfetto {

namespace ipc {
class Host;
}

// The implementation of the IPC host for the tracing service. This class does
// very few things: it mostly initializes the IPC transport. The actual
// implementation of the IPC <> Service business logic glue lives in
// producer_ipc_service.cc and consumer_ipc_service.cc.
class ServiceIPCHostImpl : public ServiceIPCHost {
 public:
  ServiceIPCHostImpl(base::TaskRunner*);
  ~ServiceIPCHostImpl() override;

  // ServiceIPCHost implementation.
  bool Start(const char* producer_socket_name,
             const char* consumer_socket_name) override;
  bool Start(base::ScopedFile producer_socket_fd,
             base::ScopedFile consumer_socket_fd) override;

  TracingService* service() const override;

 private:
  bool DoStart();
  void Shutdown();

  base::TaskRunner* const task_runner_;
  std::unique_ptr<TracingService> svc_;  // The service business logic.

  // The IPC host that listens on the Producer socket. It owns the
  // PosixServiceProducerPort instance which deals with all producers' IPC(s).
  std::unique_ptr<ipc::Host> producer_ipc_port_;

  // As above, but for the Consumer port.
  std::unique_ptr<ipc::Host> consumer_ipc_port_;
};

}  // namespace perfetto

#endif  // SRC_TRACING_IPC_SERVICE_SERVICE_IPC_HOST_IMPL_H_
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "src/tracing/ipc/service/service_ipc_host_impl.h"

// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/base/task_runner.h"
// gen_amalgamated expanded: #include "perfetto/ext/ipc/host.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/tracing_service.h"
// gen_amalgamated expanded: #include "src/tracing/ipc/posix_shared_memory.h"
// gen_amalgamated expanded: #include "src/tracing/ipc/service/consumer_ipc_service.h"
// gen_amalgamated expanded: #include "src/tracing/ipc/service/producer_ipc_service.h"

namespace perfetto {

// TODO(fmayer): implement per-uid connection limit (b/69093705).

// Implements the publicly exposed factory method declared in
// include/tracing/posix_ipc/posix_service_host.h.
std::unique_ptr<ServiceIPCHost> ServiceIPCHost::CreateInstance(
    base::TaskRunner* task_runner) {
  return std::unique_ptr<ServiceIPCHost>(new ServiceIPCHostImpl(task_runner));
}

ServiceIPCHostImpl::ServiceIPCHostImpl(base::TaskRunner* task_runner)
    : task_runner_(task_runner) {}

ServiceIPCHostImpl::~ServiceIPCHostImpl() {}

bool ServiceIPCHostImpl::Start(const char* producer_socket_name,
                               const char* consumer_socket_name) {
  PERFETTO_CHECK(!svc_);  // Check if already started.

  // Initialize the IPC transport.
  producer_ipc_port_ =
      ipc::Host::CreateInstance(producer_socket_name, task_runner_);
  consumer_ipc_port_ =
      ipc::Host::CreateInstance(consumer_socket_name, task_runner_);
  return DoStart();
}

bool ServiceIPCHostImpl::Start(base::ScopedFile producer_socket_fd,
                               base::ScopedFile consumer_socket_fd) {
  PERFETTO_CHECK(!svc_);  // Check if already started.

  // Initialize the IPC transport.
  producer_ipc_port_ =
      ipc::Host::CreateInstance(std::move(producer_socket_fd), task_runner_);
  consumer_ipc_port_ =
      ipc::Host::CreateInstance(std::move(consumer_socket_fd), task_runner_);
  return DoStart();
}

bool ServiceIPCHostImpl::DoStart() {
  // Create and initialize the platform-independent tracing business logic.
  std::unique_ptr<SharedMemory::Factory> shm_factory(
      new PosixSharedMemory::Factory());
  svc_ = TracingService::CreateInstance(std::move(shm_factory), task_runner_);

  if (!producer_ipc_port_ || !consumer_ipc_port_) {
    Shutdown();
    return false;
  }

  // TODO(fmayer): add a test that destroyes the ServiceIPCHostImpl soon after
  // Start() and checks that no spurious callbacks are issued.
  bool producer_service_exposed = producer_ipc_port_->ExposeService(
      std::unique_ptr<ipc::Service>(new ProducerIPCService(svc_.get())));
  PERFETTO_CHECK(producer_service_exposed);

  bool consumer_service_exposed = consumer_ipc_port_->ExposeService(
      std::unique_ptr<ipc::Service>(new ConsumerIPCService(svc_.get())));
  PERFETTO_CHECK(consumer_service_exposed);

  return true;
}

TracingService* ServiceIPCHostImpl::service() const {
  return svc_.get();
}

void ServiceIPCHostImpl::Shutdown() {
  // TODO(primiano): add a test that causes the Shutdown() and checks that no
  // spurious callbacks are issued.
  producer_ipc_port_.reset();
  consumer_ipc_port_.reset();
  svc_.reset();
}

// Definitions for the base class ctor/dtor.
ServiceIPCHost::ServiceIPCHost() = default;
ServiceIPCHost::~ServiceIPCHost() = default;

}  // namespace perfetto
// gen_amalgamated begin source: src/tracing/data_source.cc
// gen_amalgamated begin header: include/perfetto/tracing/data_source.h
// gen_amalgamated begin header: include/perfetto/tracing/internal/basic_types.h
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_TRACING_INTERNAL_BASIC_TYPES_H_
#define INCLUDE_PERFETTO_TRACING_INTERNAL_BASIC_TYPES_H_

#include <stddef.h>
#include <stdint.h>

namespace perfetto {
namespace internal {

// A static_assert in tracing_muxer_impl.cc guarantees that this stays in sync
// with the definition in tracing/core/basic_types.h
using BufferId = uint16_t;

// This is a direct index in the TracingMuxer::backends_ vector.
// Backends are only added and never removed.
using TracingBackendId = size_t;

// Max numbers of data sources that can be registered in a process.
constexpr size_t kMaxDataSources = 32;

// Max instances for each data source type. This typically matches the
// "max number of concurrent tracing sessions". However remember that a data
// source can be instantiated more than once within one tracing session by
// creating two entries for it in the trace config.
constexpr size_t kMaxDataSourceInstances = 8;

}  // namespace internal
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_TRACING_INTERNAL_BASIC_TYPES_H_
// gen_amalgamated begin header: include/perfetto/tracing/internal/data_source_internal.h
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_TRACING_INTERNAL_DATA_SOURCE_INTERNAL_H_
#define INCLUDE_PERFETTO_TRACING_INTERNAL_DATA_SOURCE_INTERNAL_H_

#include <stddef.h>
#include <stdint.h>

#include <array>
#include <atomic>
#include <functional>
#include <memory>
#include <mutex>

// No perfetto headers (other than tracing/api and protozero) should be here.
// gen_amalgamated expanded: #include "perfetto/tracing/internal/basic_types.h"
// gen_amalgamated expanded: #include "perfetto/tracing/trace_writer_base.h"

namespace perfetto {

class DataSourceBase;
class TraceWriterBase;

namespace internal {

class TracingTLS;

// This maintains the internal state of a data source instance that is used only
// to implement the tracing mechanics and is not exposed to the API client.
// There is one of these object per DataSource instance (up to
// kMaxDataSourceInstances).
struct DataSourceState {
  // If false the data source is initialized but not started yet (or stopped).
  // This is set right before calling OnStart() and cleared right before calling
  // OnStop()
  bool started = false;

  // The central buffer id that all TraceWriter(s) created by this data source
  // must target.
  BufferId buffer_id = 0;

  // The index within TracingMuxerImpl.backends_. Practically it allows to
  // lookup the Producer object, and hence the IPC channel, for this data
  // source.
  TracingBackendId backend_id = 0;

  // The instance id as assigned by the tracing service. Note that because a
  // process can be connected to >1 services, this ID is not globally unique but
  // is only unique within the scope of its backend.
  // Only the tuple (backend_id, data_source_instance_id) is globally unique.
  uint64_t data_source_instance_id = 0;

  // This lock is not held to implement Trace() and it's used only if the trace
  // code wants to access its own data source state.
  // This is to prevent that accessing the data source on an arbitrary embedder
  // thread races with the internal IPC thread destroying the data source
  // because of a end-of-tracing notification from the service.
  std::mutex lock;
  std::unique_ptr<DataSourceBase> data_source;
};

// This is to allow lazy-initialization and avoid static initializers and
// at-exit destructors. All the entries are initialized via placement-new when
// DataSource::Register() is called, see TracingMuxerImpl::RegisterDataSource().
struct DataSourceStateStorage {
  alignas(DataSourceState) char storage[sizeof(DataSourceState)]{};
};

// Per-DataSource-type global state.
struct DataSourceStaticState {
  uint32_t index = 0;  // Unique ID, assigned at registration time.

  // A bitmap that tells about the validity of each |instances| entry. When the
  // i-th bit of the bitmap it's set, instances[i] is valid.
  std::atomic<uint32_t> valid_instances{};
  std::array<DataSourceStateStorage, kMaxDataSourceInstances> instances{};

  // Can be used with a cached |valid_instances| bitmap.
  DataSourceState* TryGetCached(uint32_t cached_bitmap, size_t n) {
    return cached_bitmap & (1 << n)
               ? reinterpret_cast<DataSourceState*>(&instances[n])
               : nullptr;
  }

  DataSourceState* TryGet(size_t n) {
    return TryGetCached(valid_instances.load(std::memory_order_acquire), n);
  }

  void CompilerAsserts() {
    static_assert(sizeof(valid_instances.load()) * 8 >= kMaxDataSourceInstances,
                  "kMaxDataSourceInstances too high");
  }
};

// Per-DataSource-instance thread-local state.
struct DataSourceInstanceThreadLocalState {
  void Reset() {
    trace_writer.reset();
    backend_id = 0;
    buffer_id = 0;
  }

  std::unique_ptr<TraceWriterBase> trace_writer;
  TracingBackendId backend_id;
  BufferId buffer_id;
};

// Per-DataSource-type thread-local state.
struct DataSourceThreadLocalState {
  DataSourceStaticState* static_state = nullptr;

  // Pointer to the parent tls object that holds us. Used to retrieve the
  // generation, which is per-global-TLS and not per data-source.
  TracingTLS* root_tls = nullptr;

  // One entry per each data source instance.
  std::array<DataSourceInstanceThreadLocalState, kMaxDataSourceInstances>
      per_instance{};
};

}  // namespace internal
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_TRACING_INTERNAL_DATA_SOURCE_INTERNAL_H_
// gen_amalgamated begin header: include/perfetto/tracing/internal/tracing_muxer.h
// gen_amalgamated begin header: include/perfetto/tracing/internal/tracing_tls.h
// gen_amalgamated begin header: include/perfetto/tracing/platform.h
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_TRACING_PLATFORM_H_
#define INCLUDE_PERFETTO_TRACING_PLATFORM_H_

#include <stddef.h>
#include <stdint.h>

#include <functional>
#include <memory>

namespace perfetto {

namespace base {
class TaskRunner;
}  // namespace base

// This abstract class is used to abstract dependencies on platform-specific
// primitives that cannot be implemented by the perfetto codebase and must be
// provided or overridden by the embedder.
// This is, for instance, for cases where we want to use some particular
// base:: class in Chrome and provide instead POSIX fallbacks for other
// embedders.

// Base class for thread-local objects. This is to get a basic object vtable and
// delegate destruction to the embedder. See Platform::CreateThreadLocalObject.
class PlatformThreadLocalObject {
 public:
  // Implemented by perfetto internal code. The embedder must call this when
  // implementing GetOrCreateThreadLocalObject() to create an instance for the
  // first time on each thread.
  static std::unique_ptr<PlatformThreadLocalObject> CreateInstance();
  virtual ~PlatformThreadLocalObject();
};

class Platform {
 public:
  // Embedders can use this unless they have custom needs (e.g. Chrome wanting
  // to use its own base class for TLS).
  static Platform* GetDefaultPlatform();

  virtual ~Platform();

  // Creates a thread-local object. The embedder must:
  // - Create an instance per-thread calling ThreadLocalObject::CreateInstance.
  // - Own the lifetime of the returned object as long as the thread is alive.
  // - Destroy it when the thread exits.
  // Perfetto requires only one thread-local object overall (obviously, one
  // instance per-thread) from the embedder.
  using ThreadLocalObject = ::perfetto::PlatformThreadLocalObject;
  virtual ThreadLocalObject* GetOrCreateThreadLocalObject() = 0;

  // Creates a sequenced task runner. The easiest implementation is to create
  // a new thread (e.g. use base::ThreadTaskRunner) but this can also be
  // implemented in some more clever way (e.g. using chromiums's scheduler).
  struct CreateTaskRunnerArgs {};
  virtual std::unique_ptr<base::TaskRunner> CreateTaskRunner(
      const CreateTaskRunnerArgs&) = 0;

  // Used to derive the producer name. Mostly relevant when using the
  // kSystemBackend mode. It can be an arbitrary string when using the
  // in-process mode.
  virtual std::string GetCurrentProcessName() = 0;
};

}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_TRACING_PLATFORM_H_
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_TRACING_INTERNAL_TRACING_TLS_H_
#define INCLUDE_PERFETTO_TRACING_INTERNAL_TRACING_TLS_H_

#include <array>
#include <memory>

// gen_amalgamated expanded: #include "perfetto/tracing/internal/basic_types.h"
// gen_amalgamated expanded: #include "perfetto/tracing/internal/data_source_internal.h"
// gen_amalgamated expanded: #include "perfetto/tracing/platform.h"

namespace perfetto {

class TraceWriterBase;

namespace internal {

// Organization of the thread-local storage
// ----------------------------------------
// First of all, remember the cardinality of the problem: at any point in time
// there are M data sources registered (i.e. number of subclasses of DataSource)
// and up to N concurrent instances for each data source, so up to M * N total
// data source instances around.
// Each data source instance can be accessed by T threads (no upper bound).
// We can safely put hard limits both to M and N (i.e. say that we support at
// most 32 data source types per process and up to 8 concurrent instances).
//
// We want to make it so from the Platform viewpoint, we use only one global
// TLS object, so T instances in total, one per thread, regardless of M and N.
// This allows to deal with at-thread-exit destruction only in one place, rather
// than N, M or M * N.
//
// Visually:
//                     [    Thread 1   ] [    Thread 2   ] [    Thread T   ]
//                     +---------------+ +---------------+ +---------------+
// Data source Foo     |               | |               | |               |
//  Instance 1         |     TLS       | |     TLS       | |     TLS       |
//  Instance 2         |    Object     | |    Object     | |    Object     |
//  Instance 3         |               | |               | |               |
//                     |               | |               | |               |
// Data source Bar     |               | |               | |               |
//  Instance 1         |               | |               | |               |
//  Instance 2         |               | |               | |               |
//                     +---------------+ +---------------+ +---------------+
//
// Each TLS Object is organized as an array of M DataSourceThreadLocalState.
// Each DSTLS itself is an array of up to N per-instance objects.
// The only per-instance object for now is the TraceWriter.
// So for each data source, for each instance, for each thread we keep one
// TraceWriter.
// The lookup is O(1): Given the TLS object, the TraceWriter is just tls[M][N].
class TracingTLS : public Platform::ThreadLocalObject {
 public:
  ~TracingTLS() override;

  // This is checked against TraceMuxerImpl's global generation counter to
  // handle destruction of TraceWriter(s) that belong to data sources that
  // have been stopped. When the two numbers diverge, a scan of all the
  // thread-local TraceWriter(s) is issued.
  uint32_t generation = 0;

  std::array<DataSourceThreadLocalState, kMaxDataSources> data_sources_tls{};
};

}  // namespace internal
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_TRACING_INTERNAL_TRACING_TLS_H_
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_TRACING_INTERNAL_TRACING_MUXER_H_
#define INCLUDE_PERFETTO_TRACING_INTERNAL_TRACING_MUXER_H_

#include <atomic>
#include <memory>

// gen_amalgamated expanded: #include "perfetto/tracing/internal/basic_types.h"
// gen_amalgamated expanded: #include "perfetto/tracing/internal/tracing_tls.h"
// gen_amalgamated expanded: #include "perfetto/tracing/platform.h"

namespace perfetto {

class DataSourceBase;
class DataSourceDescriptor;
class TraceWriterBase;
struct TracingInitArgs;
class TracingSession;

namespace internal {

struct DataSourceStaticState;

// This class acts as a bridge between the public API methods and the
// TracingBackend(s). It exposes a simplified view of the world to the API
// methods, so that they don't have to care about the multiplicity of backends.
// It handles all the bookkeeping to map data source instances and trace writers
// to the various backends.
// See tracing_muxer_impl.h for the full picture. This class contains only the
// fewer fields and methods that need to be exposed to public/ headers. Fields
// and methods that are required to implement them should go into
// src/tracing/internal/tracing_muxer_impl.h instead: that one can pull in
// perfetto headers outside of public, this one cannot.
class TracingMuxer {
 public:
  static TracingMuxer* Get() { return instance_; }

  virtual ~TracingMuxer();

  TracingTLS* GetOrCreateTracingTLS() {
    return static_cast<TracingTLS*>(platform_->GetOrCreateThreadLocalObject());
  }

  // Note that the returned object is one per-thread per-data-source-type, NOT
  // per data-soruce *instance*.
  DataSourceThreadLocalState* GetOrCreateDataSourceTLS(
      DataSourceStaticState* static_state) {
    TracingTLS* root_tls = GetOrCreateTracingTLS();
    auto* ds_tls = &root_tls->data_sources_tls[static_state->index];

    // The per-type TLS is either zero-initialized or must have been initialized
    // for this specific data source type. We keep re-initializing as the
    // initialization is idempotent and not worth the code for extra checks.
    assert(!ds_tls->static_state || ds_tls->static_state == static_state);
    ds_tls->static_state = static_state;
    assert(!ds_tls->root_tls || ds_tls->root_tls == root_tls);
    ds_tls->root_tls = root_tls;
    return ds_tls;
  }

  // This method can fail and return false if trying to register more than
  // kMaxDataSources types.
  using DataSourceFactory = std::function<std::unique_ptr<DataSourceBase>()>;
  virtual bool RegisterDataSource(const DataSourceDescriptor&,
                                  DataSourceFactory,
                                  DataSourceStaticState*) = 0;

  // It identifies the right backend and forwards the call to it.
  // The returned TraceWriter must be used within the same sequence (for most
  // projects this means "same thread"). Alternatively the client needs to take
  // care of using synchronization primitives to prevent concurrent accesses.
  virtual std::unique_ptr<TraceWriterBase> CreateTraceWriter(
      DataSourceState*) = 0;

  virtual void DestroyStoppedTraceWritersForCurrentThread() = 0;

  uint32_t generation(std::memory_order ord) { return generation_.load(ord); }

 protected:
  explicit TracingMuxer(Platform* platform) : platform_(platform) {}

  static TracingMuxer* instance_;
  Platform* const platform_ = nullptr;

  // Incremented upon each data source stop. See comment in tracing_tls.h.
  std::atomic<uint32_t> generation_{};
};

}  // namespace internal
}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_TRACING_INTERNAL_TRACING_MUXER_H_
// gen_amalgamated begin header: include/perfetto/tracing/locked_handle.h
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_TRACING_LOCKED_HANDLE_H_
#define INCLUDE_PERFETTO_TRACING_LOCKED_HANDLE_H_

#include <mutex>

namespace perfetto {

// This is used for GetDataSourceLocked(), in the (rare) case where the
// tracing code wants to access the state of its data source from the Trace()
// method.
template <typename T>
class LockedHandle {
 public:
  LockedHandle(std::mutex* mutex, T* obj) : lock_(*mutex), obj_(obj) {}
  LockedHandle() = default;  // For the invalid case.
  LockedHandle(LockedHandle&&) = default;
  LockedHandle& operator=(LockedHandle&&) = default;

  bool valid() const { return obj_; }
  explicit operator bool() const { return valid(); }

  T* operator->() {
    assert(valid());
    return obj_;
  }

  T& operator*() { return *(this->operator->()); }

 private:
  std::unique_lock<std::mutex> lock_;
  T* obj_ = nullptr;
};

}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_TRACING_LOCKED_HANDLE_H_
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_TRACING_DATA_SOURCE_H_
#define INCLUDE_PERFETTO_TRACING_DATA_SOURCE_H_

// This header contains the key class (DataSource) that a producer app should
// override in order to create a custom data source that gets tracing Start/Stop
// notifications and emits tracing data.

#include <assert.h>
#include <stddef.h>
#include <stdint.h>

#include <array>
#include <atomic>
#include <functional>
#include <memory>
#include <mutex>

// gen_amalgamated expanded: #include "perfetto/base/compiler.h"
// gen_amalgamated expanded: #include "perfetto/protozero/message.h"
// gen_amalgamated expanded: #include "perfetto/protozero/message_handle.h"
// gen_amalgamated expanded: #include "perfetto/trace/trace_packet.pbzero.h"
// gen_amalgamated expanded: #include "perfetto/tracing/internal/basic_types.h"
// gen_amalgamated expanded: #include "perfetto/tracing/internal/data_source_internal.h"
// gen_amalgamated expanded: #include "perfetto/tracing/internal/tracing_muxer.h"
// gen_amalgamated expanded: #include "perfetto/tracing/locked_handle.h"
// gen_amalgamated expanded: #include "perfetto/tracing/trace_writer_base.h"

namespace perfetto {

class DataSourceConfig;

// Base class with the virtual methods to get start/stop notifications.
// Embedders are supposed to derive the templated version below, not this one.
class DataSourceBase {
 public:
  virtual ~DataSourceBase();

  // OnSetup() is invoked when tracing is configured. In most cases this happens
  // just before starting the trace. In the case of deferred start (see
  // deferred_start in trace_config.proto) start might happen later.
  struct SetupArgs {
    // This is valid only within the scope of the OnSetup() call and must not
    // be retained.
    const DataSourceConfig* config = nullptr;
  };
  virtual void OnSetup(const SetupArgs&);

  struct StartArgs {};
  virtual void OnStart(const StartArgs&);

  struct StopArgs {};
  virtual void OnStop(const StopArgs&);
};

// Templated base class meant to be derived by embedders to create a custom data
// source. DataSourceType must be the type of the derived class itself, e.g.:
// class MyDataSource : public DataSourceBase<MyDataSource> {...}.
template <typename DataSourceType>
class DataSource : public DataSourceBase {
 public:
  // Argument passed to the lambda function passed to Trace() (below).
  class TraceContext {
   public:
    using TracePacketHandle =
        ::protozero::MessageHandle<::perfetto::protos::pbzero::TracePacket>;

    TraceContext(TraceContext&&) noexcept = default;
    ~TraceContext() = default;

    TracePacketHandle NewTracePacket() {
      return trace_writer_->NewTracePacket();
    }

    // Returns a RAII handle to access the data source instance, guaranteeing
    // that it won't be deleted on another thread (because of trace stopping)
    // while accessing it from within the Trace() lambda.
    // The returned handle can be invalid (nullptr) if tracing is stopped
    // immediately before calling this. The caller is supposed to check for its
    // validity before using it. After checking, the handle is guaranteed to
    // remain valid until the handle goes out of scope.
    LockedHandle<DataSourceType> GetDataSourceLocked() {
      auto* internal_state = static_state_.TryGet(instance_index_);
      if (!internal_state)
        return LockedHandle<DataSourceType>();
      return LockedHandle<DataSourceType>(
          &internal_state->lock,
          static_cast<DataSourceType*>(internal_state->data_source.get()));
    }

   private:
    friend class DataSource;
    TraceContext(TraceWriterBase* trace_writer, uint32_t instance_index)
        : trace_writer_(trace_writer), instance_index_(instance_index) {}
    TraceContext(const TraceContext&) = delete;
    TraceContext& operator=(const TraceContext&) = delete;

    TraceWriterBase* const trace_writer_;
    uint32_t const instance_index_;
  };

  // The main tracing method. Tracing code should call this passing a lambda as
  // argument, with the following signature: void(TraceContext).
  // The lambda will be called synchronously (i.e., always before Trace()
  // returns) only if tracing is enabled and the data source has been enabled in
  // the tracing config.
  // The lambda can be called more than once per Trace() call, in the case of
  // concurrent tracing sessions (or even if the data source is instantiated
  // twice within the same trace config).
  template <typename Lambda>
  static void Trace(Lambda tracing_fn) {
    constexpr auto kMaxDataSourceInstances = internal::kMaxDataSourceInstances;

    // |instances| is a per-class bitmap that tells:
    // 1. If the data source is enabled at all.
    // 2. The index of the slot within |valid_instances| that holds the instance
    //    state. In turn this allows to map the data source to the tracing
    //    session and buffers.
    // memory_order_relaxed is okay because:
    // - |instances| is re-read with an acquire barrier below if this succeeds.
    // - The code between this point and the acquire-load is based on static
    //    storage which has indefinite lifetime.
    auto instances =
        static_state_.valid_instances.load(std::memory_order_relaxed);

    // This is the tracing fast-path. Bail out immediately if tracing is not
    // enabled (or tracing is enabled but not for this data source).
    if (PERFETTO_LIKELY(!instances))
      return;

    // TODO(primiano): all the stuff below should be outlined. Or at least
    // we should have some compile-time traits like kOptimizeBinarySize /
    // kOptimizeTracingLatency.

    // See tracing_muxer.h for the structure of the TLS.
    auto* tracing_impl = internal::TracingMuxer::Get();
    if (PERFETTO_UNLIKELY(!tls_state_))
      tls_state_ = tracing_impl->GetOrCreateDataSourceTLS(&static_state_);

    // TracingTLS::generation is a global monotonic counter that is incremented
    // every time a tracing session is stopped. We use that as a signal to force
    // a slow-path garbage collection of all the trace writers for the current
    // thread and to destroy the ones that belong to tracing sessions that have
    // ended. This is to avoid having too many TraceWriter instances alive, each
    // holding onto one chunk of the shared memory buffer.
    // Rationale why memory_order_relaxed should be fine:
    // - The TraceWriter object that we use is always constructed and destructed
    //   on the current thread. There is no risk of accessing a half-initialized
    //   TraceWriter (which would be really bad).
    // - In the worst case, in the case of a race on the generation check, we
    //   might end up using a TraceWriter for the same data source that belongs
    //   to a stopped session. This is not really wrong, as we don't give any
    //   guarantee on the global atomicity of the stop. In the worst case the
    //   service will reject the data commit if this arrives too late.

    if (PERFETTO_UNLIKELY(
            tls_state_->root_tls->generation !=
            tracing_impl->generation(std::memory_order_relaxed))) {
      // Will update root_tls->generation.
      tracing_impl->DestroyStoppedTraceWritersForCurrentThread();
    }

    for (uint32_t i = 0; i < kMaxDataSourceInstances; i++) {
      internal::DataSourceState* instance_state =
          static_state_.TryGetCached(instances, i);
      if (!instance_state)
        continue;

      // Even if we passed the check above, the DataSourceInstance might be
      // still destroyed concurrently while this code runs. The code below is
      // designed to deal with such race, as follows:
      // - We don't access the user-defined data source instance state. The only
      //   bits of state we use are |backend_id| and |buffer_id|.
      // - Beyond those two integers, we access only the TraceWriter here. The
      //   TraceWriter is always safe because it lives on the TLS.
      // - |instance_state| is backed by static storage, so the pointer is
      //   always valid, even after the data source instance is destroyed.
      // - In the case of a race-on-destruction, we'll still see the latest
      //   backend_id and buffer_id and in the worst case keep trying writing
      //   into the tracing shared memory buffer after stopped. But this isn't
      //   really any worse than the case of the stop IPC being delayed by the
      //   kernel scheduler. The tracing service is robust against data commit
      //   attemps made after tracing is stopped.
      // There is a theoretical race that would case the wrong behavior w.r.t
      // writing data in the wrong buffer, but it's so rare that we ignore it:
      // if the data source is stopped and started kMaxDataSourceInstances
      // times (so that the same id is recycled) while we are in this function,
      // we might end up reusing the old data source's backend_id and buffer_id
      // for the new one, because we don't see the generation change past this
      // point. But stopping and starting tracing (even once) takes so much
      // handshaking to make this extremely unrealistic.

      auto& tls_inst = tls_state_->per_instance[i];
      TraceWriterBase* trace_writer = tls_inst.trace_writer.get();

      if (PERFETTO_UNLIKELY(!trace_writer)) {
        // Here we need an acquire barrier, which matches the release-store made
        // by TracingMuxerImpl::SetupDataSource(), to ensure that the backend_id
        // and buffer_id are consistent.
        instances =
            static_state_.valid_instances.load(std::memory_order_acquire);
        instance_state = static_state_.TryGetCached(instances, i);
        if (!instance_state || !instance_state->started)
          return;
        tls_inst.backend_id = instance_state->backend_id;
        tls_inst.buffer_id = instance_state->buffer_id;
        tls_inst.trace_writer = tracing_impl->CreateTraceWriter(instance_state);
        trace_writer = tls_inst.trace_writer.get();

        // Even in the case of out-of-IDs, SharedMemoryArbiterImpl returns a
        // NullTraceWriter. The returned pointer should never be null.
        assert(trace_writer);
      }

      tracing_fn(TraceContext(trace_writer, i));
    }
  }

  // Registers the data source on all tracing backends, including ones that
  // connect after the registration. Doing so enables the data source to receive
  // Setup/Start/Stop notifications and makes the Trace() method work when
  // tracing is enabled and the data source is selected.
  // This must be called after Tracing::Initialize().
  // The caller must also use the DEFINE_DATA_SOURCE_STATIC_MEMBERS() macro
  // documented below.
  // Can return false to signal failure if attemping to register more than
  // kMaxDataSources (32) data sources types.
  static bool Register(const DataSourceDescriptor& descriptor) {
    // Silences -Wunused-variable warning in case the trace method is not used
    // by the translation unit that declares the data source.
    (void)static_state_;
    (void)tls_state_;

    auto factory = [] {
      return std::unique_ptr<DataSourceBase>(new DataSourceType());
    };
    auto* tracing_impl = internal::TracingMuxer::Get();
    return tracing_impl->RegisterDataSource(descriptor, factory,
                                            &static_state_);
  }

  // Static state. Accessed by the static Trace() method fastpaths.
  static internal::DataSourceStaticState static_state_;

  // This TLS object is a cached raw pointer and has deliberately no destructor.
  // The Platform implementation is supposed to create and manage the lifetime
  // of the Platform::ThreadLocalObject and take care of destroying it.
  // This is because non-POD thread_local variables have subtleties (global
  // destructors) that we need to defer to the embedder. In chromium's platform
  // implementation, for instance, the tls slot is implemented using
  // chromium's base::ThreadLocalStorage.
  static thread_local internal::DataSourceThreadLocalState* tls_state_;
};

}  // namespace perfetto

// The API client must use this in a translation unit. This is because it needs
// to instantiate the static storage for the datasource to allow the fastpath
// enabled check.
#define PERFETTO_DEFINE_DATA_SOURCE_STATIC_MEMBERS(X)          \
  template <>                                                  \
  perfetto::internal::DataSourceStaticState                    \
      perfetto::DataSource<X>::static_state_{};                \
  template <>                                                  \
  thread_local perfetto::internal::DataSourceThreadLocalState* \
      perfetto::DataSource<X>::tls_state_ = nullptr

#endif  // INCLUDE_PERFETTO_TRACING_DATA_SOURCE_H_
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "perfetto/tracing/data_source.h"

namespace perfetto {

DataSourceBase::~DataSourceBase() = default;
void DataSourceBase::OnSetup(const SetupArgs&) {}
void DataSourceBase::OnStart(const StartArgs&) {}
void DataSourceBase::OnStop(const StopArgs&) {}

}  // namespace perfetto
// gen_amalgamated begin source: src/tracing/internal/in_process_tracing_backend.cc
// gen_amalgamated begin header: src/tracing/internal/in_process_tracing_backend.h
// gen_amalgamated begin header: include/perfetto/tracing/tracing_backend.h
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_TRACING_TRACING_BACKEND_H_
#define INCLUDE_PERFETTO_TRACING_TRACING_BACKEND_H_

#include <memory>
#include <string>

// The embedder can (but doesn't have to) extend the TracingBackend class and
// pass as an argument to Tracing::Initialize(kCustomBackend) to override the
// way to reach the service. This is for peculiar cases where the embedder has
// a multi-process architecture and wants to override the IPC transport. The
// real use-case for this at the time of writing is chromium (+ Mojo IPC).
// Extending this class requires depending on the full set of perfetto headers
// (not just /public/). Contact the team before doing so as the non-public
// headers are not guaranteed to be API stable.

namespace perfetto {

namespace base {
class TaskRunner;
}

// These classes are declared in headers outside of /public/.
class Consumer;
class ConsumerEndpoint;
class Producer;
class ProducerEndpoint;

class TracingBackend {
 public:
  virtual ~TracingBackend();

  // Connects a Producer instance and obtains a ProducerEndpoint, which is
  // essentially a 1:1 channel between one Producer and the Service.
  // To disconnect just destroy the returned endpoint object. It is safe to
  // destroy the Producer once Producer::OnDisconnect() has been invoked.
  struct ConnectProducerArgs {
    std::string producer_name;

    // The Producer object that will receive calls like Start/StopDataSource().
    // The caller has to guarantee that this object is valid as long as the
    // returned ProducerEndpoint is alive.
    Producer* producer{};

    // The task runner where the Producer methods will be called onto.
    // The caller has to guarantee that the passed TaskRunner is valid as long
    // as the returned ProducerEndpoint is alive.
    ::perfetto::base::TaskRunner* task_runner{};
  };
  virtual std::unique_ptr<ProducerEndpoint> ConnectProducer(
      const ConnectProducerArgs&) = 0;

  // As above, for the Consumer-side.
  struct ConnectConsumerArgs {
    // The Consumer object that will receive calls like OnTracingDisabled(),
    // OnTraceData().
    Consumer* consumer{};

    // The task runner where the Consumer methods will be called onto.
    ::perfetto::base::TaskRunner* task_runner{};
  };
  virtual std::unique_ptr<ConsumerEndpoint> ConnectConsumer(
      const ConnectConsumerArgs&) = 0;
};

}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_TRACING_TRACING_BACKEND_H_
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef SRC_TRACING_INTERNAL_IN_PROCESS_TRACING_BACKEND_H_
#define SRC_TRACING_INTERNAL_IN_PROCESS_TRACING_BACKEND_H_

// gen_amalgamated expanded: #include "perfetto/tracing/tracing_backend.h"

namespace perfetto {

namespace base {
class TaskRunner;
}

class Producer;
class TracingService;

namespace internal {

// A built-in implementation of TracingBackend that creates a tracing service
// instance in-process. Instantiated when the embedder calls
// Tracing::Initialize(kInProcessBackend). Solves most in-app-only tracing
// use-cases.
class InProcessTracingBackend : public TracingBackend {
 public:
  static InProcessTracingBackend* GetInstance();

  // TracingBackend implementation.
  std::unique_ptr<ProducerEndpoint> ConnectProducer(
      const ConnectProducerArgs&) override;
  std::unique_ptr<ConsumerEndpoint> ConnectConsumer(
      const ConnectConsumerArgs&) override;

 private:
  InProcessTracingBackend();
  TracingService* GetOrCreateService(base::TaskRunner*);

  std::unique_ptr<TracingService> service_;
};

}  // namespace internal
}  // namespace perfetto

#endif  // SRC_TRACING_INTERNAL_IN_PROCESS_TRACING_BACKEND_H_
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "src/tracing/internal/in_process_tracing_backend.h"

// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/base/task_runner.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/paged_memory.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/shared_memory.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/tracing_service.h"

// TODO(primiano): When the in-process backend is used, we should never end up
// in a situation where the thread where the TracingService and Producer live
// writes a packet and hence can get into the GetNewChunk() stall.
// This would happen only if the API client code calls Trace() from one of the
// callbacks it receives (e.g. OnStart(), OnStop()). We should either cause a
// hard crash or ignore traces from that thread if that happens, because it
// will deadlock (the Service will never free up the SMB because won't ever get
// to run the task).

namespace perfetto {
namespace internal {

namespace {

class InProcessShm : public SharedMemory {
 public:
  explicit InProcessShm(size_t size);
  ~InProcessShm() override;
  void* start() const override;
  size_t size() const override;

 private:
  base::PagedMemory mem_;
};

class InProcessShmFactory : public SharedMemory::Factory {
 public:
  ~InProcessShmFactory() override;
  std::unique_ptr<SharedMemory> CreateSharedMemory(size_t) override;
};

InProcessShm::~InProcessShm() = default;

InProcessShm::InProcessShm(size_t size)
    : mem_(base::PagedMemory::Allocate(size)) {}

void* InProcessShm::start() const {
  return mem_.Get();
}

size_t InProcessShm::size() const {
  return mem_.size();
}

InProcessShmFactory::~InProcessShmFactory() = default;
std::unique_ptr<SharedMemory> InProcessShmFactory::CreateSharedMemory(
    size_t size) {
  return std::unique_ptr<SharedMemory>(new InProcessShm(size));
}

}  // namespace

// static
InProcessTracingBackend* InProcessTracingBackend::GetInstance() {
  static auto* instance = new InProcessTracingBackend();
  return instance;
}

InProcessTracingBackend::InProcessTracingBackend() {}

std::unique_ptr<ProducerEndpoint> InProcessTracingBackend::ConnectProducer(
    const ConnectProducerArgs& args) {
  PERFETTO_DCHECK(args.task_runner->RunsTasksOnCurrentThread());

  // This should never happen as we can have at most one in-process backend.
  if (service_)
    PERFETTO_FATAL("InProcessTracingBackend initialized twice");

  return GetOrCreateService(args.task_runner)
      ->ConnectProducer(args.producer, /*uid=*/0, args.producer_name,
                        /*shm_hint=*/0, /*in_process=*/true,
                        TracingService::ProducerSMBScrapingMode::kEnabled);
}

std::unique_ptr<ConsumerEndpoint> InProcessTracingBackend::ConnectConsumer(
    const ConnectConsumerArgs& args) {
  return GetOrCreateService(args.task_runner)
      ->ConnectConsumer(args.consumer, /*uid=*/0);
}

TracingService* InProcessTracingBackend::GetOrCreateService(
    base::TaskRunner* task_runner) {
  if (!service_) {
    std::unique_ptr<InProcessShmFactory> shm(new InProcessShmFactory());
    service_ = TracingService::CreateInstance(std::move(shm), task_runner);
    service_->SetSMBScrapingEnabled(true);
  }
  return service_.get();
}

}  // namespace internal
}  // namespace perfetto
// gen_amalgamated begin source: src/tracing/internal/tracing_muxer_impl.cc
// gen_amalgamated begin header: src/tracing/internal/tracing_muxer_impl.h
// gen_amalgamated begin header: include/perfetto/tracing/tracing.h
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef INCLUDE_PERFETTO_TRACING_TRACING_H_
#define INCLUDE_PERFETTO_TRACING_TRACING_H_

#include <stddef.h>
#include <stdint.h>

#include <functional>
#include <memory>
#include <string>
#include <vector>

namespace perfetto {

class TracingBackend;
class Platform;
class TraceConfig;
class TracingSession;  // Declared below.

enum BackendType : uint32_t {
  kUnspecifiedBackend = 0,

  // Connects to a previously-initialized perfetto tracing backend for
  // in-process. If the in-process backend has not been previously initialized
  // it will do so and create the tracing service on a dedicated thread.
  kInProcessBackend = 1 << 0,

  // Connects to the system tracing service (e.g. on Linux/Android/Mac uses a
  // named UNIX socket).
  kSystemBackend = 1 << 1,

  // Used to provide a custom IPC transport to connect to the service.
  // TracingInitArgs::custom_backend must be non-null and point to an
  // indefinitely lived instance.
  kCustomBackend = 1 << 2,
};

struct TracingInitArgs {
  uint32_t backends = 0;                     // One or more BackendFlags.
  TracingBackend* custom_backend = nullptr;  // [Optional].

  // [Optional] Platform implementation. It allows the embedder to take control
  // of platform-specific bits like thread creation and TLS slot handling. If
  // not set it will use Platform::GetDefaultPlatform().
  Platform* platform = nullptr;
};

// The entry-point for using perfetto.
class Tracing {
 public:
  // Initializes Perfetto with the given backends in the calling process and/or
  // with a user-provided backend. Can only be called once.
  static void Initialize(const TracingInitArgs&);

  // For the moment this can be used only when initializing tracing in
  // kInProcess mode. For the system mode use the 'bin/perfetto' cmdline client.
  static std::unique_ptr<TracingSession> NewTrace(BackendType);

 private:
  Tracing() = delete;
};

class TracingSession {
 public:
  virtual ~TracingSession();

  // Configure the session passing the trace config.
  // TODO(primiano): add an error callback.
  virtual void Setup(const TraceConfig&) = 0;

  virtual void Start() = 0;

  // Use SetOnStopCallback() to get a notification when the tracing session is
  // fully stopped and all data sources have acked.
  virtual void Stop() = 0;

  // This callback will be invoked when tracing is disabled.
  // This can happen either when explicitly calling TracingSession.Stop() or
  // when the trace reaches its |duration_ms| time limit.
  // This callback will be invoked on an internal perfetto thread.
  virtual void SetOnStopCallback(std::function<void()>) = 0;

  // Struct passed as argument to the callback passed to ReadTrace().
  // [data, size] is guaranteed to contain 1 or more full trace packets, which
  // can be decoded using trace.proto. No partial or truncated packets are
  // exposed. If the trace is empty this returns a zero-sized nullptr with
  // |has_more| == true to signal EOF.
  // This callback will be invoked on an internal perfetto thread.
  struct ReadTraceCallbackArgs {
    const char* data = nullptr;
    size_t size = 0;

    // When false, this will be the last invocation of the callback for this
    // read cycle.
    bool has_more = false;
  };

  // Reads back the trace data (raw protobuf-encoded bytes) asynchronously.
  // Can be called at any point during the trace, typically but not necessarily,
  // after stopping. Reading the trace data is a destructive operation w.r.t.
  // contents of the trace buffer and is not idempotent.
  // A single ReadTrace() call can yield >1 callback invocations, until
  // |has_more| is true.
  using ReadTraceCallback = std::function<void(ReadTraceCallbackArgs)>;
  virtual void ReadTrace(ReadTraceCallback) = 0;

  // Synchronous version of ReadTrace(). It blocks the calling thread until all
  // the trace contents are read. This is slow and inefficient (involves more
  // copies) and is mainly intended for testing.
  std::vector<char> ReadTraceBlocking();
};

}  // namespace perfetto

#endif  // INCLUDE_PERFETTO_TRACING_TRACING_H_
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef SRC_TRACING_INTERNAL_TRACING_MUXER_IMPL_H_
#define SRC_TRACING_INTERNAL_TRACING_MUXER_IMPL_H_

#include <stddef.h>
#include <stdint.h>

#include <array>
#include <atomic>
#include <bitset>
#include <memory>
#include <vector>

// gen_amalgamated expanded: #include "perfetto/ext/base/thread_checker.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/basic_types.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/consumer.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/producer.h"
// gen_amalgamated expanded: #include "perfetto/tracing/core/data_source_descriptor.h"
// gen_amalgamated expanded: #include "perfetto/tracing/core/trace_config.h"
// gen_amalgamated expanded: #include "perfetto/tracing/internal/basic_types.h"
// gen_amalgamated expanded: #include "perfetto/tracing/internal/tracing_muxer.h"
// gen_amalgamated expanded: #include "perfetto/tracing/tracing.h"

namespace perfetto {

class ConsumerEndpoint;
class DataSourceBase;
class DataSourceConfig;
class ProducerEndpoint;
class TraceWriterBase;
class TracingBackend;
class TracingSession;
struct TracingInitArgs;

namespace base {
class TaskRunner;
}

namespace internal {

struct DataSourceStaticState;

// This class acts as a bridge between the public API and the TracingBackend(s).
// It exposes a simplified view of the world to the API methods handling all the
// bookkeeping to map data source instances and trace writers to the various
// backends. It deals with N data sources, M backends (1 backend == 1 tracing
// service == 1 producer connection) and T concurrent tracing sessions.
//
// Handing data source registration and start/stop flows [producer side]:
// ----------------------------------------------------------------------
// 1. The API client subclasses perfetto::DataSource and calls
//    DataSource::Register<MyDataSource>(). In turn this calls into the
//    TracingMuxer.
// 2. The tracing muxer iterates through all the backends (1 backend == 1
//    service == 1 producer connection) and registers the data source on each
//    backend.
// 3. When any (services behind a) backend starts tracing and requests to start
//    that specific data source, the TracingMuxerImpl constructs a new instance
//    of MyDataSource and calls the OnStart() method.
//
// Controlling trace and retrieving trace data [consumer side]:
// ------------------------------------------------------------
// 1. The API client calls Tracing::NewTrace(), returns a RAII TracingSession
//    object.
// 2. NewTrace() calls into internal::TracingMuxer(Impl). TracingMuxer
//    subclasses the TracingSession object (TracingSessionImpl) and returns it.
// 3. The tracing muxer identifies the backend (according to the args passed to
//    NewTrace), creates a new Consumer and connects to it.
// 4. When the API client calls Start()/Stop()/ReadTrace() methods, the
//    TracingMuxer forwards them to the consumer associated to the
//    TracingSession. Likewise for callbacks coming from the consumer-side of
//    the service.
class TracingMuxerImpl : public TracingMuxer {
 public:
  // This is different than TracingSessionID because it's global across all
  // backends. TracingSessionID is global only within the scope of one service.
  using TracingSessionGlobalID = uint64_t;

  static void InitializeInstance(const TracingInitArgs&);

  // TracingMuxer implementation.
  bool RegisterDataSource(const DataSourceDescriptor&,
                          DataSourceFactory,
                          DataSourceStaticState*) override;
  std::unique_ptr<TraceWriterBase> CreateTraceWriter(DataSourceState*) override;
  void DestroyStoppedTraceWritersForCurrentThread() override;

  std::unique_ptr<TracingSession> CreateTracingSession(BackendType);

  // Producer-side bookkeeping methods.
  void UpdateDataSourcesOnAllBackends();
  void SetupDataSource(TracingBackendId,
                       DataSourceInstanceID,
                       const DataSourceConfig&);
  void StartDataSource(TracingBackendId, DataSourceInstanceID);
  void StopDataSource(TracingBackendId, DataSourceInstanceID);

  // Consumer-side bookkeeping methods.
  void SetupTracingSession(TracingSessionGlobalID,
                           const std::shared_ptr<TraceConfig>&);
  void StartTracingSession(TracingSessionGlobalID);
  void StopTracingSession(TracingSessionGlobalID);
  void DestroyTracingSession(TracingSessionGlobalID);
  void ReadTracingSessionData(
      TracingSessionGlobalID,
      std::function<void(TracingSession::ReadTraceCallbackArgs)>);

 private:
  // For each TracingBackend we create and register one ProducerImpl instance.
  // This talks to the producer-side of the service, gets start/stop requests
  // from it and routes them to the registered data sources.
  // One ProducerImpl == one backend == one tracing service.
  // This class is needed to disambiguate callbacks coming from different
  // services. TracingMuxerImpl can't directly implement the Producer interface
  // because the Producer virtual methods don't allow to identify the service.
  class ProducerImpl : public Producer {
   public:
    ProducerImpl(TracingMuxerImpl*, TracingBackendId);
    ~ProducerImpl() override;

    void Initialize(std::unique_ptr<ProducerEndpoint> endpoint);
    void RegisterDataSource(const DataSourceDescriptor&,
                            DataSourceFactory,
                            DataSourceStaticState*);

    // perfetto::Producer implementation.
    void OnConnect() override;
    void OnDisconnect() override;
    void OnTracingSetup() override;
    void SetupDataSource(DataSourceInstanceID,
                         const DataSourceConfig&) override;
    void StartDataSource(DataSourceInstanceID,
                         const DataSourceConfig&) override;
    void StopDataSource(DataSourceInstanceID) override;
    void Flush(FlushRequestID, const DataSourceInstanceID*, size_t) override;
    void ClearIncrementalState(const DataSourceInstanceID*, size_t) override;

    PERFETTO_THREAD_CHECKER(thread_checker_)
    TracingMuxerImpl* const muxer_;
    TracingBackendId const backend_id_;
    bool connected_ = false;

    // Set of data sources that have been actually registered on this producer.
    // This can be a subset of the global |data_sources_|, because data sources
    // can register before the producer is fully connected.
    std::bitset<kMaxDataSources> registered_data_sources_{};

    std::unique_ptr<ProducerEndpoint> service_;  // Keep last.
  };

  // For each TracingSession created by the API client (Tracing::NewTrace() we
  // create and register one ConsumerImpl instance.
  // This talks to the consumer-side of the service, gets end-of-trace and
  // on-trace-data callbacks and routes them to the API client callbacks.
  // This class is needed to disambiguate callbacks coming from different
  // tracing sessions.
  class ConsumerImpl : public Consumer {
   public:
    ConsumerImpl(TracingMuxerImpl*, TracingBackendId, TracingSessionGlobalID);
    ~ConsumerImpl() override;

    void Initialize(std::unique_ptr<ConsumerEndpoint> endpoint);

    // perfetto::Consumer implementation.
    void OnConnect() override;
    void OnDisconnect() override;
    void OnTracingDisabled() override;
    void OnTraceData(std::vector<TracePacket>, bool has_more) override;
    void OnDetach(bool success) override;
    void OnAttach(bool success, const TraceConfig&) override;
    void OnTraceStats(bool success, const TraceStats&) override;
    void OnObservableEvents(const ObservableEvents&) override;

    TracingMuxerImpl* const muxer_;
    TracingBackendId const backend_id_;
    TracingSessionGlobalID const session_id_;
    bool connected_ = false;

    // This is to handle the case where the Setup call from the API client
    // arrives before the consumer has connected. In this case we keep around
    // the config and check if we have it after connection.
    bool start_pending_ = false;

    // shared_ptr because it's posted across threads. This is to avoid copying
    // it more than once.
    std::shared_ptr<TraceConfig> trace_config_;

    // If the API client passes a callback to stop, we should invoke this when
    // OnTracingDisabled() is invoked.
    std::function<void()> stop_complete_callback_;

    // Callback passed to ReadTrace().
    std::function<void(TracingSession::ReadTraceCallbackArgs)>
        read_trace_callback_;

    std::unique_ptr<ConsumerEndpoint> service_;  // Keep before last.
    PERFETTO_THREAD_CHECKER(thread_checker_)     // Keep last.
  };

  // This object is returned to API clients when they call
  // Tracing::CreateTracingSession().
  class TracingSessionImpl : public TracingSession {
   public:
    TracingSessionImpl(TracingMuxerImpl*, TracingSessionGlobalID);
    ~TracingSessionImpl() override;
    void Setup(const TraceConfig&) override;
    void Start() override;
    void Stop() override;
    void ReadTrace(ReadTraceCallback) override;
    void SetOnStopCallback(std::function<void()>) override;

   private:
    TracingMuxerImpl* const muxer_;
    TracingSessionGlobalID const session_id_;
  };

  struct RegisteredDataSource {
    DataSourceDescriptor descriptor;
    DataSourceFactory factory{};
    DataSourceStaticState* static_state = nullptr;
  };

  struct RegisteredBackend {
    // Backends are supposed to have static lifetime.
    TracingBackend* backend = nullptr;
    TracingBackendId id = 0;
    BackendType type{};

    std::unique_ptr<ProducerImpl> producer;

    // The calling code can request more than one concurrently active tracing
    // session for the same backend. We need to create one consumer per session.
    std::vector<std::unique_ptr<ConsumerImpl>> consumers;
  };

  explicit TracingMuxerImpl(const TracingInitArgs&);
  void Initialize(const TracingInitArgs& args);
  ConsumerImpl* FindConsumer(TracingSessionGlobalID session_id);

  std::unique_ptr<base::TaskRunner> task_runner_;
  std::vector<RegisteredDataSource> data_sources_;
  std::vector<RegisteredBackend> backends_;

  std::atomic<TracingSessionGlobalID> next_tracing_session_id_{};

  PERFETTO_THREAD_CHECKER(thread_checker_)
};

}  // namespace internal
}  // namespace perfetto

#endif  // SRC_TRACING_INTERNAL_TRACING_MUXER_IMPL_H_
// gen_amalgamated begin header: src/tracing/internal/system_tracing_backend.h
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef SRC_TRACING_INTERNAL_SYSTEM_TRACING_BACKEND_H_
#define SRC_TRACING_INTERNAL_SYSTEM_TRACING_BACKEND_H_

// gen_amalgamated expanded: #include "perfetto/tracing/tracing_backend.h"

namespace perfetto {

namespace base {
class TaskRunner;
}

class Producer;

// A built-in implementation of TracingBackend that connects to the system
// tracing daemon (traced) via a UNIX socket using the perfetto built-in
// proto-based IPC mechanism. Instantiated when the embedder calls
// Tracing::Initialize(kSystemBackend). It allows to get app-traces fused
// together with system traces, useful to correlate on the timeline system
// events (e.g. scheduling slices from the kernel) with in-app events.
namespace internal {
class SystemTracingBackend : public TracingBackend {
 public:
  static SystemTracingBackend* GetInstance();

  // TracingBackend implementation.
  std::unique_ptr<ProducerEndpoint> ConnectProducer(
      const ConnectProducerArgs&) override;
  std::unique_ptr<ConsumerEndpoint> ConnectConsumer(
      const ConnectConsumerArgs&) override;

 private:
  SystemTracingBackend();
};

}  // namespace internal
}  // namespace perfetto

#endif  // SRC_TRACING_INTERNAL_SYSTEM_TRACING_BACKEND_H_
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "src/tracing/internal/tracing_muxer_impl.h"

#include <algorithm>
#include <atomic>
#include <vector>

// gen_amalgamated expanded: #include "perfetto/base/build_config.h"
// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/base/task_runner.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/thread_checker.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/trace_packet.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/trace_writer.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/tracing_service.h"
// gen_amalgamated expanded: #include "perfetto/tracing/core/data_source_config.h"
// gen_amalgamated expanded: #include "perfetto/tracing/data_source.h"
// gen_amalgamated expanded: #include "perfetto/tracing/internal/data_source_internal.h"
// gen_amalgamated expanded: #include "perfetto/tracing/trace_writer_base.h"
// gen_amalgamated expanded: #include "perfetto/tracing/tracing.h"
// gen_amalgamated expanded: #include "perfetto/tracing/tracing_backend.h"
// gen_amalgamated expanded: #include "src/tracing/internal/in_process_tracing_backend.h"
// gen_amalgamated expanded: #include "src/tracing/internal/system_tracing_backend.h"

namespace perfetto {
namespace internal {

// ----- Begin of TracingMuxerImpl::ProducerImpl
TracingMuxerImpl::ProducerImpl::ProducerImpl(TracingMuxerImpl* muxer,
                                             TracingBackendId backend_id)
    : muxer_(muxer), backend_id_(backend_id) {}
TracingMuxerImpl::ProducerImpl::~ProducerImpl() = default;

void TracingMuxerImpl::ProducerImpl::Initialize(
    std::unique_ptr<ProducerEndpoint> endpoint) {
  service_ = std::move(endpoint);
}

void TracingMuxerImpl::ProducerImpl::OnConnect() {
  PERFETTO_DLOG("Producer connected");
  PERFETTO_DCHECK_THREAD(thread_checker_);
  PERFETTO_DCHECK(!connected_);
  connected_ = true;
  muxer_->UpdateDataSourcesOnAllBackends();
}

void TracingMuxerImpl::ProducerImpl::OnDisconnect() {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  connected_ = false;
  PERFETTO_DFATAL("Producer::OnDisconnect not implemented");  // TODO.
}

void TracingMuxerImpl::ProducerImpl::OnTracingSetup() {
  PERFETTO_DCHECK_THREAD(thread_checker_);
}

void TracingMuxerImpl::ProducerImpl::SetupDataSource(
    DataSourceInstanceID id,
    const DataSourceConfig& cfg) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  muxer_->SetupDataSource(backend_id_, id, cfg);
}

void TracingMuxerImpl::ProducerImpl::StartDataSource(DataSourceInstanceID id,
                                                     const DataSourceConfig&) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  muxer_->StartDataSource(backend_id_, id);
  service_->NotifyDataSourceStarted(id);
}

void TracingMuxerImpl::ProducerImpl::StopDataSource(DataSourceInstanceID id) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  muxer_->StopDataSource(backend_id_, id);
  service_->NotifyDataSourceStopped(id);
}

void TracingMuxerImpl::ProducerImpl::Flush(FlushRequestID flush_id,
                                           const DataSourceInstanceID*,
                                           size_t) {
  // Flush is not plumbed for now, we just ack straight away.
  PERFETTO_DCHECK_THREAD(thread_checker_);
  service_->NotifyFlushComplete(flush_id);
}

void TracingMuxerImpl::ProducerImpl::ClearIncrementalState(
    const DataSourceInstanceID*,
    size_t) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
}
// ----- End of TracingMuxerImpl::ProducerImpl methods.

// ----- Begin of TracingMuxerImpl::ConsumerImpl
TracingMuxerImpl::ConsumerImpl::ConsumerImpl(TracingMuxerImpl* muxer,
                                             TracingBackendId backend_id,
                                             TracingSessionGlobalID session_id)
    : muxer_(muxer), backend_id_(backend_id), session_id_(session_id) {}

TracingMuxerImpl::ConsumerImpl::~ConsumerImpl() = default;

void TracingMuxerImpl::ConsumerImpl::Initialize(
    std::unique_ptr<ConsumerEndpoint> endpoint) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  service_ = std::move(endpoint);
}

void TracingMuxerImpl::ConsumerImpl::OnConnect() {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  PERFETTO_DCHECK(!connected_);
  connected_ = true;

  // If the API client configured and started tracing before we connected,
  // tell the backend about it now.
  if (trace_config_) {
    muxer_->SetupTracingSession(session_id_, trace_config_);
    if (start_pending_)
      muxer_->StartTracingSession(session_id_);
  }
}

void TracingMuxerImpl::ConsumerImpl::OnDisconnect() {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  // It shouldn't be necessary to call StopTracingSession. If we get this call
  // it means that the service did shutdown before us, so there is no point
  // trying it to ask it to stop the session. We should just remember to cleanup
  // the consumer vector.
  connected_ = false;

  // TODO notify the client somehow.
}

void TracingMuxerImpl::ConsumerImpl::OnTracingDisabled() {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  if (stop_complete_callback_)
    muxer_->task_runner_->PostTask(std::move(stop_complete_callback_));
}

void TracingMuxerImpl::ConsumerImpl::OnTraceData(
    std::vector<TracePacket> packets,
    bool has_more) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  if (!read_trace_callback_)
    return;

  size_t capacity = 0;
  for (const auto& packet : packets) {
    // 16 is an over-estimation of the proto preamble size
    capacity += packet.size() + 16;
  }

  // The shared_ptr is to avoid making a copy of the buffer when PostTask-ing.
  std::shared_ptr<std::vector<char>> buf(new std::vector<char>());
  buf->reserve(capacity);
  for (auto& packet : packets) {
    char* start;
    size_t size;
    std::tie(start, size) = packet.GetProtoPreamble();
    buf->insert(buf->end(), start, start + size);
    for (auto& slice : packet.slices()) {
      const auto* slice_data = reinterpret_cast<const char*>(slice.start);
      buf->insert(buf->end(), slice_data, slice_data + slice.size);
    }
  }

  auto callback = read_trace_callback_;
  muxer_->task_runner_->PostTask([callback, buf, has_more] {
    TracingSession::ReadTraceCallbackArgs callback_arg{};
    callback_arg.data = &(*buf)[0];
    callback_arg.size = buf->size();
    callback_arg.has_more = has_more;
    callback(callback_arg);
  });

  if (!has_more)
    read_trace_callback_ = nullptr;
}

// The callbacks below are not used.
void TracingMuxerImpl::ConsumerImpl::OnDetach(bool) {}
void TracingMuxerImpl::ConsumerImpl::OnAttach(bool, const TraceConfig&) {}
void TracingMuxerImpl::ConsumerImpl::OnTraceStats(bool, const TraceStats&) {}
void TracingMuxerImpl::ConsumerImpl::OnObservableEvents(
    const ObservableEvents&) {}
// ----- End of TracingMuxerImpl::ConsumerImpl

// ----- Begin of TracingMuxerImpl::TracingSessionImpl

// TracingSessionImpl is the RAII object returned to API clients when they
// invoke Tracing::CreateTracingSession. They use it for starting/stopping
// tracing.

TracingMuxerImpl::TracingSessionImpl::TracingSessionImpl(
    TracingMuxerImpl* muxer,
    TracingSessionGlobalID session_id)
    : muxer_(muxer), session_id_(session_id) {}

// Can be destroyed from any thread.
TracingMuxerImpl::TracingSessionImpl::~TracingSessionImpl() {
  auto* muxer = muxer_;
  auto session_id = session_id_;
  muxer->task_runner_->PostTask(
      [muxer, session_id] { muxer->DestroyTracingSession(session_id); });
}

// Can be called from any thread.
void TracingMuxerImpl::TracingSessionImpl::Setup(const TraceConfig& cfg) {
  auto* muxer = muxer_;
  auto session_id = session_id_;
  std::shared_ptr<TraceConfig> trace_config(new TraceConfig(cfg));
  muxer->task_runner_->PostTask([muxer, session_id, trace_config] {
    muxer->SetupTracingSession(session_id, trace_config);
  });
}

// Can be called from any thread.
void TracingMuxerImpl::TracingSessionImpl::Start() {
  auto* muxer = muxer_;
  auto session_id = session_id_;
  muxer->task_runner_->PostTask(
      [muxer, session_id] { muxer->StartTracingSession(session_id); });
}

// Can be called from any thread.
void TracingMuxerImpl::TracingSessionImpl::Stop() {
  auto* muxer = muxer_;
  auto session_id = session_id_;
  muxer->task_runner_->PostTask(
      [muxer, session_id] { muxer->StopTracingSession(session_id); });
}

// Can be called from any thread.
void TracingMuxerImpl::TracingSessionImpl::ReadTrace(ReadTraceCallback cb) {
  auto* muxer = muxer_;
  auto session_id = session_id_;
  muxer->task_runner_->PostTask([muxer, session_id, cb] {
    muxer->ReadTracingSessionData(session_id, std::move(cb));
  });
}

// Can be called from any thread.
void TracingMuxerImpl::TracingSessionImpl::SetOnStopCallback(
    std::function<void()> cb) {
  auto* muxer = muxer_;
  auto session_id = session_id_;
  muxer->task_runner_->PostTask([muxer, session_id, cb] {
    auto* consumer = muxer->FindConsumer(session_id);
    consumer->stop_complete_callback_ = cb;
  });
}
// ----- End of TracingMuxerImpl::TracingSessionImpl

// static
TracingMuxer* TracingMuxer::instance_ = nullptr;

// This is called by perfetto::Tracing::Initialize().
// Can be called on any thread. Typically, but not necessarily, that will be
// the embedder's main thread.
TracingMuxerImpl::TracingMuxerImpl(const TracingInitArgs& args)
    : TracingMuxer(args.platform ? args.platform
                                 : Platform::GetDefaultPlatform()) {
  PERFETTO_DETACH_FROM_THREAD(thread_checker_);

  // Create the thread where muxer, producers and service will live.
  task_runner_ = platform_->CreateTaskRunner({});

  // Run the initializer on that thread.
  task_runner_->PostTask([this, args] { Initialize(args); });
}

void TracingMuxerImpl::Initialize(const TracingInitArgs& args) {
  PERFETTO_DCHECK_THREAD(thread_checker_);  // Rebind the thread checker.

  auto add_backend = [this](TracingBackend* backend, BackendType type) {
    TracingBackendId backend_id = backends_.size();
    backends_.emplace_back();
    RegisteredBackend& rb = backends_.back();
    rb.backend = backend;
    rb.id = backend_id;
    rb.type = type;
    rb.producer.reset(new ProducerImpl(this, backend_id));
    TracingBackend::ConnectProducerArgs conn_args;
    conn_args.producer = rb.producer.get();
    conn_args.producer_name = platform_->GetCurrentProcessName();
    conn_args.task_runner = task_runner_.get();
    rb.producer->Initialize(rb.backend->ConnectProducer(conn_args));
  };

  if (args.backends & kSystemBackend) {
// These buildflags match the |perfetto_build_with_ipc_layer| condition in
// the //src/tracing:client_api target.
#if (PERFETTO_BUILDFLAG(PERFETTO_ANDROID_BUILD) ||     \
     PERFETTO_BUILDFLAG(PERFETTO_CHROMIUM_BUILD) ||    \
     PERFETTO_BUILDFLAG(PERFETTO_STANDALONE_BUILD)) && \
    (PERFETTO_BUILDFLAG(PERFETTO_OS_LINUX) ||          \
     PERFETTO_BUILDFLAG(PERFETTO_OS_ANDROID) ||        \
     PERFETTO_BUILDFLAG(PERFETTO_OS_MACOSX))
    add_backend(SystemTracingBackend::GetInstance(), kSystemBackend);
#else
    PERFETTO_ELOG("System backend not supporteed in the current configuration");
#endif
  }

  if (args.backends & kInProcessBackend)
    add_backend(InProcessTracingBackend::GetInstance(), kInProcessBackend);

  if (args.backends & kCustomBackend) {
    PERFETTO_CHECK(args.custom_backend);
    add_backend(args.custom_backend, kCustomBackend);
  }

  if (args.backends & ~(kSystemBackend | kInProcessBackend | kCustomBackend)) {
    PERFETTO_FATAL("Unsupported tracing backend type");
  }
}

// Can be called from any thread.
bool TracingMuxerImpl::RegisterDataSource(
    const DataSourceDescriptor& descriptor,
    DataSourceFactory factory,
    DataSourceStaticState* static_state) {
  static std::atomic<uint32_t> last_id{};
  uint32_t new_index = last_id++;
  if (new_index >= kMaxDataSources - 1) {
    PERFETTO_DLOG(
        "RegisterDataSource failed: too many data sources already registered");
    return false;
  }

  // Initialize the static state.
  static_assert(sizeof(static_state->instances[0]) >= sizeof(DataSourceState),
                "instances[] size mismatch");
  for (size_t i = 0; i < static_state->instances.size(); i++)
    new (&static_state->instances[i]) DataSourceState{};

  static_state->index = new_index;

  task_runner_->PostTask([this, descriptor, factory, static_state] {
    data_sources_.emplace_back();
    RegisteredDataSource& rds = data_sources_.back();
    rds.descriptor = descriptor;
    rds.factory = factory;
    rds.static_state = static_state;
    UpdateDataSourcesOnAllBackends();
  });
  return true;
}

// Called by the service of one of the backends.
void TracingMuxerImpl::SetupDataSource(TracingBackendId backend_id,
                                       DataSourceInstanceID instance_id,
                                       const DataSourceConfig& cfg) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  PERFETTO_DLOG("Setting up data source %" PRIu64 " %s", instance_id,
                cfg.name().c_str());

  for (const auto& rds : data_sources_) {
    if (rds.descriptor.name() != cfg.name())
      continue;

    DataSourceStaticState& static_state = *rds.static_state;
    for (uint32_t i = 0; i < kMaxDataSourceInstances; i++) {
      // Find a free slot.
      if (static_state.TryGet(i))
        continue;

      auto* internal_state =
          reinterpret_cast<DataSourceState*>(&static_state.instances[i]);
      std::lock_guard<std::mutex> guard(internal_state->lock);
      static_assert(
          std::is_same<decltype(internal_state->data_source_instance_id),
                       DataSourceInstanceID>::value,
          "data_source_instance_id type mismatch");
      internal_state->backend_id = backend_id;
      internal_state->data_source_instance_id = instance_id;
      internal_state->buffer_id =
          static_cast<internal::BufferId>(cfg.target_buffer());
      internal_state->data_source = rds.factory();

      // This must be made at the end. See matching acquire-load in
      // DataSource::Trace().
      static_state.valid_instances.fetch_or(1 << i, std::memory_order_acq_rel);

      DataSourceBase::SetupArgs setup_args;
      setup_args.config = &cfg;
      internal_state->data_source->OnSetup(setup_args);
      break;
    }
  }
}

// Called by the service of one of the backends.
void TracingMuxerImpl::StartDataSource(TracingBackendId backend_id,
                                       DataSourceInstanceID instance_id) {
  PERFETTO_DLOG("Starting data source %" PRIu64, instance_id);
  PERFETTO_DCHECK_THREAD(thread_checker_);
  for (const auto& rds : data_sources_) {
    DataSourceStaticState& static_state = *rds.static_state;
    for (uint32_t i = 0; i < kMaxDataSourceInstances; i++) {
      auto* internal_state = static_state.TryGet(i);
      if (!internal_state)
        continue;

      if (internal_state->backend_id != backend_id ||
          internal_state->data_source_instance_id != instance_id) {
        continue;
      }

      std::lock_guard<std::mutex> guard(internal_state->lock);
      internal_state->started = true;
      internal_state->data_source->OnStart(DataSourceBase::StartArgs{});
      return;
    }
  }
  PERFETTO_ELOG("Could not find data source to start");
}

// Called by the service of one of the backends.
void TracingMuxerImpl::StopDataSource(TracingBackendId backend_id,
                                      DataSourceInstanceID instance_id) {
  PERFETTO_DLOG("Stopping data source %" PRIu64, instance_id);
  PERFETTO_DCHECK_THREAD(thread_checker_);
  for (const auto& rds : data_sources_) {
    DataSourceStaticState& static_state = *rds.static_state;
    for (uint32_t i = 0; i < kMaxDataSourceInstances; i++) {
      auto* internal_state = static_state.TryGet(i);
      if (!internal_state)
        continue;

      if (internal_state->backend_id != backend_id ||
          internal_state->data_source_instance_id != instance_id) {
        continue;
      }

      static_state.valid_instances.fetch_and(~(1 << i),
                                             std::memory_order_acq_rel);

      // Take the mutex to prevent that the data source is in the middle of
      // a Trace() execution where it called GetDataSourceLocked() while we
      // destroy it.
      {
        std::lock_guard<std::mutex> guard(internal_state->lock);
        internal_state->started = false;
        internal_state->data_source->OnStop(DataSourceBase::StopArgs{});
        internal_state->data_source.reset();
      }

      // The other fields of internal_state are deliberately *not* cleared.
      // See races-related comments of DataSource::Trace().

      TracingMuxer::generation_++;
      return;
    }
  }
  PERFETTO_ELOG("Could not find data source to stop");
}

void TracingMuxerImpl::DestroyStoppedTraceWritersForCurrentThread() {
  // Iterate across all possible data source types.
  auto cur_generation = generation_.load(std::memory_order_acquire);
  auto* root_tls = GetOrCreateTracingTLS();
  for (size_t ds_idx = 0; ds_idx < kMaxDataSources; ds_idx++) {
    // |tls| has a vector of per-data-source-instance thread-local state.
    DataSourceThreadLocalState& tls = root_tls->data_sources_tls[ds_idx];
    DataSourceStaticState* static_state = tls.static_state;
    if (!static_state)
      continue;  // Slot not used.

    // Iterate across all possible instances for this data source.
    for (uint32_t inst = 0; inst < kMaxDataSourceInstances; inst++) {
      DataSourceInstanceThreadLocalState& ds_tls = tls.per_instance[inst];
      if (!ds_tls.trace_writer)
        continue;

      DataSourceState* ds_state = static_state->TryGet(inst);
      if (ds_state && ds_state->backend_id == ds_tls.backend_id &&
          ds_state->buffer_id == ds_tls.buffer_id) {
        continue;
      }

      // The DataSource instance has been destroyed or recycled.
      ds_tls.Reset();  // Will also destroy the |ds_tls.trace_writer|.
    }
  }
  root_tls->generation = cur_generation;
}

// Called both when a new data source is registered or when a new backend
// connects. In both cases we want to be sure we reflected the data source
// registrations on the backends.
void TracingMuxerImpl::UpdateDataSourcesOnAllBackends() {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  for (RegisteredDataSource& rds : data_sources_) {
    for (RegisteredBackend& backend : backends_) {
      // We cannot call RegisterDataSource on the backend before it connects.
      if (!backend.producer->connected_)
        continue;

      PERFETTO_DCHECK(rds.static_state->index < kMaxDataSourceInstances);
      if (backend.producer->registered_data_sources_.test(
              rds.static_state->index))
        continue;

      rds.descriptor.set_will_notify_on_start(true);
      rds.descriptor.set_will_notify_on_stop(true);
      backend.producer->service_->RegisterDataSource(rds.descriptor);
      backend.producer->registered_data_sources_.set(rds.static_state->index);
    }
  }
}

void TracingMuxerImpl::SetupTracingSession(
    TracingSessionGlobalID session_id,
    const std::shared_ptr<TraceConfig>& trace_config) {
  PERFETTO_DCHECK_THREAD(thread_checker_);

  auto* consumer = FindConsumer(session_id);

  if (!consumer)
    return;

  consumer->trace_config_ = trace_config;

  if (!consumer->connected_)
    return;

  // Only used in the deferred start mode.
  if (trace_config->deferred_start())
    consumer->service_->EnableTracing(*trace_config);
}

void TracingMuxerImpl::StartTracingSession(TracingSessionGlobalID session_id) {
  PERFETTO_DCHECK_THREAD(thread_checker_);

  auto* consumer = FindConsumer(session_id);

  if (!consumer)
    return;

  if (!consumer->trace_config_) {
    PERFETTO_ELOG("Must call Setup(config) first");
    return;
  }

  if (!consumer->connected_) {
    consumer->start_pending_ = true;
    return;
  }

  if (consumer->trace_config_->deferred_start()) {
    consumer->service_->StartTracing();
  } else {
    consumer->service_->EnableTracing(*consumer->trace_config_);
  }

  // TODO implement support for the deferred-start + fast-triggering case.
}

void TracingMuxerImpl::StopTracingSession(TracingSessionGlobalID session_id) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  auto* consumer = FindConsumer(session_id);
  if (!consumer)
    return;

  if (!consumer->trace_config_) {
    PERFETTO_ELOG("Must call Setup(config) and Start() first");
    return;
  }

  consumer->service_->DisableTracing();
  consumer->trace_config_.reset();
}

void TracingMuxerImpl::DestroyTracingSession(
    TracingSessionGlobalID session_id) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  for (RegisteredBackend& backend : backends_) {
    auto pred = [session_id](const std::unique_ptr<ConsumerImpl>& consumer) {
      return consumer->session_id_ == session_id;
    };
    backend.consumers.erase(std::remove_if(backend.consumers.begin(),
                                           backend.consumers.end(), pred),
                            backend.consumers.end());
  }
}

void TracingMuxerImpl::ReadTracingSessionData(
    TracingSessionGlobalID session_id,
    std::function<void(TracingSession::ReadTraceCallbackArgs)> callback) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  auto* consumer = FindConsumer(session_id);
  if (!consumer)
    return;
  PERFETTO_DCHECK(!consumer->read_trace_callback_);
  consumer->read_trace_callback_ = std::move(callback);
  consumer->service_->ReadBuffers();
}

TracingMuxerImpl::ConsumerImpl* TracingMuxerImpl::FindConsumer(
    TracingSessionGlobalID session_id) {
  PERFETTO_DCHECK_THREAD(thread_checker_);
  for (RegisteredBackend& backend : backends_) {
    for (auto& consumer : backend.consumers) {
      if (consumer->session_id_ == session_id)
        return consumer.get();
    }
  }
  return nullptr;
}

// Can be called from any thread.
std::unique_ptr<TraceWriterBase> TracingMuxerImpl::CreateTraceWriter(
    DataSourceState* data_source) {
  ProducerImpl* producer = backends_[data_source->backend_id].producer.get();
  return producer->service_->CreateTraceWriter(data_source->buffer_id);
}

// This is called via the public API Tracing::NewTrace().
// Can be called from any thread.
std::unique_ptr<TracingSession> TracingMuxerImpl::CreateTracingSession(
    BackendType backend_type) {
  TracingSessionGlobalID session_id = ++next_tracing_session_id_;

  // |backend_type| can only specify one backend, not an OR-ed mask.
  PERFETTO_CHECK((backend_type & (backend_type - 1)) == 0);

  // Capturing |this| is fine because the TracingMuxer is a leaky singleton.
  task_runner_->PostTask([this, backend_type, session_id] {
    for (RegisteredBackend& backend : backends_) {
      if (backend_type && backend.type != backend_type)
        continue;

      backend.consumers.emplace_back(
          new ConsumerImpl(this, backend.id, session_id));
      auto& consumer = backend.consumers.back();
      TracingBackend::ConnectConsumerArgs conn_args;
      conn_args.consumer = consumer.get();
      conn_args.task_runner = task_runner_.get();
      consumer->Initialize(backend.backend->ConnectConsumer(conn_args));
      return;
    }
    PERFETTO_ELOG(
        "Cannot create tracing session, no tracing backend ready for type=%d",
        backend_type);
  });

  return std::unique_ptr<TracingSession>(
      new TracingSessionImpl(this, session_id));
}

void TracingMuxerImpl::InitializeInstance(const TracingInitArgs& args) {
  if (instance_)
    PERFETTO_FATAL("Tracing already initialized");
  instance_ = new TracingMuxerImpl(args);
}

TracingMuxer::~TracingMuxer() = default;

static_assert(std::is_same<internal::BufferId, BufferID>::value,
              "public's BufferId and tracing/core's BufferID diverged");

}  // namespace internal
}  // namespace perfetto
// gen_amalgamated begin source: src/tracing/platform.cc
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "perfetto/tracing/platform.h"
// gen_amalgamated expanded: #include "perfetto/tracing/internal/tracing_tls.h"
// gen_amalgamated expanded: #include "perfetto/tracing/trace_writer_base.h"

namespace perfetto {

PlatformThreadLocalObject::~PlatformThreadLocalObject() = default;
Platform::~Platform() = default;

// static
std::unique_ptr<PlatformThreadLocalObject>
PlatformThreadLocalObject::CreateInstance() {
  return std::unique_ptr<PlatformThreadLocalObject>(new internal::TracingTLS());
}

}  // namespace perfetto
// gen_amalgamated begin source: src/tracing/tracing.cc
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "perfetto/tracing/tracing.h"
// gen_amalgamated expanded: #include "src/tracing/internal/tracing_muxer_impl.h"

#include <condition_variable>
#include <mutex>

namespace perfetto {

// static
void Tracing::Initialize(const TracingInitArgs& args) {
  internal::TracingMuxerImpl::InitializeInstance(args);
}

//  static
std::unique_ptr<TracingSession> Tracing::NewTrace(BackendType backend) {
  return static_cast<internal::TracingMuxerImpl*>(internal::TracingMuxer::Get())
      ->CreateTracingSession(backend);
}

std::vector<char> TracingSession::ReadTraceBlocking() {
  std::vector<char> raw_trace;
  std::mutex mutex;
  std::condition_variable cv;
  bool all_read = false;

  ReadTrace([&mutex, &raw_trace, &all_read, &cv](ReadTraceCallbackArgs cb) {
    raw_trace.insert(raw_trace.end(), cb.data, cb.data + cb.size);
    std::unique_lock<std::mutex> lock(mutex);
    all_read = !cb.has_more;
    if (all_read)
      cv.notify_one();
  });

  {
    std::unique_lock<std::mutex> lock(mutex);
    cv.wait(lock, [&all_read] { return all_read; });
  }
  return raw_trace;
}

}  // namespace perfetto
// gen_amalgamated begin source: src/tracing/virtual_destructors.cc
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "perfetto/tracing/internal/tracing_tls.h"
// gen_amalgamated expanded: #include "perfetto/tracing/tracing.h"
// gen_amalgamated expanded: #include "perfetto/tracing/tracing_backend.h"

// This translation unit contains the definitions for the destructor of pure
// virtual interfaces for the src/public:public target. The alternative would be
// introducing a one-liner .cc file for each pure virtual interface, which is
// overkill. This is for compliance with -Wweak-vtables.

namespace perfetto {
namespace internal {

TracingTLS::~TracingTLS() = default;

}  // namespace internal

TracingBackend::~TracingBackend() = default;
TracingSession::~TracingSession() = default;

}  // namespace perfetto
// gen_amalgamated begin source: src/tracing/internal/system_tracing_backend.cc
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "src/tracing/internal/system_tracing_backend.h"

// gen_amalgamated expanded: #include "perfetto/base/logging.h"
// gen_amalgamated expanded: #include "perfetto/base/task_runner.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/core/tracing_service.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/ipc/default_socket.h"
// gen_amalgamated expanded: #include "perfetto/ext/tracing/ipc/producer_ipc_client.h"

namespace perfetto {
namespace internal {

// static
SystemTracingBackend* SystemTracingBackend::GetInstance() {
  static auto* instance = new SystemTracingBackend();
  return instance;
}

SystemTracingBackend::SystemTracingBackend() {}

std::unique_ptr<ProducerEndpoint> SystemTracingBackend::ConnectProducer(
    const ConnectProducerArgs& args) {
  PERFETTO_DCHECK(args.task_runner->RunsTasksOnCurrentThread());

  auto endpoint = ProducerIPCClient::Connect(
      GetProducerSocket(), args.producer, args.producer_name, args.task_runner,
      TracingService::ProducerSMBScrapingMode::kEnabled);
  PERFETTO_CHECK(endpoint);
  return endpoint;
}

std::unique_ptr<ConsumerEndpoint> SystemTracingBackend::ConnectConsumer(
    const ConnectConsumerArgs&) {
  PERFETTO_FATAL(
      "Trace session creation is not supported yet when using the system "
      "tracing backend. Use the perfetto cmdline client instead to start "
      "system-wide tracing sessions");
}

}  // namespace internal
}  // namespace perfetto
// gen_amalgamated begin source: src/tracing/platform_posix.cc
/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// gen_amalgamated expanded: #include "perfetto/base/build_config.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/file_utils.h"
// gen_amalgamated expanded: #include "perfetto/ext/base/thread_task_runner.h"
// gen_amalgamated expanded: #include "perfetto/tracing/internal/tracing_tls.h"
// gen_amalgamated expanded: #include "perfetto/tracing/platform.h"
// gen_amalgamated expanded: #include "perfetto/tracing/trace_writer_base.h"

#include <pthread.h>
#include <stdlib.h>

namespace perfetto {

namespace {

class PlatformPosix : public Platform {
 public:
  PlatformPosix();
  ~PlatformPosix() override;

  ThreadLocalObject* GetOrCreateThreadLocalObject() override;
  std::unique_ptr<base::TaskRunner> CreateTaskRunner(
      const CreateTaskRunnerArgs&) override;
  std::string GetCurrentProcessName() override;

 private:
  pthread_key_t tls_key_{};
};

// TODO(primiano): make base::ThreadTaskRunner directly inherit TaskRunner, so
// we can avoid this boilerplate.
class TaskRunnerInstance : public base::TaskRunner {
 public:
  TaskRunnerInstance();
  ~TaskRunnerInstance() override;

  void PostTask(std::function<void()>) override;
  void PostDelayedTask(std::function<void()>, uint32_t delay_ms) override;
  void AddFileDescriptorWatch(int fd, std::function<void()>) override;
  void RemoveFileDescriptorWatch(int fd) override;
  bool RunsTasksOnCurrentThread() const override;

 private:
  base::ThreadTaskRunner thread_task_runner_;
};

using ThreadLocalObject = Platform::ThreadLocalObject;

PlatformPosix::PlatformPosix() {
  auto tls_dtor = [](void* obj) {
    delete static_cast<ThreadLocalObject*>(obj);
  };
  PERFETTO_CHECK(pthread_key_create(&tls_key_, tls_dtor) == 0);
}

PlatformPosix::~PlatformPosix() {
  pthread_key_delete(tls_key_);
}

ThreadLocalObject* PlatformPosix::GetOrCreateThreadLocalObject() {
  // In chromium this should be implemented using base::ThreadLocalStorage.
  auto tls = static_cast<ThreadLocalObject*>(pthread_getspecific(tls_key_));
  if (!tls) {
    tls = ThreadLocalObject::CreateInstance().release();
    pthread_setspecific(tls_key_, tls);
  }
  return tls;
}

std::unique_ptr<base::TaskRunner> PlatformPosix::CreateTaskRunner(
    const CreateTaskRunnerArgs&) {
  return std::unique_ptr<base::TaskRunner>(new TaskRunnerInstance());
}

std::string PlatformPosix::GetCurrentProcessName() {
#if PERFETTO_BUILDFLAG(PERFETTO_OS_LINUX) || \
    PERFETTO_BUILDFLAG(PERFETTO_OS_ANDROID)
  std::string cmdline;
  base::ReadFile("/proc/self/cmdline", &cmdline);
  return cmdline.substr(0, cmdline.find('\0'));
#elif PERFETTO_BUILDFLAG(PERFETTO_OS_MACOSX)
  return std::string(getprogname());
#else
  return "unknown_producer";
#endif
}

TaskRunnerInstance::TaskRunnerInstance()
    : thread_task_runner_(base::ThreadTaskRunner::CreateAndStart()) {}
TaskRunnerInstance::~TaskRunnerInstance() = default;
void TaskRunnerInstance::PostTask(std::function<void()> func) {
  thread_task_runner_.get()->PostTask(func);
}

void TaskRunnerInstance::PostDelayedTask(std::function<void()> func,
                                         uint32_t delay_ms) {
  thread_task_runner_.get()->PostDelayedTask(func, delay_ms);
}

void TaskRunnerInstance::AddFileDescriptorWatch(int fd,
                                                std::function<void()> func) {
  thread_task_runner_.get()->AddFileDescriptorWatch(fd, func);
}

void TaskRunnerInstance::RemoveFileDescriptorWatch(int fd) {
  thread_task_runner_.get()->RemoveFileDescriptorWatch(fd);
}

bool TaskRunnerInstance::RunsTasksOnCurrentThread() const {
  return thread_task_runner_.get()->RunsTasksOnCurrentThread();
}

}  // namespace

// static
Platform* Platform::GetDefaultPlatform() {
  static PlatformPosix* instance = new PlatformPosix();
  return instance;
}

}  // namespace perfetto

